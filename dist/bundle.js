/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.tsx");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/fbjs/lib/EventListener.js":
/*!************************************************!*\
  !*** ./node_modules/fbjs/lib/EventListener.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var emptyFunction = __webpack_require__(/*! ./emptyFunction */ "./node_modules/fbjs/lib/emptyFunction.js");

/**
 * Upstream version of event listener. Does not take into account specific
 * nature of platform.
 */
var EventListener = {
  /**
   * Listen to DOM events during the bubble phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  listen: function listen(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function remove() {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  },

  /**
   * Listen to DOM events during the capture phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  capture: function capture(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, true);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, true);
        }
      };
    } else {
      if (true) {
        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
      }
      return {
        remove: emptyFunction
      };
    }
  },

  registerDefault: function registerDefault() {}
};

module.exports = EventListener;

/***/ }),

/***/ "./node_modules/fbjs/lib/ExecutionEnvironment.js":
/*!*******************************************************!*\
  !*** ./node_modules/fbjs/lib/ExecutionEnvironment.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

module.exports = ExecutionEnvironment;

/***/ }),

/***/ "./node_modules/fbjs/lib/camelize.js":
/*!*******************************************!*\
  !*** ./node_modules/fbjs/lib/camelize.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var _hyphenPattern = /-(.)/g;

/**
 * Camelcases a hyphenated string, for example:
 *
 *   > camelize('background-color')
 *   < "backgroundColor"
 *
 * @param {string} string
 * @return {string}
 */
function camelize(string) {
  return string.replace(_hyphenPattern, function (_, character) {
    return character.toUpperCase();
  });
}

module.exports = camelize;

/***/ }),

/***/ "./node_modules/fbjs/lib/camelizeStyleName.js":
/*!****************************************************!*\
  !*** ./node_modules/fbjs/lib/camelizeStyleName.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */



var camelize = __webpack_require__(/*! ./camelize */ "./node_modules/fbjs/lib/camelize.js");

var msPattern = /^-ms-/;

/**
 * Camelcases a hyphenated CSS property name, for example:
 *
 *   > camelizeStyleName('background-color')
 *   < "backgroundColor"
 *   > camelizeStyleName('-moz-transition')
 *   < "MozTransition"
 *   > camelizeStyleName('-ms-transition')
 *   < "msTransition"
 *
 * As Andi Smith suggests
 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
 * is converted to lowercase `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function camelizeStyleName(string) {
  return camelize(string.replace(msPattern, 'ms-'));
}

module.exports = camelizeStyleName;

/***/ }),

/***/ "./node_modules/fbjs/lib/containsNode.js":
/*!***********************************************!*\
  !*** ./node_modules/fbjs/lib/containsNode.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var isTextNode = __webpack_require__(/*! ./isTextNode */ "./node_modules/fbjs/lib/isTextNode.js");

/*eslint-disable no-bitwise */

/**
 * Checks if a given DOM node contains or is another DOM node.
 */
function containsNode(outerNode, innerNode) {
  if (!outerNode || !innerNode) {
    return false;
  } else if (outerNode === innerNode) {
    return true;
  } else if (isTextNode(outerNode)) {
    return false;
  } else if (isTextNode(innerNode)) {
    return containsNode(outerNode, innerNode.parentNode);
  } else if ('contains' in outerNode) {
    return outerNode.contains(innerNode);
  } else if (outerNode.compareDocumentPosition) {
    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
  } else {
    return false;
  }
}

module.exports = containsNode;

/***/ }),

/***/ "./node_modules/fbjs/lib/emptyFunction.js":
/*!************************************************!*\
  !*** ./node_modules/fbjs/lib/emptyFunction.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),

/***/ "./node_modules/fbjs/lib/emptyObject.js":
/*!**********************************************!*\
  !*** ./node_modules/fbjs/lib/emptyObject.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyObject = {};

if (true) {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;

/***/ }),

/***/ "./node_modules/fbjs/lib/focusNode.js":
/*!********************************************!*\
  !*** ./node_modules/fbjs/lib/focusNode.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * @param {DOMElement} node input/textarea to focus
 */

function focusNode(node) {
  // IE8 can throw "Can't move focus to the control because it is invisible,
  // not enabled, or of a type that does not accept the focus." for all kinds of
  // reasons that are too expensive and fragile to test.
  try {
    node.focus();
  } catch (e) {}
}

module.exports = focusNode;

/***/ }),

/***/ "./node_modules/fbjs/lib/getActiveElement.js":
/*!***************************************************!*\
  !*** ./node_modules/fbjs/lib/getActiveElement.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

/* eslint-disable fb-www/typeof-undefined */

/**
 * Same as document.activeElement but wraps in a try-catch block. In IE it is
 * not safe to call document.activeElement if there is nothing focused.
 *
 * The activeElement will be null only if the document or document body is not
 * yet defined.
 *
 * @param {?DOMDocument} doc Defaults to current document.
 * @return {?DOMElement}
 */
function getActiveElement(doc) /*?DOMElement*/{
  doc = doc || (typeof document !== 'undefined' ? document : undefined);
  if (typeof doc === 'undefined') {
    return null;
  }
  try {
    return doc.activeElement || doc.body;
  } catch (e) {
    return doc.body;
  }
}

module.exports = getActiveElement;

/***/ }),

/***/ "./node_modules/fbjs/lib/hyphenate.js":
/*!********************************************!*\
  !*** ./node_modules/fbjs/lib/hyphenate.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var _uppercasePattern = /([A-Z])/g;

/**
 * Hyphenates a camelcased string, for example:
 *
 *   > hyphenate('backgroundColor')
 *   < "background-color"
 *
 * For CSS style names, use `hyphenateStyleName` instead which works properly
 * with all vendor prefixes, including `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenate(string) {
  return string.replace(_uppercasePattern, '-$1').toLowerCase();
}

module.exports = hyphenate;

/***/ }),

/***/ "./node_modules/fbjs/lib/hyphenateStyleName.js":
/*!*****************************************************!*\
  !*** ./node_modules/fbjs/lib/hyphenateStyleName.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */



var hyphenate = __webpack_require__(/*! ./hyphenate */ "./node_modules/fbjs/lib/hyphenate.js");

var msPattern = /^ms-/;

/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenateStyleName(string) {
  return hyphenate(string).replace(msPattern, '-ms-');
}

module.exports = hyphenateStyleName;

/***/ }),

/***/ "./node_modules/fbjs/lib/invariant.js":
/*!********************************************!*\
  !*** ./node_modules/fbjs/lib/invariant.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (true) {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;

/***/ }),

/***/ "./node_modules/fbjs/lib/isNode.js":
/*!*****************************************!*\
  !*** ./node_modules/fbjs/lib/isNode.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM node.
 */
function isNode(object) {
  var doc = object ? object.ownerDocument || object : document;
  var defaultView = doc.defaultView || window;
  return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
}

module.exports = isNode;

/***/ }),

/***/ "./node_modules/fbjs/lib/isTextNode.js":
/*!*********************************************!*\
  !*** ./node_modules/fbjs/lib/isTextNode.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var isNode = __webpack_require__(/*! ./isNode */ "./node_modules/fbjs/lib/isNode.js");

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM text node.
 */
function isTextNode(object) {
  return isNode(object) && object.nodeType == 3;
}

module.exports = isTextNode;

/***/ }),

/***/ "./node_modules/fbjs/lib/shallowEqual.js":
/*!***********************************************!*\
  !*** ./node_modules/fbjs/lib/shallowEqual.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 * 
 */

/*eslint-disable no-self-compare */



var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
  // SameValue algorithm
  if (x === y) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    // Added the nonzero y check to make Flow happy, but it is redundant
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
  }
}

/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */
function shallowEqual(objA, objB) {
  if (is(objA, objB)) {
    return true;
  }

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

module.exports = shallowEqual;

/***/ }),

/***/ "./node_modules/fbjs/lib/warning.js":
/*!******************************************!*\
  !*** ./node_modules/fbjs/lib/warning.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyFunction = __webpack_require__(/*! ./emptyFunction */ "./node_modules/fbjs/lib/emptyFunction.js");

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (true) {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = warning;

/***/ }),

/***/ "./node_modules/free-style/dist/free-style.js":
/*!****************************************************!*\
  !*** ./node_modules/free-style/dist/free-style.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The unique id is used for unique hashes.
 */
var uniqueId = 0;
/**
 * Tag styles with this string to get unique hashes.
 */
exports.IS_UNIQUE = '__DO_NOT_DEDUPE_STYLE__';
var upperCasePattern = /[A-Z]/g;
var msPattern = /^ms-/;
var interpolatePattern = /&/g;
var escapePattern = /[ !#$%&()*+,./;<=>?@[\]^`{|}~"'\\]/g;
var propLower = function (m) { return "-" + m.toLowerCase(); };
/**
 * CSS properties that are valid unit-less numbers.
 */
var cssNumberProperties = [
    'animation-iteration-count',
    'box-flex',
    'box-flex-group',
    'column-count',
    'counter-increment',
    'counter-reset',
    'flex',
    'flex-grow',
    'flex-positive',
    'flex-shrink',
    'flex-negative',
    'font-weight',
    'line-clamp',
    'line-height',
    'opacity',
    'order',
    'orphans',
    'tab-size',
    'widows',
    'z-index',
    'zoom',
    // SVG properties.
    'fill-opacity',
    'stroke-dashoffset',
    'stroke-opacity',
    'stroke-width'
];
/**
 * Map of css number properties.
 */
var CSS_NUMBER = Object.create(null);
// Add vendor prefixes to all unit-less properties.
for (var _i = 0, _a = ['-webkit-', '-ms-', '-moz-', '-o-', '']; _i < _a.length; _i++) {
    var prefix = _a[_i];
    for (var _b = 0, cssNumberProperties_1 = cssNumberProperties; _b < cssNumberProperties_1.length; _b++) {
        var property = cssNumberProperties_1[_b];
        CSS_NUMBER[prefix + property] = true;
    }
}
/**
 * Escape a CSS class name.
 */
exports.escape = function (str) { return str.replace(escapePattern, '\\$&'); };
/**
 * Transform a JavaScript property into a CSS property.
 */
function hyphenate(propertyName) {
    return propertyName
        .replace(upperCasePattern, propLower)
        .replace(msPattern, '-ms-'); // Internet Explorer vendor prefix.
}
exports.hyphenate = hyphenate;
/**
 * Generate a hash value from a string.
 */
function stringHash(str) {
    var value = 5381;
    var len = str.length;
    while (len--)
        value = (value * 33) ^ str.charCodeAt(len);
    return (value >>> 0).toString(36);
}
exports.stringHash = stringHash;
/**
 * Transform a style string to a CSS string.
 */
function styleToString(key, value) {
    if (typeof value === 'number' && value !== 0 && !CSS_NUMBER[key]) {
        return key + ":" + value + "px";
    }
    return key + ":" + value;
}
/**
 * Sort an array of tuples by first value.
 */
function sortTuples(value) {
    return value.sort(function (a, b) { return a[0] > b[0] ? 1 : -1; });
}
/**
 * Categorize user styles.
 */
function parseStyles(styles, hasNestedStyles) {
    var properties = [];
    var nestedStyles = [];
    var isUnique = false;
    // Sort keys before adding to styles.
    for (var _i = 0, _a = Object.keys(styles); _i < _a.length; _i++) {
        var key = _a[_i];
        var value = styles[key];
        if (value !== null && value !== undefined) {
            if (key === exports.IS_UNIQUE) {
                isUnique = true;
            }
            else if (typeof value === 'object' && !Array.isArray(value)) {
                nestedStyles.push([key.trim(), value]);
            }
            else {
                properties.push([hyphenate(key.trim()), value]);
            }
        }
    }
    return {
        styleString: stringifyProperties(sortTuples(properties)),
        nestedStyles: hasNestedStyles ? nestedStyles : sortTuples(nestedStyles),
        isUnique: isUnique
    };
}
/**
 * Stringify an array of property tuples.
 */
function stringifyProperties(properties) {
    return properties.map(function (_a) {
        var name = _a[0], value = _a[1];
        if (!Array.isArray(value))
            return styleToString(name, value);
        return value.map(function (x) { return styleToString(name, x); }).join(';');
    }).join(';');
}
/**
 * Interpolate CSS selectors.
 */
function interpolate(selector, parent) {
    if (selector.indexOf('&') > -1) {
        return selector.replace(interpolatePattern, parent);
    }
    return parent + " " + selector;
}
/**
 * Recursive loop building styles with deferred selectors.
 */
function stylize(cache, selector, styles, list, parent) {
    var _a = parseStyles(styles, !!selector), styleString = _a.styleString, nestedStyles = _a.nestedStyles, isUnique = _a.isUnique;
    var pid = styleString;
    if (selector.charCodeAt(0) === 64 /* @ */) {
        var rule = cache.add(new Rule(selector, parent ? undefined : styleString, cache.hash));
        // Nested styles support (e.g. `.foo > @media > .bar`).
        if (styleString && parent) {
            var style = rule.add(new Style(styleString, rule.hash, isUnique ? "u" + (++uniqueId).toString(36) : undefined));
            list.push([parent, style]);
        }
        for (var _i = 0, nestedStyles_1 = nestedStyles; _i < nestedStyles_1.length; _i++) {
            var _b = nestedStyles_1[_i], name = _b[0], value = _b[1];
            pid += name + stylize(rule, name, value, list, parent);
        }
    }
    else {
        var key = parent ? interpolate(selector, parent) : selector;
        if (styleString) {
            var style = cache.add(new Style(styleString, cache.hash, isUnique ? "u" + (++uniqueId).toString(36) : undefined));
            list.push([key, style]);
        }
        for (var _c = 0, nestedStyles_2 = nestedStyles; _c < nestedStyles_2.length; _c++) {
            var _d = nestedStyles_2[_c], name = _d[0], value = _d[1];
            pid += name + stylize(cache, name, value, list, key);
        }
    }
    return pid;
}
/**
 * Register all styles, but collect for selector interpolation using the hash.
 */
function composeStyles(container, selector, styles, isStyle, displayName) {
    var cache = new Cache(container.hash);
    var list = [];
    var pid = stylize(cache, selector, styles, list);
    var hash = "f" + cache.hash(pid);
    var id = displayName ? displayName + "_" + hash : hash;
    for (var _i = 0, list_1 = list; _i < list_1.length; _i++) {
        var _a = list_1[_i], selector_1 = _a[0], style = _a[1];
        var key = isStyle ? interpolate(selector_1, "." + exports.escape(id)) : selector_1;
        style.add(new Selector(key, style.hash, undefined, pid));
    }
    return { cache: cache, pid: pid, id: id };
}
/**
 * Cache to list to styles.
 */
function join(arr) {
    var res = '';
    for (var i = 0; i < arr.length; i++)
        res += arr[i];
    return res;
}
/**
 * Noop changes.
 */
var noopChanges = {
    add: function () { return undefined; },
    change: function () { return undefined; },
    remove: function () { return undefined; }
};
/**
 * Implement a cache/event emitter.
 */
var Cache = /** @class */ (function () {
    function Cache(hash, changes) {
        if (hash === void 0) { hash = stringHash; }
        if (changes === void 0) { changes = noopChanges; }
        this.hash = hash;
        this.changes = changes;
        this.sheet = [];
        this.changeId = 0;
        this._keys = [];
        this._children = Object.create(null);
        this._counters = Object.create(null);
    }
    Cache.prototype.add = function (style) {
        var count = this._counters[style.id] || 0;
        var item = this._children[style.id] || style.clone();
        this._counters[style.id] = count + 1;
        if (count === 0) {
            this._children[item.id] = item;
            this._keys.push(item.id);
            this.sheet.push(item.getStyles());
            this.changeId++;
            this.changes.add(item, this._keys.length - 1);
        }
        else {
            // Check if contents are different.
            if (item.getIdentifier() !== style.getIdentifier()) {
                throw new TypeError("Hash collision: " + style.getStyles() + " === " + item.getStyles());
            }
            var oldIndex = this._keys.indexOf(style.id);
            var newIndex = this._keys.length - 1;
            var prevChangeId = this.changeId;
            if (oldIndex !== newIndex) {
                this._keys.splice(oldIndex, 1);
                this._keys.push(style.id);
                this.changeId++;
            }
            if (item instanceof Cache && style instanceof Cache) {
                var prevChangeId_1 = item.changeId;
                item.merge(style);
                if (item.changeId !== prevChangeId_1) {
                    this.changeId++;
                }
            }
            if (this.changeId !== prevChangeId) {
                if (oldIndex === newIndex) {
                    this.sheet.splice(oldIndex, 1, item.getStyles());
                }
                else {
                    this.sheet.splice(oldIndex, 1);
                    this.sheet.splice(newIndex, 0, item.getStyles());
                }
                this.changes.change(item, oldIndex, newIndex);
            }
        }
        return item;
    };
    Cache.prototype.remove = function (style) {
        var count = this._counters[style.id];
        if (count > 0) {
            this._counters[style.id] = count - 1;
            var item = this._children[style.id];
            var index = this._keys.indexOf(item.id);
            if (count === 1) {
                delete this._counters[style.id];
                delete this._children[style.id];
                this._keys.splice(index, 1);
                this.sheet.splice(index, 1);
                this.changeId++;
                this.changes.remove(item, index);
            }
            else if (item instanceof Cache && style instanceof Cache) {
                var prevChangeId = item.changeId;
                item.unmerge(style);
                if (item.changeId !== prevChangeId) {
                    this.sheet.splice(index, 1, item.getStyles());
                    this.changeId++;
                    this.changes.change(item, index, index);
                }
            }
        }
    };
    Cache.prototype.merge = function (cache) {
        for (var _i = 0, _a = cache._keys; _i < _a.length; _i++) {
            var id = _a[_i];
            this.add(cache._children[id]);
        }
        return this;
    };
    Cache.prototype.unmerge = function (cache) {
        for (var _i = 0, _a = cache._keys; _i < _a.length; _i++) {
            var id = _a[_i];
            this.remove(cache._children[id]);
        }
        return this;
    };
    Cache.prototype.clone = function () {
        return new Cache(this.hash).merge(this);
    };
    return Cache;
}());
exports.Cache = Cache;
/**
 * Selector is a dumb class made to represent nested CSS selectors.
 */
var Selector = /** @class */ (function () {
    function Selector(selector, hash, id, pid) {
        if (id === void 0) { id = "s" + hash(selector); }
        if (pid === void 0) { pid = ''; }
        this.selector = selector;
        this.hash = hash;
        this.id = id;
        this.pid = pid;
    }
    Selector.prototype.getStyles = function () {
        return this.selector;
    };
    Selector.prototype.getIdentifier = function () {
        return this.pid + "." + this.selector;
    };
    Selector.prototype.clone = function () {
        return new Selector(this.selector, this.hash, this.id, this.pid);
    };
    return Selector;
}());
exports.Selector = Selector;
/**
 * The style container registers a style string with selectors.
 */
var Style = /** @class */ (function (_super) {
    __extends(Style, _super);
    function Style(style, hash, id) {
        if (id === void 0) { id = "c" + hash(style); }
        var _this = _super.call(this, hash) || this;
        _this.style = style;
        _this.hash = hash;
        _this.id = id;
        return _this;
    }
    Style.prototype.getStyles = function () {
        return this.sheet.join(',') + "{" + this.style + "}";
    };
    Style.prototype.getIdentifier = function () {
        return this.style;
    };
    Style.prototype.clone = function () {
        return new Style(this.style, this.hash, this.id).merge(this);
    };
    return Style;
}(Cache));
exports.Style = Style;
/**
 * Implement rule logic for style output.
 */
var Rule = /** @class */ (function (_super) {
    __extends(Rule, _super);
    function Rule(rule, style, hash, id, pid) {
        if (style === void 0) { style = ''; }
        if (id === void 0) { id = "a" + hash(rule + "." + style); }
        if (pid === void 0) { pid = ''; }
        var _this = _super.call(this, hash) || this;
        _this.rule = rule;
        _this.style = style;
        _this.hash = hash;
        _this.id = id;
        _this.pid = pid;
        return _this;
    }
    Rule.prototype.getStyles = function () {
        return this.rule + "{" + this.style + join(this.sheet) + "}";
    };
    Rule.prototype.getIdentifier = function () {
        return this.pid + "." + this.rule + "." + this.style;
    };
    Rule.prototype.clone = function () {
        return new Rule(this.rule, this.style, this.hash, this.id, this.pid).merge(this);
    };
    return Rule;
}(Cache));
exports.Rule = Rule;
/**
 * The FreeStyle class implements the API for everything else.
 */
var FreeStyle = /** @class */ (function (_super) {
    __extends(FreeStyle, _super);
    function FreeStyle(hash, debug, id, changes) {
        if (hash === void 0) { hash = stringHash; }
        if (debug === void 0) { debug = typeof process !== 'undefined' && "development" !== 'production'; }
        if (id === void 0) { id = "f" + (++uniqueId).toString(36); }
        var _this = _super.call(this, hash, changes) || this;
        _this.hash = hash;
        _this.debug = debug;
        _this.id = id;
        return _this;
    }
    FreeStyle.prototype.registerStyle = function (styles, displayName) {
        var debugName = this.debug ? displayName : undefined;
        var _a = composeStyles(this, '&', styles, true, debugName), cache = _a.cache, id = _a.id;
        this.merge(cache);
        return id;
    };
    FreeStyle.prototype.registerKeyframes = function (keyframes, displayName) {
        return this.registerHashRule('@keyframes', keyframes, displayName);
    };
    FreeStyle.prototype.registerHashRule = function (prefix, styles, displayName) {
        var debugName = this.debug ? displayName : undefined;
        var _a = composeStyles(this, '', styles, false, debugName), cache = _a.cache, pid = _a.pid, id = _a.id;
        var rule = new Rule(prefix + " " + exports.escape(id), undefined, this.hash, undefined, pid);
        this.add(rule.merge(cache));
        return id;
    };
    FreeStyle.prototype.registerRule = function (rule, styles) {
        this.merge(composeStyles(this, rule, styles, false).cache);
    };
    FreeStyle.prototype.registerCss = function (styles) {
        this.merge(composeStyles(this, '', styles, false).cache);
    };
    FreeStyle.prototype.getStyles = function () {
        return join(this.sheet);
    };
    FreeStyle.prototype.getIdentifier = function () {
        return this.id;
    };
    FreeStyle.prototype.clone = function () {
        return new FreeStyle(this.hash, this.debug, this.id, this.changes).merge(this);
    };
    return FreeStyle;
}(Cache));
exports.FreeStyle = FreeStyle;
/**
 * Exports a simple function to create a new instance.
 */
function create(hash, debug, changes) {
    return new FreeStyle(hash, debug, undefined, changes);
}
exports.create = create;
//# sourceMappingURL=free-style.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/mobx-react/index.module.js":
/*!*************************************************!*\
  !*** ./node_modules/mobx-react/index.module.js ***!
  \*************************************************/
/*! exports provided: propTypes, PropTypes, onError, observer, Observer, renderReporter, componentByNodeRegistery, trackComponents, useStaticRendering, Provider, inject */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "propTypes", function() { return propTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PropTypes", function() { return propTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onError", function() { return onError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "observer", function() { return observer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Observer", function() { return Observer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderReporter", function() { return renderReporter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "componentByNodeRegistery", function() { return componentByNodeRegistery; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trackComponents", function() { return trackComponents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useStaticRendering", function() { return useStaticRendering; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Provider", function() { return Provider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inject", function() { return inject; });
/* harmony import */ var mobx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mobx */ "./node_modules/mobx/lib/mobx.module.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_2__);




// These functions can be stubbed out in specific environments
var unstable_batchedUpdates$1 = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};





var asyncGenerator = function () {
  function AwaitValue(value) {
    this.value = value;
  }

  function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;

        if (value instanceof AwaitValue) {
          Promise.resolve(value.value).then(function (arg) {
            resume("next", arg);
          }, function (arg) {
            resume("throw", arg);
          });
        } else {
          settle(result.done ? "return" : "normal", result.value);
        }
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value: value,
            done: true
          });
          break;

        case "throw":
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };

  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };

  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };

  return {
    wrap: function (fn) {
      return function () {
        return new AsyncGenerator(fn.apply(this, arguments));
      };
    },
    await: function (value) {
      return new AwaitValue(value);
    }
  };
}();





var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();









var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var EventEmitter = function () {
    function EventEmitter() {
        classCallCheck(this, EventEmitter);
        this.listeners = [];
    }

    createClass(EventEmitter, [{
        key: "on",
        value: function on(cb) {
            var _this = this;

            this.listeners.push(cb);
            return function () {
                var index = _this.listeners.indexOf(cb);
                if (index !== -1) _this.listeners.splice(index, 1);
            };
        }
    }, {
        key: "emit",
        value: function emit(data) {
            this.listeners.forEach(function (fn) {
                return fn(data);
            });
        }
    }]);
    return EventEmitter;
}();

/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
'use strict';

var REACT_STATICS = {
    childContextTypes: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    mixins: true,
    propTypes: true,
    type: true
};

var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};

var defineProperty$1 = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = getPrototypeOf && getPrototypeOf(Object);

var hoistNonReactStatics = function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components

        if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
            }
        }

        var keys = getOwnPropertyNames(sourceComponent);

        if (getOwnPropertySymbols) {
            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }

        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {
                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                try { // Avoid failures from read-only properties
                    defineProperty$1(targetComponent, key, descriptor);
                } catch (e) {}
            }
        }

        return targetComponent;
    }

    return targetComponent;
};

// Copied from React.PropTypes
function createChainableTypeChecker(validate) {
    function checkType(isRequired, props, propName, componentName, location, propFullName) {
        for (var _len = arguments.length, rest = Array(_len > 6 ? _len - 6 : 0), _key = 6; _key < _len; _key++) {
            rest[_key - 6] = arguments[_key];
        }

        return Object(mobx__WEBPACK_IMPORTED_MODULE_0__["untracked"])(function () {
            componentName = componentName || "<<anonymous>>";
            propFullName = propFullName || propName;
            if (props[propName] == null) {
                if (isRequired) {
                    var actual = props[propName] === null ? "null" : "undefined";
                    return new Error("The " + location + " `" + propFullName + "` is marked as required " + "in `" + componentName + "`, but its value is `" + actual + "`.");
                }
                return null;
            } else {
                return validate.apply(undefined, [props, propName, componentName, location, propFullName].concat(rest));
            }
        });
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);
    return chainedCheckType;
}

// Copied from React.PropTypes
function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === "symbol") {
        return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue["@@toStringTag"] === "Symbol") {
        return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === "function" && propValue instanceof Symbol) {
        return true;
    }

    return false;
}

// Copied from React.PropTypes
function getPropType(propValue) {
    var propType = typeof propValue === "undefined" ? "undefined" : _typeof(propValue);
    if (Array.isArray(propValue)) {
        return "array";
    }
    if (propValue instanceof RegExp) {
        // Old webkits (at least until Android 4.0) return 'function' rather than
        // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
        // passes PropTypes.object.
        return "object";
    }
    if (isSymbol(propType, propValue)) {
        return "symbol";
    }
    return propType;
}

// This handles more types than `getPropType`. Only used for error messages.
// Copied from React.PropTypes
function getPreciseType(propValue) {
    var propType = getPropType(propValue);
    if (propType === "object") {
        if (propValue instanceof Date) {
            return "date";
        } else if (propValue instanceof RegExp) {
            return "regexp";
        }
    }
    return propType;
}

function createObservableTypeCheckerCreator(allowNativeType, mobxType) {
    return createChainableTypeChecker(function (props, propName, componentName, location, propFullName) {
        return Object(mobx__WEBPACK_IMPORTED_MODULE_0__["untracked"])(function () {
            if (allowNativeType) {
                if (getPropType(props[propName]) === mobxType.toLowerCase()) return null;
            }
            var mobxChecker = void 0;
            switch (mobxType) {
                case "Array":
                    mobxChecker = mobx__WEBPACK_IMPORTED_MODULE_0__["isObservableArray"];
                    break;
                case "Object":
                    mobxChecker = mobx__WEBPACK_IMPORTED_MODULE_0__["isObservableObject"];
                    break;
                case "Map":
                    mobxChecker = mobx__WEBPACK_IMPORTED_MODULE_0__["isObservableMap"];
                    break;
                default:
                    throw new Error("Unexpected mobxType: " + mobxType);
            }
            var propValue = props[propName];
            if (!mobxChecker(propValue)) {
                var preciseType = getPreciseType(propValue);
                var nativeTypeExpectationMessage = allowNativeType ? " or javascript `" + mobxType.toLowerCase() + "`" : "";
                return new Error("Invalid prop `" + propFullName + "` of type `" + preciseType + "` supplied to" + " `" + componentName + "`, expected `mobx.Observable" + mobxType + "`" + nativeTypeExpectationMessage + ".");
            }
            return null;
        });
    });
}

function createObservableArrayOfTypeChecker(allowNativeType, typeChecker) {
    return createChainableTypeChecker(function (props, propName, componentName, location, propFullName) {
        for (var _len2 = arguments.length, rest = Array(_len2 > 5 ? _len2 - 5 : 0), _key2 = 5; _key2 < _len2; _key2++) {
            rest[_key2 - 5] = arguments[_key2];
        }

        return Object(mobx__WEBPACK_IMPORTED_MODULE_0__["untracked"])(function () {
            if (typeof typeChecker !== "function") {
                return new Error("Property `" + propFullName + "` of component `" + componentName + "` has " + "invalid PropType notation.");
            }
            var error = createObservableTypeCheckerCreator(allowNativeType, "Array")(props, propName, componentName);
            if (error instanceof Error) return error;
            var propValue = props[propName];
            for (var i = 0; i < propValue.length; i++) {
                error = typeChecker.apply(undefined, [propValue, i, componentName, location, propFullName + "[" + i + "]"].concat(rest));
                if (error instanceof Error) return error;
            }
            return null;
        });
    });
}

var observableArray = createObservableTypeCheckerCreator(false, "Array");
var observableArrayOf = createObservableArrayOfTypeChecker.bind(null, false);
var observableMap = createObservableTypeCheckerCreator(false, "Map");
var observableObject = createObservableTypeCheckerCreator(false, "Object");
var arrayOrObservableArray = createObservableTypeCheckerCreator(true, "Array");
var arrayOrObservableArrayOf = createObservableArrayOfTypeChecker.bind(null, true);
var objectOrObservableObject = createObservableTypeCheckerCreator(true, "Object");



var propTypes = Object.freeze({
	observableArray: observableArray,
	observableArrayOf: observableArrayOf,
	observableMap: observableMap,
	observableObject: observableObject,
	arrayOrObservableArray: arrayOrObservableArray,
	arrayOrObservableArrayOf: arrayOrObservableArrayOf,
	objectOrObservableObject: objectOrObservableObject
});

function isStateless(component) {
    // `function() {}` has prototype, but `() => {}` doesn't
    // `() => {}` via Babel has prototype too.
    return !(component.prototype && component.prototype.render);
}

var injectorContextTypes = {
    mobxStores: objectOrObservableObject
};
Object.seal(injectorContextTypes);

var proxiedInjectorProps = {
    contextTypes: {
        get: function get$$1() {
            return injectorContextTypes;
        },
        set: function set$$1(_) {
            console.warn("Mobx Injector: you are trying to attach `contextTypes` on an component decorated with `inject` (or `observer`) HOC. Please specify the contextTypes on the wrapped component instead. It is accessible through the `wrappedComponent`");
        },
        configurable: true,
        enumerable: false
    },
    isMobxInjector: {
        value: true,
        writable: true,
        configurable: true,
        enumerable: true
    }

    /**
     * Store Injection
     */
};function createStoreInjector(grabStoresFn, component, injectNames) {
    var _class, _temp2;

    var displayName = "inject-" + (component.displayName || component.name || component.constructor && component.constructor.name || "Unknown");
    if (injectNames) displayName += "-with-" + injectNames;

    var Injector = (_temp2 = _class = function (_Component) {
        inherits(Injector, _Component);

        function Injector() {
            var _ref;

            var _temp, _this, _ret;

            classCallCheck(this, Injector);

            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Injector.__proto__ || Object.getPrototypeOf(Injector)).call.apply(_ref, [this].concat(args))), _this), _this.storeRef = function (instance) {
                _this.wrappedInstance = instance;
            }, _temp), possibleConstructorReturn(_this, _ret);
        }

        createClass(Injector, [{
            key: "render",
            value: function render() {
                // Optimization: it might be more efficient to apply the mapper function *outside* the render method
                // (if the mapper is a function), that could avoid expensive(?) re-rendering of the injector component
                // See this test: 'using a custom injector is not too reactive' in inject.js
                var newProps = {};
                for (var key in this.props) {
                    if (this.props.hasOwnProperty(key)) {
                        newProps[key] = this.props[key];
                    }
                }var additionalProps = grabStoresFn(this.context.mobxStores || {}, newProps, this.context) || {};
                for (var _key2 in additionalProps) {
                    newProps[_key2] = additionalProps[_key2];
                }

                if (!isStateless(component)) {
                    newProps.ref = this.storeRef;
                }

                return Object(react__WEBPACK_IMPORTED_MODULE_1__["createElement"])(component, newProps);
            }
        }]);
        return Injector;
    }(react__WEBPACK_IMPORTED_MODULE_1__["Component"]), _class.displayName = displayName, _temp2);

    // Static fields from component should be visible on the generated Injector

    hoistNonReactStatics(Injector, component);

    Injector.wrappedComponent = component;
    Object.defineProperties(Injector, proxiedInjectorProps);

    return Injector;
}

function grabStoresByName(storeNames) {
    return function (baseStores, nextProps) {
        storeNames.forEach(function (storeName) {
            if (storeName in nextProps // prefer props over stores
            ) return;
            if (!(storeName in baseStores)) throw new Error("MobX injector: Store '" + storeName + "' is not available! Make sure it is provided by some Provider");
            nextProps[storeName] = baseStores[storeName];
        });
        return nextProps;
    };
}

/**
 * higher order component that injects stores to a child.
 * takes either a varargs list of strings, which are stores read from the context,
 * or a function that manually maps the available stores from the context to props:
 * storesToProps(mobxStores, props, context) => newProps
 */
function inject() /* fn(stores, nextProps) or ...storeNames */{
    var grabStoresFn = void 0;
    if (typeof arguments[0] === "function") {
        grabStoresFn = arguments[0];
        return function (componentClass) {
            var injected = createStoreInjector(grabStoresFn, componentClass);
            injected.isMobxInjector = false; // supress warning
            // mark the Injector as observer, to make it react to expressions in `grabStoresFn`,
            // see #111
            injected = observer(injected);
            injected.isMobxInjector = true; // restore warning
            return injected;
        };
    } else {
        var storeNames = [];
        for (var i = 0; i < arguments.length; i++) {
            storeNames[i] = arguments[i];
        }grabStoresFn = grabStoresByName(storeNames);
        return function (componentClass) {
            return createStoreInjector(grabStoresFn, componentClass, storeNames.join("-"));
        };
    }
}

/**
 * dev tool support
 */
var isDevtoolsEnabled = false;

var isUsingStaticRendering = false;

var warnedAboutObserverInjectDeprecation = false;

// WeakMap<Node, Object>;
var componentByNodeRegistery = typeof WeakMap !== "undefined" ? new WeakMap() : undefined;
var renderReporter = new EventEmitter();

function findDOMNode$2(component) {
    if (react_dom__WEBPACK_IMPORTED_MODULE_2__["findDOMNode"]) {
        try {
            return Object(react_dom__WEBPACK_IMPORTED_MODULE_2__["findDOMNode"])(component);
        } catch (e) {
            // findDOMNode will throw in react-test-renderer, see:
            // See https://github.com/mobxjs/mobx-react/issues/216
            // Is there a better heuristic?
            return null;
        }
    }
    return null;
}

function reportRendering(component) {
    var node = findDOMNode$2(component);
    if (node && componentByNodeRegistery) componentByNodeRegistery.set(node, component);

    renderReporter.emit({
        event: "render",
        renderTime: component.__$mobRenderEnd - component.__$mobRenderStart,
        totalTime: Date.now() - component.__$mobRenderStart,
        component: component,
        node: node
    });
}

function trackComponents() {
    if (typeof WeakMap === "undefined") throw new Error("[mobx-react] tracking components is not supported in this browser.");
    if (!isDevtoolsEnabled) isDevtoolsEnabled = true;
}

function useStaticRendering(useStaticRendering) {
    isUsingStaticRendering = useStaticRendering;
}

/**
 * Errors reporter
 */

var errorsReporter = new EventEmitter();

/**
 * Utilities
 */

function patch(target, funcName) {
    var runMixinFirst = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    var base = target[funcName];
    var mixinFunc = reactiveMixin[funcName];
    var f = !base ? mixinFunc : runMixinFirst === true ? function () {
        mixinFunc.apply(this, arguments);
        base.apply(this, arguments);
    } : function () {
        base.apply(this, arguments);
        mixinFunc.apply(this, arguments);
    };

    // MWE: ideally we freeze here to protect against accidental overwrites in component instances, see #195
    // ...but that breaks react-hot-loader, see #231...
    target[funcName] = f;
}

function shallowEqual(objA, objB) {
    //From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js
    if (is(objA, objB)) return true;
    if ((typeof objA === "undefined" ? "undefined" : _typeof(objA)) !== "object" || objA === null || (typeof objB === "undefined" ? "undefined" : _typeof(objB)) !== "object" || objB === null) {
        return false;
    }
    var keysA = Object.keys(objA);
    var keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) return false;
    for (var i = 0; i < keysA.length; i++) {
        if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
            return false;
        }
    }
    return true;
}

function is(x, y) {
    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js
    if (x === y) {
        return x !== 0 || 1 / x === 1 / y;
    } else {
        return x !== x && y !== y;
    }
}

/**
 * ReactiveMixin
 */
var reactiveMixin = {
    componentWillMount: function componentWillMount() {
        var _this = this;

        if (isUsingStaticRendering === true) return;
        // Generate friendly name for debugging
        var initialName = this.displayName || this.name || this.constructor && (this.constructor.displayName || this.constructor.name) || "<component>";
        var rootNodeID = this._reactInternalInstance && this._reactInternalInstance._rootNodeID || this._reactInternalFiber && this._reactInternalFiber._debugID;

        /**
         * If props are shallowly modified, react will render anyway,
         * so atom.reportChanged() should not result in yet another re-render
         */
        var skipRender = false;
        /**
         * forceUpdate will re-assign this.props. We don't want that to cause a loop,
         * so detect these changes
         */
        var isForcingUpdate = false;

        function makePropertyObservableReference(propName) {
            var valueHolder = this[propName];
            var atom = new mobx__WEBPACK_IMPORTED_MODULE_0__["Atom"]("reactive " + propName);
            Object.defineProperty(this, propName, {
                configurable: true,
                enumerable: true,
                get: function get$$1() {
                    atom.reportObserved();
                    return valueHolder;
                },
                set: function set$$1(v) {
                    if (!isForcingUpdate && !shallowEqual(valueHolder, v)) {
                        valueHolder = v;
                        skipRender = true;
                        atom.reportChanged();
                        skipRender = false;
                    } else {
                        valueHolder = v;
                    }
                }
            });
        }

        // make this.props an observable reference, see #124
        makePropertyObservableReference.call(this, "props");
        // make state an observable reference
        makePropertyObservableReference.call(this, "state");

        // wire up reactive render
        var baseRender = this.render.bind(this);
        var reaction = null;
        var isRenderingPending = false;

        var initialRender = function initialRender() {
            reaction = new mobx__WEBPACK_IMPORTED_MODULE_0__["Reaction"](initialName + "#" + rootNodeID + ".render()", function () {
                if (!isRenderingPending) {
                    // N.B. Getting here *before mounting* means that a component constructor has side effects (see the relevant test in misc.js)
                    // This unidiomatic React usage but React will correctly warn about this so we continue as usual
                    // See #85 / Pull #44
                    isRenderingPending = true;
                    if (typeof _this.componentWillReact === "function") _this.componentWillReact(); // TODO: wrap in action?
                    if (_this.__$mobxIsUnmounted !== true) {
                        // If we are unmounted at this point, componentWillReact() had a side effect causing the component to unmounted
                        // TODO: remove this check? Then react will properly warn about the fact that this should not happen? See #73
                        // However, people also claim this migth happen during unit tests..
                        var hasError = true;
                        try {
                            isForcingUpdate = true;
                            if (!skipRender) react__WEBPACK_IMPORTED_MODULE_1__["Component"].prototype.forceUpdate.call(_this);
                            hasError = false;
                        } finally {
                            isForcingUpdate = false;
                            if (hasError) reaction.dispose();
                        }
                    }
                }
            });
            reaction.reactComponent = _this;
            reactiveRender.$mobx = reaction;
            _this.render = reactiveRender;
            return reactiveRender();
        };

        var reactiveRender = function reactiveRender() {
            isRenderingPending = false;
            var exception = undefined;
            var rendering = undefined;
            reaction.track(function () {
                if (isDevtoolsEnabled) {
                    _this.__$mobRenderStart = Date.now();
                }
                try {
                    rendering = mobx__WEBPACK_IMPORTED_MODULE_0__["extras"].allowStateChanges(false, baseRender);
                } catch (e) {
                    exception = e;
                }
                if (isDevtoolsEnabled) {
                    _this.__$mobRenderEnd = Date.now();
                }
            });
            if (exception) {
                errorsReporter.emit(exception);
                throw exception;
            }
            return rendering;
        };

        this.render = initialRender;
    },

    componentWillUnmount: function componentWillUnmount() {
        if (isUsingStaticRendering === true) return;
        this.render.$mobx && this.render.$mobx.dispose();
        this.__$mobxIsUnmounted = true;
        if (isDevtoolsEnabled) {
            var node = findDOMNode$2(this);
            if (node && componentByNodeRegistery) {
                componentByNodeRegistery.delete(node);
            }
            renderReporter.emit({
                event: "destroy",
                component: this,
                node: node
            });
        }
    },

    componentDidMount: function componentDidMount() {
        if (isDevtoolsEnabled) {
            reportRendering(this);
        }
    },

    componentDidUpdate: function componentDidUpdate() {
        if (isDevtoolsEnabled) {
            reportRendering(this);
        }
    },

    shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
        if (isUsingStaticRendering) {
            console.warn("[mobx-react] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side.");
        }
        // update on any state changes (as is the default)
        if (this.state !== nextState) {
            return true;
        }
        // update if props are shallowly not equal, inspired by PureRenderMixin
        // we could return just 'false' here, and avoid the `skipRender` checks etc
        // however, it is nicer if lifecycle events are triggered like usually,
        // so we return true here if props are shallowly modified.
        return !shallowEqual(this.props, nextProps);
    }

    /**
     * Observer function / decorator
     */
};function observer(arg1, arg2) {
    if (typeof arg1 === "string") {
        throw new Error("Store names should be provided as array");
    }
    if (Array.isArray(arg1)) {
        // component needs stores
        if (!warnedAboutObserverInjectDeprecation) {
            warnedAboutObserverInjectDeprecation = true;
            console.warn('Mobx observer: Using observer to inject stores is deprecated since 4.0. Use `@inject("store1", "store2") @observer ComponentClass` or `inject("store1", "store2")(observer(componentClass))` instead of `@observer(["store1", "store2"]) ComponentClass`');
        }
        if (!arg2) {
            // invoked as decorator
            return function (componentClass) {
                return observer(arg1, componentClass);
            };
        } else {
            return inject.apply(null, arg1)(observer(arg2));
        }
    }
    var componentClass = arg1;

    if (componentClass.isMobxInjector === true) {
        console.warn("Mobx observer: You are trying to use 'observer' on a component that already has 'inject'. Please apply 'observer' before applying 'inject'");
    }

    // Stateless function component:
    // If it is function but doesn't seem to be a react class constructor,
    // wrap it to a react class automatically
    if (typeof componentClass === "function" && (!componentClass.prototype || !componentClass.prototype.render) && !componentClass.isReactClass && !react__WEBPACK_IMPORTED_MODULE_1__["Component"].isPrototypeOf(componentClass)) {
        var _class, _temp;

        return observer((_temp = _class = function (_Component) {
            inherits(_class, _Component);

            function _class() {
                classCallCheck(this, _class);
                return possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
            }

            createClass(_class, [{
                key: "render",
                value: function render() {
                    return componentClass.call(this, this.props, this.context);
                }
            }]);
            return _class;
        }(react__WEBPACK_IMPORTED_MODULE_1__["Component"]), _class.displayName = componentClass.displayName || componentClass.name, _class.contextTypes = componentClass.contextTypes, _class.propTypes = componentClass.propTypes, _class.defaultProps = componentClass.defaultProps, _temp));
    }

    if (!componentClass) {
        throw new Error("Please pass a valid component to 'observer'");
    }

    var target = componentClass.prototype || componentClass;
    mixinLifecycleEvents(target);
    componentClass.isMobXReactObserver = true;
    return componentClass;
}

function mixinLifecycleEvents(target) {
    patch(target, "componentWillMount", true);["componentDidMount", "componentWillUnmount", "componentDidUpdate"].forEach(function (funcName) {
        patch(target, funcName);
    });
    if (!target.shouldComponentUpdate) {
        target.shouldComponentUpdate = reactiveMixin.shouldComponentUpdate;
    }
}

// TODO: support injection somehow as well?
var Observer = observer(function (_ref) {
    var children = _ref.children,
        observerInject = _ref.inject,
        render = _ref.render;

    var component = children || render;
    if (typeof component === "undefined") {
        return null;
    }
    if (!observerInject) {
        return component();
    }
    var InjectComponent = inject(observerInject)(component);
    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(InjectComponent, null);
});

Observer.displayName = "Observer";

var ObserverPropsCheck = function ObserverPropsCheck(props, key, componentName, location, propFullName) {
    var extraKey = key === "children" ? "render" : "children";
    if (typeof props[key] === "function" && typeof props[extraKey] === "function") {
        return new Error("Invalid prop,do not use children and render in the same time in`" + componentName);
    }

    if (typeof props[key] === "function" || typeof props[extraKey] === "function") {
        return;
    }
    return new Error("Invalid prop `" + propFullName + "` of type `" + _typeof(props[key]) + "` supplied to" + " `" + componentName + "`, expected `function`.");
};

Observer.propTypes = {
    render: ObserverPropsCheck,
    children: ObserverPropsCheck
};

var _class;
var _temp;

var specialReactKeys = { children: true, key: true, ref: true };

var Provider = (_temp = _class = function (_Component) {
    inherits(Provider, _Component);

    function Provider() {
        classCallCheck(this, Provider);
        return possibleConstructorReturn(this, (Provider.__proto__ || Object.getPrototypeOf(Provider)).apply(this, arguments));
    }

    createClass(Provider, [{
        key: "render",
        value: function render() {
            return react__WEBPACK_IMPORTED_MODULE_1__["Children"].only(this.props.children);
        }
    }, {
        key: "getChildContext",
        value: function getChildContext() {
            var stores = {};
            // inherit stores
            var baseStores = this.context.mobxStores;
            if (baseStores) for (var key in baseStores) {
                stores[key] = baseStores[key];
            }
            // add own stores
            for (var _key in this.props) {
                if (!specialReactKeys[_key] && _key !== "suppressChangedStoreWarning") stores[_key] = this.props[_key];
            }return {
                mobxStores: stores
            };
        }
    }, {
        key: "componentWillReceiveProps",
        value: function componentWillReceiveProps(nextProps) {
            // Maybe this warning is too aggressive?
            if (Object.keys(nextProps).length !== Object.keys(this.props).length) console.warn("MobX Provider: The set of provided stores has changed. Please avoid changing stores as the change might not propagate to all children");
            if (!nextProps.suppressChangedStoreWarning) for (var key in nextProps) {
                if (!specialReactKeys[key] && this.props[key] !== nextProps[key]) console.warn("MobX Provider: Provided store '" + key + "' has changed. Please avoid replacing stores as the change might not propagate to all children");
            }
        }
    }]);
    return Provider;
}(react__WEBPACK_IMPORTED_MODULE_1__["Component"]), _class.contextTypes = {
    mobxStores: objectOrObservableObject
}, _class.childContextTypes = {
    mobxStores: objectOrObservableObject.isRequired
}, _temp);

if (!react__WEBPACK_IMPORTED_MODULE_1__["Component"]) throw new Error("mobx-react requires React to be available");
if (!mobx__WEBPACK_IMPORTED_MODULE_0__["extras"]) throw new Error("mobx-react requires mobx to be available");

if (typeof react_dom__WEBPACK_IMPORTED_MODULE_2__["unstable_batchedUpdates"] === "function") mobx__WEBPACK_IMPORTED_MODULE_0__["extras"].setReactionScheduler(react_dom__WEBPACK_IMPORTED_MODULE_2__["unstable_batchedUpdates"]);else if (typeof unstable_batchedUpdates$1 === "function") mobx__WEBPACK_IMPORTED_MODULE_0__["extras"].setReactionScheduler(unstable_batchedUpdates$1);

var onError = function onError(fn) {
    return errorsReporter.on(fn);
};

/* DevTool support */
// See: https://github.com/andykog/mobx-devtools/blob/d8976c24b8cb727ed59f9a0bc905a009df79e221/src/backend/installGlobalHook.js

if ((typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === "undefined" ? "undefined" : _typeof(__MOBX_DEVTOOLS_GLOBAL_HOOK__)) === "object") {
    var mobx$1 = { spy: mobx__WEBPACK_IMPORTED_MODULE_0__["spy"], extras: mobx__WEBPACK_IMPORTED_MODULE_0__["extras"] };
    var mobxReact = { renderReporter: renderReporter, componentByNodeRegistery: componentByNodeRegistery, trackComponents: trackComponents };
    __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobxReact(mobxReact, mobx$1);
}




/***/ }),

/***/ "./node_modules/mobx/lib/mobx.module.js":
/*!**********************************************!*\
  !*** ./node_modules/mobx/lib/mobx.module.js ***!
  \**********************************************/
/*! exports provided: extras, Reaction, untracked, IDerivationState, Atom, BaseAtom, useStrict, isStrictModeEnabled, spy, comparer, asReference, asFlat, asStructure, asMap, isModifierDescriptor, isObservableObject, isBoxedObservable, isObservableArray, ObservableMap, isObservableMap, map, transaction, observable, computed, isObservable, isComputed, extendObservable, extendShallowObservable, observe, intercept, autorun, autorunAsync, when, reaction, action, isAction, runInAction, expr, toJS, createTransformer, whyRun, trace, isArrayLike, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extras", function() { return extras; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Reaction", function() { return Reaction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "untracked", function() { return untracked; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IDerivationState", function() { return IDerivationState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Atom", function() { return Atom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseAtom", function() { return BaseAtom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useStrict", function() { return useStrict; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isStrictModeEnabled", function() { return isStrictModeEnabled; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spy", function() { return spy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "comparer", function() { return comparer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asReference", function() { return asReference; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asFlat", function() { return asFlat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asStructure", function() { return asStructure; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asMap", function() { return asMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isModifierDescriptor", function() { return isModifierDescriptor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isObservableObject", function() { return isObservableObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBoxedObservable", function() { return isObservableValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isObservableArray", function() { return isObservableArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObservableMap", function() { return ObservableMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isObservableMap", function() { return isObservableMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "map", function() { return map; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transaction", function() { return transaction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "observable", function() { return observable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computed", function() { return computed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isObservable", function() { return isObservable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isComputed", function() { return isComputed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendObservable", function() { return extendObservable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendShallowObservable", function() { return extendShallowObservable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "observe", function() { return observe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intercept", function() { return intercept; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "autorun", function() { return autorun; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "autorunAsync", function() { return autorunAsync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "when", function() { return when; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reaction", function() { return reaction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "action", function() { return action; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isAction", function() { return isAction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "runInAction", function() { return runInAction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expr", function() { return expr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toJS", function() { return toJS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createTransformer", function() { return createTransformer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "whyRun", function() { return whyRun; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trace", function() { return trace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isArrayLike", function() { return isArrayLike; });
/** MobX - (c) Michel Weststrate 2015, 2016 - MIT Licensed */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

/**
 * Anything that can be used to _store_ state is an Atom in mobx. Atoms have two important jobs
 *
 * 1) detect when they are being _used_ and report this (using reportObserved). This allows mobx to make the connection between running functions and the data they used
 * 2) they should notify mobx whenever they have _changed_. This way mobx can re-run any functions (derivations) that are using this atom.
 */
var BaseAtom = (function () {
    /**
     * Create a new atom. For debugging purposes it is recommended to give it a name.
     * The onBecomeObserved and onBecomeUnobserved callbacks can be used for resource management.
     */
    function BaseAtom(name) {
        if (name === void 0) { name = "Atom@" + getNextId(); }
        this.name = name;
        this.isPendingUnobservation = true; // for effective unobserving. BaseAtom has true, for extra optimization, so its onBecomeUnobserved never gets called, because it's not needed
        this.observers = [];
        this.observersIndexes = {};
        this.diffValue = 0;
        this.lastAccessedBy = 0;
        this.lowestObserverState = IDerivationState.NOT_TRACKING;
    }
    BaseAtom.prototype.onBecomeUnobserved = function () {
        // noop
    };
    /**
     * Invoke this method to notify mobx that your atom has been used somehow.
     */
    BaseAtom.prototype.reportObserved = function () {
        reportObserved(this);
    };
    /**
     * Invoke this method _after_ this method has changed to signal mobx that all its observers should invalidate.
     */
    BaseAtom.prototype.reportChanged = function () {
        startBatch();
        propagateChanged(this);
        endBatch();
    };
    BaseAtom.prototype.toString = function () {
        return this.name;
    };
    return BaseAtom;
}());
var Atom = (function (_super) {
    __extends(Atom, _super);
    /**
     * Create a new atom. For debugging purposes it is recommended to give it a name.
     * The onBecomeObserved and onBecomeUnobserved callbacks can be used for resource management.
     */
    function Atom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {
        if (name === void 0) { name = "Atom@" + getNextId(); }
        if (onBecomeObservedHandler === void 0) { onBecomeObservedHandler = noop; }
        if (onBecomeUnobservedHandler === void 0) { onBecomeUnobservedHandler = noop; }
        var _this = _super.call(this, name) || this;
        _this.name = name;
        _this.onBecomeObservedHandler = onBecomeObservedHandler;
        _this.onBecomeUnobservedHandler = onBecomeUnobservedHandler;
        _this.isPendingUnobservation = false; // for effective unobserving.
        _this.isBeingTracked = false;
        return _this;
    }
    Atom.prototype.reportObserved = function () {
        startBatch();
        _super.prototype.reportObserved.call(this);
        if (!this.isBeingTracked) {
            this.isBeingTracked = true;
            this.onBecomeObservedHandler();
        }
        endBatch();
        return !!globalState.trackingDerivation;
        // return doesn't really give useful info, because it can be as well calling computed which calls atom (no reactions)
        // also it could not trigger when calculating reaction dependent on Atom because Atom's value was cached by computed called by given reaction.
    };
    Atom.prototype.onBecomeUnobserved = function () {
        this.isBeingTracked = false;
        this.onBecomeUnobservedHandler();
    };
    return Atom;
}(BaseAtom));
var isAtom = createInstanceofPredicate("Atom", BaseAtom);

function hasInterceptors(interceptable) {
    return interceptable.interceptors && interceptable.interceptors.length > 0;
}
function registerInterceptor(interceptable, handler) {
    var interceptors = interceptable.interceptors || (interceptable.interceptors = []);
    interceptors.push(handler);
    return once(function () {
        var idx = interceptors.indexOf(handler);
        if (idx !== -1)
            interceptors.splice(idx, 1);
    });
}
function interceptChange(interceptable, change) {
    var prevU = untrackedStart();
    try {
        var interceptors = interceptable.interceptors;
        if (interceptors)
            for (var i = 0, l = interceptors.length; i < l; i++) {
                change = interceptors[i](change);
                invariant(!change || change.type, "Intercept handlers should return nothing or a change object");
                if (!change)
                    break;
            }
        return change;
    }
    finally {
        untrackedEnd(prevU);
    }
}

function hasListeners(listenable) {
    return listenable.changeListeners && listenable.changeListeners.length > 0;
}
function registerListener(listenable, handler) {
    var listeners = listenable.changeListeners || (listenable.changeListeners = []);
    listeners.push(handler);
    return once(function () {
        var idx = listeners.indexOf(handler);
        if (idx !== -1)
            listeners.splice(idx, 1);
    });
}
function notifyListeners(listenable, change) {
    var prevU = untrackedStart();
    var listeners = listenable.changeListeners;
    if (!listeners)
        return;
    listeners = listeners.slice();
    for (var i = 0, l = listeners.length; i < l; i++) {
        listeners[i](change);
    }
    untrackedEnd(prevU);
}

function isSpyEnabled() {
    return !!globalState.spyListeners.length;
}
function spyReport(event) {
    if (!globalState.spyListeners.length)
        return;
    var listeners = globalState.spyListeners;
    for (var i = 0, l = listeners.length; i < l; i++)
        listeners[i](event);
}
function spyReportStart(event) {
    var change = objectAssign({}, event, { spyReportStart: true });
    spyReport(change);
}
var END_EVENT = { spyReportEnd: true };
function spyReportEnd(change) {
    if (change)
        spyReport(objectAssign({}, change, END_EVENT));
    else
        spyReport(END_EVENT);
}
function spy(listener) {
    globalState.spyListeners.push(listener);
    return once(function () {
        var idx = globalState.spyListeners.indexOf(listener);
        if (idx !== -1)
            globalState.spyListeners.splice(idx, 1);
    });
}

function iteratorSymbol() {
    return (typeof Symbol === "function" && Symbol.iterator) || "@@iterator";
}
var IS_ITERATING_MARKER = "__$$iterating";
function arrayAsIterator(array) {
    // returning an array for entries(), values() etc for maps was a mis-interpretation of the specs..,
    // yet it is quite convenient to be able to use the response both as array directly and as iterator
    // it is suboptimal, but alas...
    invariant(array[IS_ITERATING_MARKER] !== true, "Illegal state: cannot recycle array as iterator");
    addHiddenFinalProp(array, IS_ITERATING_MARKER, true);
    var idx = -1;
    addHiddenFinalProp(array, "next", function next() {
        idx++;
        return {
            done: idx >= this.length,
            value: idx < this.length ? this[idx] : undefined
        };
    });
    return array;
}
function declareIterator(prototType, iteratorFactory) {
    addHiddenFinalProp(prototType, iteratorSymbol(), iteratorFactory);
}

var MAX_SPLICE_SIZE = 10000; // See e.g. https://github.com/mobxjs/mobx/issues/859
// Detects bug in safari 9.1.1 (or iOS 9 safari mobile). See #364
var safariPrototypeSetterInheritanceBug = (function () {
    var v = false;
    var p = {};
    Object.defineProperty(p, "0", {
        set: function () {
            v = true;
        }
    });
    Object.create(p)["0"] = 1;
    return v === false;
})();
/**
 * This array buffer contains two lists of properties, so that all arrays
 * can recycle their property definitions, which significantly improves performance of creating
 * properties on the fly.
 */
var OBSERVABLE_ARRAY_BUFFER_SIZE = 0;
// Typescript workaround to make sure ObservableArray extends Array
var StubArray = (function () {
    function StubArray() {
    }
    return StubArray;
}());
function inherit(ctor, proto) {
    if (typeof Object["setPrototypeOf"] !== "undefined") {
        Object["setPrototypeOf"](ctor.prototype, proto);
    }
    else if (typeof ctor.prototype.__proto__ !== "undefined") {
        ctor.prototype.__proto__ = proto;
    }
    else {
        ctor["prototype"] = proto;
    }
}
inherit(StubArray, Array.prototype);
// Weex freeze Array.prototype
// Make them writeable and configurable in prototype chain
// https://github.com/alibaba/weex/pull/1529
if (Object.isFrozen(Array)) {
    
    [
        "constructor",
        "push",
        "shift",
        "concat",
        "pop",
        "unshift",
        "replace",
        "find",
        "findIndex",
        "splice",
        "reverse",
        "sort"
    ].forEach(function (key) {
        Object.defineProperty(StubArray.prototype, key, {
            configurable: true,
            writable: true,
            value: Array.prototype[key]
        });
    });
}
var ObservableArrayAdministration = (function () {
    function ObservableArrayAdministration(name, enhancer, array, owned) {
        this.array = array;
        this.owned = owned;
        this.values = [];
        this.lastKnownLength = 0;
        this.interceptors = null;
        this.changeListeners = null;
        this.atom = new BaseAtom(name || "ObservableArray@" + getNextId());
        this.enhancer = function (newV, oldV) { return enhancer(newV, oldV, name + "[..]"); };
    }
    ObservableArrayAdministration.prototype.dehanceValue = function (value) {
        if (this.dehancer !== undefined)
            return this.dehancer(value);
        return value;
    };
    ObservableArrayAdministration.prototype.dehanceValues = function (values) {
        if (this.dehancer !== undefined)
            return values.map(this.dehancer);
        return values;
    };
    ObservableArrayAdministration.prototype.intercept = function (handler) {
        return registerInterceptor(this, handler);
    };
    ObservableArrayAdministration.prototype.observe = function (listener, fireImmediately) {
        if (fireImmediately === void 0) { fireImmediately = false; }
        if (fireImmediately) {
            listener({
                object: this.array,
                type: "splice",
                index: 0,
                added: this.values.slice(),
                addedCount: this.values.length,
                removed: [],
                removedCount: 0
            });
        }
        return registerListener(this, listener);
    };
    ObservableArrayAdministration.prototype.getArrayLength = function () {
        this.atom.reportObserved();
        return this.values.length;
    };
    ObservableArrayAdministration.prototype.setArrayLength = function (newLength) {
        if (typeof newLength !== "number" || newLength < 0)
            throw new Error("[mobx.array] Out of range: " + newLength);
        var currentLength = this.values.length;
        if (newLength === currentLength)
            return;
        else if (newLength > currentLength) {
            var newItems = new Array(newLength - currentLength);
            for (var i = 0; i < newLength - currentLength; i++)
                newItems[i] = undefined; // No Array.fill everywhere...
            this.spliceWithArray(currentLength, 0, newItems);
        }
        else
            this.spliceWithArray(newLength, currentLength - newLength);
    };
    // adds / removes the necessary numeric properties to this object
    ObservableArrayAdministration.prototype.updateArrayLength = function (oldLength, delta) {
        if (oldLength !== this.lastKnownLength)
            throw new Error("[mobx] Modification exception: the internal structure of an observable array was changed. Did you use peek() to change it?");
        this.lastKnownLength += delta;
        if (delta > 0 && oldLength + delta + 1 > OBSERVABLE_ARRAY_BUFFER_SIZE)
            reserveArrayBuffer(oldLength + delta + 1);
    };
    ObservableArrayAdministration.prototype.spliceWithArray = function (index, deleteCount, newItems) {
        var _this = this;
        checkIfStateModificationsAreAllowed(this.atom);
        var length = this.values.length;
        if (index === undefined)
            index = 0;
        else if (index > length)
            index = length;
        else if (index < 0)
            index = Math.max(0, length + index);
        if (arguments.length === 1)
            deleteCount = length - index;
        else if (deleteCount === undefined || deleteCount === null)
            deleteCount = 0;
        else
            deleteCount = Math.max(0, Math.min(deleteCount, length - index));
        if (newItems === undefined)
            newItems = [];
        if (hasInterceptors(this)) {
            var change = interceptChange(this, {
                object: this.array,
                type: "splice",
                index: index,
                removedCount: deleteCount,
                added: newItems
            });
            if (!change)
                return EMPTY_ARRAY;
            deleteCount = change.removedCount;
            newItems = change.added;
        }
        newItems = newItems.map(function (v) { return _this.enhancer(v, undefined); });
        var lengthDelta = newItems.length - deleteCount;
        this.updateArrayLength(length, lengthDelta); // create or remove new entries
        var res = this.spliceItemsIntoValues(index, deleteCount, newItems);
        if (deleteCount !== 0 || newItems.length !== 0)
            this.notifyArraySplice(index, newItems, res);
        return this.dehanceValues(res);
    };
    ObservableArrayAdministration.prototype.spliceItemsIntoValues = function (index, deleteCount, newItems) {
        if (newItems.length < MAX_SPLICE_SIZE) {
            return (_a = this.values).splice.apply(_a, [index, deleteCount].concat(newItems));
        }
        else {
            var res = this.values.slice(index, index + deleteCount);
            this.values = this.values
                .slice(0, index)
                .concat(newItems, this.values.slice(index + deleteCount));
            return res;
        }
        var _a;
    };
    ObservableArrayAdministration.prototype.notifyArrayChildUpdate = function (index, newValue, oldValue) {
        var notifySpy = !this.owned && isSpyEnabled();
        var notify = hasListeners(this);
        var change = notify || notifySpy
            ? {
                object: this.array,
                type: "update",
                index: index,
                newValue: newValue,
                oldValue: oldValue
            }
            : null;
        if (notifySpy)
            spyReportStart(change);
        this.atom.reportChanged();
        if (notify)
            notifyListeners(this, change);
        if (notifySpy)
            spyReportEnd();
    };
    ObservableArrayAdministration.prototype.notifyArraySplice = function (index, added, removed) {
        var notifySpy = !this.owned && isSpyEnabled();
        var notify = hasListeners(this);
        var change = notify || notifySpy
            ? {
                object: this.array,
                type: "splice",
                index: index,
                removed: removed,
                added: added,
                removedCount: removed.length,
                addedCount: added.length
            }
            : null;
        if (notifySpy)
            spyReportStart(change);
        this.atom.reportChanged();
        // conform: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/observe
        if (notify)
            notifyListeners(this, change);
        if (notifySpy)
            spyReportEnd();
    };
    return ObservableArrayAdministration;
}());
var ObservableArray = (function (_super) {
    __extends(ObservableArray, _super);
    function ObservableArray(initialValues, enhancer, name, owned) {
        if (name === void 0) { name = "ObservableArray@" + getNextId(); }
        if (owned === void 0) { owned = false; }
        var _this = _super.call(this) || this;
        var adm = new ObservableArrayAdministration(name, enhancer, _this, owned);
        addHiddenFinalProp(_this, "$mobx", adm);
        if (initialValues && initialValues.length) {
            _this.spliceWithArray(0, 0, initialValues);
        }
        if (safariPrototypeSetterInheritanceBug) {
            // Seems that Safari won't use numeric prototype setter untill any * numeric property is
            // defined on the instance. After that it works fine, even if this property is deleted.
            Object.defineProperty(adm.array, "0", ENTRY_0);
        }
        return _this;
    }
    ObservableArray.prototype.intercept = function (handler) {
        return this.$mobx.intercept(handler);
    };
    ObservableArray.prototype.observe = function (listener, fireImmediately) {
        if (fireImmediately === void 0) { fireImmediately = false; }
        return this.$mobx.observe(listener, fireImmediately);
    };
    ObservableArray.prototype.clear = function () {
        return this.splice(0);
    };
    ObservableArray.prototype.concat = function () {
        var arrays = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            arrays[_i] = arguments[_i];
        }
        this.$mobx.atom.reportObserved();
        return Array.prototype.concat.apply(this.peek(), arrays.map(function (a) { return (isObservableArray(a) ? a.peek() : a); }));
    };
    ObservableArray.prototype.replace = function (newItems) {
        return this.$mobx.spliceWithArray(0, this.$mobx.values.length, newItems);
    };
    /**
     * Converts this array back to a (shallow) javascript structure.
     * For a deep clone use mobx.toJS
     */
    ObservableArray.prototype.toJS = function () {
        return this.slice();
    };
    ObservableArray.prototype.toJSON = function () {
        // Used by JSON.stringify
        return this.toJS();
    };
    ObservableArray.prototype.peek = function () {
        this.$mobx.atom.reportObserved();
        return this.$mobx.dehanceValues(this.$mobx.values);
    };
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
    ObservableArray.prototype.find = function (predicate, thisArg, fromIndex) {
        if (fromIndex === void 0) { fromIndex = 0; }
        var idx = this.findIndex.apply(this, arguments);
        return idx === -1 ? undefined : this.get(idx);
    };
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex
    ObservableArray.prototype.findIndex = function (predicate, thisArg, fromIndex) {
        if (fromIndex === void 0) { fromIndex = 0; }
        var items = this.peek(), l = items.length;
        for (var i = fromIndex; i < l; i++)
            if (predicate.call(thisArg, items[i], i, this))
                return i;
        return -1;
    };
    /*
     * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)
     * since these functions alter the inner structure of the array, the have side effects.
     * Because the have side effects, they should not be used in computed function,
     * and for that reason the do not call dependencyState.notifyObserved
     */
    ObservableArray.prototype.splice = function (index, deleteCount) {
        var newItems = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            newItems[_i - 2] = arguments[_i];
        }
        switch (arguments.length) {
            case 0:
                return [];
            case 1:
                return this.$mobx.spliceWithArray(index);
            case 2:
                return this.$mobx.spliceWithArray(index, deleteCount);
        }
        return this.$mobx.spliceWithArray(index, deleteCount, newItems);
    };
    ObservableArray.prototype.spliceWithArray = function (index, deleteCount, newItems) {
        return this.$mobx.spliceWithArray(index, deleteCount, newItems);
    };
    ObservableArray.prototype.push = function () {
        var items = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            items[_i] = arguments[_i];
        }
        var adm = this.$mobx;
        adm.spliceWithArray(adm.values.length, 0, items);
        return adm.values.length;
    };
    ObservableArray.prototype.pop = function () {
        return this.splice(Math.max(this.$mobx.values.length - 1, 0), 1)[0];
    };
    ObservableArray.prototype.shift = function () {
        return this.splice(0, 1)[0];
    };
    ObservableArray.prototype.unshift = function () {
        var items = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            items[_i] = arguments[_i];
        }
        var adm = this.$mobx;
        adm.spliceWithArray(0, 0, items);
        return adm.values.length;
    };
    ObservableArray.prototype.reverse = function () {
        // reverse by default mutates in place before returning the result
        // which makes it both a 'derivation' and a 'mutation'.
        // so we deviate from the default and just make it an dervitation
        var clone = this.slice();
        return clone.reverse.apply(clone, arguments);
    };
    ObservableArray.prototype.sort = function (compareFn) {
        // sort by default mutates in place before returning the result
        // which goes against all good practices. Let's not change the array in place!
        var clone = this.slice();
        return clone.sort.apply(clone, arguments);
    };
    ObservableArray.prototype.remove = function (value) {
        var idx = this.$mobx.dehanceValues(this.$mobx.values).indexOf(value);
        if (idx > -1) {
            this.splice(idx, 1);
            return true;
        }
        return false;
    };
    ObservableArray.prototype.move = function (fromIndex, toIndex) {
        function checkIndex(index) {
            if (index < 0) {
                throw new Error("[mobx.array] Index out of bounds: " + index + " is negative");
            }
            var length = this.$mobx.values.length;
            if (index >= length) {
                throw new Error("[mobx.array] Index out of bounds: " + index + " is not smaller than " + length);
            }
        }
        checkIndex.call(this, fromIndex);
        checkIndex.call(this, toIndex);
        if (fromIndex === toIndex) {
            return;
        }
        var oldItems = this.$mobx.values;
        var newItems;
        if (fromIndex < toIndex) {
            newItems = oldItems.slice(0, fromIndex).concat(oldItems.slice(fromIndex + 1, toIndex + 1), [
                oldItems[fromIndex]
            ], oldItems.slice(toIndex + 1));
        }
        else {
            // toIndex < fromIndex
            newItems = oldItems.slice(0, toIndex).concat([
                oldItems[fromIndex]
            ], oldItems.slice(toIndex, fromIndex), oldItems.slice(fromIndex + 1));
        }
        this.replace(newItems);
    };
    // See #734, in case property accessors are unreliable...
    ObservableArray.prototype.get = function (index) {
        var impl = this.$mobx;
        if (impl) {
            if (index < impl.values.length) {
                impl.atom.reportObserved();
                return impl.dehanceValue(impl.values[index]);
            }
            console.warn("[mobx.array] Attempt to read an array index (" + index + ") that is out of bounds (" + impl
                .values
                .length + "). Please check length first. Out of bound indices will not be tracked by MobX");
        }
        return undefined;
    };
    // See #734, in case property accessors are unreliable...
    ObservableArray.prototype.set = function (index, newValue) {
        var adm = this.$mobx;
        var values = adm.values;
        if (index < values.length) {
            // update at index in range
            checkIfStateModificationsAreAllowed(adm.atom);
            var oldValue = values[index];
            if (hasInterceptors(adm)) {
                var change = interceptChange(adm, {
                    type: "update",
                    object: this,
                    index: index,
                    newValue: newValue
                });
                if (!change)
                    return;
                newValue = change.newValue;
            }
            newValue = adm.enhancer(newValue, oldValue);
            var changed = newValue !== oldValue;
            if (changed) {
                values[index] = newValue;
                adm.notifyArrayChildUpdate(index, newValue, oldValue);
            }
        }
        else if (index === values.length) {
            // add a new item
            adm.spliceWithArray(index, 0, [newValue]);
        }
        else {
            // out of bounds
            throw new Error("[mobx.array] Index out of bounds, " + index + " is larger than " + values.length);
        }
    };
    return ObservableArray;
}(StubArray));
declareIterator(ObservableArray.prototype, function () {
    return arrayAsIterator(this.slice());
});
Object.defineProperty(ObservableArray.prototype, "length", {
    enumerable: false,
    configurable: true,
    get: function () {
        return this.$mobx.getArrayLength();
    },
    set: function (newLength) {
        this.$mobx.setArrayLength(newLength);
    }
});
[
    "every",
    "filter",
    "forEach",
    "indexOf",
    "join",
    "lastIndexOf",
    "map",
    "reduce",
    "reduceRight",
    "slice",
    "some",
    "toString",
    "toLocaleString"
].forEach(function (funcName) {
    var baseFunc = Array.prototype[funcName];
    invariant(typeof baseFunc === "function", "Base function not defined on Array prototype: '" + funcName + "'");
    addHiddenProp(ObservableArray.prototype, funcName, function () {
        return baseFunc.apply(this.peek(), arguments);
    });
});
/**
 * We don't want those to show up in `for (const key in ar)` ...
 */
makeNonEnumerable(ObservableArray.prototype, [
    "constructor",
    "intercept",
    "observe",
    "clear",
    "concat",
    "get",
    "replace",
    "toJS",
    "toJSON",
    "peek",
    "find",
    "findIndex",
    "splice",
    "spliceWithArray",
    "push",
    "pop",
    "set",
    "shift",
    "unshift",
    "reverse",
    "sort",
    "remove",
    "move",
    "toString",
    "toLocaleString"
]);
// See #364
var ENTRY_0 = createArrayEntryDescriptor(0);
function createArrayEntryDescriptor(index) {
    return {
        enumerable: false,
        configurable: false,
        get: function () {
            // TODO: Check `this`?, see #752?
            return this.get(index);
        },
        set: function (value) {
            this.set(index, value);
        }
    };
}
function createArrayBufferItem(index) {
    Object.defineProperty(ObservableArray.prototype, "" + index, createArrayEntryDescriptor(index));
}
function reserveArrayBuffer(max) {
    for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max; index++)
        createArrayBufferItem(index);
    OBSERVABLE_ARRAY_BUFFER_SIZE = max;
}
reserveArrayBuffer(1000);
var isObservableArrayAdministration = createInstanceofPredicate("ObservableArrayAdministration", ObservableArrayAdministration);
function isObservableArray(thing) {
    return isObject(thing) && isObservableArrayAdministration(thing.$mobx);
}

var UNCHANGED = {};
var ObservableValue = (function (_super) {
    __extends(ObservableValue, _super);
    function ObservableValue(value, enhancer, name, notifySpy) {
        if (name === void 0) { name = "ObservableValue@" + getNextId(); }
        if (notifySpy === void 0) { notifySpy = true; }
        var _this = _super.call(this, name) || this;
        _this.enhancer = enhancer;
        _this.hasUnreportedChange = false;
        _this.dehancer = undefined;
        _this.value = enhancer(value, undefined, name);
        if (notifySpy && isSpyEnabled()) {
            // only notify spy if this is a stand-alone observable
            spyReport({ type: "create", object: _this, newValue: _this.value });
        }
        return _this;
    }
    ObservableValue.prototype.dehanceValue = function (value) {
        if (this.dehancer !== undefined)
            return this.dehancer(value);
        return value;
    };
    ObservableValue.prototype.set = function (newValue) {
        var oldValue = this.value;
        newValue = this.prepareNewValue(newValue);
        if (newValue !== UNCHANGED) {
            var notifySpy = isSpyEnabled();
            if (notifySpy) {
                spyReportStart({
                    type: "update",
                    object: this,
                    newValue: newValue,
                    oldValue: oldValue
                });
            }
            this.setNewValue(newValue);
            if (notifySpy)
                spyReportEnd();
        }
    };
    ObservableValue.prototype.prepareNewValue = function (newValue) {
        checkIfStateModificationsAreAllowed(this);
        if (hasInterceptors(this)) {
            var change = interceptChange(this, {
                object: this,
                type: "update",
                newValue: newValue
            });
            if (!change)
                return UNCHANGED;
            newValue = change.newValue;
        }
        // apply modifier
        newValue = this.enhancer(newValue, this.value, this.name);
        return this.value !== newValue ? newValue : UNCHANGED;
    };
    ObservableValue.prototype.setNewValue = function (newValue) {
        var oldValue = this.value;
        this.value = newValue;
        this.reportChanged();
        if (hasListeners(this)) {
            notifyListeners(this, {
                type: "update",
                object: this,
                newValue: newValue,
                oldValue: oldValue
            });
        }
    };
    ObservableValue.prototype.get = function () {
        this.reportObserved();
        return this.dehanceValue(this.value);
    };
    ObservableValue.prototype.intercept = function (handler) {
        return registerInterceptor(this, handler);
    };
    ObservableValue.prototype.observe = function (listener, fireImmediately) {
        if (fireImmediately)
            listener({
                object: this,
                type: "update",
                newValue: this.value,
                oldValue: undefined
            });
        return registerListener(this, listener);
    };
    ObservableValue.prototype.toJSON = function () {
        return this.get();
    };
    ObservableValue.prototype.toString = function () {
        return this.name + "[" + this.value + "]";
    };
    ObservableValue.prototype.valueOf = function () {
        return toPrimitive(this.get());
    };
    return ObservableValue;
}(BaseAtom));
ObservableValue.prototype[primitiveSymbol()] = ObservableValue.prototype.valueOf;
var isObservableValue = createInstanceofPredicate("ObservableValue", ObservableValue);

var messages = {
    m001: "It is not allowed to assign new values to @action fields",
    m002: "`runInAction` expects a function",
    m003: "`runInAction` expects a function without arguments",
    m004: "autorun expects a function",
    m005: "Warning: attempted to pass an action to autorun. Actions are untracked and will not trigger on state changes. Use `reaction` or wrap only your state modification code in an action.",
    m006: "Warning: attempted to pass an action to autorunAsync. Actions are untracked and will not trigger on state changes. Use `reaction` or wrap only your state modification code in an action.",
    m007: "reaction only accepts 2 or 3 arguments. If migrating from MobX 2, please provide an options object",
    m008: "wrapping reaction expression in `asReference` is no longer supported, use options object instead",
    m009: "@computed can only be used on getter functions, like: '@computed get myProps() { return ...; }'. It looks like it was used on a property.",
    m010: "@computed can only be used on getter functions, like: '@computed get myProps() { return ...; }'",
    m011: "First argument to `computed` should be an expression. If using computed as decorator, don't pass it arguments",
    m012: "computed takes one or two arguments if used as function",
    m013: "[mobx.expr] 'expr' should only be used inside other reactive functions.",
    m014: "extendObservable expected 2 or more arguments",
    m015: "extendObservable expects an object as first argument",
    m016: "extendObservable should not be used on maps, use map.merge instead",
    m017: "all arguments of extendObservable should be objects",
    m018: "extending an object with another observable (object) is not supported. Please construct an explicit propertymap, using `toJS` if need. See issue #540",
    m019: "[mobx.isObservable] isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.",
    m020: "modifiers can only be used for individual object properties",
    m021: "observable expects zero or one arguments",
    m022: "@observable can not be used on getters, use @computed instead",
    m024: "whyRun() can only be used if a derivation is active, or by passing an computed value / reaction explicitly. If you invoked whyRun from inside a computation; the computation is currently suspended but re-evaluating because somebody requested its value.",
    m025: "whyRun can only be used on reactions and computed values",
    m026: "`action` can only be invoked on functions",
    m028: "It is not allowed to set `useStrict` when a derivation is running",
    m029: "INTERNAL ERROR only onBecomeUnobserved shouldn't be called twice in a row",
    m030a: "Since strict-mode is enabled, changing observed observable values outside actions is not allowed. Please wrap the code in an `action` if this change is intended. Tried to modify: ",
    m030b: "Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, the render function of a React component? Tried to modify: ",
    m031: "Computed values are not allowed to cause side effects by changing observables that are already being observed. Tried to modify: ",
    m032: "* This computation is suspended (not in use by any reaction) and won't run automatically.\n	Didn't expect this computation to be suspended at this point?\n	  1. Make sure this computation is used by a reaction (reaction, autorun, observer).\n	  2. Check whether you are using this computation synchronously (in the same stack as they reaction that needs it).",
    m033: "`observe` doesn't support the fire immediately property for observable maps.",
    m034: "`mobx.map` is deprecated, use `new ObservableMap` or `mobx.observable.map` instead",
    m035: "Cannot make the designated object observable; it is not extensible",
    m036: "It is not possible to get index atoms from arrays",
    m037: "Hi there! I'm sorry you have just run into an exception.\nIf your debugger ends up here, know that some reaction (like the render() of an observer component, autorun or reaction)\nthrew an exception and that mobx caught it, to avoid that it brings the rest of your application down.\nThe original cause of the exception (the code that caused this reaction to run (again)), is still in the stack.\n\nHowever, more interesting is the actual stack trace of the error itself.\nHopefully the error is an instanceof Error, because in that case you can inspect the original stack of the error from where it was thrown.\nSee `error.stack` property, or press the very subtle \"(...)\" link you see near the console.error message that probably brought you here.\nThat stack is more interesting than the stack of this console.error itself.\n\nIf the exception you see is an exception you created yourself, make sure to use `throw new Error(\"Oops\")` instead of `throw \"Oops\"`,\nbecause the javascript environment will only preserve the original stack trace in the first form.\n\nYou can also make sure the debugger pauses the next time this very same exception is thrown by enabling \"Pause on caught exception\".\n(Note that it might pause on many other, unrelated exception as well).\n\nIf that all doesn't help you out, feel free to open an issue https://github.com/mobxjs/mobx/issues!\n",
    m038: "Missing items in this list?\n    1. Check whether all used values are properly marked as observable (use isObservable to verify)\n    2. Make sure you didn't dereference values too early. MobX observes props, not primitives. E.g: use 'person.name' instead of 'name' in your computation.\n"
};
function getMessage(id) {
    return messages[id];
}

function createAction(actionName, fn) {
    invariant(typeof fn === "function", getMessage("m026"));
    invariant(typeof actionName === "string" && actionName.length > 0, "actions should have valid names, got: '" + actionName + "'");
    var res = function () {
        return executeAction(actionName, fn, this, arguments);
    };
    res.originalFn = fn;
    res.isMobxAction = true;
    return res;
}
function executeAction(actionName, fn, scope, args) {
    var runInfo = startAction(actionName, fn, scope, args);
    try {
        return fn.apply(scope, args);
    }
    finally {
        endAction(runInfo);
    }
}
function startAction(actionName, fn, scope, args) {
    var notifySpy = isSpyEnabled() && !!actionName;
    var startTime = 0;
    if (notifySpy) {
        startTime = Date.now();
        var l = (args && args.length) || 0;
        var flattendArgs = new Array(l);
        if (l > 0)
            for (var i = 0; i < l; i++)
                flattendArgs[i] = args[i];
        spyReportStart({
            type: "action",
            name: actionName,
            fn: fn,
            object: scope,
            arguments: flattendArgs
        });
    }
    var prevDerivation = untrackedStart();
    startBatch();
    var prevAllowStateChanges = allowStateChangesStart(true);
    return {
        prevDerivation: prevDerivation,
        prevAllowStateChanges: prevAllowStateChanges,
        notifySpy: notifySpy,
        startTime: startTime
    };
}
function endAction(runInfo) {
    allowStateChangesEnd(runInfo.prevAllowStateChanges);
    endBatch();
    untrackedEnd(runInfo.prevDerivation);
    if (runInfo.notifySpy)
        spyReportEnd({ time: Date.now() - runInfo.startTime });
}
function useStrict(strict) {
    invariant(globalState.trackingDerivation === null, getMessage("m028"));
    globalState.strictMode = strict;
    globalState.allowStateChanges = !strict;
}
function isStrictModeEnabled() {
    return globalState.strictMode;
}
function allowStateChanges(allowStateChanges, func) {
    // TODO: deprecate / refactor this function in next major
    // Currently only used by `@observer`
    // Proposed change: remove first param, rename to `forbidStateChanges`,
    // require error callback instead of the hardcoded error message now used
    // Use `inAction` instead of allowStateChanges in derivation.ts to check strictMode
    var prev = allowStateChangesStart(allowStateChanges);
    var res;
    try {
        res = func();
    }
    finally {
        allowStateChangesEnd(prev);
    }
    return res;
}
function allowStateChangesStart(allowStateChanges) {
    var prev = globalState.allowStateChanges;
    globalState.allowStateChanges = allowStateChanges;
    return prev;
}
function allowStateChangesEnd(prev) {
    globalState.allowStateChanges = prev;
}

/**
 * Constructs a decorator, that normalizes the differences between
 * TypeScript and Babel. Mainly caused by the fact that legacy-decorator cannot assign
 * values during instance creation to properties that have a getter setter.
 *
 * - Sigh -
 *
 * Also takes care of the difference between @decorator field and @decorator(args) field, and different forms of values.
 * For performance (cpu and mem) reasons the properties are always defined on the prototype (at least initially).
 * This means that these properties despite being enumerable might not show up in Object.keys() (but they will show up in for...in loops).
 */
function createClassPropertyDecorator(
    /**
     * This function is invoked once, when the property is added to a new instance.
     * When this happens is not strictly determined due to differences in TS and Babel:
     * Typescript: Usually when constructing the new instance
     * Babel, sometimes Typescript: during the first get / set
     * Both: when calling `runLazyInitializers(instance)`
     */
    onInitialize, get, set, enumerable, 
    /**
     * Can this decorator invoked with arguments? e.g. @decorator(args)
     */
    allowCustomArguments) {
    function classPropertyDecorator(target, key, descriptor, customArgs, argLen) {
        if (argLen === void 0) { argLen = 0; }
        invariant(allowCustomArguments || quacksLikeADecorator(arguments), "This function is a decorator, but it wasn't invoked like a decorator");
        if (!descriptor) {
            // typescript (except for getter / setters)
            var newDescriptor = {
                enumerable: enumerable,
                configurable: true,
                get: function () {
                    if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true)
                        typescriptInitializeProperty(this, key, undefined, onInitialize, customArgs, descriptor);
                    return get.call(this, key);
                },
                set: function (v) {
                    if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true) {
                        typescriptInitializeProperty(this, key, v, onInitialize, customArgs, descriptor);
                    }
                    else {
                        set.call(this, key, v);
                    }
                }
            };
            if (arguments.length < 3 || (arguments.length === 5 && argLen < 3)) {
                // Typescript target is ES3, so it won't define property for us
                // or using Reflect.decorate polyfill, which will return no descriptor
                // (see https://github.com/mobxjs/mobx/issues/333)
                Object.defineProperty(target, key, newDescriptor);
            }
            return newDescriptor;
        }
        else {
            // babel and typescript getter / setter props
            if (!hasOwnProperty(target, "__mobxLazyInitializers")) {
                addHiddenProp(target, "__mobxLazyInitializers", (target.__mobxLazyInitializers && target.__mobxLazyInitializers.slice()) || [] // support inheritance
                );
            }
            var value_1 = descriptor.value, initializer_1 = descriptor.initializer;
            target.__mobxLazyInitializers.push(function (instance) {
                onInitialize(instance, key, initializer_1 ? initializer_1.call(instance) : value_1, customArgs, descriptor);
            });
            return {
                enumerable: enumerable,
                configurable: true,
                get: function () {
                    if (this.__mobxDidRunLazyInitializers !== true)
                        runLazyInitializers(this);
                    return get.call(this, key);
                },
                set: function (v) {
                    if (this.__mobxDidRunLazyInitializers !== true)
                        runLazyInitializers(this);
                    set.call(this, key, v);
                }
            };
        }
    }
    if (allowCustomArguments) {
        /** If custom arguments are allowed, we should return a function that returns a decorator */
        return function () {
            /** Direct invocation: @decorator bla */
            if (quacksLikeADecorator(arguments))
                return classPropertyDecorator.apply(null, arguments);
            /** Indirect invocation: @decorator(args) bla */
            var outerArgs = arguments;
            var argLen = arguments.length;
            return function (target, key, descriptor) {
                return classPropertyDecorator(target, key, descriptor, outerArgs, argLen);
            };
        };
    }
    return classPropertyDecorator;
}
function typescriptInitializeProperty(instance, key, v, onInitialize, customArgs, baseDescriptor) {
    if (!hasOwnProperty(instance, "__mobxInitializedProps"))
        addHiddenProp(instance, "__mobxInitializedProps", {});
    instance.__mobxInitializedProps[key] = true;
    onInitialize(instance, key, v, customArgs, baseDescriptor);
}
function runLazyInitializers(instance) {
    if (instance.__mobxDidRunLazyInitializers === true)
        return;
    if (instance.__mobxLazyInitializers) {
        addHiddenProp(instance, "__mobxDidRunLazyInitializers", true);
        instance.__mobxDidRunLazyInitializers &&
            instance.__mobxLazyInitializers.forEach(function (initializer) { return initializer(instance); });
    }
}
function quacksLikeADecorator(args) {
    return (args.length === 2 || args.length === 3) && typeof args[1] === "string";
}

var actionFieldDecorator = createClassPropertyDecorator(function (target, key, value, args, originalDescriptor) {
    var actionName = args && args.length === 1 ? args[0] : value.name || key || "<unnamed action>";
    var wrappedAction = action(actionName, value);
    addHiddenProp(target, key, wrappedAction);
}, function (key) {
    return this[key];
}, function () {
    invariant(false, getMessage("m001"));
}, false, true);
var boundActionDecorator = createClassPropertyDecorator(function (target, key, value) {
    defineBoundAction(target, key, value);
}, function (key) {
    return this[key];
}, function () {
    invariant(false, getMessage("m001"));
}, false, false);
var action = function action(arg1, arg2, arg3, arg4) {
    if (arguments.length === 1 && typeof arg1 === "function")
        return createAction(arg1.name || "<unnamed action>", arg1);
    if (arguments.length === 2 && typeof arg2 === "function")
        return createAction(arg1, arg2);
    if (arguments.length === 1 && typeof arg1 === "string")
        return namedActionDecorator(arg1);
    return namedActionDecorator(arg2).apply(null, arguments);
};
action.bound = function boundAction(arg1, arg2, arg3) {
    if (typeof arg1 === "function") {
        var action_1 = createAction("<not yet bound action>", arg1);
        action_1.autoBind = true;
        return action_1;
    }
    return boundActionDecorator.apply(null, arguments);
};
function namedActionDecorator(name) {
    return function (target, prop, descriptor) {
        if (descriptor && typeof descriptor.value === "function") {
            // TypeScript @action method() { }. Defined on proto before being decorated
            // Don't use the field decorator if we are just decorating a method
            descriptor.value = createAction(name, descriptor.value);
            descriptor.enumerable = false;
            descriptor.configurable = true;
            return descriptor;
        }
        if (descriptor !== undefined && descriptor.get !== undefined) {
            throw new Error("[mobx] action is not expected to be used with getters");
        }
        // bound instance methods
        return actionFieldDecorator(name).apply(this, arguments);
    };
}
function runInAction(arg1, arg2, arg3) {
    var actionName = typeof arg1 === "string" ? arg1 : arg1.name || "<unnamed action>";
    var fn = typeof arg1 === "function" ? arg1 : arg2;
    var scope = typeof arg1 === "function" ? arg2 : arg3;
    invariant(typeof fn === "function", getMessage("m002"));
    invariant(fn.length === 0, getMessage("m003"));
    invariant(typeof actionName === "string" && actionName.length > 0, "actions should have valid names, got: '" + actionName + "'");
    return executeAction(actionName, fn, scope, undefined);
}
function isAction(thing) {
    return typeof thing === "function" && thing.isMobxAction === true;
}
function defineBoundAction(target, propertyName, fn) {
    var res = function () {
        return executeAction(propertyName, fn, target, arguments);
    };
    res.isMobxAction = true;
    addHiddenProp(target, propertyName, res);
}

function identityComparer(a, b) {
    return a === b;
}
function structuralComparer(a, b) {
    return deepEqual(a, b);
}
function defaultComparer(a, b) {
    return areBothNaN(a, b) || identityComparer(a, b);
}
var comparer = {
    identity: identityComparer,
    structural: structuralComparer,
    default: defaultComparer
};

function autorun(arg1, arg2, arg3) {
    var name, view, scope;
    if (typeof arg1 === "string") {
        name = arg1;
        view = arg2;
        scope = arg3;
    }
    else {
        name = arg1.name || "Autorun@" + getNextId();
        view = arg1;
        scope = arg2;
    }
    invariant(typeof view === "function", getMessage("m004"));
    invariant(isAction(view) === false, getMessage("m005"));
    if (scope)
        view = view.bind(scope);
    var reaction = new Reaction(name, function () {
        this.track(reactionRunner);
    });
    function reactionRunner() {
        view(reaction);
    }
    reaction.schedule();
    return reaction.getDisposer();
}
function when(arg1, arg2, arg3, arg4) {
    var name, predicate, effect, scope;
    if (typeof arg1 === "string") {
        name = arg1;
        predicate = arg2;
        effect = arg3;
        scope = arg4;
    }
    else {
        name = "When@" + getNextId();
        predicate = arg1;
        effect = arg2;
        scope = arg3;
    }
    var disposer = autorun(name, function (r) {
        if (predicate.call(scope)) {
            r.dispose();
            var prevUntracked = untrackedStart();
            effect.call(scope);
            untrackedEnd(prevUntracked);
        }
    });
    return disposer;
}
function autorunAsync(arg1, arg2, arg3, arg4) {
    var name, func, delay, scope;
    if (typeof arg1 === "string") {
        name = arg1;
        func = arg2;
        delay = arg3;
        scope = arg4;
    }
    else {
        name = arg1.name || "AutorunAsync@" + getNextId();
        func = arg1;
        delay = arg2;
        scope = arg3;
    }
    invariant(isAction(func) === false, getMessage("m006"));
    if (delay === void 0)
        delay = 1;
    if (scope)
        func = func.bind(scope);
    var isScheduled = false;
    var r = new Reaction(name, function () {
        if (!isScheduled) {
            isScheduled = true;
            setTimeout(function () {
                isScheduled = false;
                if (!r.isDisposed)
                    r.track(reactionRunner);
            }, delay);
        }
    });
    function reactionRunner() {
        func(r);
    }
    r.schedule();
    return r.getDisposer();
}
function reaction(expression, effect, arg3) {
    if (arguments.length > 3) {
        fail(getMessage("m007"));
    }
    if (isModifierDescriptor(expression)) {
        fail(getMessage("m008"));
    }
    var opts;
    if (typeof arg3 === "object") {
        opts = arg3;
    }
    else {
        opts = {};
    }
    opts.name =
        opts.name || expression.name || effect.name || "Reaction@" + getNextId();
    opts.fireImmediately = arg3 === true || opts.fireImmediately === true;
    opts.delay = opts.delay || 0;
    opts.compareStructural = opts.compareStructural || opts.struct || false;
    // TODO: creates ugly spy events, use `effect = (r) => runInAction(opts.name, () => effect(r))` instead
    effect = action(opts.name, opts.context ? effect.bind(opts.context) : effect);
    if (opts.context) {
        expression = expression.bind(opts.context);
    }
    var firstTime = true;
    var isScheduled = false;
    var value;
    var equals = opts.equals
        ? opts.equals
        : opts.compareStructural || opts.struct ? comparer.structural : comparer.default;
    var r = new Reaction(opts.name, function () {
        if (firstTime || opts.delay < 1) {
            reactionRunner();
        }
        else if (!isScheduled) {
            isScheduled = true;
            setTimeout(function () {
                isScheduled = false;
                reactionRunner();
            }, opts.delay);
        }
    });
    function reactionRunner() {
        if (r.isDisposed)
            return;
        var changed = false;
        r.track(function () {
            var nextValue = expression(r);
            changed = firstTime || !equals(value, nextValue);
            value = nextValue;
        });
        if (firstTime && opts.fireImmediately)
            effect(value, r);
        if (!firstTime && changed === true)
            effect(value, r);
        if (firstTime)
            firstTime = false;
    }
    r.schedule();
    return r.getDisposer();
}

/**
 * A node in the state dependency root that observes other nodes, and can be observed itself.
 *
 * ComputedValue will remember the result of the computation for the duration of the batch, or
 * while being observed.
 *
 * During this time it will recompute only when one of its direct dependencies changed,
 * but only when it is being accessed with `ComputedValue.get()`.
 *
 * Implementation description:
 * 1. First time it's being accessed it will compute and remember result
 *    give back remembered result until 2. happens
 * 2. First time any deep dependency change, propagate POSSIBLY_STALE to all observers, wait for 3.
 * 3. When it's being accessed, recompute if any shallow dependency changed.
 *    if result changed: propagate STALE to all observers, that were POSSIBLY_STALE from the last step.
 *    go to step 2. either way
 *
 * If at any point it's outside batch and it isn't observed: reset everything and go to 1.
 */
var ComputedValue = (function () {
    /**
     * Create a new computed value based on a function expression.
     *
     * The `name` property is for debug purposes only.
     *
     * The `equals` property specifies the comparer function to use to determine if a newly produced
     * value differs from the previous value. Two comparers are provided in the library; `defaultComparer`
     * compares based on identity comparison (===), and `structualComparer` deeply compares the structure.
     * Structural comparison can be convenient if you always produce an new aggregated object and
     * don't want to notify observers if it is structurally the same.
     * This is useful for working with vectors, mouse coordinates etc.
     */
    function ComputedValue(derivation, scope, equals, name, setter) {
        this.derivation = derivation;
        this.scope = scope;
        this.equals = equals;
        this.dependenciesState = IDerivationState.NOT_TRACKING;
        this.observing = []; // nodes we are looking at. Our value depends on these nodes
        this.newObserving = null; // during tracking it's an array with new observed observers
        this.isPendingUnobservation = false;
        this.observers = [];
        this.observersIndexes = {};
        this.diffValue = 0;
        this.runId = 0;
        this.lastAccessedBy = 0;
        this.lowestObserverState = IDerivationState.UP_TO_DATE;
        this.unboundDepsCount = 0;
        this.__mapid = "#" + getNextId();
        this.value = new CaughtException(null);
        this.isComputing = false; // to check for cycles
        this.isRunningSetter = false;
        this.isTracing = TraceMode.NONE;
        this.name = name || "ComputedValue@" + getNextId();
        if (setter)
            this.setter = createAction(name + "-setter", setter);
    }
    ComputedValue.prototype.onBecomeStale = function () {
        propagateMaybeChanged(this);
    };
    ComputedValue.prototype.onBecomeUnobserved = function () {
        clearObserving(this);
        this.value = undefined;
    };
    /**
     * Returns the current value of this computed value.
     * Will evaluate its computation first if needed.
     */
    ComputedValue.prototype.get = function () {
        invariant(!this.isComputing, "Cycle detected in computation " + this.name, this.derivation);
        if (globalState.inBatch === 0) {
            // This is an minor optimization which could be omitted to simplify the code
            // The computedValue is accessed outside of any mobx stuff. Batch observing should be enough and don't need
            // tracking as it will never be called again inside this batch.
            startBatch();
            if (shouldCompute(this)) {
                if (this.isTracing !== TraceMode.NONE) {
                    console.log("[mobx.trace] '" + this
                        .name + "' is being read outside a reactive context and doing a full recompute");
                }
                this.value = this.computeValue(false);
            }
            endBatch();
        }
        else {
            reportObserved(this);
            if (shouldCompute(this))
                if (this.trackAndCompute())
                    propagateChangeConfirmed(this);
        }
        var result = this.value;
        if (isCaughtException(result))
            throw result.cause;
        return result;
    };
    ComputedValue.prototype.peek = function () {
        var res = this.computeValue(false);
        if (isCaughtException(res))
            throw res.cause;
        return res;
    };
    ComputedValue.prototype.set = function (value) {
        if (this.setter) {
            invariant(!this.isRunningSetter, "The setter of computed value '" + this
                .name + "' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?");
            this.isRunningSetter = true;
            try {
                this.setter.call(this.scope, value);
            }
            finally {
                this.isRunningSetter = false;
            }
        }
        else
            invariant(false, "[ComputedValue '" + this
                .name + "'] It is not possible to assign a new value to a computed value.");
    };
    ComputedValue.prototype.trackAndCompute = function () {
        if (isSpyEnabled()) {
            spyReport({
                object: this.scope,
                type: "compute",
                fn: this.derivation
            });
        }
        var oldValue = this.value;
        var wasSuspended = 
        /* see #1208 */ this.dependenciesState === IDerivationState.NOT_TRACKING;
        var newValue = (this.value = this.computeValue(true));
        return (wasSuspended ||
            isCaughtException(oldValue) ||
            isCaughtException(newValue) ||
            !this.equals(oldValue, newValue));
    };
    ComputedValue.prototype.computeValue = function (track) {
        this.isComputing = true;
        globalState.computationDepth++;
        var res;
        if (track) {
            res = trackDerivedFunction(this, this.derivation, this.scope);
        }
        else {
            try {
                res = this.derivation.call(this.scope);
            }
            catch (e) {
                res = new CaughtException(e);
            }
        }
        globalState.computationDepth--;
        this.isComputing = false;
        return res;
    };
    ComputedValue.prototype.observe = function (listener, fireImmediately) {
        var _this = this;
        var firstTime = true;
        var prevValue = undefined;
        return autorun(function () {
            var newValue = _this.get();
            if (!firstTime || fireImmediately) {
                var prevU = untrackedStart();
                listener({
                    type: "update",
                    object: _this,
                    newValue: newValue,
                    oldValue: prevValue
                });
                untrackedEnd(prevU);
            }
            firstTime = false;
            prevValue = newValue;
        });
    };
    ComputedValue.prototype.toJSON = function () {
        return this.get();
    };
    ComputedValue.prototype.toString = function () {
        return this.name + "[" + this.derivation.toString() + "]";
    };
    ComputedValue.prototype.valueOf = function () {
        return toPrimitive(this.get());
    };
    ComputedValue.prototype.whyRun = function () {
        var isTracking = Boolean(globalState.trackingDerivation);
        var observing = unique(this.isComputing ? this.newObserving : this.observing).map(function (dep) { return dep.name; });
        var observers = unique(getObservers(this).map(function (dep) { return dep.name; }));
        return ("\nWhyRun? computation '" + this.name + "':\n * Running because: " + (isTracking
            ? "[active] the value of this computation is needed by a reaction"
            : this.isComputing
                ? "[get] The value of this computed was requested outside a reaction"
                : "[idle] not running at the moment") + "\n" +
            (this.dependenciesState === IDerivationState.NOT_TRACKING
                ? getMessage("m032")
                : " * This computation will re-run if any of the following observables changes:\n    " + joinStrings(observing) + "\n    " + (this.isComputing && isTracking
                    ? " (... or any observable accessed during the remainder of the current run)"
                    : "") + "\n    " + getMessage("m038") + "\n\n  * If the outcome of this computation changes, the following observers will be re-run:\n    " + joinStrings(observers) + "\n"));
    };
    return ComputedValue;
}());
ComputedValue.prototype[primitiveSymbol()] = ComputedValue.prototype.valueOf;
var isComputedValue = createInstanceofPredicate("ComputedValue", ComputedValue);

var ObservableObjectAdministration = (function () {
    function ObservableObjectAdministration(target, name) {
        this.target = target;
        this.name = name;
        this.values = {};
        this.changeListeners = null;
        this.interceptors = null;
    }
    /**
     * Observes this object. Triggers for the events 'add', 'update' and 'delete'.
     * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe
     * for callback details
     */
    ObservableObjectAdministration.prototype.observe = function (callback, fireImmediately) {
        invariant(fireImmediately !== true, "`observe` doesn't support the fire immediately property for observable objects.");
        return registerListener(this, callback);
    };
    ObservableObjectAdministration.prototype.intercept = function (handler) {
        return registerInterceptor(this, handler);
    };
    return ObservableObjectAdministration;
}());
function asObservableObject(target, name) {
    if (isObservableObject(target) && target.hasOwnProperty("$mobx"))
        return target.$mobx;
    invariant(Object.isExtensible(target), getMessage("m035"));
    if (!isPlainObject(target))
        name = (target.constructor.name || "ObservableObject") + "@" + getNextId();
    if (!name)
        name = "ObservableObject@" + getNextId();
    var adm = new ObservableObjectAdministration(target, name);
    addHiddenFinalProp(target, "$mobx", adm);
    return adm;
}
function defineObservablePropertyFromDescriptor(adm, propName, descriptor, defaultEnhancer) {
    if (adm.values[propName] && !isComputedValue(adm.values[propName])) {
        // already observable property
        invariant("value" in descriptor, "The property " + propName + " in " + adm.name + " is already observable, cannot redefine it as computed property");
        adm.target[propName] = descriptor.value; // the property setter will make 'value' reactive if needed.
        return;
    }
    // not yet observable property
    if ("value" in descriptor) {
        // not a computed value
        if (isModifierDescriptor(descriptor.value)) {
            // x : ref(someValue)
            var modifierDescriptor = descriptor.value;
            defineObservableProperty(adm, propName, modifierDescriptor.initialValue, modifierDescriptor.enhancer);
        }
        else if (isAction(descriptor.value) && descriptor.value.autoBind === true) {
            defineBoundAction(adm.target, propName, descriptor.value.originalFn);
        }
        else if (isComputedValue(descriptor.value)) {
            // x: computed(someExpr)
            defineComputedPropertyFromComputedValue(adm, propName, descriptor.value);
        }
        else {
            // x: someValue
            defineObservableProperty(adm, propName, descriptor.value, defaultEnhancer);
        }
    }
    else {
        // get x() { return 3 } set x(v) { }
        defineComputedProperty(adm, propName, descriptor.get, descriptor.set, comparer.default, true);
    }
}
function defineObservableProperty(adm, propName, newValue, enhancer) {
    assertPropertyConfigurable(adm.target, propName);
    if (hasInterceptors(adm)) {
        var change = interceptChange(adm, {
            object: adm.target,
            name: propName,
            type: "add",
            newValue: newValue
        });
        if (!change)
            return;
        newValue = change.newValue;
    }
    var observable = (adm.values[propName] = new ObservableValue(newValue, enhancer, adm.name + "." + propName, false));
    newValue = observable.value; // observableValue might have changed it
    Object.defineProperty(adm.target, propName, generateObservablePropConfig(propName));
    notifyPropertyAddition(adm, adm.target, propName, newValue);
}
function defineComputedProperty(adm, propName, getter, setter, equals, asInstanceProperty) {
    if (asInstanceProperty)
        assertPropertyConfigurable(adm.target, propName);
    adm.values[propName] = new ComputedValue(getter, adm.target, equals, adm.name + "." + propName, setter);
    if (asInstanceProperty) {
        Object.defineProperty(adm.target, propName, generateComputedPropConfig(propName));
    }
}
function defineComputedPropertyFromComputedValue(adm, propName, computedValue) {
    var name = adm.name + "." + propName;
    computedValue.name = name;
    if (!computedValue.scope)
        computedValue.scope = adm.target;
    adm.values[propName] = computedValue;
    Object.defineProperty(adm.target, propName, generateComputedPropConfig(propName));
}
var observablePropertyConfigs = {};
var computedPropertyConfigs = {};
function generateObservablePropConfig(propName) {
    return (observablePropertyConfigs[propName] ||
        (observablePropertyConfigs[propName] = {
            configurable: true,
            enumerable: true,
            get: function () {
                return this.$mobx.values[propName].get();
            },
            set: function (v) {
                setPropertyValue(this, propName, v);
            }
        }));
}
function generateComputedPropConfig(propName) {
    return (computedPropertyConfigs[propName] ||
        (computedPropertyConfigs[propName] = {
            configurable: true,
            enumerable: false,
            get: function () {
                return this.$mobx.values[propName].get();
            },
            set: function (v) {
                return this.$mobx.values[propName].set(v);
            }
        }));
}
function setPropertyValue(instance, name, newValue) {
    var adm = instance.$mobx;
    var observable = adm.values[name];
    // intercept
    if (hasInterceptors(adm)) {
        var change = interceptChange(adm, {
            type: "update",
            object: instance,
            name: name,
            newValue: newValue
        });
        if (!change)
            return;
        newValue = change.newValue;
    }
    newValue = observable.prepareNewValue(newValue);
    // notify spy & observers
    if (newValue !== UNCHANGED) {
        var notify = hasListeners(adm);
        var notifySpy = isSpyEnabled();
        var change = notify || notifySpy
            ? {
                type: "update",
                object: instance,
                oldValue: observable.value,
                name: name,
                newValue: newValue
            }
            : null;
        if (notifySpy)
            spyReportStart(change);
        observable.setNewValue(newValue);
        if (notify)
            notifyListeners(adm, change);
        if (notifySpy)
            spyReportEnd();
    }
}
function notifyPropertyAddition(adm, object, name, newValue) {
    var notify = hasListeners(adm);
    var notifySpy = isSpyEnabled();
    var change = notify || notifySpy
        ? {
            type: "add",
            object: object,
            name: name,
            newValue: newValue
        }
        : null;
    if (notifySpy)
        spyReportStart(change);
    if (notify)
        notifyListeners(adm, change);
    if (notifySpy)
        spyReportEnd();
}
var isObservableObjectAdministration = createInstanceofPredicate("ObservableObjectAdministration", ObservableObjectAdministration);
function isObservableObject(thing) {
    if (isObject(thing)) {
        // Initializers run lazily when transpiling to babel, so make sure they are run...
        runLazyInitializers(thing);
        return isObservableObjectAdministration(thing.$mobx);
    }
    return false;
}

/**
 * Returns true if the provided value is reactive.
 * @param value object, function or array
 * @param property if property is specified, checks whether value.property is reactive.
 */
function isObservable(value, property) {
    if (value === null || value === undefined)
        return false;
    if (property !== undefined) {
        if (isObservableArray(value) || isObservableMap(value))
            throw new Error(getMessage("m019"));
        else if (isObservableObject(value)) {
            var o = value.$mobx;
            return o.values && !!o.values[property];
        }
        return false;
    }
    // For first check, see #701
    return (isObservableObject(value) ||
        !!value.$mobx ||
        isAtom(value) ||
        isReaction(value) ||
        isComputedValue(value));
}

function createDecoratorForEnhancer(enhancer) {
    invariant(!!enhancer, ":(");
    return createClassPropertyDecorator(function (target, name, baseValue, _, baseDescriptor) {
        assertPropertyConfigurable(target, name);
        invariant(!baseDescriptor || !baseDescriptor.get, getMessage("m022"));
        var adm = asObservableObject(target, undefined);
        defineObservableProperty(adm, name, baseValue, enhancer);
    }, function (name) {
        var observable = this.$mobx.values[name];
        if (observable === undefined // See #505
        )
            return undefined;
        return observable.get();
    }, function (name, value) {
        setPropertyValue(this, name, value);
    }, true, false);
}

function extendObservable(target) {
    var properties = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        properties[_i - 1] = arguments[_i];
    }
    return extendObservableHelper(target, deepEnhancer, properties);
}
function extendShallowObservable(target) {
    var properties = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        properties[_i - 1] = arguments[_i];
    }
    return extendObservableHelper(target, referenceEnhancer, properties);
}
function extendObservableHelper(target, defaultEnhancer, properties) {
    invariant(arguments.length >= 2, getMessage("m014"));
    invariant(typeof target === "object", getMessage("m015"));
    invariant(!isObservableMap(target), getMessage("m016"));
    properties.forEach(function (propSet) {
        invariant(typeof propSet === "object", getMessage("m017"));
        invariant(!isObservable(propSet), getMessage("m018"));
    });
    var adm = asObservableObject(target);
    var definedProps = {};
    // Note could be optimised if properties.length === 1
    for (var i = properties.length - 1; i >= 0; i--) {
        var propSet = properties[i];
        for (var key in propSet)
            if (definedProps[key] !== true && hasOwnProperty(propSet, key)) {
                definedProps[key] = true;
                if (target === propSet && !isPropertyConfigurable(target, key))
                    continue; // see #111, skip non-configurable or non-writable props for `observable(object)`.
                var descriptor = Object.getOwnPropertyDescriptor(propSet, key);
                defineObservablePropertyFromDescriptor(adm, key, descriptor, defaultEnhancer);
            }
    }
    return target;
}

var deepDecorator = createDecoratorForEnhancer(deepEnhancer);
var shallowDecorator = createDecoratorForEnhancer(shallowEnhancer);
var refDecorator = createDecoratorForEnhancer(referenceEnhancer);
var deepStructDecorator = createDecoratorForEnhancer(deepStructEnhancer);
var refStructDecorator = createDecoratorForEnhancer(refStructEnhancer);
/**
 * Turns an object, array or function into a reactive structure.
 * @param v the value which should become observable.
 */
function createObservable(v) {
    if (v === void 0) { v = undefined; }
    // @observable someProp;
    if (typeof arguments[1] === "string")
        return deepDecorator.apply(null, arguments);
    invariant(arguments.length <= 1, getMessage("m021"));
    invariant(!isModifierDescriptor(v), getMessage("m020"));
    // it is an observable already, done
    if (isObservable(v))
        return v;
    // something that can be converted and mutated?
    var res = deepEnhancer(v, undefined, undefined);
    // this value could be converted to a new observable data structure, return it
    if (res !== v)
        return res;
    // otherwise, just box it
    return observable.box(v);
}
var observableFactories = {
    box: function (value, name) {
        if (arguments.length > 2)
            incorrectlyUsedAsDecorator("box");
        return new ObservableValue(value, deepEnhancer, name);
    },
    shallowBox: function (value, name) {
        if (arguments.length > 2)
            incorrectlyUsedAsDecorator("shallowBox");
        return new ObservableValue(value, referenceEnhancer, name);
    },
    array: function (initialValues, name) {
        if (arguments.length > 2)
            incorrectlyUsedAsDecorator("array");
        return new ObservableArray(initialValues, deepEnhancer, name);
    },
    shallowArray: function (initialValues, name) {
        if (arguments.length > 2)
            incorrectlyUsedAsDecorator("shallowArray");
        return new ObservableArray(initialValues, referenceEnhancer, name);
    },
    map: function (initialValues, name) {
        if (arguments.length > 2)
            incorrectlyUsedAsDecorator("map");
        return new ObservableMap(initialValues, deepEnhancer, name);
    },
    shallowMap: function (initialValues, name) {
        if (arguments.length > 2)
            incorrectlyUsedAsDecorator("shallowMap");
        return new ObservableMap(initialValues, referenceEnhancer, name);
    },
    object: function (props, name) {
        if (arguments.length > 2)
            incorrectlyUsedAsDecorator("object");
        var res = {};
        // convert to observable object
        asObservableObject(res, name);
        // add properties
        extendObservable(res, props);
        return res;
    },
    shallowObject: function (props, name) {
        if (arguments.length > 2)
            incorrectlyUsedAsDecorator("shallowObject");
        var res = {};
        asObservableObject(res, name);
        extendShallowObservable(res, props);
        return res;
    },
    ref: function () {
        if (arguments.length < 2) {
            // although ref creates actually a modifier descriptor, the type of the resultig properties
            // of the object is `T` in the end, when the descriptors are interpreted
            return createModifierDescriptor(referenceEnhancer, arguments[0]);
        }
        else {
            return refDecorator.apply(null, arguments);
        }
    },
    shallow: function () {
        if (arguments.length < 2) {
            // although ref creates actually a modifier descriptor, the type of the resultig properties
            // of the object is `T` in the end, when the descriptors are interpreted
            return createModifierDescriptor(shallowEnhancer, arguments[0]);
        }
        else {
            return shallowDecorator.apply(null, arguments);
        }
    },
    deep: function () {
        if (arguments.length < 2) {
            // although ref creates actually a modifier descriptor, the type of the resultig properties
            // of the object is `T` in the end, when the descriptors are interpreted
            return createModifierDescriptor(deepEnhancer, arguments[0]);
        }
        else {
            return deepDecorator.apply(null, arguments);
        }
    },
    struct: function () {
        if (arguments.length < 2) {
            // although ref creates actually a modifier descriptor, the type of the resultig properties
            // of the object is `T` in the end, when the descriptors are interpreted
            return createModifierDescriptor(deepStructEnhancer, arguments[0]);
        }
        else {
            return deepStructDecorator.apply(null, arguments);
        }
    }
};
var observable = createObservable;
// weird trick to keep our typings nicely with our funcs, and still extend the observable function
Object.keys(observableFactories).forEach(function (name) { return (observable[name] = observableFactories[name]); });
observable.deep.struct = observable.struct;
observable.ref.struct = function () {
    if (arguments.length < 2) {
        return createModifierDescriptor(refStructEnhancer, arguments[0]);
    }
    else {
        return refStructDecorator.apply(null, arguments);
    }
};
function incorrectlyUsedAsDecorator(methodName) {
    fail("Expected one or two arguments to observable." + methodName + ". Did you accidentally try to use observable." + methodName + " as decorator?");
}

function isModifierDescriptor(thing) {
    return typeof thing === "object" && thing !== null && thing.isMobxModifierDescriptor === true;
}
function createModifierDescriptor(enhancer, initialValue) {
    invariant(!isModifierDescriptor(initialValue), "Modifiers cannot be nested");
    return {
        isMobxModifierDescriptor: true,
        initialValue: initialValue,
        enhancer: enhancer
    };
}
function deepEnhancer(v, _, name) {
    if (isModifierDescriptor(v))
        fail("You tried to assign a modifier wrapped value to a collection, please define modifiers when creating the collection, not when modifying it");
    // it is an observable already, done
    if (isObservable(v))
        return v;
    // something that can be converted and mutated?
    if (Array.isArray(v))
        return observable.array(v, name);
    if (isPlainObject(v))
        return observable.object(v, name);
    if (isES6Map(v))
        return observable.map(v, name);
    return v;
}
function shallowEnhancer(v, _, name) {
    if (isModifierDescriptor(v))
        fail("You tried to assign a modifier wrapped value to a collection, please define modifiers when creating the collection, not when modifying it");
    if (v === undefined || v === null)
        return v;
    if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v))
        return v;
    if (Array.isArray(v))
        return observable.shallowArray(v, name);
    if (isPlainObject(v))
        return observable.shallowObject(v, name);
    if (isES6Map(v))
        return observable.shallowMap(v, name);
    return fail("The shallow modifier / decorator can only used in combination with arrays, objects and maps");
}
function referenceEnhancer(newValue) {
    // never turn into an observable
    return newValue;
}
function deepStructEnhancer(v, oldValue, name) {
    // don't confuse structurally compare enhancer with ref enhancer! The latter is probably
    // more suited for immutable objects
    if (deepEqual(v, oldValue))
        return oldValue;
    // it is an observable already, done
    if (isObservable(v))
        return v;
    // something that can be converted and mutated?
    if (Array.isArray(v))
        return new ObservableArray(v, deepStructEnhancer, name);
    if (isES6Map(v))
        return new ObservableMap(v, deepStructEnhancer, name);
    if (isPlainObject(v)) {
        var res = {};
        asObservableObject(res, name);
        extendObservableHelper(res, deepStructEnhancer, [v]);
        return res;
    }
    return v;
}
function refStructEnhancer(v, oldValue, name) {
    if (deepEqual(v, oldValue))
        return oldValue;
    return v;
}

/**
 * During a transaction no views are updated until the end of the transaction.
 * The transaction will be run synchronously nonetheless.
 *
 * @param action a function that updates some reactive state
 * @returns any value that was returned by the 'action' parameter.
 */
function transaction(action, thisArg) {
    if (thisArg === void 0) { thisArg = undefined; }
    startBatch();
    try {
        return action.apply(thisArg);
    }
    finally {
        endBatch();
    }
}

var ObservableMapMarker = {};
var ObservableMap = (function () {
    function ObservableMap(initialData, enhancer, name) {
        if (enhancer === void 0) { enhancer = deepEnhancer; }
        if (name === void 0) { name = "ObservableMap@" + getNextId(); }
        this.enhancer = enhancer;
        this.name = name;
        this.$mobx = ObservableMapMarker;
        this._data = Object.create(null);
        this._hasMap = Object.create(null); // hasMap, not hashMap >-).
        this._keys = new ObservableArray(undefined, referenceEnhancer, this.name + ".keys()", true);
        this.interceptors = null;
        this.changeListeners = null;
        this.dehancer = undefined;
        this.merge(initialData);
    }
    ObservableMap.prototype._has = function (key) {
        return typeof this._data[key] !== "undefined";
    };
    ObservableMap.prototype.has = function (key) {
        if (!this.isValidKey(key))
            return false;
        key = "" + key;
        if (this._hasMap[key])
            return this._hasMap[key].get();
        return this._updateHasMapEntry(key, false).get();
    };
    ObservableMap.prototype.set = function (key, value) {
        this.assertValidKey(key);
        key = "" + key;
        var hasKey = this._has(key);
        if (hasInterceptors(this)) {
            var change = interceptChange(this, {
                type: hasKey ? "update" : "add",
                object: this,
                newValue: value,
                name: key
            });
            if (!change)
                return this;
            value = change.newValue;
        }
        if (hasKey) {
            this._updateValue(key, value);
        }
        else {
            this._addValue(key, value);
        }
        return this;
    };
    ObservableMap.prototype.delete = function (key) {
        var _this = this;
        this.assertValidKey(key);
        key = "" + key;
        if (hasInterceptors(this)) {
            var change = interceptChange(this, {
                type: "delete",
                object: this,
                name: key
            });
            if (!change)
                return false;
        }
        if (this._has(key)) {
            var notifySpy = isSpyEnabled();
            var notify = hasListeners(this);
            var change = notify || notifySpy
                ? {
                    type: "delete",
                    object: this,
                    oldValue: this._data[key].value,
                    name: key
                }
                : null;
            if (notifySpy)
                spyReportStart(change);
            transaction(function () {
                _this._keys.remove(key);
                _this._updateHasMapEntry(key, false);
                var observable$$1 = _this._data[key];
                observable$$1.setNewValue(undefined);
                _this._data[key] = undefined;
            });
            if (notify)
                notifyListeners(this, change);
            if (notifySpy)
                spyReportEnd();
            return true;
        }
        return false;
    };
    ObservableMap.prototype._updateHasMapEntry = function (key, value) {
        // optimization; don't fill the hasMap if we are not observing, or remove entry if there are no observers anymore
        var entry = this._hasMap[key];
        if (entry) {
            entry.setNewValue(value);
        }
        else {
            entry = this._hasMap[key] = new ObservableValue(value, referenceEnhancer, this.name + "." + key + "?", false);
        }
        return entry;
    };
    ObservableMap.prototype._updateValue = function (name, newValue) {
        var observable$$1 = this._data[name];
        newValue = observable$$1.prepareNewValue(newValue);
        if (newValue !== UNCHANGED) {
            var notifySpy = isSpyEnabled();
            var notify = hasListeners(this);
            var change = notify || notifySpy
                ? {
                    type: "update",
                    object: this,
                    oldValue: observable$$1.value,
                    name: name,
                    newValue: newValue
                }
                : null;
            if (notifySpy)
                spyReportStart(change);
            observable$$1.setNewValue(newValue);
            if (notify)
                notifyListeners(this, change);
            if (notifySpy)
                spyReportEnd();
        }
    };
    ObservableMap.prototype._addValue = function (name, newValue) {
        var _this = this;
        transaction(function () {
            var observable$$1 = (_this._data[name] = new ObservableValue(newValue, _this.enhancer, _this.name + "." + name, false));
            newValue = observable$$1.value; // value might have been changed
            _this._updateHasMapEntry(name, true);
            _this._keys.push(name);
        });
        var notifySpy = isSpyEnabled();
        var notify = hasListeners(this);
        var change = notify || notifySpy
            ? {
                type: "add",
                object: this,
                name: name,
                newValue: newValue
            }
            : null;
        if (notifySpy)
            spyReportStart(change);
        if (notify)
            notifyListeners(this, change);
        if (notifySpy)
            spyReportEnd();
    };
    ObservableMap.prototype.get = function (key) {
        key = "" + key;
        if (this.has(key))
            return this.dehanceValue(this._data[key].get());
        return this.dehanceValue(undefined);
    };
    ObservableMap.prototype.dehanceValue = function (value) {
        if (this.dehancer !== undefined) {
            return this.dehancer(value);
        }
        return value;
    };
    ObservableMap.prototype.keys = function () {
        return arrayAsIterator(this._keys.slice());
    };
    ObservableMap.prototype.values = function () {
        return arrayAsIterator(this._keys.map(this.get, this));
    };
    ObservableMap.prototype.entries = function () {
        var _this = this;
        return arrayAsIterator(this._keys.map(function (key) { return [key, _this.get(key)]; }));
    };
    ObservableMap.prototype.forEach = function (callback, thisArg) {
        var _this = this;
        this.keys().forEach(function (key) { return callback.call(thisArg, _this.get(key), key, _this); });
    };
    /** Merge another object into this object, returns this. */
    ObservableMap.prototype.merge = function (other) {
        var _this = this;
        if (isObservableMap(other)) {
            other = other.toJS();
        }
        transaction(function () {
            if (isPlainObject(other))
                Object.keys(other).forEach(function (key) { return _this.set(key, other[key]); });
            else if (Array.isArray(other))
                other.forEach(function (_a) {
                    var key = _a[0], value = _a[1];
                    return _this.set(key, value);
                });
            else if (isES6Map(other))
                other.forEach(function (value, key) { return _this.set(key, value); });
            else if (other !== null && other !== undefined)
                fail("Cannot initialize map from " + other);
        });
        return this;
    };
    ObservableMap.prototype.clear = function () {
        var _this = this;
        transaction(function () {
            untracked(function () {
                _this.keys().forEach(_this.delete, _this);
            });
        });
    };
    ObservableMap.prototype.replace = function (values) {
        var _this = this;
        transaction(function () {
            // grab all the keys that are present in the new map but not present in the current map
            // and delete them from the map, then merge the new map
            // this will cause reactions only on changed values
            var newKeys = getMapLikeKeys(values);
            var oldKeys = _this.keys();
            var missingKeys = oldKeys.filter(function (k) { return newKeys.indexOf(k) === -1; });
            missingKeys.forEach(function (k) { return _this.delete(k); });
            _this.merge(values);
        });
        return this;
    };
    Object.defineProperty(ObservableMap.prototype, "size", {
        get: function () {
            return this._keys.length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns a shallow non observable object clone of this map.
     * Note that the values might still be observable. For a deep clone use mobx.toJS.
     */
    ObservableMap.prototype.toJS = function () {
        var _this = this;
        var res = {};
        this.keys().forEach(function (key) { return (res[key] = _this.get(key)); });
        return res;
    };
    ObservableMap.prototype.toJSON = function () {
        // Used by JSON.stringify
        return this.toJS();
    };
    ObservableMap.prototype.isValidKey = function (key) {
        if (key === null || key === undefined)
            return false;
        if (typeof key === "string" || typeof key === "number" || typeof key === "boolean")
            return true;
        return false;
    };
    ObservableMap.prototype.assertValidKey = function (key) {
        if (!this.isValidKey(key))
            throw new Error("[mobx.map] Invalid key: '" + key + "', only strings, numbers and booleans are accepted as key in observable maps.");
    };
    ObservableMap.prototype.toString = function () {
        var _this = this;
        return (this.name +
            "[{ " +
            this.keys().map(function (key) { return key + ": " + ("" + _this.get(key)); }).join(", ") +
            " }]");
    };
    /**
     * Observes this object. Triggers for the events 'add', 'update' and 'delete'.
     * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe
     * for callback details
     */
    ObservableMap.prototype.observe = function (listener, fireImmediately) {
        invariant(fireImmediately !== true, getMessage("m033"));
        return registerListener(this, listener);
    };
    ObservableMap.prototype.intercept = function (handler) {
        return registerInterceptor(this, handler);
    };
    return ObservableMap;
}());
declareIterator(ObservableMap.prototype, function () {
    return this.entries();
});
function map(initialValues) {
    deprecated("`mobx.map` is deprecated, use `new ObservableMap` or `mobx.observable.map` instead");
    return observable.map(initialValues);
}
/* 'var' fixes small-build issue */
var isObservableMap = createInstanceofPredicate("ObservableMap", ObservableMap);

var EMPTY_ARRAY = [];
Object.freeze(EMPTY_ARRAY);
function getGlobal() {
    return typeof window !== "undefined" ? window : global;
}
function getNextId() {
    return ++globalState.mobxGuid;
}
function fail(message, thing) {
    invariant(false, message, thing);
    throw "X"; // unreachable
}
function invariant(check, message, thing) {
    if (!check)
        throw new Error("[mobx] Invariant failed: " + message + (thing ? " in '" + thing + "'" : ""));
}
/**
 * Prints a deprecation message, but only one time.
 * Returns false if the deprecated message was already printed before
 */
var deprecatedMessages = [];
function deprecated(msg) {
    if (deprecatedMessages.indexOf(msg) !== -1)
        return false;
    deprecatedMessages.push(msg);
    console.error("[mobx] Deprecated: " + msg);
    return true;
}
/**
 * Makes sure that the provided function is invoked at most once.
 */
function once(func) {
    var invoked = false;
    return function () {
        if (invoked)
            return;
        invoked = true;
        return func.apply(this, arguments);
    };
}
var noop = function () { };
function unique(list) {
    var res = [];
    list.forEach(function (item) {
        if (res.indexOf(item) === -1)
            res.push(item);
    });
    return res;
}
function joinStrings(things, limit, separator) {
    if (limit === void 0) { limit = 100; }
    if (separator === void 0) { separator = " - "; }
    if (!things)
        return "";
    var sliced = things.slice(0, limit);
    return "" + sliced.join(separator) + (things.length > limit
        ? " (... and " + (things.length - limit) + "more)"
        : "");
}
function isObject(value) {
    return value !== null && typeof value === "object";
}
function isPlainObject(value) {
    if (value === null || typeof value !== "object")
        return false;
    var proto = Object.getPrototypeOf(value);
    return proto === Object.prototype || proto === null;
}
function objectAssign() {
    var res = arguments[0];
    for (var i = 1, l = arguments.length; i < l; i++) {
        var source = arguments[i];
        for (var key in source)
            if (hasOwnProperty(source, key)) {
                res[key] = source[key];
            }
    }
    return res;
}
var prototypeHasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwnProperty(object, propName) {
    return prototypeHasOwnProperty.call(object, propName);
}
function makeNonEnumerable(object, propNames) {
    for (var i = 0; i < propNames.length; i++) {
        addHiddenProp(object, propNames[i], object[propNames[i]]);
    }
}
function addHiddenProp(object, propName, value) {
    Object.defineProperty(object, propName, {
        enumerable: false,
        writable: true,
        configurable: true,
        value: value
    });
}
function addHiddenFinalProp(object, propName, value) {
    Object.defineProperty(object, propName, {
        enumerable: false,
        writable: false,
        configurable: true,
        value: value
    });
}
function isPropertyConfigurable(object, prop) {
    var descriptor = Object.getOwnPropertyDescriptor(object, prop);
    return !descriptor || (descriptor.configurable !== false && descriptor.writable !== false);
}
function assertPropertyConfigurable(object, prop) {
    invariant(isPropertyConfigurable(object, prop), "Cannot make property '" + prop + "' observable, it is not configurable and writable in the target object");
}
function getEnumerableKeys(obj) {
    var res = [];
    for (var key in obj)
        res.push(key);
    return res;
}
/**
 * Naive deepEqual. Doesn't check for prototype, non-enumerable or out-of-range properties on arrays.
 * If you have such a case, you probably should use this function but something fancier :).
 */
function deepEqual(a, b) {
    if (a === null && b === null)
        return true;
    if (a === undefined && b === undefined)
        return true;
    if (areBothNaN(a, b))
        return true;
    if (typeof a !== "object")
        return a === b;
    var aIsArray = isArrayLike(a);
    var aIsMap = isMapLike(a);
    if (aIsArray !== isArrayLike(b)) {
        return false;
    }
    else if (aIsMap !== isMapLike(b)) {
        return false;
    }
    else if (aIsArray) {
        if (a.length !== b.length)
            return false;
        for (var i = a.length - 1; i >= 0; i--)
            if (!deepEqual(a[i], b[i]))
                return false;
        return true;
    }
    else if (aIsMap) {
        if (a.size !== b.size)
            return false;
        var equals_1 = true;
        a.forEach(function (value, key) {
            equals_1 = equals_1 && deepEqual(b.get(key), value);
        });
        return equals_1;
    }
    else if (typeof a === "object" && typeof b === "object") {
        if (a === null || b === null)
            return false;
        if (isMapLike(a) && isMapLike(b)) {
            if (a.size !== b.size)
                return false;
            // Freaking inefficient.... Create PR if you run into this :) Much appreciated!
            return deepEqual(observable.shallowMap(a).entries(), observable.shallowMap(b).entries());
        }
        if (getEnumerableKeys(a).length !== getEnumerableKeys(b).length)
            return false;
        for (var prop in a) {
            if (!(prop in b))
                return false;
            if (!deepEqual(a[prop], b[prop]))
                return false;
        }
        return true;
    }
    return false;
}
function createInstanceofPredicate(name, clazz) {
    var propName = "isMobX" + name;
    clazz.prototype[propName] = true;
    return function (x) {
        return isObject(x) && x[propName] === true;
    };
}
function areBothNaN(a, b) {
    return (typeof a === "number" && typeof b === "number" && isNaN(a) && isNaN(b));
}
/**
 * Returns whether the argument is an array, disregarding observability.
 */
function isArrayLike(x) {
    return Array.isArray(x) || isObservableArray(x);
}
function isMapLike(x) {
    return isES6Map(x) || isObservableMap(x);
}
function isES6Map(thing) {
    if (getGlobal().Map !== undefined && thing instanceof getGlobal().Map)
        return true;
    return false;
}
function getMapLikeKeys(map$$1) {
    var keys;
    if (isPlainObject(map$$1))
        keys = Object.keys(map$$1);
    else if (Array.isArray(map$$1))
        keys = map$$1.map(function (_a) {
            var key = _a[0];
            return key;
        });
    else if (isMapLike(map$$1))
        keys = Array.from(map$$1.keys());
    else
        fail("Cannot get keys from " + map$$1);
    return keys;
}
function primitiveSymbol() {
    return (typeof Symbol === "function" && Symbol.toPrimitive) || "@@toPrimitive";
}
function toPrimitive(value) {
    return value === null ? null : typeof value === "object" ? "" + value : value;
}

/**
 * These values will persist if global state is reset
 */
var persistentKeys = ["mobxGuid", "resetId", "spyListeners", "strictMode", "runId"];
var MobXGlobals = (function () {
    function MobXGlobals() {
        /**
         * MobXGlobals version.
         * MobX compatiblity with other versions loaded in memory as long as this version matches.
         * It indicates that the global state still stores similar information
         */
        this.version = 5;
        /**
         * Currently running derivation
         */
        this.trackingDerivation = null;
        /**
         * Are we running a computation currently? (not a reaction)
         */
        this.computationDepth = 0;
        /**
         * Each time a derivation is tracked, it is assigned a unique run-id
         */
        this.runId = 0;
        /**
         * 'guid' for general purpose. Will be persisted amongst resets.
         */
        this.mobxGuid = 0;
        /**
         * Are we in a batch block? (and how many of them)
         */
        this.inBatch = 0;
        /**
         * Observables that don't have observers anymore, and are about to be
         * suspended, unless somebody else accesses it in the same batch
         *
         * @type {IObservable[]}
         */
        this.pendingUnobservations = [];
        /**
         * List of scheduled, not yet executed, reactions.
         */
        this.pendingReactions = [];
        /**
         * Are we currently processing reactions?
         */
        this.isRunningReactions = false;
        /**
         * Is it allowed to change observables at this point?
         * In general, MobX doesn't allow that when running computations and React.render.
         * To ensure that those functions stay pure.
         */
        this.allowStateChanges = true;
        /**
         * If strict mode is enabled, state changes are by default not allowed
         */
        this.strictMode = false;
        /**
         * Used by createTransformer to detect that the global state has been reset.
         */
        this.resetId = 0;
        /**
         * Spy callbacks
         */
        this.spyListeners = [];
        /**
         * Globally attached error handlers that react specifically to errors in reactions
         */
        this.globalReactionErrorHandlers = [];
    }
    return MobXGlobals;
}());
var globalState = new MobXGlobals();
var shareGlobalStateCalled = false;
var runInIsolationCalled = false;
var warnedAboutMultipleInstances = false;
{
    var global_1 = getGlobal();
    if (!global_1.__mobxInstanceCount) {
        global_1.__mobxInstanceCount = 1;
    }
    else {
        global_1.__mobxInstanceCount++;
        setTimeout(function () {
            if (!shareGlobalStateCalled && !runInIsolationCalled && !warnedAboutMultipleInstances) {
                warnedAboutMultipleInstances = true;
                console.warn("[mobx] Warning: there are multiple mobx instances active. This might lead to unexpected results. See https://github.com/mobxjs/mobx/issues/1082 for details.");
            }
        });
    }
}
function isolateGlobalState() {
    runInIsolationCalled = true;
    getGlobal().__mobxInstanceCount--;
}
function shareGlobalState() {
    // TODO: remove in 4.0; just use peer dependencies instead.
    deprecated("Using `shareGlobalState` is not recommended, use peer dependencies instead. See https://github.com/mobxjs/mobx/issues/1082 for details.");
    shareGlobalStateCalled = true;
    var global = getGlobal();
    var ownState = globalState;
    /**
     * Backward compatibility check
     */
    if (global.__mobservableTrackingStack || global.__mobservableViewStack)
        throw new Error("[mobx] An incompatible version of mobservable is already loaded.");
    if (global.__mobxGlobal && global.__mobxGlobal.version !== ownState.version)
        throw new Error("[mobx] An incompatible version of mobx is already loaded.");
    if (global.__mobxGlobal)
        globalState = global.__mobxGlobal;
    else
        global.__mobxGlobal = ownState;
}
function getGlobalState() {
    return globalState;
}

/**
 * For testing purposes only; this will break the internal state of existing observables,
 * but can be used to get back at a stable state after throwing errors
 */
function resetGlobalState() {
    globalState.resetId++;
    var defaultGlobals = new MobXGlobals();
    for (var key in defaultGlobals)
        if (persistentKeys.indexOf(key) === -1)
            globalState[key] = defaultGlobals[key];
    globalState.allowStateChanges = !globalState.strictMode;
}

function getAtom(thing, property) {
    if (typeof thing === "object" && thing !== null) {
        if (isObservableArray(thing)) {
            invariant(property === undefined, getMessage("m036"));
            return thing.$mobx.atom;
        }
        if (isObservableMap(thing)) {
            var anyThing = thing;
            if (property === undefined)
                return getAtom(anyThing._keys);
            var observable = anyThing._data[property] || anyThing._hasMap[property];
            invariant(!!observable, "the entry '" + property + "' does not exist in the observable map '" + getDebugName(thing) + "'");
            return observable;
        }
        // Initializers run lazily when transpiling to babel, so make sure they are run...
        runLazyInitializers(thing);
        if (property && !thing.$mobx)
            thing[property]; // See #1072 // TODO: remove in 4.0
        if (isObservableObject(thing)) {
            if (!property)
                return fail("please specify a property");
            var observable = thing.$mobx.values[property];
            invariant(!!observable, "no observable property '" + property + "' found on the observable object '" + getDebugName(thing) + "'");
            return observable;
        }
        if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
            return thing;
        }
    }
    else if (typeof thing === "function") {
        if (isReaction(thing.$mobx)) {
            // disposer function
            return thing.$mobx;
        }
    }
    return fail("Cannot obtain atom from " + thing);
}
function getAdministration(thing, property) {
    invariant(thing, "Expecting some object");
    if (property !== undefined)
        return getAdministration(getAtom(thing, property));
    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing))
        return thing;
    if (isObservableMap(thing))
        return thing;
    // Initializers run lazily when transpiling to babel, so make sure they are run...
    runLazyInitializers(thing);
    if (thing.$mobx)
        return thing.$mobx;
    invariant(false, "Cannot obtain administration from " + thing);
}
function getDebugName(thing, property) {
    var named;
    if (property !== undefined)
        named = getAtom(thing, property);
    else if (isObservableObject(thing) || isObservableMap(thing))
        named = getAdministration(thing);
    else
        named = getAtom(thing); // valid for arrays as well
    return named.name;
}

function getDependencyTree(thing, property) {
    return nodeToDependencyTree(getAtom(thing, property));
}
function nodeToDependencyTree(node) {
    var result = {
        name: node.name
    };
    if (node.observing && node.observing.length > 0)
        result.dependencies = unique(node.observing).map(nodeToDependencyTree);
    return result;
}
function getObserverTree(thing, property) {
    return nodeToObserverTree(getAtom(thing, property));
}
function nodeToObserverTree(node) {
    var result = {
        name: node.name
    };
    if (hasObservers(node))
        result.observers = getObservers(node).map(nodeToObserverTree);
    return result;
}

function hasObservers(observable) {
    return observable.observers && observable.observers.length > 0;
}
function getObservers(observable) {
    return observable.observers;
}
function addObserver(observable, node) {
    // invariant(node.dependenciesState !== -1, "INTERNAL ERROR, can add only dependenciesState !== -1");
    // invariant(observable._observers.indexOf(node) === -1, "INTERNAL ERROR add already added node");
    // invariantObservers(observable);
    var l = observable.observers.length;
    if (l) {
        // because object assignment is relatively expensive, let's not store data about index 0.
        observable.observersIndexes[node.__mapid] = l;
    }
    observable.observers[l] = node;
    if (observable.lowestObserverState > node.dependenciesState)
        observable.lowestObserverState = node.dependenciesState;
    // invariantObservers(observable);
    // invariant(observable._observers.indexOf(node) !== -1, "INTERNAL ERROR didn't add node");
}
function removeObserver(observable, node) {
    // invariant(globalState.inBatch > 0, "INTERNAL ERROR, remove should be called only inside batch");
    // invariant(observable._observers.indexOf(node) !== -1, "INTERNAL ERROR remove already removed node");
    // invariantObservers(observable);
    if (observable.observers.length === 1) {
        // deleting last observer
        observable.observers.length = 0;
        queueForUnobservation(observable);
    }
    else {
        // deleting from _observersIndexes is straight forward, to delete from _observers, let's swap `node` with last element
        var list = observable.observers;
        var map = observable.observersIndexes;
        var filler = list.pop(); // get last element, which should fill the place of `node`, so the array doesn't have holes
        if (filler !== node) {
            // otherwise node was the last element, which already got removed from array
            var index = map[node.__mapid] || 0; // getting index of `node`. this is the only place we actually use map.
            if (index) {
                // map store all indexes but 0, see comment in `addObserver`
                map[filler.__mapid] = index;
            }
            else {
                delete map[filler.__mapid];
            }
            list[index] = filler;
        }
        delete map[node.__mapid];
    }
    // invariantObservers(observable);
    // invariant(observable._observers.indexOf(node) === -1, "INTERNAL ERROR remove already removed node2");
}
function queueForUnobservation(observable) {
    if (!observable.isPendingUnobservation) {
        // invariant(globalState.inBatch > 0, "INTERNAL ERROR, remove should be called only inside batch");
        // invariant(observable._observers.length === 0, "INTERNAL ERROR, should only queue for unobservation unobserved observables");
        observable.isPendingUnobservation = true;
        globalState.pendingUnobservations.push(observable);
    }
}
/**
 * Batch starts a transaction, at least for purposes of memoizing ComputedValues when nothing else does.
 * During a batch `onBecomeUnobserved` will be called at most once per observable.
 * Avoids unnecessary recalculations.
 */
function startBatch() {
    globalState.inBatch++;
}
function endBatch() {
    if (--globalState.inBatch === 0) {
        runReactions();
        // the batch is actually about to finish, all unobserving should happen here.
        var list = globalState.pendingUnobservations;
        for (var i = 0; i < list.length; i++) {
            var observable = list[i];
            observable.isPendingUnobservation = false;
            if (observable.observers.length === 0) {
                observable.onBecomeUnobserved();
                // NOTE: onBecomeUnobserved might push to `pendingUnobservations`
            }
        }
        globalState.pendingUnobservations = [];
    }
}
function reportObserved(observable) {
    var derivation = globalState.trackingDerivation;
    if (derivation !== null) {
        /**
         * Simple optimization, give each derivation run an unique id (runId)
         * Check if last time this observable was accessed the same runId is used
         * if this is the case, the relation is already known
         */
        if (derivation.runId !== observable.lastAccessedBy) {
            observable.lastAccessedBy = derivation.runId;
            derivation.newObserving[derivation.unboundDepsCount++] = observable;
        }
    }
    else if (observable.observers.length === 0) {
        queueForUnobservation(observable);
    }
}
/**
 * NOTE: current propagation mechanism will in case of self reruning autoruns behave unexpectedly
 * It will propagate changes to observers from previous run
 * It's hard or maybe impossible (with reasonable perf) to get it right with current approach
 * Hopefully self reruning autoruns aren't a feature people should depend on
 * Also most basic use cases should be ok
 */
// Called by Atom when its value changes
function propagateChanged(observable) {
    // invariantLOS(observable, "changed start");
    if (observable.lowestObserverState === IDerivationState.STALE)
        return;
    observable.lowestObserverState = IDerivationState.STALE;
    var observers = observable.observers;
    var i = observers.length;
    while (i--) {
        var d = observers[i];
        if (d.dependenciesState === IDerivationState.UP_TO_DATE) {
            if (d.isTracing !== TraceMode.NONE) {
                logTraceInfo(d, observable);
            }
            d.onBecomeStale();
        }
        d.dependenciesState = IDerivationState.STALE;
    }
    // invariantLOS(observable, "changed end");
}
// Called by ComputedValue when it recalculate and its value changed
function propagateChangeConfirmed(observable) {
    // invariantLOS(observable, "confirmed start");
    if (observable.lowestObserverState === IDerivationState.STALE)
        return;
    observable.lowestObserverState = IDerivationState.STALE;
    var observers = observable.observers;
    var i = observers.length;
    while (i--) {
        var d = observers[i];
        if (d.dependenciesState === IDerivationState.POSSIBLY_STALE)
            d.dependenciesState = IDerivationState.STALE;
        else if (d.dependenciesState === IDerivationState.UP_TO_DATE // this happens during computing of `d`, just keep lowestObserverState up to date.
        )
            observable.lowestObserverState = IDerivationState.UP_TO_DATE;
    }
    // invariantLOS(observable, "confirmed end");
}
// Used by computed when its dependency changed, but we don't wan't to immediately recompute.
function propagateMaybeChanged(observable) {
    // invariantLOS(observable, "maybe start");
    if (observable.lowestObserverState !== IDerivationState.UP_TO_DATE)
        return;
    observable.lowestObserverState = IDerivationState.POSSIBLY_STALE;
    var observers = observable.observers;
    var i = observers.length;
    while (i--) {
        var d = observers[i];
        if (d.dependenciesState === IDerivationState.UP_TO_DATE) {
            d.dependenciesState = IDerivationState.POSSIBLY_STALE;
            if (d.isTracing !== TraceMode.NONE) {
                logTraceInfo(d, observable);
            }
            d.onBecomeStale();
        }
    }
    // invariantLOS(observable, "maybe end");
}
function logTraceInfo(derivation, observable) {
    console.log("[mobx.trace] '" + derivation.name + "' is invalidated due to a change in: '" + observable.name + "'");
    if (derivation.isTracing === TraceMode.BREAK) {
        var lines = [];
        printDepTree(getDependencyTree(derivation), lines, 1);
        // prettier-ignore
        new Function("debugger;\n/*\nTracing '" + derivation.name + "'\n\nYou are entering this break point because derivation '" + derivation.name + "' is being traced and '" + observable.name + "' is now forcing it to update.\nJust follow the stacktrace you should now see in the devtools to see precisely what piece of your code is causing this update\nThe stackframe you are looking for is at least ~6-8 stack-frames up.\n\n" + (derivation instanceof ComputedValue ? derivation.derivation.toString() : "") + "\n\nThe dependencies for this derivation are:\n\n" + lines.join("\n") + "\n*/\n    ")();
    }
}
function printDepTree(tree, lines, depth) {
    if (lines.length >= 1000) {
        lines.push("(and many more)");
        return;
    }
    lines.push("" + new Array(depth).join("\t") + tree.name); // MWE: not the fastest, but the easiest way :)
    if (tree.dependencies)
        tree.dependencies.forEach(function (child) { return printDepTree(child, lines, depth + 1); });
}

var IDerivationState;
(function (IDerivationState) {
    // before being run or (outside batch and not being observed)
    // at this point derivation is not holding any data about dependency tree
    IDerivationState[IDerivationState["NOT_TRACKING"] = -1] = "NOT_TRACKING";
    // no shallow dependency changed since last computation
    // won't recalculate derivation
    // this is what makes mobx fast
    IDerivationState[IDerivationState["UP_TO_DATE"] = 0] = "UP_TO_DATE";
    // some deep dependency changed, but don't know if shallow dependency changed
    // will require to check first if UP_TO_DATE or POSSIBLY_STALE
    // currently only ComputedValue will propagate POSSIBLY_STALE
    //
    // having this state is second big optimization:
    // don't have to recompute on every dependency change, but only when it's needed
    IDerivationState[IDerivationState["POSSIBLY_STALE"] = 1] = "POSSIBLY_STALE";
    // A shallow dependency has changed since last computation and the derivation
    // will need to recompute when it's needed next.
    IDerivationState[IDerivationState["STALE"] = 2] = "STALE";
})(IDerivationState || (IDerivationState = {}));
var TraceMode;
(function (TraceMode) {
    TraceMode[TraceMode["NONE"] = 0] = "NONE";
    TraceMode[TraceMode["LOG"] = 1] = "LOG";
    TraceMode[TraceMode["BREAK"] = 2] = "BREAK";
})(TraceMode || (TraceMode = {}));
var CaughtException = (function () {
    function CaughtException(cause) {
        this.cause = cause;
        // Empty
    }
    return CaughtException;
}());
function isCaughtException(e) {
    return e instanceof CaughtException;
}
/**
 * Finds out whether any dependency of the derivation has actually changed.
 * If dependenciesState is 1 then it will recalculate dependencies,
 * if any dependency changed it will propagate it by changing dependenciesState to 2.
 *
 * By iterating over the dependencies in the same order that they were reported and
 * stopping on the first change, all the recalculations are only called for ComputedValues
 * that will be tracked by derivation. That is because we assume that if the first x
 * dependencies of the derivation doesn't change then the derivation should run the same way
 * up until accessing x-th dependency.
 */
function shouldCompute(derivation) {
    switch (derivation.dependenciesState) {
        case IDerivationState.UP_TO_DATE:
            return false;
        case IDerivationState.NOT_TRACKING:
        case IDerivationState.STALE:
            return true;
        case IDerivationState.POSSIBLY_STALE: {
            var prevUntracked = untrackedStart(); // no need for those computeds to be reported, they will be picked up in trackDerivedFunction.
            var obs = derivation.observing, l = obs.length;
            for (var i = 0; i < l; i++) {
                var obj = obs[i];
                if (isComputedValue(obj)) {
                    try {
                        obj.get();
                    }
                    catch (e) {
                        // we are not interested in the value *or* exception at this moment, but if there is one, notify all
                        untrackedEnd(prevUntracked);
                        return true;
                    }
                    // if ComputedValue `obj` actually changed it will be computed and propagated to its observers.
                    // and `derivation` is an observer of `obj`
                    if (derivation.dependenciesState === IDerivationState.STALE) {
                        untrackedEnd(prevUntracked);
                        return true;
                    }
                }
            }
            changeDependenciesStateTo0(derivation);
            untrackedEnd(prevUntracked);
            return false;
        }
    }
}
function isComputingDerivation() {
    return globalState.trackingDerivation !== null; // filter out actions inside computations
}
function checkIfStateModificationsAreAllowed(atom) {
    var hasObservers$$1 = atom.observers.length > 0;
    // Should never be possible to change an observed observable from inside computed, see #798
    if (globalState.computationDepth > 0 && hasObservers$$1)
        fail(getMessage("m031") + atom.name);
    // Should not be possible to change observed state outside strict mode, except during initialization, see #563
    if (!globalState.allowStateChanges && hasObservers$$1)
        fail(getMessage(globalState.strictMode ? "m030a" : "m030b") + atom.name);
}
/**
 * Executes the provided function `f` and tracks which observables are being accessed.
 * The tracking information is stored on the `derivation` object and the derivation is registered
 * as observer of any of the accessed observables.
 */
function trackDerivedFunction(derivation, f, context) {
    // pre allocate array allocation + room for variation in deps
    // array will be trimmed by bindDependencies
    changeDependenciesStateTo0(derivation);
    derivation.newObserving = new Array(derivation.observing.length + 100);
    derivation.unboundDepsCount = 0;
    derivation.runId = ++globalState.runId;
    var prevTracking = globalState.trackingDerivation;
    globalState.trackingDerivation = derivation;
    var result;
    try {
        result = f.call(context);
    }
    catch (e) {
        result = new CaughtException(e);
    }
    globalState.trackingDerivation = prevTracking;
    bindDependencies(derivation);
    return result;
}
/**
 * diffs newObserving with observing.
 * update observing to be newObserving with unique observables
 * notify observers that become observed/unobserved
 */
function bindDependencies(derivation) {
    // invariant(derivation.dependenciesState !== IDerivationState.NOT_TRACKING, "INTERNAL ERROR bindDependencies expects derivation.dependenciesState !== -1");
    var prevObserving = derivation.observing;
    var observing = (derivation.observing = derivation.newObserving);
    var lowestNewObservingDerivationState = IDerivationState.UP_TO_DATE;
    // Go through all new observables and check diffValue: (this list can contain duplicates):
    //   0: first occurrence, change to 1 and keep it
    //   1: extra occurrence, drop it
    var i0 = 0, l = derivation.unboundDepsCount;
    for (var i = 0; i < l; i++) {
        var dep = observing[i];
        if (dep.diffValue === 0) {
            dep.diffValue = 1;
            if (i0 !== i)
                observing[i0] = dep;
            i0++;
        }
        // Upcast is 'safe' here, because if dep is IObservable, `dependenciesState` will be undefined,
        // not hitting the condition
        if (dep.dependenciesState > lowestNewObservingDerivationState) {
            lowestNewObservingDerivationState = dep.dependenciesState;
        }
    }
    observing.length = i0;
    derivation.newObserving = null; // newObserving shouldn't be needed outside tracking (statement moved down to work around FF bug, see #614)
    // Go through all old observables and check diffValue: (it is unique after last bindDependencies)
    //   0: it's not in new observables, unobserve it
    //   1: it keeps being observed, don't want to notify it. change to 0
    l = prevObserving.length;
    while (l--) {
        var dep = prevObserving[l];
        if (dep.diffValue === 0) {
            removeObserver(dep, derivation);
        }
        dep.diffValue = 0;
    }
    // Go through all new observables and check diffValue: (now it should be unique)
    //   0: it was set to 0 in last loop. don't need to do anything.
    //   1: it wasn't observed, let's observe it. set back to 0
    while (i0--) {
        var dep = observing[i0];
        if (dep.diffValue === 1) {
            dep.diffValue = 0;
            addObserver(dep, derivation);
        }
    }
    // Some new observed derivations may become stale during this derivation computation
    // so they have had no chance to propagate staleness (#916)
    if (lowestNewObservingDerivationState !== IDerivationState.UP_TO_DATE) {
        derivation.dependenciesState = lowestNewObservingDerivationState;
        derivation.onBecomeStale();
    }
}
function clearObserving(derivation) {
    // invariant(globalState.inBatch > 0, "INTERNAL ERROR clearObserving should be called only inside batch");
    var obs = derivation.observing;
    derivation.observing = [];
    var i = obs.length;
    while (i--)
        removeObserver(obs[i], derivation);
    derivation.dependenciesState = IDerivationState.NOT_TRACKING;
}
function untracked(action) {
    var prev = untrackedStart();
    var res = action();
    untrackedEnd(prev);
    return res;
}
function untrackedStart() {
    var prev = globalState.trackingDerivation;
    globalState.trackingDerivation = null;
    return prev;
}
function untrackedEnd(prev) {
    globalState.trackingDerivation = prev;
}
/**
 * needed to keep `lowestObserverState` correct. when changing from (2 or 1) to 0
 *
 */
function changeDependenciesStateTo0(derivation) {
    if (derivation.dependenciesState === IDerivationState.UP_TO_DATE)
        return;
    derivation.dependenciesState = IDerivationState.UP_TO_DATE;
    var obs = derivation.observing;
    var i = obs.length;
    while (i--)
        obs[i].lowestObserverState = IDerivationState.UP_TO_DATE;
}

function log(msg) {
    console.log(msg);
    return msg;
}
function whyRun(thing, prop) {
    deprecated("`whyRun` is deprecated in favor of `trace`");
    thing = getAtomFromArgs(arguments);
    if (!thing)
        return log(getMessage("m024"));
    if (isComputedValue(thing) || isReaction(thing))
        return log(thing.whyRun());
    return fail(getMessage("m025"));
}
function trace() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var enterBreakPoint = false;
    if (typeof args[args.length - 1] === "boolean")
        enterBreakPoint = args.pop();
    var derivation = getAtomFromArgs(args);
    if (!derivation) {
        return fail("'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly");
    }
    if (derivation.isTracing === TraceMode.NONE) {
        console.log("[mobx.trace] '" + derivation.name + "' tracing enabled");
    }
    derivation.isTracing = enterBreakPoint ? TraceMode.BREAK : TraceMode.LOG;
}
function getAtomFromArgs(args) {
    switch (args.length) {
        case 0:
            return globalState.trackingDerivation;
        case 1:
            return getAtom(args[0]);
        case 2:
            return getAtom(args[0], args[1]);
    }
}

var Reaction = (function () {
    function Reaction(name, onInvalidate) {
        if (name === void 0) { name = "Reaction@" + getNextId(); }
        this.name = name;
        this.onInvalidate = onInvalidate;
        this.observing = []; // nodes we are looking at. Our value depends on these nodes
        this.newObserving = [];
        this.dependenciesState = IDerivationState.NOT_TRACKING;
        this.diffValue = 0;
        this.runId = 0;
        this.unboundDepsCount = 0;
        this.__mapid = "#" + getNextId();
        this.isDisposed = false;
        this._isScheduled = false;
        this._isTrackPending = false;
        this._isRunning = false;
        this.isTracing = TraceMode.NONE;
    }
    Reaction.prototype.onBecomeStale = function () {
        this.schedule();
    };
    Reaction.prototype.schedule = function () {
        if (!this._isScheduled) {
            this._isScheduled = true;
            globalState.pendingReactions.push(this);
            runReactions();
        }
    };
    Reaction.prototype.isScheduled = function () {
        return this._isScheduled;
    };
    /**
     * internal, use schedule() if you intend to kick off a reaction
     */
    Reaction.prototype.runReaction = function () {
        if (!this.isDisposed) {
            startBatch();
            this._isScheduled = false;
            if (shouldCompute(this)) {
                this._isTrackPending = true;
                this.onInvalidate();
                if (this._isTrackPending && isSpyEnabled()) {
                    // onInvalidate didn't trigger track right away..
                    spyReport({
                        object: this,
                        type: "scheduled-reaction"
                    });
                }
            }
            endBatch();
        }
    };
    Reaction.prototype.track = function (fn) {
        startBatch();
        var notify = isSpyEnabled();
        var startTime;
        if (notify) {
            startTime = Date.now();
            spyReportStart({
                object: this,
                type: "reaction",
                fn: fn
            });
        }
        this._isRunning = true;
        var result = trackDerivedFunction(this, fn, undefined);
        this._isRunning = false;
        this._isTrackPending = false;
        if (this.isDisposed) {
            // disposed during last run. Clean up everything that was bound after the dispose call.
            clearObserving(this);
        }
        if (isCaughtException(result))
            this.reportExceptionInDerivation(result.cause);
        if (notify) {
            spyReportEnd({
                time: Date.now() - startTime
            });
        }
        endBatch();
    };
    Reaction.prototype.reportExceptionInDerivation = function (error) {
        var _this = this;
        if (this.errorHandler) {
            this.errorHandler(error, this);
            return;
        }
        var message = "[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '" + this;
        var messageToUser = getMessage("m037");
        console.error(message || messageToUser /* latter will not be true, make sure uglify doesn't remove */, error);
        /** If debugging brought you here, please, read the above message :-). Tnx! */
        if (isSpyEnabled()) {
            spyReport({
                type: "error",
                message: message,
                error: error,
                object: this
            });
        }
        globalState.globalReactionErrorHandlers.forEach(function (f) { return f(error, _this); });
    };
    Reaction.prototype.dispose = function () {
        if (!this.isDisposed) {
            this.isDisposed = true;
            if (!this._isRunning) {
                // if disposed while running, clean up later. Maybe not optimal, but rare case
                startBatch();
                clearObserving(this);
                endBatch();
            }
        }
    };
    Reaction.prototype.getDisposer = function () {
        var r = this.dispose.bind(this);
        r.$mobx = this;
        r.onError = registerErrorHandler;
        return r;
    };
    Reaction.prototype.toString = function () {
        return "Reaction[" + this.name + "]";
    };
    Reaction.prototype.whyRun = function () {
        var observing = unique(this._isRunning ? this.newObserving : this.observing).map(function (dep) { return dep.name; });
        return "\nWhyRun? reaction '" + this.name + "':\n * Status: [" + (this.isDisposed
            ? "stopped"
            : this._isRunning ? "running" : this.isScheduled() ? "scheduled" : "idle") + "]\n * This reaction will re-run if any of the following observables changes:\n    " + joinStrings(observing) + "\n    " + (this._isRunning
            ? " (... or any observable accessed during the remainder of the current run)"
            : "") + "\n\t" + getMessage("m038") + "\n";
    };
    Reaction.prototype.trace = function (enterBreakPoint) {
        if (enterBreakPoint === void 0) { enterBreakPoint = false; }
        trace(this, enterBreakPoint);
    };
    return Reaction;
}());
function registerErrorHandler(handler) {
    invariant(this && this.$mobx && isReaction(this.$mobx), "Invalid `this`");
    invariant(!this.$mobx.errorHandler, "Only one onErrorHandler can be registered");
    this.$mobx.errorHandler = handler;
}
function onReactionError(handler) {
    globalState.globalReactionErrorHandlers.push(handler);
    return function () {
        var idx = globalState.globalReactionErrorHandlers.indexOf(handler);
        if (idx >= 0)
            globalState.globalReactionErrorHandlers.splice(idx, 1);
    };
}
/**
 * Magic number alert!
 * Defines within how many times a reaction is allowed to re-trigger itself
 * until it is assumed that this is gonna be a never ending loop...
 */
var MAX_REACTION_ITERATIONS = 100;
var reactionScheduler = function (f) { return f(); };
function runReactions() {
    // Trampolining, if runReactions are already running, new reactions will be picked up
    if (globalState.inBatch > 0 || globalState.isRunningReactions)
        return;
    reactionScheduler(runReactionsHelper);
}
function runReactionsHelper() {
    globalState.isRunningReactions = true;
    var allReactions = globalState.pendingReactions;
    var iterations = 0;
    // While running reactions, new reactions might be triggered.
    // Hence we work with two variables and check whether
    // we converge to no remaining reactions after a while.
    while (allReactions.length > 0) {
        if (++iterations === MAX_REACTION_ITERATIONS) {
            console.error("Reaction doesn't converge to a stable state after " + MAX_REACTION_ITERATIONS + " iterations." +
                (" Probably there is a cycle in the reactive function: " + allReactions[0]));
            allReactions.splice(0); // clear reactions
        }
        var remainingReactions = allReactions.splice(0);
        for (var i = 0, l = remainingReactions.length; i < l; i++)
            remainingReactions[i].runReaction();
    }
    globalState.isRunningReactions = false;
}
var isReaction = createInstanceofPredicate("Reaction", Reaction);
function setReactionScheduler(fn) {
    var baseScheduler = reactionScheduler;
    reactionScheduler = function (f) { return fn(function () { return baseScheduler(f); }); };
}

function asReference(value) {
    deprecated("asReference is deprecated, use observable.ref instead");
    return observable.ref(value);
}
function asStructure(value) {
    deprecated("asStructure is deprecated. Use observable.struct, computed.struct or reaction options instead.");
    return observable.struct(value);
}
function asFlat(value) {
    deprecated("asFlat is deprecated, use observable.shallow instead");
    return observable.shallow(value);
}
function asMap(data) {
    deprecated("asMap is deprecated, use observable.map or observable.shallowMap instead");
    return observable.map(data || {});
}

function createComputedDecorator(equals) {
    return createClassPropertyDecorator(function (target, name, _, __, originalDescriptor) {
        invariant(typeof originalDescriptor !== "undefined", getMessage("m009"));
        invariant(typeof originalDescriptor.get === "function", getMessage("m010"));
        var adm = asObservableObject(target, "");
        defineComputedProperty(adm, name, originalDescriptor.get, originalDescriptor.set, equals, false);
    }, function (name) {
        var observable = this.$mobx.values[name];
        if (observable === undefined // See #505
        )
            return undefined;
        return observable.get();
    }, function (name, value) {
        this.$mobx.values[name].set(value);
    }, false, false);
}
var computedDecorator = createComputedDecorator(comparer.default);
var computedStructDecorator = createComputedDecorator(comparer.structural);
/**
 * Decorator for class properties: @computed get value() { return expr; }.
 * For legacy purposes also invokable as ES5 observable created: `computed(() => expr)`;
 */
var computed = function computed(arg1, arg2, arg3) {
    if (typeof arg2 === "string") {
        return computedDecorator.apply(null, arguments);
    }
    invariant(typeof arg1 === "function", getMessage("m011"));
    invariant(arguments.length < 3, getMessage("m012"));
    var opts = typeof arg2 === "object" ? arg2 : {};
    opts.setter = typeof arg2 === "function" ? arg2 : opts.setter;
    var equals = opts.equals
        ? opts.equals
        : opts.compareStructural || opts.struct ? comparer.structural : comparer.default;
    return new ComputedValue(arg1, opts.context, equals, opts.name || arg1.name || "", opts.setter);
};
computed.struct = computedStructDecorator;
computed.equals = createComputedDecorator;

function isComputed(value, property) {
    if (value === null || value === undefined)
        return false;
    if (property !== undefined) {
        if (isObservableObject(value) === false)
            return false;
        if (!value.$mobx.values[property])
            return false;
        var atom = getAtom(value, property);
        return isComputedValue(atom);
    }
    return isComputedValue(value);
}

function observe(thing, propOrCb, cbOrFire, fireImmediately) {
    if (typeof cbOrFire === "function")
        return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);
    else
        return observeObservable(thing, propOrCb, cbOrFire);
}
function observeObservable(thing, listener, fireImmediately) {
    return getAdministration(thing).observe(listener, fireImmediately);
}
function observeObservableProperty(thing, property, listener, fireImmediately) {
    return getAdministration(thing, property).observe(listener, fireImmediately);
}

function intercept(thing, propOrHandler, handler) {
    if (typeof handler === "function")
        return interceptProperty(thing, propOrHandler, handler);
    else
        return interceptInterceptable(thing, propOrHandler);
}
function interceptInterceptable(thing, handler) {
    return getAdministration(thing).intercept(handler);
}
function interceptProperty(thing, property, handler) {
    return getAdministration(thing, property).intercept(handler);
}

/**
 * expr can be used to create temporarily views inside views.
 * This can be improved to improve performance if a value changes often, but usually doesn't affect the outcome of an expression.
 *
 * In the following example the expression prevents that a component is rerender _each time_ the selection changes;
 * instead it will only rerenders when the current todo is (de)selected.
 *
 * reactiveComponent((props) => {
 *     const todo = props.todo;
 *     const isSelected = mobx.expr(() => props.viewState.selection === todo);
 *     return <div className={isSelected ? "todo todo-selected" : "todo"}>{todo.title}</div>
 * });
 *
 */
function expr(expr, scope) {
    if (!isComputingDerivation())
        console.warn(getMessage("m013"));
    // optimization: would be more efficient if the expr itself wouldn't be evaluated first on the next change, but just a 'changed' signal would be fired
    return computed(expr, { context: scope }).get();
}

function toJS(source, detectCycles, __alreadySeen) {
    if (detectCycles === void 0) { detectCycles = true; }
    if (__alreadySeen === void 0) { __alreadySeen = []; }
    // optimization: using ES6 map would be more efficient!
    // optimization: lift this function outside toJS, this makes recursion expensive
    function cache(value) {
        if (detectCycles)
            __alreadySeen.push([source, value]);
        return value;
    }
    if (isObservable(source)) {
        if (detectCycles && __alreadySeen === null)
            __alreadySeen = [];
        if (detectCycles && source !== null && typeof source === "object") {
            for (var i = 0, l = __alreadySeen.length; i < l; i++)
                if (__alreadySeen[i][0] === source)
                    return __alreadySeen[i][1];
        }
        if (isObservableArray(source)) {
            var res = cache([]);
            var toAdd = source.map(function (value) { return toJS(value, detectCycles, __alreadySeen); });
            res.length = toAdd.length;
            for (var i = 0, l = toAdd.length; i < l; i++)
                res[i] = toAdd[i];
            return res;
        }
        if (isObservableObject(source)) {
            var res = cache({});
            for (var key in source)
                res[key] = toJS(source[key], detectCycles, __alreadySeen);
            return res;
        }
        if (isObservableMap(source)) {
            var res_1 = cache({});
            source.forEach(function (value, key) { return (res_1[key] = toJS(value, detectCycles, __alreadySeen)); });
            return res_1;
        }
        if (isObservableValue(source))
            return toJS(source.get(), detectCycles, __alreadySeen);
    }
    return source;
}

function createTransformer(transformer, onCleanup) {
    invariant(typeof transformer === "function" && transformer.length < 2, "createTransformer expects a function that accepts one argument");
    // Memoizes: object id -> reactive view that applies transformer to the object
    var objectCache = {};
    // If the resetId changes, we will clear the object cache, see #163
    // This construction is used to avoid leaking refs to the objectCache directly
    var resetId = globalState.resetId;
    // Local transformer class specifically for this transformer
    var Transformer = (function (_super) {
        __extends(Transformer, _super);
        function Transformer(sourceIdentifier, sourceObject) {
            var _this = _super.call(this, function () { return transformer(sourceObject); }, undefined, comparer.default, "Transformer-" + transformer.name + "-" + sourceIdentifier, undefined) || this;
            _this.sourceIdentifier = sourceIdentifier;
            _this.sourceObject = sourceObject;
            return _this;
        }
        Transformer.prototype.onBecomeUnobserved = function () {
            var lastValue = this.value;
            _super.prototype.onBecomeUnobserved.call(this);
            delete objectCache[this.sourceIdentifier];
            if (onCleanup)
                onCleanup(lastValue, this.sourceObject);
        };
        return Transformer;
    }(ComputedValue));
    return function (object) {
        if (resetId !== globalState.resetId) {
            objectCache = {};
            resetId = globalState.resetId;
        }
        var identifier = getMemoizationId(object);
        var reactiveTransformer = objectCache[identifier];
        if (reactiveTransformer)
            return reactiveTransformer.get();
        // Not in cache; create a reactive view
        reactiveTransformer = objectCache[identifier] = new Transformer(identifier, object);
        return reactiveTransformer.get();
    };
}
function getMemoizationId(object) {
    if (typeof object === "string" || typeof object === "number")
        return object;
    if (object === null || typeof object !== "object")
        throw new Error("[mobx] transform expected some kind of object or primitive value, got: " + object);
    var tid = object.$transformId;
    if (tid === undefined) {
        tid = getNextId();
        addHiddenProp(object, "$transformId", tid);
    }
    return tid;
}

function interceptReads(thing, propOrHandler, handler) {
    var target;
    if (isObservableMap(thing) || isObservableArray(thing) || isObservableValue(thing)) {
        target = getAdministration(thing);
    }
    else if (isObservableObject(thing)) {
        if (typeof propOrHandler !== "string")
            return fail("InterceptReads can only be used with a specific property, not with an object in general");
        target = getAdministration(thing, propOrHandler);
    }
    else {
        return fail("Expected observable map, object or array as first array");
    }
    if (target.dehancer !== undefined)
        return fail("An intercept reader was already established");
    target.dehancer = typeof propOrHandler === "function" ? propOrHandler : handler;
    return function () {
        target.dehancer = undefined;
    };
}

/**
 * (c) Michel Weststrate 2015 - 2016
 * MIT Licensed
 *
 * Welcome to the mobx sources! To get an global overview of how MobX internally works,
 * this is a good place to start:
 * https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254#.xvbh6qd74
 *
 * Source folders:
 * ===============
 *
 * - api/     Most of the public static methods exposed by the module can be found here.
 * - core/    Implementation of the MobX algorithm; atoms, derivations, reactions, dependency trees, optimizations. Cool stuff can be found here.
 * - types/   All the magic that is need to have observable objects, arrays and values is in this folder. Including the modifiers like `asFlat`.
 * - utils/   Utility stuff.
 *
 */
var extras = {
    allowStateChanges: allowStateChanges,
    deepEqual: deepEqual,
    getAtom: getAtom,
    getDebugName: getDebugName,
    getDependencyTree: getDependencyTree,
    getAdministration: getAdministration,
    getGlobalState: getGlobalState,
    getObserverTree: getObserverTree,
    interceptReads: interceptReads,
    isComputingDerivation: isComputingDerivation,
    isSpyEnabled: isSpyEnabled,
    onReactionError: onReactionError,
    reserveArrayBuffer: reserveArrayBuffer,
    resetGlobalState: resetGlobalState,
    isolateGlobalState: isolateGlobalState,
    shareGlobalState: shareGlobalState,
    spyReport: spyReport,
    spyReportEnd: spyReportEnd,
    spyReportStart: spyReportStart,
    setReactionScheduler: setReactionScheduler
};
var everything = {
    Reaction: Reaction,
    untracked: untracked,
    Atom: Atom,
    BaseAtom: BaseAtom,
    useStrict: useStrict,
    isStrictModeEnabled: isStrictModeEnabled,
    spy: spy,
    comparer: comparer,
    asReference: asReference,
    asFlat: asFlat,
    asStructure: asStructure,
    asMap: asMap,
    isModifierDescriptor: isModifierDescriptor,
    isObservableObject: isObservableObject,
    isBoxedObservable: isObservableValue,
    isObservableArray: isObservableArray,
    ObservableMap: ObservableMap,
    isObservableMap: isObservableMap,
    map: map,
    transaction: transaction,
    observable: observable,
    computed: computed,
    isObservable: isObservable,
    isComputed: isComputed,
    extendObservable: extendObservable,
    extendShallowObservable: extendShallowObservable,
    observe: observe,
    intercept: intercept,
    autorun: autorun,
    autorunAsync: autorunAsync,
    when: when,
    reaction: reaction,
    action: action,
    isAction: isAction,
    runInAction: runInAction,
    expr: expr,
    toJS: toJS,
    createTransformer: createTransformer,
    whyRun: whyRun,
    isArrayLike: isArrayLike,
    extras: extras
};
var warnedAboutDefaultExport = false;
var _loop_1 = function (p) {
    var val = everything[p];
    Object.defineProperty(everything, p, {
        get: function () {
            if (!warnedAboutDefaultExport) {
                warnedAboutDefaultExport = true;
                console.warn("Using default export (`import mobx from 'mobx'`) is deprecated " +
                    "and wont work in mobx@4.0.0\n" +
                    "Use `import * as mobx from 'mobx'` instead");
            }
            return val;
        }
    });
};
for (var p in everything) {
    _loop_1(p);
}
if (typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === "object") {
    __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({ spy: spy, extras: extras });
}

/* harmony default export */ __webpack_exports__["default"] = (everything);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  var invariant = __webpack_require__(/*! fbjs/lib/invariant */ "./node_modules/fbjs/lib/invariant.js");
  var warning = __webpack_require__(/*! fbjs/lib/warning */ "./node_modules/fbjs/lib/warning.js");
  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
  var loggedTypeFailures = {};
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (true) {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, typeof typeSpecs[typeSpecName]);
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
        }
      }
    }
  }
}

module.exports = checkPropTypes;


/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "./node_modules/react-dom/cjs/react-dom.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom.development.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.2.0
 * react-dom.development.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var invariant = __webpack_require__(/*! fbjs/lib/invariant */ "./node_modules/fbjs/lib/invariant.js");
var warning = __webpack_require__(/*! fbjs/lib/warning */ "./node_modules/fbjs/lib/warning.js");
var ExecutionEnvironment = __webpack_require__(/*! fbjs/lib/ExecutionEnvironment */ "./node_modules/fbjs/lib/ExecutionEnvironment.js");
var _assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");
var emptyFunction = __webpack_require__(/*! fbjs/lib/emptyFunction */ "./node_modules/fbjs/lib/emptyFunction.js");
var EventListener = __webpack_require__(/*! fbjs/lib/EventListener */ "./node_modules/fbjs/lib/EventListener.js");
var getActiveElement = __webpack_require__(/*! fbjs/lib/getActiveElement */ "./node_modules/fbjs/lib/getActiveElement.js");
var shallowEqual = __webpack_require__(/*! fbjs/lib/shallowEqual */ "./node_modules/fbjs/lib/shallowEqual.js");
var containsNode = __webpack_require__(/*! fbjs/lib/containsNode */ "./node_modules/fbjs/lib/containsNode.js");
var focusNode = __webpack_require__(/*! fbjs/lib/focusNode */ "./node_modules/fbjs/lib/focusNode.js");
var emptyObject = __webpack_require__(/*! fbjs/lib/emptyObject */ "./node_modules/fbjs/lib/emptyObject.js");
var checkPropTypes = __webpack_require__(/*! prop-types/checkPropTypes */ "./node_modules/prop-types/checkPropTypes.js");
var hyphenateStyleName = __webpack_require__(/*! fbjs/lib/hyphenateStyleName */ "./node_modules/fbjs/lib/hyphenateStyleName.js");
var camelizeStyleName = __webpack_require__(/*! fbjs/lib/camelizeStyleName */ "./node_modules/fbjs/lib/camelizeStyleName.js");

/**
 * WARNING: DO NOT manually require this module.
 * This is a replacement for `invariant(...)` used by the error code system
 * and will _only_ be required by the corresponding babel pass.
 * It always throws.
 */

!React ? invariant(false, 'ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.') : void 0;

// These attributes should be all lowercase to allow for
// case insensitive checks
var RESERVED_PROPS = {
  children: true,
  dangerouslySetInnerHTML: true,
  defaultValue: true,
  defaultChecked: true,
  innerHTML: true,
  suppressContentEditableWarning: true,
  suppressHydrationWarning: true,
  style: true
};

function checkMask(value, bitmask) {
  return (value & bitmask) === bitmask;
}

var DOMPropertyInjection = {
  /**
   * Mapping from normalized, camelcased property names to a configuration that
   * specifies how the associated DOM property should be accessed or rendered.
   */
  MUST_USE_PROPERTY: 0x1,
  HAS_BOOLEAN_VALUE: 0x4,
  HAS_NUMERIC_VALUE: 0x8,
  HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
  HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,
  HAS_STRING_BOOLEAN_VALUE: 0x40,

  /**
   * Inject some specialized knowledge about the DOM. This takes a config object
   * with the following properties:
   *
   * Properties: object mapping DOM property name to one of the
   * DOMPropertyInjection constants or null. If your attribute isn't in here,
   * it won't get written to the DOM.
   *
   * DOMAttributeNames: object mapping React attribute name to the DOM
   * attribute name. Attribute names not specified use the **lowercase**
   * normalized name.
   *
   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
   * attribute namespace URL. (Attribute names not specified use no namespace.)
   *
   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
   * Property names not specified use the normalized name.
   *
   * DOMMutationMethods: Properties that require special mutation methods. If
   * `value` is undefined, the mutation method should unset the property.
   *
   * @param {object} domPropertyConfig the config as described above.
   */
  injectDOMPropertyConfig: function (domPropertyConfig) {
    var Injection = DOMPropertyInjection;
    var Properties = domPropertyConfig.Properties || {};
    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};

    for (var propName in Properties) {
      !!properties.hasOwnProperty(propName) ? invariant(false, "injectDOMPropertyConfig(...): You're trying to inject DOM property '%s' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.", propName) : void 0;

      var lowerCased = propName.toLowerCase();
      var propConfig = Properties[propName];

      var propertyInfo = {
        attributeName: lowerCased,
        attributeNamespace: null,
        propertyName: propName,
        mutationMethod: null,

        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE),
        hasStringBooleanValue: checkMask(propConfig, Injection.HAS_STRING_BOOLEAN_VALUE)
      };
      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? invariant(false, "DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s", propName) : void 0;

      if (DOMAttributeNames.hasOwnProperty(propName)) {
        var attributeName = DOMAttributeNames[propName];

        propertyInfo.attributeName = attributeName;
      }

      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
      }

      if (DOMMutationMethods.hasOwnProperty(propName)) {
        propertyInfo.mutationMethod = DOMMutationMethods[propName];
      }

      // Downcase references to whitelist properties to check for membership
      // without case-sensitivity. This allows the whitelist to pick up
      // `allowfullscreen`, which should be written using the property configuration
      // for `allowFullscreen`
      properties[propName] = propertyInfo;
    }
  }
};

/* eslint-disable max-len */
var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
/* eslint-enable max-len */
var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";


var ROOT_ATTRIBUTE_NAME = 'data-reactroot';

/**
 * Map from property "standard name" to an object with info about how to set
 * the property in the DOM. Each object contains:
 *
 * attributeName:
 *   Used when rendering markup or with `*Attribute()`.
 * attributeNamespace
 * propertyName:
 *   Used on DOM node instances. (This includes properties that mutate due to
 *   external factors.)
 * mutationMethod:
 *   If non-null, used instead of the property or `setAttribute()` after
 *   initial render.
 * mustUseProperty:
 *   Whether the property must be accessed and mutated as an object property.
 * hasBooleanValue:
 *   Whether the property should be removed when set to a falsey value.
 * hasNumericValue:
 *   Whether the property must be numeric or parse as a numeric and should be
 *   removed when set to a falsey value.
 * hasPositiveNumericValue:
 *   Whether the property must be positive numeric or parse as a positive
 *   numeric and should be removed when set to a falsey value.
 * hasOverloadedBooleanValue:
 *   Whether the property can be used as a flag as well as with a value.
 *   Removed when strictly equal to false; present without a value when
 *   strictly equal to true; present with a value otherwise.
 */
var properties = {};

/**
 * Checks whether a property name is a writeable attribute.
 * @method
 */
function shouldSetAttribute(name, value) {
  if (isReservedProp(name)) {
    return false;
  }
  if (name.length > 2 && (name[0] === 'o' || name[0] === 'O') && (name[1] === 'n' || name[1] === 'N')) {
    return false;
  }
  if (value === null) {
    return true;
  }
  switch (typeof value) {
    case 'boolean':
      return shouldAttributeAcceptBooleanValue(name);
    case 'undefined':
    case 'number':
    case 'string':
    case 'object':
      return true;
    default:
      // function, symbol
      return false;
  }
}

function getPropertyInfo(name) {
  return properties.hasOwnProperty(name) ? properties[name] : null;
}

function shouldAttributeAcceptBooleanValue(name) {
  if (isReservedProp(name)) {
    return true;
  }
  var propertyInfo = getPropertyInfo(name);
  if (propertyInfo) {
    return propertyInfo.hasBooleanValue || propertyInfo.hasStringBooleanValue || propertyInfo.hasOverloadedBooleanValue;
  }
  var prefix = name.toLowerCase().slice(0, 5);
  return prefix === 'data-' || prefix === 'aria-';
}

/**
 * Checks to see if a property name is within the list of properties
 * reserved for internal React operations. These properties should
 * not be set on an HTML element.
 *
 * @private
 * @param {string} name
 * @return {boolean} If the name is within reserved props
 */
function isReservedProp(name) {
  return RESERVED_PROPS.hasOwnProperty(name);
}

var injection = DOMPropertyInjection;

var MUST_USE_PROPERTY = injection.MUST_USE_PROPERTY;
var HAS_BOOLEAN_VALUE = injection.HAS_BOOLEAN_VALUE;
var HAS_NUMERIC_VALUE = injection.HAS_NUMERIC_VALUE;
var HAS_POSITIVE_NUMERIC_VALUE = injection.HAS_POSITIVE_NUMERIC_VALUE;
var HAS_OVERLOADED_BOOLEAN_VALUE = injection.HAS_OVERLOADED_BOOLEAN_VALUE;
var HAS_STRING_BOOLEAN_VALUE = injection.HAS_STRING_BOOLEAN_VALUE;

var HTMLDOMPropertyConfig = {
  // When adding attributes to this list, be sure to also add them to
  // the `possibleStandardNames` module to ensure casing and incorrect
  // name warnings.
  Properties: {
    allowFullScreen: HAS_BOOLEAN_VALUE,
    // specifies target context for links with `preload` type
    async: HAS_BOOLEAN_VALUE,
    // Note: there is a special case that prevents it from being written to the DOM
    // on the client side because the browsers are inconsistent. Instead we call focus().
    autoFocus: HAS_BOOLEAN_VALUE,
    autoPlay: HAS_BOOLEAN_VALUE,
    capture: HAS_OVERLOADED_BOOLEAN_VALUE,
    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    cols: HAS_POSITIVE_NUMERIC_VALUE,
    contentEditable: HAS_STRING_BOOLEAN_VALUE,
    controls: HAS_BOOLEAN_VALUE,
    'default': HAS_BOOLEAN_VALUE,
    defer: HAS_BOOLEAN_VALUE,
    disabled: HAS_BOOLEAN_VALUE,
    download: HAS_OVERLOADED_BOOLEAN_VALUE,
    draggable: HAS_STRING_BOOLEAN_VALUE,
    formNoValidate: HAS_BOOLEAN_VALUE,
    hidden: HAS_BOOLEAN_VALUE,
    loop: HAS_BOOLEAN_VALUE,
    // Caution; `option.selected` is not updated if `select.multiple` is
    // disabled with `removeAttribute`.
    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    noValidate: HAS_BOOLEAN_VALUE,
    open: HAS_BOOLEAN_VALUE,
    playsInline: HAS_BOOLEAN_VALUE,
    readOnly: HAS_BOOLEAN_VALUE,
    required: HAS_BOOLEAN_VALUE,
    reversed: HAS_BOOLEAN_VALUE,
    rows: HAS_POSITIVE_NUMERIC_VALUE,
    rowSpan: HAS_NUMERIC_VALUE,
    scoped: HAS_BOOLEAN_VALUE,
    seamless: HAS_BOOLEAN_VALUE,
    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    size: HAS_POSITIVE_NUMERIC_VALUE,
    start: HAS_NUMERIC_VALUE,
    // support for projecting regular DOM Elements via V1 named slots ( shadow dom )
    span: HAS_POSITIVE_NUMERIC_VALUE,
    spellCheck: HAS_STRING_BOOLEAN_VALUE,
    // Style must be explicitly set in the attribute list. React components
    // expect a style object
    style: 0,
    // Keep it in the whitelist because it is case-sensitive for SVG.
    tabIndex: 0,
    // itemScope is for for Microdata support.
    // See http://schema.org/docs/gs.html
    itemScope: HAS_BOOLEAN_VALUE,
    // These attributes must stay in the white-list because they have
    // different attribute names (see DOMAttributeNames below)
    acceptCharset: 0,
    className: 0,
    htmlFor: 0,
    httpEquiv: 0,
    // Attributes with mutation methods must be specified in the whitelist
    // Set the string boolean flag to allow the behavior
    value: HAS_STRING_BOOLEAN_VALUE
  },
  DOMAttributeNames: {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
  },
  DOMMutationMethods: {
    value: function (node, value) {
      if (value == null) {
        return node.removeAttribute('value');
      }

      // Number inputs get special treatment due to some edge cases in
      // Chrome. Let everything else assign the value attribute as normal.
      // https://github.com/facebook/react/issues/7253#issuecomment-236074326
      if (node.type !== 'number' || node.hasAttribute('value') === false) {
        node.setAttribute('value', '' + value);
      } else if (node.validity && !node.validity.badInput && node.ownerDocument.activeElement !== node) {
        // Don't assign an attribute if validation reports bad
        // input. Chrome will clear the value. Additionally, don't
        // operate on inputs that have focus, otherwise Chrome might
        // strip off trailing decimal places and cause the user's
        // cursor position to jump to the beginning of the input.
        //
        // In ReactDOMInput, we have an onBlur event that will trigger
        // this function again when focus is lost.
        node.setAttribute('value', '' + value);
      }
    }
  }
};

var HAS_STRING_BOOLEAN_VALUE$1 = injection.HAS_STRING_BOOLEAN_VALUE;


var NS = {
  xlink: 'http://www.w3.org/1999/xlink',
  xml: 'http://www.w3.org/XML/1998/namespace'
};

/**
 * This is a list of all SVG attributes that need special casing,
 * namespacing, or boolean value assignment.
 *
 * When adding attributes to this list, be sure to also add them to
 * the `possibleStandardNames` module to ensure casing and incorrect
 * name warnings.
 *
 * SVG Attributes List:
 * https://www.w3.org/TR/SVG/attindex.html
 * SMIL Spec:
 * https://www.w3.org/TR/smil
 */
var ATTRS = ['accent-height', 'alignment-baseline', 'arabic-form', 'baseline-shift', 'cap-height', 'clip-path', 'clip-rule', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'dominant-baseline', 'enable-background', 'fill-opacity', 'fill-rule', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-name', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'horiz-adv-x', 'horiz-origin-x', 'image-rendering', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'overline-position', 'overline-thickness', 'paint-order', 'panose-1', 'pointer-events', 'rendering-intent', 'shape-rendering', 'stop-color', 'stop-opacity', 'strikethrough-position', 'strikethrough-thickness', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'underline-position', 'underline-thickness', 'unicode-bidi', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'vector-effect', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'word-spacing', 'writing-mode', 'x-height', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xmlns:xlink', 'xml:lang', 'xml:space'];

var SVGDOMPropertyConfig = {
  Properties: {
    autoReverse: HAS_STRING_BOOLEAN_VALUE$1,
    externalResourcesRequired: HAS_STRING_BOOLEAN_VALUE$1,
    preserveAlpha: HAS_STRING_BOOLEAN_VALUE$1
  },
  DOMAttributeNames: {
    autoReverse: 'autoReverse',
    externalResourcesRequired: 'externalResourcesRequired',
    preserveAlpha: 'preserveAlpha'
  },
  DOMAttributeNamespaces: {
    xlinkActuate: NS.xlink,
    xlinkArcrole: NS.xlink,
    xlinkHref: NS.xlink,
    xlinkRole: NS.xlink,
    xlinkShow: NS.xlink,
    xlinkTitle: NS.xlink,
    xlinkType: NS.xlink,
    xmlBase: NS.xml,
    xmlLang: NS.xml,
    xmlSpace: NS.xml
  }
};

var CAMELIZE = /[\-\:]([a-z])/g;
var capitalize = function (token) {
  return token[1].toUpperCase();
};

ATTRS.forEach(function (original) {
  var reactName = original.replace(CAMELIZE, capitalize);

  SVGDOMPropertyConfig.Properties[reactName] = 0;
  SVGDOMPropertyConfig.DOMAttributeNames[reactName] = original;
});

injection.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
injection.injectDOMPropertyConfig(SVGDOMPropertyConfig);

var ReactErrorUtils = {
  // Used by Fiber to simulate a try-catch.
  _caughtError: null,
  _hasCaughtError: false,

  // Used by event system to capture/rethrow the first error.
  _rethrowError: null,
  _hasRethrowError: false,

  injection: {
    injectErrorUtils: function (injectedErrorUtils) {
      !(typeof injectedErrorUtils.invokeGuardedCallback === 'function') ? invariant(false, 'Injected invokeGuardedCallback() must be a function.') : void 0;
      invokeGuardedCallback = injectedErrorUtils.invokeGuardedCallback;
    }
  },

  /**
   * Call a function while guarding against errors that happens within it.
   * Returns an error if it throws, otherwise null.
   *
   * In production, this is implemented using a try-catch. The reason we don't
   * use a try-catch directly is so that we can swap out a different
   * implementation in DEV mode.
   *
   * @param {String} name of the guard to use for logging or debugging
   * @param {Function} func The function to invoke
   * @param {*} context The context to use when calling the function
   * @param {...*} args Arguments for function
   */
  invokeGuardedCallback: function (name, func, context, a, b, c, d, e, f) {
    invokeGuardedCallback.apply(ReactErrorUtils, arguments);
  },

  /**
   * Same as invokeGuardedCallback, but instead of returning an error, it stores
   * it in a global so it can be rethrown by `rethrowCaughtError` later.
   * TODO: See if _caughtError and _rethrowError can be unified.
   *
   * @param {String} name of the guard to use for logging or debugging
   * @param {Function} func The function to invoke
   * @param {*} context The context to use when calling the function
   * @param {...*} args Arguments for function
   */
  invokeGuardedCallbackAndCatchFirstError: function (name, func, context, a, b, c, d, e, f) {
    ReactErrorUtils.invokeGuardedCallback.apply(this, arguments);
    if (ReactErrorUtils.hasCaughtError()) {
      var error = ReactErrorUtils.clearCaughtError();
      if (!ReactErrorUtils._hasRethrowError) {
        ReactErrorUtils._hasRethrowError = true;
        ReactErrorUtils._rethrowError = error;
      }
    }
  },

  /**
   * During execution of guarded functions we will capture the first error which
   * we will rethrow to be handled by the top level error handler.
   */
  rethrowCaughtError: function () {
    return rethrowCaughtError.apply(ReactErrorUtils, arguments);
  },

  hasCaughtError: function () {
    return ReactErrorUtils._hasCaughtError;
  },

  clearCaughtError: function () {
    if (ReactErrorUtils._hasCaughtError) {
      var error = ReactErrorUtils._caughtError;
      ReactErrorUtils._caughtError = null;
      ReactErrorUtils._hasCaughtError = false;
      return error;
    } else {
      invariant(false, 'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.');
    }
  }
};

var invokeGuardedCallback = function (name, func, context, a, b, c, d, e, f) {
  ReactErrorUtils._hasCaughtError = false;
  ReactErrorUtils._caughtError = null;
  var funcArgs = Array.prototype.slice.call(arguments, 3);
  try {
    func.apply(context, funcArgs);
  } catch (error) {
    ReactErrorUtils._caughtError = error;
    ReactErrorUtils._hasCaughtError = true;
  }
};

{
  // In DEV mode, we swap out invokeGuardedCallback for a special version
  // that plays more nicely with the browser's DevTools. The idea is to preserve
  // "Pause on exceptions" behavior. Because React wraps all user-provided
  // functions in invokeGuardedCallback, and the production version of
  // invokeGuardedCallback uses a try-catch, all user exceptions are treated
  // like caught exceptions, and the DevTools won't pause unless the developer
  // takes the extra step of enabling pause on caught exceptions. This is
  // untintuitive, though, because even though React has caught the error, from
  // the developer's perspective, the error is uncaught.
  //
  // To preserve the expected "Pause on exceptions" behavior, we don't use a
  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
  // DOM node, and call the user-provided callback from inside an event handler
  // for that fake event. If the callback throws, the error is "captured" using
  // a global event handler. But because the error happens in a different
  // event loop context, it does not interrupt the normal program flow.
  // Effectively, this gives us try-catch behavior without actually using
  // try-catch. Neat!

  // Check that the browser supports the APIs we need to implement our special
  // DEV version of invokeGuardedCallback
  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
    var fakeNode = document.createElement('react');

    var invokeGuardedCallbackDev = function (name, func, context, a, b, c, d, e, f) {
      // Keeps track of whether the user-provided callback threw an error. We
      // set this to true at the beginning, then set it to false right after
      // calling the function. If the function errors, `didError` will never be
      // set to false. This strategy works even if the browser is flaky and
      // fails to call our global error handler, because it doesn't rely on
      // the error event at all.
      var didError = true;

      // Create an event handler for our fake event. We will synchronously
      // dispatch our fake event using `dispatchEvent`. Inside the handler, we
      // call the user-provided callback.
      var funcArgs = Array.prototype.slice.call(arguments, 3);
      function callCallback() {
        // We immediately remove the callback from event listeners so that
        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a
        // nested call would trigger the fake event handlers of any call higher
        // in the stack.
        fakeNode.removeEventListener(evtType, callCallback, false);
        func.apply(context, funcArgs);
        didError = false;
      }

      // Create a global error event handler. We use this to capture the value
      // that was thrown. It's possible that this error handler will fire more
      // than once; for example, if non-React code also calls `dispatchEvent`
      // and a handler for that event throws. We should be resilient to most of
      // those cases. Even if our error event handler fires more than once, the
      // last error event is always used. If the callback actually does error,
      // we know that the last error event is the correct one, because it's not
      // possible for anything else to have happened in between our callback
      // erroring and the code that follows the `dispatchEvent` call below. If
      // the callback doesn't error, but the error event was fired, we know to
      // ignore it because `didError` will be false, as described above.
      var error = void 0;
      // Use this to track whether the error event is ever called.
      var didSetError = false;
      var isCrossOriginError = false;

      function onError(event) {
        error = event.error;
        didSetError = true;
        if (error === null && event.colno === 0 && event.lineno === 0) {
          isCrossOriginError = true;
        }
      }

      // Create a fake event type.
      var evtType = 'react-' + (name ? name : 'invokeguardedcallback');

      // Attach our event handlers
      window.addEventListener('error', onError);
      fakeNode.addEventListener(evtType, callCallback, false);

      // Synchronously dispatch our fake event. If the user-provided function
      // errors, it will trigger our global error handler.
      var evt = document.createEvent('Event');
      evt.initEvent(evtType, false, false);
      fakeNode.dispatchEvent(evt);

      if (didError) {
        if (!didSetError) {
          // The callback errored, but the error event never fired.
          error = new Error('An error was thrown inside one of your components, but React ' + "doesn't know what it was. This is likely due to browser " + 'flakiness. React does its best to preserve the "Pause on ' + 'exceptions" behavior of the DevTools, which requires some ' + "DEV-mode only tricks. It's possible that these don't work in " + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');
        } else if (isCrossOriginError) {
          error = new Error("A cross-origin error was thrown. React doesn't have access to " + 'the actual error object in development. ' + 'See https://fb.me/react-crossorigin-error for more information.');
        }
        ReactErrorUtils._hasCaughtError = true;
        ReactErrorUtils._caughtError = error;
      } else {
        ReactErrorUtils._hasCaughtError = false;
        ReactErrorUtils._caughtError = null;
      }

      // Remove our event listeners
      window.removeEventListener('error', onError);
    };

    invokeGuardedCallback = invokeGuardedCallbackDev;
  }
}

var rethrowCaughtError = function () {
  if (ReactErrorUtils._hasRethrowError) {
    var error = ReactErrorUtils._rethrowError;
    ReactErrorUtils._rethrowError = null;
    ReactErrorUtils._hasRethrowError = false;
    throw error;
  }
};

/**
 * Injectable ordering of event plugins.
 */
var eventPluginOrder = null;

/**
 * Injectable mapping from names to event plugin modules.
 */
var namesToPlugins = {};

/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
 *
 * @private
 */
function recomputePluginOrdering() {
  if (!eventPluginOrder) {
    // Wait until an `eventPluginOrder` is injected.
    return;
  }
  for (var pluginName in namesToPlugins) {
    var pluginModule = namesToPlugins[pluginName];
    var pluginIndex = eventPluginOrder.indexOf(pluginName);
    !(pluginIndex > -1) ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : void 0;
    if (plugins[pluginIndex]) {
      continue;
    }
    !pluginModule.extractEvents ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : void 0;
    plugins[pluginIndex] = pluginModule;
    var publishedEvents = pluginModule.eventTypes;
    for (var eventName in publishedEvents) {
      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : void 0;
    }
  }
}

/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */
function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
  !!eventNameDispatchConfigs.hasOwnProperty(eventName) ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : void 0;
  eventNameDispatchConfigs[eventName] = dispatchConfig;

  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
  if (phasedRegistrationNames) {
    for (var phaseName in phasedRegistrationNames) {
      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
        var phasedRegistrationName = phasedRegistrationNames[phaseName];
        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
      }
    }
    return true;
  } else if (dispatchConfig.registrationName) {
    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
    return true;
  }
  return false;
}

/**
 * Publishes a registration name that is used to identify dispatched events.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */
function publishRegistrationName(registrationName, pluginModule, eventName) {
  !!registrationNameModules[registrationName] ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : void 0;
  registrationNameModules[registrationName] = pluginModule;
  registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;

  {
    var lowerCasedName = registrationName.toLowerCase();
    possibleRegistrationNames[lowerCasedName] = registrationName;

    if (registrationName === 'onDoubleClick') {
      possibleRegistrationNames.ondblclick = registrationName;
    }
  }
}

/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 */

/**
 * Ordered list of injected plugins.
 */
var plugins = [];

/**
 * Mapping from event name to dispatch config
 */
var eventNameDispatchConfigs = {};

/**
 * Mapping from registration name to plugin module
 */
var registrationNameModules = {};

/**
 * Mapping from registration name to event name
 */
var registrationNameDependencies = {};

/**
 * Mapping from lowercase registration names to the properly cased version,
 * used to warn in the case of missing event handlers. Available
 * only in true.
 * @type {Object}
 */
var possibleRegistrationNames = {};
// Trust the developer to only use possibleRegistrationNames in true

/**
 * Injects an ordering of plugins (by plugin name). This allows the ordering
 * to be decoupled from injection of the actual plugins so that ordering is
 * always deterministic regardless of packaging, on-the-fly injection, etc.
 *
 * @param {array} InjectedEventPluginOrder
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginOrder}
 */
function injectEventPluginOrder(injectedEventPluginOrder) {
  !!eventPluginOrder ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : void 0;
  // Clone the ordering so it cannot be dynamically mutated.
  eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
  recomputePluginOrdering();
}

/**
 * Injects plugins to be used by `EventPluginHub`. The plugin names must be
 * in the ordering injected by `injectEventPluginOrder`.
 *
 * Plugins can be injected as part of page initialization or on-the-fly.
 *
 * @param {object} injectedNamesToPlugins Map from names to plugin modules.
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginsByName}
 */
function injectEventPluginsByName(injectedNamesToPlugins) {
  var isOrderingDirty = false;
  for (var pluginName in injectedNamesToPlugins) {
    if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
      continue;
    }
    var pluginModule = injectedNamesToPlugins[pluginName];
    if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
      !!namesToPlugins[pluginName] ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : void 0;
      namesToPlugins[pluginName] = pluginModule;
      isOrderingDirty = true;
    }
  }
  if (isOrderingDirty) {
    recomputePluginOrdering();
  }
}

var EventPluginRegistry = Object.freeze({
	plugins: plugins,
	eventNameDispatchConfigs: eventNameDispatchConfigs,
	registrationNameModules: registrationNameModules,
	registrationNameDependencies: registrationNameDependencies,
	possibleRegistrationNames: possibleRegistrationNames,
	injectEventPluginOrder: injectEventPluginOrder,
	injectEventPluginsByName: injectEventPluginsByName
});

var getFiberCurrentPropsFromNode = null;
var getInstanceFromNode = null;
var getNodeFromInstance = null;

var injection$2 = {
  injectComponentTree: function (Injected) {
    getFiberCurrentPropsFromNode = Injected.getFiberCurrentPropsFromNode;
    getInstanceFromNode = Injected.getInstanceFromNode;
    getNodeFromInstance = Injected.getNodeFromInstance;

    {
      warning(getNodeFromInstance && getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.');
    }
  }
};






var validateEventDispatches;
{
  validateEventDispatches = function (event) {
    var dispatchListeners = event._dispatchListeners;
    var dispatchInstances = event._dispatchInstances;

    var listenersIsArr = Array.isArray(dispatchListeners);
    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;

    var instancesIsArr = Array.isArray(dispatchInstances);
    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;

    warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.');
  };
}

/**
 * Dispatch the event to the listener.
 * @param {SyntheticEvent} event SyntheticEvent to handle
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @param {function} listener Application-level callback
 * @param {*} inst Internal component instance
 */
function executeDispatch(event, simulated, listener, inst) {
  var type = event.type || 'unknown-event';
  event.currentTarget = getNodeFromInstance(inst);
  ReactErrorUtils.invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);
  event.currentTarget = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches.
 */
function executeDispatchesInOrder(event, simulated) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchInstances = event._dispatchInstances;
  {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and Instances are two parallel arrays that are always in sync.
      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
    }
  } else if (dispatchListeners) {
    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
  }
  event._dispatchListeners = null;
  event._dispatchInstances = null;
}

/**
 * @see executeDispatchesInOrderStopAtTrueImpl
 */


/**
 * Execution of a "direct" dispatch - there must be at most one dispatch
 * accumulated on the event or it is considered an error. It doesn't really make
 * sense for an event with multiple dispatches (bubbled) to keep track of the
 * return values at each dispatch execution, but it does tend to make sense when
 * dealing with "direct" dispatches.
 *
 * @return {*} The return value of executing the single dispatch.
 */


/**
 * @param {SyntheticEvent} event
 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
 */

/**
 * Accumulates items that must not be null or undefined into the first one. This
 * is used to conserve memory by avoiding array allocations, and thus sacrifices
 * API cleanness. Since `current` can be null before being passed in and not
 * null after this function, make sure to assign it back to `current`:
 *
 * `a = accumulateInto(a, b);`
 *
 * This API should be sparingly used. Try `accumulate` for something cleaner.
 *
 * @return {*|array<*>} An accumulation of items.
 */

function accumulateInto(current, next) {
  !(next != null) ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : void 0;

  if (current == null) {
    return next;
  }

  // Both are not empty. Warning: Never call x.concat(y) when you are not
  // certain that x is an Array (x could be a string with concat method).
  if (Array.isArray(current)) {
    if (Array.isArray(next)) {
      current.push.apply(current, next);
      return current;
    }
    current.push(next);
    return current;
  }

  if (Array.isArray(next)) {
    // A bit too dangerous to mutate `next`.
    return [current].concat(next);
  }

  return [current, next];
}

/**
 * @param {array} arr an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 * @param {function} cb Callback invoked with each element or a collection.
 * @param {?} [scope] Scope used as `this` in a callback.
 */
function forEachAccumulated(arr, cb, scope) {
  if (Array.isArray(arr)) {
    arr.forEach(cb, scope);
  } else if (arr) {
    cb.call(scope, arr);
  }
}

/**
 * Internal queue of events that have accumulated their dispatches and are
 * waiting to have their dispatches executed.
 */
var eventQueue = null;

/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.release(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
  return executeDispatchesAndRelease(e, false);
};

function isInteractive(tag) {
  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
}

function shouldPreventMouseEvent(name, type, props) {
  switch (name) {
    case 'onClick':
    case 'onClickCapture':
    case 'onDoubleClick':
    case 'onDoubleClickCapture':
    case 'onMouseDown':
    case 'onMouseDownCapture':
    case 'onMouseMove':
    case 'onMouseMoveCapture':
    case 'onMouseUp':
    case 'onMouseUpCapture':
      return !!(props.disabled && isInteractive(type));
    default:
      return false;
  }
}

/**
 * This is a unified interface for event plugins to be installed and configured.
 *
 * Event plugins can implement the following properties:
 *
 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
 *     Required. When a top-level event is fired, this method is expected to
 *     extract synthetic events that will in turn be queued and dispatched.
 *
 *   `eventTypes` {object}
 *     Optional, plugins that fire events must publish a mapping of registration
 *     names that are used to register listeners. Values of this mapping must
 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
 *
 *   `executeDispatch` {function(object, function, string)}
 *     Optional, allows plugins to override how an event gets dispatched. By
 *     default, the listener is simply invoked.
 *
 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
 *
 * @public
 */

/**
 * Methods for injecting dependencies.
 */
var injection$1 = {
  /**
   * @param {array} InjectedEventPluginOrder
   * @public
   */
  injectEventPluginOrder: injectEventPluginOrder,

  /**
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   */
  injectEventPluginsByName: injectEventPluginsByName
};

/**
 * @param {object} inst The instance, which is the source of events.
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @return {?function} The stored callback.
 */
function getListener(inst, registrationName) {
  var listener;

  // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
  // live here; needs to be moved to a better place soon
  var stateNode = inst.stateNode;
  if (!stateNode) {
    // Work in progress (ex: onload events in incremental mode).
    return null;
  }
  var props = getFiberCurrentPropsFromNode(stateNode);
  if (!props) {
    // Work in progress.
    return null;
  }
  listener = props[registrationName];
  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
    return null;
  }
  !(!listener || typeof listener === 'function') ? invariant(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.', registrationName, typeof listener) : void 0;
  return listener;
}

/**
 * Allows registered plugins an opportunity to extract events from top-level
 * native browser events.
 *
 * @return {*} An accumulation of synthetic events.
 * @internal
 */
function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events;
  for (var i = 0; i < plugins.length; i++) {
    // Not every plugin in the ordering may be loaded at runtime.
    var possiblePlugin = plugins[i];
    if (possiblePlugin) {
      var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
      if (extractedEvents) {
        events = accumulateInto(events, extractedEvents);
      }
    }
  }
  return events;
}

/**
 * Enqueues a synthetic event that should be dispatched when
 * `processEventQueue` is invoked.
 *
 * @param {*} events An accumulation of synthetic events.
 * @internal
 */
function enqueueEvents(events) {
  if (events) {
    eventQueue = accumulateInto(eventQueue, events);
  }
}

/**
 * Dispatches all synthetic events on the event queue.
 *
 * @internal
 */
function processEventQueue(simulated) {
  // Set `eventQueue` to null before processing it so that we can tell if more
  // events get enqueued while processing.
  var processingEventQueue = eventQueue;
  eventQueue = null;

  if (!processingEventQueue) {
    return;
  }

  if (simulated) {
    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
  } else {
    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
  }
  !!eventQueue ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : void 0;
  // This would be a good time to rethrow if any of the event handlers threw.
  ReactErrorUtils.rethrowCaughtError();
}

var EventPluginHub = Object.freeze({
	injection: injection$1,
	getListener: getListener,
	extractEvents: extractEvents,
	enqueueEvents: enqueueEvents,
	processEventQueue: processEventQueue
});

var IndeterminateComponent = 0; // Before we know whether it is functional or class
var FunctionalComponent = 1;
var ClassComponent = 2;
var HostRoot = 3; // Root of a host tree. Could be nested inside another node.
var HostPortal = 4; // A subtree. Could be an entry point to a different renderer.
var HostComponent = 5;
var HostText = 6;
var CallComponent = 7;
var CallHandlerPhase = 8;
var ReturnComponent = 9;
var Fragment = 10;

var randomKey = Math.random().toString(36).slice(2);
var internalInstanceKey = '__reactInternalInstance$' + randomKey;
var internalEventHandlersKey = '__reactEventHandlers$' + randomKey;

function precacheFiberNode$1(hostInst, node) {
  node[internalInstanceKey] = hostInst;
}

/**
 * Given a DOM node, return the closest ReactDOMComponent or
 * ReactDOMTextComponent instance ancestor.
 */
function getClosestInstanceFromNode(node) {
  if (node[internalInstanceKey]) {
    return node[internalInstanceKey];
  }

  // Walk up the tree until we find an ancestor whose instance we have cached.
  var parents = [];
  while (!node[internalInstanceKey]) {
    parents.push(node);
    if (node.parentNode) {
      node = node.parentNode;
    } else {
      // Top of the tree. This node must not be part of a React tree (or is
      // unmounted, potentially).
      return null;
    }
  }

  var closest = void 0;
  var inst = node[internalInstanceKey];
  if (inst.tag === HostComponent || inst.tag === HostText) {
    // In Fiber, this will always be the deepest root.
    return inst;
  }
  for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
    closest = inst;
  }

  return closest;
}

/**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */
function getInstanceFromNode$1(node) {
  var inst = node[internalInstanceKey];
  if (inst) {
    if (inst.tag === HostComponent || inst.tag === HostText) {
      return inst;
    } else {
      return null;
    }
  }
  return null;
}

/**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */
function getNodeFromInstance$1(inst) {
  if (inst.tag === HostComponent || inst.tag === HostText) {
    // In Fiber this, is just the state node right now. We assume it will be
    // a host component or host text.
    return inst.stateNode;
  }

  // Without this first invariant, passing a non-DOM-component triggers the next
  // invariant for a missing parent, which is super confusing.
  invariant(false, 'getNodeFromInstance: Invalid argument.');
}

function getFiberCurrentPropsFromNode$1(node) {
  return node[internalEventHandlersKey] || null;
}

function updateFiberProps$1(node, props) {
  node[internalEventHandlersKey] = props;
}

var ReactDOMComponentTree = Object.freeze({
	precacheFiberNode: precacheFiberNode$1,
	getClosestInstanceFromNode: getClosestInstanceFromNode,
	getInstanceFromNode: getInstanceFromNode$1,
	getNodeFromInstance: getNodeFromInstance$1,
	getFiberCurrentPropsFromNode: getFiberCurrentPropsFromNode$1,
	updateFiberProps: updateFiberProps$1
});

function getParent(inst) {
  do {
    inst = inst['return'];
    // TODO: If this is a HostRoot we might want to bail out.
    // That is depending on if we want nested subtrees (layers) to bubble
    // events to their parent. We could also go through parentNode on the
    // host node but that wouldn't work for React Native and doesn't let us
    // do the portal feature.
  } while (inst && inst.tag !== HostComponent);
  if (inst) {
    return inst;
  }
  return null;
}

/**
 * Return the lowest common ancestor of A and B, or null if they are in
 * different trees.
 */
function getLowestCommonAncestor(instA, instB) {
  var depthA = 0;
  for (var tempA = instA; tempA; tempA = getParent(tempA)) {
    depthA++;
  }
  var depthB = 0;
  for (var tempB = instB; tempB; tempB = getParent(tempB)) {
    depthB++;
  }

  // If A is deeper, crawl up.
  while (depthA - depthB > 0) {
    instA = getParent(instA);
    depthA--;
  }

  // If B is deeper, crawl up.
  while (depthB - depthA > 0) {
    instB = getParent(instB);
    depthB--;
  }

  // Walk in lockstep until we find a match.
  var depth = depthA;
  while (depth--) {
    if (instA === instB || instA === instB.alternate) {
      return instA;
    }
    instA = getParent(instA);
    instB = getParent(instB);
  }
  return null;
}

/**
 * Return if A is an ancestor of B.
 */


/**
 * Return the parent instance of the passed-in instance.
 */
function getParentInstance(inst) {
  return getParent(inst);
}

/**
 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
 */
function traverseTwoPhase(inst, fn, arg) {
  var path = [];
  while (inst) {
    path.push(inst);
    inst = getParent(inst);
  }
  var i;
  for (i = path.length; i-- > 0;) {
    fn(path[i], 'captured', arg);
  }
  for (i = 0; i < path.length; i++) {
    fn(path[i], 'bubbled', arg);
  }
}

/**
 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
 * should would receive a `mouseEnter` or `mouseLeave` event.
 *
 * Does not invoke the callback on the nearest common ancestor because nothing
 * "entered" or "left" that element.
 */
function traverseEnterLeave(from, to, fn, argFrom, argTo) {
  var common = from && to ? getLowestCommonAncestor(from, to) : null;
  var pathFrom = [];
  while (true) {
    if (!from) {
      break;
    }
    if (from === common) {
      break;
    }
    var alternate = from.alternate;
    if (alternate !== null && alternate === common) {
      break;
    }
    pathFrom.push(from);
    from = getParent(from);
  }
  var pathTo = [];
  while (true) {
    if (!to) {
      break;
    }
    if (to === common) {
      break;
    }
    var _alternate = to.alternate;
    if (_alternate !== null && _alternate === common) {
      break;
    }
    pathTo.push(to);
    to = getParent(to);
  }
  for (var i = 0; i < pathFrom.length; i++) {
    fn(pathFrom[i], 'bubbled', argFrom);
  }
  for (var _i = pathTo.length; _i-- > 0;) {
    fn(pathTo[_i], 'captured', argTo);
  }
}

/**
 * Some event types have a notion of different registration names for different
 * "phases" of propagation. This finds listeners by a given phase.
 */
function listenerAtPhase(inst, event, propagationPhase) {
  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
  return getListener(inst, registrationName);
}

/**
 * A small set of propagation patterns, each of which will accept a small amount
 * of information, and generate a set of "dispatch ready event objects" - which
 * are sets of events that have already been annotated with a set of dispatched
 * listener functions/ids. The API is designed this way to discourage these
 * propagation strategies from actually executing the dispatches, since we
 * always want to collect the entire set of dispatches before executing even a
 * single one.
 */

/**
 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
 * here, allows us to not have to bind or create functions for each event.
 * Mutating the event's members allows us to not have to create a wrapping
 * "dispatch" object that pairs the event with the listener.
 */
function accumulateDirectionalDispatches(inst, phase, event) {
  {
    warning(inst, 'Dispatching inst must not be null');
  }
  var listener = listenerAtPhase(inst, event, phase);
  if (listener) {
    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
  }
}

/**
 * Collect dispatches (must be entirely collected before dispatching - see unit
 * tests). Lazily allocate the array to conserve memory.  We must loop through
 * each event and perform the traversal for each one. We cannot perform a
 * single traversal for the entire collection of events because each event may
 * have a different target.
 */
function accumulateTwoPhaseDispatchesSingle(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
  }
}

/**
 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
 */
function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    var targetInst = event._targetInst;
    var parentInst = targetInst ? getParentInstance(targetInst) : null;
    traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
  }
}

/**
 * Accumulates without regard to direction, does not look for phased
 * registration names. Same as `accumulateDirectDispatchesSingle` but without
 * requiring that the `dispatchMarker` be the same as the dispatched ID.
 */
function accumulateDispatches(inst, ignoredDirection, event) {
  if (inst && event && event.dispatchConfig.registrationName) {
    var registrationName = event.dispatchConfig.registrationName;
    var listener = getListener(inst, registrationName);
    if (listener) {
      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
    }
  }
}

/**
 * Accumulates dispatches on an `SyntheticEvent`, but only for the
 * `dispatchMarker`.
 * @param {SyntheticEvent} event
 */
function accumulateDirectDispatchesSingle(event) {
  if (event && event.dispatchConfig.registrationName) {
    accumulateDispatches(event._targetInst, null, event);
  }
}

function accumulateTwoPhaseDispatches(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
}

function accumulateTwoPhaseDispatchesSkipTarget(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
}

function accumulateEnterLeaveDispatches(leave, enter, from, to) {
  traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
}

function accumulateDirectDispatches(events) {
  forEachAccumulated(events, accumulateDirectDispatchesSingle);
}

var EventPropagators = Object.freeze({
	accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
	accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
	accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches,
	accumulateDirectDispatches: accumulateDirectDispatches
});

var contentKey = null;

/**
 * Gets the key used to access text content on a DOM node.
 *
 * @return {?string} Key used to access text content.
 * @internal
 */
function getTextContentAccessor() {
  if (!contentKey && ExecutionEnvironment.canUseDOM) {
    // Prefer textContent to innerText because many browsers support both but
    // SVG <text> elements don't support innerText even when <div> does.
    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
  }
  return contentKey;
}

/**
 * This helper object stores information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 *
 */
var compositionState = {
  _root: null,
  _startText: null,
  _fallbackText: null
};

function initialize(nativeEventTarget) {
  compositionState._root = nativeEventTarget;
  compositionState._startText = getText();
  return true;
}

function reset() {
  compositionState._root = null;
  compositionState._startText = null;
  compositionState._fallbackText = null;
}

function getData() {
  if (compositionState._fallbackText) {
    return compositionState._fallbackText;
  }

  var start;
  var startValue = compositionState._startText;
  var startLength = startValue.length;
  var end;
  var endValue = getText();
  var endLength = endValue.length;

  for (start = 0; start < startLength; start++) {
    if (startValue[start] !== endValue[start]) {
      break;
    }
  }

  var minEnd = startLength - start;
  for (end = 1; end <= minEnd; end++) {
    if (startValue[startLength - end] !== endValue[endLength - end]) {
      break;
    }
  }

  var sliceTail = end > 1 ? 1 - end : undefined;
  compositionState._fallbackText = endValue.slice(start, sliceTail);
  return compositionState._fallbackText;
}

function getText() {
  if ('value' in compositionState._root) {
    return compositionState._root.value;
  }
  return compositionState._root[getTextContentAccessor()];
}

/* eslint valid-typeof: 0 */

var didWarnForAddedNewProperty = false;
var isProxySupported = typeof Proxy === 'function';
var EVENT_POOL_SIZE = 10;

var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var EventInterface = {
  type: null,
  target: null,
  // currentTarget is set when dispatching; no use in copying it here
  currentTarget: emptyFunction.thatReturnsNull,
  eventPhase: null,
  bubbles: null,
  cancelable: null,
  timeStamp: function (event) {
    return event.timeStamp || Date.now();
  },
  defaultPrevented: null,
  isTrusted: null
};

/**
 * Synthetic events are dispatched by event plugins, typically in response to a
 * top-level event delegation handler.
 *
 * These systems should generally use pooling to reduce the frequency of garbage
 * collection. The system should check `isPersistent` to determine whether the
 * event should be released into the pool after being dispatched. Users that
 * need a persisted event should invoke `persist`.
 *
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
 * normalizing browser quirks. Subclasses do not necessarily have to implement a
 * DOM interface; custom application-specific events can also subclass this.
 *
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {*} targetInst Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @param {DOMEventTarget} nativeEventTarget Target node.
 */
function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
  {
    // these have a getter/setter for warnings
    delete this.nativeEvent;
    delete this.preventDefault;
    delete this.stopPropagation;
  }

  this.dispatchConfig = dispatchConfig;
  this._targetInst = targetInst;
  this.nativeEvent = nativeEvent;

  var Interface = this.constructor.Interface;
  for (var propName in Interface) {
    if (!Interface.hasOwnProperty(propName)) {
      continue;
    }
    {
      delete this[propName]; // this has a getter/setter for warnings
    }
    var normalize = Interface[propName];
    if (normalize) {
      this[propName] = normalize(nativeEvent);
    } else {
      if (propName === 'target') {
        this.target = nativeEventTarget;
      } else {
        this[propName] = nativeEvent[propName];
      }
    }
  }

  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
  if (defaultPrevented) {
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  } else {
    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
  }
  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
  return this;
}

_assign(SyntheticEvent.prototype, {
  preventDefault: function () {
    this.defaultPrevented = true;
    var event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.preventDefault) {
      event.preventDefault();
    } else if (typeof event.returnValue !== 'unknown') {
      event.returnValue = false;
    }
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  },

  stopPropagation: function () {
    var event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.stopPropagation) {
      event.stopPropagation();
    } else if (typeof event.cancelBubble !== 'unknown') {
      // The ChangeEventPlugin registers a "propertychange" event for
      // IE. This event does not support bubbling or cancelling, and
      // any references to cancelBubble throw "Member not found".  A
      // typeof check of "unknown" circumvents this issue (and is also
      // IE specific).
      event.cancelBubble = true;
    }

    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
  },

  /**
   * We release all dispatched `SyntheticEvent`s after each event loop, adding
   * them back into the pool. This allows a way to hold onto a reference that
   * won't be added back into the pool.
   */
  persist: function () {
    this.isPersistent = emptyFunction.thatReturnsTrue;
  },

  /**
   * Checks if this event should be released back into the pool.
   *
   * @return {boolean} True if this should not be released, false otherwise.
   */
  isPersistent: emptyFunction.thatReturnsFalse,

  /**
   * `PooledClass` looks for `destructor` on each instance it releases.
   */
  destructor: function () {
    var Interface = this.constructor.Interface;
    for (var propName in Interface) {
      {
        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
      }
    }
    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
      this[shouldBeReleasedProperties[i]] = null;
    }
    {
      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));
      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));
    }
  }
});

SyntheticEvent.Interface = EventInterface;

/**
 * Helper to reduce boilerplate when creating subclasses.
 *
 * @param {function} Class
 * @param {?object} Interface
 */
SyntheticEvent.augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;
  addEventPoolingTo(Class);
};

/** Proxying after everything set on SyntheticEvent
 * to resolve Proxy issue on some WebKit browsers
 * in which some Event properties are set to undefined (GH#10010)
 */
{
  if (isProxySupported) {
    /*eslint-disable no-func-assign */
    SyntheticEvent = new Proxy(SyntheticEvent, {
      construct: function (target, args) {
        return this.apply(target, Object.create(target.prototype), args);
      },
      apply: function (constructor, that, args) {
        return new Proxy(constructor.apply(that, args), {
          set: function (target, prop, value) {
            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
              warning(didWarnForAddedNewProperty || target.isPersistent(), "This synthetic event is reused for performance reasons. If you're " + "seeing this, you're adding a new property in the synthetic event object. " + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.');
              didWarnForAddedNewProperty = true;
            }
            target[prop] = value;
            return true;
          }
        });
      }
    });
    /*eslint-enable no-func-assign */
  }
}

addEventPoolingTo(SyntheticEvent);

/**
 * Helper to nullify syntheticEvent instance properties when destructing
 *
 * @param {String} propName
 * @param {?object} getVal
 * @return {object} defineProperty object
 */
function getPooledWarningPropertyDefinition(propName, getVal) {
  var isFunction = typeof getVal === 'function';
  return {
    configurable: true,
    set: set,
    get: get
  };

  function set(val) {
    var action = isFunction ? 'setting the method' : 'setting the property';
    warn(action, 'This is effectively a no-op');
    return val;
  }

  function get() {
    var action = isFunction ? 'accessing the method' : 'accessing the property';
    var result = isFunction ? 'This is a no-op function' : 'This is set to null';
    warn(action, result);
    return getVal;
  }

  function warn(action, result) {
    var warningCondition = false;
    warning(warningCondition, "This synthetic event is reused for performance reasons. If you're seeing this, " + "you're %s `%s` on a released/nullified synthetic event. %s. " + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result);
  }
}

function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {
  var EventConstructor = this;
  if (EventConstructor.eventPool.length) {
    var instance = EventConstructor.eventPool.pop();
    EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);
    return instance;
  }
  return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);
}

function releasePooledEvent(event) {
  var EventConstructor = this;
  !(event instanceof EventConstructor) ? invariant(false, 'Trying to release an event instance  into a pool of a different type.') : void 0;
  event.destructor();
  if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {
    EventConstructor.eventPool.push(event);
  }
}

function addEventPoolingTo(EventConstructor) {
  EventConstructor.eventPool = [];
  EventConstructor.getPooled = getPooledEvent;
  EventConstructor.release = releasePooledEvent;
}

var SyntheticEvent$1 = SyntheticEvent;

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */
var CompositionEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);

/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */
var InputEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticInputEvent, InputEventInterface);

var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
var START_KEYCODE = 229;

var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;

var documentMode = null;
if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
  documentMode = document.documentMode;
}

// Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.
var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();

// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.
var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);

/**
 * Opera <= 12 includes TextEvent in window, but does not fire
 * text input events. Rely on keypress instead.
 */
function isPresto() {
  var opera = window.opera;
  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
}

var SPACEBAR_CODE = 32;
var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

// Events and their corresponding property names.
var eventTypes = {
  beforeInput: {
    phasedRegistrationNames: {
      bubbled: 'onBeforeInput',
      captured: 'onBeforeInputCapture'
    },
    dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste']
  },
  compositionEnd: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionEnd',
      captured: 'onCompositionEndCapture'
    },
    dependencies: ['topBlur', 'topCompositionEnd', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  },
  compositionStart: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionStart',
      captured: 'onCompositionStartCapture'
    },
    dependencies: ['topBlur', 'topCompositionStart', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  },
  compositionUpdate: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionUpdate',
      captured: 'onCompositionUpdateCapture'
    },
    dependencies: ['topBlur', 'topCompositionUpdate', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  }
};

// Track whether we've ever handled a keypress on the space key.
var hasSpaceKeypress = false;

/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */
function isKeypressCommand(nativeEvent) {
  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
  !(nativeEvent.ctrlKey && nativeEvent.altKey);
}

/**
 * Translate native top level events into event types.
 *
 * @param {string} topLevelType
 * @return {object}
 */
function getCompositionEventType(topLevelType) {
  switch (topLevelType) {
    case 'topCompositionStart':
      return eventTypes.compositionStart;
    case 'topCompositionEnd':
      return eventTypes.compositionEnd;
    case 'topCompositionUpdate':
      return eventTypes.compositionUpdate;
  }
}

/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionStart(topLevelType, nativeEvent) {
  return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;
}

/**
 * Does our fallback mode think that this event is the end of composition?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionEnd(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case 'topKeyUp':
      // Command keys insert or clear IME input.
      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
    case 'topKeyDown':
      // Expect IME keyCode on each keydown. If we get any other
      // code we must have exited earlier.
      return nativeEvent.keyCode !== START_KEYCODE;
    case 'topKeyPress':
    case 'topMouseDown':
    case 'topBlur':
      // Events are not possible without cancelling IME.
      return true;
    default:
      return false;
  }
}

/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */
function getDataFromCustomEvent(nativeEvent) {
  var detail = nativeEvent.detail;
  if (typeof detail === 'object' && 'data' in detail) {
    return detail.data;
  }
  return null;
}

// Track the current IME composition status, if any.
var isComposing = false;

/**
 * @return {?object} A SyntheticCompositionEvent.
 */
function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var eventType;
  var fallbackData;

  if (canUseCompositionEvent) {
    eventType = getCompositionEventType(topLevelType);
  } else if (!isComposing) {
    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
      eventType = eventTypes.compositionStart;
    }
  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
    eventType = eventTypes.compositionEnd;
  }

  if (!eventType) {
    return null;
  }

  if (useFallbackCompositionData) {
    // The current composition is stored statically and must not be
    // overwritten while composition continues.
    if (!isComposing && eventType === eventTypes.compositionStart) {
      isComposing = initialize(nativeEventTarget);
    } else if (eventType === eventTypes.compositionEnd) {
      if (isComposing) {
        fallbackData = getData();
      }
    }
  }

  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);

  if (fallbackData) {
    // Inject data generated from fallback path into the synthetic event.
    // This matches the property of native CompositionEventInterface.
    event.data = fallbackData;
  } else {
    var customData = getDataFromCustomEvent(nativeEvent);
    if (customData !== null) {
      event.data = customData;
    }
  }

  accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * @param {TopLevelTypes} topLevelType Record from `BrowserEventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The string corresponding to this `beforeInput` event.
 */
function getNativeBeforeInputChars(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case 'topCompositionEnd':
      return getDataFromCustomEvent(nativeEvent);
    case 'topKeyPress':
      /**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */
      var which = nativeEvent.which;
      if (which !== SPACEBAR_CODE) {
        return null;
      }

      hasSpaceKeypress = true;
      return SPACEBAR_CHAR;

    case 'topTextInput':
      // Record the characters to be added to the DOM.
      var chars = nativeEvent.data;

      // If it's a spacebar character, assume that we have already handled
      // it at the keypress level and bail immediately. Android Chrome
      // doesn't give us keycodes, so we need to blacklist it.
      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
        return null;
      }

      return chars;

    default:
      // For other native event types, do nothing.
      return null;
  }
}

/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The fallback string for this `beforeInput` event.
 */
function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
  // If we are currently composing (IME) and using a fallback to do so,
  // try to extract the composed characters from the fallback object.
  // If composition event is available, we extract a string only at
  // compositionevent, otherwise extract it at fallback events.
  if (isComposing) {
    if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {
      var chars = getData();
      reset();
      isComposing = false;
      return chars;
    }
    return null;
  }

  switch (topLevelType) {
    case 'topPaste':
      // If a paste event occurs after a keypress, throw out the input
      // chars. Paste events should not lead to BeforeInput events.
      return null;
    case 'topKeyPress':
      /**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */
      if (!isKeypressCommand(nativeEvent)) {
        // IE fires the `keypress` event when a user types an emoji via
        // Touch keyboard of Windows.  In such a case, the `char` property
        // holds an emoji character like `\uD83D\uDE0A`.  Because its length
        // is 2, the property `which` does not represent an emoji correctly.
        // In such a case, we directly return the `char` property instead of
        // using `which`.
        if (nativeEvent.char && nativeEvent.char.length > 1) {
          return nativeEvent.char;
        } else if (nativeEvent.which) {
          return String.fromCharCode(nativeEvent.which);
        }
      }
      return null;
    case 'topCompositionEnd':
      return useFallbackCompositionData ? null : nativeEvent.data;
    default:
      return null;
  }
}

/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @return {?object} A SyntheticInputEvent.
 */
function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var chars;

  if (canUseTextInputEvent) {
    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
  } else {
    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
  }

  // If no characters are being inserted, no BeforeInput event should
  // be fired.
  if (!chars) {
    return null;
  }

  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);

  event.data = chars;
  accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */
var BeforeInputEventPlugin = {
  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
  }
};

// Use to restore controlled state after a change event has fired.

var fiberHostComponent = null;

var ReactControlledComponentInjection = {
  injectFiberControlledHostComponent: function (hostComponentImpl) {
    // The fiber implementation doesn't use dynamic dispatch so we need to
    // inject the implementation.
    fiberHostComponent = hostComponentImpl;
  }
};

var restoreTarget = null;
var restoreQueue = null;

function restoreStateOfTarget(target) {
  // We perform this translation at the end of the event loop so that we
  // always receive the correct fiber here
  var internalInstance = getInstanceFromNode(target);
  if (!internalInstance) {
    // Unmounted
    return;
  }
  !(fiberHostComponent && typeof fiberHostComponent.restoreControlledState === 'function') ? invariant(false, 'Fiber needs to be injected to handle a fiber target for controlled events. This error is likely caused by a bug in React. Please file an issue.') : void 0;
  var props = getFiberCurrentPropsFromNode(internalInstance.stateNode);
  fiberHostComponent.restoreControlledState(internalInstance.stateNode, internalInstance.type, props);
}

var injection$3 = ReactControlledComponentInjection;

function enqueueStateRestore(target) {
  if (restoreTarget) {
    if (restoreQueue) {
      restoreQueue.push(target);
    } else {
      restoreQueue = [target];
    }
  } else {
    restoreTarget = target;
  }
}

function restoreStateIfNeeded() {
  if (!restoreTarget) {
    return;
  }
  var target = restoreTarget;
  var queuedTargets = restoreQueue;
  restoreTarget = null;
  restoreQueue = null;

  restoreStateOfTarget(target);
  if (queuedTargets) {
    for (var i = 0; i < queuedTargets.length; i++) {
      restoreStateOfTarget(queuedTargets[i]);
    }
  }
}

var ReactControlledComponent = Object.freeze({
	injection: injection$3,
	enqueueStateRestore: enqueueStateRestore,
	restoreStateIfNeeded: restoreStateIfNeeded
});

// Used as a way to call batchedUpdates when we don't have a reference to
// the renderer. Such as when we're dispatching events or if third party
// libraries need to call batchedUpdates. Eventually, this API will go away when
// everything is batched by default. We'll then have a similar API to opt-out of
// scheduled work and instead do synchronous work.

// Defaults
var fiberBatchedUpdates = function (fn, bookkeeping) {
  return fn(bookkeeping);
};

var isNestingBatched = false;
function batchedUpdates(fn, bookkeeping) {
  if (isNestingBatched) {
    // If we are currently inside another batch, we need to wait until it
    // fully completes before restoring state. Therefore, we add the target to
    // a queue of work.
    return fiberBatchedUpdates(fn, bookkeeping);
  }
  isNestingBatched = true;
  try {
    return fiberBatchedUpdates(fn, bookkeeping);
  } finally {
    // Here we wait until all updates have propagated, which is important
    // when using controlled components within layers:
    // https://github.com/facebook/react/issues/1698
    // Then we restore state of any controlled component.
    isNestingBatched = false;
    restoreStateIfNeeded();
  }
}

var ReactGenericBatchingInjection = {
  injectFiberBatchedUpdates: function (_batchedUpdates) {
    fiberBatchedUpdates = _batchedUpdates;
  }
};

var injection$4 = ReactGenericBatchingInjection;

/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */
var supportedInputTypes = {
  color: true,
  date: true,
  datetime: true,
  'datetime-local': true,
  email: true,
  month: true,
  number: true,
  password: true,
  range: true,
  search: true,
  tel: true,
  text: true,
  time: true,
  url: true,
  week: true
};

function isTextInputElement(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();

  if (nodeName === 'input') {
    return !!supportedInputTypes[elem.type];
  }

  if (nodeName === 'textarea') {
    return true;
  }

  return false;
}

/**
 * HTML nodeType values that represent the type of the node
 */

var ELEMENT_NODE = 1;
var TEXT_NODE = 3;
var COMMENT_NODE = 8;
var DOCUMENT_NODE = 9;
var DOCUMENT_FRAGMENT_NODE = 11;

/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */
function getEventTarget(nativeEvent) {
  var target = nativeEvent.target || nativeEvent.srcElement || window;

  // Normalize SVG <use> element events #4963
  if (target.correspondingUseElement) {
    target = target.correspondingUseElement;
  }

  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
  // @see http://www.quirksmode.org/js/events_properties.html
  return target.nodeType === TEXT_NODE ? target.parentNode : target;
}

var useHasFeature;
if (ExecutionEnvironment.canUseDOM) {
  useHasFeature = document.implementation && document.implementation.hasFeature &&
  // always returns true in newer browsers as per the standard.
  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
  document.implementation.hasFeature('', '') !== true;
}

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported(eventNameSuffix, capture) {
  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = eventName in document;

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}

function isCheckable(elem) {
  var type = elem.type;
  var nodeName = elem.nodeName;
  return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');
}

function getTracker(node) {
  return node._valueTracker;
}

function detachTracker(node) {
  node._valueTracker = null;
}

function getValueFromNode(node) {
  var value = '';
  if (!node) {
    return value;
  }

  if (isCheckable(node)) {
    value = node.checked ? 'true' : 'false';
  } else {
    value = node.value;
  }

  return value;
}

function trackValueOnNode(node) {
  var valueField = isCheckable(node) ? 'checked' : 'value';
  var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);

  var currentValue = '' + node[valueField];

  // if someone has already defined a value or Safari, then bail
  // and don't track value will cause over reporting of changes,
  // but it's better then a hard failure
  // (needed for certain tests that spyOn input values and Safari)
  if (node.hasOwnProperty(valueField) || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') {
    return;
  }

  Object.defineProperty(node, valueField, {
    enumerable: descriptor.enumerable,
    configurable: true,
    get: function () {
      return descriptor.get.call(this);
    },
    set: function (value) {
      currentValue = '' + value;
      descriptor.set.call(this, value);
    }
  });

  var tracker = {
    getValue: function () {
      return currentValue;
    },
    setValue: function (value) {
      currentValue = '' + value;
    },
    stopTracking: function () {
      detachTracker(node);
      delete node[valueField];
    }
  };
  return tracker;
}

function track(node) {
  if (getTracker(node)) {
    return;
  }

  // TODO: Once it's just Fiber we can move this to node._wrapperState
  node._valueTracker = trackValueOnNode(node);
}

function updateValueIfChanged(node) {
  if (!node) {
    return false;
  }

  var tracker = getTracker(node);
  // if there is no tracker at this point it's unlikely
  // that trying again will succeed
  if (!tracker) {
    return true;
  }

  var lastValue = tracker.getValue();
  var nextValue = getValueFromNode(node);
  if (nextValue !== lastValue) {
    tracker.setValue(nextValue);
    return true;
  }
  return false;
}

var eventTypes$1 = {
  change: {
    phasedRegistrationNames: {
      bubbled: 'onChange',
      captured: 'onChangeCapture'
    },
    dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']
  }
};

function createAndAccumulateChangeEvent(inst, nativeEvent, target) {
  var event = SyntheticEvent$1.getPooled(eventTypes$1.change, inst, nativeEvent, target);
  event.type = 'change';
  // Flag this event loop as needing state restore.
  enqueueStateRestore(target);
  accumulateTwoPhaseDispatches(event);
  return event;
}
/**
 * For IE shims
 */
var activeElement = null;
var activeElementInst = null;

/**
 * SECTION: handle `change` event
 */
function shouldUseChangeEvent(elem) {
  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
}

function manualDispatchChangeEvent(nativeEvent) {
  var event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent));

  // If change and propertychange bubbled, we'd just bind to it like all the
  // other events and have it go through ReactBrowserEventEmitter. Since it
  // doesn't, we manually listen for the events and so we have to enqueue and
  // process the abstract event manually.
  //
  // Batching is necessary here in order to ensure that all event handlers run
  // before the next rerender (including event handlers attached to ancestor
  // elements instead of directly on the input). Without this, controlled
  // components don't work properly in conjunction with event bubbling because
  // the component is rerendered and the value reverted before all the event
  // handlers can run. See https://github.com/facebook/react/issues/708.
  batchedUpdates(runEventInBatch, event);
}

function runEventInBatch(event) {
  enqueueEvents(event);
  processEventQueue(false);
}

function getInstIfValueChanged(targetInst) {
  var targetNode = getNodeFromInstance$1(targetInst);
  if (updateValueIfChanged(targetNode)) {
    return targetInst;
  }
}

function getTargetInstForChangeEvent(topLevelType, targetInst) {
  if (topLevelType === 'topChange') {
    return targetInst;
  }
}

/**
 * SECTION: handle `input` event
 */
var isInputEventSupported = false;
if (ExecutionEnvironment.canUseDOM) {
  // IE9 claims to support the input event but fails to trigger it when
  // deleting text, so we ignore its input events.
  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 9);
}

/**
 * (For IE <=9) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */
function startWatchingForValueChange(target, targetInst) {
  activeElement = target;
  activeElementInst = targetInst;
  activeElement.attachEvent('onpropertychange', handlePropertyChange);
}

/**
 * (For IE <=9) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */
function stopWatchingForValueChange() {
  if (!activeElement) {
    return;
  }
  activeElement.detachEvent('onpropertychange', handlePropertyChange);
  activeElement = null;
  activeElementInst = null;
}

/**
 * (For IE <=9) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */
function handlePropertyChange(nativeEvent) {
  if (nativeEvent.propertyName !== 'value') {
    return;
  }
  if (getInstIfValueChanged(activeElementInst)) {
    manualDispatchChangeEvent(nativeEvent);
  }
}

function handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {
  if (topLevelType === 'topFocus') {
    // In IE9, propertychange fires for most input events but is buggy and
    // doesn't fire when text is deleted, but conveniently, selectionchange
    // appears to fire in all of the remaining cases so we catch those and
    // forward the event if the value has changed
    // In either case, we don't want to call the event handler if the value
    // is changed from JS so we redefine a setter for `.value` that updates
    // our activeElementValue variable, allowing us to ignore those changes
    //
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForValueChange();
    startWatchingForValueChange(target, targetInst);
  } else if (topLevelType === 'topBlur') {
    stopWatchingForValueChange();
  }
}

// For IE8 and IE9.
function getTargetInstForInputEventPolyfill(topLevelType, targetInst) {
  if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {
    // On the selectionchange event, the target is just document which isn't
    // helpful for us so just check activeElement instead.
    //
    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
    // propertychange on the first input event after setting `value` from a
    // script and fires only keydown, keypress, keyup. Catching keyup usually
    // gets it and catching keydown lets us fire an event for the first
    // keystroke if user does a key repeat (it'll be a little delayed: right
    // before the second keystroke). Other input methods (e.g., paste) seem to
    // fire selectionchange normally.
    return getInstIfValueChanged(activeElementInst);
  }
}

/**
 * SECTION: handle `click` event
 */
function shouldUseClickEvent(elem) {
  // Use the `click` event to detect changes to checkbox and radio inputs.
  // This approach works across all browsers, whereas `change` does not fire
  // until `blur` in IE8.
  var nodeName = elem.nodeName;
  return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
}

function getTargetInstForClickEvent(topLevelType, targetInst) {
  if (topLevelType === 'topClick') {
    return getInstIfValueChanged(targetInst);
  }
}

function getTargetInstForInputOrChangeEvent(topLevelType, targetInst) {
  if (topLevelType === 'topInput' || topLevelType === 'topChange') {
    return getInstIfValueChanged(targetInst);
  }
}

function handleControlledInputBlur(inst, node) {
  // TODO: In IE, inst is occasionally null. Why?
  if (inst == null) {
    return;
  }

  // Fiber and ReactDOM keep wrapper state in separate places
  var state = inst._wrapperState || node._wrapperState;

  if (!state || !state.controlled || node.type !== 'number') {
    return;
  }

  // If controlled, assign the value attribute to the current value on blur
  var value = '' + node.value;
  if (node.getAttribute('value') !== value) {
    node.setAttribute('value', value);
  }
}

/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */
var ChangeEventPlugin = {
  eventTypes: eventTypes$1,

  _isInputEventSupported: isInputEventSupported,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;

    var getTargetInstFunc, handleEventFunc;
    if (shouldUseChangeEvent(targetNode)) {
      getTargetInstFunc = getTargetInstForChangeEvent;
    } else if (isTextInputElement(targetNode)) {
      if (isInputEventSupported) {
        getTargetInstFunc = getTargetInstForInputOrChangeEvent;
      } else {
        getTargetInstFunc = getTargetInstForInputEventPolyfill;
        handleEventFunc = handleEventsForInputEventPolyfill;
      }
    } else if (shouldUseClickEvent(targetNode)) {
      getTargetInstFunc = getTargetInstForClickEvent;
    }

    if (getTargetInstFunc) {
      var inst = getTargetInstFunc(topLevelType, targetInst);
      if (inst) {
        var event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);
        return event;
      }
    }

    if (handleEventFunc) {
      handleEventFunc(topLevelType, targetNode, targetInst);
    }

    // When blurring, set the value attribute for number inputs
    if (topLevelType === 'topBlur') {
      handleControlledInputBlur(targetInst, targetNode);
    }
  }
};

/**
 * Module that is injectable into `EventPluginHub`, that specifies a
 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
 * plugins, without having to package every one of them. This is better than
 * having plugins be ordered in the same order that they are injected because
 * that ordering would be influenced by the packaging order.
 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
 */
var DOMEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];

/**
 * @interface UIEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var UIEventInterface = {
  view: null,
  detail: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticUIEvent, UIEventInterface);

/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */

var modifierKeyToProp = {
  Alt: 'altKey',
  Control: 'ctrlKey',
  Meta: 'metaKey',
  Shift: 'shiftKey'
};

// IE8 does not implement getModifierState so we simply map it to the only
// modifier keys exposed by the event itself, does not support Lock-keys.
// Currently, all major browsers except Chrome seems to support Lock-keys.
function modifierStateGetter(keyArg) {
  var syntheticEvent = this;
  var nativeEvent = syntheticEvent.nativeEvent;
  if (nativeEvent.getModifierState) {
    return nativeEvent.getModifierState(keyArg);
  }
  var keyProp = modifierKeyToProp[keyArg];
  return keyProp ? !!nativeEvent[keyProp] : false;
}

function getEventModifierState(nativeEvent) {
  return modifierStateGetter;
}

/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var MouseEventInterface = {
  screenX: null,
  screenY: null,
  clientX: null,
  clientY: null,
  pageX: null,
  pageY: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  getModifierState: getEventModifierState,
  button: null,
  buttons: null,
  relatedTarget: function (event) {
    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);

var eventTypes$2 = {
  mouseEnter: {
    registrationName: 'onMouseEnter',
    dependencies: ['topMouseOut', 'topMouseOver']
  },
  mouseLeave: {
    registrationName: 'onMouseLeave',
    dependencies: ['topMouseOut', 'topMouseOver']
  }
};

var EnterLeaveEventPlugin = {
  eventTypes: eventTypes$2,

  /**
   * For almost every interaction we care about, there will be both a top-level
   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
   * we do not extract duplicate events. However, moving the mouse into the
   * browser from outside will not fire a `mouseout` event. In this case, we use
   * the `mouseover` top-level event.
   */
  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
      return null;
    }
    if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {
      // Must not be a mouse in or mouse out - ignoring.
      return null;
    }

    var win;
    if (nativeEventTarget.window === nativeEventTarget) {
      // `nativeEventTarget` is probably a window object.
      win = nativeEventTarget;
    } else {
      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
      var doc = nativeEventTarget.ownerDocument;
      if (doc) {
        win = doc.defaultView || doc.parentWindow;
      } else {
        win = window;
      }
    }

    var from;
    var to;
    if (topLevelType === 'topMouseOut') {
      from = targetInst;
      var related = nativeEvent.relatedTarget || nativeEvent.toElement;
      to = related ? getClosestInstanceFromNode(related) : null;
    } else {
      // Moving to a node from outside the window.
      from = null;
      to = targetInst;
    }

    if (from === to) {
      // Nothing pertains to our managed components.
      return null;
    }

    var fromNode = from == null ? win : getNodeFromInstance$1(from);
    var toNode = to == null ? win : getNodeFromInstance$1(to);

    var leave = SyntheticMouseEvent.getPooled(eventTypes$2.mouseLeave, from, nativeEvent, nativeEventTarget);
    leave.type = 'mouseleave';
    leave.target = fromNode;
    leave.relatedTarget = toNode;

    var enter = SyntheticMouseEvent.getPooled(eventTypes$2.mouseEnter, to, nativeEvent, nativeEventTarget);
    enter.type = 'mouseenter';
    enter.target = toNode;
    enter.relatedTarget = fromNode;

    accumulateEnterLeaveDispatches(leave, enter, from, to);

    return [leave, enter];
  }
};

/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 *
 * Note that this module is currently shared and assumed to be stateless.
 * If this becomes an actual Map, that will break.
 */

/**
 * This API should be called `delete` but we'd have to make sure to always
 * transform these to strings for IE support. When this transform is fully
 * supported we can rename it.
 */


function get(key) {
  return key._reactInternalFiber;
}

function has(key) {
  return key._reactInternalFiber !== undefined;
}

function set(key, value) {
  key._reactInternalFiber = value;
}

var ReactInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

var ReactCurrentOwner = ReactInternals.ReactCurrentOwner;
var ReactDebugCurrentFrame = ReactInternals.ReactDebugCurrentFrame;

function getComponentName(fiber) {
  var type = fiber.type;

  if (typeof type === 'string') {
    return type;
  }
  if (typeof type === 'function') {
    return type.displayName || type.name;
  }
  return null;
}

// Don't change these two values:
var NoEffect = 0; //           0b00000000
var PerformedWork = 1; //      0b00000001

// You can change the rest (and add more).
var Placement = 2; //          0b00000010
var Update = 4; //             0b00000100
var PlacementAndUpdate = 6; // 0b00000110
var Deletion = 8; //           0b00001000
var ContentReset = 16; //      0b00010000
var Callback = 32; //          0b00100000
var Err = 64; //               0b01000000
var Ref = 128; //              0b10000000

var MOUNTING = 1;
var MOUNTED = 2;
var UNMOUNTED = 3;

function isFiberMountedImpl(fiber) {
  var node = fiber;
  if (!fiber.alternate) {
    // If there is no alternate, this might be a new tree that isn't inserted
    // yet. If it is, then it will have a pending insertion effect on it.
    if ((node.effectTag & Placement) !== NoEffect) {
      return MOUNTING;
    }
    while (node['return']) {
      node = node['return'];
      if ((node.effectTag & Placement) !== NoEffect) {
        return MOUNTING;
      }
    }
  } else {
    while (node['return']) {
      node = node['return'];
    }
  }
  if (node.tag === HostRoot) {
    // TODO: Check if this was a nested HostRoot when used with
    // renderContainerIntoSubtree.
    return MOUNTED;
  }
  // If we didn't hit the root, that means that we're in an disconnected tree
  // that has been unmounted.
  return UNMOUNTED;
}

function isFiberMounted(fiber) {
  return isFiberMountedImpl(fiber) === MOUNTED;
}

function isMounted(component) {
  {
    var owner = ReactCurrentOwner.current;
    if (owner !== null && owner.tag === ClassComponent) {
      var ownerFiber = owner;
      var instance = ownerFiber.stateNode;
      warning(instance._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(ownerFiber) || 'A component');
      instance._warnedAboutRefsInRender = true;
    }
  }

  var fiber = get(component);
  if (!fiber) {
    return false;
  }
  return isFiberMountedImpl(fiber) === MOUNTED;
}

function assertIsMounted(fiber) {
  !(isFiberMountedImpl(fiber) === MOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;
}

function findCurrentFiberUsingSlowPath(fiber) {
  var alternate = fiber.alternate;
  if (!alternate) {
    // If there is no alternate, then we only need to check if it is mounted.
    var state = isFiberMountedImpl(fiber);
    !(state !== UNMOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;
    if (state === MOUNTING) {
      return null;
    }
    return fiber;
  }
  // If we have two possible branches, we'll walk backwards up to the root
  // to see what path the root points to. On the way we may hit one of the
  // special cases and we'll deal with them.
  var a = fiber;
  var b = alternate;
  while (true) {
    var parentA = a['return'];
    var parentB = parentA ? parentA.alternate : null;
    if (!parentA || !parentB) {
      // We're at the root.
      break;
    }

    // If both copies of the parent fiber point to the same child, we can
    // assume that the child is current. This happens when we bailout on low
    // priority: the bailed out fiber's child reuses the current child.
    if (parentA.child === parentB.child) {
      var child = parentA.child;
      while (child) {
        if (child === a) {
          // We've determined that A is the current branch.
          assertIsMounted(parentA);
          return fiber;
        }
        if (child === b) {
          // We've determined that B is the current branch.
          assertIsMounted(parentA);
          return alternate;
        }
        child = child.sibling;
      }
      // We should never have an alternate for any mounting node. So the only
      // way this could possibly happen is if this was unmounted, if at all.
      invariant(false, 'Unable to find node on an unmounted component.');
    }

    if (a['return'] !== b['return']) {
      // The return pointer of A and the return pointer of B point to different
      // fibers. We assume that return pointers never criss-cross, so A must
      // belong to the child set of A.return, and B must belong to the child
      // set of B.return.
      a = parentA;
      b = parentB;
    } else {
      // The return pointers point to the same fiber. We'll have to use the
      // default, slow path: scan the child sets of each parent alternate to see
      // which child belongs to which set.
      //
      // Search parent A's child set
      var didFindChild = false;
      var _child = parentA.child;
      while (_child) {
        if (_child === a) {
          didFindChild = true;
          a = parentA;
          b = parentB;
          break;
        }
        if (_child === b) {
          didFindChild = true;
          b = parentA;
          a = parentB;
          break;
        }
        _child = _child.sibling;
      }
      if (!didFindChild) {
        // Search parent B's child set
        _child = parentB.child;
        while (_child) {
          if (_child === a) {
            didFindChild = true;
            a = parentB;
            b = parentA;
            break;
          }
          if (_child === b) {
            didFindChild = true;
            b = parentB;
            a = parentA;
            break;
          }
          _child = _child.sibling;
        }
        !didFindChild ? invariant(false, 'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.') : void 0;
      }
    }

    !(a.alternate === b) ? invariant(false, 'Return fibers should always be each others\' alternates. This error is likely caused by a bug in React. Please file an issue.') : void 0;
  }
  // If the root is not a host container, we're in a disconnected tree. I.e.
  // unmounted.
  !(a.tag === HostRoot) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;
  if (a.stateNode.current === a) {
    // We've determined that A is the current branch.
    return fiber;
  }
  // Otherwise B has to be current branch.
  return alternate;
}

function findCurrentHostFiber(parent) {
  var currentParent = findCurrentFiberUsingSlowPath(parent);
  if (!currentParent) {
    return null;
  }

  // Next we'll drill down this component to find the first HostComponent/Text.
  var node = currentParent;
  while (true) {
    if (node.tag === HostComponent || node.tag === HostText) {
      return node;
    } else if (node.child) {
      node.child['return'] = node;
      node = node.child;
      continue;
    }
    if (node === currentParent) {
      return null;
    }
    while (!node.sibling) {
      if (!node['return'] || node['return'] === currentParent) {
        return null;
      }
      node = node['return'];
    }
    node.sibling['return'] = node['return'];
    node = node.sibling;
  }
  // Flow needs the return null here, but ESLint complains about it.
  // eslint-disable-next-line no-unreachable
  return null;
}

function findCurrentHostFiberWithNoPortals(parent) {
  var currentParent = findCurrentFiberUsingSlowPath(parent);
  if (!currentParent) {
    return null;
  }

  // Next we'll drill down this component to find the first HostComponent/Text.
  var node = currentParent;
  while (true) {
    if (node.tag === HostComponent || node.tag === HostText) {
      return node;
    } else if (node.child && node.tag !== HostPortal) {
      node.child['return'] = node;
      node = node.child;
      continue;
    }
    if (node === currentParent) {
      return null;
    }
    while (!node.sibling) {
      if (!node['return'] || node['return'] === currentParent) {
        return null;
      }
      node = node['return'];
    }
    node.sibling['return'] = node['return'];
    node = node.sibling;
  }
  // Flow needs the return null here, but ESLint complains about it.
  // eslint-disable-next-line no-unreachable
  return null;
}

var CALLBACK_BOOKKEEPING_POOL_SIZE = 10;
var callbackBookkeepingPool = [];

/**
 * Find the deepest React component completely containing the root of the
 * passed-in instance (for use when entire React trees are nested within each
 * other). If React trees are not nested, returns null.
 */
function findRootContainerNode(inst) {
  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
  // traversal, but caching is difficult to do correctly without using a
  // mutation observer to listen for all DOM changes.
  while (inst['return']) {
    inst = inst['return'];
  }
  if (inst.tag !== HostRoot) {
    // This can happen if we're in a detached tree.
    return null;
  }
  return inst.stateNode.containerInfo;
}

// Used to store ancestor hierarchy in top level callback
function getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst) {
  if (callbackBookkeepingPool.length) {
    var instance = callbackBookkeepingPool.pop();
    instance.topLevelType = topLevelType;
    instance.nativeEvent = nativeEvent;
    instance.targetInst = targetInst;
    return instance;
  }
  return {
    topLevelType: topLevelType,
    nativeEvent: nativeEvent,
    targetInst: targetInst,
    ancestors: []
  };
}

function releaseTopLevelCallbackBookKeeping(instance) {
  instance.topLevelType = null;
  instance.nativeEvent = null;
  instance.targetInst = null;
  instance.ancestors.length = 0;
  if (callbackBookkeepingPool.length < CALLBACK_BOOKKEEPING_POOL_SIZE) {
    callbackBookkeepingPool.push(instance);
  }
}

function handleTopLevelImpl(bookKeeping) {
  var targetInst = bookKeeping.targetInst;

  // Loop through the hierarchy, in case there's any nested components.
  // It's important that we build the array of ancestors before calling any
  // event handlers, because event handlers can modify the DOM, leading to
  // inconsistencies with ReactMount's node cache. See #1105.
  var ancestor = targetInst;
  do {
    if (!ancestor) {
      bookKeeping.ancestors.push(ancestor);
      break;
    }
    var root = findRootContainerNode(ancestor);
    if (!root) {
      break;
    }
    bookKeeping.ancestors.push(ancestor);
    ancestor = getClosestInstanceFromNode(root);
  } while (ancestor);

  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
    targetInst = bookKeeping.ancestors[i];
    _handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
  }
}

// TODO: can we stop exporting these?
var _enabled = true;
var _handleTopLevel = void 0;

function setHandleTopLevel(handleTopLevel) {
  _handleTopLevel = handleTopLevel;
}

function setEnabled(enabled) {
  _enabled = !!enabled;
}

function isEnabled() {
  return _enabled;
}

/**
 * Traps top-level events by using event bubbling.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {string} handlerBaseName Event name (e.g. "click").
 * @param {object} element Element on which to attach listener.
 * @return {?object} An object with a remove function which will forcefully
 *                  remove the listener.
 * @internal
 */
function trapBubbledEvent(topLevelType, handlerBaseName, element) {
  if (!element) {
    return null;
  }
  return EventListener.listen(element, handlerBaseName, dispatchEvent.bind(null, topLevelType));
}

/**
 * Traps a top-level event by using event capturing.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {string} handlerBaseName Event name (e.g. "click").
 * @param {object} element Element on which to attach listener.
 * @return {?object} An object with a remove function which will forcefully
 *                  remove the listener.
 * @internal
 */
function trapCapturedEvent(topLevelType, handlerBaseName, element) {
  if (!element) {
    return null;
  }
  return EventListener.capture(element, handlerBaseName, dispatchEvent.bind(null, topLevelType));
}

function dispatchEvent(topLevelType, nativeEvent) {
  if (!_enabled) {
    return;
  }

  var nativeEventTarget = getEventTarget(nativeEvent);
  var targetInst = getClosestInstanceFromNode(nativeEventTarget);
  if (targetInst !== null && typeof targetInst.tag === 'number' && !isFiberMounted(targetInst)) {
    // If we get an event (ex: img onload) before committing that
    // component's mount, ignore it for now (that is, treat it as if it was an
    // event on a non-React tree). We might also consider queueing events and
    // dispatching them after the mount.
    targetInst = null;
  }

  var bookKeeping = getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst);

  try {
    // Event queue being processed in the same cycle allows
    // `preventDefault`.
    batchedUpdates(handleTopLevelImpl, bookKeeping);
  } finally {
    releaseTopLevelCallbackBookKeeping(bookKeeping);
  }
}

var ReactDOMEventListener = Object.freeze({
	get _enabled () { return _enabled; },
	get _handleTopLevel () { return _handleTopLevel; },
	setHandleTopLevel: setHandleTopLevel,
	setEnabled: setEnabled,
	isEnabled: isEnabled,
	trapBubbledEvent: trapBubbledEvent,
	trapCapturedEvent: trapCapturedEvent,
	dispatchEvent: dispatchEvent
});

/**
 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
 *
 * @param {string} styleProp
 * @param {string} eventName
 * @returns {object}
 */
function makePrefixMap(styleProp, eventName) {
  var prefixes = {};

  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
  prefixes['Moz' + styleProp] = 'moz' + eventName;
  prefixes['ms' + styleProp] = 'MS' + eventName;
  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();

  return prefixes;
}

/**
 * A list of event names to a configurable list of vendor prefixes.
 */
var vendorPrefixes = {
  animationend: makePrefixMap('Animation', 'AnimationEnd'),
  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
  animationstart: makePrefixMap('Animation', 'AnimationStart'),
  transitionend: makePrefixMap('Transition', 'TransitionEnd')
};

/**
 * Event names that have already been detected and prefixed (if applicable).
 */
var prefixedEventNames = {};

/**
 * Element to check for prefixes on.
 */
var style = {};

/**
 * Bootstrap if a DOM exists.
 */
if (ExecutionEnvironment.canUseDOM) {
  style = document.createElement('div').style;

  // On some platforms, in particular some releases of Android 4.x,
  // the un-prefixed "animation" and "transition" properties are defined on the
  // style object but the events that fire will still be prefixed, so we need
  // to check if the un-prefixed events are usable, and if not remove them from the map.
  if (!('AnimationEvent' in window)) {
    delete vendorPrefixes.animationend.animation;
    delete vendorPrefixes.animationiteration.animation;
    delete vendorPrefixes.animationstart.animation;
  }

  // Same as above
  if (!('TransitionEvent' in window)) {
    delete vendorPrefixes.transitionend.transition;
  }
}

/**
 * Attempts to determine the correct vendor prefixed event name.
 *
 * @param {string} eventName
 * @returns {string}
 */
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) {
    return prefixedEventNames[eventName];
  } else if (!vendorPrefixes[eventName]) {
    return eventName;
  }

  var prefixMap = vendorPrefixes[eventName];

  for (var styleProp in prefixMap) {
    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
      return prefixedEventNames[eventName] = prefixMap[styleProp];
    }
  }

  return '';
}

/**
 * Types of raw signals from the browser caught at the top level.
 *
 * For events like 'submit' which don't consistently bubble (which we
 * trap at a lower node than `document`), binding at `document` would
 * cause duplicate events so we don't include them here.
 */
var topLevelTypes$1 = {
  topAbort: 'abort',
  topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
  topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
  topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
  topBlur: 'blur',
  topCancel: 'cancel',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topChange: 'change',
  topClick: 'click',
  topClose: 'close',
  topCompositionEnd: 'compositionend',
  topCompositionStart: 'compositionstart',
  topCompositionUpdate: 'compositionupdate',
  topContextMenu: 'contextmenu',
  topCopy: 'copy',
  topCut: 'cut',
  topDoubleClick: 'dblclick',
  topDrag: 'drag',
  topDragEnd: 'dragend',
  topDragEnter: 'dragenter',
  topDragExit: 'dragexit',
  topDragLeave: 'dragleave',
  topDragOver: 'dragover',
  topDragStart: 'dragstart',
  topDrop: 'drop',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topFocus: 'focus',
  topInput: 'input',
  topKeyDown: 'keydown',
  topKeyPress: 'keypress',
  topKeyUp: 'keyup',
  topLoadedData: 'loadeddata',
  topLoad: 'load',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topMouseDown: 'mousedown',
  topMouseMove: 'mousemove',
  topMouseOut: 'mouseout',
  topMouseOver: 'mouseover',
  topMouseUp: 'mouseup',
  topPaste: 'paste',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topScroll: 'scroll',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topSelectionChange: 'selectionchange',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTextInput: 'textInput',
  topTimeUpdate: 'timeupdate',
  topToggle: 'toggle',
  topTouchCancel: 'touchcancel',
  topTouchEnd: 'touchend',
  topTouchMove: 'touchmove',
  topTouchStart: 'touchstart',
  topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting',
  topWheel: 'wheel'
};

var BrowserEventConstants = {
  topLevelTypes: topLevelTypes$1
};

function runEventQueueInBatch(events) {
  enqueueEvents(events);
  processEventQueue(false);
}

/**
 * Streams a fired top-level event to `EventPluginHub` where plugins have the
 * opportunity to create `ReactEvent`s to be dispatched.
 */
function handleTopLevel(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events = extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
  runEventQueueInBatch(events);
}

var topLevelTypes = BrowserEventConstants.topLevelTypes;

/**
 * Summary of `ReactBrowserEventEmitter` event handling:
 *
 *  - Top-level delegation is used to trap most native browser events. This
 *    may only occur in the main thread and is the responsibility of
 *    ReactDOMEventListener, which is injected and can therefore support
 *    pluggable event sources. This is the only work that occurs in the main
 *    thread.
 *
 *  - We normalize and de-duplicate events to account for browser quirks. This
 *    may be done in the worker thread.
 *
 *  - Forward these native events (with the associated top-level type used to
 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
 *    to extract any synthetic events.
 *
 *  - The `EventPluginHub` will then process each event by annotating them with
 *    "dispatches", a sequence of listeners and IDs that care about that event.
 *
 *  - The `EventPluginHub` then dispatches the events.
 *
 * Overview of React and the event system:
 *
 * +------------+    .
 * |    DOM     |    .
 * +------------+    .
 *       |           .
 *       v           .
 * +------------+    .
 * | ReactEvent |    .
 * |  Listener  |    .
 * +------------+    .                         +-----------+
 *       |           .               +--------+|SimpleEvent|
 *       |           .               |         |Plugin     |
 * +-----|------+    .               v         +-----------+
 * |     |      |    .    +--------------+                    +------------+
 * |     +-----------.--->|EventPluginHub|                    |    Event   |
 * |            |    .    |              |     +-----------+  | Propagators|
 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
 * |            |    .    |              |     +-----------+  |  utilities |
 * |     +-----------.--->|              |                    +------------+
 * |     |      |    .    +--------------+
 * +-----|------+    .                ^        +-----------+
 *       |           .                |        |Enter/Leave|
 *       +           .                +-------+|Plugin     |
 * +-------------+   .                         +-----------+
 * | application |   .
 * |-------------|   .
 * |             |   .
 * |             |   .
 * +-------------+   .
 *                   .
 *    React Core     .  General Purpose Event Plugin System
 */

var alreadyListeningTo = {};
var reactTopListenersCounter = 0;

/**
 * To ensure no conflicts with other potential React instances on the page
 */
var topListenersIDKey = '_reactListenersID' + ('' + Math.random()).slice(2);

function getListeningForDocument(mountAt) {
  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
  // directly.
  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
    mountAt[topListenersIDKey] = reactTopListenersCounter++;
    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
  }
  return alreadyListeningTo[mountAt[topListenersIDKey]];
}

/**
 * We listen for bubbled touch events on the document object.
 *
 * Firefox v8.01 (and possibly others) exhibited strange behavior when
 * mounting `onmousemove` events at some node that was not the document
 * element. The symptoms were that if your mouse is not moving over something
 * contained within that mount point (for example on the background) the
 * top-level listeners for `onmousemove` won't be called. However, if you
 * register the `mousemove` on the document object, then it will of course
 * catch all `mousemove`s. This along with iOS quirks, justifies restricting
 * top-level listeners to the document object only, at least for these
 * movement types of events and possibly all events.
 *
 * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
 *
 * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
 * they bubble to document.
 *
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @param {object} contentDocumentHandle Document which owns the container
 */
function listenTo(registrationName, contentDocumentHandle) {
  var mountAt = contentDocumentHandle;
  var isListening = getListeningForDocument(mountAt);
  var dependencies = registrationNameDependencies[registrationName];

  for (var i = 0; i < dependencies.length; i++) {
    var dependency = dependencies[i];
    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
      if (dependency === 'topScroll') {
        trapCapturedEvent('topScroll', 'scroll', mountAt);
      } else if (dependency === 'topFocus' || dependency === 'topBlur') {
        trapCapturedEvent('topFocus', 'focus', mountAt);
        trapCapturedEvent('topBlur', 'blur', mountAt);

        // to make sure blur and focus event listeners are only attached once
        isListening.topBlur = true;
        isListening.topFocus = true;
      } else if (dependency === 'topCancel') {
        if (isEventSupported('cancel', true)) {
          trapCapturedEvent('topCancel', 'cancel', mountAt);
        }
        isListening.topCancel = true;
      } else if (dependency === 'topClose') {
        if (isEventSupported('close', true)) {
          trapCapturedEvent('topClose', 'close', mountAt);
        }
        isListening.topClose = true;
      } else if (topLevelTypes.hasOwnProperty(dependency)) {
        trapBubbledEvent(dependency, topLevelTypes[dependency], mountAt);
      }

      isListening[dependency] = true;
    }
  }
}

function isListeningToAllDependencies(registrationName, mountAt) {
  var isListening = getListeningForDocument(mountAt);
  var dependencies = registrationNameDependencies[registrationName];
  for (var i = 0; i < dependencies.length; i++) {
    var dependency = dependencies[i];
    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
      return false;
    }
  }
  return true;
}

/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */
function getLeafNode(node) {
  while (node && node.firstChild) {
    node = node.firstChild;
  }
  return node;
}

/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */
function getSiblingNode(node) {
  while (node) {
    if (node.nextSibling) {
      return node.nextSibling;
    }
    node = node.parentNode;
  }
}

/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */
function getNodeForCharacterOffset(root, offset) {
  var node = getLeafNode(root);
  var nodeStart = 0;
  var nodeEnd = 0;

  while (node) {
    if (node.nodeType === TEXT_NODE) {
      nodeEnd = nodeStart + node.textContent.length;

      if (nodeStart <= offset && nodeEnd >= offset) {
        return {
          node: node,
          offset: offset - nodeStart
        };
      }

      nodeStart = nodeEnd;
    }

    node = getLeafNode(getSiblingNode(node));
  }
}

/**
 * @param {DOMElement} outerNode
 * @return {?object}
 */
function getOffsets(outerNode) {
  var selection = window.getSelection && window.getSelection();

  if (!selection || selection.rangeCount === 0) {
    return null;
  }

  var anchorNode = selection.anchorNode,
      anchorOffset = selection.anchorOffset,
      focusNode$$1 = selection.focusNode,
      focusOffset = selection.focusOffset;

  // In Firefox, anchorNode and focusNode can be "anonymous divs", e.g. the
  // up/down buttons on an <input type="number">. Anonymous divs do not seem to
  // expose properties, triggering a "Permission denied error" if any of its
  // properties are accessed. The only seemingly possible way to avoid erroring
  // is to access a property that typically works for non-anonymous divs and
  // catch any error that may otherwise arise. See
  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427

  try {
    /* eslint-disable no-unused-expressions */
    anchorNode.nodeType;
    focusNode$$1.nodeType;
    /* eslint-enable no-unused-expressions */
  } catch (e) {
    return null;
  }

  return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode$$1, focusOffset);
}

/**
 * Returns {start, end} where `start` is the character/codepoint index of
 * (anchorNode, anchorOffset) within the textContent of `outerNode`, and
 * `end` is the index of (focusNode, focusOffset).
 *
 * Returns null if you pass in garbage input but we should probably just crash.
 *
 * Exported only for testing.
 */
function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode$$1, focusOffset) {
  var length = 0;
  var start = -1;
  var end = -1;
  var indexWithinAnchor = 0;
  var indexWithinFocus = 0;
  var node = outerNode;
  var parentNode = null;

  outer: while (true) {
    var next = null;

    while (true) {
      if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {
        start = length + anchorOffset;
      }
      if (node === focusNode$$1 && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {
        end = length + focusOffset;
      }

      if (node.nodeType === TEXT_NODE) {
        length += node.nodeValue.length;
      }

      if ((next = node.firstChild) === null) {
        break;
      }
      // Moving from `node` to its first child `next`.
      parentNode = node;
      node = next;
    }

    while (true) {
      if (node === outerNode) {
        // If `outerNode` has children, this is always the second time visiting
        // it. If it has no children, this is still the first loop, and the only
        // valid selection is anchorNode and focusNode both equal to this node
        // and both offsets 0, in which case we will have handled above.
        break outer;
      }
      if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
        start = length;
      }
      if (parentNode === focusNode$$1 && ++indexWithinFocus === focusOffset) {
        end = length;
      }
      if ((next = node.nextSibling) !== null) {
        break;
      }
      node = parentNode;
      parentNode = node.parentNode;
    }

    // Moving from `node` to its next sibling `next`.
    node = next;
  }

  if (start === -1 || end === -1) {
    // This should never happen. (Would happen if the anchor/focus nodes aren't
    // actually inside the passed-in node.)
    return null;
  }

  return {
    start: start,
    end: end
  };
}

/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setOffsets(node, offsets) {
  if (!window.getSelection) {
    return;
  }

  var selection = window.getSelection();
  var length = node[getTextContentAccessor()].length;
  var start = Math.min(offsets.start, length);
  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);

  // IE 11 uses modern selection, but doesn't support the extend method.
  // Flip backward selections, so we can set with a single range.
  if (!selection.extend && start > end) {
    var temp = end;
    end = start;
    start = temp;
  }

  var startMarker = getNodeForCharacterOffset(node, start);
  var endMarker = getNodeForCharacterOffset(node, end);

  if (startMarker && endMarker) {
    if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
      return;
    }
    var range = document.createRange();
    range.setStart(startMarker.node, startMarker.offset);
    selection.removeAllRanges();

    if (start > end) {
      selection.addRange(range);
      selection.extend(endMarker.node, endMarker.offset);
    } else {
      range.setEnd(endMarker.node, endMarker.offset);
      selection.addRange(range);
    }
  }
}

function isInDocument(node) {
  return containsNode(document.documentElement, node);
}

/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */

function hasSelectionCapabilities(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
}

function getSelectionInformation() {
  var focusedElem = getActiveElement();
  return {
    focusedElem: focusedElem,
    selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection$1(focusedElem) : null
  };
}

/**
 * @restoreSelection: If any selection information was potentially lost,
 * restore it. This is useful when performing operations that could remove dom
 * nodes and place them back in, resulting in focus being lost.
 */
function restoreSelection(priorSelectionInformation) {
  var curFocusedElem = getActiveElement();
  var priorFocusedElem = priorSelectionInformation.focusedElem;
  var priorSelectionRange = priorSelectionInformation.selectionRange;
  if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
    if (hasSelectionCapabilities(priorFocusedElem)) {
      setSelection(priorFocusedElem, priorSelectionRange);
    }

    // Focusing a node can change the scroll position, which is undesirable
    var ancestors = [];
    var ancestor = priorFocusedElem;
    while (ancestor = ancestor.parentNode) {
      if (ancestor.nodeType === ELEMENT_NODE) {
        ancestors.push({
          element: ancestor,
          left: ancestor.scrollLeft,
          top: ancestor.scrollTop
        });
      }
    }

    focusNode(priorFocusedElem);

    for (var i = 0; i < ancestors.length; i++) {
      var info = ancestors[i];
      info.element.scrollLeft = info.left;
      info.element.scrollTop = info.top;
    }
  }
}

/**
 * @getSelection: Gets the selection bounds of a focused textarea, input or
 * contentEditable node.
 * -@input: Look up selection bounds of this input
 * -@return {start: selectionStart, end: selectionEnd}
 */
function getSelection$1(input) {
  var selection = void 0;

  if ('selectionStart' in input) {
    // Modern browser with input or textarea.
    selection = {
      start: input.selectionStart,
      end: input.selectionEnd
    };
  } else {
    // Content editable or old IE textarea.
    selection = getOffsets(input);
  }

  return selection || { start: 0, end: 0 };
}

/**
 * @setSelection: Sets the selection bounds of a textarea or input and focuses
 * the input.
 * -@input     Set selection bounds of this input or textarea
 * -@offsets   Object of same form that is returned from get*
 */
function setSelection(input, offsets) {
  var start = offsets.start,
      end = offsets.end;

  if (end === undefined) {
    end = start;
  }

  if ('selectionStart' in input) {
    input.selectionStart = start;
    input.selectionEnd = Math.min(end, input.value.length);
  } else {
    setOffsets(input, offsets);
  }
}

var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;

var eventTypes$3 = {
  select: {
    phasedRegistrationNames: {
      bubbled: 'onSelect',
      captured: 'onSelectCapture'
    },
    dependencies: ['topBlur', 'topContextMenu', 'topFocus', 'topKeyDown', 'topKeyUp', 'topMouseDown', 'topMouseUp', 'topSelectionChange']
  }
};

var activeElement$1 = null;
var activeElementInst$1 = null;
var lastSelection = null;
var mouseDown = false;

/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getSelection(node) {
  if ('selectionStart' in node && hasSelectionCapabilities(node)) {
    return {
      start: node.selectionStart,
      end: node.selectionEnd
    };
  } else if (window.getSelection) {
    var selection = window.getSelection();
    return {
      anchorNode: selection.anchorNode,
      anchorOffset: selection.anchorOffset,
      focusNode: selection.focusNode,
      focusOffset: selection.focusOffset
    };
  }
}

/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @return {?SyntheticEvent}
 */
function constructSelectEvent(nativeEvent, nativeEventTarget) {
  // Ensure we have the right element, and that the user is not dragging a
  // selection (this matches native `select` event behavior). In HTML5, select
  // fires only on input and textarea thus if there's no focused element we
  // won't dispatch.
  if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement()) {
    return null;
  }

  // Only fire when selection has actually changed.
  var currentSelection = getSelection(activeElement$1);
  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
    lastSelection = currentSelection;

    var syntheticEvent = SyntheticEvent$1.getPooled(eventTypes$3.select, activeElementInst$1, nativeEvent, nativeEventTarget);

    syntheticEvent.type = 'select';
    syntheticEvent.target = activeElement$1;

    accumulateTwoPhaseDispatches(syntheticEvent);

    return syntheticEvent;
  }

  return null;
}

/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */
var SelectEventPlugin = {
  eventTypes: eventTypes$3,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : nativeEventTarget.nodeType === DOCUMENT_NODE ? nativeEventTarget : nativeEventTarget.ownerDocument;
    // Track whether all listeners exists for this plugin. If none exist, we do
    // not extract events. See #3639.
    if (!doc || !isListeningToAllDependencies('onSelect', doc)) {
      return null;
    }

    var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;

    switch (topLevelType) {
      // Track the input node that has focus.
      case 'topFocus':
        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
          activeElement$1 = targetNode;
          activeElementInst$1 = targetInst;
          lastSelection = null;
        }
        break;
      case 'topBlur':
        activeElement$1 = null;
        activeElementInst$1 = null;
        lastSelection = null;
        break;
      // Don't fire the event while the user is dragging. This matches the
      // semantics of the native select event.
      case 'topMouseDown':
        mouseDown = true;
        break;
      case 'topContextMenu':
      case 'topMouseUp':
        mouseDown = false;
        return constructSelectEvent(nativeEvent, nativeEventTarget);
      // Chrome and IE fire non-standard event when selection is changed (and
      // sometimes when it hasn't). IE's event fires out of order with respect
      // to key and input events on deletion, so we discard it.
      //
      // Firefox doesn't support selectionchange, so check selection status
      // after each key entry. The selection changes after keydown and before
      // keyup, but we check on keydown as well in the case of holding down a
      // key, when multiple keydown events are fired but only one keyup is.
      // This is also our approach for IE handling, for the reason above.
      case 'topSelectionChange':
        if (skipSelectionChangeEvent) {
          break;
        }
      // falls through
      case 'topKeyDown':
      case 'topKeyUp':
        return constructSelectEvent(nativeEvent, nativeEventTarget);
    }

    return null;
  }
};

/**
 * @interface Event
 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
 */
var AnimationEventInterface = {
  animationName: null,
  elapsedTime: null,
  pseudoElement: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);

/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */
var ClipboardEventInterface = {
  clipboardData: function (event) {
    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);

/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var FocusEventInterface = {
  relatedTarget: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);

/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */
function getEventCharCode(nativeEvent) {
  var charCode;
  var keyCode = nativeEvent.keyCode;

  if ('charCode' in nativeEvent) {
    charCode = nativeEvent.charCode;

    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
    if (charCode === 0 && keyCode === 13) {
      charCode = 13;
    }
  } else {
    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
    charCode = keyCode;
  }

  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
  // Must not discard the (non-)printable Enter-key.
  if (charCode >= 32 || charCode === 13) {
    return charCode;
  }

  return 0;
}

/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var normalizeKey = {
  Esc: 'Escape',
  Spacebar: ' ',
  Left: 'ArrowLeft',
  Up: 'ArrowUp',
  Right: 'ArrowRight',
  Down: 'ArrowDown',
  Del: 'Delete',
  Win: 'OS',
  Menu: 'ContextMenu',
  Apps: 'ContextMenu',
  Scroll: 'ScrollLock',
  MozPrintableKey: 'Unidentified'
};

/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var translateToKey = {
  '8': 'Backspace',
  '9': 'Tab',
  '12': 'Clear',
  '13': 'Enter',
  '16': 'Shift',
  '17': 'Control',
  '18': 'Alt',
  '19': 'Pause',
  '20': 'CapsLock',
  '27': 'Escape',
  '32': ' ',
  '33': 'PageUp',
  '34': 'PageDown',
  '35': 'End',
  '36': 'Home',
  '37': 'ArrowLeft',
  '38': 'ArrowUp',
  '39': 'ArrowRight',
  '40': 'ArrowDown',
  '45': 'Insert',
  '46': 'Delete',
  '112': 'F1',
  '113': 'F2',
  '114': 'F3',
  '115': 'F4',
  '116': 'F5',
  '117': 'F6',
  '118': 'F7',
  '119': 'F8',
  '120': 'F9',
  '121': 'F10',
  '122': 'F11',
  '123': 'F12',
  '144': 'NumLock',
  '145': 'ScrollLock',
  '224': 'Meta'
};

/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */
function getEventKey(nativeEvent) {
  if (nativeEvent.key) {
    // Normalize inconsistent values reported by browsers due to
    // implementations of a working draft specification.

    // FireFox implements `key` but returns `MozPrintableKey` for all
    // printable characters (normalized to `Unidentified`), ignore it.
    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
    if (key !== 'Unidentified') {
      return key;
    }
  }

  // Browser does not implement `key`, polyfill as much of it as we can.
  if (nativeEvent.type === 'keypress') {
    var charCode = getEventCharCode(nativeEvent);

    // The enter-key is technically both printable and non-printable and can
    // thus be captured by `keypress`, no other non-printable key should.
    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
  }
  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
    // While user keyboard layout determines the actual meaning of each
    // `keyCode` value, almost all function keys have a universal value.
    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
  }
  return '';
}

/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var KeyboardEventInterface = {
  key: getEventKey,
  location: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  repeat: null,
  locale: null,
  getModifierState: getEventModifierState,
  // Legacy Interface
  charCode: function (event) {
    // `charCode` is the result of a KeyPress event and represents the value of
    // the actual printable character.

    // KeyPress is deprecated, but its replacement is not yet final and not
    // implemented in any major browser. Only KeyPress has charCode.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    return 0;
  },
  keyCode: function (event) {
    // `keyCode` is the result of a KeyDown/Up event and represents the value of
    // physical keyboard key.

    // The actual meaning of the value depends on the users' keyboard layout
    // which cannot be detected. Assuming that it is a US keyboard layout
    // provides a surprisingly accurate mapping for US and European users.
    // Due to this, it is left to the user to implement at this time.
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  },
  which: function (event) {
    // `which` is an alias for either `keyCode` or `charCode` depending on the
    // type of the event.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);

/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var DragEventInterface = {
  dataTransfer: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */
function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);

/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */
var TouchEventInterface = {
  touches: null,
  targetTouches: null,
  changedTouches: null,
  altKey: null,
  metaKey: null,
  ctrlKey: null,
  shiftKey: null,
  getModifierState: getEventModifierState
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);

/**
 * @interface Event
 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
 */
var TransitionEventInterface = {
  propertyName: null,
  elapsedTime: null,
  pseudoElement: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);

/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var WheelEventInterface = {
  deltaX: function (event) {
    return 'deltaX' in event ? event.deltaX : // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
  },
  deltaY: function (event) {
    return 'deltaY' in event ? event.deltaY : // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
    'wheelDeltaY' in event ? -event.wheelDeltaY : // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
    'wheelDelta' in event ? -event.wheelDelta : 0;
  },
  deltaZ: null,

  // Browsers without "deltaMode" is reporting in raw wheel delta where one
  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
  deltaMode: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */
function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);

/**
 * Turns
 * ['abort', ...]
 * into
 * eventTypes = {
 *   'abort': {
 *     phasedRegistrationNames: {
 *       bubbled: 'onAbort',
 *       captured: 'onAbortCapture',
 *     },
 *     dependencies: ['topAbort'],
 *   },
 *   ...
 * };
 * topLevelEventsToDispatchConfig = {
 *   'topAbort': { sameConfig }
 * };
 */
var eventTypes$4 = {};
var topLevelEventsToDispatchConfig = {};
['abort', 'animationEnd', 'animationIteration', 'animationStart', 'blur', 'cancel', 'canPlay', 'canPlayThrough', 'click', 'close', 'contextMenu', 'copy', 'cut', 'doubleClick', 'drag', 'dragEnd', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'dragStart', 'drop', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'mouseDown', 'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'paste', 'pause', 'play', 'playing', 'progress', 'rateChange', 'reset', 'scroll', 'seeked', 'seeking', 'stalled', 'submit', 'suspend', 'timeUpdate', 'toggle', 'touchCancel', 'touchEnd', 'touchMove', 'touchStart', 'transitionEnd', 'volumeChange', 'waiting', 'wheel'].forEach(function (event) {
  var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
  var onEvent = 'on' + capitalizedEvent;
  var topEvent = 'top' + capitalizedEvent;

  var type = {
    phasedRegistrationNames: {
      bubbled: onEvent,
      captured: onEvent + 'Capture'
    },
    dependencies: [topEvent]
  };
  eventTypes$4[event] = type;
  topLevelEventsToDispatchConfig[topEvent] = type;
});

// Only used in DEV for exhaustiveness validation.
var knownHTMLTopLevelTypes = ['topAbort', 'topCancel', 'topCanPlay', 'topCanPlayThrough', 'topClose', 'topDurationChange', 'topEmptied', 'topEncrypted', 'topEnded', 'topError', 'topInput', 'topInvalid', 'topLoad', 'topLoadedData', 'topLoadedMetadata', 'topLoadStart', 'topPause', 'topPlay', 'topPlaying', 'topProgress', 'topRateChange', 'topReset', 'topSeeked', 'topSeeking', 'topStalled', 'topSubmit', 'topSuspend', 'topTimeUpdate', 'topToggle', 'topVolumeChange', 'topWaiting'];

var SimpleEventPlugin = {
  eventTypes: eventTypes$4,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
    if (!dispatchConfig) {
      return null;
    }
    var EventConstructor;
    switch (topLevelType) {
      case 'topKeyPress':
        // Firefox creates a keypress event for function keys too. This removes
        // the unwanted keypress events. Enter is however both printable and
        // non-printable. One would expect Tab to be as well (but it isn't).
        if (getEventCharCode(nativeEvent) === 0) {
          return null;
        }
      /* falls through */
      case 'topKeyDown':
      case 'topKeyUp':
        EventConstructor = SyntheticKeyboardEvent;
        break;
      case 'topBlur':
      case 'topFocus':
        EventConstructor = SyntheticFocusEvent;
        break;
      case 'topClick':
        // Firefox creates a click event on right mouse clicks. This removes the
        // unwanted click events.
        if (nativeEvent.button === 2) {
          return null;
        }
      /* falls through */
      case 'topDoubleClick':
      case 'topMouseDown':
      case 'topMouseMove':
      case 'topMouseUp':
      // TODO: Disabled elements should not respond to mouse events
      /* falls through */
      case 'topMouseOut':
      case 'topMouseOver':
      case 'topContextMenu':
        EventConstructor = SyntheticMouseEvent;
        break;
      case 'topDrag':
      case 'topDragEnd':
      case 'topDragEnter':
      case 'topDragExit':
      case 'topDragLeave':
      case 'topDragOver':
      case 'topDragStart':
      case 'topDrop':
        EventConstructor = SyntheticDragEvent;
        break;
      case 'topTouchCancel':
      case 'topTouchEnd':
      case 'topTouchMove':
      case 'topTouchStart':
        EventConstructor = SyntheticTouchEvent;
        break;
      case 'topAnimationEnd':
      case 'topAnimationIteration':
      case 'topAnimationStart':
        EventConstructor = SyntheticAnimationEvent;
        break;
      case 'topTransitionEnd':
        EventConstructor = SyntheticTransitionEvent;
        break;
      case 'topScroll':
        EventConstructor = SyntheticUIEvent;
        break;
      case 'topWheel':
        EventConstructor = SyntheticWheelEvent;
        break;
      case 'topCopy':
      case 'topCut':
      case 'topPaste':
        EventConstructor = SyntheticClipboardEvent;
        break;
      default:
        {
          if (knownHTMLTopLevelTypes.indexOf(topLevelType) === -1) {
            warning(false, 'SimpleEventPlugin: Unhandled event type, `%s`. This warning ' + 'is likely caused by a bug in React. Please file an issue.', topLevelType);
          }
        }
        // HTML Events
        // @see http://www.w3.org/TR/html5/index.html#events-0
        EventConstructor = SyntheticEvent$1;
        break;
    }
    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
    accumulateTwoPhaseDispatches(event);
    return event;
  }
};

setHandleTopLevel(handleTopLevel);

/**
 * Inject modules for resolving DOM hierarchy and plugin ordering.
 */
injection$1.injectEventPluginOrder(DOMEventPluginOrder);
injection$2.injectComponentTree(ReactDOMComponentTree);

/**
 * Some important event plugins included by default (without having to require
 * them).
 */
injection$1.injectEventPluginsByName({
  SimpleEventPlugin: SimpleEventPlugin,
  EnterLeaveEventPlugin: EnterLeaveEventPlugin,
  ChangeEventPlugin: ChangeEventPlugin,
  SelectEventPlugin: SelectEventPlugin,
  BeforeInputEventPlugin: BeforeInputEventPlugin
});

var enableAsyncSubtreeAPI = true;
var enableAsyncSchedulingByDefaultInReactDOM = false;
// Exports ReactDOM.createRoot
var enableCreateRoot = false;
var enableUserTimingAPI = true;

// Mutating mode (React DOM, React ART, React Native):
var enableMutatingReconciler = true;
// Experimental noop mode (currently unused):
var enableNoopReconciler = false;
// Experimental persistent mode (CS):
var enablePersistentReconciler = false;

// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:
var debugRenderPhaseSideEffects = false;

// Only used in www builds.

var valueStack = [];

{
  var fiberStack = [];
}

var index = -1;

function createCursor(defaultValue) {
  return {
    current: defaultValue
  };
}



function pop(cursor, fiber) {
  if (index < 0) {
    {
      warning(false, 'Unexpected pop.');
    }
    return;
  }

  {
    if (fiber !== fiberStack[index]) {
      warning(false, 'Unexpected Fiber popped.');
    }
  }

  cursor.current = valueStack[index];

  valueStack[index] = null;

  {
    fiberStack[index] = null;
  }

  index--;
}

function push(cursor, value, fiber) {
  index++;

  valueStack[index] = cursor.current;

  {
    fiberStack[index] = fiber;
  }

  cursor.current = value;
}

function reset$1() {
  while (index > -1) {
    valueStack[index] = null;

    {
      fiberStack[index] = null;
    }

    index--;
  }
}

var describeComponentFrame = function (name, source, ownerName) {
  return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
};

function describeFiber(fiber) {
  switch (fiber.tag) {
    case IndeterminateComponent:
    case FunctionalComponent:
    case ClassComponent:
    case HostComponent:
      var owner = fiber._debugOwner;
      var source = fiber._debugSource;
      var name = getComponentName(fiber);
      var ownerName = null;
      if (owner) {
        ownerName = getComponentName(owner);
      }
      return describeComponentFrame(name, source, ownerName);
    default:
      return '';
  }
}

// This function can only be called with a work-in-progress fiber and
// only during begin or complete phase. Do not call it under any other
// circumstances.
function getStackAddendumByWorkInProgressFiber(workInProgress) {
  var info = '';
  var node = workInProgress;
  do {
    info += describeFiber(node);
    // Otherwise this return pointer might point to the wrong tree:
    node = node['return'];
  } while (node);
  return info;
}

function getCurrentFiberOwnerName() {
  {
    var fiber = ReactDebugCurrentFiber.current;
    if (fiber === null) {
      return null;
    }
    var owner = fiber._debugOwner;
    if (owner !== null && typeof owner !== 'undefined') {
      return getComponentName(owner);
    }
  }
  return null;
}

function getCurrentFiberStackAddendum() {
  {
    var fiber = ReactDebugCurrentFiber.current;
    if (fiber === null) {
      return null;
    }
    // Safe because if current fiber exists, we are reconciling,
    // and it is guaranteed to be the work-in-progress version.
    return getStackAddendumByWorkInProgressFiber(fiber);
  }
  return null;
}

function resetCurrentFiber() {
  ReactDebugCurrentFrame.getCurrentStack = null;
  ReactDebugCurrentFiber.current = null;
  ReactDebugCurrentFiber.phase = null;
}

function setCurrentFiber(fiber) {
  ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackAddendum;
  ReactDebugCurrentFiber.current = fiber;
  ReactDebugCurrentFiber.phase = null;
}

function setCurrentPhase(phase) {
  ReactDebugCurrentFiber.phase = phase;
}

var ReactDebugCurrentFiber = {
  current: null,
  phase: null,
  resetCurrentFiber: resetCurrentFiber,
  setCurrentFiber: setCurrentFiber,
  setCurrentPhase: setCurrentPhase,
  getCurrentFiberOwnerName: getCurrentFiberOwnerName,
  getCurrentFiberStackAddendum: getCurrentFiberStackAddendum
};

// Prefix measurements so that it's possible to filter them.
// Longer prefixes are hard to read in DevTools.
var reactEmoji = '\u269B';
var warningEmoji = '\u26D4';
var supportsUserTiming = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';

// Keep track of current fiber so that we know the path to unwind on pause.
// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?
var currentFiber = null;
// If we're in the middle of user code, which fiber and method is it?
// Reusing `currentFiber` would be confusing for this because user code fiber
// can change during commit phase too, but we don't need to unwind it (since
// lifecycles in the commit phase don't resemble a tree).
var currentPhase = null;
var currentPhaseFiber = null;
// Did lifecycle hook schedule an update? This is often a performance problem,
// so we will keep track of it, and include it in the report.
// Track commits caused by cascading updates.
var isCommitting = false;
var hasScheduledUpdateInCurrentCommit = false;
var hasScheduledUpdateInCurrentPhase = false;
var commitCountInCurrentWorkLoop = 0;
var effectCountInCurrentCommit = 0;
var isWaitingForCallback = false;
// During commits, we only show a measurement once per method name
// to avoid stretch the commit phase with measurement overhead.
var labelsInCurrentCommit = new Set();

var formatMarkName = function (markName) {
  return reactEmoji + ' ' + markName;
};

var formatLabel = function (label, warning$$1) {
  var prefix = warning$$1 ? warningEmoji + ' ' : reactEmoji + ' ';
  var suffix = warning$$1 ? ' Warning: ' + warning$$1 : '';
  return '' + prefix + label + suffix;
};

var beginMark = function (markName) {
  performance.mark(formatMarkName(markName));
};

var clearMark = function (markName) {
  performance.clearMarks(formatMarkName(markName));
};

var endMark = function (label, markName, warning$$1) {
  var formattedMarkName = formatMarkName(markName);
  var formattedLabel = formatLabel(label, warning$$1);
  try {
    performance.measure(formattedLabel, formattedMarkName);
  } catch (err) {}
  // If previous mark was missing for some reason, this will throw.
  // This could only happen if React crashed in an unexpected place earlier.
  // Don't pile on with more errors.

  // Clear marks immediately to avoid growing buffer.
  performance.clearMarks(formattedMarkName);
  performance.clearMeasures(formattedLabel);
};

var getFiberMarkName = function (label, debugID) {
  return label + ' (#' + debugID + ')';
};

var getFiberLabel = function (componentName, isMounted, phase) {
  if (phase === null) {
    // These are composite component total time measurements.
    return componentName + ' [' + (isMounted ? 'update' : 'mount') + ']';
  } else {
    // Composite component methods.
    return componentName + '.' + phase;
  }
};

var beginFiberMark = function (fiber, phase) {
  var componentName = getComponentName(fiber) || 'Unknown';
  var debugID = fiber._debugID;
  var isMounted = fiber.alternate !== null;
  var label = getFiberLabel(componentName, isMounted, phase);

  if (isCommitting && labelsInCurrentCommit.has(label)) {
    // During the commit phase, we don't show duplicate labels because
    // there is a fixed overhead for every measurement, and we don't
    // want to stretch the commit phase beyond necessary.
    return false;
  }
  labelsInCurrentCommit.add(label);

  var markName = getFiberMarkName(label, debugID);
  beginMark(markName);
  return true;
};

var clearFiberMark = function (fiber, phase) {
  var componentName = getComponentName(fiber) || 'Unknown';
  var debugID = fiber._debugID;
  var isMounted = fiber.alternate !== null;
  var label = getFiberLabel(componentName, isMounted, phase);
  var markName = getFiberMarkName(label, debugID);
  clearMark(markName);
};

var endFiberMark = function (fiber, phase, warning$$1) {
  var componentName = getComponentName(fiber) || 'Unknown';
  var debugID = fiber._debugID;
  var isMounted = fiber.alternate !== null;
  var label = getFiberLabel(componentName, isMounted, phase);
  var markName = getFiberMarkName(label, debugID);
  endMark(label, markName, warning$$1);
};

var shouldIgnoreFiber = function (fiber) {
  // Host components should be skipped in the timeline.
  // We could check typeof fiber.type, but does this work with RN?
  switch (fiber.tag) {
    case HostRoot:
    case HostComponent:
    case HostText:
    case HostPortal:
    case ReturnComponent:
    case Fragment:
      return true;
    default:
      return false;
  }
};

var clearPendingPhaseMeasurement = function () {
  if (currentPhase !== null && currentPhaseFiber !== null) {
    clearFiberMark(currentPhaseFiber, currentPhase);
  }
  currentPhaseFiber = null;
  currentPhase = null;
  hasScheduledUpdateInCurrentPhase = false;
};

var pauseTimers = function () {
  // Stops all currently active measurements so that they can be resumed
  // if we continue in a later deferred loop from the same unit of work.
  var fiber = currentFiber;
  while (fiber) {
    if (fiber._debugIsCurrentlyTiming) {
      endFiberMark(fiber, null, null);
    }
    fiber = fiber['return'];
  }
};

var resumeTimersRecursively = function (fiber) {
  if (fiber['return'] !== null) {
    resumeTimersRecursively(fiber['return']);
  }
  if (fiber._debugIsCurrentlyTiming) {
    beginFiberMark(fiber, null);
  }
};

var resumeTimers = function () {
  // Resumes all measurements that were active during the last deferred loop.
  if (currentFiber !== null) {
    resumeTimersRecursively(currentFiber);
  }
};

function recordEffect() {
  if (enableUserTimingAPI) {
    effectCountInCurrentCommit++;
  }
}

function recordScheduleUpdate() {
  if (enableUserTimingAPI) {
    if (isCommitting) {
      hasScheduledUpdateInCurrentCommit = true;
    }
    if (currentPhase !== null && currentPhase !== 'componentWillMount' && currentPhase !== 'componentWillReceiveProps') {
      hasScheduledUpdateInCurrentPhase = true;
    }
  }
}

function startRequestCallbackTimer() {
  if (enableUserTimingAPI) {
    if (supportsUserTiming && !isWaitingForCallback) {
      isWaitingForCallback = true;
      beginMark('(Waiting for async callback...)');
    }
  }
}

function stopRequestCallbackTimer(didExpire) {
  if (enableUserTimingAPI) {
    if (supportsUserTiming) {
      isWaitingForCallback = false;
      var warning$$1 = didExpire ? 'React was blocked by main thread' : null;
      endMark('(Waiting for async callback...)', '(Waiting for async callback...)', warning$$1);
    }
  }
}

function startWorkTimer(fiber) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
      return;
    }
    // If we pause, this is the fiber to unwind from.
    currentFiber = fiber;
    if (!beginFiberMark(fiber, null)) {
      return;
    }
    fiber._debugIsCurrentlyTiming = true;
  }
}

function cancelWorkTimer(fiber) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
      return;
    }
    // Remember we shouldn't complete measurement for this fiber.
    // Otherwise flamechart will be deep even for small updates.
    fiber._debugIsCurrentlyTiming = false;
    clearFiberMark(fiber, null);
  }
}

function stopWorkTimer(fiber) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
      return;
    }
    // If we pause, its parent is the fiber to unwind from.
    currentFiber = fiber['return'];
    if (!fiber._debugIsCurrentlyTiming) {
      return;
    }
    fiber._debugIsCurrentlyTiming = false;
    endFiberMark(fiber, null, null);
  }
}

function stopFailedWorkTimer(fiber) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
      return;
    }
    // If we pause, its parent is the fiber to unwind from.
    currentFiber = fiber['return'];
    if (!fiber._debugIsCurrentlyTiming) {
      return;
    }
    fiber._debugIsCurrentlyTiming = false;
    var warning$$1 = 'An error was thrown inside this error boundary';
    endFiberMark(fiber, null, warning$$1);
  }
}

function startPhaseTimer(fiber, phase) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    clearPendingPhaseMeasurement();
    if (!beginFiberMark(fiber, phase)) {
      return;
    }
    currentPhaseFiber = fiber;
    currentPhase = phase;
  }
}

function stopPhaseTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    if (currentPhase !== null && currentPhaseFiber !== null) {
      var warning$$1 = hasScheduledUpdateInCurrentPhase ? 'Scheduled a cascading update' : null;
      endFiberMark(currentPhaseFiber, currentPhase, warning$$1);
    }
    currentPhase = null;
    currentPhaseFiber = null;
  }
}

function startWorkLoopTimer(nextUnitOfWork) {
  if (enableUserTimingAPI) {
    currentFiber = nextUnitOfWork;
    if (!supportsUserTiming) {
      return;
    }
    commitCountInCurrentWorkLoop = 0;
    // This is top level call.
    // Any other measurements are performed within.
    beginMark('(React Tree Reconciliation)');
    // Resume any measurements that were in progress during the last loop.
    resumeTimers();
  }
}

function stopWorkLoopTimer(interruptedBy) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    var warning$$1 = null;
    if (interruptedBy !== null) {
      if (interruptedBy.tag === HostRoot) {
        warning$$1 = 'A top-level update interrupted the previous render';
      } else {
        var componentName = getComponentName(interruptedBy) || 'Unknown';
        warning$$1 = 'An update to ' + componentName + ' interrupted the previous render';
      }
    } else if (commitCountInCurrentWorkLoop > 1) {
      warning$$1 = 'There were cascading updates';
    }
    commitCountInCurrentWorkLoop = 0;
    // Pause any measurements until the next loop.
    pauseTimers();
    endMark('(React Tree Reconciliation)', '(React Tree Reconciliation)', warning$$1);
  }
}

function startCommitTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    isCommitting = true;
    hasScheduledUpdateInCurrentCommit = false;
    labelsInCurrentCommit.clear();
    beginMark('(Committing Changes)');
  }
}

function stopCommitTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }

    var warning$$1 = null;
    if (hasScheduledUpdateInCurrentCommit) {
      warning$$1 = 'Lifecycle hook scheduled a cascading update';
    } else if (commitCountInCurrentWorkLoop > 0) {
      warning$$1 = 'Caused by a cascading update in earlier commit';
    }
    hasScheduledUpdateInCurrentCommit = false;
    commitCountInCurrentWorkLoop++;
    isCommitting = false;
    labelsInCurrentCommit.clear();

    endMark('(Committing Changes)', '(Committing Changes)', warning$$1);
  }
}

function startCommitHostEffectsTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    effectCountInCurrentCommit = 0;
    beginMark('(Committing Host Effects)');
  }
}

function stopCommitHostEffectsTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    var count = effectCountInCurrentCommit;
    effectCountInCurrentCommit = 0;
    endMark('(Committing Host Effects: ' + count + ' Total)', '(Committing Host Effects)', null);
  }
}

function startCommitLifeCyclesTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    effectCountInCurrentCommit = 0;
    beginMark('(Calling Lifecycle Methods)');
  }
}

function stopCommitLifeCyclesTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    var count = effectCountInCurrentCommit;
    effectCountInCurrentCommit = 0;
    endMark('(Calling Lifecycle Methods: ' + count + ' Total)', '(Calling Lifecycle Methods)', null);
  }
}

{
  var warnedAboutMissingGetChildContext = {};
}

// A cursor to the current merged context object on the stack.
var contextStackCursor = createCursor(emptyObject);
// A cursor to a boolean indicating whether the context has changed.
var didPerformWorkStackCursor = createCursor(false);
// Keep track of the previous context object that was on the stack.
// We use this to get access to the parent context after we have already
// pushed the next context provider, and now need to merge their contexts.
var previousContext = emptyObject;

function getUnmaskedContext(workInProgress) {
  var hasOwnContext = isContextProvider(workInProgress);
  if (hasOwnContext) {
    // If the fiber is a context provider itself, when we read its context
    // we have already pushed its own child context on the stack. A context
    // provider should not "see" its own child context. Therefore we read the
    // previous (parent) context instead for a context provider.
    return previousContext;
  }
  return contextStackCursor.current;
}

function cacheContext(workInProgress, unmaskedContext, maskedContext) {
  var instance = workInProgress.stateNode;
  instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
  instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
}

function getMaskedContext(workInProgress, unmaskedContext) {
  var type = workInProgress.type;
  var contextTypes = type.contextTypes;
  if (!contextTypes) {
    return emptyObject;
  }

  // Avoid recreating masked context unless unmasked context has changed.
  // Failing to do this will result in unnecessary calls to componentWillReceiveProps.
  // This may trigger infinite loops if componentWillReceiveProps calls setState.
  var instance = workInProgress.stateNode;
  if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
    return instance.__reactInternalMemoizedMaskedChildContext;
  }

  var context = {};
  for (var key in contextTypes) {
    context[key] = unmaskedContext[key];
  }

  {
    var name = getComponentName(workInProgress) || 'Unknown';
    checkPropTypes(contextTypes, context, 'context', name, ReactDebugCurrentFiber.getCurrentFiberStackAddendum);
  }

  // Cache unmasked context so we can avoid recreating masked context unless necessary.
  // Context is created before the class component is instantiated so check for instance.
  if (instance) {
    cacheContext(workInProgress, unmaskedContext, context);
  }

  return context;
}

function hasContextChanged() {
  return didPerformWorkStackCursor.current;
}

function isContextConsumer(fiber) {
  return fiber.tag === ClassComponent && fiber.type.contextTypes != null;
}

function isContextProvider(fiber) {
  return fiber.tag === ClassComponent && fiber.type.childContextTypes != null;
}

function popContextProvider(fiber) {
  if (!isContextProvider(fiber)) {
    return;
  }

  pop(didPerformWorkStackCursor, fiber);
  pop(contextStackCursor, fiber);
}

function popTopLevelContextObject(fiber) {
  pop(didPerformWorkStackCursor, fiber);
  pop(contextStackCursor, fiber);
}

function pushTopLevelContextObject(fiber, context, didChange) {
  !(contextStackCursor.cursor == null) ? invariant(false, 'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.') : void 0;

  push(contextStackCursor, context, fiber);
  push(didPerformWorkStackCursor, didChange, fiber);
}

function processChildContext(fiber, parentContext) {
  var instance = fiber.stateNode;
  var childContextTypes = fiber.type.childContextTypes;

  // TODO (bvaughn) Replace this behavior with an invariant() in the future.
  // It has only been added in Fiber to match the (unintentional) behavior in Stack.
  if (typeof instance.getChildContext !== 'function') {
    {
      var componentName = getComponentName(fiber) || 'Unknown';

      if (!warnedAboutMissingGetChildContext[componentName]) {
        warnedAboutMissingGetChildContext[componentName] = true;
        warning(false, '%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);
      }
    }
    return parentContext;
  }

  var childContext = void 0;
  {
    ReactDebugCurrentFiber.setCurrentPhase('getChildContext');
  }
  startPhaseTimer(fiber, 'getChildContext');
  childContext = instance.getChildContext();
  stopPhaseTimer();
  {
    ReactDebugCurrentFiber.setCurrentPhase(null);
  }
  for (var contextKey in childContext) {
    !(contextKey in childContextTypes) ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', getComponentName(fiber) || 'Unknown', contextKey) : void 0;
  }
  {
    var name = getComponentName(fiber) || 'Unknown';
    checkPropTypes(childContextTypes, childContext, 'child context', name,
    // In practice, there is one case in which we won't get a stack. It's when
    // somebody calls unstable_renderSubtreeIntoContainer() and we process
    // context from the parent component instance. The stack will be missing
    // because it's outside of the reconciliation, and so the pointer has not
    // been set. This is rare and doesn't matter. We'll also remove that API.
    ReactDebugCurrentFiber.getCurrentFiberStackAddendum);
  }

  return _assign({}, parentContext, childContext);
}

function pushContextProvider(workInProgress) {
  if (!isContextProvider(workInProgress)) {
    return false;
  }

  var instance = workInProgress.stateNode;
  // We push the context as early as possible to ensure stack integrity.
  // If the instance does not exist yet, we will push null at first,
  // and replace it on the stack later when invalidating the context.
  var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyObject;

  // Remember the parent context so we can merge with it later.
  // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.
  previousContext = contextStackCursor.current;
  push(contextStackCursor, memoizedMergedChildContext, workInProgress);
  push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);

  return true;
}

function invalidateContextProvider(workInProgress, didChange) {
  var instance = workInProgress.stateNode;
  !instance ? invariant(false, 'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.') : void 0;

  if (didChange) {
    // Merge parent and own context.
    // Skip this if we're not updating due to sCU.
    // This avoids unnecessarily recomputing memoized values.
    var mergedContext = processChildContext(workInProgress, previousContext);
    instance.__reactInternalMemoizedMergedChildContext = mergedContext;

    // Replace the old (or empty) context with the new one.
    // It is important to unwind the context in the reverse order.
    pop(didPerformWorkStackCursor, workInProgress);
    pop(contextStackCursor, workInProgress);
    // Now push the new context and mark that it has changed.
    push(contextStackCursor, mergedContext, workInProgress);
    push(didPerformWorkStackCursor, didChange, workInProgress);
  } else {
    pop(didPerformWorkStackCursor, workInProgress);
    push(didPerformWorkStackCursor, didChange, workInProgress);
  }
}

function resetContext() {
  previousContext = emptyObject;
  contextStackCursor.current = emptyObject;
  didPerformWorkStackCursor.current = false;
}

function findCurrentUnmaskedContext(fiber) {
  // Currently this is only used with renderSubtreeIntoContainer; not sure if it
  // makes sense elsewhere
  !(isFiberMounted(fiber) && fiber.tag === ClassComponent) ? invariant(false, 'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.') : void 0;

  var node = fiber;
  while (node.tag !== HostRoot) {
    if (isContextProvider(node)) {
      return node.stateNode.__reactInternalMemoizedMergedChildContext;
    }
    var parent = node['return'];
    !parent ? invariant(false, 'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    node = parent;
  }
  return node.stateNode.context;
}

var NoWork = 0; // TODO: Use an opaque type once ESLint et al support the syntax

var Sync = 1;
var Never = 2147483647; // Max int32: Math.pow(2, 31) - 1

var UNIT_SIZE = 10;
var MAGIC_NUMBER_OFFSET = 2;

// 1 unit of expiration time represents 10ms.
function msToExpirationTime(ms) {
  // Always add an offset so that we don't clash with the magic number for NoWork.
  return (ms / UNIT_SIZE | 0) + MAGIC_NUMBER_OFFSET;
}

function expirationTimeToMs(expirationTime) {
  return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE;
}

function ceiling(num, precision) {
  return ((num / precision | 0) + 1) * precision;
}

function computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {
  return ceiling(currentTime + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);
}

var NoContext = 0;
var AsyncUpdates = 1;

{
  var hasBadMapPolyfill = false;
  try {
    var nonExtensibleObject = Object.preventExtensions({});
    /* eslint-disable no-new */
    
    /* eslint-enable no-new */
  } catch (e) {
    // TODO: Consider warning about bad polyfills
    hasBadMapPolyfill = true;
  }
}

// A Fiber is work on a Component that needs to be done or was done. There can
// be more than one per component.


{
  var debugCounter = 1;
}

function FiberNode(tag, key, internalContextTag) {
  // Instance
  this.tag = tag;
  this.key = key;
  this.type = null;
  this.stateNode = null;

  // Fiber
  this['return'] = null;
  this.child = null;
  this.sibling = null;
  this.index = 0;

  this.ref = null;

  this.pendingProps = null;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;

  this.internalContextTag = internalContextTag;

  // Effects
  this.effectTag = NoEffect;
  this.nextEffect = null;

  this.firstEffect = null;
  this.lastEffect = null;

  this.expirationTime = NoWork;

  this.alternate = null;

  {
    this._debugID = debugCounter++;
    this._debugSource = null;
    this._debugOwner = null;
    this._debugIsCurrentlyTiming = false;
    if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {
      Object.preventExtensions(this);
    }
  }
}

// This is a constructor function, rather than a POJO constructor, still
// please ensure we do the following:
// 1) Nobody should add any instance methods on this. Instance methods can be
//    more difficult to predict when they get optimized and they are almost
//    never inlined properly in static compilers.
// 2) Nobody should rely on `instanceof Fiber` for type testing. We should
//    always know when it is a fiber.
// 3) We might want to experiment with using numeric keys since they are easier
//    to optimize in a non-JIT environment.
// 4) We can easily go from a constructor to a createFiber object literal if that
//    is faster.
// 5) It should be easy to port this to a C struct and keep a C implementation
//    compatible.
var createFiber = function (tag, key, internalContextTag) {
  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors
  return new FiberNode(tag, key, internalContextTag);
};

function shouldConstruct(Component) {
  return !!(Component.prototype && Component.prototype.isReactComponent);
}

// This is used to create an alternate fiber to do work on.
function createWorkInProgress(current, pendingProps, expirationTime) {
  var workInProgress = current.alternate;
  if (workInProgress === null) {
    // We use a double buffering pooling technique because we know that we'll
    // only ever need at most two versions of a tree. We pool the "other" unused
    // node that we're free to reuse. This is lazily created to avoid allocating
    // extra objects for things that are never updated. It also allow us to
    // reclaim the extra memory if needed.
    workInProgress = createFiber(current.tag, current.key, current.internalContextTag);
    workInProgress.type = current.type;
    workInProgress.stateNode = current.stateNode;

    {
      // DEV-only fields
      workInProgress._debugID = current._debugID;
      workInProgress._debugSource = current._debugSource;
      workInProgress._debugOwner = current._debugOwner;
    }

    workInProgress.alternate = current;
    current.alternate = workInProgress;
  } else {
    // We already have an alternate.
    // Reset the effect tag.
    workInProgress.effectTag = NoEffect;

    // The effect list is no longer valid.
    workInProgress.nextEffect = null;
    workInProgress.firstEffect = null;
    workInProgress.lastEffect = null;
  }

  workInProgress.expirationTime = expirationTime;
  workInProgress.pendingProps = pendingProps;

  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;

  // These will be overridden during the parent's reconciliation
  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
  workInProgress.ref = current.ref;

  return workInProgress;
}

function createHostRootFiber() {
  var fiber = createFiber(HostRoot, null, NoContext);
  return fiber;
}

function createFiberFromElement(element, internalContextTag, expirationTime) {
  var owner = null;
  {
    owner = element._owner;
  }

  var fiber = void 0;
  var type = element.type,
      key = element.key;

  if (typeof type === 'function') {
    fiber = shouldConstruct(type) ? createFiber(ClassComponent, key, internalContextTag) : createFiber(IndeterminateComponent, key, internalContextTag);
    fiber.type = type;
    fiber.pendingProps = element.props;
  } else if (typeof type === 'string') {
    fiber = createFiber(HostComponent, key, internalContextTag);
    fiber.type = type;
    fiber.pendingProps = element.props;
  } else if (typeof type === 'object' && type !== null && typeof type.tag === 'number') {
    // Currently assumed to be a continuation and therefore is a fiber already.
    // TODO: The yield system is currently broken for updates in some cases.
    // The reified yield stores a fiber, but we don't know which fiber that is;
    // the current or a workInProgress? When the continuation gets rendered here
    // we don't know if we can reuse that fiber or if we need to clone it.
    // There is probably a clever way to restructure this.
    fiber = type;
    fiber.pendingProps = element.props;
  } else {
    var info = '';
    {
      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
      }
      var ownerName = owner ? getComponentName(owner) : null;
      if (ownerName) {
        info += '\n\nCheck the render method of `' + ownerName + '`.';
      }
    }
    invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info);
  }

  {
    fiber._debugSource = element._source;
    fiber._debugOwner = element._owner;
  }

  fiber.expirationTime = expirationTime;

  return fiber;
}

function createFiberFromFragment(elements, internalContextTag, expirationTime, key) {
  var fiber = createFiber(Fragment, key, internalContextTag);
  fiber.pendingProps = elements;
  fiber.expirationTime = expirationTime;
  return fiber;
}

function createFiberFromText(content, internalContextTag, expirationTime) {
  var fiber = createFiber(HostText, null, internalContextTag);
  fiber.pendingProps = content;
  fiber.expirationTime = expirationTime;
  return fiber;
}

function createFiberFromHostInstanceForDeletion() {
  var fiber = createFiber(HostComponent, null, NoContext);
  fiber.type = 'DELETED';
  return fiber;
}

function createFiberFromCall(call, internalContextTag, expirationTime) {
  var fiber = createFiber(CallComponent, call.key, internalContextTag);
  fiber.type = call.handler;
  fiber.pendingProps = call;
  fiber.expirationTime = expirationTime;
  return fiber;
}

function createFiberFromReturn(returnNode, internalContextTag, expirationTime) {
  var fiber = createFiber(ReturnComponent, null, internalContextTag);
  fiber.expirationTime = expirationTime;
  return fiber;
}

function createFiberFromPortal(portal, internalContextTag, expirationTime) {
  var fiber = createFiber(HostPortal, portal.key, internalContextTag);
  fiber.pendingProps = portal.children || [];
  fiber.expirationTime = expirationTime;
  fiber.stateNode = {
    containerInfo: portal.containerInfo,
    pendingChildren: null, // Used by persistent updates
    implementation: portal.implementation
  };
  return fiber;
}

function createFiberRoot(containerInfo, hydrate) {
  // Cyclic construction. This cheats the type system right now because
  // stateNode is any.
  var uninitializedFiber = createHostRootFiber();
  var root = {
    current: uninitializedFiber,
    containerInfo: containerInfo,
    pendingChildren: null,
    remainingExpirationTime: NoWork,
    isReadyForCommit: false,
    finishedWork: null,
    context: null,
    pendingContext: null,
    hydrate: hydrate,
    nextScheduledRoot: null
  };
  uninitializedFiber.stateNode = root;
  return root;
}

var onCommitFiberRoot = null;
var onCommitFiberUnmount = null;
var hasLoggedError = false;

function catchErrors(fn) {
  return function (arg) {
    try {
      return fn(arg);
    } catch (err) {
      if (true && !hasLoggedError) {
        hasLoggedError = true;
        warning(false, 'React DevTools encountered an error: %s', err);
      }
    }
  };
}

function injectInternals(internals) {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
    // No DevTools
    return false;
  }
  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (hook.isDisabled) {
    // This isn't a real property on the hook, but it can be set to opt out
    // of DevTools integration and associated warnings and logs.
    // https://github.com/facebook/react/issues/3877
    return true;
  }
  if (!hook.supportsFiber) {
    {
      warning(false, 'The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://fb.me/react-devtools');
    }
    // DevTools exists, even though it doesn't support Fiber.
    return true;
  }
  try {
    var rendererID = hook.inject(internals);
    // We have successfully injected, so now it is safe to set up hooks.
    onCommitFiberRoot = catchErrors(function (root) {
      return hook.onCommitFiberRoot(rendererID, root);
    });
    onCommitFiberUnmount = catchErrors(function (fiber) {
      return hook.onCommitFiberUnmount(rendererID, fiber);
    });
  } catch (err) {
    // Catch all errors because it is unsafe to throw during initialization.
    {
      warning(false, 'React DevTools encountered an error: %s.', err);
    }
  }
  // DevTools exists
  return true;
}

function onCommitRoot(root) {
  if (typeof onCommitFiberRoot === 'function') {
    onCommitFiberRoot(root);
  }
}

function onCommitUnmount(fiber) {
  if (typeof onCommitFiberUnmount === 'function') {
    onCommitFiberUnmount(fiber);
  }
}

{
  var didWarnUpdateInsideUpdate = false;
}

// Callbacks are not validated until invocation


// Singly linked-list of updates. When an update is scheduled, it is added to
// the queue of the current fiber and the work-in-progress fiber. The two queues
// are separate but they share a persistent structure.
//
// During reconciliation, updates are removed from the work-in-progress fiber,
// but they remain on the current fiber. That ensures that if a work-in-progress
// is aborted, the aborted updates are recovered by cloning from current.
//
// The work-in-progress queue is always a subset of the current queue.
//
// When the tree is committed, the work-in-progress becomes the current.


function createUpdateQueue(baseState) {
  var queue = {
    baseState: baseState,
    expirationTime: NoWork,
    first: null,
    last: null,
    callbackList: null,
    hasForceUpdate: false,
    isInitialized: false
  };
  {
    queue.isProcessing = false;
  }
  return queue;
}

function insertUpdateIntoQueue(queue, update) {
  // Append the update to the end of the list.
  if (queue.last === null) {
    // Queue is empty
    queue.first = queue.last = update;
  } else {
    queue.last.next = update;
    queue.last = update;
  }
  if (queue.expirationTime === NoWork || queue.expirationTime > update.expirationTime) {
    queue.expirationTime = update.expirationTime;
  }
}

function insertUpdateIntoFiber(fiber, update) {
  // We'll have at least one and at most two distinct update queues.
  var alternateFiber = fiber.alternate;
  var queue1 = fiber.updateQueue;
  if (queue1 === null) {
    // TODO: We don't know what the base state will be until we begin work.
    // It depends on which fiber is the next current. Initialize with an empty
    // base state, then set to the memoizedState when rendering. Not super
    // happy with this approach.
    queue1 = fiber.updateQueue = createUpdateQueue(null);
  }

  var queue2 = void 0;
  if (alternateFiber !== null) {
    queue2 = alternateFiber.updateQueue;
    if (queue2 === null) {
      queue2 = alternateFiber.updateQueue = createUpdateQueue(null);
    }
  } else {
    queue2 = null;
  }
  queue2 = queue2 !== queue1 ? queue2 : null;

  // Warn if an update is scheduled from inside an updater function.
  {
    if ((queue1.isProcessing || queue2 !== null && queue2.isProcessing) && !didWarnUpdateInsideUpdate) {
      warning(false, 'An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');
      didWarnUpdateInsideUpdate = true;
    }
  }

  // If there's only one queue, add the update to that queue and exit.
  if (queue2 === null) {
    insertUpdateIntoQueue(queue1, update);
    return;
  }

  // If either queue is empty, we need to add to both queues.
  if (queue1.last === null || queue2.last === null) {
    insertUpdateIntoQueue(queue1, update);
    insertUpdateIntoQueue(queue2, update);
    return;
  }

  // If both lists are not empty, the last update is the same for both lists
  // because of structural sharing. So, we should only append to one of
  // the lists.
  insertUpdateIntoQueue(queue1, update);
  // But we still need to update the `last` pointer of queue2.
  queue2.last = update;
}

function getUpdateExpirationTime(fiber) {
  if (fiber.tag !== ClassComponent && fiber.tag !== HostRoot) {
    return NoWork;
  }
  var updateQueue = fiber.updateQueue;
  if (updateQueue === null) {
    return NoWork;
  }
  return updateQueue.expirationTime;
}

function getStateFromUpdate(update, instance, prevState, props) {
  var partialState = update.partialState;
  if (typeof partialState === 'function') {
    var updateFn = partialState;

    // Invoke setState callback an extra time to help detect side-effects.
    if (debugRenderPhaseSideEffects) {
      updateFn.call(instance, prevState, props);
    }

    return updateFn.call(instance, prevState, props);
  } else {
    return partialState;
  }
}

function processUpdateQueue(current, workInProgress, queue, instance, props, renderExpirationTime) {
  if (current !== null && current.updateQueue === queue) {
    // We need to create a work-in-progress queue, by cloning the current queue.
    var currentQueue = queue;
    queue = workInProgress.updateQueue = {
      baseState: currentQueue.baseState,
      expirationTime: currentQueue.expirationTime,
      first: currentQueue.first,
      last: currentQueue.last,
      isInitialized: currentQueue.isInitialized,
      // These fields are no longer valid because they were already committed.
      // Reset them.
      callbackList: null,
      hasForceUpdate: false
    };
  }

  {
    // Set this flag so we can warn if setState is called inside the update
    // function of another setState.
    queue.isProcessing = true;
  }

  // Reset the remaining expiration time. If we skip over any updates, we'll
  // increase this accordingly.
  queue.expirationTime = NoWork;

  // TODO: We don't know what the base state will be until we begin work.
  // It depends on which fiber is the next current. Initialize with an empty
  // base state, then set to the memoizedState when rendering. Not super
  // happy with this approach.
  var state = void 0;
  if (queue.isInitialized) {
    state = queue.baseState;
  } else {
    state = queue.baseState = workInProgress.memoizedState;
    queue.isInitialized = true;
  }
  var dontMutatePrevState = true;
  var update = queue.first;
  var didSkip = false;
  while (update !== null) {
    var updateExpirationTime = update.expirationTime;
    if (updateExpirationTime > renderExpirationTime) {
      // This update does not have sufficient priority. Skip it.
      var remainingExpirationTime = queue.expirationTime;
      if (remainingExpirationTime === NoWork || remainingExpirationTime > updateExpirationTime) {
        // Update the remaining expiration time.
        queue.expirationTime = updateExpirationTime;
      }
      if (!didSkip) {
        didSkip = true;
        queue.baseState = state;
      }
      // Continue to the next update.
      update = update.next;
      continue;
    }

    // This update does have sufficient priority.

    // If no previous updates were skipped, drop this update from the queue by
    // advancing the head of the list.
    if (!didSkip) {
      queue.first = update.next;
      if (queue.first === null) {
        queue.last = null;
      }
    }

    // Process the update
    var _partialState = void 0;
    if (update.isReplace) {
      state = getStateFromUpdate(update, instance, state, props);
      dontMutatePrevState = true;
    } else {
      _partialState = getStateFromUpdate(update, instance, state, props);
      if (_partialState) {
        if (dontMutatePrevState) {
          // $FlowFixMe: Idk how to type this properly.
          state = _assign({}, state, _partialState);
        } else {
          state = _assign(state, _partialState);
        }
        dontMutatePrevState = false;
      }
    }
    if (update.isForced) {
      queue.hasForceUpdate = true;
    }
    if (update.callback !== null) {
      // Append to list of callbacks.
      var _callbackList = queue.callbackList;
      if (_callbackList === null) {
        _callbackList = queue.callbackList = [];
      }
      _callbackList.push(update);
    }
    update = update.next;
  }

  if (queue.callbackList !== null) {
    workInProgress.effectTag |= Callback;
  } else if (queue.first === null && !queue.hasForceUpdate) {
    // The queue is empty. We can reset it.
    workInProgress.updateQueue = null;
  }

  if (!didSkip) {
    didSkip = true;
    queue.baseState = state;
  }

  {
    // No longer processing.
    queue.isProcessing = false;
  }

  return state;
}

function commitCallbacks(queue, context) {
  var callbackList = queue.callbackList;
  if (callbackList === null) {
    return;
  }
  // Set the list to null to make sure they don't get called more than once.
  queue.callbackList = null;
  for (var i = 0; i < callbackList.length; i++) {
    var update = callbackList[i];
    var _callback = update.callback;
    // This update might be processed again. Clear the callback so it's only
    // called once.
    update.callback = null;
    !(typeof _callback === 'function') ? invariant(false, 'Invalid argument passed as callback. Expected a function. Instead received: %s', _callback) : void 0;
    _callback.call(context);
  }
}

var fakeInternalInstance = {};
var isArray = Array.isArray;

{
  var didWarnAboutStateAssignmentForComponent = {};

  var warnOnInvalidCallback = function (callback, callerName) {
    warning(callback === null || typeof callback === 'function', '%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);
  };

  // This is so gross but it's at least non-critical and can be removed if
  // it causes problems. This is meant to give a nicer error message for
  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
  // ...)) which otherwise throws a "_processChildContext is not a function"
  // exception.
  Object.defineProperty(fakeInternalInstance, '_processChildContext', {
    enumerable: false,
    value: function () {
      invariant(false, '_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn\'t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).');
    }
  });
  Object.freeze(fakeInternalInstance);
}

var ReactFiberClassComponent = function (scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState) {
  // Class component state updater
  var updater = {
    isMounted: isMounted,
    enqueueSetState: function (instance, partialState, callback) {
      var fiber = get(instance);
      callback = callback === undefined ? null : callback;
      {
        warnOnInvalidCallback(callback, 'setState');
      }
      var expirationTime = computeExpirationForFiber(fiber);
      var update = {
        expirationTime: expirationTime,
        partialState: partialState,
        callback: callback,
        isReplace: false,
        isForced: false,
        nextCallback: null,
        next: null
      };
      insertUpdateIntoFiber(fiber, update);
      scheduleWork(fiber, expirationTime);
    },
    enqueueReplaceState: function (instance, state, callback) {
      var fiber = get(instance);
      callback = callback === undefined ? null : callback;
      {
        warnOnInvalidCallback(callback, 'replaceState');
      }
      var expirationTime = computeExpirationForFiber(fiber);
      var update = {
        expirationTime: expirationTime,
        partialState: state,
        callback: callback,
        isReplace: true,
        isForced: false,
        nextCallback: null,
        next: null
      };
      insertUpdateIntoFiber(fiber, update);
      scheduleWork(fiber, expirationTime);
    },
    enqueueForceUpdate: function (instance, callback) {
      var fiber = get(instance);
      callback = callback === undefined ? null : callback;
      {
        warnOnInvalidCallback(callback, 'forceUpdate');
      }
      var expirationTime = computeExpirationForFiber(fiber);
      var update = {
        expirationTime: expirationTime,
        partialState: null,
        callback: callback,
        isReplace: false,
        isForced: true,
        nextCallback: null,
        next: null
      };
      insertUpdateIntoFiber(fiber, update);
      scheduleWork(fiber, expirationTime);
    }
  };

  function checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext) {
    if (oldProps === null || workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate) {
      // If the workInProgress already has an Update effect, return true
      return true;
    }

    var instance = workInProgress.stateNode;
    var type = workInProgress.type;
    if (typeof instance.shouldComponentUpdate === 'function') {
      startPhaseTimer(workInProgress, 'shouldComponentUpdate');
      var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, newContext);
      stopPhaseTimer();

      // Simulate an async bailout/interruption by invoking lifecycle twice.
      if (debugRenderPhaseSideEffects) {
        instance.shouldComponentUpdate(newProps, newState, newContext);
      }

      {
        warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentName(workInProgress) || 'Unknown');
      }

      return shouldUpdate;
    }

    if (type.prototype && type.prototype.isPureReactComponent) {
      return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
    }

    return true;
  }

  function checkClassInstance(workInProgress) {
    var instance = workInProgress.stateNode;
    var type = workInProgress.type;
    {
      var name = getComponentName(workInProgress);
      var renderPresent = instance.render;

      if (!renderPresent) {
        if (type.prototype && typeof type.prototype.render === 'function') {
          warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);
        } else {
          warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);
        }
      }

      var noGetInitialStateOnES6 = !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state;
      warning(noGetInitialStateOnES6, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);
      var noGetDefaultPropsOnES6 = !instance.getDefaultProps || instance.getDefaultProps.isReactClassApproved;
      warning(noGetDefaultPropsOnES6, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);
      var noInstancePropTypes = !instance.propTypes;
      warning(noInstancePropTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);
      var noInstanceContextTypes = !instance.contextTypes;
      warning(noInstanceContextTypes, 'contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name);
      var noComponentShouldUpdate = typeof instance.componentShouldUpdate !== 'function';
      warning(noComponentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);
      if (type.prototype && type.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {
        warning(false, '%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentName(workInProgress) || 'A pure component');
      }
      var noComponentDidUnmount = typeof instance.componentDidUnmount !== 'function';
      warning(noComponentDidUnmount, '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);
      var noComponentDidReceiveProps = typeof instance.componentDidReceiveProps !== 'function';
      warning(noComponentDidReceiveProps, '%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name);
      var noComponentWillRecieveProps = typeof instance.componentWillRecieveProps !== 'function';
      warning(noComponentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);
      var hasMutatedProps = instance.props !== workInProgress.pendingProps;
      warning(instance.props === undefined || !hasMutatedProps, '%s(...): When calling super() in `%s`, make sure to pass ' + "up the same props that your component's constructor was passed.", name, name);
      var noInstanceDefaultProps = !instance.defaultProps;
      warning(noInstanceDefaultProps, 'Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);
    }

    var state = instance.state;
    if (state && (typeof state !== 'object' || isArray(state))) {
      warning(false, '%s.state: must be set to an object or null', getComponentName(workInProgress));
    }
    if (typeof instance.getChildContext === 'function') {
      warning(typeof workInProgress.type.childContextTypes === 'object', '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', getComponentName(workInProgress));
    }
  }

  function resetInputPointers(workInProgress, instance) {
    instance.props = workInProgress.memoizedProps;
    instance.state = workInProgress.memoizedState;
  }

  function adoptClassInstance(workInProgress, instance) {
    instance.updater = updater;
    workInProgress.stateNode = instance;
    // The instance needs access to the fiber so that it can schedule updates
    set(instance, workInProgress);
    {
      instance._reactInternalInstance = fakeInternalInstance;
    }
  }

  function constructClassInstance(workInProgress, props) {
    var ctor = workInProgress.type;
    var unmaskedContext = getUnmaskedContext(workInProgress);
    var needsContext = isContextConsumer(workInProgress);
    var context = needsContext ? getMaskedContext(workInProgress, unmaskedContext) : emptyObject;
    var instance = new ctor(props, context);
    adoptClassInstance(workInProgress, instance);

    // Cache unmasked context so we can avoid recreating masked context unless necessary.
    // ReactFiberContext usually updates this cache but can't for newly-created instances.
    if (needsContext) {
      cacheContext(workInProgress, unmaskedContext, context);
    }

    return instance;
  }

  function callComponentWillMount(workInProgress, instance) {
    startPhaseTimer(workInProgress, 'componentWillMount');
    var oldState = instance.state;
    instance.componentWillMount();
    stopPhaseTimer();

    // Simulate an async bailout/interruption by invoking lifecycle twice.
    if (debugRenderPhaseSideEffects) {
      instance.componentWillMount();
    }

    if (oldState !== instance.state) {
      {
        warning(false, '%s.componentWillMount(): Assigning directly to this.state is ' + "deprecated (except inside a component's " + 'constructor). Use setState instead.', getComponentName(workInProgress));
      }
      updater.enqueueReplaceState(instance, instance.state, null);
    }
  }

  function callComponentWillReceiveProps(workInProgress, instance, newProps, newContext) {
    startPhaseTimer(workInProgress, 'componentWillReceiveProps');
    var oldState = instance.state;
    instance.componentWillReceiveProps(newProps, newContext);
    stopPhaseTimer();

    // Simulate an async bailout/interruption by invoking lifecycle twice.
    if (debugRenderPhaseSideEffects) {
      instance.componentWillReceiveProps(newProps, newContext);
    }

    if (instance.state !== oldState) {
      {
        var componentName = getComponentName(workInProgress) || 'Component';
        if (!didWarnAboutStateAssignmentForComponent[componentName]) {
          warning(false, '%s.componentWillReceiveProps(): Assigning directly to ' + "this.state is deprecated (except inside a component's " + 'constructor). Use setState instead.', componentName);
          didWarnAboutStateAssignmentForComponent[componentName] = true;
        }
      }
      updater.enqueueReplaceState(instance, instance.state, null);
    }
  }

  // Invokes the mount life-cycles on a previously never rendered instance.
  function mountClassInstance(workInProgress, renderExpirationTime) {
    var current = workInProgress.alternate;

    {
      checkClassInstance(workInProgress);
    }

    var instance = workInProgress.stateNode;
    var state = instance.state || null;

    var props = workInProgress.pendingProps;
    !props ? invariant(false, 'There must be pending props for an initial mount. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    var unmaskedContext = getUnmaskedContext(workInProgress);

    instance.props = props;
    instance.state = workInProgress.memoizedState = state;
    instance.refs = emptyObject;
    instance.context = getMaskedContext(workInProgress, unmaskedContext);

    if (enableAsyncSubtreeAPI && workInProgress.type != null && workInProgress.type.prototype != null && workInProgress.type.prototype.unstable_isAsyncReactComponent === true) {
      workInProgress.internalContextTag |= AsyncUpdates;
    }

    if (typeof instance.componentWillMount === 'function') {
      callComponentWillMount(workInProgress, instance);
      // If we had additional state updates during this life-cycle, let's
      // process them now.
      var updateQueue = workInProgress.updateQueue;
      if (updateQueue !== null) {
        instance.state = processUpdateQueue(current, workInProgress, updateQueue, instance, props, renderExpirationTime);
      }
    }
    if (typeof instance.componentDidMount === 'function') {
      workInProgress.effectTag |= Update;
    }
  }

  // Called on a preexisting class instance. Returns false if a resumed render
  // could be reused.
  // function resumeMountClassInstance(
  //   workInProgress: Fiber,
  //   priorityLevel: PriorityLevel,
  // ): boolean {
  //   const instance = workInProgress.stateNode;
  //   resetInputPointers(workInProgress, instance);

  //   let newState = workInProgress.memoizedState;
  //   let newProps = workInProgress.pendingProps;
  //   if (!newProps) {
  //     // If there isn't any new props, then we'll reuse the memoized props.
  //     // This could be from already completed work.
  //     newProps = workInProgress.memoizedProps;
  //     invariant(
  //       newProps != null,
  //       'There should always be pending or memoized props. This error is ' +
  //         'likely caused by a bug in React. Please file an issue.',
  //     );
  //   }
  //   const newUnmaskedContext = getUnmaskedContext(workInProgress);
  //   const newContext = getMaskedContext(workInProgress, newUnmaskedContext);

  //   const oldContext = instance.context;
  //   const oldProps = workInProgress.memoizedProps;

  //   if (
  //     typeof instance.componentWillReceiveProps === 'function' &&
  //     (oldProps !== newProps || oldContext !== newContext)
  //   ) {
  //     callComponentWillReceiveProps(
  //       workInProgress,
  //       instance,
  //       newProps,
  //       newContext,
  //     );
  //   }

  //   // Process the update queue before calling shouldComponentUpdate
  //   const updateQueue = workInProgress.updateQueue;
  //   if (updateQueue !== null) {
  //     newState = processUpdateQueue(
  //       workInProgress,
  //       updateQueue,
  //       instance,
  //       newState,
  //       newProps,
  //       priorityLevel,
  //     );
  //   }

  //   // TODO: Should we deal with a setState that happened after the last
  //   // componentWillMount and before this componentWillMount? Probably
  //   // unsupported anyway.

  //   if (
  //     !checkShouldComponentUpdate(
  //       workInProgress,
  //       workInProgress.memoizedProps,
  //       newProps,
  //       workInProgress.memoizedState,
  //       newState,
  //       newContext,
  //     )
  //   ) {
  //     // Update the existing instance's state, props, and context pointers even
  //     // though we're bailing out.
  //     instance.props = newProps;
  //     instance.state = newState;
  //     instance.context = newContext;
  //     return false;
  //   }

  //   // Update the input pointers now so that they are correct when we call
  //   // componentWillMount
  //   instance.props = newProps;
  //   instance.state = newState;
  //   instance.context = newContext;

  //   if (typeof instance.componentWillMount === 'function') {
  //     callComponentWillMount(workInProgress, instance);
  //     // componentWillMount may have called setState. Process the update queue.
  //     const newUpdateQueue = workInProgress.updateQueue;
  //     if (newUpdateQueue !== null) {
  //       newState = processUpdateQueue(
  //         workInProgress,
  //         newUpdateQueue,
  //         instance,
  //         newState,
  //         newProps,
  //         priorityLevel,
  //       );
  //     }
  //   }

  //   if (typeof instance.componentDidMount === 'function') {
  //     workInProgress.effectTag |= Update;
  //   }

  //   instance.state = newState;

  //   return true;
  // }

  // Invokes the update life-cycles and returns false if it shouldn't rerender.
  function updateClassInstance(current, workInProgress, renderExpirationTime) {
    var instance = workInProgress.stateNode;
    resetInputPointers(workInProgress, instance);

    var oldProps = workInProgress.memoizedProps;
    var newProps = workInProgress.pendingProps;
    if (!newProps) {
      // If there aren't any new props, then we'll reuse the memoized props.
      // This could be from already completed work.
      newProps = oldProps;
      !(newProps != null) ? invariant(false, 'There should always be pending or memoized props. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    }
    var oldContext = instance.context;
    var newUnmaskedContext = getUnmaskedContext(workInProgress);
    var newContext = getMaskedContext(workInProgress, newUnmaskedContext);

    // Note: During these life-cycles, instance.props/instance.state are what
    // ever the previously attempted to render - not the "current". However,
    // during componentDidUpdate we pass the "current" props.

    if (typeof instance.componentWillReceiveProps === 'function' && (oldProps !== newProps || oldContext !== newContext)) {
      callComponentWillReceiveProps(workInProgress, instance, newProps, newContext);
    }

    // Compute the next state using the memoized state and the update queue.
    var oldState = workInProgress.memoizedState;
    // TODO: Previous state can be null.
    var newState = void 0;
    if (workInProgress.updateQueue !== null) {
      newState = processUpdateQueue(current, workInProgress, workInProgress.updateQueue, instance, newProps, renderExpirationTime);
    } else {
      newState = oldState;
    }

    if (oldProps === newProps && oldState === newState && !hasContextChanged() && !(workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate)) {
      // If an update was already in progress, we should schedule an Update
      // effect even though we're bailing out, so that cWU/cDU are called.
      if (typeof instance.componentDidUpdate === 'function') {
        if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
          workInProgress.effectTag |= Update;
        }
      }
      return false;
    }

    var shouldUpdate = checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext);

    if (shouldUpdate) {
      if (typeof instance.componentWillUpdate === 'function') {
        startPhaseTimer(workInProgress, 'componentWillUpdate');
        instance.componentWillUpdate(newProps, newState, newContext);
        stopPhaseTimer();

        // Simulate an async bailout/interruption by invoking lifecycle twice.
        if (debugRenderPhaseSideEffects) {
          instance.componentWillUpdate(newProps, newState, newContext);
        }
      }
      if (typeof instance.componentDidUpdate === 'function') {
        workInProgress.effectTag |= Update;
      }
    } else {
      // If an update was already in progress, we should schedule an Update
      // effect even though we're bailing out, so that cWU/cDU are called.
      if (typeof instance.componentDidUpdate === 'function') {
        if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
          workInProgress.effectTag |= Update;
        }
      }

      // If shouldComponentUpdate returned false, we should still update the
      // memoized props/state to indicate that this work can be reused.
      memoizeProps(workInProgress, newProps);
      memoizeState(workInProgress, newState);
    }

    // Update the existing instance's state, props, and context pointers even
    // if shouldComponentUpdate returns false.
    instance.props = newProps;
    instance.state = newState;
    instance.context = newContext;

    return shouldUpdate;
  }

  return {
    adoptClassInstance: adoptClassInstance,
    constructClassInstance: constructClassInstance,
    mountClassInstance: mountClassInstance,
    // resumeMountClassInstance,
    updateClassInstance: updateClassInstance
  };
};

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol['for'];

var REACT_ELEMENT_TYPE = hasSymbol ? Symbol['for']('react.element') : 0xeac7;
var REACT_CALL_TYPE = hasSymbol ? Symbol['for']('react.call') : 0xeac8;
var REACT_RETURN_TYPE = hasSymbol ? Symbol['for']('react.return') : 0xeac9;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol['for']('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol['for']('react.fragment') : 0xeacb;

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';

function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable === 'undefined') {
    return null;
  }
  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }
  return null;
}

var getCurrentFiberStackAddendum$1 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;


{
  var didWarnAboutMaps = false;
  /**
   * Warn if there's no key explicitly set on dynamic arrays of children or
   * object keys are not valid. This allows us to keep track of children between
   * updates.
   */
  var ownerHasKeyUseWarning = {};
  var ownerHasFunctionTypeWarning = {};

  var warnForMissingKey = function (child) {
    if (child === null || typeof child !== 'object') {
      return;
    }
    if (!child._store || child._store.validated || child.key != null) {
      return;
    }
    !(typeof child._store === 'object') ? invariant(false, 'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    child._store.validated = true;

    var currentComponentErrorInfo = 'Each child in an array or iterator should have a unique ' + '"key" prop. See https://fb.me/react-warning-keys for ' + 'more information.' + (getCurrentFiberStackAddendum$1() || '');
    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
      return;
    }
    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;

    warning(false, 'Each child in an array or iterator should have a unique ' + '"key" prop. See https://fb.me/react-warning-keys for ' + 'more information.%s', getCurrentFiberStackAddendum$1());
  };
}

var isArray$1 = Array.isArray;

function coerceRef(current, element) {
  var mixedRef = element.ref;
  if (mixedRef !== null && typeof mixedRef !== 'function') {
    if (element._owner) {
      var owner = element._owner;
      var inst = void 0;
      if (owner) {
        var ownerFiber = owner;
        !(ownerFiber.tag === ClassComponent) ? invariant(false, 'Stateless function components cannot have refs.') : void 0;
        inst = ownerFiber.stateNode;
      }
      !inst ? invariant(false, 'Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.', mixedRef) : void 0;
      var stringRef = '' + mixedRef;
      // Check if previous string ref matches new string ref
      if (current !== null && current.ref !== null && current.ref._stringRef === stringRef) {
        return current.ref;
      }
      var ref = function (value) {
        var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
        if (value === null) {
          delete refs[stringRef];
        } else {
          refs[stringRef] = value;
        }
      };
      ref._stringRef = stringRef;
      return ref;
    } else {
      !(typeof mixedRef === 'string') ? invariant(false, 'Expected ref to be a function or a string.') : void 0;
      !element._owner ? invariant(false, 'Element ref was specified as a string (%s) but no owner was set. You may have multiple copies of React loaded. (details: https://fb.me/react-refs-must-have-owner).', mixedRef) : void 0;
    }
  }
  return mixedRef;
}

function throwOnInvalidObjectType(returnFiber, newChild) {
  if (returnFiber.type !== 'textarea') {
    var addendum = '';
    {
      addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + (getCurrentFiberStackAddendum$1() || '');
    }
    invariant(false, 'Objects are not valid as a React child (found: %s).%s', Object.prototype.toString.call(newChild) === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : newChild, addendum);
  }
}

function warnOnFunctionType() {
  var currentComponentErrorInfo = 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.' + (getCurrentFiberStackAddendum$1() || '');

  if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {
    return;
  }
  ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;

  warning(false, 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.%s', getCurrentFiberStackAddendum$1() || '');
}

// This wrapper function exists because I expect to clone the code in each path
// to be able to optimize each path individually by branching early. This needs
// a compiler or we can do it manually. Helpers that don't need this branching
// live outside of this function.
function ChildReconciler(shouldTrackSideEffects) {
  function deleteChild(returnFiber, childToDelete) {
    if (!shouldTrackSideEffects) {
      // Noop.
      return;
    }
    // Deletions are added in reversed order so we add it to the front.
    // At this point, the return fiber's effect list is empty except for
    // deletions, so we can just append the deletion to the list. The remaining
    // effects aren't added until the complete phase. Once we implement
    // resuming, this may not be true.
    var last = returnFiber.lastEffect;
    if (last !== null) {
      last.nextEffect = childToDelete;
      returnFiber.lastEffect = childToDelete;
    } else {
      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
    }
    childToDelete.nextEffect = null;
    childToDelete.effectTag = Deletion;
  }

  function deleteRemainingChildren(returnFiber, currentFirstChild) {
    if (!shouldTrackSideEffects) {
      // Noop.
      return null;
    }

    // TODO: For the shouldClone case, this could be micro-optimized a bit by
    // assuming that after the first child we've already added everything.
    var childToDelete = currentFirstChild;
    while (childToDelete !== null) {
      deleteChild(returnFiber, childToDelete);
      childToDelete = childToDelete.sibling;
    }
    return null;
  }

  function mapRemainingChildren(returnFiber, currentFirstChild) {
    // Add the remaining children to a temporary map so that we can find them by
    // keys quickly. Implicit (null) keys get added to this set with their index
    var existingChildren = new Map();

    var existingChild = currentFirstChild;
    while (existingChild !== null) {
      if (existingChild.key !== null) {
        existingChildren.set(existingChild.key, existingChild);
      } else {
        existingChildren.set(existingChild.index, existingChild);
      }
      existingChild = existingChild.sibling;
    }
    return existingChildren;
  }

  function useFiber(fiber, pendingProps, expirationTime) {
    // We currently set sibling to null and index to 0 here because it is easy
    // to forget to do before returning it. E.g. for the single child case.
    var clone = createWorkInProgress(fiber, pendingProps, expirationTime);
    clone.index = 0;
    clone.sibling = null;
    return clone;
  }

  function placeChild(newFiber, lastPlacedIndex, newIndex) {
    newFiber.index = newIndex;
    if (!shouldTrackSideEffects) {
      // Noop.
      return lastPlacedIndex;
    }
    var current = newFiber.alternate;
    if (current !== null) {
      var oldIndex = current.index;
      if (oldIndex < lastPlacedIndex) {
        // This is a move.
        newFiber.effectTag = Placement;
        return lastPlacedIndex;
      } else {
        // This item can stay in place.
        return oldIndex;
      }
    } else {
      // This is an insertion.
      newFiber.effectTag = Placement;
      return lastPlacedIndex;
    }
  }

  function placeSingleChild(newFiber) {
    // This is simpler for the single child case. We only need to do a
    // placement for inserting new children.
    if (shouldTrackSideEffects && newFiber.alternate === null) {
      newFiber.effectTag = Placement;
    }
    return newFiber;
  }

  function updateTextNode(returnFiber, current, textContent, expirationTime) {
    if (current === null || current.tag !== HostText) {
      // Insert
      var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);
      created['return'] = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current, textContent, expirationTime);
      existing['return'] = returnFiber;
      return existing;
    }
  }

  function updateElement(returnFiber, current, element, expirationTime) {
    if (current !== null && current.type === element.type) {
      // Move based on index
      var existing = useFiber(current, element.props, expirationTime);
      existing.ref = coerceRef(current, element);
      existing['return'] = returnFiber;
      {
        existing._debugSource = element._source;
        existing._debugOwner = element._owner;
      }
      return existing;
    } else {
      // Insert
      var created = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);
      created.ref = coerceRef(current, element);
      created['return'] = returnFiber;
      return created;
    }
  }

  function updateCall(returnFiber, current, call, expirationTime) {
    // TODO: Should this also compare handler to determine whether to reuse?
    if (current === null || current.tag !== CallComponent) {
      // Insert
      var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);
      created['return'] = returnFiber;
      return created;
    } else {
      // Move based on index
      var existing = useFiber(current, call, expirationTime);
      existing['return'] = returnFiber;
      return existing;
    }
  }

  function updateReturn(returnFiber, current, returnNode, expirationTime) {
    if (current === null || current.tag !== ReturnComponent) {
      // Insert
      var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);
      created.type = returnNode.value;
      created['return'] = returnFiber;
      return created;
    } else {
      // Move based on index
      var existing = useFiber(current, null, expirationTime);
      existing.type = returnNode.value;
      existing['return'] = returnFiber;
      return existing;
    }
  }

  function updatePortal(returnFiber, current, portal, expirationTime) {
    if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {
      // Insert
      var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);
      created['return'] = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current, portal.children || [], expirationTime);
      existing['return'] = returnFiber;
      return existing;
    }
  }

  function updateFragment(returnFiber, current, fragment, expirationTime, key) {
    if (current === null || current.tag !== Fragment) {
      // Insert
      var created = createFiberFromFragment(fragment, returnFiber.internalContextTag, expirationTime, key);
      created['return'] = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current, fragment, expirationTime);
      existing['return'] = returnFiber;
      return existing;
    }
  }

  function createChild(returnFiber, newChild, expirationTime) {
    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys. If the previous node is implicitly keyed
      // we can continue to replace it without aborting even if it is not a text
      // node.
      var created = createFiberFromText('' + newChild, returnFiber.internalContextTag, expirationTime);
      created['return'] = returnFiber;
      return created;
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          {
            if (newChild.type === REACT_FRAGMENT_TYPE) {
              var _created = createFiberFromFragment(newChild.props.children, returnFiber.internalContextTag, expirationTime, newChild.key);
              _created['return'] = returnFiber;
              return _created;
            } else {
              var _created2 = createFiberFromElement(newChild, returnFiber.internalContextTag, expirationTime);
              _created2.ref = coerceRef(null, newChild);
              _created2['return'] = returnFiber;
              return _created2;
            }
          }

        case REACT_CALL_TYPE:
          {
            var _created3 = createFiberFromCall(newChild, returnFiber.internalContextTag, expirationTime);
            _created3['return'] = returnFiber;
            return _created3;
          }

        case REACT_RETURN_TYPE:
          {
            var _created4 = createFiberFromReturn(newChild, returnFiber.internalContextTag, expirationTime);
            _created4.type = newChild.value;
            _created4['return'] = returnFiber;
            return _created4;
          }

        case REACT_PORTAL_TYPE:
          {
            var _created5 = createFiberFromPortal(newChild, returnFiber.internalContextTag, expirationTime);
            _created5['return'] = returnFiber;
            return _created5;
          }
      }

      if (isArray$1(newChild) || getIteratorFn(newChild)) {
        var _created6 = createFiberFromFragment(newChild, returnFiber.internalContextTag, expirationTime, null);
        _created6['return'] = returnFiber;
        return _created6;
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType();
      }
    }

    return null;
  }

  function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {
    // Update the fiber if the keys match, otherwise return null.

    var key = oldFiber !== null ? oldFiber.key : null;

    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys. If the previous node is implicitly keyed
      // we can continue to replace it without aborting even if it is not a text
      // node.
      if (key !== null) {
        return null;
      }
      return updateTextNode(returnFiber, oldFiber, '' + newChild, expirationTime);
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          {
            if (newChild.key === key) {
              if (newChild.type === REACT_FRAGMENT_TYPE) {
                return updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key);
              }
              return updateElement(returnFiber, oldFiber, newChild, expirationTime);
            } else {
              return null;
            }
          }

        case REACT_CALL_TYPE:
          {
            if (newChild.key === key) {
              return updateCall(returnFiber, oldFiber, newChild, expirationTime);
            } else {
              return null;
            }
          }

        case REACT_RETURN_TYPE:
          {
            // Returns don't have keys. If the previous node is implicitly keyed
            // we can continue to replace it without aborting even if it is not a
            // yield.
            if (key === null) {
              return updateReturn(returnFiber, oldFiber, newChild, expirationTime);
            } else {
              return null;
            }
          }

        case REACT_PORTAL_TYPE:
          {
            if (newChild.key === key) {
              return updatePortal(returnFiber, oldFiber, newChild, expirationTime);
            } else {
              return null;
            }
          }
      }

      if (isArray$1(newChild) || getIteratorFn(newChild)) {
        if (key !== null) {
          return null;
        }

        return updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType();
      }
    }

    return null;
  }

  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {
    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys, so we neither have to check the old nor
      // new node for the key. If both are text nodes, they match.
      var matchedFiber = existingChildren.get(newIdx) || null;
      return updateTextNode(returnFiber, matchedFiber, '' + newChild, expirationTime);
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          {
            var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
            if (newChild.type === REACT_FRAGMENT_TYPE) {
              return updateFragment(returnFiber, _matchedFiber, newChild.props.children, expirationTime, newChild.key);
            }
            return updateElement(returnFiber, _matchedFiber, newChild, expirationTime);
          }

        case REACT_CALL_TYPE:
          {
            var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
            return updateCall(returnFiber, _matchedFiber2, newChild, expirationTime);
          }

        case REACT_RETURN_TYPE:
          {
            // Returns don't have keys, so we neither have to check the old nor
            // new node for the key. If both are returns, they match.
            var _matchedFiber3 = existingChildren.get(newIdx) || null;
            return updateReturn(returnFiber, _matchedFiber3, newChild, expirationTime);
          }

        case REACT_PORTAL_TYPE:
          {
            var _matchedFiber4 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
            return updatePortal(returnFiber, _matchedFiber4, newChild, expirationTime);
          }
      }

      if (isArray$1(newChild) || getIteratorFn(newChild)) {
        var _matchedFiber5 = existingChildren.get(newIdx) || null;
        return updateFragment(returnFiber, _matchedFiber5, newChild, expirationTime, null);
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType();
      }
    }

    return null;
  }

  /**
   * Warns if there is a duplicate or missing key
   */
  function warnOnInvalidKey(child, knownKeys) {
    {
      if (typeof child !== 'object' || child === null) {
        return knownKeys;
      }
      switch (child.$$typeof) {
        case REACT_ELEMENT_TYPE:
        case REACT_CALL_TYPE:
        case REACT_PORTAL_TYPE:
          warnForMissingKey(child);
          var key = child.key;
          if (typeof key !== 'string') {
            break;
          }
          if (knownKeys === null) {
            knownKeys = new Set();
            knownKeys.add(key);
            break;
          }
          if (!knownKeys.has(key)) {
            knownKeys.add(key);
            break;
          }
          warning(false, 'Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted  the behavior is unsupported and ' + 'could change in a future version.%s', key, getCurrentFiberStackAddendum$1());
          break;
        default:
          break;
      }
    }
    return knownKeys;
  }

  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {
    // This algorithm can't optimize by searching from boths ends since we
    // don't have backpointers on fibers. I'm trying to see how far we can get
    // with that model. If it ends up not being worth the tradeoffs, we can
    // add it later.

    // Even with a two ended optimization, we'd want to optimize for the case
    // where there are few changes and brute force the comparison instead of
    // going for the Map. It'd like to explore hitting that path first in
    // forward-only mode and only go for the Map once we notice that we need
    // lots of look ahead. This doesn't handle reversal as well as two ended
    // search but that's unusual. Besides, for the two ended optimization to
    // work on Iterables, we'd need to copy the whole set.

    // In this first iteration, we'll just live with hitting the bad case
    // (adding everything to a Map) in for every insert/move.

    // If you change this code, also update reconcileChildrenIterator() which
    // uses the same algorithm.

    {
      // First, validate keys.
      var knownKeys = null;
      for (var i = 0; i < newChildren.length; i++) {
        var child = newChildren[i];
        knownKeys = warnOnInvalidKey(child, knownKeys);
      }
    }

    var resultingFirstChild = null;
    var previousNewFiber = null;

    var oldFiber = currentFirstChild;
    var lastPlacedIndex = 0;
    var newIdx = 0;
    var nextOldFiber = null;
    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
      if (oldFiber.index > newIdx) {
        nextOldFiber = oldFiber;
        oldFiber = null;
      } else {
        nextOldFiber = oldFiber.sibling;
      }
      var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);
      if (newFiber === null) {
        // TODO: This breaks on empty slots like null children. That's
        // unfortunate because it triggers the slow path all the time. We need
        // a better way to communicate whether this was a miss or null,
        // boolean, undefined, etc.
        if (oldFiber === null) {
          oldFiber = nextOldFiber;
        }
        break;
      }
      if (shouldTrackSideEffects) {
        if (oldFiber && newFiber.alternate === null) {
          // We matched the slot, but we didn't reuse the existing fiber, so we
          // need to delete the existing child.
          deleteChild(returnFiber, oldFiber);
        }
      }
      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
      if (previousNewFiber === null) {
        // TODO: Move out of the loop. This only happens for the first run.
        resultingFirstChild = newFiber;
      } else {
        // TODO: Defer siblings if we're not at the right index for this slot.
        // I.e. if we had null values before, then we want to defer this
        // for each null value. However, we also don't want to call updateSlot
        // with the previous one.
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }

    if (newIdx === newChildren.length) {
      // We've reached the end of the new children. We can delete the rest.
      deleteRemainingChildren(returnFiber, oldFiber);
      return resultingFirstChild;
    }

    if (oldFiber === null) {
      // If we don't have any more existing children we can choose a fast path
      // since the rest will all be insertions.
      for (; newIdx < newChildren.length; newIdx++) {
        var _newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);
        if (!_newFiber) {
          continue;
        }
        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          // TODO: Move out of the loop. This only happens for the first run.
          resultingFirstChild = _newFiber;
        } else {
          previousNewFiber.sibling = _newFiber;
        }
        previousNewFiber = _newFiber;
      }
      return resultingFirstChild;
    }

    // Add all children to a key map for quick lookups.
    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);

    // Keep scanning and use the map to restore deleted items as moves.
    for (; newIdx < newChildren.length; newIdx++) {
      var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);
      if (_newFiber2) {
        if (shouldTrackSideEffects) {
          if (_newFiber2.alternate !== null) {
            // The new fiber is a work in progress, but if there exists a
            // current, that means that we reused the fiber. We need to delete
            // it from the child list so that we don't add it to the deletion
            // list.
            existingChildren['delete'](_newFiber2.key === null ? newIdx : _newFiber2.key);
          }
        }
        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          resultingFirstChild = _newFiber2;
        } else {
          previousNewFiber.sibling = _newFiber2;
        }
        previousNewFiber = _newFiber2;
      }
    }

    if (shouldTrackSideEffects) {
      // Any existing children that weren't consumed above were deleted. We need
      // to add them to the deletion list.
      existingChildren.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
    }

    return resultingFirstChild;
  }

  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {
    // This is the same implementation as reconcileChildrenArray(),
    // but using the iterator instead.

    var iteratorFn = getIteratorFn(newChildrenIterable);
    !(typeof iteratorFn === 'function') ? invariant(false, 'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    {
      // Warn about using Maps as children
      if (typeof newChildrenIterable.entries === 'function') {
        var possibleMap = newChildrenIterable;
        if (possibleMap.entries === iteratorFn) {
          warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', getCurrentFiberStackAddendum$1());
          didWarnAboutMaps = true;
        }
      }

      // First, validate keys.
      // We'll get a different iterator later for the main pass.
      var _newChildren = iteratorFn.call(newChildrenIterable);
      if (_newChildren) {
        var knownKeys = null;
        var _step = _newChildren.next();
        for (; !_step.done; _step = _newChildren.next()) {
          var child = _step.value;
          knownKeys = warnOnInvalidKey(child, knownKeys);
        }
      }
    }

    var newChildren = iteratorFn.call(newChildrenIterable);
    !(newChildren != null) ? invariant(false, 'An iterable object provided no iterator.') : void 0;

    var resultingFirstChild = null;
    var previousNewFiber = null;

    var oldFiber = currentFirstChild;
    var lastPlacedIndex = 0;
    var newIdx = 0;
    var nextOldFiber = null;

    var step = newChildren.next();
    for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
      if (oldFiber.index > newIdx) {
        nextOldFiber = oldFiber;
        oldFiber = null;
      } else {
        nextOldFiber = oldFiber.sibling;
      }
      var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);
      if (newFiber === null) {
        // TODO: This breaks on empty slots like null children. That's
        // unfortunate because it triggers the slow path all the time. We need
        // a better way to communicate whether this was a miss or null,
        // boolean, undefined, etc.
        if (!oldFiber) {
          oldFiber = nextOldFiber;
        }
        break;
      }
      if (shouldTrackSideEffects) {
        if (oldFiber && newFiber.alternate === null) {
          // We matched the slot, but we didn't reuse the existing fiber, so we
          // need to delete the existing child.
          deleteChild(returnFiber, oldFiber);
        }
      }
      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
      if (previousNewFiber === null) {
        // TODO: Move out of the loop. This only happens for the first run.
        resultingFirstChild = newFiber;
      } else {
        // TODO: Defer siblings if we're not at the right index for this slot.
        // I.e. if we had null values before, then we want to defer this
        // for each null value. However, we also don't want to call updateSlot
        // with the previous one.
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }

    if (step.done) {
      // We've reached the end of the new children. We can delete the rest.
      deleteRemainingChildren(returnFiber, oldFiber);
      return resultingFirstChild;
    }

    if (oldFiber === null) {
      // If we don't have any more existing children we can choose a fast path
      // since the rest will all be insertions.
      for (; !step.done; newIdx++, step = newChildren.next()) {
        var _newFiber3 = createChild(returnFiber, step.value, expirationTime);
        if (_newFiber3 === null) {
          continue;
        }
        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          // TODO: Move out of the loop. This only happens for the first run.
          resultingFirstChild = _newFiber3;
        } else {
          previousNewFiber.sibling = _newFiber3;
        }
        previousNewFiber = _newFiber3;
      }
      return resultingFirstChild;
    }

    // Add all children to a key map for quick lookups.
    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);

    // Keep scanning and use the map to restore deleted items as moves.
    for (; !step.done; newIdx++, step = newChildren.next()) {
      var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);
      if (_newFiber4 !== null) {
        if (shouldTrackSideEffects) {
          if (_newFiber4.alternate !== null) {
            // The new fiber is a work in progress, but if there exists a
            // current, that means that we reused the fiber. We need to delete
            // it from the child list so that we don't add it to the deletion
            // list.
            existingChildren['delete'](_newFiber4.key === null ? newIdx : _newFiber4.key);
          }
        }
        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          resultingFirstChild = _newFiber4;
        } else {
          previousNewFiber.sibling = _newFiber4;
        }
        previousNewFiber = _newFiber4;
      }
    }

    if (shouldTrackSideEffects) {
      // Any existing children that weren't consumed above were deleted. We need
      // to add them to the deletion list.
      existingChildren.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
    }

    return resultingFirstChild;
  }

  function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {
    // There's no need to check for keys on text nodes since we don't have a
    // way to define them.
    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
      // We already have an existing node so let's just update it and delete
      // the rest.
      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
      var existing = useFiber(currentFirstChild, textContent, expirationTime);
      existing['return'] = returnFiber;
      return existing;
    }
    // The existing first child is not a text node so we need to create one
    // and delete the existing ones.
    deleteRemainingChildren(returnFiber, currentFirstChild);
    var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);
    created['return'] = returnFiber;
    return created;
  }

  function reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime) {
    var key = element.key;
    var child = currentFirstChild;
    while (child !== null) {
      // TODO: If key === null and child.key === null, then this only applies to
      // the first item in the list.
      if (child.key === key) {
        if (child.tag === Fragment ? element.type === REACT_FRAGMENT_TYPE : child.type === element.type) {
          deleteRemainingChildren(returnFiber, child.sibling);
          var existing = useFiber(child, element.type === REACT_FRAGMENT_TYPE ? element.props.children : element.props, expirationTime);
          existing.ref = coerceRef(child, element);
          existing['return'] = returnFiber;
          {
            existing._debugSource = element._source;
            existing._debugOwner = element._owner;
          }
          return existing;
        } else {
          deleteRemainingChildren(returnFiber, child);
          break;
        }
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }

    if (element.type === REACT_FRAGMENT_TYPE) {
      var created = createFiberFromFragment(element.props.children, returnFiber.internalContextTag, expirationTime, element.key);
      created['return'] = returnFiber;
      return created;
    } else {
      var _created7 = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);
      _created7.ref = coerceRef(currentFirstChild, element);
      _created7['return'] = returnFiber;
      return _created7;
    }
  }

  function reconcileSingleCall(returnFiber, currentFirstChild, call, expirationTime) {
    var key = call.key;
    var child = currentFirstChild;
    while (child !== null) {
      // TODO: If key === null and child.key === null, then this only applies to
      // the first item in the list.
      if (child.key === key) {
        if (child.tag === CallComponent) {
          deleteRemainingChildren(returnFiber, child.sibling);
          var existing = useFiber(child, call, expirationTime);
          existing['return'] = returnFiber;
          return existing;
        } else {
          deleteRemainingChildren(returnFiber, child);
          break;
        }
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }

    var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);
    created['return'] = returnFiber;
    return created;
  }

  function reconcileSingleReturn(returnFiber, currentFirstChild, returnNode, expirationTime) {
    // There's no need to check for keys on yields since they're stateless.
    var child = currentFirstChild;
    if (child !== null) {
      if (child.tag === ReturnComponent) {
        deleteRemainingChildren(returnFiber, child.sibling);
        var existing = useFiber(child, null, expirationTime);
        existing.type = returnNode.value;
        existing['return'] = returnFiber;
        return existing;
      } else {
        deleteRemainingChildren(returnFiber, child);
      }
    }

    var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);
    created.type = returnNode.value;
    created['return'] = returnFiber;
    return created;
  }

  function reconcileSinglePortal(returnFiber, currentFirstChild, portal, expirationTime) {
    var key = portal.key;
    var child = currentFirstChild;
    while (child !== null) {
      // TODO: If key === null and child.key === null, then this only applies to
      // the first item in the list.
      if (child.key === key) {
        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
          deleteRemainingChildren(returnFiber, child.sibling);
          var existing = useFiber(child, portal.children || [], expirationTime);
          existing['return'] = returnFiber;
          return existing;
        } else {
          deleteRemainingChildren(returnFiber, child);
          break;
        }
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }

    var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);
    created['return'] = returnFiber;
    return created;
  }

  // This API will tag the children with the side-effect of the reconciliation
  // itself. They will be added to the side-effect list as we pass through the
  // children and the parent.
  function reconcileChildFibers(returnFiber, currentFirstChild, newChild, expirationTime) {
    // This function is not recursive.
    // If the top level item is an array, we treat it as a set of children,
    // not as a fragment. Nested arrays on the other hand will be treated as
    // fragment nodes. Recursion happens at the normal flow.

    // Handle top level unkeyed fragments as if they were arrays.
    // This leads to an ambiguity between <>{[...]}</> and <>...</>.
    // We treat the ambiguous cases above the same.
    if (typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null) {
      newChild = newChild.props.children;
    }

    // Handle object types
    var isObject = typeof newChild === 'object' && newChild !== null;

    if (isObject) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));

        case REACT_CALL_TYPE:
          return placeSingleChild(reconcileSingleCall(returnFiber, currentFirstChild, newChild, expirationTime));
        case REACT_RETURN_TYPE:
          return placeSingleChild(reconcileSingleReturn(returnFiber, currentFirstChild, newChild, expirationTime));
        case REACT_PORTAL_TYPE:
          return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));
      }
    }

    if (typeof newChild === 'string' || typeof newChild === 'number') {
      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, expirationTime));
    }

    if (isArray$1(newChild)) {
      return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);
    }

    if (getIteratorFn(newChild)) {
      return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);
    }

    if (isObject) {
      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType();
      }
    }
    if (typeof newChild === 'undefined') {
      // If the new child is undefined, and the return fiber is a composite
      // component, throw an error. If Fiber return types are disabled,
      // we already threw above.
      switch (returnFiber.tag) {
        case ClassComponent:
          {
            {
              var instance = returnFiber.stateNode;
              if (instance.render._isMockFunction) {
                // We allow auto-mocks to proceed as if they're returning null.
                break;
              }
            }
          }
        // Intentionally fall through to the next case, which handles both
        // functions and classes
        // eslint-disable-next-lined no-fallthrough
        case FunctionalComponent:
          {
            var Component = returnFiber.type;
            invariant(false, '%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.', Component.displayName || Component.name || 'Component');
          }
      }
    }

    // Remaining cases are all treated as empty.
    return deleteRemainingChildren(returnFiber, currentFirstChild);
  }

  return reconcileChildFibers;
}

var reconcileChildFibers = ChildReconciler(true);
var mountChildFibers = ChildReconciler(false);

function cloneChildFibers(current, workInProgress) {
  !(current === null || workInProgress.child === current.child) ? invariant(false, 'Resuming work not yet implemented.') : void 0;

  if (workInProgress.child === null) {
    return;
  }

  var currentChild = workInProgress.child;
  var newChild = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);
  workInProgress.child = newChild;

  newChild['return'] = workInProgress;
  while (currentChild.sibling !== null) {
    currentChild = currentChild.sibling;
    newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);
    newChild['return'] = workInProgress;
  }
  newChild.sibling = null;
}

{
  var warnedAboutStatelessRefs = {};
}

var ReactFiberBeginWork = function (config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber) {
  var shouldSetTextContent = config.shouldSetTextContent,
      useSyncScheduling = config.useSyncScheduling,
      shouldDeprioritizeSubtree = config.shouldDeprioritizeSubtree;
  var pushHostContext = hostContext.pushHostContext,
      pushHostContainer = hostContext.pushHostContainer;
  var enterHydrationState = hydrationContext.enterHydrationState,
      resetHydrationState = hydrationContext.resetHydrationState,
      tryToClaimNextHydratableInstance = hydrationContext.tryToClaimNextHydratableInstance;

  var _ReactFiberClassCompo = ReactFiberClassComponent(scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState),
      adoptClassInstance = _ReactFiberClassCompo.adoptClassInstance,
      constructClassInstance = _ReactFiberClassCompo.constructClassInstance,
      mountClassInstance = _ReactFiberClassCompo.mountClassInstance,
      updateClassInstance = _ReactFiberClassCompo.updateClassInstance;

  // TODO: Remove this and use reconcileChildrenAtExpirationTime directly.


  function reconcileChildren(current, workInProgress, nextChildren) {
    reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, workInProgress.expirationTime);
  }

  function reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime) {
    if (current === null) {
      // If this is a fresh new component that hasn't been rendered yet, we
      // won't update its child set by applying minimal side-effects. Instead,
      // we will add them all to the child before it gets rendered. That means
      // we can optimize this reconciliation pass by not tracking side-effects.
      workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
    } else {
      // If the current child is the same as the work in progress, it means that
      // we haven't yet started any work on these children. Therefore, we use
      // the clone algorithm to create a copy of all the current children.

      // If we had any progressed work already, that is invalid at this point so
      // let's throw it out.
      workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderExpirationTime);
    }
  }

  function updateFragment(current, workInProgress) {
    var nextChildren = workInProgress.pendingProps;
    if (hasContextChanged()) {
      // Normally we can bail out on props equality but if context has changed
      // we don't do the bailout and we have to reuse existing props instead.
      if (nextChildren === null) {
        nextChildren = workInProgress.memoizedProps;
      }
    } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {
      return bailoutOnAlreadyFinishedWork(current, workInProgress);
    }
    reconcileChildren(current, workInProgress, nextChildren);
    memoizeProps(workInProgress, nextChildren);
    return workInProgress.child;
  }

  function markRef(current, workInProgress) {
    var ref = workInProgress.ref;
    if (ref !== null && (!current || current.ref !== ref)) {
      // Schedule a Ref effect
      workInProgress.effectTag |= Ref;
    }
  }

  function updateFunctionalComponent(current, workInProgress) {
    var fn = workInProgress.type;
    var nextProps = workInProgress.pendingProps;

    var memoizedProps = workInProgress.memoizedProps;
    if (hasContextChanged()) {
      // Normally we can bail out on props equality but if context has changed
      // we don't do the bailout and we have to reuse existing props instead.
      if (nextProps === null) {
        nextProps = memoizedProps;
      }
    } else {
      if (nextProps === null || memoizedProps === nextProps) {
        return bailoutOnAlreadyFinishedWork(current, workInProgress);
      }
      // TODO: consider bringing fn.shouldComponentUpdate() back.
      // It used to be here.
    }

    var unmaskedContext = getUnmaskedContext(workInProgress);
    var context = getMaskedContext(workInProgress, unmaskedContext);

    var nextChildren;

    {
      ReactCurrentOwner.current = workInProgress;
      ReactDebugCurrentFiber.setCurrentPhase('render');
      nextChildren = fn(nextProps, context);
      ReactDebugCurrentFiber.setCurrentPhase(null);
    }
    // React DevTools reads this flag.
    workInProgress.effectTag |= PerformedWork;
    reconcileChildren(current, workInProgress, nextChildren);
    memoizeProps(workInProgress, nextProps);
    return workInProgress.child;
  }

  function updateClassComponent(current, workInProgress, renderExpirationTime) {
    // Push context providers early to prevent context stack mismatches.
    // During mounting we don't know the child context yet as the instance doesn't exist.
    // We will invalidate the child context in finishClassComponent() right after rendering.
    var hasContext = pushContextProvider(workInProgress);

    var shouldUpdate = void 0;
    if (current === null) {
      if (!workInProgress.stateNode) {
        // In the initial pass we might need to construct the instance.
        constructClassInstance(workInProgress, workInProgress.pendingProps);
        mountClassInstance(workInProgress, renderExpirationTime);
        shouldUpdate = true;
      } else {
        invariant(false, 'Resuming work not yet implemented.');
        // In a resume, we'll already have an instance we can reuse.
        // shouldUpdate = resumeMountClassInstance(workInProgress, renderExpirationTime);
      }
    } else {
      shouldUpdate = updateClassInstance(current, workInProgress, renderExpirationTime);
    }
    return finishClassComponent(current, workInProgress, shouldUpdate, hasContext);
  }

  function finishClassComponent(current, workInProgress, shouldUpdate, hasContext) {
    // Refs should update even if shouldComponentUpdate returns false
    markRef(current, workInProgress);

    if (!shouldUpdate) {
      // Context providers should defer to sCU for rendering
      if (hasContext) {
        invalidateContextProvider(workInProgress, false);
      }

      return bailoutOnAlreadyFinishedWork(current, workInProgress);
    }

    var instance = workInProgress.stateNode;

    // Rerender
    ReactCurrentOwner.current = workInProgress;
    var nextChildren = void 0;
    {
      ReactDebugCurrentFiber.setCurrentPhase('render');
      nextChildren = instance.render();
      if (debugRenderPhaseSideEffects) {
        instance.render();
      }
      ReactDebugCurrentFiber.setCurrentPhase(null);
    }
    // React DevTools reads this flag.
    workInProgress.effectTag |= PerformedWork;
    reconcileChildren(current, workInProgress, nextChildren);
    // Memoize props and state using the values we just used to render.
    // TODO: Restructure so we never read values from the instance.
    memoizeState(workInProgress, instance.state);
    memoizeProps(workInProgress, instance.props);

    // The context might have changed so we need to recalculate it.
    if (hasContext) {
      invalidateContextProvider(workInProgress, true);
    }

    return workInProgress.child;
  }

  function pushHostRootContext(workInProgress) {
    var root = workInProgress.stateNode;
    if (root.pendingContext) {
      pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);
    } else if (root.context) {
      // Should always be set
      pushTopLevelContextObject(workInProgress, root.context, false);
    }
    pushHostContainer(workInProgress, root.containerInfo);
  }

  function updateHostRoot(current, workInProgress, renderExpirationTime) {
    pushHostRootContext(workInProgress);
    var updateQueue = workInProgress.updateQueue;
    if (updateQueue !== null) {
      var prevState = workInProgress.memoizedState;
      var state = processUpdateQueue(current, workInProgress, updateQueue, null, null, renderExpirationTime);
      if (prevState === state) {
        // If the state is the same as before, that's a bailout because we had
        // no work that expires at this time.
        resetHydrationState();
        return bailoutOnAlreadyFinishedWork(current, workInProgress);
      }
      var element = state.element;
      var root = workInProgress.stateNode;
      if ((current === null || current.child === null) && root.hydrate && enterHydrationState(workInProgress)) {
        // If we don't have any current children this might be the first pass.
        // We always try to hydrate. If this isn't a hydration pass there won't
        // be any children to hydrate which is effectively the same thing as
        // not hydrating.

        // This is a bit of a hack. We track the host root as a placement to
        // know that we're currently in a mounting state. That way isMounted
        // works as expected. We must reset this before committing.
        // TODO: Delete this when we delete isMounted and findDOMNode.
        workInProgress.effectTag |= Placement;

        // Ensure that children mount into this root without tracking
        // side-effects. This ensures that we don't store Placement effects on
        // nodes that will be hydrated.
        workInProgress.child = mountChildFibers(workInProgress, null, element, renderExpirationTime);
      } else {
        // Otherwise reset hydration state in case we aborted and resumed another
        // root.
        resetHydrationState();
        reconcileChildren(current, workInProgress, element);
      }
      memoizeState(workInProgress, state);
      return workInProgress.child;
    }
    resetHydrationState();
    // If there is no update queue, that's a bailout because the root has no props.
    return bailoutOnAlreadyFinishedWork(current, workInProgress);
  }

  function updateHostComponent(current, workInProgress, renderExpirationTime) {
    pushHostContext(workInProgress);

    if (current === null) {
      tryToClaimNextHydratableInstance(workInProgress);
    }

    var type = workInProgress.type;
    var memoizedProps = workInProgress.memoizedProps;
    var nextProps = workInProgress.pendingProps;
    if (nextProps === null) {
      nextProps = memoizedProps;
      !(nextProps !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    }
    var prevProps = current !== null ? current.memoizedProps : null;

    if (hasContextChanged()) {
      // Normally we can bail out on props equality but if context has changed
      // we don't do the bailout and we have to reuse existing props instead.
    } else if (nextProps === null || memoizedProps === nextProps) {
      return bailoutOnAlreadyFinishedWork(current, workInProgress);
    }

    var nextChildren = nextProps.children;
    var isDirectTextChild = shouldSetTextContent(type, nextProps);

    if (isDirectTextChild) {
      // We special case a direct text child of a host node. This is a common
      // case. We won't handle it as a reified child. We will instead handle
      // this in the host environment that also have access to this prop. That
      // avoids allocating another HostText fiber and traversing it.
      nextChildren = null;
    } else if (prevProps && shouldSetTextContent(type, prevProps)) {
      // If we're switching from a direct text child to a normal child, or to
      // empty, we need to schedule the text content to be reset.
      workInProgress.effectTag |= ContentReset;
    }

    markRef(current, workInProgress);

    // Check the host config to see if the children are offscreen/hidden.
    if (renderExpirationTime !== Never && !useSyncScheduling && shouldDeprioritizeSubtree(type, nextProps)) {
      // Down-prioritize the children.
      workInProgress.expirationTime = Never;
      // Bailout and come back to this fiber later.
      return null;
    }

    reconcileChildren(current, workInProgress, nextChildren);
    memoizeProps(workInProgress, nextProps);
    return workInProgress.child;
  }

  function updateHostText(current, workInProgress) {
    if (current === null) {
      tryToClaimNextHydratableInstance(workInProgress);
    }
    var nextProps = workInProgress.pendingProps;
    if (nextProps === null) {
      nextProps = workInProgress.memoizedProps;
    }
    memoizeProps(workInProgress, nextProps);
    // Nothing to do here. This is terminal. We'll do the completion step
    // immediately after.
    return null;
  }

  function mountIndeterminateComponent(current, workInProgress, renderExpirationTime) {
    !(current === null) ? invariant(false, 'An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    var fn = workInProgress.type;
    var props = workInProgress.pendingProps;
    var unmaskedContext = getUnmaskedContext(workInProgress);
    var context = getMaskedContext(workInProgress, unmaskedContext);

    var value;

    {
      if (fn.prototype && typeof fn.prototype.render === 'function') {
        var componentName = getComponentName(workInProgress);
        warning(false, "The <%s /> component appears to have a render method, but doesn't extend React.Component. " + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);
      }
      ReactCurrentOwner.current = workInProgress;
      value = fn(props, context);
    }
    // React DevTools reads this flag.
    workInProgress.effectTag |= PerformedWork;

    if (typeof value === 'object' && value !== null && typeof value.render === 'function') {
      // Proceed under the assumption that this is a class instance
      workInProgress.tag = ClassComponent;

      // Push context providers early to prevent context stack mismatches.
      // During mounting we don't know the child context yet as the instance doesn't exist.
      // We will invalidate the child context in finishClassComponent() right after rendering.
      var hasContext = pushContextProvider(workInProgress);
      adoptClassInstance(workInProgress, value);
      mountClassInstance(workInProgress, renderExpirationTime);
      return finishClassComponent(current, workInProgress, true, hasContext);
    } else {
      // Proceed under the assumption that this is a functional component
      workInProgress.tag = FunctionalComponent;
      {
        var Component = workInProgress.type;

        if (Component) {
          warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component');
        }
        if (workInProgress.ref !== null) {
          var info = '';
          var ownerName = ReactDebugCurrentFiber.getCurrentFiberOwnerName();
          if (ownerName) {
            info += '\n\nCheck the render method of `' + ownerName + '`.';
          }

          var warningKey = ownerName || workInProgress._debugID || '';
          var debugSource = workInProgress._debugSource;
          if (debugSource) {
            warningKey = debugSource.fileName + ':' + debugSource.lineNumber;
          }
          if (!warnedAboutStatelessRefs[warningKey]) {
            warnedAboutStatelessRefs[warningKey] = true;
            warning(false, 'Stateless function components cannot be given refs. ' + 'Attempts to access this ref will fail.%s%s', info, ReactDebugCurrentFiber.getCurrentFiberStackAddendum());
          }
        }
      }
      reconcileChildren(current, workInProgress, value);
      memoizeProps(workInProgress, props);
      return workInProgress.child;
    }
  }

  function updateCallComponent(current, workInProgress, renderExpirationTime) {
    var nextCall = workInProgress.pendingProps;
    if (hasContextChanged()) {
      // Normally we can bail out on props equality but if context has changed
      // we don't do the bailout and we have to reuse existing props instead.
      if (nextCall === null) {
        nextCall = current && current.memoizedProps;
        !(nextCall !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;
      }
    } else if (nextCall === null || workInProgress.memoizedProps === nextCall) {
      nextCall = workInProgress.memoizedProps;
      // TODO: When bailing out, we might need to return the stateNode instead
      // of the child. To check it for work.
      // return bailoutOnAlreadyFinishedWork(current, workInProgress);
    }

    var nextChildren = nextCall.children;

    // The following is a fork of reconcileChildrenAtExpirationTime but using
    // stateNode to store the child.
    if (current === null) {
      workInProgress.stateNode = mountChildFibers(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);
    } else {
      workInProgress.stateNode = reconcileChildFibers(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);
    }

    memoizeProps(workInProgress, nextCall);
    // This doesn't take arbitrary time so we could synchronously just begin
    // eagerly do the work of workInProgress.child as an optimization.
    return workInProgress.stateNode;
  }

  function updatePortalComponent(current, workInProgress, renderExpirationTime) {
    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
    var nextChildren = workInProgress.pendingProps;
    if (hasContextChanged()) {
      // Normally we can bail out on props equality but if context has changed
      // we don't do the bailout and we have to reuse existing props instead.
      if (nextChildren === null) {
        nextChildren = current && current.memoizedProps;
        !(nextChildren != null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;
      }
    } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {
      return bailoutOnAlreadyFinishedWork(current, workInProgress);
    }

    if (current === null) {
      // Portals are special because we don't append the children during mount
      // but at commit. Therefore we need to track insertions which the normal
      // flow doesn't do during mount. This doesn't happen at the root because
      // the root always starts with a "current" with a null child.
      // TODO: Consider unifying this with how the root works.
      workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
      memoizeProps(workInProgress, nextChildren);
    } else {
      reconcileChildren(current, workInProgress, nextChildren);
      memoizeProps(workInProgress, nextChildren);
    }
    return workInProgress.child;
  }

  /*
  function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {
    let child = firstChild;
    do {
      // Ensure that the first and last effect of the parent corresponds
      // to the children's first and last effect.
      if (!returnFiber.firstEffect) {
        returnFiber.firstEffect = child.firstEffect;
      }
      if (child.lastEffect) {
        if (returnFiber.lastEffect) {
          returnFiber.lastEffect.nextEffect = child.firstEffect;
        }
        returnFiber.lastEffect = child.lastEffect;
      }
    } while (child = child.sibling);
  }
  */

  function bailoutOnAlreadyFinishedWork(current, workInProgress) {
    cancelWorkTimer(workInProgress);

    // TODO: We should ideally be able to bail out early if the children have no
    // more work to do. However, since we don't have a separation of this
    // Fiber's priority and its children yet - we don't know without doing lots
    // of the same work we do anyway. Once we have that separation we can just
    // bail out here if the children has no more work at this priority level.
    // if (workInProgress.priorityOfChildren <= priorityLevel) {
    //   // If there are side-effects in these children that have not yet been
    //   // committed we need to ensure that they get properly transferred up.
    //   if (current && current.child !== workInProgress.child) {
    //     reuseChildrenEffects(workInProgress, child);
    //   }
    //   return null;
    // }

    cloneChildFibers(current, workInProgress);
    return workInProgress.child;
  }

  function bailoutOnLowPriority(current, workInProgress) {
    cancelWorkTimer(workInProgress);

    // TODO: Handle HostComponent tags here as well and call pushHostContext()?
    // See PR 8590 discussion for context
    switch (workInProgress.tag) {
      case HostRoot:
        pushHostRootContext(workInProgress);
        break;
      case ClassComponent:
        pushContextProvider(workInProgress);
        break;
      case HostPortal:
        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
        break;
    }
    // TODO: What if this is currently in progress?
    // How can that happen? How is this not being cloned?
    return null;
  }

  // TODO: Delete memoizeProps/State and move to reconcile/bailout instead
  function memoizeProps(workInProgress, nextProps) {
    workInProgress.memoizedProps = nextProps;
  }

  function memoizeState(workInProgress, nextState) {
    workInProgress.memoizedState = nextState;
    // Don't reset the updateQueue, in case there are pending updates. Resetting
    // is handled by processUpdateQueue.
  }

  function beginWork(current, workInProgress, renderExpirationTime) {
    if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {
      return bailoutOnLowPriority(current, workInProgress);
    }

    switch (workInProgress.tag) {
      case IndeterminateComponent:
        return mountIndeterminateComponent(current, workInProgress, renderExpirationTime);
      case FunctionalComponent:
        return updateFunctionalComponent(current, workInProgress);
      case ClassComponent:
        return updateClassComponent(current, workInProgress, renderExpirationTime);
      case HostRoot:
        return updateHostRoot(current, workInProgress, renderExpirationTime);
      case HostComponent:
        return updateHostComponent(current, workInProgress, renderExpirationTime);
      case HostText:
        return updateHostText(current, workInProgress);
      case CallHandlerPhase:
        // This is a restart. Reset the tag to the initial phase.
        workInProgress.tag = CallComponent;
      // Intentionally fall through since this is now the same.
      case CallComponent:
        return updateCallComponent(current, workInProgress, renderExpirationTime);
      case ReturnComponent:
        // A return component is just a placeholder, we can just run through the
        // next one immediately.
        return null;
      case HostPortal:
        return updatePortalComponent(current, workInProgress, renderExpirationTime);
      case Fragment:
        return updateFragment(current, workInProgress);
      default:
        invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');
    }
  }

  function beginFailedWork(current, workInProgress, renderExpirationTime) {
    // Push context providers here to avoid a push/pop context mismatch.
    switch (workInProgress.tag) {
      case ClassComponent:
        pushContextProvider(workInProgress);
        break;
      case HostRoot:
        pushHostRootContext(workInProgress);
        break;
      default:
        invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');
    }

    // Add an error effect so we can handle the error during the commit phase
    workInProgress.effectTag |= Err;

    // This is a weird case where we do "resume" work  work that failed on
    // our first attempt. Because we no longer have a notion of "progressed
    // deletions," reset the child to the current child to make sure we delete
    // it again. TODO: Find a better way to handle this, perhaps during a more
    // general overhaul of error handling.
    if (current === null) {
      workInProgress.child = null;
    } else if (workInProgress.child !== current.child) {
      workInProgress.child = current.child;
    }

    if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {
      return bailoutOnLowPriority(current, workInProgress);
    }

    // If we don't bail out, we're going be recomputing our children so we need
    // to drop our effect list.
    workInProgress.firstEffect = null;
    workInProgress.lastEffect = null;

    // Unmount the current children as if the component rendered null
    var nextChildren = null;
    reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime);

    if (workInProgress.tag === ClassComponent) {
      var instance = workInProgress.stateNode;
      workInProgress.memoizedProps = instance.props;
      workInProgress.memoizedState = instance.state;
    }

    return workInProgress.child;
  }

  return {
    beginWork: beginWork,
    beginFailedWork: beginFailedWork
  };
};

var ReactFiberCompleteWork = function (config, hostContext, hydrationContext) {
  var createInstance = config.createInstance,
      createTextInstance = config.createTextInstance,
      appendInitialChild = config.appendInitialChild,
      finalizeInitialChildren = config.finalizeInitialChildren,
      prepareUpdate = config.prepareUpdate,
      mutation = config.mutation,
      persistence = config.persistence;
  var getRootHostContainer = hostContext.getRootHostContainer,
      popHostContext = hostContext.popHostContext,
      getHostContext = hostContext.getHostContext,
      popHostContainer = hostContext.popHostContainer;
  var prepareToHydrateHostInstance = hydrationContext.prepareToHydrateHostInstance,
      prepareToHydrateHostTextInstance = hydrationContext.prepareToHydrateHostTextInstance,
      popHydrationState = hydrationContext.popHydrationState;


  function markUpdate(workInProgress) {
    // Tag the fiber with an update effect. This turns a Placement into
    // an UpdateAndPlacement.
    workInProgress.effectTag |= Update;
  }

  function markRef(workInProgress) {
    workInProgress.effectTag |= Ref;
  }

  function appendAllReturns(returns, workInProgress) {
    var node = workInProgress.stateNode;
    if (node) {
      node['return'] = workInProgress;
    }
    while (node !== null) {
      if (node.tag === HostComponent || node.tag === HostText || node.tag === HostPortal) {
        invariant(false, 'A call cannot have host component children.');
      } else if (node.tag === ReturnComponent) {
        returns.push(node.type);
      } else if (node.child !== null) {
        node.child['return'] = node;
        node = node.child;
        continue;
      }
      while (node.sibling === null) {
        if (node['return'] === null || node['return'] === workInProgress) {
          return;
        }
        node = node['return'];
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
    }
  }

  function moveCallToHandlerPhase(current, workInProgress, renderExpirationTime) {
    var call = workInProgress.memoizedProps;
    !call ? invariant(false, 'Should be resolved by now. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    // First step of the call has completed. Now we need to do the second.
    // TODO: It would be nice to have a multi stage call represented by a
    // single component, or at least tail call optimize nested ones. Currently
    // that requires additional fields that we don't want to add to the fiber.
    // So this requires nested handlers.
    // Note: This doesn't mutate the alternate node. I don't think it needs to
    // since this stage is reset for every pass.
    workInProgress.tag = CallHandlerPhase;

    // Build up the returns.
    // TODO: Compare this to a generator or opaque helpers like Children.
    var returns = [];
    appendAllReturns(returns, workInProgress);
    var fn = call.handler;
    var props = call.props;
    var nextChildren = fn(props, returns);

    var currentFirstChild = current !== null ? current.child : null;
    workInProgress.child = reconcileChildFibers(workInProgress, currentFirstChild, nextChildren, renderExpirationTime);
    return workInProgress.child;
  }

  function appendAllChildren(parent, workInProgress) {
    // We only have the top Fiber that was created but we need recurse down its
    // children to find all the terminal nodes.
    var node = workInProgress.child;
    while (node !== null) {
      if (node.tag === HostComponent || node.tag === HostText) {
        appendInitialChild(parent, node.stateNode);
      } else if (node.tag === HostPortal) {
        // If we have a portal child, then we don't want to traverse
        // down its children. Instead, we'll get insertions from each child in
        // the portal directly.
      } else if (node.child !== null) {
        node.child['return'] = node;
        node = node.child;
        continue;
      }
      if (node === workInProgress) {
        return;
      }
      while (node.sibling === null) {
        if (node['return'] === null || node['return'] === workInProgress) {
          return;
        }
        node = node['return'];
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
    }
  }

  var updateHostContainer = void 0;
  var updateHostComponent = void 0;
  var updateHostText = void 0;
  if (mutation) {
    if (enableMutatingReconciler) {
      // Mutation mode
      updateHostContainer = function (workInProgress) {
        // Noop
      };
      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {
        // TODO: Type this specific to this type of component.
        workInProgress.updateQueue = updatePayload;
        // If the update payload indicates that there is a change or if there
        // is a new ref we mark this as an update. All the work is done in commitWork.
        if (updatePayload) {
          markUpdate(workInProgress);
        }
      };
      updateHostText = function (current, workInProgress, oldText, newText) {
        // If the text differs, mark it as an update. All the work in done in commitWork.
        if (oldText !== newText) {
          markUpdate(workInProgress);
        }
      };
    } else {
      invariant(false, 'Mutating reconciler is disabled.');
    }
  } else if (persistence) {
    if (enablePersistentReconciler) {
      // Persistent host tree mode
      var cloneInstance = persistence.cloneInstance,
          createContainerChildSet = persistence.createContainerChildSet,
          appendChildToContainerChildSet = persistence.appendChildToContainerChildSet,
          finalizeContainerChildren = persistence.finalizeContainerChildren;

      // An unfortunate fork of appendAllChildren because we have two different parent types.

      var appendAllChildrenToContainer = function (containerChildSet, workInProgress) {
        // We only have the top Fiber that was created but we need recurse down its
        // children to find all the terminal nodes.
        var node = workInProgress.child;
        while (node !== null) {
          if (node.tag === HostComponent || node.tag === HostText) {
            appendChildToContainerChildSet(containerChildSet, node.stateNode);
          } else if (node.tag === HostPortal) {
            // If we have a portal child, then we don't want to traverse
            // down its children. Instead, we'll get insertions from each child in
            // the portal directly.
          } else if (node.child !== null) {
            node.child['return'] = node;
            node = node.child;
            continue;
          }
          if (node === workInProgress) {
            return;
          }
          while (node.sibling === null) {
            if (node['return'] === null || node['return'] === workInProgress) {
              return;
            }
            node = node['return'];
          }
          node.sibling['return'] = node['return'];
          node = node.sibling;
        }
      };
      updateHostContainer = function (workInProgress) {
        var portalOrRoot = workInProgress.stateNode;
        var childrenUnchanged = workInProgress.firstEffect === null;
        if (childrenUnchanged) {
          // No changes, just reuse the existing instance.
        } else {
          var container = portalOrRoot.containerInfo;
          var newChildSet = createContainerChildSet(container);
          if (finalizeContainerChildren(container, newChildSet)) {
            markUpdate(workInProgress);
          }
          portalOrRoot.pendingChildren = newChildSet;
          // If children might have changed, we have to add them all to the set.
          appendAllChildrenToContainer(newChildSet, workInProgress);
          // Schedule an update on the container to swap out the container.
          markUpdate(workInProgress);
        }
      };
      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {
        // If there are no effects associated with this node, then none of our children had any updates.
        // This guarantees that we can reuse all of them.
        var childrenUnchanged = workInProgress.firstEffect === null;
        var currentInstance = current.stateNode;
        if (childrenUnchanged && updatePayload === null) {
          // No changes, just reuse the existing instance.
          // Note that this might release a previous clone.
          workInProgress.stateNode = currentInstance;
        } else {
          var recyclableInstance = workInProgress.stateNode;
          var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);
          if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance)) {
            markUpdate(workInProgress);
          }
          workInProgress.stateNode = newInstance;
          if (childrenUnchanged) {
            // If there are no other effects in this tree, we need to flag this node as having one.
            // Even though we're not going to use it for anything.
            // Otherwise parents won't know that there are new children to propagate upwards.
            markUpdate(workInProgress);
          } else {
            // If children might have changed, we have to add them all to the set.
            appendAllChildren(newInstance, workInProgress);
          }
        }
      };
      updateHostText = function (current, workInProgress, oldText, newText) {
        if (oldText !== newText) {
          // If the text content differs, we'll create a new text instance for it.
          var rootContainerInstance = getRootHostContainer();
          var currentHostContext = getHostContext();
          workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress);
          // We'll have to mark it as having an effect, even though we won't use the effect for anything.
          // This lets the parents know that at least one of their children has changed.
          markUpdate(workInProgress);
        }
      };
    } else {
      invariant(false, 'Persistent reconciler is disabled.');
    }
  } else {
    if (enableNoopReconciler) {
      // No host operations
      updateHostContainer = function (workInProgress) {
        // Noop
      };
      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {
        // Noop
      };
      updateHostText = function (current, workInProgress, oldText, newText) {
        // Noop
      };
    } else {
      invariant(false, 'Noop reconciler is disabled.');
    }
  }

  function completeWork(current, workInProgress, renderExpirationTime) {
    // Get the latest props.
    var newProps = workInProgress.pendingProps;
    if (newProps === null) {
      newProps = workInProgress.memoizedProps;
    } else if (workInProgress.expirationTime !== Never || renderExpirationTime === Never) {
      // Reset the pending props, unless this was a down-prioritization.
      workInProgress.pendingProps = null;
    }

    switch (workInProgress.tag) {
      case FunctionalComponent:
        return null;
      case ClassComponent:
        {
          // We are leaving this subtree, so pop context if any.
          popContextProvider(workInProgress);
          return null;
        }
      case HostRoot:
        {
          popHostContainer(workInProgress);
          popTopLevelContextObject(workInProgress);
          var fiberRoot = workInProgress.stateNode;
          if (fiberRoot.pendingContext) {
            fiberRoot.context = fiberRoot.pendingContext;
            fiberRoot.pendingContext = null;
          }

          if (current === null || current.child === null) {
            // If we hydrated, pop so that we can delete any remaining children
            // that weren't hydrated.
            popHydrationState(workInProgress);
            // This resets the hacky state to fix isMounted before committing.
            // TODO: Delete this when we delete isMounted and findDOMNode.
            workInProgress.effectTag &= ~Placement;
          }
          updateHostContainer(workInProgress);
          return null;
        }
      case HostComponent:
        {
          popHostContext(workInProgress);
          var rootContainerInstance = getRootHostContainer();
          var type = workInProgress.type;
          if (current !== null && workInProgress.stateNode != null) {
            // If we have an alternate, that means this is an update and we need to
            // schedule a side-effect to do the updates.
            var oldProps = current.memoizedProps;
            // If we get updated because one of our children updated, we don't
            // have newProps so we'll have to reuse them.
            // TODO: Split the update API as separate for the props vs. children.
            // Even better would be if children weren't special cased at all tho.
            var instance = workInProgress.stateNode;
            var currentHostContext = getHostContext();
            var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);

            updateHostComponent(current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance);

            if (current.ref !== workInProgress.ref) {
              markRef(workInProgress);
            }
          } else {
            if (!newProps) {
              !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;
              // This can happen when we abort work.
              return null;
            }

            var _currentHostContext = getHostContext();
            // TODO: Move createInstance to beginWork and keep it on a context
            // "stack" as the parent. Then append children as we go in beginWork
            // or completeWork depending on we want to add then top->down or
            // bottom->up. Top->down is faster in IE11.
            var wasHydrated = popHydrationState(workInProgress);
            if (wasHydrated) {
              // TODO: Move this and createInstance step into the beginPhase
              // to consolidate.
              if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, _currentHostContext)) {
                // If changes to the hydrated node needs to be applied at the
                // commit-phase we mark this as such.
                markUpdate(workInProgress);
              }
            } else {
              var _instance = createInstance(type, newProps, rootContainerInstance, _currentHostContext, workInProgress);

              appendAllChildren(_instance, workInProgress);

              // Certain renderers require commit-time effects for initial mount.
              // (eg DOM renderer supports auto-focus for certain elements).
              // Make sure such renderers get scheduled for later work.
              if (finalizeInitialChildren(_instance, type, newProps, rootContainerInstance)) {
                markUpdate(workInProgress);
              }
              workInProgress.stateNode = _instance;
            }

            if (workInProgress.ref !== null) {
              // If there is a ref on a host node we need to schedule a callback
              markRef(workInProgress);
            }
          }
          return null;
        }
      case HostText:
        {
          var newText = newProps;
          if (current && workInProgress.stateNode != null) {
            var oldText = current.memoizedProps;
            // If we have an alternate, that means this is an update and we need
            // to schedule a side-effect to do the updates.
            updateHostText(current, workInProgress, oldText, newText);
          } else {
            if (typeof newText !== 'string') {
              !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;
              // This can happen when we abort work.
              return null;
            }
            var _rootContainerInstance = getRootHostContainer();
            var _currentHostContext2 = getHostContext();
            var _wasHydrated = popHydrationState(workInProgress);
            if (_wasHydrated) {
              if (prepareToHydrateHostTextInstance(workInProgress)) {
                markUpdate(workInProgress);
              }
            } else {
              workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext2, workInProgress);
            }
          }
          return null;
        }
      case CallComponent:
        return moveCallToHandlerPhase(current, workInProgress, renderExpirationTime);
      case CallHandlerPhase:
        // Reset the tag to now be a first phase call.
        workInProgress.tag = CallComponent;
        return null;
      case ReturnComponent:
        // Does nothing.
        return null;
      case Fragment:
        return null;
      case HostPortal:
        popHostContainer(workInProgress);
        updateHostContainer(workInProgress);
        return null;
      // Error cases
      case IndeterminateComponent:
        invariant(false, 'An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue.');
      // eslint-disable-next-line no-fallthrough
      default:
        invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');
    }
  }

  return {
    completeWork: completeWork
  };
};

var invokeGuardedCallback$2 = ReactErrorUtils.invokeGuardedCallback;
var hasCaughtError$1 = ReactErrorUtils.hasCaughtError;
var clearCaughtError$1 = ReactErrorUtils.clearCaughtError;


var ReactFiberCommitWork = function (config, captureError) {
  var getPublicInstance = config.getPublicInstance,
      mutation = config.mutation,
      persistence = config.persistence;


  var callComponentWillUnmountWithTimer = function (current, instance) {
    startPhaseTimer(current, 'componentWillUnmount');
    instance.props = current.memoizedProps;
    instance.state = current.memoizedState;
    instance.componentWillUnmount();
    stopPhaseTimer();
  };

  // Capture errors so they don't interrupt unmounting.
  function safelyCallComponentWillUnmount(current, instance) {
    {
      invokeGuardedCallback$2(null, callComponentWillUnmountWithTimer, null, current, instance);
      if (hasCaughtError$1()) {
        var unmountError = clearCaughtError$1();
        captureError(current, unmountError);
      }
    }
  }

  function safelyDetachRef(current) {
    var ref = current.ref;
    if (ref !== null) {
      {
        invokeGuardedCallback$2(null, ref, null, null);
        if (hasCaughtError$1()) {
          var refError = clearCaughtError$1();
          captureError(current, refError);
        }
      }
    }
  }

  function commitLifeCycles(current, finishedWork) {
    switch (finishedWork.tag) {
      case ClassComponent:
        {
          var instance = finishedWork.stateNode;
          if (finishedWork.effectTag & Update) {
            if (current === null) {
              startPhaseTimer(finishedWork, 'componentDidMount');
              instance.props = finishedWork.memoizedProps;
              instance.state = finishedWork.memoizedState;
              instance.componentDidMount();
              stopPhaseTimer();
            } else {
              var prevProps = current.memoizedProps;
              var prevState = current.memoizedState;
              startPhaseTimer(finishedWork, 'componentDidUpdate');
              instance.props = finishedWork.memoizedProps;
              instance.state = finishedWork.memoizedState;
              instance.componentDidUpdate(prevProps, prevState);
              stopPhaseTimer();
            }
          }
          var updateQueue = finishedWork.updateQueue;
          if (updateQueue !== null) {
            commitCallbacks(updateQueue, instance);
          }
          return;
        }
      case HostRoot:
        {
          var _updateQueue = finishedWork.updateQueue;
          if (_updateQueue !== null) {
            var _instance = finishedWork.child !== null ? finishedWork.child.stateNode : null;
            commitCallbacks(_updateQueue, _instance);
          }
          return;
        }
      case HostComponent:
        {
          var _instance2 = finishedWork.stateNode;

          // Renderers may schedule work to be done after host components are mounted
          // (eg DOM renderer may schedule auto-focus for inputs and form controls).
          // These effects should only be committed when components are first mounted,
          // aka when there is no current/alternate.
          if (current === null && finishedWork.effectTag & Update) {
            var type = finishedWork.type;
            var props = finishedWork.memoizedProps;
            commitMount(_instance2, type, props, finishedWork);
          }

          return;
        }
      case HostText:
        {
          // We have no life-cycles associated with text.
          return;
        }
      case HostPortal:
        {
          // We have no life-cycles associated with portals.
          return;
        }
      default:
        {
          invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');
        }
    }
  }

  function commitAttachRef(finishedWork) {
    var ref = finishedWork.ref;
    if (ref !== null) {
      var instance = finishedWork.stateNode;
      switch (finishedWork.tag) {
        case HostComponent:
          ref(getPublicInstance(instance));
          break;
        default:
          ref(instance);
      }
    }
  }

  function commitDetachRef(current) {
    var currentRef = current.ref;
    if (currentRef !== null) {
      currentRef(null);
    }
  }

  // User-originating errors (lifecycles and refs) should not interrupt
  // deletion, so don't let them throw. Host-originating errors should
  // interrupt deletion, so it's okay
  function commitUnmount(current) {
    if (typeof onCommitUnmount === 'function') {
      onCommitUnmount(current);
    }

    switch (current.tag) {
      case ClassComponent:
        {
          safelyDetachRef(current);
          var instance = current.stateNode;
          if (typeof instance.componentWillUnmount === 'function') {
            safelyCallComponentWillUnmount(current, instance);
          }
          return;
        }
      case HostComponent:
        {
          safelyDetachRef(current);
          return;
        }
      case CallComponent:
        {
          commitNestedUnmounts(current.stateNode);
          return;
        }
      case HostPortal:
        {
          // TODO: this is recursive.
          // We are also not using this parent because
          // the portal will get pushed immediately.
          if (enableMutatingReconciler && mutation) {
            unmountHostComponents(current);
          } else if (enablePersistentReconciler && persistence) {
            emptyPortalContainer(current);
          }
          return;
        }
    }
  }

  function commitNestedUnmounts(root) {
    // While we're inside a removed host node we don't want to call
    // removeChild on the inner nodes because they're removed by the top
    // call anyway. We also want to call componentWillUnmount on all
    // composites before this host node is removed from the tree. Therefore
    var node = root;
    while (true) {
      commitUnmount(node);
      // Visit children because they may contain more composite or host nodes.
      // Skip portals because commitUnmount() currently visits them recursively.
      if (node.child !== null && (
      // If we use mutation we drill down into portals using commitUnmount above.
      // If we don't use mutation we drill down into portals here instead.
      !mutation || node.tag !== HostPortal)) {
        node.child['return'] = node;
        node = node.child;
        continue;
      }
      if (node === root) {
        return;
      }
      while (node.sibling === null) {
        if (node['return'] === null || node['return'] === root) {
          return;
        }
        node = node['return'];
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
    }
  }

  function detachFiber(current) {
    // Cut off the return pointers to disconnect it from the tree. Ideally, we
    // should clear the child pointer of the parent alternate to let this
    // get GC:ed but we don't know which for sure which parent is the current
    // one so we'll settle for GC:ing the subtree of this child. This child
    // itself will be GC:ed when the parent updates the next time.
    current['return'] = null;
    current.child = null;
    if (current.alternate) {
      current.alternate.child = null;
      current.alternate['return'] = null;
    }
  }

  if (!mutation) {
    var commitContainer = void 0;
    if (persistence) {
      var replaceContainerChildren = persistence.replaceContainerChildren,
          createContainerChildSet = persistence.createContainerChildSet;

      var emptyPortalContainer = function (current) {
        var portal = current.stateNode;
        var containerInfo = portal.containerInfo;

        var emptyChildSet = createContainerChildSet(containerInfo);
        replaceContainerChildren(containerInfo, emptyChildSet);
      };
      commitContainer = function (finishedWork) {
        switch (finishedWork.tag) {
          case ClassComponent:
            {
              return;
            }
          case HostComponent:
            {
              return;
            }
          case HostText:
            {
              return;
            }
          case HostRoot:
          case HostPortal:
            {
              var portalOrRoot = finishedWork.stateNode;
              var containerInfo = portalOrRoot.containerInfo,
                  _pendingChildren = portalOrRoot.pendingChildren;

              replaceContainerChildren(containerInfo, _pendingChildren);
              return;
            }
          default:
            {
              invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');
            }
        }
      };
    } else {
      commitContainer = function (finishedWork) {
        // Noop
      };
    }
    if (enablePersistentReconciler || enableNoopReconciler) {
      return {
        commitResetTextContent: function (finishedWork) {},
        commitPlacement: function (finishedWork) {},
        commitDeletion: function (current) {
          // Detach refs and call componentWillUnmount() on the whole subtree.
          commitNestedUnmounts(current);
          detachFiber(current);
        },
        commitWork: function (current, finishedWork) {
          commitContainer(finishedWork);
        },

        commitLifeCycles: commitLifeCycles,
        commitAttachRef: commitAttachRef,
        commitDetachRef: commitDetachRef
      };
    } else if (persistence) {
      invariant(false, 'Persistent reconciler is disabled.');
    } else {
      invariant(false, 'Noop reconciler is disabled.');
    }
  }
  var commitMount = mutation.commitMount,
      commitUpdate = mutation.commitUpdate,
      resetTextContent = mutation.resetTextContent,
      commitTextUpdate = mutation.commitTextUpdate,
      appendChild = mutation.appendChild,
      appendChildToContainer = mutation.appendChildToContainer,
      insertBefore = mutation.insertBefore,
      insertInContainerBefore = mutation.insertInContainerBefore,
      removeChild = mutation.removeChild,
      removeChildFromContainer = mutation.removeChildFromContainer;


  function getHostParentFiber(fiber) {
    var parent = fiber['return'];
    while (parent !== null) {
      if (isHostParent(parent)) {
        return parent;
      }
      parent = parent['return'];
    }
    invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.');
  }

  function isHostParent(fiber) {
    return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
  }

  function getHostSibling(fiber) {
    // We're going to search forward into the tree until we find a sibling host
    // node. Unfortunately, if multiple insertions are done in a row we have to
    // search past them. This leads to exponential search for the next sibling.
    var node = fiber;
    siblings: while (true) {
      // If we didn't find anything, let's try the next sibling.
      while (node.sibling === null) {
        if (node['return'] === null || isHostParent(node['return'])) {
          // If we pop out of the root or hit the parent the fiber we are the
          // last sibling.
          return null;
        }
        node = node['return'];
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
      while (node.tag !== HostComponent && node.tag !== HostText) {
        // If it is not host node and, we might have a host node inside it.
        // Try to search down until we find one.
        if (node.effectTag & Placement) {
          // If we don't have a child, try the siblings instead.
          continue siblings;
        }
        // If we don't have a child, try the siblings instead.
        // We also skip portals because they are not part of this host tree.
        if (node.child === null || node.tag === HostPortal) {
          continue siblings;
        } else {
          node.child['return'] = node;
          node = node.child;
        }
      }
      // Check if this host node is stable or about to be placed.
      if (!(node.effectTag & Placement)) {
        // Found it!
        return node.stateNode;
      }
    }
  }

  function commitPlacement(finishedWork) {
    // Recursively insert all host nodes into the parent.
    var parentFiber = getHostParentFiber(finishedWork);
    var parent = void 0;
    var isContainer = void 0;
    switch (parentFiber.tag) {
      case HostComponent:
        parent = parentFiber.stateNode;
        isContainer = false;
        break;
      case HostRoot:
        parent = parentFiber.stateNode.containerInfo;
        isContainer = true;
        break;
      case HostPortal:
        parent = parentFiber.stateNode.containerInfo;
        isContainer = true;
        break;
      default:
        invariant(false, 'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.');
    }
    if (parentFiber.effectTag & ContentReset) {
      // Reset the text content of the parent before doing any insertions
      resetTextContent(parent);
      // Clear ContentReset from the effect tag
      parentFiber.effectTag &= ~ContentReset;
    }

    var before = getHostSibling(finishedWork);
    // We only have the top Fiber that was inserted but we need recurse down its
    // children to find all the terminal nodes.
    var node = finishedWork;
    while (true) {
      if (node.tag === HostComponent || node.tag === HostText) {
        if (before) {
          if (isContainer) {
            insertInContainerBefore(parent, node.stateNode, before);
          } else {
            insertBefore(parent, node.stateNode, before);
          }
        } else {
          if (isContainer) {
            appendChildToContainer(parent, node.stateNode);
          } else {
            appendChild(parent, node.stateNode);
          }
        }
      } else if (node.tag === HostPortal) {
        // If the insertion itself is a portal, then we don't want to traverse
        // down its children. Instead, we'll get insertions from each child in
        // the portal directly.
      } else if (node.child !== null) {
        node.child['return'] = node;
        node = node.child;
        continue;
      }
      if (node === finishedWork) {
        return;
      }
      while (node.sibling === null) {
        if (node['return'] === null || node['return'] === finishedWork) {
          return;
        }
        node = node['return'];
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
    }
  }

  function unmountHostComponents(current) {
    // We only have the top Fiber that was inserted but we need recurse down its
    var node = current;

    // Each iteration, currentParent is populated with node's host parent if not
    // currentParentIsValid.
    var currentParentIsValid = false;
    var currentParent = void 0;
    var currentParentIsContainer = void 0;

    while (true) {
      if (!currentParentIsValid) {
        var parent = node['return'];
        findParent: while (true) {
          !(parent !== null) ? invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;
          switch (parent.tag) {
            case HostComponent:
              currentParent = parent.stateNode;
              currentParentIsContainer = false;
              break findParent;
            case HostRoot:
              currentParent = parent.stateNode.containerInfo;
              currentParentIsContainer = true;
              break findParent;
            case HostPortal:
              currentParent = parent.stateNode.containerInfo;
              currentParentIsContainer = true;
              break findParent;
          }
          parent = parent['return'];
        }
        currentParentIsValid = true;
      }

      if (node.tag === HostComponent || node.tag === HostText) {
        commitNestedUnmounts(node);
        // After all the children have unmounted, it is now safe to remove the
        // node from the tree.
        if (currentParentIsContainer) {
          removeChildFromContainer(currentParent, node.stateNode);
        } else {
          removeChild(currentParent, node.stateNode);
        }
        // Don't visit children because we already visited them.
      } else if (node.tag === HostPortal) {
        // When we go into a portal, it becomes the parent to remove from.
        // We will reassign it back when we pop the portal on the way up.
        currentParent = node.stateNode.containerInfo;
        // Visit children because portals might contain host components.
        if (node.child !== null) {
          node.child['return'] = node;
          node = node.child;
          continue;
        }
      } else {
        commitUnmount(node);
        // Visit children because we may find more host components below.
        if (node.child !== null) {
          node.child['return'] = node;
          node = node.child;
          continue;
        }
      }
      if (node === current) {
        return;
      }
      while (node.sibling === null) {
        if (node['return'] === null || node['return'] === current) {
          return;
        }
        node = node['return'];
        if (node.tag === HostPortal) {
          // When we go out of the portal, we need to restore the parent.
          // Since we don't keep a stack of them, we will search for it.
          currentParentIsValid = false;
        }
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
    }
  }

  function commitDeletion(current) {
    // Recursively delete all host nodes from the parent.
    // Detach refs and call componentWillUnmount() on the whole subtree.
    unmountHostComponents(current);
    detachFiber(current);
  }

  function commitWork(current, finishedWork) {
    switch (finishedWork.tag) {
      case ClassComponent:
        {
          return;
        }
      case HostComponent:
        {
          var instance = finishedWork.stateNode;
          if (instance != null) {
            // Commit the work prepared earlier.
            var newProps = finishedWork.memoizedProps;
            // For hydration we reuse the update path but we treat the oldProps
            // as the newProps. The updatePayload will contain the real change in
            // this case.
            var oldProps = current !== null ? current.memoizedProps : newProps;
            var type = finishedWork.type;
            // TODO: Type the updateQueue to be specific to host components.
            var updatePayload = finishedWork.updateQueue;
            finishedWork.updateQueue = null;
            if (updatePayload !== null) {
              commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);
            }
          }
          return;
        }
      case HostText:
        {
          !(finishedWork.stateNode !== null) ? invariant(false, 'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.') : void 0;
          var textInstance = finishedWork.stateNode;
          var newText = finishedWork.memoizedProps;
          // For hydration we reuse the update path but we treat the oldProps
          // as the newProps. The updatePayload will contain the real change in
          // this case.
          var oldText = current !== null ? current.memoizedProps : newText;
          commitTextUpdate(textInstance, oldText, newText);
          return;
        }
      case HostRoot:
        {
          return;
        }
      default:
        {
          invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');
        }
    }
  }

  function commitResetTextContent(current) {
    resetTextContent(current.stateNode);
  }

  if (enableMutatingReconciler) {
    return {
      commitResetTextContent: commitResetTextContent,
      commitPlacement: commitPlacement,
      commitDeletion: commitDeletion,
      commitWork: commitWork,
      commitLifeCycles: commitLifeCycles,
      commitAttachRef: commitAttachRef,
      commitDetachRef: commitDetachRef
    };
  } else {
    invariant(false, 'Mutating reconciler is disabled.');
  }
};

var NO_CONTEXT = {};

var ReactFiberHostContext = function (config) {
  var getChildHostContext = config.getChildHostContext,
      getRootHostContext = config.getRootHostContext;


  var contextStackCursor = createCursor(NO_CONTEXT);
  var contextFiberStackCursor = createCursor(NO_CONTEXT);
  var rootInstanceStackCursor = createCursor(NO_CONTEXT);

  function requiredContext(c) {
    !(c !== NO_CONTEXT) ? invariant(false, 'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    return c;
  }

  function getRootHostContainer() {
    var rootInstance = requiredContext(rootInstanceStackCursor.current);
    return rootInstance;
  }

  function pushHostContainer(fiber, nextRootInstance) {
    // Push current root instance onto the stack;
    // This allows us to reset root when portals are popped.
    push(rootInstanceStackCursor, nextRootInstance, fiber);

    var nextRootContext = getRootHostContext(nextRootInstance);

    // Track the context and the Fiber that provided it.
    // This enables us to pop only Fibers that provide unique contexts.
    push(contextFiberStackCursor, fiber, fiber);
    push(contextStackCursor, nextRootContext, fiber);
  }

  function popHostContainer(fiber) {
    pop(contextStackCursor, fiber);
    pop(contextFiberStackCursor, fiber);
    pop(rootInstanceStackCursor, fiber);
  }

  function getHostContext() {
    var context = requiredContext(contextStackCursor.current);
    return context;
  }

  function pushHostContext(fiber) {
    var rootInstance = requiredContext(rootInstanceStackCursor.current);
    var context = requiredContext(contextStackCursor.current);
    var nextContext = getChildHostContext(context, fiber.type, rootInstance);

    // Don't push this Fiber's context unless it's unique.
    if (context === nextContext) {
      return;
    }

    // Track the context and the Fiber that provided it.
    // This enables us to pop only Fibers that provide unique contexts.
    push(contextFiberStackCursor, fiber, fiber);
    push(contextStackCursor, nextContext, fiber);
  }

  function popHostContext(fiber) {
    // Do not pop unless this Fiber provided the current context.
    // pushHostContext() only pushes Fibers that provide unique contexts.
    if (contextFiberStackCursor.current !== fiber) {
      return;
    }

    pop(contextStackCursor, fiber);
    pop(contextFiberStackCursor, fiber);
  }

  function resetHostContainer() {
    contextStackCursor.current = NO_CONTEXT;
    rootInstanceStackCursor.current = NO_CONTEXT;
  }

  return {
    getHostContext: getHostContext,
    getRootHostContainer: getRootHostContainer,
    popHostContainer: popHostContainer,
    popHostContext: popHostContext,
    pushHostContainer: pushHostContainer,
    pushHostContext: pushHostContext,
    resetHostContainer: resetHostContainer
  };
};

var ReactFiberHydrationContext = function (config) {
  var shouldSetTextContent = config.shouldSetTextContent,
      hydration = config.hydration;

  // If this doesn't have hydration mode.

  if (!hydration) {
    return {
      enterHydrationState: function () {
        return false;
      },
      resetHydrationState: function () {},
      tryToClaimNextHydratableInstance: function () {},
      prepareToHydrateHostInstance: function () {
        invariant(false, 'Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');
      },
      prepareToHydrateHostTextInstance: function () {
        invariant(false, 'Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');
      },
      popHydrationState: function (fiber) {
        return false;
      }
    };
  }

  var canHydrateInstance = hydration.canHydrateInstance,
      canHydrateTextInstance = hydration.canHydrateTextInstance,
      getNextHydratableSibling = hydration.getNextHydratableSibling,
      getFirstHydratableChild = hydration.getFirstHydratableChild,
      hydrateInstance = hydration.hydrateInstance,
      hydrateTextInstance = hydration.hydrateTextInstance,
      didNotMatchHydratedContainerTextInstance = hydration.didNotMatchHydratedContainerTextInstance,
      didNotMatchHydratedTextInstance = hydration.didNotMatchHydratedTextInstance,
      didNotHydrateContainerInstance = hydration.didNotHydrateContainerInstance,
      didNotHydrateInstance = hydration.didNotHydrateInstance,
      didNotFindHydratableContainerInstance = hydration.didNotFindHydratableContainerInstance,
      didNotFindHydratableContainerTextInstance = hydration.didNotFindHydratableContainerTextInstance,
      didNotFindHydratableInstance = hydration.didNotFindHydratableInstance,
      didNotFindHydratableTextInstance = hydration.didNotFindHydratableTextInstance;

  // The deepest Fiber on the stack involved in a hydration context.
  // This may have been an insertion or a hydration.

  var hydrationParentFiber = null;
  var nextHydratableInstance = null;
  var isHydrating = false;

  function enterHydrationState(fiber) {
    var parentInstance = fiber.stateNode.containerInfo;
    nextHydratableInstance = getFirstHydratableChild(parentInstance);
    hydrationParentFiber = fiber;
    isHydrating = true;
    return true;
  }

  function deleteHydratableInstance(returnFiber, instance) {
    {
      switch (returnFiber.tag) {
        case HostRoot:
          didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);
          break;
        case HostComponent:
          didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);
          break;
      }
    }

    var childToDelete = createFiberFromHostInstanceForDeletion();
    childToDelete.stateNode = instance;
    childToDelete['return'] = returnFiber;
    childToDelete.effectTag = Deletion;

    // This might seem like it belongs on progressedFirstDeletion. However,
    // these children are not part of the reconciliation list of children.
    // Even if we abort and rereconcile the children, that will try to hydrate
    // again and the nodes are still in the host tree so these will be
    // recreated.
    if (returnFiber.lastEffect !== null) {
      returnFiber.lastEffect.nextEffect = childToDelete;
      returnFiber.lastEffect = childToDelete;
    } else {
      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
    }
  }

  function insertNonHydratedInstance(returnFiber, fiber) {
    fiber.effectTag |= Placement;
    {
      switch (returnFiber.tag) {
        case HostRoot:
          {
            var parentContainer = returnFiber.stateNode.containerInfo;
            switch (fiber.tag) {
              case HostComponent:
                var type = fiber.type;
                var props = fiber.pendingProps;
                didNotFindHydratableContainerInstance(parentContainer, type, props);
                break;
              case HostText:
                var text = fiber.pendingProps;
                didNotFindHydratableContainerTextInstance(parentContainer, text);
                break;
            }
            break;
          }
        case HostComponent:
          {
            var parentType = returnFiber.type;
            var parentProps = returnFiber.memoizedProps;
            var parentInstance = returnFiber.stateNode;
            switch (fiber.tag) {
              case HostComponent:
                var _type = fiber.type;
                var _props = fiber.pendingProps;
                didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);
                break;
              case HostText:
                var _text = fiber.pendingProps;
                didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);
                break;
            }
            break;
          }
        default:
          return;
      }
    }
  }

  function tryHydrate(fiber, nextInstance) {
    switch (fiber.tag) {
      case HostComponent:
        {
          var type = fiber.type;
          var props = fiber.pendingProps;
          var instance = canHydrateInstance(nextInstance, type, props);
          if (instance !== null) {
            fiber.stateNode = instance;
            return true;
          }
          return false;
        }
      case HostText:
        {
          var text = fiber.pendingProps;
          var textInstance = canHydrateTextInstance(nextInstance, text);
          if (textInstance !== null) {
            fiber.stateNode = textInstance;
            return true;
          }
          return false;
        }
      default:
        return false;
    }
  }

  function tryToClaimNextHydratableInstance(fiber) {
    if (!isHydrating) {
      return;
    }
    var nextInstance = nextHydratableInstance;
    if (!nextInstance) {
      // Nothing to hydrate. Make it an insertion.
      insertNonHydratedInstance(hydrationParentFiber, fiber);
      isHydrating = false;
      hydrationParentFiber = fiber;
      return;
    }
    if (!tryHydrate(fiber, nextInstance)) {
      // If we can't hydrate this instance let's try the next one.
      // We use this as a heuristic. It's based on intuition and not data so it
      // might be flawed or unnecessary.
      nextInstance = getNextHydratableSibling(nextInstance);
      if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
        // Nothing to hydrate. Make it an insertion.
        insertNonHydratedInstance(hydrationParentFiber, fiber);
        isHydrating = false;
        hydrationParentFiber = fiber;
        return;
      }
      // We matched the next one, we'll now assume that the first one was
      // superfluous and we'll delete it. Since we can't eagerly delete it
      // we'll have to schedule a deletion. To do that, this node needs a dummy
      // fiber associated with it.
      deleteHydratableInstance(hydrationParentFiber, nextHydratableInstance);
    }
    hydrationParentFiber = fiber;
    nextHydratableInstance = getFirstHydratableChild(nextInstance);
  }

  function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
    var instance = fiber.stateNode;
    var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber);
    // TODO: Type this specific to this type of component.
    fiber.updateQueue = updatePayload;
    // If the update payload indicates that there is a change or if there
    // is a new ref we mark this as an update.
    if (updatePayload !== null) {
      return true;
    }
    return false;
  }

  function prepareToHydrateHostTextInstance(fiber) {
    var textInstance = fiber.stateNode;
    var textContent = fiber.memoizedProps;
    var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
    {
      if (shouldUpdate) {
        // We assume that prepareToHydrateHostTextInstance is called in a context where the
        // hydration parent is the parent host component of this host text.
        var returnFiber = hydrationParentFiber;
        if (returnFiber !== null) {
          switch (returnFiber.tag) {
            case HostRoot:
              {
                var parentContainer = returnFiber.stateNode.containerInfo;
                didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);
                break;
              }
            case HostComponent:
              {
                var parentType = returnFiber.type;
                var parentProps = returnFiber.memoizedProps;
                var parentInstance = returnFiber.stateNode;
                didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);
                break;
              }
          }
        }
      }
    }
    return shouldUpdate;
  }

  function popToNextHostParent(fiber) {
    var parent = fiber['return'];
    while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot) {
      parent = parent['return'];
    }
    hydrationParentFiber = parent;
  }

  function popHydrationState(fiber) {
    if (fiber !== hydrationParentFiber) {
      // We're deeper than the current hydration context, inside an inserted
      // tree.
      return false;
    }
    if (!isHydrating) {
      // If we're not currently hydrating but we're in a hydration context, then
      // we were an insertion and now need to pop up reenter hydration of our
      // siblings.
      popToNextHostParent(fiber);
      isHydrating = true;
      return false;
    }

    var type = fiber.type;

    // If we have any remaining hydratable nodes, we need to delete them now.
    // We only do this deeper than head and body since they tend to have random
    // other nodes in them. We also ignore components with pure text content in
    // side of them.
    // TODO: Better heuristic.
    if (fiber.tag !== HostComponent || type !== 'head' && type !== 'body' && !shouldSetTextContent(type, fiber.memoizedProps)) {
      var nextInstance = nextHydratableInstance;
      while (nextInstance) {
        deleteHydratableInstance(fiber, nextInstance);
        nextInstance = getNextHydratableSibling(nextInstance);
      }
    }

    popToNextHostParent(fiber);
    nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
    return true;
  }

  function resetHydrationState() {
    hydrationParentFiber = null;
    nextHydratableInstance = null;
    isHydrating = false;
  }

  return {
    enterHydrationState: enterHydrationState,
    resetHydrationState: resetHydrationState,
    tryToClaimNextHydratableInstance: tryToClaimNextHydratableInstance,
    prepareToHydrateHostInstance: prepareToHydrateHostInstance,
    prepareToHydrateHostTextInstance: prepareToHydrateHostTextInstance,
    popHydrationState: popHydrationState
  };
};

// This lets us hook into Fiber to debug what it's doing.
// See https://github.com/facebook/react/pull/8033.
// This is not part of the public API, not even for React DevTools.
// You may only inject a debugTool if you work on React Fiber itself.
var ReactFiberInstrumentation = {
  debugTool: null
};

var ReactFiberInstrumentation_1 = ReactFiberInstrumentation;

var defaultShowDialog = function (capturedError) {
  return true;
};

var showDialog = defaultShowDialog;

function logCapturedError(capturedError) {
  var logError = showDialog(capturedError);

  // Allow injected showDialog() to prevent default console.error logging.
  // This enables renderers like ReactNative to better manage redbox behavior.
  if (logError === false) {
    return;
  }

  var error = capturedError.error;
  var suppressLogging = error && error.suppressReactErrorLogging;
  if (suppressLogging) {
    return;
  }

  {
    var componentName = capturedError.componentName,
        componentStack = capturedError.componentStack,
        errorBoundaryName = capturedError.errorBoundaryName,
        errorBoundaryFound = capturedError.errorBoundaryFound,
        willRetry = capturedError.willRetry;


    var componentNameMessage = componentName ? 'The above error occurred in the <' + componentName + '> component:' : 'The above error occurred in one of your React components:';

    var errorBoundaryMessage = void 0;
    // errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.
    if (errorBoundaryFound && errorBoundaryName) {
      if (willRetry) {
        errorBoundaryMessage = 'React will try to recreate this component tree from scratch ' + ('using the error boundary you provided, ' + errorBoundaryName + '.');
      } else {
        errorBoundaryMessage = 'This error was initially handled by the error boundary ' + errorBoundaryName + '.\n' + 'Recreating the tree from scratch failed so React will unmount the tree.';
      }
    } else {
      errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\n' + 'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.';
    }
    var combinedMessage = '' + componentNameMessage + componentStack + '\n\n' + ('' + errorBoundaryMessage);

    // In development, we provide our own message with just the component stack.
    // We don't include the original error message and JS stack because the browser
    // has already printed it. Even if the application swallows the error, it is still
    // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.
    console.error(combinedMessage);
  }
}

var invokeGuardedCallback$1 = ReactErrorUtils.invokeGuardedCallback;
var hasCaughtError = ReactErrorUtils.hasCaughtError;
var clearCaughtError = ReactErrorUtils.clearCaughtError;


{
  var didWarnAboutStateTransition = false;
  var didWarnSetStateChildContext = false;
  var didWarnStateUpdateForUnmountedComponent = {};

  var warnAboutUpdateOnUnmounted = function (fiber) {
    var componentName = getComponentName(fiber) || 'ReactClass';
    if (didWarnStateUpdateForUnmountedComponent[componentName]) {
      return;
    }
    warning(false, 'Can only update a mounted or mounting ' + 'component. This usually means you called setState, replaceState, ' + 'or forceUpdate on an unmounted component. This is a no-op.\n\nPlease ' + 'check the code for the %s component.', componentName);
    didWarnStateUpdateForUnmountedComponent[componentName] = true;
  };

  var warnAboutInvalidUpdates = function (instance) {
    switch (ReactDebugCurrentFiber.phase) {
      case 'getChildContext':
        if (didWarnSetStateChildContext) {
          return;
        }
        warning(false, 'setState(...): Cannot call setState() inside getChildContext()');
        didWarnSetStateChildContext = true;
        break;
      case 'render':
        if (didWarnAboutStateTransition) {
          return;
        }
        warning(false, 'Cannot update during an existing state transition (such as within ' + "`render` or another component's constructor). Render methods should " + 'be a pure function of props and state; constructor side-effects are ' + 'an anti-pattern, but can be moved to `componentWillMount`.');
        didWarnAboutStateTransition = true;
        break;
    }
  };
}

var ReactFiberScheduler = function (config) {
  var hostContext = ReactFiberHostContext(config);
  var hydrationContext = ReactFiberHydrationContext(config);
  var popHostContainer = hostContext.popHostContainer,
      popHostContext = hostContext.popHostContext,
      resetHostContainer = hostContext.resetHostContainer;

  var _ReactFiberBeginWork = ReactFiberBeginWork(config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber),
      beginWork = _ReactFiberBeginWork.beginWork,
      beginFailedWork = _ReactFiberBeginWork.beginFailedWork;

  var _ReactFiberCompleteWo = ReactFiberCompleteWork(config, hostContext, hydrationContext),
      completeWork = _ReactFiberCompleteWo.completeWork;

  var _ReactFiberCommitWork = ReactFiberCommitWork(config, captureError),
      commitResetTextContent = _ReactFiberCommitWork.commitResetTextContent,
      commitPlacement = _ReactFiberCommitWork.commitPlacement,
      commitDeletion = _ReactFiberCommitWork.commitDeletion,
      commitWork = _ReactFiberCommitWork.commitWork,
      commitLifeCycles = _ReactFiberCommitWork.commitLifeCycles,
      commitAttachRef = _ReactFiberCommitWork.commitAttachRef,
      commitDetachRef = _ReactFiberCommitWork.commitDetachRef;

  var now = config.now,
      scheduleDeferredCallback = config.scheduleDeferredCallback,
      cancelDeferredCallback = config.cancelDeferredCallback,
      useSyncScheduling = config.useSyncScheduling,
      prepareForCommit = config.prepareForCommit,
      resetAfterCommit = config.resetAfterCommit;

  // Represents the current time in ms.

  var startTime = now();
  var mostRecentCurrentTime = msToExpirationTime(0);

  // Represents the expiration time that incoming updates should use. (If this
  // is NoWork, use the default strategy: async updates in async mode, sync
  // updates in sync mode.)
  var expirationContext = NoWork;

  var isWorking = false;

  // The next work in progress fiber that we're currently working on.
  var nextUnitOfWork = null;
  var nextRoot = null;
  // The time at which we're currently rendering work.
  var nextRenderExpirationTime = NoWork;

  // The next fiber with an effect that we're currently committing.
  var nextEffect = null;

  // Keep track of which fibers have captured an error that need to be handled.
  // Work is removed from this collection after componentDidCatch is called.
  var capturedErrors = null;
  // Keep track of which fibers have failed during the current batch of work.
  // This is a different set than capturedErrors, because it is not reset until
  // the end of the batch. This is needed to propagate errors correctly if a
  // subtree fails more than once.
  var failedBoundaries = null;
  // Error boundaries that captured an error during the current commit.
  var commitPhaseBoundaries = null;
  var firstUncaughtError = null;
  var didFatal = false;

  var isCommitting = false;
  var isUnmounting = false;

  // Used for performance tracking.
  var interruptedBy = null;

  function resetContextStack() {
    // Reset the stack
    reset$1();
    // Reset the cursors
    resetContext();
    resetHostContainer();
  }

  function commitAllHostEffects() {
    while (nextEffect !== null) {
      {
        ReactDebugCurrentFiber.setCurrentFiber(nextEffect);
      }
      recordEffect();

      var effectTag = nextEffect.effectTag;
      if (effectTag & ContentReset) {
        commitResetTextContent(nextEffect);
      }

      if (effectTag & Ref) {
        var current = nextEffect.alternate;
        if (current !== null) {
          commitDetachRef(current);
        }
      }

      // The following switch statement is only concerned about placement,
      // updates, and deletions. To avoid needing to add a case for every
      // possible bitmap value, we remove the secondary effects from the
      // effect tag and switch on that value.
      var primaryEffectTag = effectTag & ~(Callback | Err | ContentReset | Ref | PerformedWork);
      switch (primaryEffectTag) {
        case Placement:
          {
            commitPlacement(nextEffect);
            // Clear the "placement" from effect tag so that we know that this is inserted, before
            // any life-cycles like componentDidMount gets called.
            // TODO: findDOMNode doesn't rely on this any more but isMounted
            // does and isMounted is deprecated anyway so we should be able
            // to kill this.
            nextEffect.effectTag &= ~Placement;
            break;
          }
        case PlacementAndUpdate:
          {
            // Placement
            commitPlacement(nextEffect);
            // Clear the "placement" from effect tag so that we know that this is inserted, before
            // any life-cycles like componentDidMount gets called.
            nextEffect.effectTag &= ~Placement;

            // Update
            var _current = nextEffect.alternate;
            commitWork(_current, nextEffect);
            break;
          }
        case Update:
          {
            var _current2 = nextEffect.alternate;
            commitWork(_current2, nextEffect);
            break;
          }
        case Deletion:
          {
            isUnmounting = true;
            commitDeletion(nextEffect);
            isUnmounting = false;
            break;
          }
      }
      nextEffect = nextEffect.nextEffect;
    }

    {
      ReactDebugCurrentFiber.resetCurrentFiber();
    }
  }

  function commitAllLifeCycles() {
    while (nextEffect !== null) {
      var effectTag = nextEffect.effectTag;

      if (effectTag & (Update | Callback)) {
        recordEffect();
        var current = nextEffect.alternate;
        commitLifeCycles(current, nextEffect);
      }

      if (effectTag & Ref) {
        recordEffect();
        commitAttachRef(nextEffect);
      }

      if (effectTag & Err) {
        recordEffect();
        commitErrorHandling(nextEffect);
      }

      var next = nextEffect.nextEffect;
      // Ensure that we clean these up so that we don't accidentally keep them.
      // I'm not actually sure this matters because we can't reset firstEffect
      // and lastEffect since they're on every node, not just the effectful
      // ones. So we have to clean everything as we reuse nodes anyway.
      nextEffect.nextEffect = null;
      // Ensure that we reset the effectTag here so that we can rely on effect
      // tags to reason about the current life-cycle.
      nextEffect = next;
    }
  }

  function commitRoot(finishedWork) {
    // We keep track of this so that captureError can collect any boundaries
    // that capture an error during the commit phase. The reason these aren't
    // local to this function is because errors that occur during cWU are
    // captured elsewhere, to prevent the unmount from being interrupted.
    isWorking = true;
    isCommitting = true;
    startCommitTimer();

    var root = finishedWork.stateNode;
    !(root.current !== finishedWork) ? invariant(false, 'Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    root.isReadyForCommit = false;

    // Reset this to null before calling lifecycles
    ReactCurrentOwner.current = null;

    var firstEffect = void 0;
    if (finishedWork.effectTag > PerformedWork) {
      // A fiber's effect list consists only of its children, not itself. So if
      // the root has an effect, we need to add it to the end of the list. The
      // resulting list is the set that would belong to the root's parent, if
      // it had one; that is, all the effects in the tree including the root.
      if (finishedWork.lastEffect !== null) {
        finishedWork.lastEffect.nextEffect = finishedWork;
        firstEffect = finishedWork.firstEffect;
      } else {
        firstEffect = finishedWork;
      }
    } else {
      // There is no effect on the root.
      firstEffect = finishedWork.firstEffect;
    }

    prepareForCommit();

    // Commit all the side-effects within a tree. We'll do this in two passes.
    // The first pass performs all the host insertions, updates, deletions and
    // ref unmounts.
    nextEffect = firstEffect;
    startCommitHostEffectsTimer();
    while (nextEffect !== null) {
      var didError = false;
      var _error = void 0;
      {
        invokeGuardedCallback$1(null, commitAllHostEffects, null);
        if (hasCaughtError()) {
          didError = true;
          _error = clearCaughtError();
        }
      }
      if (didError) {
        !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;
        captureError(nextEffect, _error);
        // Clean-up
        if (nextEffect !== null) {
          nextEffect = nextEffect.nextEffect;
        }
      }
    }
    stopCommitHostEffectsTimer();

    resetAfterCommit();

    // The work-in-progress tree is now the current tree. This must come after
    // the first pass of the commit phase, so that the previous tree is still
    // current during componentWillUnmount, but before the second pass, so that
    // the finished work is current during componentDidMount/Update.
    root.current = finishedWork;

    // In the second pass we'll perform all life-cycles and ref callbacks.
    // Life-cycles happen as a separate pass so that all placements, updates,
    // and deletions in the entire tree have already been invoked.
    // This pass also triggers any renderer-specific initial effects.
    nextEffect = firstEffect;
    startCommitLifeCyclesTimer();
    while (nextEffect !== null) {
      var _didError = false;
      var _error2 = void 0;
      {
        invokeGuardedCallback$1(null, commitAllLifeCycles, null);
        if (hasCaughtError()) {
          _didError = true;
          _error2 = clearCaughtError();
        }
      }
      if (_didError) {
        !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;
        captureError(nextEffect, _error2);
        if (nextEffect !== null) {
          nextEffect = nextEffect.nextEffect;
        }
      }
    }

    isCommitting = false;
    isWorking = false;
    stopCommitLifeCyclesTimer();
    stopCommitTimer();
    if (typeof onCommitRoot === 'function') {
      onCommitRoot(finishedWork.stateNode);
    }
    if (true && ReactFiberInstrumentation_1.debugTool) {
      ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);
    }

    // If we caught any errors during this commit, schedule their boundaries
    // to update.
    if (commitPhaseBoundaries) {
      commitPhaseBoundaries.forEach(scheduleErrorRecovery);
      commitPhaseBoundaries = null;
    }

    if (firstUncaughtError !== null) {
      var _error3 = firstUncaughtError;
      firstUncaughtError = null;
      onUncaughtError(_error3);
    }

    var remainingTime = root.current.expirationTime;

    if (remainingTime === NoWork) {
      capturedErrors = null;
      failedBoundaries = null;
    }

    return remainingTime;
  }

  function resetExpirationTime(workInProgress, renderTime) {
    if (renderTime !== Never && workInProgress.expirationTime === Never) {
      // The children of this component are hidden. Don't bubble their
      // expiration times.
      return;
    }

    // Check for pending updates.
    var newExpirationTime = getUpdateExpirationTime(workInProgress);

    // TODO: Calls need to visit stateNode

    // Bubble up the earliest expiration time.
    var child = workInProgress.child;
    while (child !== null) {
      if (child.expirationTime !== NoWork && (newExpirationTime === NoWork || newExpirationTime > child.expirationTime)) {
        newExpirationTime = child.expirationTime;
      }
      child = child.sibling;
    }
    workInProgress.expirationTime = newExpirationTime;
  }

  function completeUnitOfWork(workInProgress) {
    while (true) {
      // The current, flushed, state of this fiber is the alternate.
      // Ideally nothing should rely on this, but relying on it here
      // means that we don't need an additional field on the work in
      // progress.
      var current = workInProgress.alternate;
      {
        ReactDebugCurrentFiber.setCurrentFiber(workInProgress);
      }
      var next = completeWork(current, workInProgress, nextRenderExpirationTime);
      {
        ReactDebugCurrentFiber.resetCurrentFiber();
      }

      var returnFiber = workInProgress['return'];
      var siblingFiber = workInProgress.sibling;

      resetExpirationTime(workInProgress, nextRenderExpirationTime);

      if (next !== null) {
        stopWorkTimer(workInProgress);
        if (true && ReactFiberInstrumentation_1.debugTool) {
          ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
        }
        // If completing this work spawned new work, do that next. We'll come
        // back here again.
        return next;
      }

      if (returnFiber !== null) {
        // Append all the effects of the subtree and this fiber onto the effect
        // list of the parent. The completion order of the children affects the
        // side-effect order.
        if (returnFiber.firstEffect === null) {
          returnFiber.firstEffect = workInProgress.firstEffect;
        }
        if (workInProgress.lastEffect !== null) {
          if (returnFiber.lastEffect !== null) {
            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;
          }
          returnFiber.lastEffect = workInProgress.lastEffect;
        }

        // If this fiber had side-effects, we append it AFTER the children's
        // side-effects. We can perform certain side-effects earlier if
        // needed, by doing multiple passes over the effect list. We don't want
        // to schedule our own side-effect on our own list because if end up
        // reusing children we'll schedule this effect onto itself since we're
        // at the end.
        var effectTag = workInProgress.effectTag;
        // Skip both NoWork and PerformedWork tags when creating the effect list.
        // PerformedWork effect is read by React DevTools but shouldn't be committed.
        if (effectTag > PerformedWork) {
          if (returnFiber.lastEffect !== null) {
            returnFiber.lastEffect.nextEffect = workInProgress;
          } else {
            returnFiber.firstEffect = workInProgress;
          }
          returnFiber.lastEffect = workInProgress;
        }
      }

      stopWorkTimer(workInProgress);
      if (true && ReactFiberInstrumentation_1.debugTool) {
        ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
      }

      if (siblingFiber !== null) {
        // If there is more work to do in this returnFiber, do that next.
        return siblingFiber;
      } else if (returnFiber !== null) {
        // If there's no more work in this returnFiber. Complete the returnFiber.
        workInProgress = returnFiber;
        continue;
      } else {
        // We've reached the root.
        var root = workInProgress.stateNode;
        root.isReadyForCommit = true;
        return null;
      }
    }

    // Without this explicit null return Flow complains of invalid return type
    // TODO Remove the above while(true) loop
    // eslint-disable-next-line no-unreachable
    return null;
  }

  function performUnitOfWork(workInProgress) {
    // The current, flushed, state of this fiber is the alternate.
    // Ideally nothing should rely on this, but relying on it here
    // means that we don't need an additional field on the work in
    // progress.
    var current = workInProgress.alternate;

    // See if beginning this work spawns more work.
    startWorkTimer(workInProgress);
    {
      ReactDebugCurrentFiber.setCurrentFiber(workInProgress);
    }

    var next = beginWork(current, workInProgress, nextRenderExpirationTime);
    {
      ReactDebugCurrentFiber.resetCurrentFiber();
    }
    if (true && ReactFiberInstrumentation_1.debugTool) {
      ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);
    }

    if (next === null) {
      // If this doesn't spawn new work, complete the current work.
      next = completeUnitOfWork(workInProgress);
    }

    ReactCurrentOwner.current = null;

    return next;
  }

  function performFailedUnitOfWork(workInProgress) {
    // The current, flushed, state of this fiber is the alternate.
    // Ideally nothing should rely on this, but relying on it here
    // means that we don't need an additional field on the work in
    // progress.
    var current = workInProgress.alternate;

    // See if beginning this work spawns more work.
    startWorkTimer(workInProgress);
    {
      ReactDebugCurrentFiber.setCurrentFiber(workInProgress);
    }
    var next = beginFailedWork(current, workInProgress, nextRenderExpirationTime);
    {
      ReactDebugCurrentFiber.resetCurrentFiber();
    }
    if (true && ReactFiberInstrumentation_1.debugTool) {
      ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);
    }

    if (next === null) {
      // If this doesn't spawn new work, complete the current work.
      next = completeUnitOfWork(workInProgress);
    }

    ReactCurrentOwner.current = null;

    return next;
  }

  function workLoop(expirationTime) {
    if (capturedErrors !== null) {
      // If there are unhandled errors, switch to the slow work loop.
      // TODO: How to avoid this check in the fast path? Maybe the renderer
      // could keep track of which roots have unhandled errors and call a
      // forked version of renderRoot.
      slowWorkLoopThatChecksForFailedWork(expirationTime);
      return;
    }
    if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {
      return;
    }

    if (nextRenderExpirationTime <= mostRecentCurrentTime) {
      // Flush all expired work.
      while (nextUnitOfWork !== null) {
        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
      }
    } else {
      // Flush asynchronous work until the deadline runs out of time.
      while (nextUnitOfWork !== null && !shouldYield()) {
        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
      }
    }
  }

  function slowWorkLoopThatChecksForFailedWork(expirationTime) {
    if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {
      return;
    }

    if (nextRenderExpirationTime <= mostRecentCurrentTime) {
      // Flush all expired work.
      while (nextUnitOfWork !== null) {
        if (hasCapturedError(nextUnitOfWork)) {
          // Use a forked version of performUnitOfWork
          nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);
        } else {
          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
        }
      }
    } else {
      // Flush asynchronous work until the deadline runs out of time.
      while (nextUnitOfWork !== null && !shouldYield()) {
        if (hasCapturedError(nextUnitOfWork)) {
          // Use a forked version of performUnitOfWork
          nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);
        } else {
          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
        }
      }
    }
  }

  function renderRootCatchBlock(root, failedWork, boundary, expirationTime) {
    // We're going to restart the error boundary that captured the error.
    // Conceptually, we're unwinding the stack. We need to unwind the
    // context stack, too.
    unwindContexts(failedWork, boundary);

    // Restart the error boundary using a forked version of
    // performUnitOfWork that deletes the boundary's children. The entire
    // failed subree will be unmounted. During the commit phase, a special
    // lifecycle method is called on the error boundary, which triggers
    // a re-render.
    nextUnitOfWork = performFailedUnitOfWork(boundary);

    // Continue working.
    workLoop(expirationTime);
  }

  function renderRoot(root, expirationTime) {
    !!isWorking ? invariant(false, 'renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    isWorking = true;

    // We're about to mutate the work-in-progress tree. If the root was pending
    // commit, it no longer is: we'll need to complete it again.
    root.isReadyForCommit = false;

    // Check if we're starting from a fresh stack, or if we're resuming from
    // previously yielded work.
    if (root !== nextRoot || expirationTime !== nextRenderExpirationTime || nextUnitOfWork === null) {
      // Reset the stack and start working from the root.
      resetContextStack();
      nextRoot = root;
      nextRenderExpirationTime = expirationTime;
      nextUnitOfWork = createWorkInProgress(nextRoot.current, null, expirationTime);
    }

    startWorkLoopTimer(nextUnitOfWork);

    var didError = false;
    var error = null;
    {
      invokeGuardedCallback$1(null, workLoop, null, expirationTime);
      if (hasCaughtError()) {
        didError = true;
        error = clearCaughtError();
      }
    }

    // An error was thrown during the render phase.
    while (didError) {
      if (didFatal) {
        // This was a fatal error. Don't attempt to recover from it.
        firstUncaughtError = error;
        break;
      }

      var failedWork = nextUnitOfWork;
      if (failedWork === null) {
        // An error was thrown but there's no current unit of work. This can
        // happen during the commit phase if there's a bug in the renderer.
        didFatal = true;
        continue;
      }

      // "Capture" the error by finding the nearest boundary. If there is no
      // error boundary, we use the root.
      var boundary = captureError(failedWork, error);
      !(boundary !== null) ? invariant(false, 'Should have found an error boundary. This error is likely caused by a bug in React. Please file an issue.') : void 0;

      if (didFatal) {
        // The error we just captured was a fatal error. This happens
        // when the error propagates to the root more than once.
        continue;
      }

      didError = false;
      error = null;
      {
        invokeGuardedCallback$1(null, renderRootCatchBlock, null, root, failedWork, boundary, expirationTime);
        if (hasCaughtError()) {
          didError = true;
          error = clearCaughtError();
          continue;
        }
      }
      // We're finished working. Exit the error loop.
      break;
    }

    var uncaughtError = firstUncaughtError;

    // We're done performing work. Time to clean up.
    stopWorkLoopTimer(interruptedBy);
    interruptedBy = null;
    isWorking = false;
    didFatal = false;
    firstUncaughtError = null;

    if (uncaughtError !== null) {
      onUncaughtError(uncaughtError);
    }

    return root.isReadyForCommit ? root.current.alternate : null;
  }

  // Returns the boundary that captured the error, or null if the error is ignored
  function captureError(failedWork, error) {
    // It is no longer valid because we exited the user code.
    ReactCurrentOwner.current = null;
    {
      ReactDebugCurrentFiber.resetCurrentFiber();
    }

    // Search for the nearest error boundary.
    var boundary = null;

    // Passed to logCapturedError()
    var errorBoundaryFound = false;
    var willRetry = false;
    var errorBoundaryName = null;

    // Host containers are a special case. If the failed work itself is a host
    // container, then it acts as its own boundary. In all other cases, we
    // ignore the work itself and only search through the parents.
    if (failedWork.tag === HostRoot) {
      boundary = failedWork;

      if (isFailedBoundary(failedWork)) {
        // If this root already failed, there must have been an error when
        // attempting to unmount it. This is a worst-case scenario and
        // should only be possible if there's a bug in the renderer.
        didFatal = true;
      }
    } else {
      var node = failedWork['return'];
      while (node !== null && boundary === null) {
        if (node.tag === ClassComponent) {
          var instance = node.stateNode;
          if (typeof instance.componentDidCatch === 'function') {
            errorBoundaryFound = true;
            errorBoundaryName = getComponentName(node);

            // Found an error boundary!
            boundary = node;
            willRetry = true;
          }
        } else if (node.tag === HostRoot) {
          // Treat the root like a no-op error boundary
          boundary = node;
        }

        if (isFailedBoundary(node)) {
          // This boundary is already in a failed state.

          // If we're currently unmounting, that means this error was
          // thrown while unmounting a failed subtree. We should ignore
          // the error.
          if (isUnmounting) {
            return null;
          }

          // If we're in the commit phase, we should check to see if
          // this boundary already captured an error during this commit.
          // This case exists because multiple errors can be thrown during
          // a single commit without interruption.
          if (commitPhaseBoundaries !== null && (commitPhaseBoundaries.has(node) || node.alternate !== null && commitPhaseBoundaries.has(node.alternate))) {
            // If so, we should ignore this error.
            return null;
          }

          // The error should propagate to the next boundary - we keep looking.
          boundary = null;
          willRetry = false;
        }

        node = node['return'];
      }
    }

    if (boundary !== null) {
      // Add to the collection of failed boundaries. This lets us know that
      // subsequent errors in this subtree should propagate to the next boundary.
      if (failedBoundaries === null) {
        failedBoundaries = new Set();
      }
      failedBoundaries.add(boundary);

      // This method is unsafe outside of the begin and complete phases.
      // We might be in the commit phase when an error is captured.
      // The risk is that the return path from this Fiber may not be accurate.
      // That risk is acceptable given the benefit of providing users more context.
      var _componentStack = getStackAddendumByWorkInProgressFiber(failedWork);
      var _componentName = getComponentName(failedWork);

      // Add to the collection of captured errors. This is stored as a global
      // map of errors and their component stack location keyed by the boundaries
      // that capture them. We mostly use this Map as a Set; it's a Map only to
      // avoid adding a field to Fiber to store the error.
      if (capturedErrors === null) {
        capturedErrors = new Map();
      }

      var capturedError = {
        componentName: _componentName,
        componentStack: _componentStack,
        error: error,
        errorBoundary: errorBoundaryFound ? boundary.stateNode : null,
        errorBoundaryFound: errorBoundaryFound,
        errorBoundaryName: errorBoundaryName,
        willRetry: willRetry
      };

      capturedErrors.set(boundary, capturedError);

      try {
        logCapturedError(capturedError);
      } catch (e) {
        // Prevent cycle if logCapturedError() throws.
        // A cycle may still occur if logCapturedError renders a component that throws.
        var suppressLogging = e && e.suppressReactErrorLogging;
        if (!suppressLogging) {
          console.error(e);
        }
      }

      // If we're in the commit phase, defer scheduling an update on the
      // boundary until after the commit is complete
      if (isCommitting) {
        if (commitPhaseBoundaries === null) {
          commitPhaseBoundaries = new Set();
        }
        commitPhaseBoundaries.add(boundary);
      } else {
        // Otherwise, schedule an update now.
        // TODO: Is this actually necessary during the render phase? Is it
        // possible to unwind and continue rendering at the same priority,
        // without corrupting internal state?
        scheduleErrorRecovery(boundary);
      }
      return boundary;
    } else if (firstUncaughtError === null) {
      // If no boundary is found, we'll need to throw the error
      firstUncaughtError = error;
    }
    return null;
  }

  function hasCapturedError(fiber) {
    // TODO: capturedErrors should store the boundary instance, to avoid needing
    // to check the alternate.
    return capturedErrors !== null && (capturedErrors.has(fiber) || fiber.alternate !== null && capturedErrors.has(fiber.alternate));
  }

  function isFailedBoundary(fiber) {
    // TODO: failedBoundaries should store the boundary instance, to avoid
    // needing to check the alternate.
    return failedBoundaries !== null && (failedBoundaries.has(fiber) || fiber.alternate !== null && failedBoundaries.has(fiber.alternate));
  }

  function commitErrorHandling(effectfulFiber) {
    var capturedError = void 0;
    if (capturedErrors !== null) {
      capturedError = capturedErrors.get(effectfulFiber);
      capturedErrors['delete'](effectfulFiber);
      if (capturedError == null) {
        if (effectfulFiber.alternate !== null) {
          effectfulFiber = effectfulFiber.alternate;
          capturedError = capturedErrors.get(effectfulFiber);
          capturedErrors['delete'](effectfulFiber);
        }
      }
    }

    !(capturedError != null) ? invariant(false, 'No error for given unit of work. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    switch (effectfulFiber.tag) {
      case ClassComponent:
        var instance = effectfulFiber.stateNode;

        var info = {
          componentStack: capturedError.componentStack
        };

        // Allow the boundary to handle the error, usually by scheduling
        // an update to itself
        instance.componentDidCatch(capturedError.error, info);
        return;
      case HostRoot:
        if (firstUncaughtError === null) {
          firstUncaughtError = capturedError.error;
        }
        return;
      default:
        invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');
    }
  }

  function unwindContexts(from, to) {
    var node = from;
    while (node !== null) {
      switch (node.tag) {
        case ClassComponent:
          popContextProvider(node);
          break;
        case HostComponent:
          popHostContext(node);
          break;
        case HostRoot:
          popHostContainer(node);
          break;
        case HostPortal:
          popHostContainer(node);
          break;
      }
      if (node === to || node.alternate === to) {
        stopFailedWorkTimer(node);
        break;
      } else {
        stopWorkTimer(node);
      }
      node = node['return'];
    }
  }

  function computeAsyncExpiration() {
    // Given the current clock time, returns an expiration time. We use rounding
    // to batch like updates together.
    // Should complete within ~1000ms. 1200ms max.
    var currentTime = recalculateCurrentTime();
    var expirationMs = 1000;
    var bucketSizeMs = 200;
    return computeExpirationBucket(currentTime, expirationMs, bucketSizeMs);
  }

  function computeExpirationForFiber(fiber) {
    var expirationTime = void 0;
    if (expirationContext !== NoWork) {
      // An explicit expiration context was set;
      expirationTime = expirationContext;
    } else if (isWorking) {
      if (isCommitting) {
        // Updates that occur during the commit phase should have sync priority
        // by default.
        expirationTime = Sync;
      } else {
        // Updates during the render phase should expire at the same time as
        // the work that is being rendered.
        expirationTime = nextRenderExpirationTime;
      }
    } else {
      // No explicit expiration context was set, and we're not currently
      // performing work. Calculate a new expiration time.
      if (useSyncScheduling && !(fiber.internalContextTag & AsyncUpdates)) {
        // This is a sync update
        expirationTime = Sync;
      } else {
        // This is an async update
        expirationTime = computeAsyncExpiration();
      }
    }
    return expirationTime;
  }

  function scheduleWork(fiber, expirationTime) {
    return scheduleWorkImpl(fiber, expirationTime, false);
  }

  function checkRootNeedsClearing(root, fiber, expirationTime) {
    if (!isWorking && root === nextRoot && expirationTime < nextRenderExpirationTime) {
      // Restart the root from the top.
      if (nextUnitOfWork !== null) {
        // This is an interruption. (Used for performance tracking.)
        interruptedBy = fiber;
      }
      nextRoot = null;
      nextUnitOfWork = null;
      nextRenderExpirationTime = NoWork;
    }
  }

  function scheduleWorkImpl(fiber, expirationTime, isErrorRecovery) {
    recordScheduleUpdate();

    {
      if (!isErrorRecovery && fiber.tag === ClassComponent) {
        var instance = fiber.stateNode;
        warnAboutInvalidUpdates(instance);
      }
    }

    var node = fiber;
    while (node !== null) {
      // Walk the parent path to the root and update each node's
      // expiration time.
      if (node.expirationTime === NoWork || node.expirationTime > expirationTime) {
        node.expirationTime = expirationTime;
      }
      if (node.alternate !== null) {
        if (node.alternate.expirationTime === NoWork || node.alternate.expirationTime > expirationTime) {
          node.alternate.expirationTime = expirationTime;
        }
      }
      if (node['return'] === null) {
        if (node.tag === HostRoot) {
          var root = node.stateNode;

          checkRootNeedsClearing(root, fiber, expirationTime);
          requestWork(root, expirationTime);
          checkRootNeedsClearing(root, fiber, expirationTime);
        } else {
          {
            if (!isErrorRecovery && fiber.tag === ClassComponent) {
              warnAboutUpdateOnUnmounted(fiber);
            }
          }
          return;
        }
      }
      node = node['return'];
    }
  }

  function scheduleErrorRecovery(fiber) {
    scheduleWorkImpl(fiber, Sync, true);
  }

  function recalculateCurrentTime() {
    // Subtract initial time so it fits inside 32bits
    var ms = now() - startTime;
    mostRecentCurrentTime = msToExpirationTime(ms);
    return mostRecentCurrentTime;
  }

  function deferredUpdates(fn) {
    var previousExpirationContext = expirationContext;
    expirationContext = computeAsyncExpiration();
    try {
      return fn();
    } finally {
      expirationContext = previousExpirationContext;
    }
  }

  function syncUpdates(fn) {
    var previousExpirationContext = expirationContext;
    expirationContext = Sync;
    try {
      return fn();
    } finally {
      expirationContext = previousExpirationContext;
    }
  }

  // TODO: Everything below this is written as if it has been lifted to the
  // renderers. I'll do this in a follow-up.

  // Linked-list of roots
  var firstScheduledRoot = null;
  var lastScheduledRoot = null;

  var callbackExpirationTime = NoWork;
  var callbackID = -1;
  var isRendering = false;
  var nextFlushedRoot = null;
  var nextFlushedExpirationTime = NoWork;
  var deadlineDidExpire = false;
  var hasUnhandledError = false;
  var unhandledError = null;
  var deadline = null;

  var isBatchingUpdates = false;
  var isUnbatchingUpdates = false;

  // Use these to prevent an infinite loop of nested updates
  var NESTED_UPDATE_LIMIT = 1000;
  var nestedUpdateCount = 0;

  var timeHeuristicForUnitOfWork = 1;

  function scheduleCallbackWithExpiration(expirationTime) {
    if (callbackExpirationTime !== NoWork) {
      // A callback is already scheduled. Check its expiration time (timeout).
      if (expirationTime > callbackExpirationTime) {
        // Existing callback has sufficient timeout. Exit.
        return;
      } else {
        // Existing callback has insufficient timeout. Cancel and schedule a
        // new one.
        cancelDeferredCallback(callbackID);
      }
      // The request callback timer is already running. Don't start a new one.
    } else {
      startRequestCallbackTimer();
    }

    // Compute a timeout for the given expiration time.
    var currentMs = now() - startTime;
    var expirationMs = expirationTimeToMs(expirationTime);
    var timeout = expirationMs - currentMs;

    callbackExpirationTime = expirationTime;
    callbackID = scheduleDeferredCallback(performAsyncWork, { timeout: timeout });
  }

  // requestWork is called by the scheduler whenever a root receives an update.
  // It's up to the renderer to call renderRoot at some point in the future.
  function requestWork(root, expirationTime) {
    if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
      invariant(false, 'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');
    }

    // Add the root to the schedule.
    // Check if this root is already part of the schedule.
    if (root.nextScheduledRoot === null) {
      // This root is not already scheduled. Add it.
      root.remainingExpirationTime = expirationTime;
      if (lastScheduledRoot === null) {
        firstScheduledRoot = lastScheduledRoot = root;
        root.nextScheduledRoot = root;
      } else {
        lastScheduledRoot.nextScheduledRoot = root;
        lastScheduledRoot = root;
        lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
      }
    } else {
      // This root is already scheduled, but its priority may have increased.
      var remainingExpirationTime = root.remainingExpirationTime;
      if (remainingExpirationTime === NoWork || expirationTime < remainingExpirationTime) {
        // Update the priority.
        root.remainingExpirationTime = expirationTime;
      }
    }

    if (isRendering) {
      // Prevent reentrancy. Remaining work will be scheduled at the end of
      // the currently rendering batch.
      return;
    }

    if (isBatchingUpdates) {
      // Flush work at the end of the batch.
      if (isUnbatchingUpdates) {
        // ...unless we're inside unbatchedUpdates, in which case we should
        // flush it now.
        nextFlushedRoot = root;
        nextFlushedExpirationTime = Sync;
        performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime);
      }
      return;
    }

    // TODO: Get rid of Sync and use current time?
    if (expirationTime === Sync) {
      performWork(Sync, null);
    } else {
      scheduleCallbackWithExpiration(expirationTime);
    }
  }

  function findHighestPriorityRoot() {
    var highestPriorityWork = NoWork;
    var highestPriorityRoot = null;

    if (lastScheduledRoot !== null) {
      var previousScheduledRoot = lastScheduledRoot;
      var root = firstScheduledRoot;
      while (root !== null) {
        var remainingExpirationTime = root.remainingExpirationTime;
        if (remainingExpirationTime === NoWork) {
          // This root no longer has work. Remove it from the scheduler.

          // TODO: This check is redudant, but Flow is confused by the branch
          // below where we set lastScheduledRoot to null, even though we break
          // from the loop right after.
          !(previousScheduledRoot !== null && lastScheduledRoot !== null) ? invariant(false, 'Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.') : void 0;
          if (root === root.nextScheduledRoot) {
            // This is the only root in the list.
            root.nextScheduledRoot = null;
            firstScheduledRoot = lastScheduledRoot = null;
            break;
          } else if (root === firstScheduledRoot) {
            // This is the first root in the list.
            var next = root.nextScheduledRoot;
            firstScheduledRoot = next;
            lastScheduledRoot.nextScheduledRoot = next;
            root.nextScheduledRoot = null;
          } else if (root === lastScheduledRoot) {
            // This is the last root in the list.
            lastScheduledRoot = previousScheduledRoot;
            lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
            root.nextScheduledRoot = null;
            break;
          } else {
            previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;
            root.nextScheduledRoot = null;
          }
          root = previousScheduledRoot.nextScheduledRoot;
        } else {
          if (highestPriorityWork === NoWork || remainingExpirationTime < highestPriorityWork) {
            // Update the priority, if it's higher
            highestPriorityWork = remainingExpirationTime;
            highestPriorityRoot = root;
          }
          if (root === lastScheduledRoot) {
            break;
          }
          previousScheduledRoot = root;
          root = root.nextScheduledRoot;
        }
      }
    }

    // If the next root is the same as the previous root, this is a nested
    // update. To prevent an infinite loop, increment the nested update count.
    var previousFlushedRoot = nextFlushedRoot;
    if (previousFlushedRoot !== null && previousFlushedRoot === highestPriorityRoot) {
      nestedUpdateCount++;
    } else {
      // Reset whenever we switch roots.
      nestedUpdateCount = 0;
    }
    nextFlushedRoot = highestPriorityRoot;
    nextFlushedExpirationTime = highestPriorityWork;
  }

  function performAsyncWork(dl) {
    performWork(NoWork, dl);
  }

  function performWork(minExpirationTime, dl) {
    deadline = dl;

    // Keep working on roots until there's no more work, or until the we reach
    // the deadline.
    findHighestPriorityRoot();

    if (enableUserTimingAPI && deadline !== null) {
      var didExpire = nextFlushedExpirationTime < recalculateCurrentTime();
      stopRequestCallbackTimer(didExpire);
    }

    while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && (minExpirationTime === NoWork || nextFlushedExpirationTime <= minExpirationTime) && !deadlineDidExpire) {
      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime);
      // Find the next highest priority work.
      findHighestPriorityRoot();
    }

    // We're done flushing work. Either we ran out of time in this callback,
    // or there's no more work left with sufficient priority.

    // If we're inside a callback, set this to false since we just completed it.
    if (deadline !== null) {
      callbackExpirationTime = NoWork;
      callbackID = -1;
    }
    // If there's work left over, schedule a new callback.
    if (nextFlushedExpirationTime !== NoWork) {
      scheduleCallbackWithExpiration(nextFlushedExpirationTime);
    }

    // Clean-up.
    deadline = null;
    deadlineDidExpire = false;
    nestedUpdateCount = 0;

    if (hasUnhandledError) {
      var _error4 = unhandledError;
      unhandledError = null;
      hasUnhandledError = false;
      throw _error4;
    }
  }

  function performWorkOnRoot(root, expirationTime) {
    !!isRendering ? invariant(false, 'performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    isRendering = true;

    // Check if this is async work or sync/expired work.
    // TODO: Pass current time as argument to renderRoot, commitRoot
    if (expirationTime <= recalculateCurrentTime()) {
      // Flush sync work.
      var finishedWork = root.finishedWork;
      if (finishedWork !== null) {
        // This root is already complete. We can commit it.
        root.finishedWork = null;
        root.remainingExpirationTime = commitRoot(finishedWork);
      } else {
        root.finishedWork = null;
        finishedWork = renderRoot(root, expirationTime);
        if (finishedWork !== null) {
          // We've completed the root. Commit it.
          root.remainingExpirationTime = commitRoot(finishedWork);
        }
      }
    } else {
      // Flush async work.
      var _finishedWork = root.finishedWork;
      if (_finishedWork !== null) {
        // This root is already complete. We can commit it.
        root.finishedWork = null;
        root.remainingExpirationTime = commitRoot(_finishedWork);
      } else {
        root.finishedWork = null;
        _finishedWork = renderRoot(root, expirationTime);
        if (_finishedWork !== null) {
          // We've completed the root. Check the deadline one more time
          // before committing.
          if (!shouldYield()) {
            // Still time left. Commit the root.
            root.remainingExpirationTime = commitRoot(_finishedWork);
          } else {
            // There's no time left. Mark this root as complete. We'll come
            // back and commit it later.
            root.finishedWork = _finishedWork;
          }
        }
      }
    }

    isRendering = false;
  }

  // When working on async work, the reconciler asks the renderer if it should
  // yield execution. For DOM, we implement this with requestIdleCallback.
  function shouldYield() {
    if (deadline === null) {
      return false;
    }
    if (deadline.timeRemaining() > timeHeuristicForUnitOfWork) {
      // Disregard deadline.didTimeout. Only expired work should be flushed
      // during a timeout. This path is only hit for non-expired work.
      return false;
    }
    deadlineDidExpire = true;
    return true;
  }

  // TODO: Not happy about this hook. Conceptually, renderRoot should return a
  // tuple of (isReadyForCommit, didError, error)
  function onUncaughtError(error) {
    !(nextFlushedRoot !== null) ? invariant(false, 'Should be working on a root. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    // Unschedule this root so we don't work on it again until there's
    // another update.
    nextFlushedRoot.remainingExpirationTime = NoWork;
    if (!hasUnhandledError) {
      hasUnhandledError = true;
      unhandledError = error;
    }
  }

  // TODO: Batching should be implemented at the renderer level, not inside
  // the reconciler.
  function batchedUpdates(fn, a) {
    var previousIsBatchingUpdates = isBatchingUpdates;
    isBatchingUpdates = true;
    try {
      return fn(a);
    } finally {
      isBatchingUpdates = previousIsBatchingUpdates;
      if (!isBatchingUpdates && !isRendering) {
        performWork(Sync, null);
      }
    }
  }

  // TODO: Batching should be implemented at the renderer level, not inside
  // the reconciler.
  function unbatchedUpdates(fn) {
    if (isBatchingUpdates && !isUnbatchingUpdates) {
      isUnbatchingUpdates = true;
      try {
        return fn();
      } finally {
        isUnbatchingUpdates = false;
      }
    }
    return fn();
  }

  // TODO: Batching should be implemented at the renderer level, not within
  // the reconciler.
  function flushSync(fn) {
    var previousIsBatchingUpdates = isBatchingUpdates;
    isBatchingUpdates = true;
    try {
      return syncUpdates(fn);
    } finally {
      isBatchingUpdates = previousIsBatchingUpdates;
      !!isRendering ? invariant(false, 'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.') : void 0;
      performWork(Sync, null);
    }
  }

  return {
    computeAsyncExpiration: computeAsyncExpiration,
    computeExpirationForFiber: computeExpirationForFiber,
    scheduleWork: scheduleWork,
    batchedUpdates: batchedUpdates,
    unbatchedUpdates: unbatchedUpdates,
    flushSync: flushSync,
    deferredUpdates: deferredUpdates
  };
};

{
  var didWarnAboutNestedUpdates = false;
}

// 0 is PROD, 1 is DEV.
// Might add PROFILE later.


function getContextForSubtree(parentComponent) {
  if (!parentComponent) {
    return emptyObject;
  }

  var fiber = get(parentComponent);
  var parentContext = findCurrentUnmaskedContext(fiber);
  return isContextProvider(fiber) ? processChildContext(fiber, parentContext) : parentContext;
}

var ReactFiberReconciler$1 = function (config) {
  var getPublicInstance = config.getPublicInstance;

  var _ReactFiberScheduler = ReactFiberScheduler(config),
      computeAsyncExpiration = _ReactFiberScheduler.computeAsyncExpiration,
      computeExpirationForFiber = _ReactFiberScheduler.computeExpirationForFiber,
      scheduleWork = _ReactFiberScheduler.scheduleWork,
      batchedUpdates = _ReactFiberScheduler.batchedUpdates,
      unbatchedUpdates = _ReactFiberScheduler.unbatchedUpdates,
      flushSync = _ReactFiberScheduler.flushSync,
      deferredUpdates = _ReactFiberScheduler.deferredUpdates;

  function scheduleTopLevelUpdate(current, element, callback) {
    {
      if (ReactDebugCurrentFiber.phase === 'render' && ReactDebugCurrentFiber.current !== null && !didWarnAboutNestedUpdates) {
        didWarnAboutNestedUpdates = true;
        warning(false, 'Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\n\n' + 'Check the render method of %s.', getComponentName(ReactDebugCurrentFiber.current) || 'Unknown');
      }
    }

    callback = callback === undefined ? null : callback;
    {
      warning(callback === null || typeof callback === 'function', 'render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);
    }

    var expirationTime = void 0;
    // Check if the top-level element is an async wrapper component. If so,
    // treat updates to the root as async. This is a bit weird but lets us
    // avoid a separate `renderAsync` API.
    if (enableAsyncSubtreeAPI && element != null && element.type != null && element.type.prototype != null && element.type.prototype.unstable_isAsyncReactComponent === true) {
      expirationTime = computeAsyncExpiration();
    } else {
      expirationTime = computeExpirationForFiber(current);
    }

    var update = {
      expirationTime: expirationTime,
      partialState: { element: element },
      callback: callback,
      isReplace: false,
      isForced: false,
      nextCallback: null,
      next: null
    };
    insertUpdateIntoFiber(current, update);
    scheduleWork(current, expirationTime);
  }

  function findHostInstance(fiber) {
    var hostFiber = findCurrentHostFiber(fiber);
    if (hostFiber === null) {
      return null;
    }
    return hostFiber.stateNode;
  }

  return {
    createContainer: function (containerInfo, hydrate) {
      return createFiberRoot(containerInfo, hydrate);
    },
    updateContainer: function (element, container, parentComponent, callback) {
      // TODO: If this is a nested container, this won't be the root.
      var current = container.current;

      {
        if (ReactFiberInstrumentation_1.debugTool) {
          if (current.alternate === null) {
            ReactFiberInstrumentation_1.debugTool.onMountContainer(container);
          } else if (element === null) {
            ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);
          } else {
            ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);
          }
        }
      }

      var context = getContextForSubtree(parentComponent);
      if (container.context === null) {
        container.context = context;
      } else {
        container.pendingContext = context;
      }

      scheduleTopLevelUpdate(current, element, callback);
    },


    batchedUpdates: batchedUpdates,

    unbatchedUpdates: unbatchedUpdates,

    deferredUpdates: deferredUpdates,

    flushSync: flushSync,

    getPublicRootInstance: function (container) {
      var containerFiber = container.current;
      if (!containerFiber.child) {
        return null;
      }
      switch (containerFiber.child.tag) {
        case HostComponent:
          return getPublicInstance(containerFiber.child.stateNode);
        default:
          return containerFiber.child.stateNode;
      }
    },


    findHostInstance: findHostInstance,

    findHostInstanceWithNoPortals: function (fiber) {
      var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
      if (hostFiber === null) {
        return null;
      }
      return hostFiber.stateNode;
    },
    injectIntoDevTools: function (devToolsConfig) {
      var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;

      return injectInternals(_assign({}, devToolsConfig, {
        findHostInstanceByFiber: function (fiber) {
          return findHostInstance(fiber);
        },
        findFiberByHostInstance: function (instance) {
          if (!findFiberByHostInstance) {
            // Might not be implemented by the renderer.
            return null;
          }
          return findFiberByHostInstance(instance);
        }
      }));
    }
  };
};

var ReactFiberReconciler$2 = Object.freeze({
	default: ReactFiberReconciler$1
});

var ReactFiberReconciler$3 = ( ReactFiberReconciler$2 && ReactFiberReconciler$1 ) || ReactFiberReconciler$2;

// TODO: bundle Flow types with the package.



// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var reactReconciler = ReactFiberReconciler$3['default'] ? ReactFiberReconciler$3['default'] : ReactFiberReconciler$3;

function createPortal$1(children, containerInfo,
// TODO: figure out the API for cross-renderer implementation.
implementation) {
  var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  return {
    // This tag allow us to uniquely identify this as a React Portal
    $$typeof: REACT_PORTAL_TYPE,
    key: key == null ? null : '' + key,
    children: children,
    containerInfo: containerInfo,
    implementation: implementation
  };
}

// TODO: this is special because it gets imported during build.

var ReactVersion = '16.2.0';

// a requestAnimationFrame, storing the time for the start of the frame, then
// scheduling a postMessage which gets scheduled after paint. Within the
// postMessage handler do as much work as possible until time + frame rate.
// By separating the idle call into a separate event tick we ensure that
// layout, paint and other browser work is counted against the available time.
// The frame rate is dynamically adjusted.

{
  if (ExecutionEnvironment.canUseDOM && typeof requestAnimationFrame !== 'function') {
    warning(false, 'React depends on requestAnimationFrame. Make sure that you load a ' + 'polyfill in older browsers. http://fb.me/react-polyfills');
  }
}

var hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';

var now = void 0;
if (hasNativePerformanceNow) {
  now = function () {
    return performance.now();
  };
} else {
  now = function () {
    return Date.now();
  };
}

// TODO: There's no way to cancel, because Fiber doesn't atm.
var rIC = void 0;
var cIC = void 0;

if (!ExecutionEnvironment.canUseDOM) {
  rIC = function (frameCallback) {
    return setTimeout(function () {
      frameCallback({
        timeRemaining: function () {
          return Infinity;
        }
      });
    });
  };
  cIC = function (timeoutID) {
    clearTimeout(timeoutID);
  };
} else if (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {
  // Polyfill requestIdleCallback and cancelIdleCallback

  var scheduledRICCallback = null;
  var isIdleScheduled = false;
  var timeoutTime = -1;

  var isAnimationFrameScheduled = false;

  var frameDeadline = 0;
  // We start out assuming that we run at 30fps but then the heuristic tracking
  // will adjust this value to a faster fps if we get more frequent animation
  // frames.
  var previousFrameTime = 33;
  var activeFrameTime = 33;

  var frameDeadlineObject;
  if (hasNativePerformanceNow) {
    frameDeadlineObject = {
      didTimeout: false,
      timeRemaining: function () {
        // We assume that if we have a performance timer that the rAF callback
        // gets a performance timer value. Not sure if this is always true.
        var remaining = frameDeadline - performance.now();
        return remaining > 0 ? remaining : 0;
      }
    };
  } else {
    frameDeadlineObject = {
      didTimeout: false,
      timeRemaining: function () {
        // Fallback to Date.now()
        var remaining = frameDeadline - Date.now();
        return remaining > 0 ? remaining : 0;
      }
    };
  }

  // We use the postMessage trick to defer idle work until after the repaint.
  var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);
  var idleTick = function (event) {
    if (event.source !== window || event.data !== messageKey) {
      return;
    }

    isIdleScheduled = false;

    var currentTime = now();
    if (frameDeadline - currentTime <= 0) {
      // There's no time left in this idle period. Check if the callback has
      // a timeout and whether it's been exceeded.
      if (timeoutTime !== -1 && timeoutTime <= currentTime) {
        // Exceeded the timeout. Invoke the callback even though there's no
        // time left.
        frameDeadlineObject.didTimeout = true;
      } else {
        // No timeout.
        if (!isAnimationFrameScheduled) {
          // Schedule another animation callback so we retry later.
          isAnimationFrameScheduled = true;
          requestAnimationFrame(animationTick);
        }
        // Exit without invoking the callback.
        return;
      }
    } else {
      // There's still time left in this idle period.
      frameDeadlineObject.didTimeout = false;
    }

    timeoutTime = -1;
    var callback = scheduledRICCallback;
    scheduledRICCallback = null;
    if (callback !== null) {
      callback(frameDeadlineObject);
    }
  };
  // Assumes that we have addEventListener in this environment. Might need
  // something better for old IE.
  window.addEventListener('message', idleTick, false);

  var animationTick = function (rafTime) {
    isAnimationFrameScheduled = false;
    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;
    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {
      if (nextFrameTime < 8) {
        // Defensive coding. We don't support higher frame rates than 120hz.
        // If we get lower than that, it is probably a bug.
        nextFrameTime = 8;
      }
      // If one frame goes long, then the next one can be short to catch up.
      // If two frames are short in a row, then that's an indication that we
      // actually have a higher frame rate than what we're currently optimizing.
      // We adjust our heuristic dynamically accordingly. For example, if we're
      // running on 120hz display or 90hz VR display.
      // Take the max of the two in case one of them was an anomaly due to
      // missed frame deadlines.
      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;
    } else {
      previousFrameTime = nextFrameTime;
    }
    frameDeadline = rafTime + activeFrameTime;
    if (!isIdleScheduled) {
      isIdleScheduled = true;
      window.postMessage(messageKey, '*');
    }
  };

  rIC = function (callback, options) {
    // This assumes that we only schedule one callback at a time because that's
    // how Fiber uses it.
    scheduledRICCallback = callback;
    if (options != null && typeof options.timeout === 'number') {
      timeoutTime = now() + options.timeout;
    }
    if (!isAnimationFrameScheduled) {
      // If rAF didn't already schedule one, we need to schedule a frame.
      // TODO: If this rAF doesn't materialize because the browser throttles, we
      // might want to still have setTimeout trigger rIC as a backup to ensure
      // that we keep performing work.
      isAnimationFrameScheduled = true;
      requestAnimationFrame(animationTick);
    }
    return 0;
  };

  cIC = function () {
    scheduledRICCallback = null;
    isIdleScheduled = false;
    timeoutTime = -1;
  };
} else {
  rIC = window.requestIdleCallback;
  cIC = window.cancelIdleCallback;
}

/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var lowPriorityWarning = function () {};

{
  var printWarning = function (format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.warn(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  lowPriorityWarning = function (condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }
    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

var lowPriorityWarning$1 = lowPriorityWarning;

// isAttributeNameSafe() is currently duplicated in DOMMarkupOperations.
// TODO: Find a better place for this.
var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$');
var illegalAttributeNameCache = {};
var validatedAttributeNameCache = {};
function isAttributeNameSafe(attributeName) {
  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
    return true;
  }
  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
    return false;
  }
  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
    validatedAttributeNameCache[attributeName] = true;
    return true;
  }
  illegalAttributeNameCache[attributeName] = true;
  {
    warning(false, 'Invalid attribute name: `%s`', attributeName);
  }
  return false;
}

// shouldIgnoreValue() is currently duplicated in DOMMarkupOperations.
// TODO: Find a better place for this.
function shouldIgnoreValue(propertyInfo, value) {
  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
}

/**
 * Operations for dealing with DOM properties.
 */





/**
 * Get the value for a property on a node. Only used in DEV for SSR validation.
 * The "expected" argument is used as a hint of what the expected value is.
 * Some properties have multiple equivalent values.
 */
function getValueForProperty(node, name, expected) {
  {
    var propertyInfo = getPropertyInfo(name);
    if (propertyInfo) {
      var mutationMethod = propertyInfo.mutationMethod;
      if (mutationMethod || propertyInfo.mustUseProperty) {
        return node[propertyInfo.propertyName];
      } else {
        var attributeName = propertyInfo.attributeName;

        var stringValue = null;

        if (propertyInfo.hasOverloadedBooleanValue) {
          if (node.hasAttribute(attributeName)) {
            var value = node.getAttribute(attributeName);
            if (value === '') {
              return true;
            }
            if (shouldIgnoreValue(propertyInfo, expected)) {
              return value;
            }
            if (value === '' + expected) {
              return expected;
            }
            return value;
          }
        } else if (node.hasAttribute(attributeName)) {
          if (shouldIgnoreValue(propertyInfo, expected)) {
            // We had an attribute but shouldn't have had one, so read it
            // for the error message.
            return node.getAttribute(attributeName);
          }
          if (propertyInfo.hasBooleanValue) {
            // If this was a boolean, it doesn't matter what the value is
            // the fact that we have it is the same as the expected.
            return expected;
          }
          // Even if this property uses a namespace we use getAttribute
          // because we assume its namespaced name is the same as our config.
          // To use getAttributeNS we need the local name which we don't have
          // in our config atm.
          stringValue = node.getAttribute(attributeName);
        }

        if (shouldIgnoreValue(propertyInfo, expected)) {
          return stringValue === null ? expected : stringValue;
        } else if (stringValue === '' + expected) {
          return expected;
        } else {
          return stringValue;
        }
      }
    }
  }
}

/**
 * Get the value for a attribute on a node. Only used in DEV for SSR validation.
 * The third argument is used as a hint of what the expected value is. Some
 * attributes have multiple equivalent values.
 */
function getValueForAttribute(node, name, expected) {
  {
    if (!isAttributeNameSafe(name)) {
      return;
    }
    if (!node.hasAttribute(name)) {
      return expected === undefined ? undefined : null;
    }
    var value = node.getAttribute(name);
    if (value === '' + expected) {
      return expected;
    }
    return value;
  }
}

/**
 * Sets the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 * @param {*} value
 */
function setValueForProperty(node, name, value) {
  var propertyInfo = getPropertyInfo(name);

  if (propertyInfo && shouldSetAttribute(name, value)) {
    var mutationMethod = propertyInfo.mutationMethod;
    if (mutationMethod) {
      mutationMethod(node, value);
    } else if (shouldIgnoreValue(propertyInfo, value)) {
      deleteValueForProperty(node, name);
      return;
    } else if (propertyInfo.mustUseProperty) {
      // Contrary to `setAttribute`, object properties are properly
      // `toString`ed by IE8/9.
      node[propertyInfo.propertyName] = value;
    } else {
      var attributeName = propertyInfo.attributeName;
      var namespace = propertyInfo.attributeNamespace;
      // `setAttribute` with objects becomes only `[object]` in IE8/9,
      // ('' + value) makes it output the correct toString()-value.
      if (namespace) {
        node.setAttributeNS(namespace, attributeName, '' + value);
      } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
        node.setAttribute(attributeName, '');
      } else {
        node.setAttribute(attributeName, '' + value);
      }
    }
  } else {
    setValueForAttribute(node, name, shouldSetAttribute(name, value) ? value : null);
    return;
  }

  {
    
  }
}

function setValueForAttribute(node, name, value) {
  if (!isAttributeNameSafe(name)) {
    return;
  }
  if (value == null) {
    node.removeAttribute(name);
  } else {
    node.setAttribute(name, '' + value);
  }

  {
    
  }
}

/**
 * Deletes an attributes from a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 */
function deleteValueForAttribute(node, name) {
  node.removeAttribute(name);
}

/**
 * Deletes the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 */
function deleteValueForProperty(node, name) {
  var propertyInfo = getPropertyInfo(name);
  if (propertyInfo) {
    var mutationMethod = propertyInfo.mutationMethod;
    if (mutationMethod) {
      mutationMethod(node, undefined);
    } else if (propertyInfo.mustUseProperty) {
      var propName = propertyInfo.propertyName;
      if (propertyInfo.hasBooleanValue) {
        node[propName] = false;
      } else {
        node[propName] = '';
      }
    } else {
      node.removeAttribute(propertyInfo.attributeName);
    }
  } else {
    node.removeAttribute(name);
  }
}

var ReactControlledValuePropTypes = {
  checkPropTypes: null
};

{
  var hasReadOnlyValue = {
    button: true,
    checkbox: true,
    image: true,
    hidden: true,
    radio: true,
    reset: true,
    submit: true
  };

  var propTypes = {
    value: function (props, propName, componentName) {
      if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
        return null;
      }
      return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
    },
    checked: function (props, propName, componentName) {
      if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
        return null;
      }
      return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
    }
  };

  /**
   * Provide a linked `value` attribute for controlled forms. You should not use
   * this outside of the ReactDOM controlled form components.
   */
  ReactControlledValuePropTypes.checkPropTypes = function (tagName, props, getStack) {
    checkPropTypes(propTypes, props, 'prop', tagName, getStack);
  };
}

// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$2 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;
var getCurrentFiberStackAddendum$3 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;

var didWarnValueDefaultValue = false;
var didWarnCheckedDefaultChecked = false;
var didWarnControlledToUncontrolled = false;
var didWarnUncontrolledToControlled = false;

function isControlled(props) {
  var usesChecked = props.type === 'checkbox' || props.type === 'radio';
  return usesChecked ? props.checked != null : props.value != null;
}

/**
 * Implements an <input> host component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */

function getHostProps(element, props) {
  var node = element;
  var value = props.value;
  var checked = props.checked;

  var hostProps = _assign({
    // Make sure we set .type before any other properties (setting .value
    // before .type means .value is lost in IE11 and below)
    type: undefined,
    // Make sure we set .step before .value (setting .value before .step
    // means .value is rounded on mount, based upon step precision)
    step: undefined,
    // Make sure we set .min & .max before .value (to ensure proper order
    // in corner cases such as min or max deriving from value, e.g. Issue #7170)
    min: undefined,
    max: undefined
  }, props, {
    defaultChecked: undefined,
    defaultValue: undefined,
    value: value != null ? value : node._wrapperState.initialValue,
    checked: checked != null ? checked : node._wrapperState.initialChecked
  });

  return hostProps;
}

function initWrapperState(element, props) {
  {
    ReactControlledValuePropTypes.checkPropTypes('input', props, getCurrentFiberStackAddendum$3);

    if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
      warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerName$2() || 'A component', props.type);
      didWarnCheckedDefaultChecked = true;
    }
    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
      warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerName$2() || 'A component', props.type);
      didWarnValueDefaultValue = true;
    }
  }

  var defaultValue = props.defaultValue;
  var node = element;
  node._wrapperState = {
    initialChecked: props.checked != null ? props.checked : props.defaultChecked,
    initialValue: props.value != null ? props.value : defaultValue,
    controlled: isControlled(props)
  };
}

function updateChecked(element, props) {
  var node = element;
  var checked = props.checked;
  if (checked != null) {
    setValueForProperty(node, 'checked', checked);
  }
}

function updateWrapper(element, props) {
  var node = element;
  {
    var controlled = isControlled(props);

    if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
      warning(false, 'A component is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s', props.type, getCurrentFiberStackAddendum$3());
      didWarnUncontrolledToControlled = true;
    }
    if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
      warning(false, 'A component is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s', props.type, getCurrentFiberStackAddendum$3());
      didWarnControlledToUncontrolled = true;
    }
  }

  updateChecked(element, props);

  var value = props.value;
  if (value != null) {
    if (value === 0 && node.value === '') {
      node.value = '0';
      // Note: IE9 reports a number inputs as 'text', so check props instead.
    } else if (props.type === 'number') {
      // Simulate `input.valueAsNumber`. IE9 does not support it
      var valueAsNumber = parseFloat(node.value) || 0;

      if (
      // eslint-disable-next-line
      value != valueAsNumber ||
      // eslint-disable-next-line
      value == valueAsNumber && node.value != value) {
        // Cast `value` to a string to ensure the value is set correctly. While
        // browsers typically do this as necessary, jsdom doesn't.
        node.value = '' + value;
      }
    } else if (node.value !== '' + value) {
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      node.value = '' + value;
    }
  } else {
    if (props.value == null && props.defaultValue != null) {
      // In Chrome, assigning defaultValue to certain input types triggers input validation.
      // For number inputs, the display value loses trailing decimal points. For email inputs,
      // Chrome raises "The specified value <x> is not a valid email address".
      //
      // Here we check to see if the defaultValue has actually changed, avoiding these problems
      // when the user is inputting text
      //
      // https://github.com/facebook/react/issues/7253
      if (node.defaultValue !== '' + props.defaultValue) {
        node.defaultValue = '' + props.defaultValue;
      }
    }
    if (props.checked == null && props.defaultChecked != null) {
      node.defaultChecked = !!props.defaultChecked;
    }
  }
}

function postMountWrapper(element, props) {
  var node = element;

  // Detach value from defaultValue. We won't do anything if we're working on
  // submit or reset inputs as those values & defaultValues are linked. They
  // are not resetable nodes so this operation doesn't matter and actually
  // removes browser-default values (eg "Submit Query") when no value is
  // provided.

  switch (props.type) {
    case 'submit':
    case 'reset':
      break;
    case 'color':
    case 'date':
    case 'datetime':
    case 'datetime-local':
    case 'month':
    case 'time':
    case 'week':
      // This fixes the no-show issue on iOS Safari and Android Chrome:
      // https://github.com/facebook/react/issues/7233
      node.value = '';
      node.value = node.defaultValue;
      break;
    default:
      node.value = node.value;
      break;
  }

  // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
  // this is needed to work around a chrome bug where setting defaultChecked
  // will sometimes influence the value of checked (even after detachment).
  // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
  // We need to temporarily unset name to avoid disrupting radio button groups.
  var name = node.name;
  if (name !== '') {
    node.name = '';
  }
  node.defaultChecked = !node.defaultChecked;
  node.defaultChecked = !node.defaultChecked;
  if (name !== '') {
    node.name = name;
  }
}

function restoreControlledState$1(element, props) {
  var node = element;
  updateWrapper(node, props);
  updateNamedCousins(node, props);
}

function updateNamedCousins(rootNode, props) {
  var name = props.name;
  if (props.type === 'radio' && name != null) {
    var queryRoot = rootNode;

    while (queryRoot.parentNode) {
      queryRoot = queryRoot.parentNode;
    }

    // If `rootNode.form` was non-null, then we could try `form.elements`,
    // but that sometimes behaves strangely in IE8. We could also try using
    // `form.getElementsByName`, but that will only return direct children
    // and won't include inputs that use the HTML5 `form=` attribute. Since
    // the input might not even be in a form. It might not even be in the
    // document. Let's just use the local `querySelectorAll` to ensure we don't
    // miss anything.
    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

    for (var i = 0; i < group.length; i++) {
      var otherNode = group[i];
      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
        continue;
      }
      // This will throw if radio buttons rendered by different copies of React
      // and the same name are rendered into the same form (same as #1939).
      // That's probably okay; we don't support it just as we don't support
      // mixing React radio buttons with non-React ones.
      var otherProps = getFiberCurrentPropsFromNode$1(otherNode);
      !otherProps ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : void 0;

      // We need update the tracked value on the named cousin since the value
      // was changed but the input saw no event or value set
      updateValueIfChanged(otherNode);

      // If this is a controlled radio button group, forcing the input that
      // was previously checked to update will cause it to be come re-checked
      // as appropriate.
      updateWrapper(otherNode, otherProps);
    }
  }
}

function flattenChildren(children) {
  var content = '';

  // Flatten children and warn if they aren't strings or numbers;
  // invalid types are ignored.
  // We can silently skip them because invalid DOM nesting warning
  // catches these cases in Fiber.
  React.Children.forEach(children, function (child) {
    if (child == null) {
      return;
    }
    if (typeof child === 'string' || typeof child === 'number') {
      content += child;
    }
  });

  return content;
}

/**
 * Implements an <option> host component that warns when `selected` is set.
 */

function validateProps(element, props) {
  // TODO (yungsters): Remove support for `selected` in <option>.
  {
    warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.');
  }
}

function postMountWrapper$1(element, props) {
  // value="" should make a value attribute (#6219)
  if (props.value != null) {
    element.setAttribute('value', props.value);
  }
}

function getHostProps$1(element, props) {
  var hostProps = _assign({ children: undefined }, props);
  var content = flattenChildren(props.children);

  if (content) {
    hostProps.children = content;
  }

  return hostProps;
}

// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$3 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;
var getCurrentFiberStackAddendum$4 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;


{
  var didWarnValueDefaultValue$1 = false;
}

function getDeclarationErrorAddendum() {
  var ownerName = getCurrentFiberOwnerName$3();
  if (ownerName) {
    return '\n\nCheck the render method of `' + ownerName + '`.';
  }
  return '';
}

var valuePropNames = ['value', 'defaultValue'];

/**
 * Validation function for `value` and `defaultValue`.
 */
function checkSelectPropTypes(props) {
  ReactControlledValuePropTypes.checkPropTypes('select', props, getCurrentFiberStackAddendum$4);

  for (var i = 0; i < valuePropNames.length; i++) {
    var propName = valuePropNames[i];
    if (props[propName] == null) {
      continue;
    }
    var isArray = Array.isArray(props[propName]);
    if (props.multiple && !isArray) {
      warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum());
    } else if (!props.multiple && isArray) {
      warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum());
    }
  }
}

function updateOptions(node, multiple, propValue, setDefaultSelected) {
  var options = node.options;

  if (multiple) {
    var selectedValues = propValue;
    var selectedValue = {};
    for (var i = 0; i < selectedValues.length; i++) {
      // Prefix to avoid chaos with special keys.
      selectedValue['$' + selectedValues[i]] = true;
    }
    for (var _i = 0; _i < options.length; _i++) {
      var selected = selectedValue.hasOwnProperty('$' + options[_i].value);
      if (options[_i].selected !== selected) {
        options[_i].selected = selected;
      }
      if (selected && setDefaultSelected) {
        options[_i].defaultSelected = true;
      }
    }
  } else {
    // Do not set `select.value` as exact behavior isn't consistent across all
    // browsers for all cases.
    var _selectedValue = '' + propValue;
    var defaultSelected = null;
    for (var _i2 = 0; _i2 < options.length; _i2++) {
      if (options[_i2].value === _selectedValue) {
        options[_i2].selected = true;
        if (setDefaultSelected) {
          options[_i2].defaultSelected = true;
        }
        return;
      }
      if (defaultSelected === null && !options[_i2].disabled) {
        defaultSelected = options[_i2];
      }
    }
    if (defaultSelected !== null) {
      defaultSelected.selected = true;
    }
  }
}

/**
 * Implements a <select> host component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */

function getHostProps$2(element, props) {
  return _assign({}, props, {
    value: undefined
  });
}

function initWrapperState$1(element, props) {
  var node = element;
  {
    checkSelectPropTypes(props);
  }

  var value = props.value;
  node._wrapperState = {
    initialValue: value != null ? value : props.defaultValue,
    wasMultiple: !!props.multiple
  };

  {
    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue$1) {
      warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');
      didWarnValueDefaultValue$1 = true;
    }
  }
}

function postMountWrapper$2(element, props) {
  var node = element;
  node.multiple = !!props.multiple;
  var value = props.value;
  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  } else if (props.defaultValue != null) {
    updateOptions(node, !!props.multiple, props.defaultValue, true);
  }
}

function postUpdateWrapper(element, props) {
  var node = element;
  // After the initial mount, we control selected-ness manually so don't pass
  // this value down
  node._wrapperState.initialValue = undefined;

  var wasMultiple = node._wrapperState.wasMultiple;
  node._wrapperState.wasMultiple = !!props.multiple;

  var value = props.value;
  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  } else if (wasMultiple !== !!props.multiple) {
    // For simplicity, reapply `defaultValue` if `multiple` is toggled.
    if (props.defaultValue != null) {
      updateOptions(node, !!props.multiple, props.defaultValue, true);
    } else {
      // Revert the select back to its default unselected state.
      updateOptions(node, !!props.multiple, props.multiple ? [] : '', false);
    }
  }
}

function restoreControlledState$2(element, props) {
  var node = element;
  var value = props.value;

  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  }
}

// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberStackAddendum$5 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;

var didWarnValDefaultVal = false;

/**
 * Implements a <textarea> host component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */

function getHostProps$3(element, props) {
  var node = element;
  !(props.dangerouslySetInnerHTML == null) ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : void 0;

  // Always set children to the same thing. In IE9, the selection range will
  // get reset if `textContent` is mutated.  We could add a check in setTextContent
  // to only set the value if/when the value differs from the node value (which would
  // completely solve this IE9 bug), but Sebastian+Sophie seemed to like this
  // solution. The value can be a boolean or object so that's why it's forced
  // to be a string.
  var hostProps = _assign({}, props, {
    value: undefined,
    defaultValue: undefined,
    children: '' + node._wrapperState.initialValue
  });

  return hostProps;
}

function initWrapperState$2(element, props) {
  var node = element;
  {
    ReactControlledValuePropTypes.checkPropTypes('textarea', props, getCurrentFiberStackAddendum$5);
    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
      warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');
      didWarnValDefaultVal = true;
    }
  }

  var initialValue = props.value;

  // Only bother fetching default value if we're going to use it
  if (initialValue == null) {
    var defaultValue = props.defaultValue;
    // TODO (yungsters): Remove support for children content in <textarea>.
    var children = props.children;
    if (children != null) {
      {
        warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.');
      }
      !(defaultValue == null) ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : void 0;
      if (Array.isArray(children)) {
        !(children.length <= 1) ? invariant(false, '<textarea> can only have at most one child.') : void 0;
        children = children[0];
      }

      defaultValue = '' + children;
    }
    if (defaultValue == null) {
      defaultValue = '';
    }
    initialValue = defaultValue;
  }

  node._wrapperState = {
    initialValue: '' + initialValue
  };
}

function updateWrapper$1(element, props) {
  var node = element;
  var value = props.value;
  if (value != null) {
    // Cast `value` to a string to ensure the value is set correctly. While
    // browsers typically do this as necessary, jsdom doesn't.
    var newValue = '' + value;

    // To avoid side effects (such as losing text selection), only set value if changed
    if (newValue !== node.value) {
      node.value = newValue;
    }
    if (props.defaultValue == null) {
      node.defaultValue = newValue;
    }
  }
  if (props.defaultValue != null) {
    node.defaultValue = props.defaultValue;
  }
}

function postMountWrapper$3(element, props) {
  var node = element;
  // This is in postMount because we need access to the DOM node, which is not
  // available until after the component has mounted.
  var textContent = node.textContent;

  // Only set node.value if textContent is equal to the expected
  // initial value. In IE10/IE11 there is a bug where the placeholder attribute
  // will populate textContent as well.
  // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
  if (textContent === node._wrapperState.initialValue) {
    node.value = textContent;
  }
}

function restoreControlledState$3(element, props) {
  // DOM component is still mounted; update
  updateWrapper$1(element, props);
}

var HTML_NAMESPACE$1 = 'http://www.w3.org/1999/xhtml';
var MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';

var Namespaces = {
  html: HTML_NAMESPACE$1,
  mathml: MATH_NAMESPACE,
  svg: SVG_NAMESPACE
};

// Assumes there is no parent namespace.
function getIntrinsicNamespace(type) {
  switch (type) {
    case 'svg':
      return SVG_NAMESPACE;
    case 'math':
      return MATH_NAMESPACE;
    default:
      return HTML_NAMESPACE$1;
  }
}

function getChildNamespace(parentNamespace, type) {
  if (parentNamespace == null || parentNamespace === HTML_NAMESPACE$1) {
    // No (or default) parent namespace: potential entry point.
    return getIntrinsicNamespace(type);
  }
  if (parentNamespace === SVG_NAMESPACE && type === 'foreignObject') {
    // We're leaving SVG.
    return HTML_NAMESPACE$1;
  }
  // By default, pass namespace below.
  return parentNamespace;
}

/* globals MSApp */

/**
 * Create a function which has 'unsafe' privileges (required by windows8 apps)
 */
var createMicrosoftUnsafeLocalFunction = function (func) {
  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
    return function (arg0, arg1, arg2, arg3) {
      MSApp.execUnsafeLocalFunction(function () {
        return func(arg0, arg1, arg2, arg3);
      });
    };
  } else {
    return func;
  }
};

// SVG temp container for IE lacking innerHTML
var reusableSVGContainer = void 0;

/**
 * Set the innerHTML property of a node
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */
var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
  // IE does not have innerHTML for SVG nodes, so instead we inject the
  // new markup in a temp node and then move the child nodes across into
  // the target node

  if (node.namespaceURI === Namespaces.svg && !('innerHTML' in node)) {
    reusableSVGContainer = reusableSVGContainer || document.createElement('div');
    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
    var svgNode = reusableSVGContainer.firstChild;
    while (node.firstChild) {
      node.removeChild(node.firstChild);
    }
    while (svgNode.firstChild) {
      node.appendChild(svgNode.firstChild);
    }
  } else {
    node.innerHTML = html;
  }
});

/**
 * Set the textContent property of a node, ensuring that whitespace is preserved
 * even in IE8. innerText is a poor substitute for textContent and, among many
 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
 * as it should.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */
var setTextContent = function (node, text) {
  if (text) {
    var firstChild = node.firstChild;

    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
      firstChild.nodeValue = text;
      return;
    }
  }
  node.textContent = text;
};

/**
 * CSS properties which accept numbers but are not in units of "px".
 */
var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,

  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};

/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */
function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
}

/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */
var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function (prop) {
  prefixes.forEach(function (prefix) {
    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
  });
});

/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */
function dangerousStyleValue(name, value, isCustomProperty) {
  // Note that we've removed escapeTextForBrowser() calls here since the
  // whole string will be escaped when the attribute is injected into
  // the markup. If you provide unsafe user data here they can inject
  // arbitrary CSS which may be problematic (I couldn't repro this):
  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
  // This is not an XSS hole but instead a potential CSS injection issue
  // which has lead to a greater discussion about how we're going to
  // trust URLs moving forward. See #2115901

  var isEmpty = value == null || typeof value === 'boolean' || value === '';
  if (isEmpty) {
    return '';
  }

  if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {
    return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers
  }

  return ('' + value).trim();
}

var warnValidStyle = emptyFunction;

{
  // 'msTransform' is correct, but the other prefixes should be capitalized
  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;

  // style values shouldn't contain a semicolon
  var badStyleValueWithSemicolonPattern = /;\s*$/;

  var warnedStyleNames = {};
  var warnedStyleValues = {};
  var warnedForNaNValue = false;
  var warnedForInfinityValue = false;

  var warnHyphenatedStyleName = function (name, getStack) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), getStack());
  };

  var warnBadVendoredStyleName = function (name, getStack) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), getStack());
  };

  var warnStyleValueWithSemicolon = function (name, value, getStack) {
    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
      return;
    }

    warnedStyleValues[value] = true;
    warning(false, "Style property values shouldn't contain a semicolon. " + 'Try "%s: %s" instead.%s', name, value.replace(badStyleValueWithSemicolonPattern, ''), getStack());
  };

  var warnStyleValueIsNaN = function (name, value, getStack) {
    if (warnedForNaNValue) {
      return;
    }

    warnedForNaNValue = true;
    warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, getStack());
  };

  var warnStyleValueIsInfinity = function (name, value, getStack) {
    if (warnedForInfinityValue) {
      return;
    }

    warnedForInfinityValue = true;
    warning(false, '`Infinity` is an invalid value for the `%s` css style property.%s', name, getStack());
  };

  warnValidStyle = function (name, value, getStack) {
    if (name.indexOf('-') > -1) {
      warnHyphenatedStyleName(name, getStack);
    } else if (badVendoredStyleNamePattern.test(name)) {
      warnBadVendoredStyleName(name, getStack);
    } else if (badStyleValueWithSemicolonPattern.test(value)) {
      warnStyleValueWithSemicolon(name, value, getStack);
    }

    if (typeof value === 'number') {
      if (isNaN(value)) {
        warnStyleValueIsNaN(name, value, getStack);
      } else if (!isFinite(value)) {
        warnStyleValueIsInfinity(name, value, getStack);
      }
    }
  };
}

var warnValidStyle$1 = warnValidStyle;

/**
 * Operations for dealing with CSS properties.
 */

/**
 * This creates a string that is expected to be equivalent to the style
 * attribute generated by server-side rendering. It by-passes warnings and
 * security checks so it's not safe to use this value for anything other than
 * comparison. It is only used in DEV for SSR validation.
 */
function createDangerousStringForStyles(styles) {
  {
    var serialized = '';
    var delimiter = '';
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      var styleValue = styles[styleName];
      if (styleValue != null) {
        var isCustomProperty = styleName.indexOf('--') === 0;
        serialized += delimiter + hyphenateStyleName(styleName) + ':';
        serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);

        delimiter = ';';
      }
    }
    return serialized || null;
  }
}

/**
 * Sets the value for multiple styles on a node.  If a value is specified as
 * '' (empty string), the corresponding style property will be unset.
 *
 * @param {DOMElement} node
 * @param {object} styles
 */
function setValueForStyles(node, styles, getStack) {
  var style = node.style;
  for (var styleName in styles) {
    if (!styles.hasOwnProperty(styleName)) {
      continue;
    }
    var isCustomProperty = styleName.indexOf('--') === 0;
    {
      if (!isCustomProperty) {
        warnValidStyle$1(styleName, styles[styleName], getStack);
      }
    }
    var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);
    if (styleName === 'float') {
      styleName = 'cssFloat';
    }
    if (isCustomProperty) {
      style.setProperty(styleName, styleValue);
    } else {
      style[styleName] = styleValue;
    }
  }
}

// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special-case tags.

var omittedCloseTags = {
  area: true,
  base: true,
  br: true,
  col: true,
  embed: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true
};

// For HTML, certain tags cannot have children. This has the same purpose as
// `omittedCloseTags` except that `menuitem` should still have its closing tag.

var voidElementTags = _assign({
  menuitem: true
}, omittedCloseTags);

var HTML$1 = '__html';

function assertValidProps(tag, props, getStack) {
  if (!props) {
    return;
  }
  // Note the use of `==` which checks for null or undefined.
  if (voidElementTags[tag]) {
    !(props.children == null && props.dangerouslySetInnerHTML == null) ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', tag, getStack()) : void 0;
  }
  if (props.dangerouslySetInnerHTML != null) {
    !(props.children == null) ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : void 0;
    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML$1 in props.dangerouslySetInnerHTML) ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : void 0;
  }
  {
    warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.%s', getStack());
  }
  !(props.style == null || typeof props.style === 'object') ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', getStack()) : void 0;
}

function isCustomComponent(tagName, props) {
  if (tagName.indexOf('-') === -1) {
    return typeof props.is === 'string';
  }
  switch (tagName) {
    // These are reserved SVG and MathML elements.
    // We don't mind this whitelist too much because we expect it to never grow.
    // The alternative is to track the namespace in a few places which is convoluted.
    // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
    case 'annotation-xml':
    case 'color-profile':
    case 'font-face':
    case 'font-face-src':
    case 'font-face-uri':
    case 'font-face-format':
    case 'font-face-name':
    case 'missing-glyph':
      return false;
    default:
      return true;
  }
}

var ariaProperties = {
  'aria-current': 0, // state
  'aria-details': 0,
  'aria-disabled': 0, // state
  'aria-hidden': 0, // state
  'aria-invalid': 0, // state
  'aria-keyshortcuts': 0,
  'aria-label': 0,
  'aria-roledescription': 0,
  // Widget Attributes
  'aria-autocomplete': 0,
  'aria-checked': 0,
  'aria-expanded': 0,
  'aria-haspopup': 0,
  'aria-level': 0,
  'aria-modal': 0,
  'aria-multiline': 0,
  'aria-multiselectable': 0,
  'aria-orientation': 0,
  'aria-placeholder': 0,
  'aria-pressed': 0,
  'aria-readonly': 0,
  'aria-required': 0,
  'aria-selected': 0,
  'aria-sort': 0,
  'aria-valuemax': 0,
  'aria-valuemin': 0,
  'aria-valuenow': 0,
  'aria-valuetext': 0,
  // Live Region Attributes
  'aria-atomic': 0,
  'aria-busy': 0,
  'aria-live': 0,
  'aria-relevant': 0,
  // Drag-and-Drop Attributes
  'aria-dropeffect': 0,
  'aria-grabbed': 0,
  // Relationship Attributes
  'aria-activedescendant': 0,
  'aria-colcount': 0,
  'aria-colindex': 0,
  'aria-colspan': 0,
  'aria-controls': 0,
  'aria-describedby': 0,
  'aria-errormessage': 0,
  'aria-flowto': 0,
  'aria-labelledby': 0,
  'aria-owns': 0,
  'aria-posinset': 0,
  'aria-rowcount': 0,
  'aria-rowindex': 0,
  'aria-rowspan': 0,
  'aria-setsize': 0
};

var warnedProperties = {};
var rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
var rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');

var hasOwnProperty = Object.prototype.hasOwnProperty;

function getStackAddendum() {
  var stack = ReactDebugCurrentFrame.getStackAddendum();
  return stack != null ? stack : '';
}

function validateProperty(tagName, name) {
  if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {
    return true;
  }

  if (rARIACamel.test(name)) {
    var ariaName = 'aria-' + name.slice(4).toLowerCase();
    var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;

    // If this is an aria-* attribute, but is not listed in the known DOM
    // DOM properties, then it is an invalid aria-* attribute.
    if (correctName == null) {
      warning(false, 'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.%s', name, getStackAddendum());
      warnedProperties[name] = true;
      return true;
    }
    // aria-* attributes should be lowercase; suggest the lowercase version.
    if (name !== correctName) {
      warning(false, 'Invalid ARIA attribute `%s`. Did you mean `%s`?%s', name, correctName, getStackAddendum());
      warnedProperties[name] = true;
      return true;
    }
  }

  if (rARIA.test(name)) {
    var lowerCasedName = name.toLowerCase();
    var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;

    // If this is an aria-* attribute, but is not listed in the known DOM
    // DOM properties, then it is an invalid aria-* attribute.
    if (standardName == null) {
      warnedProperties[name] = true;
      return false;
    }
    // aria-* attributes should be lowercase; suggest the lowercase version.
    if (name !== standardName) {
      warning(false, 'Unknown ARIA attribute `%s`. Did you mean `%s`?%s', name, standardName, getStackAddendum());
      warnedProperties[name] = true;
      return true;
    }
  }

  return true;
}

function warnInvalidARIAProps(type, props) {
  var invalidProps = [];

  for (var key in props) {
    var isValid = validateProperty(type, key);
    if (!isValid) {
      invalidProps.push(key);
    }
  }

  var unknownPropString = invalidProps.map(function (prop) {
    return '`' + prop + '`';
  }).join(', ');

  if (invalidProps.length === 1) {
    warning(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, type, getStackAddendum());
  } else if (invalidProps.length > 1) {
    warning(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, type, getStackAddendum());
  }
}

function validateProperties(type, props) {
  if (isCustomComponent(type, props)) {
    return;
  }
  warnInvalidARIAProps(type, props);
}

var didWarnValueNull = false;

function getStackAddendum$1() {
  var stack = ReactDebugCurrentFrame.getStackAddendum();
  return stack != null ? stack : '';
}

function validateProperties$1(type, props) {
  if (type !== 'input' && type !== 'textarea' && type !== 'select') {
    return;
  }

  if (props != null && props.value === null && !didWarnValueNull) {
    didWarnValueNull = true;
    if (type === 'select' && props.multiple) {
      warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty array when `multiple` is set to `true` ' + 'to clear the component or `undefined` for uncontrolled components.%s', type, getStackAddendum$1());
    } else {
      warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', type, getStackAddendum$1());
    }
  }
}

// When adding attributes to the HTML or SVG whitelist, be sure to
// also add them to this module to ensure casing and incorrect name
// warnings.
var possibleStandardNames = {
  // HTML
  accept: 'accept',
  acceptcharset: 'acceptCharset',
  'accept-charset': 'acceptCharset',
  accesskey: 'accessKey',
  action: 'action',
  allowfullscreen: 'allowFullScreen',
  alt: 'alt',
  as: 'as',
  async: 'async',
  autocapitalize: 'autoCapitalize',
  autocomplete: 'autoComplete',
  autocorrect: 'autoCorrect',
  autofocus: 'autoFocus',
  autoplay: 'autoPlay',
  autosave: 'autoSave',
  capture: 'capture',
  cellpadding: 'cellPadding',
  cellspacing: 'cellSpacing',
  challenge: 'challenge',
  charset: 'charSet',
  checked: 'checked',
  children: 'children',
  cite: 'cite',
  'class': 'className',
  classid: 'classID',
  classname: 'className',
  cols: 'cols',
  colspan: 'colSpan',
  content: 'content',
  contenteditable: 'contentEditable',
  contextmenu: 'contextMenu',
  controls: 'controls',
  controlslist: 'controlsList',
  coords: 'coords',
  crossorigin: 'crossOrigin',
  dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',
  data: 'data',
  datetime: 'dateTime',
  'default': 'default',
  defaultchecked: 'defaultChecked',
  defaultvalue: 'defaultValue',
  defer: 'defer',
  dir: 'dir',
  disabled: 'disabled',
  download: 'download',
  draggable: 'draggable',
  enctype: 'encType',
  'for': 'htmlFor',
  form: 'form',
  formmethod: 'formMethod',
  formaction: 'formAction',
  formenctype: 'formEncType',
  formnovalidate: 'formNoValidate',
  formtarget: 'formTarget',
  frameborder: 'frameBorder',
  headers: 'headers',
  height: 'height',
  hidden: 'hidden',
  high: 'high',
  href: 'href',
  hreflang: 'hrefLang',
  htmlfor: 'htmlFor',
  httpequiv: 'httpEquiv',
  'http-equiv': 'httpEquiv',
  icon: 'icon',
  id: 'id',
  innerhtml: 'innerHTML',
  inputmode: 'inputMode',
  integrity: 'integrity',
  is: 'is',
  itemid: 'itemID',
  itemprop: 'itemProp',
  itemref: 'itemRef',
  itemscope: 'itemScope',
  itemtype: 'itemType',
  keyparams: 'keyParams',
  keytype: 'keyType',
  kind: 'kind',
  label: 'label',
  lang: 'lang',
  list: 'list',
  loop: 'loop',
  low: 'low',
  manifest: 'manifest',
  marginwidth: 'marginWidth',
  marginheight: 'marginHeight',
  max: 'max',
  maxlength: 'maxLength',
  media: 'media',
  mediagroup: 'mediaGroup',
  method: 'method',
  min: 'min',
  minlength: 'minLength',
  multiple: 'multiple',
  muted: 'muted',
  name: 'name',
  nonce: 'nonce',
  novalidate: 'noValidate',
  open: 'open',
  optimum: 'optimum',
  pattern: 'pattern',
  placeholder: 'placeholder',
  playsinline: 'playsInline',
  poster: 'poster',
  preload: 'preload',
  profile: 'profile',
  radiogroup: 'radioGroup',
  readonly: 'readOnly',
  referrerpolicy: 'referrerPolicy',
  rel: 'rel',
  required: 'required',
  reversed: 'reversed',
  role: 'role',
  rows: 'rows',
  rowspan: 'rowSpan',
  sandbox: 'sandbox',
  scope: 'scope',
  scoped: 'scoped',
  scrolling: 'scrolling',
  seamless: 'seamless',
  selected: 'selected',
  shape: 'shape',
  size: 'size',
  sizes: 'sizes',
  span: 'span',
  spellcheck: 'spellCheck',
  src: 'src',
  srcdoc: 'srcDoc',
  srclang: 'srcLang',
  srcset: 'srcSet',
  start: 'start',
  step: 'step',
  style: 'style',
  summary: 'summary',
  tabindex: 'tabIndex',
  target: 'target',
  title: 'title',
  type: 'type',
  usemap: 'useMap',
  value: 'value',
  width: 'width',
  wmode: 'wmode',
  wrap: 'wrap',

  // SVG
  about: 'about',
  accentheight: 'accentHeight',
  'accent-height': 'accentHeight',
  accumulate: 'accumulate',
  additive: 'additive',
  alignmentbaseline: 'alignmentBaseline',
  'alignment-baseline': 'alignmentBaseline',
  allowreorder: 'allowReorder',
  alphabetic: 'alphabetic',
  amplitude: 'amplitude',
  arabicform: 'arabicForm',
  'arabic-form': 'arabicForm',
  ascent: 'ascent',
  attributename: 'attributeName',
  attributetype: 'attributeType',
  autoreverse: 'autoReverse',
  azimuth: 'azimuth',
  basefrequency: 'baseFrequency',
  baselineshift: 'baselineShift',
  'baseline-shift': 'baselineShift',
  baseprofile: 'baseProfile',
  bbox: 'bbox',
  begin: 'begin',
  bias: 'bias',
  by: 'by',
  calcmode: 'calcMode',
  capheight: 'capHeight',
  'cap-height': 'capHeight',
  clip: 'clip',
  clippath: 'clipPath',
  'clip-path': 'clipPath',
  clippathunits: 'clipPathUnits',
  cliprule: 'clipRule',
  'clip-rule': 'clipRule',
  color: 'color',
  colorinterpolation: 'colorInterpolation',
  'color-interpolation': 'colorInterpolation',
  colorinterpolationfilters: 'colorInterpolationFilters',
  'color-interpolation-filters': 'colorInterpolationFilters',
  colorprofile: 'colorProfile',
  'color-profile': 'colorProfile',
  colorrendering: 'colorRendering',
  'color-rendering': 'colorRendering',
  contentscripttype: 'contentScriptType',
  contentstyletype: 'contentStyleType',
  cursor: 'cursor',
  cx: 'cx',
  cy: 'cy',
  d: 'd',
  datatype: 'datatype',
  decelerate: 'decelerate',
  descent: 'descent',
  diffuseconstant: 'diffuseConstant',
  direction: 'direction',
  display: 'display',
  divisor: 'divisor',
  dominantbaseline: 'dominantBaseline',
  'dominant-baseline': 'dominantBaseline',
  dur: 'dur',
  dx: 'dx',
  dy: 'dy',
  edgemode: 'edgeMode',
  elevation: 'elevation',
  enablebackground: 'enableBackground',
  'enable-background': 'enableBackground',
  end: 'end',
  exponent: 'exponent',
  externalresourcesrequired: 'externalResourcesRequired',
  fill: 'fill',
  fillopacity: 'fillOpacity',
  'fill-opacity': 'fillOpacity',
  fillrule: 'fillRule',
  'fill-rule': 'fillRule',
  filter: 'filter',
  filterres: 'filterRes',
  filterunits: 'filterUnits',
  floodopacity: 'floodOpacity',
  'flood-opacity': 'floodOpacity',
  floodcolor: 'floodColor',
  'flood-color': 'floodColor',
  focusable: 'focusable',
  fontfamily: 'fontFamily',
  'font-family': 'fontFamily',
  fontsize: 'fontSize',
  'font-size': 'fontSize',
  fontsizeadjust: 'fontSizeAdjust',
  'font-size-adjust': 'fontSizeAdjust',
  fontstretch: 'fontStretch',
  'font-stretch': 'fontStretch',
  fontstyle: 'fontStyle',
  'font-style': 'fontStyle',
  fontvariant: 'fontVariant',
  'font-variant': 'fontVariant',
  fontweight: 'fontWeight',
  'font-weight': 'fontWeight',
  format: 'format',
  from: 'from',
  fx: 'fx',
  fy: 'fy',
  g1: 'g1',
  g2: 'g2',
  glyphname: 'glyphName',
  'glyph-name': 'glyphName',
  glyphorientationhorizontal: 'glyphOrientationHorizontal',
  'glyph-orientation-horizontal': 'glyphOrientationHorizontal',
  glyphorientationvertical: 'glyphOrientationVertical',
  'glyph-orientation-vertical': 'glyphOrientationVertical',
  glyphref: 'glyphRef',
  gradienttransform: 'gradientTransform',
  gradientunits: 'gradientUnits',
  hanging: 'hanging',
  horizadvx: 'horizAdvX',
  'horiz-adv-x': 'horizAdvX',
  horizoriginx: 'horizOriginX',
  'horiz-origin-x': 'horizOriginX',
  ideographic: 'ideographic',
  imagerendering: 'imageRendering',
  'image-rendering': 'imageRendering',
  in2: 'in2',
  'in': 'in',
  inlist: 'inlist',
  intercept: 'intercept',
  k1: 'k1',
  k2: 'k2',
  k3: 'k3',
  k4: 'k4',
  k: 'k',
  kernelmatrix: 'kernelMatrix',
  kernelunitlength: 'kernelUnitLength',
  kerning: 'kerning',
  keypoints: 'keyPoints',
  keysplines: 'keySplines',
  keytimes: 'keyTimes',
  lengthadjust: 'lengthAdjust',
  letterspacing: 'letterSpacing',
  'letter-spacing': 'letterSpacing',
  lightingcolor: 'lightingColor',
  'lighting-color': 'lightingColor',
  limitingconeangle: 'limitingConeAngle',
  local: 'local',
  markerend: 'markerEnd',
  'marker-end': 'markerEnd',
  markerheight: 'markerHeight',
  markermid: 'markerMid',
  'marker-mid': 'markerMid',
  markerstart: 'markerStart',
  'marker-start': 'markerStart',
  markerunits: 'markerUnits',
  markerwidth: 'markerWidth',
  mask: 'mask',
  maskcontentunits: 'maskContentUnits',
  maskunits: 'maskUnits',
  mathematical: 'mathematical',
  mode: 'mode',
  numoctaves: 'numOctaves',
  offset: 'offset',
  opacity: 'opacity',
  operator: 'operator',
  order: 'order',
  orient: 'orient',
  orientation: 'orientation',
  origin: 'origin',
  overflow: 'overflow',
  overlineposition: 'overlinePosition',
  'overline-position': 'overlinePosition',
  overlinethickness: 'overlineThickness',
  'overline-thickness': 'overlineThickness',
  paintorder: 'paintOrder',
  'paint-order': 'paintOrder',
  panose1: 'panose1',
  'panose-1': 'panose1',
  pathlength: 'pathLength',
  patterncontentunits: 'patternContentUnits',
  patterntransform: 'patternTransform',
  patternunits: 'patternUnits',
  pointerevents: 'pointerEvents',
  'pointer-events': 'pointerEvents',
  points: 'points',
  pointsatx: 'pointsAtX',
  pointsaty: 'pointsAtY',
  pointsatz: 'pointsAtZ',
  prefix: 'prefix',
  preservealpha: 'preserveAlpha',
  preserveaspectratio: 'preserveAspectRatio',
  primitiveunits: 'primitiveUnits',
  property: 'property',
  r: 'r',
  radius: 'radius',
  refx: 'refX',
  refy: 'refY',
  renderingintent: 'renderingIntent',
  'rendering-intent': 'renderingIntent',
  repeatcount: 'repeatCount',
  repeatdur: 'repeatDur',
  requiredextensions: 'requiredExtensions',
  requiredfeatures: 'requiredFeatures',
  resource: 'resource',
  restart: 'restart',
  result: 'result',
  results: 'results',
  rotate: 'rotate',
  rx: 'rx',
  ry: 'ry',
  scale: 'scale',
  security: 'security',
  seed: 'seed',
  shaperendering: 'shapeRendering',
  'shape-rendering': 'shapeRendering',
  slope: 'slope',
  spacing: 'spacing',
  specularconstant: 'specularConstant',
  specularexponent: 'specularExponent',
  speed: 'speed',
  spreadmethod: 'spreadMethod',
  startoffset: 'startOffset',
  stddeviation: 'stdDeviation',
  stemh: 'stemh',
  stemv: 'stemv',
  stitchtiles: 'stitchTiles',
  stopcolor: 'stopColor',
  'stop-color': 'stopColor',
  stopopacity: 'stopOpacity',
  'stop-opacity': 'stopOpacity',
  strikethroughposition: 'strikethroughPosition',
  'strikethrough-position': 'strikethroughPosition',
  strikethroughthickness: 'strikethroughThickness',
  'strikethrough-thickness': 'strikethroughThickness',
  string: 'string',
  stroke: 'stroke',
  strokedasharray: 'strokeDasharray',
  'stroke-dasharray': 'strokeDasharray',
  strokedashoffset: 'strokeDashoffset',
  'stroke-dashoffset': 'strokeDashoffset',
  strokelinecap: 'strokeLinecap',
  'stroke-linecap': 'strokeLinecap',
  strokelinejoin: 'strokeLinejoin',
  'stroke-linejoin': 'strokeLinejoin',
  strokemiterlimit: 'strokeMiterlimit',
  'stroke-miterlimit': 'strokeMiterlimit',
  strokewidth: 'strokeWidth',
  'stroke-width': 'strokeWidth',
  strokeopacity: 'strokeOpacity',
  'stroke-opacity': 'strokeOpacity',
  suppresscontenteditablewarning: 'suppressContentEditableWarning',
  suppresshydrationwarning: 'suppressHydrationWarning',
  surfacescale: 'surfaceScale',
  systemlanguage: 'systemLanguage',
  tablevalues: 'tableValues',
  targetx: 'targetX',
  targety: 'targetY',
  textanchor: 'textAnchor',
  'text-anchor': 'textAnchor',
  textdecoration: 'textDecoration',
  'text-decoration': 'textDecoration',
  textlength: 'textLength',
  textrendering: 'textRendering',
  'text-rendering': 'textRendering',
  to: 'to',
  transform: 'transform',
  'typeof': 'typeof',
  u1: 'u1',
  u2: 'u2',
  underlineposition: 'underlinePosition',
  'underline-position': 'underlinePosition',
  underlinethickness: 'underlineThickness',
  'underline-thickness': 'underlineThickness',
  unicode: 'unicode',
  unicodebidi: 'unicodeBidi',
  'unicode-bidi': 'unicodeBidi',
  unicoderange: 'unicodeRange',
  'unicode-range': 'unicodeRange',
  unitsperem: 'unitsPerEm',
  'units-per-em': 'unitsPerEm',
  unselectable: 'unselectable',
  valphabetic: 'vAlphabetic',
  'v-alphabetic': 'vAlphabetic',
  values: 'values',
  vectoreffect: 'vectorEffect',
  'vector-effect': 'vectorEffect',
  version: 'version',
  vertadvy: 'vertAdvY',
  'vert-adv-y': 'vertAdvY',
  vertoriginx: 'vertOriginX',
  'vert-origin-x': 'vertOriginX',
  vertoriginy: 'vertOriginY',
  'vert-origin-y': 'vertOriginY',
  vhanging: 'vHanging',
  'v-hanging': 'vHanging',
  videographic: 'vIdeographic',
  'v-ideographic': 'vIdeographic',
  viewbox: 'viewBox',
  viewtarget: 'viewTarget',
  visibility: 'visibility',
  vmathematical: 'vMathematical',
  'v-mathematical': 'vMathematical',
  vocab: 'vocab',
  widths: 'widths',
  wordspacing: 'wordSpacing',
  'word-spacing': 'wordSpacing',
  writingmode: 'writingMode',
  'writing-mode': 'writingMode',
  x1: 'x1',
  x2: 'x2',
  x: 'x',
  xchannelselector: 'xChannelSelector',
  xheight: 'xHeight',
  'x-height': 'xHeight',
  xlinkactuate: 'xlinkActuate',
  'xlink:actuate': 'xlinkActuate',
  xlinkarcrole: 'xlinkArcrole',
  'xlink:arcrole': 'xlinkArcrole',
  xlinkhref: 'xlinkHref',
  'xlink:href': 'xlinkHref',
  xlinkrole: 'xlinkRole',
  'xlink:role': 'xlinkRole',
  xlinkshow: 'xlinkShow',
  'xlink:show': 'xlinkShow',
  xlinktitle: 'xlinkTitle',
  'xlink:title': 'xlinkTitle',
  xlinktype: 'xlinkType',
  'xlink:type': 'xlinkType',
  xmlbase: 'xmlBase',
  'xml:base': 'xmlBase',
  xmllang: 'xmlLang',
  'xml:lang': 'xmlLang',
  xmlns: 'xmlns',
  'xml:space': 'xmlSpace',
  xmlnsxlink: 'xmlnsXlink',
  'xmlns:xlink': 'xmlnsXlink',
  xmlspace: 'xmlSpace',
  y1: 'y1',
  y2: 'y2',
  y: 'y',
  ychannelselector: 'yChannelSelector',
  z: 'z',
  zoomandpan: 'zoomAndPan'
};

function getStackAddendum$2() {
  var stack = ReactDebugCurrentFrame.getStackAddendum();
  return stack != null ? stack : '';
}

{
  var warnedProperties$1 = {};
  var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
  var EVENT_NAME_REGEX = /^on./;
  var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
  var rARIA$1 = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
  var rARIACamel$1 = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');

  var validateProperty$1 = function (tagName, name, value, canUseEventSystem) {
    if (hasOwnProperty$1.call(warnedProperties$1, name) && warnedProperties$1[name]) {
      return true;
    }

    var lowerCasedName = name.toLowerCase();
    if (lowerCasedName === 'onfocusin' || lowerCasedName === 'onfocusout') {
      warning(false, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.');
      warnedProperties$1[name] = true;
      return true;
    }

    // We can't rely on the event system being injected on the server.
    if (canUseEventSystem) {
      if (registrationNameModules.hasOwnProperty(name)) {
        return true;
      }
      var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
      if (registrationName != null) {
        warning(false, 'Invalid event handler property `%s`. Did you mean `%s`?%s', name, registrationName, getStackAddendum$2());
        warnedProperties$1[name] = true;
        return true;
      }
      if (EVENT_NAME_REGEX.test(name)) {
        warning(false, 'Unknown event handler property `%s`. It will be ignored.%s', name, getStackAddendum$2());
        warnedProperties$1[name] = true;
        return true;
      }
    } else if (EVENT_NAME_REGEX.test(name)) {
      // If no event plugins have been injected, we are in a server environment.
      // So we can't tell if the event name is correct for sure, but we can filter
      // out known bad ones like `onclick`. We can't suggest a specific replacement though.
      if (INVALID_EVENT_NAME_REGEX.test(name)) {
        warning(false, 'Invalid event handler property `%s`. ' + 'React events use the camelCase naming convention, for example `onClick`.%s', name, getStackAddendum$2());
      }
      warnedProperties$1[name] = true;
      return true;
    }

    // Let the ARIA attribute hook validate ARIA attributes
    if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
      return true;
    }

    if (lowerCasedName === 'innerhtml') {
      warning(false, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.');
      warnedProperties$1[name] = true;
      return true;
    }

    if (lowerCasedName === 'aria') {
      warning(false, 'The `aria` attribute is reserved for future use in React. ' + 'Pass individual `aria-` attributes instead.');
      warnedProperties$1[name] = true;
      return true;
    }

    if (lowerCasedName === 'is' && value !== null && value !== undefined && typeof value !== 'string') {
      warning(false, 'Received a `%s` for a string attribute `is`. If this is expected, cast ' + 'the value to a string.%s', typeof value, getStackAddendum$2());
      warnedProperties$1[name] = true;
      return true;
    }

    if (typeof value === 'number' && isNaN(value)) {
      warning(false, 'Received NaN for the `%s` attribute. If this is expected, cast ' + 'the value to a string.%s', name, getStackAddendum$2());
      warnedProperties$1[name] = true;
      return true;
    }

    var isReserved = isReservedProp(name);

    // Known attributes should match the casing specified in the property config.
    if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
      var standardName = possibleStandardNames[lowerCasedName];
      if (standardName !== name) {
        warning(false, 'Invalid DOM property `%s`. Did you mean `%s`?%s', name, standardName, getStackAddendum$2());
        warnedProperties$1[name] = true;
        return true;
      }
    } else if (!isReserved && name !== lowerCasedName) {
      // Unknown attributes should have lowercase casing since that's how they
      // will be cased anyway with server rendering.
      warning(false, 'React does not recognize the `%s` prop on a DOM element. If you ' + 'intentionally want it to appear in the DOM as a custom ' + 'attribute, spell it as lowercase `%s` instead. ' + 'If you accidentally passed it from a parent component, remove ' + 'it from the DOM element.%s', name, lowerCasedName, getStackAddendum$2());
      warnedProperties$1[name] = true;
      return true;
    }

    if (typeof value === 'boolean' && !shouldAttributeAcceptBooleanValue(name)) {
      if (value) {
        warning(false, 'Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.%s', value, name, name, value, name, getStackAddendum$2());
      } else {
        warning(false, 'Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.\n\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.%s', value, name, name, value, name, name, name, getStackAddendum$2());
      }
      warnedProperties$1[name] = true;
      return true;
    }

    // Now that we've validated casing, do not validate
    // data types for reserved props
    if (isReserved) {
      return true;
    }

    // Warn when a known attribute is a bad type
    if (!shouldSetAttribute(name, value)) {
      warnedProperties$1[name] = true;
      return false;
    }

    return true;
  };
}

var warnUnknownProperties = function (type, props, canUseEventSystem) {
  var unknownProps = [];
  for (var key in props) {
    var isValid = validateProperty$1(type, key, props[key], canUseEventSystem);
    if (!isValid) {
      unknownProps.push(key);
    }
  }

  var unknownPropString = unknownProps.map(function (prop) {
    return '`' + prop + '`';
  }).join(', ');
  if (unknownProps.length === 1) {
    warning(false, 'Invalid value for prop %s on <%s> tag. Either remove it from the element, ' + 'or pass a string or number value to keep it in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior%s', unknownPropString, type, getStackAddendum$2());
  } else if (unknownProps.length > 1) {
    warning(false, 'Invalid values for props %s on <%s> tag. Either remove them from the element, ' + 'or pass a string or number value to keep them in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior%s', unknownPropString, type, getStackAddendum$2());
  }
};

function validateProperties$2(type, props, canUseEventSystem) {
  if (isCustomComponent(type, props)) {
    return;
  }
  warnUnknownProperties(type, props, canUseEventSystem);
}

// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$1 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;
var getCurrentFiberStackAddendum$2 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;

var didWarnInvalidHydration = false;
var didWarnShadyDOM = false;

var DANGEROUSLY_SET_INNER_HTML = 'dangerouslySetInnerHTML';
var SUPPRESS_CONTENT_EDITABLE_WARNING = 'suppressContentEditableWarning';
var SUPPRESS_HYDRATION_WARNING$1 = 'suppressHydrationWarning';
var AUTOFOCUS = 'autoFocus';
var CHILDREN = 'children';
var STYLE = 'style';
var HTML = '__html';

var HTML_NAMESPACE = Namespaces.html;


var getStack = emptyFunction.thatReturns('');

{
  getStack = getCurrentFiberStackAddendum$2;

  var warnedUnknownTags = {
    // Chrome is the only major browser not shipping <time>. But as of July
    // 2017 it intends to ship it due to widespread usage. We intentionally
    // *don't* warn for <time> even if it's unrecognized by Chrome because
    // it soon will be, and many apps have been using it anyway.
    time: true,
    // There are working polyfills for <dialog>. Let people use it.
    dialog: true
  };

  var validatePropertiesInDevelopment = function (type, props) {
    validateProperties(type, props);
    validateProperties$1(type, props);
    validateProperties$2(type, props, /* canUseEventSystem */true);
  };

  // HTML parsing normalizes CR and CRLF to LF.
  // It also can turn \u0000 into \uFFFD inside attributes.
  // https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream
  // If we have a mismatch, it might be caused by that.
  // We will still patch up in this case but not fire the warning.
  var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
  var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;

  var normalizeMarkupForTextOrAttribute = function (markup) {
    var markupString = typeof markup === 'string' ? markup : '' + markup;
    return markupString.replace(NORMALIZE_NEWLINES_REGEX, '\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, '');
  };

  var warnForTextDifference = function (serverText, clientText) {
    if (didWarnInvalidHydration) {
      return;
    }
    var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
    var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
    if (normalizedServerText === normalizedClientText) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
  };

  var warnForPropDifference = function (propName, serverValue, clientValue) {
    if (didWarnInvalidHydration) {
      return;
    }
    var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
    var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
    if (normalizedServerValue === normalizedClientValue) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Prop `%s` did not match. Server: %s Client: %s', propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
  };

  var warnForExtraAttributes = function (attributeNames) {
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    var names = [];
    attributeNames.forEach(function (name) {
      names.push(name);
    });
    warning(false, 'Extra attributes from the server: %s', names);
  };

  var warnForInvalidEventListener = function (registrationName, listener) {
    if (listener === false) {
      warning(false, 'Expected `%s` listener to be a function, instead got `false`.\n\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.%s', registrationName, registrationName, registrationName, getCurrentFiberStackAddendum$2());
    } else {
      warning(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.%s', registrationName, typeof listener, getCurrentFiberStackAddendum$2());
    }
  };

  // Parse the HTML and read it back to normalize the HTML string so that it
  // can be used for comparison.
  var normalizeHTML = function (parent, html) {
    // We could have created a separate document here to avoid
    // re-initializing custom elements if they exist. But this breaks
    // how <noscript> is being handled. So we use the same document.
    // See the discussion in https://github.com/facebook/react/pull/11157.
    var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
    testElement.innerHTML = html;
    return testElement.innerHTML;
  };
}

function ensureListeningTo(rootContainerElement, registrationName) {
  var isDocumentOrFragment = rootContainerElement.nodeType === DOCUMENT_NODE || rootContainerElement.nodeType === DOCUMENT_FRAGMENT_NODE;
  var doc = isDocumentOrFragment ? rootContainerElement : rootContainerElement.ownerDocument;
  listenTo(registrationName, doc);
}

function getOwnerDocumentFromRootContainer(rootContainerElement) {
  return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
}

// There are so many media events, it makes sense to just
// maintain a list rather than create a `trapBubbledEvent` for each
var mediaEvents = {
  topAbort: 'abort',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topLoadedData: 'loadeddata',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTimeUpdate: 'timeupdate',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting'
};

function trapClickOnNonInteractiveElement(node) {
  // Mobile Safari does not fire properly bubble click events on
  // non-interactive elements, which means delegated click listeners do not
  // fire. The workaround for this bug involves attaching an empty click
  // listener on the target node.
  // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
  // Just set it using the onclick property so that we don't have to manage any
  // bookkeeping for it. Not sure if we need to clear it when the listener is
  // removed.
  // TODO: Only do this for the relevant Safaris maybe?
  node.onclick = emptyFunction;
}

function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
  for (var propKey in nextProps) {
    if (!nextProps.hasOwnProperty(propKey)) {
      continue;
    }
    var nextProp = nextProps[propKey];
    if (propKey === STYLE) {
      {
        if (nextProp) {
          // Freeze the next style object so that we can assume it won't be
          // mutated. We have already warned for this in the past.
          Object.freeze(nextProp);
        }
      }
      // Relies on `updateStylesByID` not mutating `styleUpdates`.
      setValueForStyles(domElement, nextProp, getStack);
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      var nextHtml = nextProp ? nextProp[HTML] : undefined;
      if (nextHtml != null) {
        setInnerHTML(domElement, nextHtml);
      }
    } else if (propKey === CHILDREN) {
      if (typeof nextProp === 'string') {
        // Avoid setting initial textContent when the text is empty. In IE11 setting
        // textContent on a <textarea> will cause the placeholder to not
        // show within the <textarea> until it has been focused and blurred again.
        // https://github.com/facebook/react/issues/6731#issuecomment-254874553
        var canSetTextContent = tag !== 'textarea' || nextProp !== '';
        if (canSetTextContent) {
          setTextContent(domElement, nextProp);
        }
      } else if (typeof nextProp === 'number') {
        setTextContent(domElement, '' + nextProp);
      }
    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {
      // Noop
    } else if (propKey === AUTOFOCUS) {
      // We polyfill it separately on the client during commit.
      // We blacklist it here rather than in the property list because we emit it in SSR.
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        if (true && typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }
        ensureListeningTo(rootContainerElement, propKey);
      }
    } else if (isCustomComponentTag) {
      setValueForAttribute(domElement, propKey, nextProp);
    } else if (nextProp != null) {
      // If we're updating to null or undefined, we should remove the property
      // from the DOM node instead of inadvertently setting to a string. This
      // brings us in line with the same behavior we have on initial render.
      setValueForProperty(domElement, propKey, nextProp);
    }
  }
}

function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
  // TODO: Handle wasCustomComponentTag
  for (var i = 0; i < updatePayload.length; i += 2) {
    var propKey = updatePayload[i];
    var propValue = updatePayload[i + 1];
    if (propKey === STYLE) {
      setValueForStyles(domElement, propValue, getStack);
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      setInnerHTML(domElement, propValue);
    } else if (propKey === CHILDREN) {
      setTextContent(domElement, propValue);
    } else if (isCustomComponentTag) {
      if (propValue != null) {
        setValueForAttribute(domElement, propKey, propValue);
      } else {
        deleteValueForAttribute(domElement, propKey);
      }
    } else if (propValue != null) {
      setValueForProperty(domElement, propKey, propValue);
    } else {
      // If we're updating to null or undefined, we should remove the property
      // from the DOM node instead of inadvertently setting to a string. This
      // brings us in line with the same behavior we have on initial render.
      deleteValueForProperty(domElement, propKey);
    }
  }
}

function createElement$1(type, props, rootContainerElement, parentNamespace) {
  // We create tags in the namespace of their parent container, except HTML
  var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
  var domElement;
  var namespaceURI = parentNamespace;
  if (namespaceURI === HTML_NAMESPACE) {
    namespaceURI = getIntrinsicNamespace(type);
  }
  if (namespaceURI === HTML_NAMESPACE) {
    {
      var isCustomComponentTag = isCustomComponent(type, props);
      // Should this check be gated by parent namespace? Not sure we want to
      // allow <SVG> or <mATH>.
      warning(isCustomComponentTag || type === type.toLowerCase(), '<%s /> is using uppercase HTML. Always use lowercase HTML tags ' + 'in React.', type);
    }

    if (type === 'script') {
      // Create the script via .innerHTML so its "parser-inserted" flag is
      // set to true and it does not execute
      var div = ownerDocument.createElement('div');
      div.innerHTML = '<script><' + '/script>'; // eslint-disable-line
      // This is guaranteed to yield a script element.
      var firstChild = div.firstChild;
      domElement = div.removeChild(firstChild);
    } else if (typeof props.is === 'string') {
      // $FlowIssue `createElement` should be updated for Web Components
      domElement = ownerDocument.createElement(type, { is: props.is });
    } else {
      // Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.
      // See discussion in https://github.com/facebook/react/pull/6896
      // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
      domElement = ownerDocument.createElement(type);
    }
  } else {
    domElement = ownerDocument.createElementNS(namespaceURI, type);
  }

  {
    if (namespaceURI === HTML_NAMESPACE) {
      if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === '[object HTMLUnknownElement]' && !Object.prototype.hasOwnProperty.call(warnedUnknownTags, type)) {
        warnedUnknownTags[type] = true;
        warning(false, 'The tag <%s> is unrecognized in this browser. ' + 'If you meant to render a React component, start its name with ' + 'an uppercase letter.', type);
      }
    }
  }

  return domElement;
}

function createTextNode$1(text, rootContainerElement) {
  return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
}

function setInitialProperties$1(domElement, tag, rawProps, rootContainerElement) {
  var isCustomComponentTag = isCustomComponent(tag, rawProps);
  {
    validatePropertiesInDevelopment(tag, rawProps);
    if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {
      warning(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerName$1() || 'A component');
      didWarnShadyDOM = true;
    }
  }

  // TODO: Make sure that we check isMounted before firing any of these events.
  var props;
  switch (tag) {
    case 'iframe':
    case 'object':
      trapBubbledEvent('topLoad', 'load', domElement);
      props = rawProps;
      break;
    case 'video':
    case 'audio':
      // Create listener for each media event
      for (var event in mediaEvents) {
        if (mediaEvents.hasOwnProperty(event)) {
          trapBubbledEvent(event, mediaEvents[event], domElement);
        }
      }
      props = rawProps;
      break;
    case 'source':
      trapBubbledEvent('topError', 'error', domElement);
      props = rawProps;
      break;
    case 'img':
    case 'image':
      trapBubbledEvent('topError', 'error', domElement);
      trapBubbledEvent('topLoad', 'load', domElement);
      props = rawProps;
      break;
    case 'form':
      trapBubbledEvent('topReset', 'reset', domElement);
      trapBubbledEvent('topSubmit', 'submit', domElement);
      props = rawProps;
      break;
    case 'details':
      trapBubbledEvent('topToggle', 'toggle', domElement);
      props = rawProps;
      break;
    case 'input':
      initWrapperState(domElement, rawProps);
      props = getHostProps(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    case 'option':
      validateProps(domElement, rawProps);
      props = getHostProps$1(domElement, rawProps);
      break;
    case 'select':
      initWrapperState$1(domElement, rawProps);
      props = getHostProps$2(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    case 'textarea':
      initWrapperState$2(domElement, rawProps);
      props = getHostProps$3(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    default:
      props = rawProps;
  }

  assertValidProps(tag, props, getStack);

  setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);

  switch (tag) {
    case 'input':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper(domElement, rawProps);
      break;
    case 'textarea':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper$3(domElement, rawProps);
      break;
    case 'option':
      postMountWrapper$1(domElement, rawProps);
      break;
    case 'select':
      postMountWrapper$2(domElement, rawProps);
      break;
    default:
      if (typeof props.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }
      break;
  }
}

// Calculate the diff between the two objects.
function diffProperties$1(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
  {
    validatePropertiesInDevelopment(tag, nextRawProps);
  }

  var updatePayload = null;

  var lastProps;
  var nextProps;
  switch (tag) {
    case 'input':
      lastProps = getHostProps(domElement, lastRawProps);
      nextProps = getHostProps(domElement, nextRawProps);
      updatePayload = [];
      break;
    case 'option':
      lastProps = getHostProps$1(domElement, lastRawProps);
      nextProps = getHostProps$1(domElement, nextRawProps);
      updatePayload = [];
      break;
    case 'select':
      lastProps = getHostProps$2(domElement, lastRawProps);
      nextProps = getHostProps$2(domElement, nextRawProps);
      updatePayload = [];
      break;
    case 'textarea':
      lastProps = getHostProps$3(domElement, lastRawProps);
      nextProps = getHostProps$3(domElement, nextRawProps);
      updatePayload = [];
      break;
    default:
      lastProps = lastRawProps;
      nextProps = nextRawProps;
      if (typeof lastProps.onClick !== 'function' && typeof nextProps.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }
      break;
  }

  assertValidProps(tag, nextProps, getStack);

  var propKey;
  var styleName;
  var styleUpdates = null;
  for (propKey in lastProps) {
    if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
      continue;
    }
    if (propKey === STYLE) {
      var lastStyle = lastProps[propKey];
      for (styleName in lastStyle) {
        if (lastStyle.hasOwnProperty(styleName)) {
          if (!styleUpdates) {
            styleUpdates = {};
          }
          styleUpdates[styleName] = '';
        }
      }
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) {
      // Noop. This is handled by the clear text mechanism.
    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {
      // Noop
    } else if (propKey === AUTOFOCUS) {
      // Noop. It doesn't work on updates anyway.
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      // This is a special case. If any listener updates we need to ensure
      // that the "current" fiber pointer gets updated so we need a commit
      // to update this element.
      if (!updatePayload) {
        updatePayload = [];
      }
    } else {
      // For all other deleted properties we add it to the queue. We use
      // the whitelist in the commit phase instead.
      (updatePayload = updatePayload || []).push(propKey, null);
    }
  }
  for (propKey in nextProps) {
    var nextProp = nextProps[propKey];
    var lastProp = lastProps != null ? lastProps[propKey] : undefined;
    if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
      continue;
    }
    if (propKey === STYLE) {
      {
        if (nextProp) {
          // Freeze the next style object so that we can assume it won't be
          // mutated. We have already warned for this in the past.
          Object.freeze(nextProp);
        }
      }
      if (lastProp) {
        // Unset styles on `lastProp` but not on `nextProp`.
        for (styleName in lastProp) {
          if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
            if (!styleUpdates) {
              styleUpdates = {};
            }
            styleUpdates[styleName] = '';
          }
        }
        // Update styles that changed since `lastProp`.
        for (styleName in nextProp) {
          if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
            if (!styleUpdates) {
              styleUpdates = {};
            }
            styleUpdates[styleName] = nextProp[styleName];
          }
        }
      } else {
        // Relies on `updateStylesByID` not mutating `styleUpdates`.
        if (!styleUpdates) {
          if (!updatePayload) {
            updatePayload = [];
          }
          updatePayload.push(propKey, styleUpdates);
        }
        styleUpdates = nextProp;
      }
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      var nextHtml = nextProp ? nextProp[HTML] : undefined;
      var lastHtml = lastProp ? lastProp[HTML] : undefined;
      if (nextHtml != null) {
        if (lastHtml !== nextHtml) {
          (updatePayload = updatePayload || []).push(propKey, '' + nextHtml);
        }
      } else {
        // TODO: It might be too late to clear this if we have children
        // inserted already.
      }
    } else if (propKey === CHILDREN) {
      if (lastProp !== nextProp && (typeof nextProp === 'string' || typeof nextProp === 'number')) {
        (updatePayload = updatePayload || []).push(propKey, '' + nextProp);
      }
    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {
      // Noop
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        // We eagerly listen to this even though we haven't committed yet.
        if (true && typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }
        ensureListeningTo(rootContainerElement, propKey);
      }
      if (!updatePayload && lastProp !== nextProp) {
        // This is a special case. If any listener updates we need to ensure
        // that the "current" props pointer gets updated so we need a commit
        // to update this element.
        updatePayload = [];
      }
    } else {
      // For any other property we always add it to the queue and then we
      // filter it out using the whitelist during the commit.
      (updatePayload = updatePayload || []).push(propKey, nextProp);
    }
  }
  if (styleUpdates) {
    (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
  }
  return updatePayload;
}

// Apply the diff.
function updateProperties$1(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
  // Update checked *before* name.
  // In the middle of an update, it is possible to have multiple checked.
  // When a checked radio tries to change name, browser makes another radio's checked false.
  if (tag === 'input' && nextRawProps.type === 'radio' && nextRawProps.name != null) {
    updateChecked(domElement, nextRawProps);
  }

  var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
  var isCustomComponentTag = isCustomComponent(tag, nextRawProps);
  // Apply the diff.
  updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);

  // TODO: Ensure that an update gets scheduled if any of the special props
  // changed.
  switch (tag) {
    case 'input':
      // Update the wrapper around inputs *after* updating props. This has to
      // happen after `updateDOMProperties`. Otherwise HTML5 input validations
      // raise warnings and prevent the new value from being assigned.
      updateWrapper(domElement, nextRawProps);
      break;
    case 'textarea':
      updateWrapper$1(domElement, nextRawProps);
      break;
    case 'select':
      // <select> value update needs to occur after <option> children
      // reconciliation
      postUpdateWrapper(domElement, nextRawProps);
      break;
  }
}

function diffHydratedProperties$1(domElement, tag, rawProps, parentNamespace, rootContainerElement) {
  {
    var suppressHydrationWarning = rawProps[SUPPRESS_HYDRATION_WARNING$1] === true;
    var isCustomComponentTag = isCustomComponent(tag, rawProps);
    validatePropertiesInDevelopment(tag, rawProps);
    if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {
      warning(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerName$1() || 'A component');
      didWarnShadyDOM = true;
    }
  }

  // TODO: Make sure that we check isMounted before firing any of these events.
  switch (tag) {
    case 'iframe':
    case 'object':
      trapBubbledEvent('topLoad', 'load', domElement);
      break;
    case 'video':
    case 'audio':
      // Create listener for each media event
      for (var event in mediaEvents) {
        if (mediaEvents.hasOwnProperty(event)) {
          trapBubbledEvent(event, mediaEvents[event], domElement);
        }
      }
      break;
    case 'source':
      trapBubbledEvent('topError', 'error', domElement);
      break;
    case 'img':
    case 'image':
      trapBubbledEvent('topError', 'error', domElement);
      trapBubbledEvent('topLoad', 'load', domElement);
      break;
    case 'form':
      trapBubbledEvent('topReset', 'reset', domElement);
      trapBubbledEvent('topSubmit', 'submit', domElement);
      break;
    case 'details':
      trapBubbledEvent('topToggle', 'toggle', domElement);
      break;
    case 'input':
      initWrapperState(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    case 'option':
      validateProps(domElement, rawProps);
      break;
    case 'select':
      initWrapperState$1(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    case 'textarea':
      initWrapperState$2(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
  }

  assertValidProps(tag, rawProps, getStack);

  {
    var extraAttributeNames = new Set();
    var attributes = domElement.attributes;
    for (var i = 0; i < attributes.length; i++) {
      var name = attributes[i].name.toLowerCase();
      switch (name) {
        // Built-in SSR attribute is whitelisted
        case 'data-reactroot':
          break;
        // Controlled attributes are not validated
        // TODO: Only ignore them on controlled tags.
        case 'value':
          break;
        case 'checked':
          break;
        case 'selected':
          break;
        default:
          // Intentionally use the original name.
          // See discussion in https://github.com/facebook/react/pull/10676.
          extraAttributeNames.add(attributes[i].name);
      }
    }
  }

  var updatePayload = null;
  for (var propKey in rawProps) {
    if (!rawProps.hasOwnProperty(propKey)) {
      continue;
    }
    var nextProp = rawProps[propKey];
    if (propKey === CHILDREN) {
      // For text content children we compare against textContent. This
      // might match additional HTML that is hidden when we read it using
      // textContent. E.g. "foo" will match "f<span>oo</span>" but that still
      // satisfies our requirement. Our requirement is not to produce perfect
      // HTML and attributes. Ideally we should preserve structure but it's
      // ok not to if the visible content is still enough to indicate what
      // even listeners these nodes might be wired up to.
      // TODO: Warn if there is more than a single textNode as a child.
      // TODO: Should we use domElement.firstChild.nodeValue to compare?
      if (typeof nextProp === 'string') {
        if (domElement.textContent !== nextProp) {
          if (true && !suppressHydrationWarning) {
            warnForTextDifference(domElement.textContent, nextProp);
          }
          updatePayload = [CHILDREN, nextProp];
        }
      } else if (typeof nextProp === 'number') {
        if (domElement.textContent !== '' + nextProp) {
          if (true && !suppressHydrationWarning) {
            warnForTextDifference(domElement.textContent, nextProp);
          }
          updatePayload = [CHILDREN, '' + nextProp];
        }
      }
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        if (true && typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }
        ensureListeningTo(rootContainerElement, propKey);
      }
    } else {
      // Validate that the properties correspond to their expected values.
      var serverValue;
      var propertyInfo;
      if (suppressHydrationWarning) {
        // Don't bother comparing. We're ignoring all these warnings.
      } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1 ||
      // Controlled attributes are not validated
      // TODO: Only ignore them on controlled tags.
      propKey === 'value' || propKey === 'checked' || propKey === 'selected') {
        // Noop
      } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
        var rawHtml = nextProp ? nextProp[HTML] || '' : '';
        var serverHTML = domElement.innerHTML;
        var expectedHTML = normalizeHTML(domElement, rawHtml);
        if (expectedHTML !== serverHTML) {
          warnForPropDifference(propKey, serverHTML, expectedHTML);
        }
      } else if (propKey === STYLE) {
        // $FlowFixMe - Should be inferred as not undefined.
        extraAttributeNames['delete'](propKey);
        var expectedStyle = createDangerousStringForStyles(nextProp);
        serverValue = domElement.getAttribute('style');
        if (expectedStyle !== serverValue) {
          warnForPropDifference(propKey, serverValue, expectedStyle);
        }
      } else if (isCustomComponentTag) {
        // $FlowFixMe - Should be inferred as not undefined.
        extraAttributeNames['delete'](propKey.toLowerCase());
        serverValue = getValueForAttribute(domElement, propKey, nextProp);

        if (nextProp !== serverValue) {
          warnForPropDifference(propKey, serverValue, nextProp);
        }
      } else if (shouldSetAttribute(propKey, nextProp)) {
        if (propertyInfo = getPropertyInfo(propKey)) {
          // $FlowFixMe - Should be inferred as not undefined.
          extraAttributeNames['delete'](propertyInfo.attributeName);
          serverValue = getValueForProperty(domElement, propKey, nextProp);
        } else {
          var ownNamespace = parentNamespace;
          if (ownNamespace === HTML_NAMESPACE) {
            ownNamespace = getIntrinsicNamespace(tag);
          }
          if (ownNamespace === HTML_NAMESPACE) {
            // $FlowFixMe - Should be inferred as not undefined.
            extraAttributeNames['delete'](propKey.toLowerCase());
          } else {
            // $FlowFixMe - Should be inferred as not undefined.
            extraAttributeNames['delete'](propKey);
          }
          serverValue = getValueForAttribute(domElement, propKey, nextProp);
        }

        if (nextProp !== serverValue) {
          warnForPropDifference(propKey, serverValue, nextProp);
        }
      }
    }
  }

  {
    // $FlowFixMe - Should be inferred as not undefined.
    if (extraAttributeNames.size > 0 && !suppressHydrationWarning) {
      // $FlowFixMe - Should be inferred as not undefined.
      warnForExtraAttributes(extraAttributeNames);
    }
  }

  switch (tag) {
    case 'input':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper(domElement, rawProps);
      break;
    case 'textarea':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper$3(domElement, rawProps);
      break;
    case 'select':
    case 'option':
      // For input and textarea we current always set the value property at
      // post mount to force it to diverge from attributes. However, for
      // option and select we don't quite do the same thing and select
      // is not resilient to the DOM state changing so we don't do that here.
      // TODO: Consider not doing this for input and textarea.
      break;
    default:
      if (typeof rawProps.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }
      break;
  }

  return updatePayload;
}

function diffHydratedText$1(textNode, text) {
  var isDifferent = textNode.nodeValue !== text;
  return isDifferent;
}

function warnForUnmatchedText$1(textNode, text) {
  {
    warnForTextDifference(textNode.nodeValue, text);
  }
}

function warnForDeletedHydratableElement$1(parentNode, child) {
  {
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Did not expect server HTML to contain a <%s> in <%s>.', child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
  }
}

function warnForDeletedHydratableText$1(parentNode, child) {
  {
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
  }
}

function warnForInsertedHydratedElement$1(parentNode, tag, props) {
  {
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Expected server HTML to contain a matching <%s> in <%s>.', tag, parentNode.nodeName.toLowerCase());
  }
}

function warnForInsertedHydratedText$1(parentNode, text) {
  {
    if (text === '') {
      // We expect to insert empty text nodes since they're not represented in
      // the HTML.
      // TODO: Remove this special case if we can just avoid inserting empty
      // text nodes.
      return;
    }
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Expected server HTML to contain a matching text node for "%s" in <%s>.', text, parentNode.nodeName.toLowerCase());
  }
}

function restoreControlledState(domElement, tag, props) {
  switch (tag) {
    case 'input':
      restoreControlledState$1(domElement, props);
      return;
    case 'textarea':
      restoreControlledState$3(domElement, props);
      return;
    case 'select':
      restoreControlledState$2(domElement, props);
      return;
  }
}

var ReactDOMFiberComponent = Object.freeze({
	createElement: createElement$1,
	createTextNode: createTextNode$1,
	setInitialProperties: setInitialProperties$1,
	diffProperties: diffProperties$1,
	updateProperties: updateProperties$1,
	diffHydratedProperties: diffHydratedProperties$1,
	diffHydratedText: diffHydratedText$1,
	warnForUnmatchedText: warnForUnmatchedText$1,
	warnForDeletedHydratableElement: warnForDeletedHydratableElement$1,
	warnForDeletedHydratableText: warnForDeletedHydratableText$1,
	warnForInsertedHydratedElement: warnForInsertedHydratedElement$1,
	warnForInsertedHydratedText: warnForInsertedHydratedText$1,
	restoreControlledState: restoreControlledState
});

// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberStackAddendum$6 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;

var validateDOMNesting = emptyFunction;

{
  // This validation code was written based on the HTML5 parsing spec:
  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  //
  // Note: this does not catch all invalid nesting, nor does it try to (as it's
  // not clear what practical benefit doing so provides); instead, we warn only
  // for cases where the parser will give a parse tree differing from what React
  // intended. For example, <b><div></div></b> is invalid but we don't warn
  // because it still parses correctly; we do warn for other cases like nested
  // <p> tags where the beginning of the second element implicitly closes the
  // first, causing a confusing mess.

  // https://html.spec.whatwg.org/multipage/syntax.html#special
  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',

  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
  // TODO: Distinguish by namespace here -- for <title>, including it here
  // errs on the side of fewer warnings
  'foreignObject', 'desc', 'title'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
  var buttonScopeTags = inScopeTags.concat(['button']);

  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];

  var emptyAncestorInfo = {
    current: null,

    formTag: null,
    aTagInScope: null,
    buttonTagInScope: null,
    nobrTagInScope: null,
    pTagInButtonScope: null,

    listItemTagAutoclosing: null,
    dlItemTagAutoclosing: null
  };

  var updatedAncestorInfo$1 = function (oldInfo, tag, instance) {
    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
    var info = { tag: tag, instance: instance };

    if (inScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.aTagInScope = null;
      ancestorInfo.buttonTagInScope = null;
      ancestorInfo.nobrTagInScope = null;
    }
    if (buttonScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.pTagInButtonScope = null;
    }

    // See rules for 'li', 'dd', 'dt' start tags in
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
      ancestorInfo.listItemTagAutoclosing = null;
      ancestorInfo.dlItemTagAutoclosing = null;
    }

    ancestorInfo.current = info;

    if (tag === 'form') {
      ancestorInfo.formTag = info;
    }
    if (tag === 'a') {
      ancestorInfo.aTagInScope = info;
    }
    if (tag === 'button') {
      ancestorInfo.buttonTagInScope = info;
    }
    if (tag === 'nobr') {
      ancestorInfo.nobrTagInScope = info;
    }
    if (tag === 'p') {
      ancestorInfo.pTagInButtonScope = info;
    }
    if (tag === 'li') {
      ancestorInfo.listItemTagAutoclosing = info;
    }
    if (tag === 'dd' || tag === 'dt') {
      ancestorInfo.dlItemTagAutoclosing = info;
    }

    return ancestorInfo;
  };

  /**
   * Returns whether
   */
  var isTagValidWithParent = function (tag, parentTag) {
    // First, let's check if we're in an unusual parsing mode...
    switch (parentTag) {
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
      case 'select':
        return tag === 'option' || tag === 'optgroup' || tag === '#text';
      case 'optgroup':
        return tag === 'option' || tag === '#text';
      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
      // but
      case 'option':
        return tag === '#text';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
      // No special behavior since these rules fall back to "in body" mode for
      // all except special table nodes which cause bad parsing behavior anyway.

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
      case 'tr':
        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
      case 'tbody':
      case 'thead':
      case 'tfoot':
        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
      case 'colgroup':
        return tag === 'col' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
      case 'table':
        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
      case 'head':
        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
      case 'html':
        return tag === 'head' || tag === 'body';
      case '#document':
        return tag === 'html';
    }

    // Probably in the "in body" parsing mode, so we outlaw only tag combos
    // where the parsing rules cause implicit opens or closes to be added.
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    switch (tag) {
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

      case 'rp':
      case 'rt':
        return impliedEndTags.indexOf(parentTag) === -1;

      case 'body':
      case 'caption':
      case 'col':
      case 'colgroup':
      case 'frame':
      case 'head':
      case 'html':
      case 'tbody':
      case 'td':
      case 'tfoot':
      case 'th':
      case 'thead':
      case 'tr':
        // These tags are only valid with a few parents that have special child
        // parsing rules -- if we're down here, then none of those matched and
        // so we allow it only if we don't know what the parent is, as all other
        // cases are invalid.
        return parentTag == null;
    }

    return true;
  };

  /**
   * Returns whether
   */
  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
    switch (tag) {
      case 'address':
      case 'article':
      case 'aside':
      case 'blockquote':
      case 'center':
      case 'details':
      case 'dialog':
      case 'dir':
      case 'div':
      case 'dl':
      case 'fieldset':
      case 'figcaption':
      case 'figure':
      case 'footer':
      case 'header':
      case 'hgroup':
      case 'main':
      case 'menu':
      case 'nav':
      case 'ol':
      case 'p':
      case 'section':
      case 'summary':
      case 'ul':
      case 'pre':
      case 'listing':
      case 'table':
      case 'hr':
      case 'xmp':
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return ancestorInfo.pTagInButtonScope;

      case 'form':
        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

      case 'li':
        return ancestorInfo.listItemTagAutoclosing;

      case 'dd':
      case 'dt':
        return ancestorInfo.dlItemTagAutoclosing;

      case 'button':
        return ancestorInfo.buttonTagInScope;

      case 'a':
        // Spec says something about storing a list of markers, but it sounds
        // equivalent to this check.
        return ancestorInfo.aTagInScope;

      case 'nobr':
        return ancestorInfo.nobrTagInScope;
    }

    return null;
  };

  var didWarn = {};

  validateDOMNesting = function (childTag, childText, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.current;
    var parentTag = parentInfo && parentInfo.tag;

    if (childText != null) {
      warning(childTag == null, 'validateDOMNesting: when childText is passed, childTag should be null');
      childTag = '#text';
    }

    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
    var invalidParentOrAncestor = invalidParent || invalidAncestor;
    if (!invalidParentOrAncestor) {
      return;
    }

    var ancestorTag = invalidParentOrAncestor.tag;
    var addendum = getCurrentFiberStackAddendum$6();

    var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + addendum;
    if (didWarn[warnKey]) {
      return;
    }
    didWarn[warnKey] = true;

    var tagDisplayName = childTag;
    var whitespaceInfo = '';
    if (childTag === '#text') {
      if (/\S/.test(childText)) {
        tagDisplayName = 'Text nodes';
      } else {
        tagDisplayName = 'Whitespace text nodes';
        whitespaceInfo = " Make sure you don't have any extra whitespace between tags on " + 'each line of your source code.';
      }
    } else {
      tagDisplayName = '<' + childTag + '>';
    }

    if (invalidParent) {
      var info = '';
      if (ancestorTag === 'table' && childTag === 'tr') {
        info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
      }
      warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s%s', tagDisplayName, ancestorTag, whitespaceInfo, info, addendum);
    } else {
      warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>.%s', tagDisplayName, ancestorTag, addendum);
    }
  };

  // TODO: turn this into a named export
  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo$1;

  // For testing
  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.current;
    var parentTag = parentInfo && parentInfo.tag;
    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
  };
}

var validateDOMNesting$1 = validateDOMNesting;

// TODO: direct imports like some-package/src/* are bad. Fix me.
var createElement = createElement$1;
var createTextNode = createTextNode$1;
var setInitialProperties = setInitialProperties$1;
var diffProperties = diffProperties$1;
var updateProperties = updateProperties$1;
var diffHydratedProperties = diffHydratedProperties$1;
var diffHydratedText = diffHydratedText$1;
var warnForUnmatchedText = warnForUnmatchedText$1;
var warnForDeletedHydratableElement = warnForDeletedHydratableElement$1;
var warnForDeletedHydratableText = warnForDeletedHydratableText$1;
var warnForInsertedHydratedElement = warnForInsertedHydratedElement$1;
var warnForInsertedHydratedText = warnForInsertedHydratedText$1;
var updatedAncestorInfo = validateDOMNesting$1.updatedAncestorInfo;
var precacheFiberNode = precacheFiberNode$1;
var updateFiberProps = updateFiberProps$1;


{
  var SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';
  if (typeof Map !== 'function' || Map.prototype == null || typeof Map.prototype.forEach !== 'function' || typeof Set !== 'function' || Set.prototype == null || typeof Set.prototype.clear !== 'function' || typeof Set.prototype.forEach !== 'function') {
    warning(false, 'React depends on Map and Set built-in types. Make sure that you load a ' + 'polyfill in older browsers. http://fb.me/react-polyfills');
  }
}

injection$3.injectFiberControlledHostComponent(ReactDOMFiberComponent);

var eventsEnabled = null;
var selectionInformation = null;

/**
 * True if the supplied DOM node is a valid node element.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM is a valid DOM node.
 * @internal
 */
function isValidContainer(node) {
  return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === ' react-mount-point-unstable '));
}

function getReactRootElementInContainer(container) {
  if (!container) {
    return null;
  }

  if (container.nodeType === DOCUMENT_NODE) {
    return container.documentElement;
  } else {
    return container.firstChild;
  }
}

function shouldHydrateDueToLegacyHeuristic(container) {
  var rootElement = getReactRootElementInContainer(container);
  return !!(rootElement && rootElement.nodeType === ELEMENT_NODE && rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));
}

function shouldAutoFocusHostComponent(type, props) {
  switch (type) {
    case 'button':
    case 'input':
    case 'select':
    case 'textarea':
      return !!props.autoFocus;
  }
  return false;
}

var DOMRenderer = reactReconciler({
  getRootHostContext: function (rootContainerInstance) {
    var type = void 0;
    var namespace = void 0;
    var nodeType = rootContainerInstance.nodeType;
    switch (nodeType) {
      case DOCUMENT_NODE:
      case DOCUMENT_FRAGMENT_NODE:
        {
          type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';
          var root = rootContainerInstance.documentElement;
          namespace = root ? root.namespaceURI : getChildNamespace(null, '');
          break;
        }
      default:
        {
          var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
          var ownNamespace = container.namespaceURI || null;
          type = container.tagName;
          namespace = getChildNamespace(ownNamespace, type);
          break;
        }
    }
    {
      var validatedTag = type.toLowerCase();
      var _ancestorInfo = updatedAncestorInfo(null, validatedTag, null);
      return { namespace: namespace, ancestorInfo: _ancestorInfo };
    }
    return namespace;
  },
  getChildHostContext: function (parentHostContext, type) {
    {
      var parentHostContextDev = parentHostContext;
      var _namespace = getChildNamespace(parentHostContextDev.namespace, type);
      var _ancestorInfo2 = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type, null);
      return { namespace: _namespace, ancestorInfo: _ancestorInfo2 };
    }
    var parentNamespace = parentHostContext;
    return getChildNamespace(parentNamespace, type);
  },
  getPublicInstance: function (instance) {
    return instance;
  },
  prepareForCommit: function () {
    eventsEnabled = isEnabled();
    selectionInformation = getSelectionInformation();
    setEnabled(false);
  },
  resetAfterCommit: function () {
    restoreSelection(selectionInformation);
    selectionInformation = null;
    setEnabled(eventsEnabled);
    eventsEnabled = null;
  },
  createInstance: function (type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
    var parentNamespace = void 0;
    {
      // TODO: take namespace into account when validating.
      var hostContextDev = hostContext;
      validateDOMNesting$1(type, null, hostContextDev.ancestorInfo);
      if (typeof props.children === 'string' || typeof props.children === 'number') {
        var string = '' + props.children;
        var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type, null);
        validateDOMNesting$1(null, string, ownAncestorInfo);
      }
      parentNamespace = hostContextDev.namespace;
    }
    var domElement = createElement(type, props, rootContainerInstance, parentNamespace);
    precacheFiberNode(internalInstanceHandle, domElement);
    updateFiberProps(domElement, props);
    return domElement;
  },
  appendInitialChild: function (parentInstance, child) {
    parentInstance.appendChild(child);
  },
  finalizeInitialChildren: function (domElement, type, props, rootContainerInstance) {
    setInitialProperties(domElement, type, props, rootContainerInstance);
    return shouldAutoFocusHostComponent(type, props);
  },
  prepareUpdate: function (domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
    {
      var hostContextDev = hostContext;
      if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === 'string' || typeof newProps.children === 'number')) {
        var string = '' + newProps.children;
        var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type, null);
        validateDOMNesting$1(null, string, ownAncestorInfo);
      }
    }
    return diffProperties(domElement, type, oldProps, newProps, rootContainerInstance);
  },
  shouldSetTextContent: function (type, props) {
    return type === 'textarea' || typeof props.children === 'string' || typeof props.children === 'number' || typeof props.dangerouslySetInnerHTML === 'object' && props.dangerouslySetInnerHTML !== null && typeof props.dangerouslySetInnerHTML.__html === 'string';
  },
  shouldDeprioritizeSubtree: function (type, props) {
    return !!props.hidden;
  },
  createTextInstance: function (text, rootContainerInstance, hostContext, internalInstanceHandle) {
    {
      var hostContextDev = hostContext;
      validateDOMNesting$1(null, text, hostContextDev.ancestorInfo);
    }
    var textNode = createTextNode(text, rootContainerInstance);
    precacheFiberNode(internalInstanceHandle, textNode);
    return textNode;
  },


  now: now,

  mutation: {
    commitMount: function (domElement, type, newProps, internalInstanceHandle) {
      domElement.focus();
    },
    commitUpdate: function (domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
      // Update the props handle so that we know which props are the ones with
      // with current event handlers.
      updateFiberProps(domElement, newProps);
      // Apply the diff to the DOM node.
      updateProperties(domElement, updatePayload, type, oldProps, newProps);
    },
    resetTextContent: function (domElement) {
      domElement.textContent = '';
    },
    commitTextUpdate: function (textInstance, oldText, newText) {
      textInstance.nodeValue = newText;
    },
    appendChild: function (parentInstance, child) {
      parentInstance.appendChild(child);
    },
    appendChildToContainer: function (container, child) {
      if (container.nodeType === COMMENT_NODE) {
        container.parentNode.insertBefore(child, container);
      } else {
        container.appendChild(child);
      }
    },
    insertBefore: function (parentInstance, child, beforeChild) {
      parentInstance.insertBefore(child, beforeChild);
    },
    insertInContainerBefore: function (container, child, beforeChild) {
      if (container.nodeType === COMMENT_NODE) {
        container.parentNode.insertBefore(child, beforeChild);
      } else {
        container.insertBefore(child, beforeChild);
      }
    },
    removeChild: function (parentInstance, child) {
      parentInstance.removeChild(child);
    },
    removeChildFromContainer: function (container, child) {
      if (container.nodeType === COMMENT_NODE) {
        container.parentNode.removeChild(child);
      } else {
        container.removeChild(child);
      }
    }
  },

  hydration: {
    canHydrateInstance: function (instance, type, props) {
      if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {
        return null;
      }
      // This has now been refined to an element node.
      return instance;
    },
    canHydrateTextInstance: function (instance, text) {
      if (text === '' || instance.nodeType !== TEXT_NODE) {
        // Empty strings are not parsed by HTML so there won't be a correct match here.
        return null;
      }
      // This has now been refined to a text node.
      return instance;
    },
    getNextHydratableSibling: function (instance) {
      var node = instance.nextSibling;
      // Skip non-hydratable nodes.
      while (node && node.nodeType !== ELEMENT_NODE && node.nodeType !== TEXT_NODE) {
        node = node.nextSibling;
      }
      return node;
    },
    getFirstHydratableChild: function (parentInstance) {
      var next = parentInstance.firstChild;
      // Skip non-hydratable nodes.
      while (next && next.nodeType !== ELEMENT_NODE && next.nodeType !== TEXT_NODE) {
        next = next.nextSibling;
      }
      return next;
    },
    hydrateInstance: function (instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
      precacheFiberNode(internalInstanceHandle, instance);
      // TODO: Possibly defer this until the commit phase where all the events
      // get attached.
      updateFiberProps(instance, props);
      var parentNamespace = void 0;
      {
        var hostContextDev = hostContext;
        parentNamespace = hostContextDev.namespace;
      }
      return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance);
    },
    hydrateTextInstance: function (textInstance, text, internalInstanceHandle) {
      precacheFiberNode(internalInstanceHandle, textInstance);
      return diffHydratedText(textInstance, text);
    },
    didNotMatchHydratedContainerTextInstance: function (parentContainer, textInstance, text) {
      {
        warnForUnmatchedText(textInstance, text);
      }
    },
    didNotMatchHydratedTextInstance: function (parentType, parentProps, parentInstance, textInstance, text) {
      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
        warnForUnmatchedText(textInstance, text);
      }
    },
    didNotHydrateContainerInstance: function (parentContainer, instance) {
      {
        if (instance.nodeType === 1) {
          warnForDeletedHydratableElement(parentContainer, instance);
        } else {
          warnForDeletedHydratableText(parentContainer, instance);
        }
      }
    },
    didNotHydrateInstance: function (parentType, parentProps, parentInstance, instance) {
      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
        if (instance.nodeType === 1) {
          warnForDeletedHydratableElement(parentInstance, instance);
        } else {
          warnForDeletedHydratableText(parentInstance, instance);
        }
      }
    },
    didNotFindHydratableContainerInstance: function (parentContainer, type, props) {
      {
        warnForInsertedHydratedElement(parentContainer, type, props);
      }
    },
    didNotFindHydratableContainerTextInstance: function (parentContainer, text) {
      {
        warnForInsertedHydratedText(parentContainer, text);
      }
    },
    didNotFindHydratableInstance: function (parentType, parentProps, parentInstance, type, props) {
      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
        warnForInsertedHydratedElement(parentInstance, type, props);
      }
    },
    didNotFindHydratableTextInstance: function (parentType, parentProps, parentInstance, text) {
      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
        warnForInsertedHydratedText(parentInstance, text);
      }
    }
  },

  scheduleDeferredCallback: rIC,
  cancelDeferredCallback: cIC,

  useSyncScheduling: !enableAsyncSchedulingByDefaultInReactDOM
});

injection$4.injectFiberBatchedUpdates(DOMRenderer.batchedUpdates);

var warnedAboutHydrateAPI = false;

function renderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
  !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;

  {
    if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {
      var hostInstance = DOMRenderer.findHostInstanceWithNoPortals(container._reactRootContainer.current);
      if (hostInstance) {
        warning(hostInstance.parentNode === container, 'render(...): It looks like the React-rendered content of this ' + 'container was removed without using React. This is not ' + 'supported and will cause errors. Instead, call ' + 'ReactDOM.unmountComponentAtNode to empty a container.');
      }
    }

    var isRootRenderedBySomeReact = !!container._reactRootContainer;
    var rootEl = getReactRootElementInContainer(container);
    var hasNonRootReactChild = !!(rootEl && getInstanceFromNode$1(rootEl));

    warning(!hasNonRootReactChild || isRootRenderedBySomeReact, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.');

    warning(container.nodeType !== ELEMENT_NODE || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.');
  }

  var root = container._reactRootContainer;
  if (!root) {
    var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container);
    // First clear any existing content.
    if (!shouldHydrate) {
      var warned = false;
      var rootSibling = void 0;
      while (rootSibling = container.lastChild) {
        {
          if (!warned && rootSibling.nodeType === ELEMENT_NODE && rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) {
            warned = true;
            warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.');
          }
        }
        container.removeChild(rootSibling);
      }
    }
    {
      if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {
        warnedAboutHydrateAPI = true;
        lowPriorityWarning$1(false, 'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' + 'will stop working in React v17. Replace the ReactDOM.render() call ' + 'with ReactDOM.hydrate() if you want React to attach to the server HTML.');
      }
    }
    var newRoot = DOMRenderer.createContainer(container, shouldHydrate);
    root = container._reactRootContainer = newRoot;
    // Initial mount should not be batched.
    DOMRenderer.unbatchedUpdates(function () {
      DOMRenderer.updateContainer(children, newRoot, parentComponent, callback);
    });
  } else {
    DOMRenderer.updateContainer(children, root, parentComponent, callback);
  }
  return DOMRenderer.getPublicRootInstance(root);
}

function createPortal(children, container) {
  var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;
  // TODO: pass ReactDOM portal implementation as third argument
  return createPortal$1(children, container, null, key);
}

function ReactRoot(container, hydrate) {
  var root = DOMRenderer.createContainer(container, hydrate);
  this._reactRootContainer = root;
}
ReactRoot.prototype.render = function (children, callback) {
  var root = this._reactRootContainer;
  DOMRenderer.updateContainer(children, root, null, callback);
};
ReactRoot.prototype.unmount = function (callback) {
  var root = this._reactRootContainer;
  DOMRenderer.updateContainer(null, root, null, callback);
};

var ReactDOM = {
  createPortal: createPortal,

  findDOMNode: function (componentOrElement) {
    {
      var owner = ReactCurrentOwner.current;
      if (owner !== null) {
        var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
        warning(warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(owner) || 'A component');
        owner.stateNode._warnedAboutRefsInRender = true;
      }
    }
    if (componentOrElement == null) {
      return null;
    }
    if (componentOrElement.nodeType === ELEMENT_NODE) {
      return componentOrElement;
    }

    var inst = get(componentOrElement);
    if (inst) {
      return DOMRenderer.findHostInstance(inst);
    }

    if (typeof componentOrElement.render === 'function') {
      invariant(false, 'Unable to find node on an unmounted component.');
    } else {
      invariant(false, 'Element appears to be neither ReactComponent nor DOMNode. Keys: %s', Object.keys(componentOrElement));
    }
  },
  hydrate: function (element, container, callback) {
    // TODO: throw or warn if we couldn't hydrate?
    return renderSubtreeIntoContainer(null, element, container, true, callback);
  },
  render: function (element, container, callback) {
    return renderSubtreeIntoContainer(null, element, container, false, callback);
  },
  unstable_renderSubtreeIntoContainer: function (parentComponent, element, containerNode, callback) {
    !(parentComponent != null && has(parentComponent)) ? invariant(false, 'parentComponent must be a valid React Component') : void 0;
    return renderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
  },
  unmountComponentAtNode: function (container) {
    !isValidContainer(container) ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : void 0;

    if (container._reactRootContainer) {
      {
        var rootEl = getReactRootElementInContainer(container);
        var renderedByDifferentReact = rootEl && !getInstanceFromNode$1(rootEl);
        warning(!renderedByDifferentReact, "unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by another copy of React.');
      }

      // Unmount should not be batched.
      DOMRenderer.unbatchedUpdates(function () {
        renderSubtreeIntoContainer(null, null, container, false, function () {
          container._reactRootContainer = null;
        });
      });
      // If you call unmountComponentAtNode twice in quick succession, you'll
      // get `true` twice. That's probably fine?
      return true;
    } else {
      {
        var _rootEl = getReactRootElementInContainer(container);
        var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode$1(_rootEl));

        // Check if the container itself is a React root node.
        var isContainerReactRoot = container.nodeType === 1 && isValidContainer(container.parentNode) && !!container.parentNode._reactRootContainer;

        warning(!hasNonRootReactChild, "unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.');
      }

      return false;
    }
  },


  // Temporary alias since we already shipped React 16 RC with it.
  // TODO: remove in React 17.
  unstable_createPortal: createPortal,

  unstable_batchedUpdates: batchedUpdates,

  unstable_deferredUpdates: DOMRenderer.deferredUpdates,

  flushSync: DOMRenderer.flushSync,

  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
    // For TapEventPlugin which is popular in open source
    EventPluginHub: EventPluginHub,
    // Used by test-utils
    EventPluginRegistry: EventPluginRegistry,
    EventPropagators: EventPropagators,
    ReactControlledComponent: ReactControlledComponent,
    ReactDOMComponentTree: ReactDOMComponentTree,
    ReactDOMEventListener: ReactDOMEventListener
  }
};

if (enableCreateRoot) {
  ReactDOM.createRoot = function createRoot(container, options) {
    var hydrate = options != null && options.hydrate === true;
    return new ReactRoot(container, hydrate);
  };
}

var foundDevTools = DOMRenderer.injectIntoDevTools({
  findFiberByHostInstance: getClosestInstanceFromNode,
  bundleType: 1,
  version: ReactVersion,
  rendererPackageName: 'react-dom'
});

{
  if (!foundDevTools && ExecutionEnvironment.canUseDOM && window.top === window.self) {
    // If we're in Chrome or Firefox, provide a download link if not installed.
    if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
      var protocol = window.location.protocol;
      // Don't warn in exotic cases like chrome-extension://.
      if (/^(https?|file):$/.test(protocol)) {
        console.info('%cDownload the React DevTools ' + 'for a better development experience: ' + 'https://fb.me/react-devtools' + (protocol === 'file:' ? '\nYou might need to use a local HTTP server (instead of file://): ' + 'https://fb.me/react-devtools-faq' : ''), 'font-weight:bold');
      }
    }
  }
}



var ReactDOM$2 = Object.freeze({
	default: ReactDOM
});

var ReactDOM$3 = ( ReactDOM$2 && ReactDOM ) || ReactDOM$2;

// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var reactDom = ReactDOM$3['default'] ? ReactDOM$3['default'] : ReactDOM$3;

module.exports = reactDom;
  })();
}


/***/ }),

/***/ "./node_modules/react-dom/index.js":
/*!*****************************************!*\
  !*** ./node_modules/react-dom/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
  ) {
    return;
  }
  if (true) {
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error('^_^');
  }
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-dom.development.js */ "./node_modules/react-dom/cjs/react-dom.development.js");
}


/***/ }),

/***/ "./node_modules/react-flip-move/dist/react-flip-move.es.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react-flip-move/dist/react-flip-move.es.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);



function warnOnce(msg) {
  var hasWarned = false;
  return function () {
    if (!hasWarned) {
      console.warn(msg);
      hasWarned = true;
    }
  };
}


var statelessFunctionalComponentSupplied = warnOnce('\n>> Error, via react-flip-move <<\n\nYou provided a stateless functional component as a child to <FlipMove>. Unfortunately, SFCs aren\'t supported, because Flip Move needs access to the backing instances via refs, and SFCs don\'t have a public instance that holds that info.\n\nPlease wrap your components in a native element (eg. <div>), or a non-functional component.\n');

var primitiveNodeSupplied = warnOnce('\n>> Error, via react-flip-move <<\n\nYou provided a primitive (text or number) node as a child to <FlipMove>. Flip Move needs containers with unique keys to move children around.\n\nPlease wrap your value in a native element (eg. <span>), or a component.\n');

var invalidTypeForTimingProp = function invalidTypeForTimingProp(args
// prettier-ignore
) {
  return console.error('\n>> Error, via react-flip-move <<\n\nThe prop you provided for \'' + args.prop + '\' is invalid. It needs to be a positive integer, or a string that can be resolved to a number. The value you provided is \'' + args.value + '\'.\n\nAs a result,  the default value for this parameter will be used, which is \'' + args.defaultValue + '\'.\n');
};

var invalidEnterLeavePreset = function invalidEnterLeavePreset(args
// prettier-ignore
) {
  return console.error('\n>> Error, via react-flip-move <<\n\nThe enter/leave preset you provided is invalid. We don\'t currently have a \'' + args.value + ' preset.\'\n\nAcceptable values are ' + args.acceptableValues + '. The default value of \'' + args.defaultValue + '\' will be used.\n');
};

var parentNodePositionStatic = warnOnce('\n>> Warning, via react-flip-move <<\n\nWhen using "wrapperless" mode (by supplying \'typeName\' of \'null\'), strange things happen when the direct parent has the default "static" position.\n\nFlipMove has added \'position: relative\' to this node, to ensure Flip Move animates correctly.\n\nTo avoid seeing this warning, simply apply a non-static position to that parent node.\n');

var childIsDisabled = warnOnce('\n>> Warning, via react-flip-move <<\n\nOne or more of Flip Move\'s child elements have the html attribute \'disabled\' set to true.\n\nPlease note that this will cause animations to break in Internet Explorer 11 and below. Either remove the disabled attribute or set \'animation\' to false.\n');

var enterPresets = {
  elevator: {
    from: { transform: 'scale(0)', opacity: '0' },
    to: { transform: '', opacity: '' }
  },
  fade: {
    from: { opacity: '0' },
    to: { opacity: '' }
  },
  accordionVertical: {
    from: { transform: 'scaleY(0)', transformOrigin: 'center top' },
    to: { transform: '', transformOrigin: 'center top' }
  },
  accordionHorizontal: {
    from: { transform: 'scaleX(0)', transformOrigin: 'left center' },
    to: { transform: '', transformOrigin: 'left center' }
  },
  none: null
};
/**
 * React Flip Move | enterLeavePresets
 * (c) 2016-present Joshua Comeau
 *
 * This contains the master list of presets available for enter/leave animations,
 * along with the mapping between preset and styles.
 */


var leavePresets = {
  elevator: {
    from: { transform: 'scale(1)', opacity: '1' },
    to: { transform: 'scale(0)', opacity: '0' }
  },
  fade: {
    from: { opacity: '1' },
    to: { opacity: '0' }
  },
  accordionVertical: {
    from: { transform: 'scaleY(1)', transformOrigin: 'center top' },
    to: { transform: 'scaleY(0)', transformOrigin: 'center top' }
  },
  accordionHorizontal: {
    from: { transform: 'scaleX(1)', transformOrigin: 'left center' },
    to: { transform: 'scaleX(0)', transformOrigin: 'left center' }
  },
  none: null
};

// For now, appearPresets will be identical to enterPresets.
// Assigning a custom export in case we ever want to add appear-specific ones.
var appearPresets = enterPresets;

var defaultPreset = 'elevator';
var disablePreset = 'none';

var find = function find(predicate, arr) {
  for (var i = 0; i < arr.length; i++) {
    if (predicate(arr[i], i, arr)) {
      return arr[i];
    }
  }

  return undefined;
};


var every = function every(predicate, arr) {
  for (var i = 0; i < arr.length; i++) {
    if (!predicate(arr[i], i, arr)) {
      return false;
    }
  }
  return true;
};

// eslint-disable-next-line import/no-mutable-exports
var _isArray = function isArray(arr) {
  _isArray = Array.isArray || function (arg) {
    return Object.prototype.toString.call(arg) === '[object Array]';
  };
  return _isArray(arr);
};

var isElementAnSFC = function isElementAnSFC(element) {
  var isNativeDOMElement = typeof element.type === 'string';

  if (isNativeDOMElement) {
    return false;
  }

  return !element.type.prototype.isReactComponent;
};

function omit(obj) {
  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  var result = {};
  Object.keys(obj).forEach(function (key) {
    if (attrs.indexOf(key) === -1) {
      result[key] = obj[key];
    }
  });
  return result;
}

function arraysEqual(a, b) {
  var sameObject = a === b;
  if (sameObject) {
    return true;
  }

  var notBothArrays = !_isArray(a) || !_isArray(b);
  var differentLengths = a.length !== b.length;

  if (notBothArrays || differentLengths) {
    return false;
  }

  return every(function (element, index) {
    return element === b[index];
  }, a);
}

function memoizeString(fn) {
  var cache = {};

  return function (str) {
    if (!cache[str]) {
      cache[str] = fn(str);
    }
    return cache[str];
  };
}

var hyphenate = memoizeString(function (str) {
  return str.replace(/([A-Z])/g, '-$1').toLowerCase();
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};









var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};



var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

/**
 * React Flip Move | propConverter
 * (c) 2016-present Joshua Comeau
 *
 * Abstracted away a bunch of the messy business with props.
 *   - props flow types and defaultProps
 *   - Type conversion (We accept 'string' and 'number' values for duration,
 *     delay, and other fields, but we actually need them to be ints.)
 *   - Children conversion (we need the children to be an array. May not always
 *     be, if a single child is passed in.)
 *   - Resolving animation presets into their base CSS styles
 */
/* eslint-disable block-scoped-var */

// eslint-disable-next-line no-duplicate-imports


function propConverter(ComposedComponent) {
  var _class, _temp;

  return _temp = _class = function (_Component) {
    inherits(FlipMovePropConverter, _Component);

    function FlipMovePropConverter() {
      classCallCheck(this, FlipMovePropConverter);
      return possibleConstructorReturn(this, _Component.apply(this, arguments));
    }

    // eslint-disable-next-line class-methods-use-this
    FlipMovePropConverter.prototype.checkChildren = function checkChildren(children) {
      // Skip all console warnings in production.
      // Bail early, to avoid unnecessary work.
      if (false) {}

      // same as React.Node, but without fragments, see https://github.com/facebook/flow/issues/4781


      // FlipMove does not support stateless functional components.
      // Check to see if any supplied components won't work.
      // If the child doesn't have a key, it means we aren't animating it.
      // It's allowed to be an SFC, since we ignore it.
      react__WEBPACK_IMPORTED_MODULE_0__["Children"].forEach(children, function (child) {
        // null, undefined, and booleans will be filtered out by Children.toArray
        if (child == null || typeof child === 'boolean') {
          return;
        }

        if ((typeof child === 'undefined' ? 'undefined' : _typeof(child)) !== 'object') {
          primitiveNodeSupplied();
          return;
        }

        if (isElementAnSFC(child) && child.key != null) {
          statelessFunctionalComponentSupplied();
        }
      });
    };

    FlipMovePropConverter.prototype.convertProps = function convertProps(props) {
      var workingProps = {
        // explicitly bypass the props that don't need conversion
        children: props.children,
        easing: props.easing,
        onStart: props.onStart,
        onFinish: props.onFinish,
        onStartAll: props.onStartAll,
        onFinishAll: props.onFinishAll,
        typeName: props.typeName,
        disableAllAnimations: props.disableAllAnimations,
        getPosition: props.getPosition,
        maintainContainerHeight: props.maintainContainerHeight,
        verticalAlignment: props.verticalAlignment,

        // Do string-to-int conversion for all timing-related props
        duration: this.convertTimingProp('duration'),
        delay: this.convertTimingProp('delay'),
        staggerDurationBy: this.convertTimingProp('staggerDurationBy'),
        staggerDelayBy: this.convertTimingProp('staggerDelayBy'),

        // Our enter/leave animations can be specified as boolean (default or
        // disabled), string (preset name), or object (actual animation values).
        // Let's standardize this so that they're always objects
        appearAnimation: this.convertAnimationProp(props.appearAnimation, appearPresets),
        enterAnimation: this.convertAnimationProp(props.enterAnimation, enterPresets),
        leaveAnimation: this.convertAnimationProp(props.leaveAnimation, leavePresets),

        delegated: {}
      };

      this.checkChildren(workingProps.children);

      // Gather any additional props;
      // they will be delegated to the ReactElement created.
      var primaryPropKeys = Object.keys(workingProps);
      var delegatedProps = omit(this.props, primaryPropKeys);

      // The FlipMove container element needs to have a non-static position.
      // We use `relative` by default, but it can be overridden by the user.
      // Now that we're delegating props, we need to merge this in.
      delegatedProps.style = _extends({
        position: 'relative'
      }, delegatedProps.style);

      workingProps.delegated = delegatedProps;

      return workingProps;
    };

    FlipMovePropConverter.prototype.convertTimingProp = function convertTimingProp(prop) {
      var rawValue = this.props[prop];

      var value = typeof rawValue === 'number' ? rawValue : parseInt(rawValue, 10);

      if (isNaN(value)) {
        var defaultValue = FlipMovePropConverter.defaultProps[prop];

        if (true) {
          invalidTypeForTimingProp({
            prop: prop,
            value: rawValue,
            defaultValue: defaultValue
          });
        }

        return defaultValue;
      }

      return value;
    };

    // eslint-disable-next-line class-methods-use-this


    FlipMovePropConverter.prototype.convertAnimationProp = function convertAnimationProp(animation, presets) {
      switch (typeof animation === 'undefined' ? 'undefined' : _typeof(animation)) {
        case 'boolean':
          {
            // If it's true, we want to use the default preset.
            // If it's false, we want to use the 'none' preset.
            return presets[animation ? defaultPreset : disablePreset];
          }

        case 'string':
          {
            var presetKeys = Object.keys(presets);

            if (presetKeys.indexOf(animation) === -1) {
              if (true) {
                invalidEnterLeavePreset({
                  value: animation,
                  acceptableValues: presetKeys.join(', '),
                  defaultValue: defaultPreset
                });
              }

              return presets[defaultPreset];
            }

            return presets[animation];
          }

        default:
          {
            return animation;
          }
      }
    };

    FlipMovePropConverter.prototype.render = function render() {
      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(ComposedComponent, this.convertProps(this.props));
    };

    return FlipMovePropConverter;
  }(react__WEBPACK_IMPORTED_MODULE_0__["Component"]), _class.defaultProps = {
    easing: 'ease-in-out',
    duration: 350,
    delay: 0,
    staggerDurationBy: 0,
    staggerDelayBy: 0,
    typeName: 'div',
    enterAnimation: defaultPreset,
    leaveAnimation: defaultPreset,
    disableAllAnimations: false,
    getPosition: function getPosition(node) {
      return node.getBoundingClientRect();
    },
    maintainContainerHeight: false,
    verticalAlignment: 'top'
  }, _temp;
}

/**
 * React Flip Move
 * (c) 2016-present Joshua Comeau
 *
 * These methods read from and write to the DOM.
 * They almost always have side effects, and will hopefully become the
 * only spot in the codebase with impure functions.
 */
function applyStylesToDOMNode(_ref) {
  var domNode = _ref.domNode,
      styles = _ref.styles;

  // Can't just do an object merge because domNode.styles is no regular object.
  // Need to do it this way for the engine to fire its `set` listeners.
  Object.keys(styles).forEach(function (key) {
    domNode.style.setProperty(hyphenate(key), styles[key]);
  });
}

// Modified from Modernizr
function whichTransitionEvent() {
  var transitions = {
    transition: 'transitionend',
    '-o-transition': 'oTransitionEnd',
    '-moz-transition': 'transitionend',
    '-webkit-transition': 'webkitTransitionEnd'
  };

  // If we're running in a browserless environment (eg. SSR), it doesn't apply.
  // Return a placeholder string, for consistent type return.
  if (typeof document === 'undefined') return '';

  var el = document.createElement('fakeelement');

  var match = find(function (t) {
    return el.style.getPropertyValue(t) !== undefined;
  }, Object.keys(transitions));

  // If no `transition` is found, we must be running in a browser so ancient,
  // React itself won't run. Return an empty string, for consistent type return
  return match ? transitions[match] : '';
}

var getRelativeBoundingBox = function getRelativeBoundingBox(_ref2) {
  var childDomNode = _ref2.childDomNode,
      parentDomNode = _ref2.parentDomNode,
      getPosition = _ref2.getPosition;

  var parentBox = getPosition(parentDomNode);

  var _getPosition = getPosition(childDomNode),
      top = _getPosition.top,
      left = _getPosition.left,
      right = _getPosition.right,
      bottom = _getPosition.bottom,
      width = _getPosition.width,
      height = _getPosition.height;

  return {
    top: top - parentBox.top,
    left: left - parentBox.left,
    right: parentBox.right - right,
    bottom: parentBox.bottom - bottom,
    width: width,
    height: height
  };
};

/** getPositionDelta
 * This method returns the delta between two bounding boxes, to figure out
 * how many pixels on each axis the element has moved.
 *
 */
var getPositionDelta = function getPositionDelta(_ref3) {
  var childDomNode = _ref3.childDomNode,
      childBoundingBox = _ref3.childBoundingBox,
      parentBoundingBox = _ref3.parentBoundingBox,
      getPosition = _ref3.getPosition;

  // TEMP: A mystery bug is sometimes causing unnecessary boundingBoxes to
  var defaultBox = {
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    height: 0,
    width: 0
  };

  // Our old box is its last calculated position, derived on mount or at the
  // start of the previous animation.
  var oldRelativeBox = childBoundingBox || defaultBox;
  var parentBox = parentBoundingBox || defaultBox;

  // Our new box is the new final resting place: Where we expect it to wind up
  // after the animation. First we get the box in absolute terms (AKA relative
  // to the viewport), and then we calculate its relative box (relative to the
  // parent container)
  var newAbsoluteBox = getPosition(childDomNode);
  var newRelativeBox = {
    top: newAbsoluteBox.top - parentBox.top,
    left: newAbsoluteBox.left - parentBox.left
  };

  return [oldRelativeBox.left - newRelativeBox.left, oldRelativeBox.top - newRelativeBox.top];
};

/** removeNodeFromDOMFlow
 * This method does something very sneaky: it removes a DOM node from the
 * document flow, but without actually changing its on-screen position.
 *
 * It works by calculating where the node is, and then applying styles
 * so that it winds up being positioned absolutely, but in exactly the
 * same place.
 *
 * This is a vital part of the FLIP technique.
 */
var removeNodeFromDOMFlow = function removeNodeFromDOMFlow(childData, verticalAlignment) {
  var domNode = childData.domNode,
      boundingBox = childData.boundingBox;


  if (!domNode || !boundingBox) {
    return;
  }

  // For this to work, we have to offset any given `margin`.
  var computed = window.getComputedStyle(domNode);

  // We need to clean up margins, by converting and removing suffix:
  // eg. '21px' -> 21
  var marginAttrs = ['margin-top', 'margin-left', 'margin-right'];
  var margins = marginAttrs.reduce(function (acc, margin) {
    var _babelHelpers$extends;

    var propertyVal = computed.getPropertyValue(margin);

    return _extends({}, acc, (_babelHelpers$extends = {}, _babelHelpers$extends[margin] = Number(propertyVal.replace('px', '')), _babelHelpers$extends));
  }, {});

  // If we're bottom-aligned, we need to add the height of the child to its
  // top offset. This is because, when the container is bottom-aligned, its
  // height shrinks from the top, not the bottom. We're removing this node
  // from the flow, so the top is going to drop by its height.
  var topOffset = verticalAlignment === 'bottom' ? boundingBox.top - boundingBox.height : boundingBox.top;

  var styles = {
    position: 'absolute',
    top: topOffset - margins['margin-top'] + 'px',
    left: boundingBox.left - margins['margin-left'] + 'px',
    right: boundingBox.right - margins['margin-right'] + 'px'
  };

  applyStylesToDOMNode({ domNode: domNode, styles: styles });
};

/** updateHeightPlaceholder
 * An optional property to FlipMove is a `maintainContainerHeight` boolean.
 * This property creates a node that fills space, so that the parent
 * container doesn't collapse when its children are removed from the
 * document flow.
 */
var updateHeightPlaceholder = function updateHeightPlaceholder(_ref4) {
  var domNode = _ref4.domNode,
      parentData = _ref4.parentData,
      getPosition = _ref4.getPosition;

  var parentDomNode = parentData.domNode;
  var parentBoundingBox = parentData.boundingBox;

  if (!parentDomNode || !parentBoundingBox) {
    return;
  }

  // We need to find the height of the container *without* the placeholder.
  // Since it's possible that the placeholder might already be present,
  // we first set its height to 0.
  // This allows the container to collapse down to the size of just its
  // content (plus container padding or borders if any).
  applyStylesToDOMNode({ domNode: domNode, styles: { height: '0' } });

  // Find the distance by which the container would be collapsed by elements
  // leaving. We compare the freshly-available parent height with the original,
  // cached container height.
  var originalParentHeight = parentBoundingBox.height;
  var collapsedParentHeight = getPosition(parentDomNode).height;
  var reductionInHeight = originalParentHeight - collapsedParentHeight;

  // If the container has become shorter, update the padding element's
  // height to take up the difference. Otherwise set its height to zero,
  // so that it has no effect.
  var styles = {
    height: reductionInHeight > 0 ? reductionInHeight + 'px' : '0'
  };

  applyStylesToDOMNode({ domNode: domNode, styles: styles });
};

var getNativeNode = function getNativeNode(element) {
  // When running in a windowless environment, abort!
  if (typeof HTMLElement === 'undefined') {
    return null;
  }

  // `element` may already be a native node.
  if (element instanceof HTMLElement) {
    return element;
  }

  // While ReactDOM's `findDOMNode` is discouraged, it's the only
  // publicly-exposed way to find the underlying DOM node for
  // composite components.
  var foundNode = Object(react_dom__WEBPACK_IMPORTED_MODULE_1__["findDOMNode"])(element);

  if (foundNode && foundNode.nodeType === Node.TEXT_NODE) {
    // Text nodes are not supported
    return null;
  }
  // eslint-disable-next-line flowtype/no-weak-types
  return foundNode;
};

var createTransitionString = function createTransitionString(index, props) {
  var delay = props.delay,
      duration = props.duration;
  var staggerDurationBy = props.staggerDurationBy,
      staggerDelayBy = props.staggerDelayBy,
      easing = props.easing;


  delay += index * staggerDelayBy;
  duration += index * staggerDurationBy;

  var cssProperties = ['transform', 'opacity'];

  return cssProperties.map(function (prop) {
    return prop + ' ' + duration + 'ms ' + easing + ' ' + delay + 'ms';
  }).join(', ');
};

/**
 * React Flip Move
 * (c) 2016-present Joshua Comeau
 *
 * For information on how this code is laid out, check out CODE_TOUR.md
 */

/* eslint-disable react/prop-types */

// eslint-disable-next-line no-duplicate-imports


var transitionEnd = whichTransitionEvent();
var noBrowserSupport = !transitionEnd;

function getKey(childData) {
  return childData.key || '';
}

function getElementChildren(children) {
  // Fix incomplete typing of Children.toArray
  // eslint-disable-next-line flowtype/no-weak-types
  return react__WEBPACK_IMPORTED_MODULE_0__["Children"].toArray(children);
}

var FlipMove$1 = function (_Component) {
  inherits(FlipMove, _Component);

  function FlipMove() {
    var _temp, _this, _ret;

    classCallCheck(this, FlipMove);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.state = {
      children: getElementChildren(
      // `this.props` ought to always be defined at this point, but a report
      // was made about it not being defined in IE10.
      // TODO: Test in IE10, to see if there's an underlying cause that can
      // be addressed.
      _this.props ? _this.props.children : []).map(function (element) {
        return _extends({}, element, {
          element: element,
          appearing: true
        });
      })
    }, _this.childrenData = {}, _this.parentData = {
      domNode: null,
      boundingBox: null
    }, _this.heightPlaceholderData = {
      domNode: null
    }, _this.remainingAnimations = 0, _this.childrenToAnimate = [], _this.findDOMContainer = function () {
      // eslint-disable-next-line react/no-find-dom-node
      var domNode = react_dom__WEBPACK_IMPORTED_MODULE_1___default.a.findDOMNode(_this);
      var parentNode = domNode && domNode.parentNode;

      // This ought to be impossible, but handling it for Flow's sake.
      if (!parentNode || !(parentNode instanceof HTMLElement)) {
        return;
      }

      // If the parent node has static positioning, leave animations might look
      // really funky. Let's automatically apply `position: relative` in this
      // case, to prevent any quirkiness.
      if (window.getComputedStyle(parentNode).position === 'static') {
        parentNode.style.position = 'relative';
        parentNodePositionStatic();
      }

      _this.parentData.domNode = parentNode;
    }, _this.runAnimation = function () {
      var dynamicChildren = _this.state.children.filter(_this.doesChildNeedToBeAnimated);

      // Splitting DOM reads and writes to be peformed in batches
      var childrenInitialStyles = dynamicChildren.map(function (child) {
        return _this.computeInitialStyles(child);
      });
      dynamicChildren.forEach(function (child, index) {
        _this.remainingAnimations += 1;
        _this.childrenToAnimate.push(getKey(child));
        _this.animateChild(child, index, childrenInitialStyles[index]);
      });

      if (typeof _this.props.onStartAll === 'function') {
        _this.callChildrenHook(_this.props.onStartAll);
      }
    }, _this.doesChildNeedToBeAnimated = function (child) {
      // If the child doesn't have a key, it's an immovable child (one that we
      // do not want to do FLIP stuff to.)
      if (!getKey(child)) {
        return false;
      }

      var childData = _this.getChildData(getKey(child));
      var childDomNode = childData.domNode;
      var childBoundingBox = childData.boundingBox;
      var parentBoundingBox = _this.parentData.boundingBox;

      if (!childDomNode) {
        return false;
      }

      var _this$props = _this.props,
          appearAnimation = _this$props.appearAnimation,
          enterAnimation = _this$props.enterAnimation,
          leaveAnimation = _this$props.leaveAnimation,
          getPosition = _this$props.getPosition;


      var isAppearingWithAnimation = child.appearing && appearAnimation;
      var isEnteringWithAnimation = child.entering && enterAnimation;
      var isLeavingWithAnimation = child.leaving && leaveAnimation;

      if (isAppearingWithAnimation || isEnteringWithAnimation || isLeavingWithAnimation) {
        return true;
      }

      // If it isn't entering/leaving, we want to animate it if it's
      // on-screen position has changed.

      var _getPositionDelta = getPositionDelta({
        childDomNode: childDomNode,
        childBoundingBox: childBoundingBox,
        parentBoundingBox: parentBoundingBox,
        getPosition: getPosition
      }),
          dX = _getPositionDelta[0],
          dY = _getPositionDelta[1];

      return dX !== 0 || dY !== 0;
    }, _temp), possibleConstructorReturn(_this, _ret);
  }
  // Copy props.children into state.
  // To understand why this is important (and not an anti-pattern), consider
  // how "leave" animations work. An item has "left" when the component
  // receives a new set of props that do NOT contain the item.
  // If we just render the props as-is, the item would instantly disappear.
  // We want to keep the item rendered for a little while, until its animation
  // can complete. Because we cannot mutate props, we make `state` the source
  // of truth.


  // FlipMove needs to know quite a bit about its children in order to do
  // its job. We store these as a property on the instance. We're not using
  // state, because we don't want changes to trigger re-renders, we just
  // need a place to keep the data for reference, when changes happen.
  // This field should not be accessed directly. Instead, use getChildData,
  // putChildData, etc...


  // Similarly, track the dom node and box of our parent element.


  // If `maintainContainerHeight` prop is set to true, we'll create a
  // placeholder element which occupies space so that the parent height
  // doesn't change when items are removed from the document flow (which
  // happens during leave animations)


  // Keep track of remaining animations so we know when to fire the
  // all-finished callback, and clean up after ourselves.
  // NOTE: we can't simply use childrenToAnimate.length to track remaining
  // animations, because we need to maintain the list of animating children,
  // to pass to the `onFinishAll` handler.


  FlipMove.prototype.componentDidMount = function componentDidMount() {
    // Because React 16 no longer requires wrapping elements, Flip Move can opt
    // to not wrap the children in an element. In that case, find the parent
    // element using `findDOMNode`.
    if (this.props.typeName === null) {
      this.findDOMContainer();
    }

    // Run our `appearAnimation` if it was requested, right after the
    // component mounts.
    var shouldTriggerFLIP = this.props.appearAnimation && !this.isAnimationDisabled(this.props);

    if (shouldTriggerFLIP) {
      this.prepForAnimation();
      this.runAnimation();
    }
  };

  FlipMove.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    // When the component is handed new props, we need to figure out the
    // "resting" position of all currently-rendered DOM nodes.
    // We store that data in this.parent and this.children,
    // so it can be used later to work out the animation.
    this.updateBoundingBoxCaches();

    // Convert opaque children object to array.
    var nextChildren = getElementChildren(nextProps.children);

    // Next, we need to update our state, so that it contains our new set of
    // children. If animation is disabled or unsupported, this is easy;
    // we just copy our props into state.
    // Assuming that we can animate, though, we have to do some work.
    // Essentially, we want to keep just-deleted nodes in the DOM for a bit
    // longer, so that we can animate them away.
    this.setState({
      children: this.isAnimationDisabled(nextProps) ? nextChildren.map(function (element) {
        return _extends({}, element, { element: element });
      }) : this.calculateNextSetOfChildren(nextChildren)
    });
  };

  FlipMove.prototype.componentDidUpdate = function componentDidUpdate(previousProps) {
    if (this.props.typeName === null) {
      this.findDOMContainer();
    }
    // If the children have been re-arranged, moved, or added/removed,
    // trigger the main FLIP animation.
    //
    // IMPORTANT: We need to make sure that the children have actually changed.
    // At the end of the transition, we clean up nodes that need to be removed.
    // We DON'T want this cleanup to trigger another update.

    var oldChildrenKeys = getElementChildren(this.props.children).map(function (d) {
      return d.key;
    });
    var nextChildrenKeys = getElementChildren(previousProps.children).map(function (d) {
      return d.key;
    });

    var shouldTriggerFLIP = !arraysEqual(oldChildrenKeys, nextChildrenKeys) && !this.isAnimationDisabled(this.props);

    if (shouldTriggerFLIP) {
      this.prepForAnimation();
      this.runAnimation();
    }
  };

  FlipMove.prototype.calculateNextSetOfChildren = function calculateNextSetOfChildren(nextChildren) {
    var _this2 = this;

    // We want to:
    //   - Mark all new children as `entering`
    //   - Pull in previous children that aren't in nextChildren, and mark them
    //     as `leaving`
    //   - Preserve the nextChildren list order, with leaving children in their
    //     appropriate places.
    //

    var updatedChildren = nextChildren.map(function (nextChild) {
      var child = _this2.findChildByKey(nextChild.key);

      // If the current child did exist, but it was in the midst of leaving,
      // we want to treat it as though it's entering
      var isEntering = !child || child.leaving;

      return _extends({}, nextChild, { element: nextChild, entering: isEntering });
    });

    // This is tricky. We want to keep the nextChildren's ordering, but with
    // any just-removed items maintaining their original position.
    // eg.
    //   this.state.children  = [ 1, 2, 3, 4 ]
    //   nextChildren         = [ 3, 1 ]
    //
    // In this example, we've removed the '2' & '4'
    // We want to end up with:  [ 2, 3, 1, 4 ]
    //
    // To accomplish that, we'll iterate through this.state.children. whenever
    // we find a match, we'll append our `leaving` flag to it, and insert it
    // into the nextChildren in its ORIGINAL position. Note that, as we keep
    // inserting old items into the new list, the "original" position will
    // keep incrementing.
    var numOfChildrenLeaving = 0;
    this.state.children.forEach(function (child, index) {
      var isLeaving = !find(function (_ref) {
        var key = _ref.key;
        return key === getKey(child);
      }, nextChildren);

      // If the child isn't leaving (or, if there is no leave animation),
      // we don't need to add it into the state children.
      if (!isLeaving || !_this2.props.leaveAnimation) return;

      var nextChild = _extends({}, child, { leaving: true });
      var nextChildIndex = index + numOfChildrenLeaving;

      updatedChildren.splice(nextChildIndex, 0, nextChild);
      numOfChildrenLeaving += 1;
    });

    return updatedChildren;
  };

  FlipMove.prototype.prepForAnimation = function prepForAnimation() {
    var _this3 = this;

    // Our animation prep consists of:
    // - remove children that are leaving from the DOM flow, so that the new
    //   layout can be accurately calculated,
    // - update the placeholder container height, if needed, to ensure that
    //   the parent's height doesn't collapse.

    var _props = this.props,
        leaveAnimation = _props.leaveAnimation,
        maintainContainerHeight = _props.maintainContainerHeight,
        getPosition = _props.getPosition;

    // we need to make all leaving nodes "invisible" to the layout calculations
    // that will take place in the next step (this.runAnimation).

    if (leaveAnimation) {
      var leavingChildren = this.state.children.filter(function (child) {
        return child.leaving;
      });

      leavingChildren.forEach(function (leavingChild) {
        var childData = _this3.getChildData(getKey(leavingChild));

        // Warn if child is disabled
        if (!_this3.isAnimationDisabled(_this3.props) && childData.domNode && childData.domNode.disabled) {
          childIsDisabled();
        }

        // We need to take the items out of the "flow" of the document, so that
        // its siblings can move to take its place.
        if (childData.boundingBox) {
          removeNodeFromDOMFlow(childData, _this3.props.verticalAlignment);
        }
      });

      if (maintainContainerHeight && this.heightPlaceholderData.domNode) {
        updateHeightPlaceholder({
          domNode: this.heightPlaceholderData.domNode,
          parentData: this.parentData,
          getPosition: getPosition
        });
      }
    }

    // For all children not in the middle of entering or leaving,
    // we need to reset the transition, so that the NEW shuffle starts from
    // the right place.
    this.state.children.forEach(function (child) {
      var _getChildData = _this3.getChildData(getKey(child)),
          domNode = _getChildData.domNode;

      // Ignore children that don't render DOM nodes (eg. by returning null)


      if (!domNode) {
        return;
      }

      if (!child.entering && !child.leaving) {
        applyStylesToDOMNode({
          domNode: domNode,
          styles: {
            transition: ''
          }
        });
      }
    });
  };

  FlipMove.prototype.animateChild = function animateChild(child, index, childInitialStyles) {
    var _this4 = this;

    var _getChildData2 = this.getChildData(getKey(child)),
        domNode = _getChildData2.domNode;

    if (!domNode) {
      return;
    }

    // Apply the relevant style for this DOM node
    // This is the offset from its actual DOM position.
    // eg. if an item has been re-rendered 20px lower, we want to apply a
    // style of 'transform: translate(-20px)', so that it appears to be where
    // it started.
    // In FLIP terminology, this is the 'Invert' stage.
    applyStylesToDOMNode({
      domNode: domNode,
      styles: childInitialStyles
    });

    // Start by invoking the onStart callback for this child.
    if (this.props.onStart) this.props.onStart(child, domNode);

    // Next, animate the item from it's artificially-offset position to its
    // new, natural position.
    requestAnimationFrame(function () {
      requestAnimationFrame(function () {
        // NOTE, RE: the double-requestAnimationFrame:
        // Sadly, this is the most browser-compatible way to do this I've found.
        // Essentially we need to set the initial styles outside of any request
        // callbacks to avoid batching them. Then, a frame needs to pass with
        // the styles above rendered. Then, on the second frame, we can apply
        // our final styles to perform the animation.

        // Our first order of business is to "undo" the styles applied in the
        // previous frames, while also adding a `transition` property.
        // This way, the item will smoothly transition from its old position
        // to its new position.

        // eslint-disable-next-line flowtype/require-variable-type
        var styles = {
          transition: createTransitionString(index, _this4.props),
          transform: '',
          opacity: ''
        };

        if (child.appearing && _this4.props.appearAnimation) {
          styles = _extends({}, styles, _this4.props.appearAnimation.to);
        } else if (child.entering && _this4.props.enterAnimation) {
          styles = _extends({}, styles, _this4.props.enterAnimation.to);
        } else if (child.leaving && _this4.props.leaveAnimation) {
          styles = _extends({}, styles, _this4.props.leaveAnimation.to);
        }

        // In FLIP terminology, this is the 'Play' stage.
        applyStylesToDOMNode({ domNode: domNode, styles: styles });
      });
    });

    this.bindTransitionEndHandler(child);
  };

  FlipMove.prototype.bindTransitionEndHandler = function bindTransitionEndHandler(child) {
    var _this5 = this;

    var _getChildData3 = this.getChildData(getKey(child)),
        domNode = _getChildData3.domNode;

    if (!domNode) {
      return;
    }

    // The onFinish callback needs to be bound to the transitionEnd event.
    // We also need to unbind it when the transition completes, so this ugly
    // inline function is required (we need it here so it closes over
    // dependent variables `child` and `domNode`)
    var transitionEndHandler = function transitionEndHandler(ev) {
      // It's possible that this handler is fired not on our primary transition,
      // but on a nested transition (eg. a hover effect). Ignore these cases.
      if (ev.target !== domNode) return;

      // Remove the 'transition' inline style we added. This is cleanup.
      domNode.style.transition = '';

      // Trigger any applicable onFinish/onFinishAll hooks
      _this5.triggerFinishHooks(child, domNode);

      domNode.removeEventListener(transitionEnd, transitionEndHandler);

      if (child.leaving) {
        _this5.removeChildData(getKey(child));
      }
    };

    domNode.addEventListener(transitionEnd, transitionEndHandler);
  };

  FlipMove.prototype.triggerFinishHooks = function triggerFinishHooks(child, domNode) {
    var _this6 = this;

    if (this.props.onFinish) this.props.onFinish(child, domNode);

    // Reduce the number of children we need to animate by 1,
    // so that we can tell when all children have finished.
    this.remainingAnimations -= 1;

    if (this.remainingAnimations === 0) {
      // Remove any items from the DOM that have left, and reset `entering`.
      var nextChildren = this.state.children.filter(function (_ref2) {
        var leaving = _ref2.leaving;
        return !leaving;
      }).map(function (item) {
        return _extends({}, item, {
          // fix for Flow
          element: item.element,
          appearing: false,
          entering: false
        });
      });

      this.setState({ children: nextChildren }, function () {
        if (typeof _this6.props.onFinishAll === 'function') {
          _this6.callChildrenHook(_this6.props.onFinishAll);
        }

        // Reset our variables for the next iteration
        _this6.childrenToAnimate = [];
      });

      // If the placeholder was holding the container open while elements were
      // leaving, we we can now set its height to zero.
      if (this.heightPlaceholderData.domNode) {
        this.heightPlaceholderData.domNode.style.height = '0';
      }
    }
  };

  FlipMove.prototype.callChildrenHook = function callChildrenHook(hook) {
    var _this7 = this;

    var elements = [];
    var domNodes = [];

    this.childrenToAnimate.forEach(function (childKey) {
      // If this was an exit animation, the child may no longer exist.
      // If so, skip it.
      var child = _this7.findChildByKey(childKey);

      if (!child) {
        return;
      }

      elements.push(child);

      if (_this7.hasChildData(childKey)) {
        domNodes.push(_this7.getChildData(childKey).domNode);
      }
    });

    hook(elements, domNodes);
  };

  FlipMove.prototype.updateBoundingBoxCaches = function updateBoundingBoxCaches() {
    var _this8 = this;

    // This is the ONLY place that parentData and childrenData's
    // bounding boxes are updated. They will be calculated at other times
    // to be compared to this value, but it's important that the cache is
    // updated once per update.
    var parentDomNode = this.parentData.domNode;

    if (!parentDomNode) {
      return;
    }

    this.parentData.boundingBox = this.props.getPosition(parentDomNode);

    // Splitting DOM reads and writes to be peformed in batches
    var childrenBoundingBoxes = [];

    this.state.children.forEach(function (child) {
      var childKey = getKey(child);

      // It is possible that a child does not have a `key` property;
      // Ignore these children, they don't need to be moved.
      if (!childKey) {
        childrenBoundingBoxes.push(null);
        return;
      }

      // In very rare circumstances, for reasons unknown, the ref is never
      // populated for certain children. In this case, avoid doing this update.
      // see: https://github.com/joshwcomeau/react-flip-move/pull/91
      if (!_this8.hasChildData(childKey)) {
        childrenBoundingBoxes.push(null);
        return;
      }

      var childData = _this8.getChildData(childKey);

      // If the child element returns null, we need to avoid trying to
      // account for it
      if (!childData.domNode || !child) {
        childrenBoundingBoxes.push(null);
        return;
      }

      childrenBoundingBoxes.push(getRelativeBoundingBox({
        childDomNode: childData.domNode,
        parentDomNode: parentDomNode,
        getPosition: _this8.props.getPosition
      }));
    });

    this.state.children.forEach(function (child, index) {
      var childKey = getKey(child);

      var childBoundingBox = childrenBoundingBoxes[index];

      if (!childKey) {
        return;
      }

      _this8.setChildData(childKey, {
        boundingBox: childBoundingBox
      });
    });
  };

  FlipMove.prototype.computeInitialStyles = function computeInitialStyles(child) {
    if (child.appearing) {
      return this.props.appearAnimation ? this.props.appearAnimation.from : {};
    } else if (child.entering) {
      if (!this.props.enterAnimation) {
        return {};
      }
      // If this child was in the middle of leaving, it still has its
      // absolute positioning styles applied. We need to undo those.
      return _extends({
        position: '',
        top: '',
        left: '',
        right: '',
        bottom: ''
      }, this.props.enterAnimation.from);
    } else if (child.leaving) {
      return this.props.leaveAnimation ? this.props.leaveAnimation.from : {};
    }

    var childData = this.getChildData(getKey(child));
    var childDomNode = childData.domNode;
    var childBoundingBox = childData.boundingBox;
    var parentBoundingBox = this.parentData.boundingBox;

    if (!childDomNode) {
      return {};
    }

    var _getPositionDelta2 = getPositionDelta({
      childDomNode: childDomNode,
      childBoundingBox: childBoundingBox,
      parentBoundingBox: parentBoundingBox,
      getPosition: this.props.getPosition
    }),
        dX = _getPositionDelta2[0],
        dY = _getPositionDelta2[1];

    return {
      transform: 'translate(' + dX + 'px, ' + dY + 'px)'
    };
  };

  // eslint-disable-next-line class-methods-use-this


  FlipMove.prototype.isAnimationDisabled = function isAnimationDisabled(props) {
    // If the component is explicitly passed a `disableAllAnimations` flag,
    // we can skip this whole process. Similarly, if all of the numbers have
    // been set to 0, there is no point in trying to animate; doing so would
    // only cause a flicker (and the intent is probably to disable animations)
    // We can also skip this rigamarole if there's no browser support for it.
    return noBrowserSupport || props.disableAllAnimations || props.duration === 0 && props.delay === 0 && props.staggerDurationBy === 0 && props.staggerDelayBy === 0;
  };

  FlipMove.prototype.findChildByKey = function findChildByKey(key) {
    return find(function (child) {
      return getKey(child) === key;
    }, this.state.children);
  };

  FlipMove.prototype.hasChildData = function hasChildData(key) {
    // Object has some built-in properties on its prototype, such as toString.  hasOwnProperty makes
    // sure that key is present on childrenData itself, not on its prototype.
    return Object.prototype.hasOwnProperty.call(this.childrenData, key);
  };

  FlipMove.prototype.getChildData = function getChildData(key) {
    return this.hasChildData(key) ? this.childrenData[key] : {};
  };

  FlipMove.prototype.setChildData = function setChildData(key, data) {
    this.childrenData[key] = _extends({}, this.getChildData(key), data);
  };

  FlipMove.prototype.removeChildData = function removeChildData(key) {
    delete this.childrenData[key];
    this.setState(function (prevState) {
      return _extends({}, prevState, {
        children: prevState.children.filter(function (child) {
          return child.element.key !== key;
        })
      });
    });
  };

  FlipMove.prototype.createHeightPlaceholder = function createHeightPlaceholder() {
    var _this9 = this;

    var typeName = this.props.typeName;

    // If requested, create an invisible element at the end of the list.
    // Its height will be modified to prevent the container from collapsing
    // prematurely.

    var isContainerAList = typeName === 'ul' || typeName === 'ol';
    var placeholderType = isContainerAList ? 'li' : 'div';

    return Object(react__WEBPACK_IMPORTED_MODULE_0__["createElement"])(placeholderType, {
      key: 'height-placeholder',
      ref: function ref(domNode) {
        _this9.heightPlaceholderData.domNode = domNode;
      },
      style: { visibility: 'hidden', height: 0 }
    });
  };

  FlipMove.prototype.childrenWithRefs = function childrenWithRefs() {
    var _this10 = this;

    // We need to clone the provided children, capturing a reference to the
    // underlying DOM node. Flip Move needs to use the React escape hatches to
    // be able to do its calculations.
    return this.state.children.map(function (child) {
      return Object(react__WEBPACK_IMPORTED_MODULE_0__["cloneElement"])(child.element, {
        ref: function ref(element) {
          // Stateless Functional Components are not supported by FlipMove,
          // because they don't have instances.
          if (!element) {
            return;
          }

          var domNode = getNativeNode(element);
          _this10.setChildData(getKey(child), { domNode: domNode });
        }
      });
    });
  };

  FlipMove.prototype.render = function render() {
    var _this11 = this;

    var _props2 = this.props,
        typeName = _props2.typeName,
        delegated = _props2.delegated,
        leaveAnimation = _props2.leaveAnimation,
        maintainContainerHeight = _props2.maintainContainerHeight;


    var children = this.childrenWithRefs();
    if (leaveAnimation && maintainContainerHeight) {
      children.push(this.createHeightPlaceholder());
    }

    if (!typeName) return children;

    var props = _extends({}, delegated, {
      children: children,
      ref: function ref(node) {
        _this11.parentData.domNode = node;
      }
    });

    return Object(react__WEBPACK_IMPORTED_MODULE_0__["createElement"])(typeName, props);
  };

  return FlipMove;
}(react__WEBPACK_IMPORTED_MODULE_0__["Component"]);

var enhancedFlipMove = /* #__PURE__ */propConverter(FlipMove$1);

/**
 * React Flip Move
 * (c) 2016-present Joshua Comeau
 */

/* harmony default export */ __webpack_exports__["default"] = (enhancedFlipMove);


/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.2.0
 * react.development.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

var _assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");
var emptyObject = __webpack_require__(/*! fbjs/lib/emptyObject */ "./node_modules/fbjs/lib/emptyObject.js");
var invariant = __webpack_require__(/*! fbjs/lib/invariant */ "./node_modules/fbjs/lib/invariant.js");
var warning = __webpack_require__(/*! fbjs/lib/warning */ "./node_modules/fbjs/lib/warning.js");
var emptyFunction = __webpack_require__(/*! fbjs/lib/emptyFunction */ "./node_modules/fbjs/lib/emptyFunction.js");
var checkPropTypes = __webpack_require__(/*! prop-types/checkPropTypes */ "./node_modules/prop-types/checkPropTypes.js");

// TODO: this is special because it gets imported during build.

var ReactVersion = '16.2.0';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol['for'];

var REACT_ELEMENT_TYPE = hasSymbol ? Symbol['for']('react.element') : 0xeac7;
var REACT_CALL_TYPE = hasSymbol ? Symbol['for']('react.call') : 0xeac8;
var REACT_RETURN_TYPE = hasSymbol ? Symbol['for']('react.return') : 0xeac9;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol['for']('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol['for']('react.fragment') : 0xeacb;

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';

function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable === 'undefined') {
    return null;
  }
  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }
  return null;
}

/**
 * WARNING: DO NOT manually require this module.
 * This is a replacement for `invariant(...)` used by the error code system
 * and will _only_ be required by the corresponding babel pass.
 * It always throws.
 */

/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var lowPriorityWarning = function () {};

{
  var printWarning = function (format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.warn(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  lowPriorityWarning = function (condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }
    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

var lowPriorityWarning$1 = lowPriorityWarning;

var didWarnStateUpdateForUnmountedComponent = {};

function warnNoop(publicInstance, callerName) {
  {
    var constructor = publicInstance.constructor;
    var componentName = constructor && (constructor.displayName || constructor.name) || 'ReactClass';
    var warningKey = componentName + '.' + callerName;
    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
      return;
    }
    warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op.\n\nPlease check the code for the %s component.', callerName, callerName, componentName);
    didWarnStateUpdateForUnmountedComponent[warningKey] = true;
  }
}

/**
 * This is the abstract API for an update queue.
 */
var ReactNoopUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance, callback, callerName) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} Name of the calling function in the public API.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState, callback, callerName) {
    warnNoop(publicInstance, 'setState');
  }
};

/**
 * Base class helpers for the updating state of a component.
 */
function Component(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

Component.prototype.isReactComponent = {};

/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */
Component.prototype.setState = function (partialState, callback) {
  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;
  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */
Component.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
};

/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */
{
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };
  var defineDeprecationWarning = function (methodName, info) {
    Object.defineProperty(Component.prototype, methodName, {
      get: function () {
        lowPriorityWarning$1(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
        return undefined;
      }
    });
  };
  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

/**
 * Base class helpers for the updating state of a component.
 */
function PureComponent(props, context, updater) {
  // Duplicated from Component.
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

function ComponentDummy() {}
ComponentDummy.prototype = Component.prototype;
var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
pureComponentPrototype.constructor = PureComponent;
// Avoid an extra prototype jump for these methods.
_assign(pureComponentPrototype, Component.prototype);
pureComponentPrototype.isPureReactComponent = true;

function AsyncComponent(props, context, updater) {
  // Duplicated from Component.
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

var asyncComponentPrototype = AsyncComponent.prototype = new ComponentDummy();
asyncComponentPrototype.constructor = AsyncComponent;
// Avoid an extra prototype jump for these methods.
_assign(asyncComponentPrototype, Component.prototype);
asyncComponentPrototype.unstable_isAsyncReactComponent = true;
asyncComponentPrototype.render = function () {
  return this.props.children;
};

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

var hasOwnProperty = Object.prototype.hasOwnProperty;

var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};

var specialPropKeyWarningShown;
var specialPropRefWarningShown;

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    if (!specialPropKeyWarningShown) {
      specialPropKeyWarningShown = true;
      warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
    }
  };
  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    if (!specialPropRefWarningShown) {
      specialPropRefWarningShown = true;
      warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
    }
  };
  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, no instanceof check
 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} key
 * @param {string|object} ref
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @param {*} owner
 * @param {*} props
 * @internal
 */
var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allow us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,

    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,

    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {};

    // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.
    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    });
    // self and source are DEV only properties.
    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    });
    // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.
    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });
    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};

/**
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 */
function createElement(type, config, children) {
  var propName;

  // Reserved names are extracted
  var props = {};

  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;
    // Remaining properties are added to a new props object
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }
    props.children = childArray;
  }

  // Resolve default props
  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }
  {
    if (key || ref) {
      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
        if (key) {
          defineKeyPropWarningGetter(props, displayName);
        }
        if (ref) {
          defineRefPropWarningGetter(props, displayName);
        }
      }
    }
  }
  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
}

/**
 * Return a function that produces ReactElements of a given type.
 * See https://reactjs.org/docs/react-api.html#createfactory
 */


function cloneAndReplaceKey(oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

  return newElement;
}

/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://reactjs.org/docs/react-api.html#cloneelement
 */
function cloneElement(element, config, children) {
  var propName;

  // Original props are copied
  var props = _assign({}, element.props);

  // Reserved names are extracted
  var key = element.key;
  var ref = element.ref;
  // Self is preserved since the owner is preserved.
  var self = element._self;
  // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.
  var source = element._source;

  // Owner will be preserved, unless ref is overridden
  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    // Remaining properties override existing props
    var defaultProps;
    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
}

/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a valid component.
 * @final
 */
function isValidElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}

var ReactDebugCurrentFrame = {};

{
  // Component that is being worked on
  ReactDebugCurrentFrame.getCurrentStack = null;

  ReactDebugCurrentFrame.getStackAddendum = function () {
    var impl = ReactDebugCurrentFrame.getCurrentStack;
    if (impl) {
      return impl();
    }
    return null;
  };
}

var SEPARATOR = '.';
var SUBSEPARATOR = ':';

/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */
function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = ('' + key).replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });

  return '$' + escapedString;
}

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var didWarnAboutMaps = false;

var userProvidedKeyEscapeRegex = /\/+/g;
function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
}

var POOL_SIZE = 10;
var traverseContextPool = [];
function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {
  if (traverseContextPool.length) {
    var traverseContext = traverseContextPool.pop();
    traverseContext.result = mapResult;
    traverseContext.keyPrefix = keyPrefix;
    traverseContext.func = mapFunction;
    traverseContext.context = mapContext;
    traverseContext.count = 0;
    return traverseContext;
  } else {
    return {
      result: mapResult,
      keyPrefix: keyPrefix,
      func: mapFunction,
      context: mapContext,
      count: 0
    };
  }
}

function releaseTraverseContext(traverseContext) {
  traverseContext.result = null;
  traverseContext.keyPrefix = null;
  traverseContext.func = null;
  traverseContext.context = null;
  traverseContext.count = 0;
  if (traverseContextPool.length < POOL_SIZE) {
    traverseContextPool.push(traverseContext);
  }
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  var invokeCallback = false;

  if (children === null) {
    invokeCallback = true;
  } else {
    switch (type) {
      case 'string':
      case 'number':
        invokeCallback = true;
        break;
      case 'object':
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_CALL_TYPE:
          case REACT_RETURN_TYPE:
          case REACT_PORTAL_TYPE:
            invokeCallback = true;
        }
    }
  }

  if (invokeCallback) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (typeof iteratorFn === 'function') {
      {
        // Warn about using Maps as children
        if (iteratorFn === children.entries) {
          warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', ReactDebugCurrentFrame.getStackAddendum());
          didWarnAboutMaps = true;
        }
      }

      var iterator = iteratorFn.call(children);
      var step;
      var ii = 0;
      while (!(step = iterator.next()).done) {
        child = step.value;
        nextName = nextNamePrefix + getComponentKey(child, ii++);
        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
      }
    } else if (type === 'object') {
      var addendum = '';
      {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();
      }
      var childrenString = '' + children;
      invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (typeof component === 'object' && component !== null && component.key != null) {
    // Explicit key
    return escape(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

function forEachSingleChild(bookKeeping, child, name) {
  var func = bookKeeping.func,
      context = bookKeeping.context;

  func.call(context, child, bookKeeping.count++);
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#react.children.foreach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }
  var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  releaseTraverseContext(traverseContext);
}

function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  var result = bookKeeping.result,
      keyPrefix = bookKeeping.keyPrefix,
      func = bookKeeping.func,
      context = bookKeeping.context;


  var mappedChild = func.call(context, child, bookKeeping.count++);
  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
  } else if (mappedChild != null) {
    if (isValidElement(mappedChild)) {
      mappedChild = cloneAndReplaceKey(mappedChild,
      // Keep both the (mapped) and old keys if they differ, just as
      // traverseAllChildren used to do for objects as children
      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
    }
    result.push(mappedChild);
  }
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  var escapedPrefix = '';
  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
  }
  var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  releaseTraverseContext(traverseContext);
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#react.children.map
 *
 * The provided mapFunction(child, key, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
  return result;
}

/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#react.children.count
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */
function countChildren(children, context) {
  return traverseAllChildren(children, emptyFunction.thatReturnsNull, null);
}

/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://reactjs.org/docs/react-api.html#react.children.toarray
 */
function toArray(children) {
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
  return result;
}

/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://reactjs.org/docs/react-api.html#react.children.only
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */
function onlyChild(children) {
  !isValidElement(children) ? invariant(false, 'React.Children.only expected to receive a single React element child.') : void 0;
  return children;
}

var describeComponentFrame = function (name, source, ownerName) {
  return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
};

function getComponentName(fiber) {
  var type = fiber.type;

  if (typeof type === 'string') {
    return type;
  }
  if (typeof type === 'function') {
    return type.displayName || type.name;
  }
  return null;
}

/**
 * ReactElementValidator provides a wrapper around a element factory
 * which validates the props passed to the element. This is intended to be
 * used only in DEV and could be replaced by a static type checker for languages
 * that support it.
 */

{
  var currentlyValidatingElement = null;

  var propTypesMisspellWarningShown = false;

  var getDisplayName = function (element) {
    if (element == null) {
      return '#empty';
    } else if (typeof element === 'string' || typeof element === 'number') {
      return '#text';
    } else if (typeof element.type === 'string') {
      return element.type;
    } else if (element.type === REACT_FRAGMENT_TYPE) {
      return 'React.Fragment';
    } else {
      return element.type.displayName || element.type.name || 'Unknown';
    }
  };

  var getStackAddendum = function () {
    var stack = '';
    if (currentlyValidatingElement) {
      var name = getDisplayName(currentlyValidatingElement);
      var owner = currentlyValidatingElement._owner;
      stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner));
    }
    stack += ReactDebugCurrentFrame.getStackAddendum() || '';
    return stack;
  };

  var VALID_FRAGMENT_PROPS = new Map([['children', true], ['key', true]]);
}

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = getComponentName(ReactCurrentOwner.current);
    if (name) {
      return '\n\nCheck the render method of `' + name + '`.';
    }
  }
  return '';
}

function getSourceInfoErrorAddendum(elementProps) {
  if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
    var source = elementProps.__source;
    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
    var lineNumber = source.lineNumber;
    return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
  }
  return '';
}

/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */
var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
    if (parentName) {
      info = '\n\nCheck the top-level render call using <' + parentName + '>.';
    }
  }
  return info;
}

/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */
function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }
  element._store.validated = true;

  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
    return;
  }
  ownerHasKeyUseWarning[currentComponentErrorInfo] = true;

  // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.
  var childOwner = '';
  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = ' It was passed a child from ' + getComponentName(element._owner) + '.';
  }

  currentlyValidatingElement = element;
  {
    warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, getStackAddendum());
  }
  currentlyValidatingElement = null;
}

/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */
function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }
  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];
      if (isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);
    if (typeof iteratorFn === 'function') {
      // Entry iterators used to provide implicit keys,
      // but now we print a separate warning for them later.
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;
        while (!(step = iterator.next()).done) {
          if (isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}

/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */
function validatePropTypes(element) {
  var componentClass = element.type;
  if (typeof componentClass !== 'function') {
    return;
  }
  var name = componentClass.displayName || componentClass.name;
  var propTypes = componentClass.propTypes;
  if (propTypes) {
    currentlyValidatingElement = element;
    checkPropTypes(propTypes, element.props, 'prop', name, getStackAddendum);
    currentlyValidatingElement = null;
  } else if (componentClass.PropTypes !== undefined && !propTypesMisspellWarningShown) {
    propTypesMisspellWarningShown = true;
    warning(false, 'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');
  }
  if (typeof componentClass.getDefaultProps === 'function') {
    warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
  }
}

/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */
function validateFragmentProps(fragment) {
  currentlyValidatingElement = fragment;

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = Object.keys(fragment.props)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;

      if (!VALID_FRAGMENT_PROPS.has(key)) {
        warning(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.%s', key, getStackAddendum());
        break;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator['return']) {
        _iterator['return']();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (fragment.ref !== null) {
    warning(false, 'Invalid attribute `ref` supplied to `React.Fragment`.%s', getStackAddendum());
  }

  currentlyValidatingElement = null;
}

function createElementWithValidation(type, props, children) {
  var validType = typeof type === 'string' || typeof type === 'function' || typeof type === 'symbol' || typeof type === 'number';
  // We warn in this case but don't throw. We expect the element creation to
  // succeed and there will likely be errors in render.
  if (!validType) {
    var info = '';
    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
      info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
    }

    var sourceInfo = getSourceInfoErrorAddendum(props);
    if (sourceInfo) {
      info += sourceInfo;
    } else {
      info += getDeclarationErrorAddendum();
    }

    info += getStackAddendum() || '';

    warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', type == null ? type : typeof type, info);
  }

  var element = createElement.apply(this, arguments);

  // The result can be nullish if a mock or a custom function is used.
  // TODO: Drop this when these are no longer allowed as the type argument.
  if (element == null) {
    return element;
  }

  // Skip key warning if the type isn't valid since our key validation logic
  // doesn't expect a non-string/function type and can throw confusing errors.
  // We don't want exception behavior to differ between dev and prod.
  // (Rendering will throw with a helpful message and as soon as the type is
  // fixed, the key warnings will appear.)
  if (validType) {
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], type);
    }
  }

  if (typeof type === 'symbol' && type === REACT_FRAGMENT_TYPE) {
    validateFragmentProps(element);
  } else {
    validatePropTypes(element);
  }

  return element;
}

function createFactoryWithValidation(type) {
  var validatedFactory = createElementWithValidation.bind(null, type);
  // Legacy hook TODO: Warn if this is accessed
  validatedFactory.type = type;

  {
    Object.defineProperty(validatedFactory, 'type', {
      enumerable: false,
      get: function () {
        lowPriorityWarning$1(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
        Object.defineProperty(this, 'type', {
          value: type
        });
        return type;
      }
    });
  }

  return validatedFactory;
}

function cloneElementWithValidation(element, props, children) {
  var newElement = cloneElement.apply(this, arguments);
  for (var i = 2; i < arguments.length; i++) {
    validateChildKeys(arguments[i], newElement.type);
  }
  validatePropTypes(newElement);
  return newElement;
}

var React = {
  Children: {
    map: mapChildren,
    forEach: forEachChildren,
    count: countChildren,
    toArray: toArray,
    only: onlyChild
  },

  Component: Component,
  PureComponent: PureComponent,
  unstable_AsyncComponent: AsyncComponent,

  Fragment: REACT_FRAGMENT_TYPE,

  createElement: createElementWithValidation,
  cloneElement: cloneElementWithValidation,
  createFactory: createFactoryWithValidation,
  isValidElement: isValidElement,

  version: ReactVersion,

  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
    ReactCurrentOwner: ReactCurrentOwner,
    // Used by renderers to avoid bundling object-assign twice in UMD bundles:
    assign: _assign
  }
};

{
  _assign(React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, {
    // These should not be included in production.
    ReactDebugCurrentFrame: ReactDebugCurrentFrame,
    // Shim for React DOM 16.0.0 which still destructured (but not used) this.
    // TODO: remove in React 17.0.
    ReactComponentTreeHook: {}
  });
}



var React$2 = Object.freeze({
	default: React
});

var React$3 = ( React$2 && React ) || React$2;

// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var react = React$3['default'] ? React$3['default'] : React$3;

module.exports = react;
  })();
}


/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ "./node_modules/react/cjs/react.development.js");
}


/***/ }),

/***/ "./node_modules/typestyle/lib.es2015/index.js":
/*!****************************************************!*\
  !*** ./node_modules/typestyle/lib.es2015/index.js ***!
  \****************************************************/
/*! exports provided: TypeStyle, types, extend, classes, media, setStylesTarget, cssRaw, cssRule, forceRenderStyles, fontFace, getStyles, keyframes, reinit, style, stylesheet, createTypeStyle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setStylesTarget", function() { return setStylesTarget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cssRaw", function() { return cssRaw; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cssRule", function() { return cssRule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forceRenderStyles", function() { return forceRenderStyles; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fontFace", function() { return fontFace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getStyles", function() { return getStyles; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keyframes", function() { return keyframes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reinit", function() { return reinit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "style", function() { return style; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stylesheet", function() { return stylesheet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createTypeStyle", function() { return createTypeStyle; });
/* harmony import */ var _internal_typestyle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/typestyle */ "./node_modules/typestyle/lib.es2015/internal/typestyle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TypeStyle", function() { return _internal_typestyle__WEBPACK_IMPORTED_MODULE_0__["TypeStyle"]; });

/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ "./node_modules/typestyle/lib.es2015/types.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "types", function() { return _types__WEBPACK_IMPORTED_MODULE_1__; });
/* harmony import */ var _internal_utilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/utilities */ "./node_modules/typestyle/lib.es2015/internal/utilities.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return _internal_utilities__WEBPACK_IMPORTED_MODULE_2__["extend"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "classes", function() { return _internal_utilities__WEBPACK_IMPORTED_MODULE_2__["classes"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "media", function() { return _internal_utilities__WEBPACK_IMPORTED_MODULE_2__["media"]; });



/**
 * All the CSS types in the 'types' namespace
 */


/**
 * Export certain utilities
 */

/** Zero configuration, default instance of TypeStyle */
var ts = new _internal_typestyle__WEBPACK_IMPORTED_MODULE_0__["TypeStyle"]({ autoGenerateTag: true });
/** Sets the target tag where we write the css on style updates */
var setStylesTarget = ts.setStylesTarget;
/**
 * Insert `raw` CSS as a string. This is useful for e.g.
 * - third party CSS that you are customizing with template strings
 * - generating raw CSS in JavaScript
 * - reset libraries like normalize.css that you can use without loaders
 */
var cssRaw = ts.cssRaw;
/**
 * Takes CSSProperties and registers it to a global selector (body, html, etc.)
 */
var cssRule = ts.cssRule;
/**
 * Renders styles to the singleton tag imediately
 * NOTE: You should only call it on initial render to prevent any non CSS flash.
 * After that it is kept sync using `requestAnimationFrame` and we haven't noticed any bad flashes.
 **/
var forceRenderStyles = ts.forceRenderStyles;
/**
 * Utility function to register an @font-face
 */
var fontFace = ts.fontFace;
/**
 * Allows use to use the stylesheet in a node.js environment
 */
var getStyles = ts.getStyles;
/**
 * Takes keyframes and returns a generated animationName
 */
var keyframes = ts.keyframes;
/**
 * Helps with testing. Reinitializes FreeStyle + raw
 */
var reinit = ts.reinit;
/**
 * Takes CSSProperties and return a generated className you can use on your component
 */
var style = ts.style;
/**
 * Takes an object where property names are ideal class names and property values are CSSProperties, and
 * returns an object where property names are the same ideal class names and the property values are
 * the actual generated class names using the ideal class name as the $debugName
 */
var stylesheet = ts.stylesheet;
/**
 * Creates a new instance of TypeStyle separate from the default instance.
 *
 * - Use this for creating a different typestyle instance for a shadow dom component.
 * - Use this if you don't want an auto tag generated and you just want to collect the CSS.
 *
 * NOTE: styles aren't shared between different instances.
 */
function createTypeStyle(target) {
    var instance = new _internal_typestyle__WEBPACK_IMPORTED_MODULE_0__["TypeStyle"]({ autoGenerateTag: false });
    if (target) {
        instance.setStylesTarget(target);
    }
    return instance;
}


/***/ }),

/***/ "./node_modules/typestyle/lib.es2015/internal/formatting.js":
/*!******************************************************************!*\
  !*** ./node_modules/typestyle/lib.es2015/internal/formatting.js ***!
  \******************************************************************/
/*! exports provided: ensureStringObj, explodeKeyframes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ensureStringObj", function() { return ensureStringObj; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "explodeKeyframes", function() { return explodeKeyframes; });
/* harmony import */ var free_style__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! free-style */ "./node_modules/free-style/dist/free-style.js");
/* harmony import */ var free_style__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(free_style__WEBPACK_IMPORTED_MODULE_0__);

/**
 * We need to do the following to *our* objects before passing to freestyle:
 * - For any `$nest` directive move up to FreeStyle style nesting
 * - For any `$unique` directive map to FreeStyle Unique
 * - For any `$debugName` directive return the debug name
 */
function ensureStringObj(object) {
    /** The final result we will return */
    var result = {};
    var debugName = '';
    for (var key in object) {
        /** Grab the value upfront */
        var val = object[key];
        /** TypeStyle configuration options */
        if (key === '$unique') {
            result[free_style__WEBPACK_IMPORTED_MODULE_0__["IS_UNIQUE"]] = val;
        }
        else if (key === '$nest') {
            var nested = val;
            for (var selector in nested) {
                var subproperties = nested[selector];
                result[selector] = ensureStringObj(subproperties).result;
            }
        }
        else if (key === '$debugName') {
            debugName = val;
        }
        else {
            result[key] = val;
        }
    }
    return { result: result, debugName: debugName };
}
// todo: better name here
function explodeKeyframes(frames) {
    var result = { $debugName: undefined, keyframes: {} };
    for (var offset in frames) {
        var val = frames[offset];
        if (offset === '$debugName') {
            result.$debugName = val;
        }
        else {
            result.keyframes[offset] = val;
        }
    }
    return result;
}


/***/ }),

/***/ "./node_modules/typestyle/lib.es2015/internal/typestyle.js":
/*!*****************************************************************!*\
  !*** ./node_modules/typestyle/lib.es2015/internal/typestyle.js ***!
  \*****************************************************************/
/*! exports provided: TypeStyle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TypeStyle", function() { return TypeStyle; });
/* harmony import */ var _formatting__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatting */ "./node_modules/typestyle/lib.es2015/internal/formatting.js");
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utilities */ "./node_modules/typestyle/lib.es2015/internal/utilities.js");
/* harmony import */ var free_style__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! free-style */ "./node_modules/free-style/dist/free-style.js");
/* harmony import */ var free_style__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(free_style__WEBPACK_IMPORTED_MODULE_2__);



/**
 * Creates an instance of free style with our options
 */
var createFreeStyle = function () { return free_style__WEBPACK_IMPORTED_MODULE_2__["create"](
/** Use the default hash function */
undefined, 
/** Preserve $debugName values */
true); };
/**
 * Maintains a single stylesheet and keeps it in sync with requested styles
 */
var TypeStyle = /** @class */ (function () {
    function TypeStyle(_a) {
        var autoGenerateTag = _a.autoGenerateTag;
        var _this = this;
        /**
         * Insert `raw` CSS as a string. This is useful for e.g.
         * - third party CSS that you are customizing with template strings
         * - generating raw CSS in JavaScript
         * - reset libraries like normalize.css that you can use without loaders
         */
        this.cssRaw = function (mustBeValidCSS) {
            if (!mustBeValidCSS) {
                return;
            }
            _this._raw += mustBeValidCSS || '';
            _this._pendingRawChange = true;
            _this._styleUpdated();
        };
        /**
         * Takes CSSProperties and registers it to a global selector (body, html, etc.)
         */
        this.cssRule = function (selector) {
            var objects = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                objects[_i - 1] = arguments[_i];
            }
            var object = Object(_formatting__WEBPACK_IMPORTED_MODULE_0__["ensureStringObj"])(_utilities__WEBPACK_IMPORTED_MODULE_1__["extend"].apply(void 0, objects)).result;
            _this._freeStyle.registerRule(selector, object);
            _this._styleUpdated();
            return;
        };
        /**
         * Renders styles to the singleton tag imediately
         * NOTE: You should only call it on initial render to prevent any non CSS flash.
         * After that it is kept sync using `requestAnimationFrame` and we haven't noticed any bad flashes.
         **/
        this.forceRenderStyles = function () {
            var target = _this._getTag();
            if (!target) {
                return;
            }
            target.textContent = _this.getStyles();
        };
        /**
         * Utility function to register an @font-face
         */
        this.fontFace = function () {
            var fontFace = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                fontFace[_i] = arguments[_i];
            }
            var freeStyle = _this._freeStyle;
            for (var _a = 0, _b = fontFace; _a < _b.length; _a++) {
                var face = _b[_a];
                freeStyle.registerRule('@font-face', face);
            }
            _this._styleUpdated();
            return;
        };
        /**
         * Allows use to use the stylesheet in a node.js environment
         */
        this.getStyles = function () {
            return (_this._raw || '') + _this._freeStyle.getStyles();
        };
        /**
         * Takes keyframes and returns a generated animationName
         */
        this.keyframes = function (frames) {
            var _a = Object(_formatting__WEBPACK_IMPORTED_MODULE_0__["explodeKeyframes"])(frames), keyframes = _a.keyframes, $debugName = _a.$debugName;
            // TODO: replace $debugName with display name
            var animationName = _this._freeStyle.registerKeyframes(keyframes, $debugName);
            _this._styleUpdated();
            return animationName;
        };
        /**
         * Helps with testing. Reinitializes FreeStyle + raw
         */
        this.reinit = function () {
            /** reinit freestyle */
            var freeStyle = createFreeStyle();
            _this._freeStyle = freeStyle;
            _this._lastFreeStyleChangeId = freeStyle.changeId;
            /** reinit raw */
            _this._raw = '';
            _this._pendingRawChange = false;
            /** Clear any styles that were flushed */
            var target = _this._getTag();
            if (target) {
                target.textContent = '';
            }
        };
        /** Sets the target tag where we write the css on style updates */
        this.setStylesTarget = function (tag) {
            /** Clear any data in any previous tag */
            if (_this._tag) {
                _this._tag.textContent = '';
            }
            _this._tag = tag;
            /** This special time buffer immediately */
            _this.forceRenderStyles();
        };
        /**
         * Takes CSSProperties and return a generated className you can use on your component
         */
        this.style = function () {
            var objects = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                objects[_i] = arguments[_i];
            }
            var freeStyle = _this._freeStyle;
            var _a = Object(_formatting__WEBPACK_IMPORTED_MODULE_0__["ensureStringObj"])(_utilities__WEBPACK_IMPORTED_MODULE_1__["extend"].apply(void 0, objects)), result = _a.result, debugName = _a.debugName;
            var className = debugName ? freeStyle.registerStyle(result, debugName) : freeStyle.registerStyle(result);
            _this._styleUpdated();
            return className;
        };
        /**
         * Takes an object where property names are ideal class names and property values are CSSProperties, and
         * returns an object where property names are the same ideal class names and the property values are
         * the actual generated class names using the ideal class name as the $debugName
         */
        this.stylesheet = function (classes) {
            var classNames = Object.getOwnPropertyNames(classes);
            var result = {};
            for (var _i = 0, classNames_1 = classNames; _i < classNames_1.length; _i++) {
                var className = classNames_1[_i];
                var classDef = classes[className];
                if (classDef) {
                    classDef.$debugName = className;
                    result[className] = _this.style(classDef);
                }
            }
            return result;
        };
        var freeStyle = createFreeStyle();
        this._autoGenerateTag = autoGenerateTag;
        this._freeStyle = freeStyle;
        this._lastFreeStyleChangeId = freeStyle.changeId;
        this._pending = 0;
        this._pendingRawChange = false;
        this._raw = '';
        this._tag = undefined;
    }
    /**
     * Only calls cb all sync operations settle
     */
    TypeStyle.prototype._afterAllSync = function (cb) {
        var _this = this;
        this._pending++;
        var pending = this._pending;
        Object(_utilities__WEBPACK_IMPORTED_MODULE_1__["raf"])(function () {
            if (pending !== _this._pending) {
                return;
            }
            cb();
        });
    };
    TypeStyle.prototype._getTag = function () {
        if (this._tag) {
            return this._tag;
        }
        if (this._autoGenerateTag) {
            var tag = typeof window === 'undefined'
                ? { textContent: '' }
                : document.createElement('style');
            if (typeof document !== 'undefined') {
                document.head.appendChild(tag);
            }
            this._tag = tag;
            return tag;
        }
        return undefined;
    };
    /** Checks if the style tag needs updating and if so queues up the change */
    TypeStyle.prototype._styleUpdated = function () {
        var _this = this;
        var changeId = this._freeStyle.changeId;
        var lastChangeId = this._lastFreeStyleChangeId;
        if (!this._pendingRawChange && changeId === lastChangeId) {
            return;
        }
        this._lastFreeStyleChangeId = changeId;
        this._pendingRawChange = false;
        this._afterAllSync(function () { return _this.forceRenderStyles(); });
    };
    return TypeStyle;
}());



/***/ }),

/***/ "./node_modules/typestyle/lib.es2015/internal/utilities.js":
/*!*****************************************************************!*\
  !*** ./node_modules/typestyle/lib.es2015/internal/utilities.js ***!
  \*****************************************************************/
/*! exports provided: raf, classes, extend, media */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "raf", function() { return raf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "classes", function() { return classes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "media", function() { return media; });
/** Raf for node + browser */
var raf = typeof requestAnimationFrame === 'undefined'
    /**
     * make sure setTimeout is always invoked with
     * `this` set to `window` or `global` automatically
     **/
    ? function (cb) { return setTimeout(cb); }
    /** make sure raf is always invoked with `this` window */
    : requestAnimationFrame.bind(window);
/**
 * Utility to join classes conditionally
 */
function classes() {
    var classes = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        classes[_i] = arguments[_i];
    }
    return classes.filter(function (c) { return !!c; }).join(' ');
}
/**
 * Merges various styles into a single style object.
 * Note: if two objects have the same property the last one wins
 */
function extend() {
    var objects = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        objects[_i] = arguments[_i];
    }
    /** The final result we will return */
    var result = {};
    for (var _a = 0, objects_1 = objects; _a < objects_1.length; _a++) {
        var object = objects_1[_a];
        if (object == null || object === false) {
            continue;
        }
        for (var key in object) {
            /** Falsy values except a explicit 0 is ignored */
            var val = object[key];
            if (!val && val !== 0) {
                continue;
            }
            /** if nested media or pseudo selector */
            if (key === '$nest' && val) {
                result[key] = result['$nest'] ? extend(result['$nest'], val) : val;
            }
            else if ((key.indexOf('&') !== -1 || key.indexOf('@media') === 0)) {
                result[key] = result[key] ? extend(result[key], val) : val;
            }
            else {
                result[key] = val;
            }
        }
    }
    return result;
}
/**
 * Utility to help customize styles with media queries. e.g.
 * ```
 * style(
 *  media({maxWidth:500}, {color:'red'})
 * )
 * ```
 */
var media = function (mediaQuery) {
    var objects = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        objects[_i - 1] = arguments[_i];
    }
    var mediaQuerySections = [];
    if (mediaQuery.type)
        mediaQuerySections.push(mediaQuery.type);
    if (mediaQuery.orientation)
        mediaQuerySections.push("(orientation: " + mediaQuery.orientation + ")");
    if (mediaQuery.minWidth)
        mediaQuerySections.push("(min-width: " + mediaLength(mediaQuery.minWidth) + ")");
    if (mediaQuery.maxWidth)
        mediaQuerySections.push("(max-width: " + mediaLength(mediaQuery.maxWidth) + ")");
    if (mediaQuery.minHeight)
        mediaQuerySections.push("(min-height: " + mediaLength(mediaQuery.minHeight) + ")");
    if (mediaQuery.maxHeight)
        mediaQuerySections.push("(max-height: " + mediaLength(mediaQuery.maxHeight) + ")");
    var stringMediaQuery = "@media " + mediaQuerySections.join(' and ');
    var object = {
        $nest: (_a = {},
            _a[stringMediaQuery] = extend.apply(void 0, objects),
            _a)
    };
    return object;
    var _a;
};
var mediaLength = function (value) {
    return typeof value === 'string' ? value : value + "px";
};


/***/ }),

/***/ "./node_modules/typestyle/lib.es2015/types.js":
/*!****************************************************!*\
  !*** ./node_modules/typestyle/lib.es2015/types.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {



/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/core/utils.ts":
/*!***************************!*\
  !*** ./src/core/utils.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function shuffle(array) {
    var currentIndex = array.length, temporaryValue, randomIndex;
    // While there remain elements to shuffle...
    while (0 !== currentIndex) {
        // Pick a remaining element...
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex -= 1;
        // And swap it with the current element.
        temporaryValue = array[currentIndex];
        array[currentIndex] = array[randomIndex];
        array[randomIndex] = temporaryValue;
    }
    return array;
}
exports.shuffle = shuffle;


/***/ }),

/***/ "./src/images/1.png":
/*!**************************!*\
  !*** ./src/images/1.png ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "./src/images/2.png":
/*!**************************!*\
  !*** ./src/images/2.png ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "./src/images/3.png":
/*!**************************!*\
  !*** ./src/images/3.png ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),

/***/ "./src/main.tsx":
/*!**********************!*\
  !*** ./src/main.tsx ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var ReactDOM = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js");
var Puzzle_1 = __webpack_require__(/*! ./puzzel/Puzzle */ "./src/puzzel/Puzzle.tsx");
var typestyle_1 = __webpack_require__(/*! typestyle */ "./node_modules/typestyle/lib.es2015/index.js");
var wrapperStyle = typestyle_1.style({
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    height: "100%"
});
typestyle_1.cssRaw("\n  html, body, #main {\n    height: 100%;\n    user-select: none;\n  }\n");
ReactDOM.render(React.createElement("div", { className: wrapperStyle },
    React.createElement(Puzzle_1.default, null)), document.getElementById("main"));


/***/ }),

/***/ "./src/puzzel/Piece.tsx":
/*!******************************!*\
  !*** ./src/puzzel/Piece.tsx ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var typestyle_1 = __webpack_require__(/*! typestyle */ "./node_modules/typestyle/lib.es2015/index.js");
var mobx_react_1 = __webpack_require__(/*! mobx-react */ "./node_modules/mobx-react/index.module.js");
var Piece = /** @class */ (function (_super) {
    __extends(Piece, _super);
    function Piece() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Piece.prototype.render = function () {
        var _this = this;
        return (React.createElement("div", { className: [
                pieceStyle(this.props.number),
                this.props.puzzelModel.isTouching(this.props.index) && "touching"
            ].join(" "), onClick: function () { return _this.props.puzzelModel.select(_this.props.index); } }, this.props.number != null ? (React.createElement("img", { src: this.props.puzzelModel.image })) : (React.createElement("span", null))));
    };
    Piece = __decorate([
        mobx_react_1.observer
    ], Piece);
    return Piece;
}(React.Component));
exports.default = Piece;
var pieceStyle = function (index) {
    return typestyle_1.style({
        height: 96,
        width: 96,
        margin: 2,
        display: "inline-block",
        background: "grey",
        overflow: "hidden",
        position: "relative",
        transform: "translate3d(0, 0, 0)",
        $nest: {
            "&.touching:hover": {
                opacity: 0.5
            },
            img: {
                marginTop: -Math.floor((index - 1) / 3) * 100,
                marginLeft: -Math.abs((index - 1) % 3) * 100
            }
        }
    });
};


/***/ }),

/***/ "./src/puzzel/PuzzelModel.ts":
/*!***********************************!*\
  !*** ./src/puzzel/PuzzelModel.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var mobx_1 = __webpack_require__(/*! mobx */ "./node_modules/mobx/lib/mobx.module.js");
var utils_1 = __webpack_require__(/*! ../core/utils */ "./src/core/utils.ts");
var PuzzleModel = /** @class */ (function () {
    function PuzzleModel() {
        this.pieces = [1, 2, 3, 4, 5, 6, 7, 8, null];
        this.original = this.pieces.concat([]);
        this.solved = this.getHash();
        this.current = this.pieces.indexOf(null);
        this.images = [
            __webpack_require__(/*! ../images/1.png */ "./src/images/1.png"),
            __webpack_require__(/*! ../images/2.png */ "./src/images/2.png"),
            __webpack_require__(/*! ../images/3.png */ "./src/images/3.png")
        ];
        this.image = this.images[0];
        this.preview = false;
        this.randomize();
    }
    PuzzleModel.prototype.randomize = function () {
        this.pieces = utils_1.shuffle(this.pieces);
        this.current = this.pieces.indexOf(null);
    };
    PuzzleModel.prototype.select = function (index) {
        if (!this.isTouching(index)) {
            return;
        }
        this.pieces[this.current] = this.pieces[index];
        this.pieces[index] = null;
        this.current = index;
        if (this.getHash() == this.solved) {
            window.alert("CONGRATULATIONS!!");
        }
    };
    PuzzleModel.prototype.changeImage = function (image) {
        this.image = image;
        this.randomize();
    };
    PuzzleModel.prototype.startPreview = function () {
        this.preview = true;
    };
    PuzzleModel.prototype.endPreview = function () {
        this.preview = false;
    };
    PuzzleModel.prototype.getHash = function () {
        return JSON.stringify(this.pieces);
    };
    PuzzleModel.prototype.isActive = function (index) {
        return index == this.current;
    };
    // find if the square is a distance of 1 from the currently active index
    PuzzleModel.prototype.isTouching = function (index) {
        var dx = Math.abs(Math.abs(this.current % 3) - Math.abs(index % 3));
        var dy = Math.abs(Math.floor(this.current / 3) - Math.floor(index / 3));
        return dx + dy == 1;
    };
    __decorate([
        mobx_1.observable
    ], PuzzleModel.prototype, "pieces", void 0);
    __decorate([
        mobx_1.observable
    ], PuzzleModel.prototype, "original", void 0);
    __decorate([
        mobx_1.observable
    ], PuzzleModel.prototype, "solved", void 0);
    __decorate([
        mobx_1.observable
    ], PuzzleModel.prototype, "current", void 0);
    __decorate([
        mobx_1.observable
    ], PuzzleModel.prototype, "images", void 0);
    __decorate([
        mobx_1.observable
    ], PuzzleModel.prototype, "image", void 0);
    __decorate([
        mobx_1.observable
    ], PuzzleModel.prototype, "preview", void 0);
    __decorate([
        mobx_1.action
    ], PuzzleModel.prototype, "randomize", null);
    __decorate([
        mobx_1.action
    ], PuzzleModel.prototype, "select", null);
    __decorate([
        mobx_1.action
    ], PuzzleModel.prototype, "changeImage", null);
    __decorate([
        mobx_1.action
    ], PuzzleModel.prototype, "startPreview", null);
    __decorate([
        mobx_1.action
    ], PuzzleModel.prototype, "endPreview", null);
    return PuzzleModel;
}());
exports.default = PuzzleModel;


/***/ }),

/***/ "./src/puzzel/Puzzle.tsx":
/*!*******************************!*\
  !*** ./src/puzzel/Puzzle.tsx ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var mobx_react_1 = __webpack_require__(/*! mobx-react */ "./node_modules/mobx-react/index.module.js");
var Piece_1 = __webpack_require__(/*! ./Piece */ "./src/puzzel/Piece.tsx");
var typestyle_1 = __webpack_require__(/*! typestyle */ "./node_modules/typestyle/lib.es2015/index.js");
var PuzzelModel_1 = __webpack_require__(/*! ./PuzzelModel */ "./src/puzzel/PuzzelModel.ts");
var react_flip_move_1 = __webpack_require__(/*! react-flip-move */ "./node_modules/react-flip-move/dist/react-flip-move.es.js");
var Puzzle = /** @class */ (function (_super) {
    __extends(Puzzle, _super);
    function Puzzle() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.model = new PuzzelModel_1.default();
        return _this;
    }
    Puzzle.prototype.render = function () {
        var _this = this;
        var pieces = this.model.preview ? this.model.original : this.model.pieces;
        return (React.createElement("div", { className: puzzleStyle },
            React.createElement("div", { className: "pieces" },
                React.createElement(react_flip_move_1.default, { duration: 200, easing: "ease-out" }, pieces.map(function (number, ix) { return (React.createElement(Piece_1.default, { key: number, index: ix, number: number, puzzelModel: _this.model })); }))),
            React.createElement("button", { onClick: function () { return _this.model.randomize(); } }, "Randomize!"),
            React.createElement("button", { onMouseDown: function () { return _this.model.startPreview(); }, onMouseUp: function () { return _this.model.endPreview(); } }, "Preview"),
            React.createElement("div", null, this.model.images.map(function (image) { return (React.createElement("img", { src: image, className: "thumb", onClick: function () { return _this.model.changeImage(image); } })); }))));
    };
    Puzzle = __decorate([
        mobx_react_1.observer
    ], Puzzle);
    return Puzzle;
}(React.Component));
exports.default = Puzzle;
var puzzleStyle = typestyle_1.style({
    background: "white",
    padding: 10,
    width: 300,
    lineHeight: 0,
    $nest: {
        ".thumb": {
            width: 50,
            height: 50,
            margin: "10px 10px 0 0"
        },
        button: {
            margin: "10px 5px 0 0"
        }
    }
});


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL0V2ZW50TGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9jYW1lbGl6ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NvbnRhaW5zTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2ZvY3VzTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaHlwaGVuYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaXNOb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pc1RleHROb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9zaGFsbG93RXF1YWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL3dhcm5pbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZyZWUtc3R5bGUvZGlzdC9mcmVlLXN0eWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb2J4LXJlYWN0L2luZGV4Lm1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9ieC9saWIvbW9ieC5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWZsaXAtbW92ZS9kaXN0L3JlYWN0LWZsaXAtbW92ZS5lcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHlwZXN0eWxlL2xpYi5lczIwMTUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R5cGVzdHlsZS9saWIuZXMyMDE1L2ludGVybmFsL2Zvcm1hdHRpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R5cGVzdHlsZS9saWIuZXMyMDE1L2ludGVybmFsL3R5cGVzdHlsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHlwZXN0eWxlL2xpYi5lczIwMTUvaW50ZXJuYWwvdXRpbGl0aWVzLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvdXRpbHMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ltYWdlcy8xLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvaW1hZ2VzLzIucG5nIiwid2VicGFjazovLy8uL3NyYy9pbWFnZXMvMy5wbmciLCJ3ZWJwYWNrOi8vLy4vc3JjL21haW4udHN4Iiwid2VicGFjazovLy8uL3NyYy9wdXp6ZWwvUGllY2UudHN4Iiwid2VicGFjazovLy8uL3NyYy9wdXp6ZWwvUHV6emVsTW9kZWwudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3B1enplbC9QdXp6bGUudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlEQUFpRCxjQUFjO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOzs7QUFHQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLE9BQU87QUFDcEIsYUFBYSxTQUFTO0FBQ3RCLGNBQWMsT0FBTztB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O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7O0FBTUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7OztBQVVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsYUFBYTtBQUN2RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSw4RkFBOEYsZUFBZTtBQUM3RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLHFCQUFxQiw4QkFBOEI7QUFDbkQsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsMkVBQTJFLGFBQWE7QUFDeEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0VBQWdFO0FBQ2pGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3Qjs7QUFFeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLDhCQUE4QixFQUFFO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLEVBQUU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRyxpQkFBaUIsRUFBRTtBQUM3SCxzRUFBc0UsaUJBQWlCLEVBQUU7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVyxXQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCx1REFBdUQsRUFBRTtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHFCQUFxQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx5QkFBeUI7QUFDM0QsOEJBQThCLHVDQUF1QztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0Esb0RBQW9ELDhDQUE4QyxFQUFFO0FBQ3BHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0Q0FBNEM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVOzs7Ozs7Ozs7Ozs7O0FDdkx0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLDRCQUE0QjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsRUFBRTtBQUNmLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsRUFBRTtBQUNmLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0Q0FBNEM7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQSw4QkFBOEIsVUFBVTtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQiwwQkFBMEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakIsc0JBQXNCOztBQUV0QjtBQUNBLGtCQUFrQjtBQUNsQixlQUFlO0FBQ2YsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQixzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCLGFBQWE7QUFDYixjQUFjOztBQUVkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxpQkFBaUIsa0NBQWtDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixpQkFBaUIsRUFBRTtBQUNyQyx5QkFBeUIsd0JBQXdCLEVBQUU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix5QkFBeUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsV0FBVztBQUN0QixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7O0FBRWY7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix5QkFBeUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrS0FBa0sseUNBQXlDO0FBQzNNO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrREFBa0Q7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZCQUE2QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSw2QkFBNkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxpQ0FBaUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkMsTUFBTTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFELG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AseUNBQXlDO0FBQ3pDLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhNQUE4TTtBQUM5TTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZEQUE2RCxtQkFBbUI7QUFDaEY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7OztBQUdMOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHNGQUFzRixhQUFhO0FBQ25HO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixlQUFlO0FBQzNHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsT0FBTztBQUNsQixXQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixzQkFBc0I7QUFDakQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxFQUFFO0FBQ2IsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhLQUE4SyxZQUFZO0FBQzFMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUxBQXVMLCtCQUErQjtBQUN0Tjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtKQUErSixpQkFBaUI7QUFDaEwsT0FBTztBQUNQLCtKQUErSixpQkFBaUIsd0RBQXdELG1CQUFtQixnQkFBZ0IsOEJBQThCO0FBQ3pTO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMElBQTBJLG1CQUFtQixnQkFBZ0IsOEJBQThCO0FBQzNNLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQiwwQkFBMEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzREFBc0QsZUFBZTtBQUNyRSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQztBQUNqQyxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOzs7Ozs7Ozs7Ozs7O0FDamllQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUtDO0FBQ0Q7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckNrRTtBQUNsQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcsc0NBQXNDO0FBQ2pELFNBQVM7QUFDVCxHQUFHO0FBQ0g7QUFDQSxXQUFXLGVBQWU7QUFDMUIsU0FBUztBQUNULEdBQUc7QUFDSDtBQUNBLFdBQVcsd0RBQXdEO0FBQ25FLFNBQVM7QUFDVCxHQUFHO0FBQ0g7QUFDQSxXQUFXLHlEQUF5RDtBQUNwRSxTQUFTO0FBQ1QsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsc0NBQXNDO0FBQ2pELFNBQVM7QUFDVCxHQUFHO0FBQ0g7QUFDQSxXQUFXLGVBQWU7QUFDMUIsU0FBUztBQUNULEdBQUc7QUFDSDtBQUNBLFdBQVcsd0RBQXdEO0FBQ25FLFNBQVM7QUFDVCxHQUFHO0FBQ0g7QUFDQSxXQUFXLHlEQUF5RDtBQUNwRSxTQUFTO0FBQ1QsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNCQUFzQixrQ0FBa0M7QUFDeEQsR0FBRyxJQUFJOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixtQ0FBbUM7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FB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OztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiLFdBQVcsY0FBYztBQUN6QixXQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsV0FBVyxFQUFFO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0EsV0FBVyxHQUFHO0FBQ2QsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxFQUFFO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrRUFBK0UsZ0VBQWdFO0FBQy9JOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7Ozs7QUFJQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7Ozs7Ozs7Ozs7Ozs7QUM1MENBOztBQUVBLGFBRUM7QUFDRDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ05vQjtBQUNaO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDUTtBQUNSO0FBQ0E7QUFDQTtBQUNpQztBQUNqQztBQUNBLDRFQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQWtDLHlCQUF5QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUNBQXFDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvQzRDO0FBQ3RCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQkFBZ0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCwwQkFBMEI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGtDQUFrQyxFQUFFO0FBQzVFO0FBQ0E7QUFDQSxDQUFDO0FBQ087Ozs7Ozs7Ozs7Ozs7Ozs7O0FDek1SO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBLHdDQUF3QyxZQUFZLEVBQUU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHVCQUF1QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYSxHQUFHLFlBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNUZBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1Qzs7Ozs7Ozs7Ozs7Ozs7O0FDbkJBLGlCQUF3QixLQUFZO0lBQ2xDLElBQUksWUFBWSxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQzdCLGNBQWMsRUFDZCxXQUFXLENBQUM7SUFFZCw0Q0FBNEM7SUFDNUMsT0FBTyxDQUFDLEtBQUssWUFBWSxFQUFFLENBQUM7UUFDMUIsOEJBQThCO1FBQzlCLFdBQVcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxZQUFZLENBQUMsQ0FBQztRQUN2RCxZQUFZLElBQUksQ0FBQyxDQUFDO1FBRWxCLHdDQUF3QztRQUN4QyxjQUFjLEdBQUcsS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBQ3JDLEtBQUssQ0FBQyxZQUFZLENBQUMsR0FBRyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDekMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxHQUFHLGNBQWMsQ0FBQztJQUN0QyxDQUFDO0lBRUQsTUFBTSxDQUFDLEtBQUssQ0FBQztBQUNmLENBQUM7QUFsQkQsMEJBa0JDOzs7Ozs7Ozs7Ozs7QUNsQkQsaUNBQWlDLHc0MlA7Ozs7Ozs7Ozs7O0FDQWpDLGlDQUFpQyx3Z2dROzs7Ozs7Ozs7OztBQ0FqQyxpQ0FBaUMsZ3Y5UDs7Ozs7Ozs7Ozs7Ozs7QUNBakMsOEVBQStCO0FBQy9CLHlGQUFzQztBQUN0QyxxRkFBcUM7QUFDckMsdUdBQTBDO0FBRTFDLElBQU0sWUFBWSxHQUFHLGlCQUFLLENBQUM7SUFDekIsT0FBTyxFQUFFLE1BQU07SUFDZixjQUFjLEVBQUUsUUFBUTtJQUN4QixVQUFVLEVBQUUsUUFBUTtJQUNwQixNQUFNLEVBQUUsTUFBTTtDQUNmLENBQUMsQ0FBQztBQUVILGtCQUFNLENBQUMsMkVBS04sQ0FBQyxDQUFDO0FBRUgsUUFBUSxDQUFDLE1BQU0sQ0FDYiw2QkFBSyxTQUFTLEVBQUUsWUFBWTtJQUMxQixvQkFBQyxnQkFBTSxPQUFHLENBQ04sRUFDTixRQUFRLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxDQUNoQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeEJGLDhFQUErQjtBQUMvQix1R0FBa0M7QUFFbEMsc0dBQXNDO0FBU3RDO0lBQW1DLHlCQUEwQjtJQUE3RDs7SUFrQkEsQ0FBQztJQWpCQyxzQkFBTSxHQUFOO1FBQUEsaUJBZ0JDO1FBZkMsTUFBTSxDQUFDLENBQ0wsNkJBQ0UsU0FBUyxFQUFFO2dCQUNULFVBQVUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQztnQkFDN0IsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksVUFBVTthQUNsRSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFDWCxPQUFPLEVBQUUsY0FBTSxZQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsS0FBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBL0MsQ0FBK0MsSUFFN0QsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUMzQiw2QkFBSyxHQUFHLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsS0FBSyxHQUFJLENBQzNDLENBQUMsQ0FBQyxDQUFDLENBQ0YsaUNBQVEsQ0FDVCxDQUNHLENBQ1AsQ0FBQztJQUNKLENBQUM7SUFqQmtCLEtBQUs7UUFEekIscUJBQVE7T0FDWSxLQUFLLENBa0J6QjtJQUFELFlBQUM7Q0FBQSxDQWxCa0MsS0FBSyxDQUFDLFNBQVMsR0FrQmpEO2tCQWxCb0IsS0FBSztBQW9CMUIsSUFBTSxVQUFVLEdBQUcsZUFBSztJQUN0QixNQUFNLENBQUMsaUJBQUssQ0FBQztRQUNYLE1BQU0sRUFBRSxFQUFFO1FBQ1YsS0FBSyxFQUFFLEVBQUU7UUFDVCxNQUFNLEVBQUUsQ0FBQztRQUNULE9BQU8sRUFBRSxjQUFjO1FBQ3ZCLFVBQVUsRUFBRSxNQUFNO1FBQ2xCLFFBQVEsRUFBRSxRQUFRO1FBQ2xCLFFBQVEsRUFBRSxVQUFVO1FBQ3BCLFNBQVMsRUFBRSxzQkFBc0I7UUFDakMsS0FBSyxFQUFFO1lBQ0wsa0JBQWtCLEVBQUU7Z0JBQ2xCLE9BQU8sRUFBRSxHQUFHO2FBQ2I7WUFDRCxHQUFHLEVBQUU7Z0JBQ0gsU0FBUyxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHO2dCQUM3QyxVQUFVLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUc7YUFDN0M7U0FDRjtLQUNGLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcERGLHVGQUEwQztBQUMxQyw4RUFBd0M7QUFFeEM7SUFjRTtRQWJZLFdBQU0sR0FBYSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDbEQsYUFBUSxHQUFhLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQzVDLFdBQU0sR0FBVyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDaEMsWUFBTyxHQUFXLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRXhELFdBQU0sR0FBYTtZQUNqQixtQkFBTyxDQUFDLDJDQUFpQixDQUFDO1lBQzFCLG1CQUFPLENBQUMsMkNBQWlCLENBQUM7WUFDMUIsbUJBQU8sQ0FBQywyQ0FBaUIsQ0FBQztTQUMzQixDQUFDO1FBQ1UsVUFBSyxHQUFXLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDL0IsWUFBTyxHQUFZLEtBQUssQ0FBQztRQUduQyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7SUFDbkIsQ0FBQztJQUdELCtCQUFTLEdBQVQ7UUFDRSxJQUFJLENBQUMsTUFBTSxHQUFHLGVBQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDbkMsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMzQyxDQUFDO0lBR0QsNEJBQU0sR0FBTixVQUFPLEtBQWE7UUFDbEIsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM1QixNQUFNLENBQUM7UUFDVCxDQUFDO1FBQ0QsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMvQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLElBQUksQ0FBQztRQUMxQixJQUFJLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQztRQUVyQixFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7WUFDbEMsTUFBTSxDQUFDLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1FBQ3BDLENBQUM7SUFDSCxDQUFDO0lBR0QsaUNBQVcsR0FBWCxVQUFZLEtBQUs7UUFDZixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNuQixJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7SUFDbkIsQ0FBQztJQUdELGtDQUFZLEdBQVo7UUFDRSxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztJQUN0QixDQUFDO0lBR0QsZ0NBQVUsR0FBVjtRQUNFLElBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO0lBQ3ZCLENBQUM7SUFFRCw2QkFBTyxHQUFQO1FBQ0UsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRCw4QkFBUSxHQUFSLFVBQVMsS0FBYTtRQUNwQixNQUFNLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUM7SUFDL0IsQ0FBQztJQUVELHdFQUF3RTtJQUN4RSxnQ0FBVSxHQUFWLFVBQVcsS0FBYTtRQUN0QixJQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3RFLElBQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDMUUsTUFBTSxDQUFDLEVBQUUsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ3RCLENBQUM7SUFsRVc7UUFBWCxpQkFBVTsrQ0FBbUQ7SUFDbEQ7UUFBWCxpQkFBVTtpREFBNkM7SUFDNUM7UUFBWCxpQkFBVTsrQ0FBaUM7SUFDaEM7UUFBWCxpQkFBVTtnREFBNkM7SUFFeEQ7UUFEQyxpQkFBVTsrQ0FLVDtJQUNVO1FBQVgsaUJBQVU7OENBQWdDO0lBQy9CO1FBQVgsaUJBQVU7Z0RBQTBCO0lBT3JDO1FBREMsYUFBTTtnREFJTjtJQUdEO1FBREMsYUFBTTs2Q0FZTjtJQUdEO1FBREMsYUFBTTtrREFJTjtJQUdEO1FBREMsYUFBTTttREFHTjtJQUdEO1FBREMsYUFBTTtpREFHTjtJQWdCSCxrQkFBQztDQUFBO2tCQXBFb0IsV0FBVzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0hoQyw4RUFBK0I7QUFHL0Isc0dBQXNDO0FBQ3RDLDJFQUE0QjtBQUM1Qix1R0FBa0M7QUFDbEMsNEZBQXdDO0FBQ3hDLGdJQUF1QztBQUd2QztJQUFvQywwQkFBdUI7SUFEM0Q7UUFBQSxxRUFzQ0M7UUFwQ0MsV0FBSyxHQUFnQixJQUFJLHFCQUFXLEVBQUUsQ0FBQzs7SUFvQ3pDLENBQUM7SUFuQ0MsdUJBQU0sR0FBTjtRQUFBLGlCQWtDQztRQWpDQyxJQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDO1FBQzVFLE1BQU0sQ0FBQyxDQUNMLDZCQUFLLFNBQVMsRUFBRSxXQUFXO1lBQ3pCLDZCQUFLLFNBQVMsRUFBQyxRQUFRO2dCQUNyQixvQkFBQyx5QkFBUSxJQUFDLFFBQVEsRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFDLFVBQVUsSUFDdkMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxVQUFDLE1BQU0sRUFBRSxFQUFFLElBQUssUUFDMUIsb0JBQUMsZUFBSyxJQUNKLEdBQUcsRUFBRSxNQUFNLEVBQ1gsS0FBSyxFQUFFLEVBQUUsRUFDVCxNQUFNLEVBQUUsTUFBTSxFQUNkLFdBQVcsRUFBRSxLQUFJLENBQUMsS0FBSyxHQUN2QixDQUNILEVBUDJCLENBTzNCLENBQUMsQ0FDTyxDQUNQO1lBQ04sZ0NBQVEsT0FBTyxFQUFFLGNBQU0sWUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEVBQUUsRUFBdEIsQ0FBc0IsaUJBQXFCO1lBQ2xFLGdDQUNFLFdBQVcsRUFBRSxjQUFNLFlBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxFQUFFLEVBQXpCLENBQXlCLEVBQzVDLFNBQVMsRUFBRSxjQUFNLFlBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxFQUFFLEVBQXZCLENBQXVCLGNBR2pDO1lBQ1QsaUNBQ0csSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLGVBQUssSUFBSSxRQUM5Qiw2QkFDRSxHQUFHLEVBQUUsS0FBSyxFQUNWLFNBQVMsRUFBQyxPQUFPLEVBQ2pCLE9BQU8sRUFBRSxjQUFNLFlBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxFQUE3QixDQUE2QixHQUM1QyxDQUNILEVBTitCLENBTS9CLENBQUMsQ0FDRSxDQUNGLENBQ1AsQ0FBQztJQUNKLENBQUM7SUFwQ2tCLE1BQU07UUFEMUIscUJBQVE7T0FDWSxNQUFNLENBcUMxQjtJQUFELGFBQUM7Q0FBQSxDQXJDbUMsS0FBSyxDQUFDLFNBQVMsR0FxQ2xEO2tCQXJDb0IsTUFBTTtBQXVDM0IsSUFBTSxXQUFXLEdBQUcsaUJBQUssQ0FBQztJQUN4QixVQUFVLEVBQUUsT0FBTztJQUNuQixPQUFPLEVBQUUsRUFBRTtJQUNYLEtBQUssRUFBRSxHQUFHO0lBQ1YsVUFBVSxFQUFFLENBQUM7SUFDYixLQUFLLEVBQUU7UUFDTCxRQUFRLEVBQUU7WUFDUixLQUFLLEVBQUUsRUFBRTtZQUNULE1BQU0sRUFBRSxFQUFFO1lBQ1YsTUFBTSxFQUFFLGVBQWU7U0FDeEI7UUFDRCxNQUFNLEVBQUU7WUFDTixNQUFNLEVBQUUsY0FBYztTQUN2QjtLQUNGO0NBQ0YsQ0FBQyxDQUFDIiwiZmlsZSI6ImJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9tYWluLnRzeFwiKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogVXBzdHJlYW0gdmVyc2lvbiBvZiBldmVudCBsaXN0ZW5lci4gRG9lcyBub3QgdGFrZSBpbnRvIGFjY291bnQgc3BlY2lmaWNcbiAqIG5hdHVyZSBvZiBwbGF0Zm9ybS5cbiAqL1xudmFyIEV2ZW50TGlzdGVuZXIgPSB7XG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gRE9NIGV2ZW50cyBkdXJpbmcgdGhlIGJ1YmJsZSBwaGFzZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdGFyZ2V0IERPTSBlbGVtZW50IHRvIHJlZ2lzdGVyIGxpc3RlbmVyIG9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIEV2ZW50IHR5cGUsIGUuZy4gJ2NsaWNrJyBvciAnbW91c2VvdmVyJy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHdpdGggYSBgcmVtb3ZlYCBtZXRob2QuXG4gICAqL1xuICBsaXN0ZW46IGZ1bmN0aW9uIGxpc3Rlbih0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldC5hdHRhY2hFdmVudCkge1xuICAgICAgdGFyZ2V0LmF0dGFjaEV2ZW50KCdvbicgKyBldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgIHRhcmdldC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gRE9NIGV2ZW50cyBkdXJpbmcgdGhlIGNhcHR1cmUgcGhhc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRhcmdldCBET00gZWxlbWVudCB0byByZWdpc3RlciBsaXN0ZW5lciBvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBFdmVudCB0eXBlLCBlLmcuICdjbGljaycgb3IgJ21vdXNlb3ZlcicuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCB3aXRoIGEgYHJlbW92ZWAgbWV0aG9kLlxuICAgKi9cbiAgY2FwdHVyZTogZnVuY3Rpb24gY2FwdHVyZSh0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIHRydWUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F0dGVtcHRlZCB0byBsaXN0ZW4gdG8gZXZlbnRzIGR1cmluZyB0aGUgY2FwdHVyZSBwaGFzZSBvbiBhICcgKyAnYnJvd3NlciB0aGF0IGRvZXMgbm90IHN1cHBvcnQgdGhlIGNhcHR1cmUgcGhhc2UuIFlvdXIgYXBwbGljYXRpb24gJyArICd3aWxsIG5vdCByZWNlaXZlIHNvbWUgZXZlbnRzLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBlbXB0eUZ1bmN0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgfSxcblxuICByZWdpc3RlckRlZmF1bHQ6IGZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdCgpIHt9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50TGlzdGVuZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxuLyoqXG4gKiBTaW1wbGUsIGxpZ2h0d2VpZ2h0IG1vZHVsZSBhc3Npc3Rpbmcgd2l0aCB0aGUgZGV0ZWN0aW9uIGFuZCBjb250ZXh0IG9mXG4gKiBXb3JrZXIuIEhlbHBzIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llcyBhbmQgYWxsb3dzIGNvZGUgdG8gcmVhc29uIGFib3V0XG4gKiB3aGV0aGVyIG9yIG5vdCB0aGV5IGFyZSBpbiBhIFdvcmtlciwgZXZlbiBpZiB0aGV5IG5ldmVyIGluY2x1ZGUgdGhlIG1haW5cbiAqIGBSZWFjdFdvcmtlcmAgZGVwZW5kZW5jeS5cbiAqL1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0ge1xuXG4gIGNhblVzZURPTTogY2FuVXNlRE9NLFxuXG4gIGNhblVzZVdvcmtlcnM6IHR5cGVvZiBXb3JrZXIgIT09ICd1bmRlZmluZWQnLFxuXG4gIGNhblVzZUV2ZW50TGlzdGVuZXJzOiBjYW5Vc2VET00gJiYgISEod2luZG93LmFkZEV2ZW50TGlzdGVuZXIgfHwgd2luZG93LmF0dGFjaEV2ZW50KSxcblxuICBjYW5Vc2VWaWV3cG9ydDogY2FuVXNlRE9NICYmICEhd2luZG93LnNjcmVlbixcblxuICBpc0luV29ya2VyOiAhY2FuVXNlRE9NIC8vIEZvciBub3csIHRoaXMgaXMgdHJ1ZSAtIG1pZ2h0IGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4ZWN1dGlvbkVudmlyb25tZW50OyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIF9oeXBoZW5QYXR0ZXJuID0gLy0oLikvZztcblxuLyoqXG4gKiBDYW1lbGNhc2VzIGEgaHlwaGVuYXRlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBjYW1lbGl6ZSgnYmFja2dyb3VuZC1jb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kQ29sb3JcIlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY2FtZWxpemUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShfaHlwaGVuUGF0dGVybiwgZnVuY3Rpb24gKF8sIGNoYXJhY3Rlcikge1xuICAgIHJldHVybiBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FtZWxpemU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhbWVsaXplID0gcmVxdWlyZSgnLi9jYW1lbGl6ZScpO1xuXG52YXIgbXNQYXR0ZXJuID0gL14tbXMtLztcblxuLyoqXG4gKiBDYW1lbGNhc2VzIGEgaHlwaGVuYXRlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCdiYWNrZ3JvdW5kLWNvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmRDb2xvclwiXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tb3otdHJhbnNpdGlvbicpXG4gKiAgIDwgXCJNb3pUcmFuc2l0aW9uXCJcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnLW1zLXRyYW5zaXRpb24nKVxuICogICA8IFwibXNUcmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBBbmRpIFNtaXRoIHN1Z2dlc3RzXG4gKiAoaHR0cDovL3d3dy5hbmRpc21pdGguY29tL2Jsb2cvMjAxMi8wMi9tb2Rlcm5penItcHJlZml4ZWQvKSwgYW4gYC1tc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlIGBtc2AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjYW1lbGl6ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuIGNhbWVsaXplKHN0cmluZy5yZXBsYWNlKG1zUGF0dGVybiwgJ21zLScpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbGl6ZVN0eWxlTmFtZTsiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxudmFyIGlzVGV4dE5vZGUgPSByZXF1aXJlKCcuL2lzVGV4dE5vZGUnKTtcblxuLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gRE9NIG5vZGUgY29udGFpbnMgb3IgaXMgYW5vdGhlciBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlKSB7XG4gIGlmICghb3V0ZXJOb2RlIHx8ICFpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAob3V0ZXJOb2RlID09PSBpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKG91dGVyTm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShpbm5lck5vZGUpKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zTm9kZShvdXRlck5vZGUsIGlubmVyTm9kZS5wYXJlbnROb2RlKTtcbiAgfSBlbHNlIGlmICgnY29udGFpbnMnIGluIG91dGVyTm9kZSkge1xuICAgIHJldHVybiBvdXRlck5vZGUuY29udGFpbnMoaW5uZXJOb2RlKTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24pIHtcbiAgICByZXR1cm4gISEob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGlubmVyTm9kZSkgJiAxNik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGFpbnNOb2RlOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cbmZ1bmN0aW9uIG1ha2VFbXB0eUZ1bmN0aW9uKGFyZykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhcmc7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGFuZCBkaXNjYXJkcyBpbnB1dHM7IGl0IGhhcyBubyBzaWRlIGVmZmVjdHMuIFRoaXMgaXNcbiAqIHByaW1hcmlseSB1c2VmdWwgaWRpb21hdGljYWxseSBmb3Igb3ZlcnJpZGFibGUgZnVuY3Rpb24gZW5kcG9pbnRzIHdoaWNoXG4gKiBhbHdheXMgbmVlZCB0byBiZSBjYWxsYWJsZSwgc2luY2UgSlMgbGFja3MgYSBudWxsLWNhbGwgaWRpb20gYWxhIENvY29hLlxuICovXG52YXIgZW1wdHlGdW5jdGlvbiA9IGZ1bmN0aW9uIGVtcHR5RnVuY3Rpb24oKSB7fTtcblxuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyA9IG1ha2VFbXB0eUZ1bmN0aW9uO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlID0gbWFrZUVtcHR5RnVuY3Rpb24oZmFsc2UpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWUgPSBtYWtlRW1wdHlGdW5jdGlvbih0cnVlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsID0gbWFrZUVtcHR5RnVuY3Rpb24obnVsbCk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVGhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50ID0gZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gYXJnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eUZ1bmN0aW9uOyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5T2JqZWN0OyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgaW5wdXQvdGV4dGFyZWEgdG8gZm9jdXNcbiAqL1xuXG5mdW5jdGlvbiBmb2N1c05vZGUobm9kZSkge1xuICAvLyBJRTggY2FuIHRocm93IFwiQ2FuJ3QgbW92ZSBmb2N1cyB0byB0aGUgY29udHJvbCBiZWNhdXNlIGl0IGlzIGludmlzaWJsZSxcbiAgLy8gbm90IGVuYWJsZWQsIG9yIG9mIGEgdHlwZSB0aGF0IGRvZXMgbm90IGFjY2VwdCB0aGUgZm9jdXMuXCIgZm9yIGFsbCBraW5kcyBvZlxuICAvLyByZWFzb25zIHRoYXQgYXJlIHRvbyBleHBlbnNpdmUgYW5kIGZyYWdpbGUgdG8gdGVzdC5cbiAgdHJ5IHtcbiAgICBub2RlLmZvY3VzKCk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9jdXNOb2RlOyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGZiLXd3dy90eXBlb2YtdW5kZWZpbmVkICovXG5cbi8qKlxuICogU2FtZSBhcyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGJ1dCB3cmFwcyBpbiBhIHRyeS1jYXRjaCBibG9jay4gSW4gSUUgaXQgaXNcbiAqIG5vdCBzYWZlIHRvIGNhbGwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpZiB0aGVyZSBpcyBub3RoaW5nIGZvY3VzZWQuXG4gKlxuICogVGhlIGFjdGl2ZUVsZW1lbnQgd2lsbCBiZSBudWxsIG9ubHkgaWYgdGhlIGRvY3VtZW50IG9yIGRvY3VtZW50IGJvZHkgaXMgbm90XG4gKiB5ZXQgZGVmaW5lZC5cbiAqXG4gKiBAcGFyYW0gez9ET01Eb2N1bWVudH0gZG9jIERlZmF1bHRzIHRvIGN1cnJlbnQgZG9jdW1lbnQuXG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudChkb2MpIC8qP0RPTUVsZW1lbnQqL3tcbiAgZG9jID0gZG9jIHx8ICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiB1bmRlZmluZWQpO1xuICBpZiAodHlwZW9mIGRvYyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBkb2MuYWN0aXZlRWxlbWVudCB8fCBkb2MuYm9keTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBkb2MuYm9keTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFjdGl2ZUVsZW1lbnQ7IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIF91cHBlcmNhc2VQYXR0ZXJuID0gLyhbQS1aXSkvZztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqXG4gKiBGb3IgQ1NTIHN0eWxlIG5hbWVzLCB1c2UgYGh5cGhlbmF0ZVN0eWxlTmFtZWAgaW5zdGVhZCB3aGljaCB3b3JrcyBwcm9wZXJseVxuICogd2l0aCBhbGwgdmVuZG9yIHByZWZpeGVzLCBpbmNsdWRpbmcgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF91cHBlcmNhc2VQYXR0ZXJuLCAnLSQxJykudG9Mb3dlckNhc2UoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGh5cGhlbmF0ZSA9IHJlcXVpcmUoJy4vaHlwaGVuYXRlJyk7XG5cbnZhciBtc1BhdHRlcm4gPSAvXm1zLS87XG5cbi8qKlxuICogSHlwaGVuYXRlcyBhIGNhbWVsY2FzZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ01velRyYW5zaXRpb24nKVxuICogICA8IFwiLW1vei10cmFuc2l0aW9uXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ21zVHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbXMtdHJhbnNpdGlvblwiXG4gKlxuICogQXMgTW9kZXJuaXpyIHN1Z2dlc3RzIChodHRwOi8vbW9kZXJuaXpyLmNvbS9kb2NzLyNwcmVmaXhlZCksIGFuIGBtc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gYC1tcy1gLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaHlwaGVuYXRlU3R5bGVOYW1lKHN0cmluZykge1xuICByZXR1cm4gaHlwaGVuYXRlKHN0cmluZykucmVwbGFjZShtc1BhdHRlcm4sICctbXMtJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaHlwaGVuYXRlU3R5bGVOYW1lOyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpO1xuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgKyAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KSk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDsiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGlzIGEgRE9NIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGlzTm9kZShvYmplY3QpIHtcbiAgdmFyIGRvYyA9IG9iamVjdCA/IG9iamVjdC5vd25lckRvY3VtZW50IHx8IG9iamVjdCA6IGRvY3VtZW50O1xuICB2YXIgZGVmYXVsdFZpZXcgPSBkb2MuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICByZXR1cm4gISEob2JqZWN0ICYmICh0eXBlb2YgZGVmYXVsdFZpZXcuTm9kZSA9PT0gJ2Z1bmN0aW9uJyA/IG9iamVjdCBpbnN0YW5jZW9mIGRlZmF1bHRWaWV3Lk5vZGUgOiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVUeXBlID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVOYW1lID09PSAnc3RyaW5nJykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTm9kZTsiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgaXNOb2RlID0gcmVxdWlyZSgnLi9pc05vZGUnKTtcblxuLyoqXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIG9iamVjdCBpcyBhIERPTSB0ZXh0IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGlzVGV4dE5vZGUob2JqZWN0KSB7XG4gIHJldHVybiBpc05vZGUob2JqZWN0KSAmJiBvYmplY3Qubm9kZVR5cGUgPT0gMztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1RleHROb2RlOyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqIFxuICovXG5cbi8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL1xuZnVuY3Rpb24gaXMoeCwgeSkge1xuICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gIGlmICh4ID09PSB5KSB7XG4gICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAvLyBBZGRlZCB0aGUgbm9uemVybyB5IGNoZWNrIHRvIG1ha2UgRmxvdyBoYXBweSwgYnV0IGl0IGlzIHJlZHVuZGFudFxuICAgIHJldHVybiB4ICE9PSAwIHx8IHkgIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICB9IGVsc2Uge1xuICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgfVxufVxuXG4vKipcbiAqIFBlcmZvcm1zIGVxdWFsaXR5IGJ5IGl0ZXJhdGluZyB0aHJvdWdoIGtleXMgb24gYW4gb2JqZWN0IGFuZCByZXR1cm5pbmcgZmFsc2VcbiAqIHdoZW4gYW55IGtleSBoYXMgdmFsdWVzIHdoaWNoIGFyZSBub3Qgc3RyaWN0bHkgZXF1YWwgYmV0d2VlbiB0aGUgYXJndW1lbnRzLlxuICogUmV0dXJucyB0cnVlIHdoZW4gdGhlIHZhbHVlcyBvZiBhbGwga2V5cyBhcmUgc3RyaWN0bHkgZXF1YWwuXG4gKi9cbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCKSB7XG4gIGlmIChpcyhvYmpBLCBvYmpCKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmpBICE9PSAnb2JqZWN0JyB8fCBvYmpBID09PSBudWxsIHx8IHR5cGVvZiBvYmpCICE9PSAnb2JqZWN0JyB8fCBvYmpCID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuXG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRlc3QgZm9yIEEncyBrZXlzIGRpZmZlcmVudCBmcm9tIEIuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwob2JqQiwga2V5c0FbaV0pIHx8ICFpcyhvYmpBW2tleXNBW2ldXSwgb2JqQltrZXlzQVtpXV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hhbGxvd0VxdWFsOyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCcuL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG5cbiAgd2FybmluZyA9IGZ1bmN0aW9uIHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdC5pbmRleE9mKCdGYWlsZWQgQ29tcG9zaXRlIHByb3BUeXBlOiAnKSA9PT0gMCkge1xuICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgQ29tcG9zaXRlQ29tcG9uZW50IHByb3B0eXBlIGNoZWNrLlxuICAgIH1cblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7IiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogVGhlIHVuaXF1ZSBpZCBpcyB1c2VkIGZvciB1bmlxdWUgaGFzaGVzLlxuICovXG52YXIgdW5pcXVlSWQgPSAwO1xuLyoqXG4gKiBUYWcgc3R5bGVzIHdpdGggdGhpcyBzdHJpbmcgdG8gZ2V0IHVuaXF1ZSBoYXNoZXMuXG4gKi9cbmV4cG9ydHMuSVNfVU5JUVVFID0gJ19fRE9fTk9UX0RFRFVQRV9TVFlMRV9fJztcbnZhciB1cHBlckNhc2VQYXR0ZXJuID0gL1tBLVpdL2c7XG52YXIgbXNQYXR0ZXJuID0gL15tcy0vO1xudmFyIGludGVycG9sYXRlUGF0dGVybiA9IC8mL2c7XG52YXIgZXNjYXBlUGF0dGVybiA9IC9bICEjJCUmKCkqKywuLzs8PT4/QFtcXF1eYHt8fX5cIidcXFxcXS9nO1xudmFyIHByb3BMb3dlciA9IGZ1bmN0aW9uIChtKSB7IHJldHVybiBcIi1cIiArIG0udG9Mb3dlckNhc2UoKTsgfTtcbi8qKlxuICogQ1NTIHByb3BlcnRpZXMgdGhhdCBhcmUgdmFsaWQgdW5pdC1sZXNzIG51bWJlcnMuXG4gKi9cbnZhciBjc3NOdW1iZXJQcm9wZXJ0aWVzID0gW1xuICAgICdhbmltYXRpb24taXRlcmF0aW9uLWNvdW50JyxcbiAgICAnYm94LWZsZXgnLFxuICAgICdib3gtZmxleC1ncm91cCcsXG4gICAgJ2NvbHVtbi1jb3VudCcsXG4gICAgJ2NvdW50ZXItaW5jcmVtZW50JyxcbiAgICAnY291bnRlci1yZXNldCcsXG4gICAgJ2ZsZXgnLFxuICAgICdmbGV4LWdyb3cnLFxuICAgICdmbGV4LXBvc2l0aXZlJyxcbiAgICAnZmxleC1zaHJpbmsnLFxuICAgICdmbGV4LW5lZ2F0aXZlJyxcbiAgICAnZm9udC13ZWlnaHQnLFxuICAgICdsaW5lLWNsYW1wJyxcbiAgICAnbGluZS1oZWlnaHQnLFxuICAgICdvcGFjaXR5JyxcbiAgICAnb3JkZXInLFxuICAgICdvcnBoYW5zJyxcbiAgICAndGFiLXNpemUnLFxuICAgICd3aWRvd3MnLFxuICAgICd6LWluZGV4JyxcbiAgICAnem9vbScsXG4gICAgLy8gU1ZHIHByb3BlcnRpZXMuXG4gICAgJ2ZpbGwtb3BhY2l0eScsXG4gICAgJ3N0cm9rZS1kYXNob2Zmc2V0JyxcbiAgICAnc3Ryb2tlLW9wYWNpdHknLFxuICAgICdzdHJva2Utd2lkdGgnXG5dO1xuLyoqXG4gKiBNYXAgb2YgY3NzIG51bWJlciBwcm9wZXJ0aWVzLlxuICovXG52YXIgQ1NTX05VTUJFUiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vLyBBZGQgdmVuZG9yIHByZWZpeGVzIHRvIGFsbCB1bml0LWxlc3MgcHJvcGVydGllcy5cbmZvciAodmFyIF9pID0gMCwgX2EgPSBbJy13ZWJraXQtJywgJy1tcy0nLCAnLW1vei0nLCAnLW8tJywgJyddOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgIHZhciBwcmVmaXggPSBfYVtfaV07XG4gICAgZm9yICh2YXIgX2IgPSAwLCBjc3NOdW1iZXJQcm9wZXJ0aWVzXzEgPSBjc3NOdW1iZXJQcm9wZXJ0aWVzOyBfYiA8IGNzc051bWJlclByb3BlcnRpZXNfMS5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgdmFyIHByb3BlcnR5ID0gY3NzTnVtYmVyUHJvcGVydGllc18xW19iXTtcbiAgICAgICAgQ1NTX05VTUJFUltwcmVmaXggKyBwcm9wZXJ0eV0gPSB0cnVlO1xuICAgIH1cbn1cbi8qKlxuICogRXNjYXBlIGEgQ1NTIGNsYXNzIG5hbWUuXG4gKi9cbmV4cG9ydHMuZXNjYXBlID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyLnJlcGxhY2UoZXNjYXBlUGF0dGVybiwgJ1xcXFwkJicpOyB9O1xuLyoqXG4gKiBUcmFuc2Zvcm0gYSBKYXZhU2NyaXB0IHByb3BlcnR5IGludG8gYSBDU1MgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZShwcm9wZXJ0eU5hbWUpIHtcbiAgICByZXR1cm4gcHJvcGVydHlOYW1lXG4gICAgICAgIC5yZXBsYWNlKHVwcGVyQ2FzZVBhdHRlcm4sIHByb3BMb3dlcilcbiAgICAgICAgLnJlcGxhY2UobXNQYXR0ZXJuLCAnLW1zLScpOyAvLyBJbnRlcm5ldCBFeHBsb3JlciB2ZW5kb3IgcHJlZml4LlxufVxuZXhwb3J0cy5oeXBoZW5hdGUgPSBoeXBoZW5hdGU7XG4vKipcbiAqIEdlbmVyYXRlIGEgaGFzaCB2YWx1ZSBmcm9tIGEgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBzdHJpbmdIYXNoKHN0cikge1xuICAgIHZhciB2YWx1ZSA9IDUzODE7XG4gICAgdmFyIGxlbiA9IHN0ci5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbi0tKVxuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSAqIDMzKSBeIHN0ci5jaGFyQ29kZUF0KGxlbik7XG4gICAgcmV0dXJuICh2YWx1ZSA+Pj4gMCkudG9TdHJpbmcoMzYpO1xufVxuZXhwb3J0cy5zdHJpbmdIYXNoID0gc3RyaW5nSGFzaDtcbi8qKlxuICogVHJhbnNmb3JtIGEgc3R5bGUgc3RyaW5nIHRvIGEgQ1NTIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gc3R5bGVUb1N0cmluZyhrZXksIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdmFsdWUgIT09IDAgJiYgIUNTU19OVU1CRVJba2V5XSkge1xuICAgICAgICByZXR1cm4ga2V5ICsgXCI6XCIgKyB2YWx1ZSArIFwicHhcIjtcbiAgICB9XG4gICAgcmV0dXJuIGtleSArIFwiOlwiICsgdmFsdWU7XG59XG4vKipcbiAqIFNvcnQgYW4gYXJyYXkgb2YgdHVwbGVzIGJ5IGZpcnN0IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzb3J0VHVwbGVzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGFbMF0gPiBiWzBdID8gMSA6IC0xOyB9KTtcbn1cbi8qKlxuICogQ2F0ZWdvcml6ZSB1c2VyIHN0eWxlcy5cbiAqL1xuZnVuY3Rpb24gcGFyc2VTdHlsZXMoc3R5bGVzLCBoYXNOZXN0ZWRTdHlsZXMpIHtcbiAgICB2YXIgcHJvcGVydGllcyA9IFtdO1xuICAgIHZhciBuZXN0ZWRTdHlsZXMgPSBbXTtcbiAgICB2YXIgaXNVbmlxdWUgPSBmYWxzZTtcbiAgICAvLyBTb3J0IGtleXMgYmVmb3JlIGFkZGluZyB0byBzdHlsZXMuXG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5rZXlzKHN0eWxlcyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBfYVtfaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IHN0eWxlc1trZXldO1xuICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gZXhwb3J0cy5JU19VTklRVUUpIHtcbiAgICAgICAgICAgICAgICBpc1VuaXF1ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG5lc3RlZFN0eWxlcy5wdXNoKFtrZXkudHJpbSgpLCB2YWx1ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKFtoeXBoZW5hdGUoa2V5LnRyaW0oKSksIHZhbHVlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3R5bGVTdHJpbmc6IHN0cmluZ2lmeVByb3BlcnRpZXMoc29ydFR1cGxlcyhwcm9wZXJ0aWVzKSksXG4gICAgICAgIG5lc3RlZFN0eWxlczogaGFzTmVzdGVkU3R5bGVzID8gbmVzdGVkU3R5bGVzIDogc29ydFR1cGxlcyhuZXN0ZWRTdHlsZXMpLFxuICAgICAgICBpc1VuaXF1ZTogaXNVbmlxdWVcbiAgICB9O1xufVxuLyoqXG4gKiBTdHJpbmdpZnkgYW4gYXJyYXkgb2YgcHJvcGVydHkgdHVwbGVzLlxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnlQcm9wZXJ0aWVzKHByb3BlcnRpZXMpIHtcbiAgICByZXR1cm4gcHJvcGVydGllcy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBuYW1lID0gX2FbMF0sIHZhbHVlID0gX2FbMV07XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gc3R5bGVUb1N0cmluZyhuYW1lLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHN0eWxlVG9TdHJpbmcobmFtZSwgeCk7IH0pLmpvaW4oJzsnKTtcbiAgICB9KS5qb2luKCc7Jyk7XG59XG4vKipcbiAqIEludGVycG9sYXRlIENTUyBzZWxlY3RvcnMuXG4gKi9cbmZ1bmN0aW9uIGludGVycG9sYXRlKHNlbGVjdG9yLCBwYXJlbnQpIHtcbiAgICBpZiAoc2VsZWN0b3IuaW5kZXhPZignJicpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yLnJlcGxhY2UoaW50ZXJwb2xhdGVQYXR0ZXJuLCBwYXJlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyZW50ICsgXCIgXCIgKyBzZWxlY3Rvcjtcbn1cbi8qKlxuICogUmVjdXJzaXZlIGxvb3AgYnVpbGRpbmcgc3R5bGVzIHdpdGggZGVmZXJyZWQgc2VsZWN0b3JzLlxuICovXG5mdW5jdGlvbiBzdHlsaXplKGNhY2hlLCBzZWxlY3Rvciwgc3R5bGVzLCBsaXN0LCBwYXJlbnQpIHtcbiAgICB2YXIgX2EgPSBwYXJzZVN0eWxlcyhzdHlsZXMsICEhc2VsZWN0b3IpLCBzdHlsZVN0cmluZyA9IF9hLnN0eWxlU3RyaW5nLCBuZXN0ZWRTdHlsZXMgPSBfYS5uZXN0ZWRTdHlsZXMsIGlzVW5pcXVlID0gX2EuaXNVbmlxdWU7XG4gICAgdmFyIHBpZCA9IHN0eWxlU3RyaW5nO1xuICAgIGlmIChzZWxlY3Rvci5jaGFyQ29kZUF0KDApID09PSA2NCAvKiBAICovKSB7XG4gICAgICAgIHZhciBydWxlID0gY2FjaGUuYWRkKG5ldyBSdWxlKHNlbGVjdG9yLCBwYXJlbnQgPyB1bmRlZmluZWQgOiBzdHlsZVN0cmluZywgY2FjaGUuaGFzaCkpO1xuICAgICAgICAvLyBOZXN0ZWQgc3R5bGVzIHN1cHBvcnQgKGUuZy4gYC5mb28gPiBAbWVkaWEgPiAuYmFyYCkuXG4gICAgICAgIGlmIChzdHlsZVN0cmluZyAmJiBwYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHJ1bGUuYWRkKG5ldyBTdHlsZShzdHlsZVN0cmluZywgcnVsZS5oYXNoLCBpc1VuaXF1ZSA/IFwidVwiICsgKCsrdW5pcXVlSWQpLnRvU3RyaW5nKDM2KSA6IHVuZGVmaW5lZCkpO1xuICAgICAgICAgICAgbGlzdC5wdXNoKFtwYXJlbnQsIHN0eWxlXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBuZXN0ZWRTdHlsZXNfMSA9IG5lc3RlZFN0eWxlczsgX2kgPCBuZXN0ZWRTdHlsZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBfYiA9IG5lc3RlZFN0eWxlc18xW19pXSwgbmFtZSA9IF9iWzBdLCB2YWx1ZSA9IF9iWzFdO1xuICAgICAgICAgICAgcGlkICs9IG5hbWUgKyBzdHlsaXplKHJ1bGUsIG5hbWUsIHZhbHVlLCBsaXN0LCBwYXJlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIga2V5ID0gcGFyZW50ID8gaW50ZXJwb2xhdGUoc2VsZWN0b3IsIHBhcmVudCkgOiBzZWxlY3RvcjtcbiAgICAgICAgaWYgKHN0eWxlU3RyaW5nKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBjYWNoZS5hZGQobmV3IFN0eWxlKHN0eWxlU3RyaW5nLCBjYWNoZS5oYXNoLCBpc1VuaXF1ZSA/IFwidVwiICsgKCsrdW5pcXVlSWQpLnRvU3RyaW5nKDM2KSA6IHVuZGVmaW5lZCkpO1xuICAgICAgICAgICAgbGlzdC5wdXNoKFtrZXksIHN0eWxlXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2MgPSAwLCBuZXN0ZWRTdHlsZXNfMiA9IG5lc3RlZFN0eWxlczsgX2MgPCBuZXN0ZWRTdHlsZXNfMi5sZW5ndGg7IF9jKyspIHtcbiAgICAgICAgICAgIHZhciBfZCA9IG5lc3RlZFN0eWxlc18yW19jXSwgbmFtZSA9IF9kWzBdLCB2YWx1ZSA9IF9kWzFdO1xuICAgICAgICAgICAgcGlkICs9IG5hbWUgKyBzdHlsaXplKGNhY2hlLCBuYW1lLCB2YWx1ZSwgbGlzdCwga2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGlkO1xufVxuLyoqXG4gKiBSZWdpc3RlciBhbGwgc3R5bGVzLCBidXQgY29sbGVjdCBmb3Igc2VsZWN0b3IgaW50ZXJwb2xhdGlvbiB1c2luZyB0aGUgaGFzaC5cbiAqL1xuZnVuY3Rpb24gY29tcG9zZVN0eWxlcyhjb250YWluZXIsIHNlbGVjdG9yLCBzdHlsZXMsIGlzU3R5bGUsIGRpc3BsYXlOYW1lKSB7XG4gICAgdmFyIGNhY2hlID0gbmV3IENhY2hlKGNvbnRhaW5lci5oYXNoKTtcbiAgICB2YXIgbGlzdCA9IFtdO1xuICAgIHZhciBwaWQgPSBzdHlsaXplKGNhY2hlLCBzZWxlY3Rvciwgc3R5bGVzLCBsaXN0KTtcbiAgICB2YXIgaGFzaCA9IFwiZlwiICsgY2FjaGUuaGFzaChwaWQpO1xuICAgIHZhciBpZCA9IGRpc3BsYXlOYW1lID8gZGlzcGxheU5hbWUgKyBcIl9cIiArIGhhc2ggOiBoYXNoO1xuICAgIGZvciAodmFyIF9pID0gMCwgbGlzdF8xID0gbGlzdDsgX2kgPCBsaXN0XzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBfYSA9IGxpc3RfMVtfaV0sIHNlbGVjdG9yXzEgPSBfYVswXSwgc3R5bGUgPSBfYVsxXTtcbiAgICAgICAgdmFyIGtleSA9IGlzU3R5bGUgPyBpbnRlcnBvbGF0ZShzZWxlY3Rvcl8xLCBcIi5cIiArIGV4cG9ydHMuZXNjYXBlKGlkKSkgOiBzZWxlY3Rvcl8xO1xuICAgICAgICBzdHlsZS5hZGQobmV3IFNlbGVjdG9yKGtleSwgc3R5bGUuaGFzaCwgdW5kZWZpbmVkLCBwaWQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY2FjaGU6IGNhY2hlLCBwaWQ6IHBpZCwgaWQ6IGlkIH07XG59XG4vKipcbiAqIENhY2hlIHRvIGxpc3QgdG8gc3R5bGVzLlxuICovXG5mdW5jdGlvbiBqb2luKGFycikge1xuICAgIHZhciByZXMgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKylcbiAgICAgICAgcmVzICs9IGFycltpXTtcbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBOb29wIGNoYW5nZXMuXG4gKi9cbnZhciBub29wQ2hhbmdlcyA9IHtcbiAgICBhZGQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSxcbiAgICBjaGFuZ2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxufTtcbi8qKlxuICogSW1wbGVtZW50IGEgY2FjaGUvZXZlbnQgZW1pdHRlci5cbiAqL1xudmFyIENhY2hlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhY2hlKGhhc2gsIGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGhhc2ggPT09IHZvaWQgMCkgeyBoYXNoID0gc3RyaW5nSGFzaDsgfVxuICAgICAgICBpZiAoY2hhbmdlcyA9PT0gdm9pZCAwKSB7IGNoYW5nZXMgPSBub29wQ2hhbmdlczsgfVxuICAgICAgICB0aGlzLmhhc2ggPSBoYXNoO1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBjaGFuZ2VzO1xuICAgICAgICB0aGlzLnNoZWV0ID0gW107XG4gICAgICAgIHRoaXMuY2hhbmdlSWQgPSAwO1xuICAgICAgICB0aGlzLl9rZXlzID0gW107XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fY291bnRlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBDYWNoZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICAgIHZhciBjb3VudCA9IHRoaXMuX2NvdW50ZXJzW3N0eWxlLmlkXSB8fCAwO1xuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuX2NoaWxkcmVuW3N0eWxlLmlkXSB8fCBzdHlsZS5jbG9uZSgpO1xuICAgICAgICB0aGlzLl9jb3VudGVyc1tzdHlsZS5pZF0gPSBjb3VudCArIDE7XG4gICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW5baXRlbS5pZF0gPSBpdGVtO1xuICAgICAgICAgICAgdGhpcy5fa2V5cy5wdXNoKGl0ZW0uaWQpO1xuICAgICAgICAgICAgdGhpcy5zaGVldC5wdXNoKGl0ZW0uZ2V0U3R5bGVzKCkpO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VJZCsrO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VzLmFkZChpdGVtLCB0aGlzLl9rZXlzLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgY29udGVudHMgYXJlIGRpZmZlcmVudC5cbiAgICAgICAgICAgIGlmIChpdGVtLmdldElkZW50aWZpZXIoKSAhPT0gc3R5bGUuZ2V0SWRlbnRpZmllcigpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkhhc2ggY29sbGlzaW9uOiBcIiArIHN0eWxlLmdldFN0eWxlcygpICsgXCIgPT09IFwiICsgaXRlbS5nZXRTdHlsZXMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb2xkSW5kZXggPSB0aGlzLl9rZXlzLmluZGV4T2Yoc3R5bGUuaWQpO1xuICAgICAgICAgICAgdmFyIG5ld0luZGV4ID0gdGhpcy5fa2V5cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgdmFyIHByZXZDaGFuZ2VJZCA9IHRoaXMuY2hhbmdlSWQ7XG4gICAgICAgICAgICBpZiAob2xkSW5kZXggIT09IG5ld0luZGV4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fa2V5cy5zcGxpY2Uob2xkSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2tleXMucHVzaChzdHlsZS5pZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VJZCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBDYWNoZSAmJiBzdHlsZSBpbnN0YW5jZW9mIENhY2hlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZDaGFuZ2VJZF8xID0gaXRlbS5jaGFuZ2VJZDtcbiAgICAgICAgICAgICAgICBpdGVtLm1lcmdlKHN0eWxlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5jaGFuZ2VJZCAhPT0gcHJldkNoYW5nZUlkXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VJZCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5nZUlkICE9PSBwcmV2Q2hhbmdlSWQpIHtcbiAgICAgICAgICAgICAgICBpZiAob2xkSW5kZXggPT09IG5ld0luZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hlZXQuc3BsaWNlKG9sZEluZGV4LCAxLCBpdGVtLmdldFN0eWxlcygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hlZXQuc3BsaWNlKG9sZEluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaGVldC5zcGxpY2UobmV3SW5kZXgsIDAsIGl0ZW0uZ2V0U3R5bGVzKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZXMuY2hhbmdlKGl0ZW0sIG9sZEluZGV4LCBuZXdJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfTtcbiAgICBDYWNoZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICAgIHZhciBjb3VudCA9IHRoaXMuX2NvdW50ZXJzW3N0eWxlLmlkXTtcbiAgICAgICAgaWYgKGNvdW50ID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fY291bnRlcnNbc3R5bGUuaWRdID0gY291bnQgLSAxO1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLl9jaGlsZHJlbltzdHlsZS5pZF07XG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9rZXlzLmluZGV4T2YoaXRlbS5pZCk7XG4gICAgICAgICAgICBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fY291bnRlcnNbc3R5bGUuaWRdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jaGlsZHJlbltzdHlsZS5pZF07XG4gICAgICAgICAgICAgICAgdGhpcy5fa2V5cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2hlZXQuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZUlkKys7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VzLnJlbW92ZShpdGVtLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgQ2FjaGUgJiYgc3R5bGUgaW5zdGFuY2VvZiBDYWNoZSkge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2Q2hhbmdlSWQgPSBpdGVtLmNoYW5nZUlkO1xuICAgICAgICAgICAgICAgIGl0ZW0udW5tZXJnZShzdHlsZSk7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uY2hhbmdlSWQgIT09IHByZXZDaGFuZ2VJZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNoZWV0LnNwbGljZShpbmRleCwgMSwgaXRlbS5nZXRTdHlsZXMoKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlSWQrKztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VzLmNoYW5nZShpdGVtLCBpbmRleCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2FjaGUucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24gKGNhY2hlKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBjYWNoZS5fa2V5czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBpZCA9IF9hW19pXTtcbiAgICAgICAgICAgIHRoaXMuYWRkKGNhY2hlLl9jaGlsZHJlbltpZF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQ2FjaGUucHJvdG90eXBlLnVubWVyZ2UgPSBmdW5jdGlvbiAoY2FjaGUpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGNhY2hlLl9rZXlzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGlkID0gX2FbX2ldO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoY2FjaGUuX2NoaWxkcmVuW2lkXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBDYWNoZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2FjaGUodGhpcy5oYXNoKS5tZXJnZSh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBDYWNoZTtcbn0oKSk7XG5leHBvcnRzLkNhY2hlID0gQ2FjaGU7XG4vKipcbiAqIFNlbGVjdG9yIGlzIGEgZHVtYiBjbGFzcyBtYWRlIHRvIHJlcHJlc2VudCBuZXN0ZWQgQ1NTIHNlbGVjdG9ycy5cbiAqL1xudmFyIFNlbGVjdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlbGVjdG9yKHNlbGVjdG9yLCBoYXNoLCBpZCwgcGlkKSB7XG4gICAgICAgIGlmIChpZCA9PT0gdm9pZCAwKSB7IGlkID0gXCJzXCIgKyBoYXNoKHNlbGVjdG9yKTsgfVxuICAgICAgICBpZiAocGlkID09PSB2b2lkIDApIHsgcGlkID0gJyc7IH1cbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICB0aGlzLmhhc2ggPSBoYXNoO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMucGlkID0gcGlkO1xuICAgIH1cbiAgICBTZWxlY3Rvci5wcm90b3R5cGUuZ2V0U3R5bGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RvcjtcbiAgICB9O1xuICAgIFNlbGVjdG9yLnByb3RvdHlwZS5nZXRJZGVudGlmaWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5waWQgKyBcIi5cIiArIHRoaXMuc2VsZWN0b3I7XG4gICAgfTtcbiAgICBTZWxlY3Rvci5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VsZWN0b3IodGhpcy5zZWxlY3RvciwgdGhpcy5oYXNoLCB0aGlzLmlkLCB0aGlzLnBpZCk7XG4gICAgfTtcbiAgICByZXR1cm4gU2VsZWN0b3I7XG59KCkpO1xuZXhwb3J0cy5TZWxlY3RvciA9IFNlbGVjdG9yO1xuLyoqXG4gKiBUaGUgc3R5bGUgY29udGFpbmVyIHJlZ2lzdGVycyBhIHN0eWxlIHN0cmluZyB3aXRoIHNlbGVjdG9ycy5cbiAqL1xudmFyIFN0eWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdHlsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdHlsZShzdHlsZSwgaGFzaCwgaWQpIHtcbiAgICAgICAgaWYgKGlkID09PSB2b2lkIDApIHsgaWQgPSBcImNcIiArIGhhc2goc3R5bGUpOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGhhc2gpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgICAgIF90aGlzLmhhc2ggPSBoYXNoO1xuICAgICAgICBfdGhpcy5pZCA9IGlkO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFN0eWxlLnByb3RvdHlwZS5nZXRTdHlsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoZWV0LmpvaW4oJywnKSArIFwie1wiICsgdGhpcy5zdHlsZSArIFwifVwiO1xuICAgIH07XG4gICAgU3R5bGUucHJvdG90eXBlLmdldElkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlO1xuICAgIH07XG4gICAgU3R5bGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0eWxlKHRoaXMuc3R5bGUsIHRoaXMuaGFzaCwgdGhpcy5pZCkubWVyZ2UodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gU3R5bGU7XG59KENhY2hlKSk7XG5leHBvcnRzLlN0eWxlID0gU3R5bGU7XG4vKipcbiAqIEltcGxlbWVudCBydWxlIGxvZ2ljIGZvciBzdHlsZSBvdXRwdXQuXG4gKi9cbnZhciBSdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSdWxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJ1bGUocnVsZSwgc3R5bGUsIGhhc2gsIGlkLCBwaWQpIHtcbiAgICAgICAgaWYgKHN0eWxlID09PSB2b2lkIDApIHsgc3R5bGUgPSAnJzsgfVxuICAgICAgICBpZiAoaWQgPT09IHZvaWQgMCkgeyBpZCA9IFwiYVwiICsgaGFzaChydWxlICsgXCIuXCIgKyBzdHlsZSk7IH1cbiAgICAgICAgaWYgKHBpZCA9PT0gdm9pZCAwKSB7IHBpZCA9ICcnOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGhhc2gpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJ1bGUgPSBydWxlO1xuICAgICAgICBfdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgICAgICBfdGhpcy5oYXNoID0gaGFzaDtcbiAgICAgICAgX3RoaXMuaWQgPSBpZDtcbiAgICAgICAgX3RoaXMucGlkID0gcGlkO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJ1bGUucHJvdG90eXBlLmdldFN0eWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucnVsZSArIFwie1wiICsgdGhpcy5zdHlsZSArIGpvaW4odGhpcy5zaGVldCkgKyBcIn1cIjtcbiAgICB9O1xuICAgIFJ1bGUucHJvdG90eXBlLmdldElkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBpZCArIFwiLlwiICsgdGhpcy5ydWxlICsgXCIuXCIgKyB0aGlzLnN0eWxlO1xuICAgIH07XG4gICAgUnVsZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUnVsZSh0aGlzLnJ1bGUsIHRoaXMuc3R5bGUsIHRoaXMuaGFzaCwgdGhpcy5pZCwgdGhpcy5waWQpLm1lcmdlKHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIFJ1bGU7XG59KENhY2hlKSk7XG5leHBvcnRzLlJ1bGUgPSBSdWxlO1xuLyoqXG4gKiBUaGUgRnJlZVN0eWxlIGNsYXNzIGltcGxlbWVudHMgdGhlIEFQSSBmb3IgZXZlcnl0aGluZyBlbHNlLlxuICovXG52YXIgRnJlZVN0eWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGcmVlU3R5bGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRnJlZVN0eWxlKGhhc2gsIGRlYnVnLCBpZCwgY2hhbmdlcykge1xuICAgICAgICBpZiAoaGFzaCA9PT0gdm9pZCAwKSB7IGhhc2ggPSBzdHJpbmdIYXNoOyB9XG4gICAgICAgIGlmIChkZWJ1ZyA9PT0gdm9pZCAwKSB7IGRlYnVnID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52WydOT0RFX0VOViddICE9PSAncHJvZHVjdGlvbic7IH1cbiAgICAgICAgaWYgKGlkID09PSB2b2lkIDApIHsgaWQgPSBcImZcIiArICgrK3VuaXF1ZUlkKS50b1N0cmluZygzNik7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaGFzaCwgY2hhbmdlcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaGFzaCA9IGhhc2g7XG4gICAgICAgIF90aGlzLmRlYnVnID0gZGVidWc7XG4gICAgICAgIF90aGlzLmlkID0gaWQ7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRnJlZVN0eWxlLnByb3RvdHlwZS5yZWdpc3RlclN0eWxlID0gZnVuY3Rpb24gKHN0eWxlcywgZGlzcGxheU5hbWUpIHtcbiAgICAgICAgdmFyIGRlYnVnTmFtZSA9IHRoaXMuZGVidWcgPyBkaXNwbGF5TmFtZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIF9hID0gY29tcG9zZVN0eWxlcyh0aGlzLCAnJicsIHN0eWxlcywgdHJ1ZSwgZGVidWdOYW1lKSwgY2FjaGUgPSBfYS5jYWNoZSwgaWQgPSBfYS5pZDtcbiAgICAgICAgdGhpcy5tZXJnZShjYWNoZSk7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9O1xuICAgIEZyZWVTdHlsZS5wcm90b3R5cGUucmVnaXN0ZXJLZXlmcmFtZXMgPSBmdW5jdGlvbiAoa2V5ZnJhbWVzLCBkaXNwbGF5TmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3Rlckhhc2hSdWxlKCdAa2V5ZnJhbWVzJywga2V5ZnJhbWVzLCBkaXNwbGF5TmFtZSk7XG4gICAgfTtcbiAgICBGcmVlU3R5bGUucHJvdG90eXBlLnJlZ2lzdGVySGFzaFJ1bGUgPSBmdW5jdGlvbiAocHJlZml4LCBzdHlsZXMsIGRpc3BsYXlOYW1lKSB7XG4gICAgICAgIHZhciBkZWJ1Z05hbWUgPSB0aGlzLmRlYnVnID8gZGlzcGxheU5hbWUgOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBfYSA9IGNvbXBvc2VTdHlsZXModGhpcywgJycsIHN0eWxlcywgZmFsc2UsIGRlYnVnTmFtZSksIGNhY2hlID0gX2EuY2FjaGUsIHBpZCA9IF9hLnBpZCwgaWQgPSBfYS5pZDtcbiAgICAgICAgdmFyIHJ1bGUgPSBuZXcgUnVsZShwcmVmaXggKyBcIiBcIiArIGV4cG9ydHMuZXNjYXBlKGlkKSwgdW5kZWZpbmVkLCB0aGlzLmhhc2gsIHVuZGVmaW5lZCwgcGlkKTtcbiAgICAgICAgdGhpcy5hZGQocnVsZS5tZXJnZShjYWNoZSkpO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfTtcbiAgICBGcmVlU3R5bGUucHJvdG90eXBlLnJlZ2lzdGVyUnVsZSA9IGZ1bmN0aW9uIChydWxlLCBzdHlsZXMpIHtcbiAgICAgICAgdGhpcy5tZXJnZShjb21wb3NlU3R5bGVzKHRoaXMsIHJ1bGUsIHN0eWxlcywgZmFsc2UpLmNhY2hlKTtcbiAgICB9O1xuICAgIEZyZWVTdHlsZS5wcm90b3R5cGUucmVnaXN0ZXJDc3MgPSBmdW5jdGlvbiAoc3R5bGVzKSB7XG4gICAgICAgIHRoaXMubWVyZ2UoY29tcG9zZVN0eWxlcyh0aGlzLCAnJywgc3R5bGVzLCBmYWxzZSkuY2FjaGUpO1xuICAgIH07XG4gICAgRnJlZVN0eWxlLnByb3RvdHlwZS5nZXRTdHlsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBqb2luKHRoaXMuc2hlZXQpO1xuICAgIH07XG4gICAgRnJlZVN0eWxlLnByb3RvdHlwZS5nZXRJZGVudGlmaWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZDtcbiAgICB9O1xuICAgIEZyZWVTdHlsZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRnJlZVN0eWxlKHRoaXMuaGFzaCwgdGhpcy5kZWJ1ZywgdGhpcy5pZCwgdGhpcy5jaGFuZ2VzKS5tZXJnZSh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBGcmVlU3R5bGU7XG59KENhY2hlKSk7XG5leHBvcnRzLkZyZWVTdHlsZSA9IEZyZWVTdHlsZTtcbi8qKlxuICogRXhwb3J0cyBhIHNpbXBsZSBmdW5jdGlvbiB0byBjcmVhdGUgYSBuZXcgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZShoYXNoLCBkZWJ1ZywgY2hhbmdlcykge1xuICAgIHJldHVybiBuZXcgRnJlZVN0eWxlKGhhc2gsIGRlYnVnLCB1bmRlZmluZWQsIGNoYW5nZXMpO1xufVxuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcmVlLXN0eWxlLmpzLm1hcCIsImltcG9ydCB7IEF0b20sIFJlYWN0aW9uLCBleHRyYXMsIGlzT2JzZXJ2YWJsZUFycmF5LCBpc09ic2VydmFibGVNYXAsIGlzT2JzZXJ2YWJsZU9iamVjdCwgc3B5LCB1bnRyYWNrZWQgfSBmcm9tICdtb2J4JztcbmltcG9ydCBSZWFjdCwgeyBDaGlsZHJlbiwgQ29tcG9uZW50LCBjcmVhdGVFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZmluZERPTU5vZGUsIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIH0gZnJvbSAncmVhY3QtZG9tJztcblxuLy8gVGhlc2UgZnVuY3Rpb25zIGNhbiBiZSBzdHViYmVkIG91dCBpbiBzcGVjaWZpYyBlbnZpcm9ubWVudHNcbnZhciB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyQxID0gdW5kZWZpbmVkO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iajtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcblxuXG5cblxuXG52YXIgYXN5bmNHZW5lcmF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEF3YWl0VmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBBc3luY0dlbmVyYXRvcihnZW4pIHtcbiAgICB2YXIgZnJvbnQsIGJhY2s7XG5cbiAgICBmdW5jdGlvbiBzZW5kKGtleSwgYXJnKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IHtcbiAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICBhcmc6IGFyZyxcbiAgICAgICAgICByZXNvbHZlOiByZXNvbHZlLFxuICAgICAgICAgIHJlamVjdDogcmVqZWN0LFxuICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoYmFjaykge1xuICAgICAgICAgIGJhY2sgPSBiYWNrLm5leHQgPSByZXF1ZXN0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZyb250ID0gYmFjayA9IHJlcXVlc3Q7XG4gICAgICAgICAgcmVzdW1lKGtleSwgYXJnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzdW1lKGtleSwgYXJnKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZ2VuW2tleV0oYXJnKTtcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEF3YWl0VmFsdWUpIHtcbiAgICAgICAgICBQcm9taXNlLnJlc29sdmUodmFsdWUudmFsdWUpLnRoZW4oZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgcmVzdW1lKFwibmV4dFwiLCBhcmcpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgIHJlc3VtZShcInRocm93XCIsIGFyZyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0dGxlKHJlc3VsdC5kb25lID8gXCJyZXR1cm5cIiA6IFwibm9ybWFsXCIsIHJlc3VsdC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBzZXR0bGUoXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldHRsZSh0eXBlLCB2YWx1ZSkge1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJyZXR1cm5cIjpcbiAgICAgICAgICBmcm9udC5yZXNvbHZlKHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwidGhyb3dcIjpcbiAgICAgICAgICBmcm9udC5yZWplY3QodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgZnJvbnQucmVzb2x2ZSh7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBmcm9udCA9IGZyb250Lm5leHQ7XG5cbiAgICAgIGlmIChmcm9udCkge1xuICAgICAgICByZXN1bWUoZnJvbnQua2V5LCBmcm9udC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFjayA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5faW52b2tlID0gc2VuZDtcblxuICAgIGlmICh0eXBlb2YgZ2VuLnJldHVybiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aGlzLnJldHVybiA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5hc3luY0l0ZXJhdG9yKSB7XG4gICAgQXN5bmNHZW5lcmF0b3IucHJvdG90eXBlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH1cblxuICBBc3luY0dlbmVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICByZXR1cm4gdGhpcy5faW52b2tlKFwibmV4dFwiLCBhcmcpO1xuICB9O1xuXG4gIEFzeW5jR2VuZXJhdG9yLnByb3RvdHlwZS50aHJvdyA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICByZXR1cm4gdGhpcy5faW52b2tlKFwidGhyb3dcIiwgYXJnKTtcbiAgfTtcblxuICBBc3luY0dlbmVyYXRvci5wcm90b3R5cGUucmV0dXJuID0gZnVuY3Rpb24gKGFyZykge1xuICAgIHJldHVybiB0aGlzLl9pbnZva2UoXCJyZXR1cm5cIiwgYXJnKTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIHdyYXA6IGZ1bmN0aW9uIChmbikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBc3luY0dlbmVyYXRvcihmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgIH07XG4gICAgfSxcbiAgICBhd2FpdDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gbmV3IEF3YWl0VmFsdWUodmFsdWUpO1xuICAgIH1cbiAgfTtcbn0oKTtcblxuXG5cblxuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG5cblxuXG5cblxuXG5cblxudmFyIGluaGVyaXRzID0gZnVuY3Rpb24gKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufTtcblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiA9IGZ1bmN0aW9uIChzZWxmLCBjYWxsKSB7XG4gIGlmICghc2VsZikge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmO1xufTtcblxudmFyIEV2ZW50RW1pdHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gICAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEV2ZW50RW1pdHRlcik7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gW107XG4gICAgfVxuXG4gICAgY3JlYXRlQ2xhc3MoRXZlbnRFbWl0dGVyLCBbe1xuICAgICAgICBrZXk6IFwib25cIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uKGNiKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5wdXNoKGNiKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gX3RoaXMubGlzdGVuZXJzLmluZGV4T2YoY2IpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIF90aGlzLmxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImVtaXRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVtaXQoZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4oZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyO1xufSgpO1xuXG4vKipcbiAqIENvcHlyaWdodCAyMDE1LCBZYWhvbyEgSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSRUFDVF9TVEFUSUNTID0ge1xuICAgIGNoaWxkQ29udGV4dFR5cGVzOiB0cnVlLFxuICAgIGNvbnRleHRUeXBlczogdHJ1ZSxcbiAgICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gICAgZGlzcGxheU5hbWU6IHRydWUsXG4gICAgZ2V0RGVmYXVsdFByb3BzOiB0cnVlLFxuICAgIG1peGluczogdHJ1ZSxcbiAgICBwcm9wVHlwZXM6IHRydWUsXG4gICAgdHlwZTogdHJ1ZVxufTtcblxudmFyIEtOT1dOX1NUQVRJQ1MgPSB7XG4gIG5hbWU6IHRydWUsXG4gIGxlbmd0aDogdHJ1ZSxcbiAgcHJvdG90eXBlOiB0cnVlLFxuICBjYWxsZXI6IHRydWUsXG4gIGNhbGxlZTogdHJ1ZSxcbiAgYXJndW1lbnRzOiB0cnVlLFxuICBhcml0eTogdHJ1ZVxufTtcblxudmFyIGRlZmluZVByb3BlcnR5JDEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBvYmplY3RQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZiAmJiBnZXRQcm90b3R5cGVPZihPYmplY3QpO1xuXG52YXIgaG9pc3ROb25SZWFjdFN0YXRpY3MgPSBmdW5jdGlvbiBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIHNvdXJjZUNvbXBvbmVudCwgYmxhY2tsaXN0KSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2VDb21wb25lbnQgIT09ICdzdHJpbmcnKSB7IC8vIGRvbid0IGhvaXN0IG92ZXIgc3RyaW5nIChodG1sKSBjb21wb25lbnRzXG5cbiAgICAgICAgaWYgKG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgICAgICAgdmFyIGluaGVyaXRlZENvbXBvbmVudCA9IGdldFByb3RvdHlwZU9mKHNvdXJjZUNvbXBvbmVudCk7XG4gICAgICAgICAgICBpZiAoaW5oZXJpdGVkQ29tcG9uZW50ICYmIGluaGVyaXRlZENvbXBvbmVudCAhPT0gb2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgICAgaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBpbmhlcml0ZWRDb21wb25lbnQsIGJsYWNrbGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXMoc291cmNlQ29tcG9uZW50KTtcblxuICAgICAgICBpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICAgICAgICBrZXlzID0ga2V5cy5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZUNvbXBvbmVudCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGlmICghUkVBQ1RfU1RBVElDU1trZXldICYmICFLTk9XTl9TVEFUSUNTW2tleV0gJiYgKCFibGFja2xpc3QgfHwgIWJsYWNrbGlzdFtrZXldKSkge1xuICAgICAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZUNvbXBvbmVudCwga2V5KTtcbiAgICAgICAgICAgICAgICB0cnkgeyAvLyBBdm9pZCBmYWlsdXJlcyBmcm9tIHJlYWQtb25seSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgIGRlZmluZVByb3BlcnR5JDEodGFyZ2V0Q29tcG9uZW50LCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0Q29tcG9uZW50O1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRDb21wb25lbnQ7XG59O1xuXG4vLyBDb3BpZWQgZnJvbSBSZWFjdC5Qcm9wVHlwZXNcbmZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gICAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IEFycmF5KF9sZW4gPiA2ID8gX2xlbiAtIDYgOiAwKSwgX2tleSA9IDY7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICAgIHJlc3RbX2tleSAtIDZdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVudHJhY2tlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBcIjw8YW5vbnltb3VzPj5cIjtcbiAgICAgICAgICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcbiAgICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3R1YWwgPSBwcm9wc1twcm9wTmFtZV0gPT09IG51bGwgPyBcIm51bGxcIiA6IFwidW5kZWZpbmVkXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXCJUaGUgXCIgKyBsb2NhdGlvbiArIFwiIGBcIiArIHByb3BGdWxsTmFtZSArIFwiYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgXCIgKyBcImluIGBcIiArIGNvbXBvbmVudE5hbWUgKyBcImAsIGJ1dCBpdHMgdmFsdWUgaXMgYFwiICsgYWN0dWFsICsgXCJgLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZS5hcHBseSh1bmRlZmluZWQsIFtwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWVdLmNvbmNhdChyZXN0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuICAgIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xufVxuXG4vLyBDb3BpZWQgZnJvbSBSZWFjdC5Qcm9wVHlwZXNcbmZ1bmN0aW9uIGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpIHtcbiAgICAvLyBOYXRpdmUgU3ltYm9sLlxuICAgIGlmIChwcm9wVHlwZSA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICAgIGlmIChwcm9wVmFsdWVbXCJAQHRvU3RyaW5nVGFnXCJdID09PSBcIlN5bWJvbFwiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHByb3BWYWx1ZSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIENvcGllZCBmcm9tIFJlYWN0LlByb3BUeXBlc1xuZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHByb3BWYWx1ZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICByZXR1cm4gXCJhcnJheVwiO1xuICAgIH1cbiAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxuICAgICAgICByZXR1cm4gXCJvYmplY3RcIjtcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBcInN5bWJvbFwiO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG59XG5cbi8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbi8vIENvcGllZCBmcm9tIFJlYWN0LlByb3BUeXBlc1xuZnVuY3Rpb24gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBcImRhdGVcIjtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgIHJldHVybiBcInJlZ2V4cFwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlT2JzZXJ2YWJsZVR5cGVDaGVja2VyQ3JlYXRvcihhbGxvd05hdGl2ZVR5cGUsIG1vYnhUeXBlKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGZ1bmN0aW9uIChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHVudHJhY2tlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoYWxsb3dOYXRpdmVUeXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdldFByb3BUeXBlKHByb3BzW3Byb3BOYW1lXSkgPT09IG1vYnhUeXBlLnRvTG93ZXJDYXNlKCkpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1vYnhDaGVja2VyID0gdm9pZCAwO1xuICAgICAgICAgICAgc3dpdGNoIChtb2J4VHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJBcnJheVwiOlxuICAgICAgICAgICAgICAgICAgICBtb2J4Q2hlY2tlciA9IGlzT2JzZXJ2YWJsZUFycmF5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiT2JqZWN0XCI6XG4gICAgICAgICAgICAgICAgICAgIG1vYnhDaGVja2VyID0gaXNPYnNlcnZhYmxlT2JqZWN0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiTWFwXCI6XG4gICAgICAgICAgICAgICAgICAgIG1vYnhDaGVja2VyID0gaXNPYnNlcnZhYmxlTWFwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG1vYnhUeXBlOiBcIiArIG1vYnhUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICAgICAgICBpZiAoIW1vYnhDaGVja2VyKHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJlY2lzZVR5cGUgPSBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICAgICAgICAgIHZhciBuYXRpdmVUeXBlRXhwZWN0YXRpb25NZXNzYWdlID0gYWxsb3dOYXRpdmVUeXBlID8gXCIgb3IgamF2YXNjcmlwdCBgXCIgKyBtb2J4VHlwZS50b0xvd2VyQ2FzZSgpICsgXCJgXCIgOiBcIlwiO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXCJJbnZhbGlkIHByb3AgYFwiICsgcHJvcEZ1bGxOYW1lICsgXCJgIG9mIHR5cGUgYFwiICsgcHJlY2lzZVR5cGUgKyBcImAgc3VwcGxpZWQgdG9cIiArIFwiIGBcIiArIGNvbXBvbmVudE5hbWUgKyBcImAsIGV4cGVjdGVkIGBtb2J4Lk9ic2VydmFibGVcIiArIG1vYnhUeXBlICsgXCJgXCIgKyBuYXRpdmVUeXBlRXhwZWN0YXRpb25NZXNzYWdlICsgXCIuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPYnNlcnZhYmxlQXJyYXlPZlR5cGVDaGVja2VyKGFsbG93TmF0aXZlVHlwZSwgdHlwZUNoZWNrZXIpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBBcnJheShfbGVuMiA+IDUgPyBfbGVuMiAtIDUgOiAwKSwgX2tleTIgPSA1OyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgICByZXN0W19rZXkyIC0gNV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVudHJhY2tlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFwiUHJvcGVydHkgYFwiICsgcHJvcEZ1bGxOYW1lICsgXCJgIG9mIGNvbXBvbmVudCBgXCIgKyBjb21wb25lbnROYW1lICsgXCJgIGhhcyBcIiArIFwiaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbi5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBjcmVhdGVPYnNlcnZhYmxlVHlwZUNoZWNrZXJDcmVhdG9yKGFsbG93TmF0aXZlVHlwZSwgXCJBcnJheVwiKShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiBlcnJvcjtcbiAgICAgICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGVycm9yID0gdHlwZUNoZWNrZXIuYXBwbHkodW5kZWZpbmVkLCBbcHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgXCJbXCIgKyBpICsgXCJdXCJdLmNvbmNhdChyZXN0KSk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxudmFyIG9ic2VydmFibGVBcnJheSA9IGNyZWF0ZU9ic2VydmFibGVUeXBlQ2hlY2tlckNyZWF0b3IoZmFsc2UsIFwiQXJyYXlcIik7XG52YXIgb2JzZXJ2YWJsZUFycmF5T2YgPSBjcmVhdGVPYnNlcnZhYmxlQXJyYXlPZlR5cGVDaGVja2VyLmJpbmQobnVsbCwgZmFsc2UpO1xudmFyIG9ic2VydmFibGVNYXAgPSBjcmVhdGVPYnNlcnZhYmxlVHlwZUNoZWNrZXJDcmVhdG9yKGZhbHNlLCBcIk1hcFwiKTtcbnZhciBvYnNlcnZhYmxlT2JqZWN0ID0gY3JlYXRlT2JzZXJ2YWJsZVR5cGVDaGVja2VyQ3JlYXRvcihmYWxzZSwgXCJPYmplY3RcIik7XG52YXIgYXJyYXlPck9ic2VydmFibGVBcnJheSA9IGNyZWF0ZU9ic2VydmFibGVUeXBlQ2hlY2tlckNyZWF0b3IodHJ1ZSwgXCJBcnJheVwiKTtcbnZhciBhcnJheU9yT2JzZXJ2YWJsZUFycmF5T2YgPSBjcmVhdGVPYnNlcnZhYmxlQXJyYXlPZlR5cGVDaGVja2VyLmJpbmQobnVsbCwgdHJ1ZSk7XG52YXIgb2JqZWN0T3JPYnNlcnZhYmxlT2JqZWN0ID0gY3JlYXRlT2JzZXJ2YWJsZVR5cGVDaGVja2VyQ3JlYXRvcih0cnVlLCBcIk9iamVjdFwiKTtcblxuXG5cbnZhciBwcm9wVHlwZXMgPSBPYmplY3QuZnJlZXplKHtcblx0b2JzZXJ2YWJsZUFycmF5OiBvYnNlcnZhYmxlQXJyYXksXG5cdG9ic2VydmFibGVBcnJheU9mOiBvYnNlcnZhYmxlQXJyYXlPZixcblx0b2JzZXJ2YWJsZU1hcDogb2JzZXJ2YWJsZU1hcCxcblx0b2JzZXJ2YWJsZU9iamVjdDogb2JzZXJ2YWJsZU9iamVjdCxcblx0YXJyYXlPck9ic2VydmFibGVBcnJheTogYXJyYXlPck9ic2VydmFibGVBcnJheSxcblx0YXJyYXlPck9ic2VydmFibGVBcnJheU9mOiBhcnJheU9yT2JzZXJ2YWJsZUFycmF5T2YsXG5cdG9iamVjdE9yT2JzZXJ2YWJsZU9iamVjdDogb2JqZWN0T3JPYnNlcnZhYmxlT2JqZWN0XG59KTtcblxuZnVuY3Rpb24gaXNTdGF0ZWxlc3MoY29tcG9uZW50KSB7XG4gICAgLy8gYGZ1bmN0aW9uKCkge31gIGhhcyBwcm90b3R5cGUsIGJ1dCBgKCkgPT4ge31gIGRvZXNuJ3RcbiAgICAvLyBgKCkgPT4ge31gIHZpYSBCYWJlbCBoYXMgcHJvdG90eXBlIHRvby5cbiAgICByZXR1cm4gIShjb21wb25lbnQucHJvdG90eXBlICYmIGNvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyKTtcbn1cblxudmFyIGluamVjdG9yQ29udGV4dFR5cGVzID0ge1xuICAgIG1vYnhTdG9yZXM6IG9iamVjdE9yT2JzZXJ2YWJsZU9iamVjdFxufTtcbk9iamVjdC5zZWFsKGluamVjdG9yQ29udGV4dFR5cGVzKTtcblxudmFyIHByb3hpZWRJbmplY3RvclByb3BzID0ge1xuICAgIGNvbnRleHRUeXBlczoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmplY3RvckNvbnRleHRUeXBlcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEoXykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiTW9ieCBJbmplY3RvcjogeW91IGFyZSB0cnlpbmcgdG8gYXR0YWNoIGBjb250ZXh0VHlwZXNgIG9uIGFuIGNvbXBvbmVudCBkZWNvcmF0ZWQgd2l0aCBgaW5qZWN0YCAob3IgYG9ic2VydmVyYCkgSE9DLiBQbGVhc2Ugc3BlY2lmeSB0aGUgY29udGV4dFR5cGVzIG9uIHRoZSB3cmFwcGVkIGNvbXBvbmVudCBpbnN0ZWFkLiBJdCBpcyBhY2Nlc3NpYmxlIHRocm91Z2ggdGhlIGB3cmFwcGVkQ29tcG9uZW50YFwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgIH0sXG4gICAgaXNNb2J4SW5qZWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdG9yZSBJbmplY3Rpb25cbiAgICAgKi9cbn07ZnVuY3Rpb24gY3JlYXRlU3RvcmVJbmplY3RvcihncmFiU3RvcmVzRm4sIGNvbXBvbmVudCwgaW5qZWN0TmFtZXMpIHtcbiAgICB2YXIgX2NsYXNzLCBfdGVtcDI7XG5cbiAgICB2YXIgZGlzcGxheU5hbWUgPSBcImluamVjdC1cIiArIChjb21wb25lbnQuZGlzcGxheU5hbWUgfHwgY29tcG9uZW50Lm5hbWUgfHwgY29tcG9uZW50LmNvbnN0cnVjdG9yICYmIGNvbXBvbmVudC5jb25zdHJ1Y3Rvci5uYW1lIHx8IFwiVW5rbm93blwiKTtcbiAgICBpZiAoaW5qZWN0TmFtZXMpIGRpc3BsYXlOYW1lICs9IFwiLXdpdGgtXCIgKyBpbmplY3ROYW1lcztcblxuICAgIHZhciBJbmplY3RvciA9IChfdGVtcDIgPSBfY2xhc3MgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICAgICAgICBpbmhlcml0cyhJbmplY3RvciwgX0NvbXBvbmVudCk7XG5cbiAgICAgICAgZnVuY3Rpb24gSW5qZWN0b3IoKSB7XG4gICAgICAgICAgICB2YXIgX3JlZjtcblxuICAgICAgICAgICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgICAgICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5qZWN0b3IpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IEluamVjdG9yLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSW5qZWN0b3IpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5zdG9yZVJlZiA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLndyYXBwZWRJbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgfSwgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNyZWF0ZUNsYXNzKEluamVjdG9yLCBbe1xuICAgICAgICAgICAga2V5OiBcInJlbmRlclwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgICAgICAgICAvLyBPcHRpbWl6YXRpb246IGl0IG1pZ2h0IGJlIG1vcmUgZWZmaWNpZW50IHRvIGFwcGx5IHRoZSBtYXBwZXIgZnVuY3Rpb24gKm91dHNpZGUqIHRoZSByZW5kZXIgbWV0aG9kXG4gICAgICAgICAgICAgICAgLy8gKGlmIHRoZSBtYXBwZXIgaXMgYSBmdW5jdGlvbiksIHRoYXQgY291bGQgYXZvaWQgZXhwZW5zaXZlKD8pIHJlLXJlbmRlcmluZyBvZiB0aGUgaW5qZWN0b3IgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgLy8gU2VlIHRoaXMgdGVzdDogJ3VzaW5nIGEgY3VzdG9tIGluamVjdG9yIGlzIG5vdCB0b28gcmVhY3RpdmUnIGluIGluamVjdC5qc1xuICAgICAgICAgICAgICAgIHZhciBuZXdQcm9wcyA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzW2tleV0gPSB0aGlzLnByb3BzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9dmFyIGFkZGl0aW9uYWxQcm9wcyA9IGdyYWJTdG9yZXNGbih0aGlzLmNvbnRleHQubW9ieFN0b3JlcyB8fCB7fSwgbmV3UHJvcHMsIHRoaXMuY29udGV4dCkgfHwge307XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2tleTIgaW4gYWRkaXRpb25hbFByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzW19rZXkyXSA9IGFkZGl0aW9uYWxQcm9wc1tfa2V5Ml07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFpc1N0YXRlbGVzcyhjb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzLnJlZiA9IHRoaXMuc3RvcmVSZWY7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBuZXdQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1dKTtcbiAgICAgICAgcmV0dXJuIEluamVjdG9yO1xuICAgIH0oQ29tcG9uZW50KSwgX2NsYXNzLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWUsIF90ZW1wMik7XG5cbiAgICAvLyBTdGF0aWMgZmllbGRzIGZyb20gY29tcG9uZW50IHNob3VsZCBiZSB2aXNpYmxlIG9uIHRoZSBnZW5lcmF0ZWQgSW5qZWN0b3JcblxuICAgIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKEluamVjdG9yLCBjb21wb25lbnQpO1xuXG4gICAgSW5qZWN0b3Iud3JhcHBlZENvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhJbmplY3RvciwgcHJveGllZEluamVjdG9yUHJvcHMpO1xuXG4gICAgcmV0dXJuIEluamVjdG9yO1xufVxuXG5mdW5jdGlvbiBncmFiU3RvcmVzQnlOYW1lKHN0b3JlTmFtZXMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGJhc2VTdG9yZXMsIG5leHRQcm9wcykge1xuICAgICAgICBzdG9yZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHN0b3JlTmFtZSkge1xuICAgICAgICAgICAgaWYgKHN0b3JlTmFtZSBpbiBuZXh0UHJvcHMgLy8gcHJlZmVyIHByb3BzIG92ZXIgc3RvcmVzXG4gICAgICAgICAgICApIHJldHVybjtcbiAgICAgICAgICAgIGlmICghKHN0b3JlTmFtZSBpbiBiYXNlU3RvcmVzKSkgdGhyb3cgbmV3IEVycm9yKFwiTW9iWCBpbmplY3RvcjogU3RvcmUgJ1wiICsgc3RvcmVOYW1lICsgXCInIGlzIG5vdCBhdmFpbGFibGUhIE1ha2Ugc3VyZSBpdCBpcyBwcm92aWRlZCBieSBzb21lIFByb3ZpZGVyXCIpO1xuICAgICAgICAgICAgbmV4dFByb3BzW3N0b3JlTmFtZV0gPSBiYXNlU3RvcmVzW3N0b3JlTmFtZV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV4dFByb3BzO1xuICAgIH07XG59XG5cbi8qKlxuICogaGlnaGVyIG9yZGVyIGNvbXBvbmVudCB0aGF0IGluamVjdHMgc3RvcmVzIHRvIGEgY2hpbGQuXG4gKiB0YWtlcyBlaXRoZXIgYSB2YXJhcmdzIGxpc3Qgb2Ygc3RyaW5ncywgd2hpY2ggYXJlIHN0b3JlcyByZWFkIGZyb20gdGhlIGNvbnRleHQsXG4gKiBvciBhIGZ1bmN0aW9uIHRoYXQgbWFudWFsbHkgbWFwcyB0aGUgYXZhaWxhYmxlIHN0b3JlcyBmcm9tIHRoZSBjb250ZXh0IHRvIHByb3BzOlxuICogc3RvcmVzVG9Qcm9wcyhtb2J4U3RvcmVzLCBwcm9wcywgY29udGV4dCkgPT4gbmV3UHJvcHNcbiAqL1xuZnVuY3Rpb24gaW5qZWN0KCkgLyogZm4oc3RvcmVzLCBuZXh0UHJvcHMpIG9yIC4uLnN0b3JlTmFtZXMgKi97XG4gICAgdmFyIGdyYWJTdG9yZXNGbiA9IHZvaWQgMDtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGdyYWJTdG9yZXNGbiA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjb21wb25lbnRDbGFzcykge1xuICAgICAgICAgICAgdmFyIGluamVjdGVkID0gY3JlYXRlU3RvcmVJbmplY3RvcihncmFiU3RvcmVzRm4sIGNvbXBvbmVudENsYXNzKTtcbiAgICAgICAgICAgIGluamVjdGVkLmlzTW9ieEluamVjdG9yID0gZmFsc2U7IC8vIHN1cHJlc3Mgd2FybmluZ1xuICAgICAgICAgICAgLy8gbWFyayB0aGUgSW5qZWN0b3IgYXMgb2JzZXJ2ZXIsIHRvIG1ha2UgaXQgcmVhY3QgdG8gZXhwcmVzc2lvbnMgaW4gYGdyYWJTdG9yZXNGbmAsXG4gICAgICAgICAgICAvLyBzZWUgIzExMVxuICAgICAgICAgICAgaW5qZWN0ZWQgPSBvYnNlcnZlcihpbmplY3RlZCk7XG4gICAgICAgICAgICBpbmplY3RlZC5pc01vYnhJbmplY3RvciA9IHRydWU7IC8vIHJlc3RvcmUgd2FybmluZ1xuICAgICAgICAgICAgcmV0dXJuIGluamVjdGVkO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzdG9yZU5hbWVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzdG9yZU5hbWVzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9Z3JhYlN0b3Jlc0ZuID0gZ3JhYlN0b3Jlc0J5TmFtZShzdG9yZU5hbWVzKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjb21wb25lbnRDbGFzcykge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVN0b3JlSW5qZWN0b3IoZ3JhYlN0b3Jlc0ZuLCBjb21wb25lbnRDbGFzcywgc3RvcmVOYW1lcy5qb2luKFwiLVwiKSk7XG4gICAgICAgIH07XG4gICAgfVxufVxuXG4vKipcbiAqIGRldiB0b29sIHN1cHBvcnRcbiAqL1xudmFyIGlzRGV2dG9vbHNFbmFibGVkID0gZmFsc2U7XG5cbnZhciBpc1VzaW5nU3RhdGljUmVuZGVyaW5nID0gZmFsc2U7XG5cbnZhciB3YXJuZWRBYm91dE9ic2VydmVySW5qZWN0RGVwcmVjYXRpb24gPSBmYWxzZTtcblxuLy8gV2Vha01hcDxOb2RlLCBPYmplY3Q+O1xudmFyIGNvbXBvbmVudEJ5Tm9kZVJlZ2lzdGVyeSA9IHR5cGVvZiBXZWFrTWFwICE9PSBcInVuZGVmaW5lZFwiID8gbmV3IFdlYWtNYXAoKSA6IHVuZGVmaW5lZDtcbnZhciByZW5kZXJSZXBvcnRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuZnVuY3Rpb24gZmluZERPTU5vZGUkMihjb21wb25lbnQpIHtcbiAgICBpZiAoZmluZERPTU5vZGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmaW5kRE9NTm9kZShjb21wb25lbnQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBmaW5kRE9NTm9kZSB3aWxsIHRocm93IGluIHJlYWN0LXRlc3QtcmVuZGVyZXIsIHNlZTpcbiAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW9ieGpzL21vYngtcmVhY3QvaXNzdWVzLzIxNlxuICAgICAgICAgICAgLy8gSXMgdGhlcmUgYSBiZXR0ZXIgaGV1cmlzdGljP1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHJlcG9ydFJlbmRlcmluZyhjb21wb25lbnQpIHtcbiAgICB2YXIgbm9kZSA9IGZpbmRET01Ob2RlJDIoY29tcG9uZW50KTtcbiAgICBpZiAobm9kZSAmJiBjb21wb25lbnRCeU5vZGVSZWdpc3RlcnkpIGNvbXBvbmVudEJ5Tm9kZVJlZ2lzdGVyeS5zZXQobm9kZSwgY29tcG9uZW50KTtcblxuICAgIHJlbmRlclJlcG9ydGVyLmVtaXQoe1xuICAgICAgICBldmVudDogXCJyZW5kZXJcIixcbiAgICAgICAgcmVuZGVyVGltZTogY29tcG9uZW50Ll9fJG1vYlJlbmRlckVuZCAtIGNvbXBvbmVudC5fXyRtb2JSZW5kZXJTdGFydCxcbiAgICAgICAgdG90YWxUaW1lOiBEYXRlLm5vdygpIC0gY29tcG9uZW50Ll9fJG1vYlJlbmRlclN0YXJ0LFxuICAgICAgICBjb21wb25lbnQ6IGNvbXBvbmVudCxcbiAgICAgICAgbm9kZTogbm9kZVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiB0cmFja0NvbXBvbmVudHMoKSB7XG4gICAgaWYgKHR5cGVvZiBXZWFrTWFwID09PSBcInVuZGVmaW5lZFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJbbW9ieC1yZWFjdF0gdHJhY2tpbmcgY29tcG9uZW50cyBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3Nlci5cIik7XG4gICAgaWYgKCFpc0RldnRvb2xzRW5hYmxlZCkgaXNEZXZ0b29sc0VuYWJsZWQgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiB1c2VTdGF0aWNSZW5kZXJpbmcodXNlU3RhdGljUmVuZGVyaW5nKSB7XG4gICAgaXNVc2luZ1N0YXRpY1JlbmRlcmluZyA9IHVzZVN0YXRpY1JlbmRlcmluZztcbn1cblxuLyoqXG4gKiBFcnJvcnMgcmVwb3J0ZXJcbiAqL1xuXG52YXIgZXJyb3JzUmVwb3J0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbi8qKlxuICogVXRpbGl0aWVzXG4gKi9cblxuZnVuY3Rpb24gcGF0Y2godGFyZ2V0LCBmdW5jTmFtZSkge1xuICAgIHZhciBydW5NaXhpbkZpcnN0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICAgIHZhciBiYXNlID0gdGFyZ2V0W2Z1bmNOYW1lXTtcbiAgICB2YXIgbWl4aW5GdW5jID0gcmVhY3RpdmVNaXhpbltmdW5jTmFtZV07XG4gICAgdmFyIGYgPSAhYmFzZSA/IG1peGluRnVuYyA6IHJ1bk1peGluRmlyc3QgPT09IHRydWUgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1peGluRnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBiYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBtaXhpbkZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgLy8gTVdFOiBpZGVhbGx5IHdlIGZyZWV6ZSBoZXJlIHRvIHByb3RlY3QgYWdhaW5zdCBhY2NpZGVudGFsIG92ZXJ3cml0ZXMgaW4gY29tcG9uZW50IGluc3RhbmNlcywgc2VlICMxOTVcbiAgICAvLyAuLi5idXQgdGhhdCBicmVha3MgcmVhY3QtaG90LWxvYWRlciwgc2VlICMyMzEuLi5cbiAgICB0YXJnZXRbZnVuY05hbWVdID0gZjtcbn1cblxuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgICAvL0Zyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mYmpzL2Jsb2IvYzY5OTA0YTUxMWI5MDAyNjY5MzUxNjgyMjMwNjNkZDg3NzJkZmM0MC9wYWNrYWdlcy9mYmpzL3NyYy9jb3JlL3NoYWxsb3dFcXVhbC5qc1xuICAgIGlmIChpcyhvYmpBLCBvYmpCKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKCh0eXBlb2Ygb2JqQSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iakEpKSAhPT0gXCJvYmplY3RcIiB8fCBvYmpBID09PSBudWxsIHx8ICh0eXBlb2Ygb2JqQiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iakIpKSAhPT0gXCJvYmplY3RcIiB8fCBvYmpCID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gICAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG4gICAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwob2JqQiwga2V5c0FbaV0pIHx8ICFpcyhvYmpBW2tleXNBW2ldXSwgb2JqQltrZXlzQVtpXV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAvLyBGcm9tOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmJqcy9ibG9iL2M2OTkwNGE1MTFiOTAwMjY2OTM1MTY4MjIzMDYzZGQ4NzcyZGZjNDAvcGFja2FnZXMvZmJqcy9zcmMvY29yZS9zaGFsbG93RXF1YWwuanNcbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG59XG5cbi8qKlxuICogUmVhY3RpdmVNaXhpblxuICovXG52YXIgcmVhY3RpdmVNaXhpbiA9IHtcbiAgICBjb21wb25lbnRXaWxsTW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICBpZiAoaXNVc2luZ1N0YXRpY1JlbmRlcmluZyA9PT0gdHJ1ZSkgcmV0dXJuO1xuICAgICAgICAvLyBHZW5lcmF0ZSBmcmllbmRseSBuYW1lIGZvciBkZWJ1Z2dpbmdcbiAgICAgICAgdmFyIGluaXRpYWxOYW1lID0gdGhpcy5kaXNwbGF5TmFtZSB8fCB0aGlzLm5hbWUgfHwgdGhpcy5jb25zdHJ1Y3RvciAmJiAodGhpcy5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCB0aGlzLmNvbnN0cnVjdG9yLm5hbWUpIHx8IFwiPGNvbXBvbmVudD5cIjtcbiAgICAgICAgdmFyIHJvb3ROb2RlSUQgPSB0aGlzLl9yZWFjdEludGVybmFsSW5zdGFuY2UgJiYgdGhpcy5fcmVhY3RJbnRlcm5hbEluc3RhbmNlLl9yb290Tm9kZUlEIHx8IHRoaXMuX3JlYWN0SW50ZXJuYWxGaWJlciAmJiB0aGlzLl9yZWFjdEludGVybmFsRmliZXIuX2RlYnVnSUQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHByb3BzIGFyZSBzaGFsbG93bHkgbW9kaWZpZWQsIHJlYWN0IHdpbGwgcmVuZGVyIGFueXdheSxcbiAgICAgICAgICogc28gYXRvbS5yZXBvcnRDaGFuZ2VkKCkgc2hvdWxkIG5vdCByZXN1bHQgaW4geWV0IGFub3RoZXIgcmUtcmVuZGVyXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgc2tpcFJlbmRlciA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogZm9yY2VVcGRhdGUgd2lsbCByZS1hc3NpZ24gdGhpcy5wcm9wcy4gV2UgZG9uJ3Qgd2FudCB0aGF0IHRvIGNhdXNlIGEgbG9vcCxcbiAgICAgICAgICogc28gZGV0ZWN0IHRoZXNlIGNoYW5nZXNcbiAgICAgICAgICovXG4gICAgICAgIHZhciBpc0ZvcmNpbmdVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICBmdW5jdGlvbiBtYWtlUHJvcGVydHlPYnNlcnZhYmxlUmVmZXJlbmNlKHByb3BOYW1lKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVIb2xkZXIgPSB0aGlzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgIHZhciBhdG9tID0gbmV3IEF0b20oXCJyZWFjdGl2ZSBcIiArIHByb3BOYW1lKTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBwcm9wTmFtZSwge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICAgICAgICAgICAgICBhdG9tLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZUhvbGRlcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0ZvcmNpbmdVcGRhdGUgJiYgIXNoYWxsb3dFcXVhbCh2YWx1ZUhvbGRlciwgdikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlSG9sZGVyID0gdjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBSZW5kZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXRvbS5yZXBvcnRDaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwUmVuZGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUhvbGRlciA9IHY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1ha2UgdGhpcy5wcm9wcyBhbiBvYnNlcnZhYmxlIHJlZmVyZW5jZSwgc2VlICMxMjRcbiAgICAgICAgbWFrZVByb3BlcnR5T2JzZXJ2YWJsZVJlZmVyZW5jZS5jYWxsKHRoaXMsIFwicHJvcHNcIik7XG4gICAgICAgIC8vIG1ha2Ugc3RhdGUgYW4gb2JzZXJ2YWJsZSByZWZlcmVuY2VcbiAgICAgICAgbWFrZVByb3BlcnR5T2JzZXJ2YWJsZVJlZmVyZW5jZS5jYWxsKHRoaXMsIFwic3RhdGVcIik7XG5cbiAgICAgICAgLy8gd2lyZSB1cCByZWFjdGl2ZSByZW5kZXJcbiAgICAgICAgdmFyIGJhc2VSZW5kZXIgPSB0aGlzLnJlbmRlci5iaW5kKHRoaXMpO1xuICAgICAgICB2YXIgcmVhY3Rpb24gPSBudWxsO1xuICAgICAgICB2YXIgaXNSZW5kZXJpbmdQZW5kaW5nID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIGluaXRpYWxSZW5kZXIgPSBmdW5jdGlvbiBpbml0aWFsUmVuZGVyKCkge1xuICAgICAgICAgICAgcmVhY3Rpb24gPSBuZXcgUmVhY3Rpb24oaW5pdGlhbE5hbWUgKyBcIiNcIiArIHJvb3ROb2RlSUQgKyBcIi5yZW5kZXIoKVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1JlbmRlcmluZ1BlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTi5CLiBHZXR0aW5nIGhlcmUgKmJlZm9yZSBtb3VudGluZyogbWVhbnMgdGhhdCBhIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBoYXMgc2lkZSBlZmZlY3RzIChzZWUgdGhlIHJlbGV2YW50IHRlc3QgaW4gbWlzYy5qcylcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB1bmlkaW9tYXRpYyBSZWFjdCB1c2FnZSBidXQgUmVhY3Qgd2lsbCBjb3JyZWN0bHkgd2FybiBhYm91dCB0aGlzIHNvIHdlIGNvbnRpbnVlIGFzIHVzdWFsXG4gICAgICAgICAgICAgICAgICAgIC8vIFNlZSAjODUgLyBQdWxsICM0NFxuICAgICAgICAgICAgICAgICAgICBpc1JlbmRlcmluZ1BlbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIF90aGlzLmNvbXBvbmVudFdpbGxSZWFjdCA9PT0gXCJmdW5jdGlvblwiKSBfdGhpcy5jb21wb25lbnRXaWxsUmVhY3QoKTsgLy8gVE9ETzogd3JhcCBpbiBhY3Rpb24/XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fXyRtb2J4SXNVbm1vdW50ZWQgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSB1bm1vdW50ZWQgYXQgdGhpcyBwb2ludCwgY29tcG9uZW50V2lsbFJlYWN0KCkgaGFkIGEgc2lkZSBlZmZlY3QgY2F1c2luZyB0aGUgY29tcG9uZW50IHRvIHVubW91bnRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgY2hlY2s/IFRoZW4gcmVhY3Qgd2lsbCBwcm9wZXJseSB3YXJuIGFib3V0IHRoZSBmYWN0IHRoYXQgdGhpcyBzaG91bGQgbm90IGhhcHBlbj8gU2VlICM3M1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSG93ZXZlciwgcGVvcGxlIGFsc28gY2xhaW0gdGhpcyBtaWd0aCBoYXBwZW4gZHVyaW5nIHVuaXQgdGVzdHMuLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNGb3JjaW5nVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNraXBSZW5kZXIpIENvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUuY2FsbChfdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNGb3JjaW5nVXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0Vycm9yKSByZWFjdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlYWN0aW9uLnJlYWN0Q29tcG9uZW50ID0gX3RoaXM7XG4gICAgICAgICAgICByZWFjdGl2ZVJlbmRlci4kbW9ieCA9IHJlYWN0aW9uO1xuICAgICAgICAgICAgX3RoaXMucmVuZGVyID0gcmVhY3RpdmVSZW5kZXI7XG4gICAgICAgICAgICByZXR1cm4gcmVhY3RpdmVSZW5kZXIoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcmVhY3RpdmVSZW5kZXIgPSBmdW5jdGlvbiByZWFjdGl2ZVJlbmRlcigpIHtcbiAgICAgICAgICAgIGlzUmVuZGVyaW5nUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGV4Y2VwdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHZhciByZW5kZXJpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZWFjdGlvbi50cmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGV2dG9vbHNFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9fJG1vYlJlbmRlclN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyaW5nID0gZXh0cmFzLmFsbG93U3RhdGVDaGFuZ2VzKGZhbHNlLCBiYXNlUmVuZGVyKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4Y2VwdGlvbiA9IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0RldnRvb2xzRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fXyRtb2JSZW5kZXJFbmQgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgIGVycm9yc1JlcG9ydGVyLmVtaXQoZXhjZXB0aW9uKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyaW5nO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucmVuZGVyID0gaW5pdGlhbFJlbmRlcjtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBpZiAoaXNVc2luZ1N0YXRpY1JlbmRlcmluZyA9PT0gdHJ1ZSkgcmV0dXJuO1xuICAgICAgICB0aGlzLnJlbmRlci4kbW9ieCAmJiB0aGlzLnJlbmRlci4kbW9ieC5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuX18kbW9ieElzVW5tb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGlzRGV2dG9vbHNFbmFibGVkKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGZpbmRET01Ob2RlJDIodGhpcyk7XG4gICAgICAgICAgICBpZiAobm9kZSAmJiBjb21wb25lbnRCeU5vZGVSZWdpc3RlcnkpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRCeU5vZGVSZWdpc3RlcnkuZGVsZXRlKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVuZGVyUmVwb3J0ZXIuZW1pdCh7XG4gICAgICAgICAgICAgICAgZXZlbnQ6IFwiZGVzdHJveVwiLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudDogdGhpcyxcbiAgICAgICAgICAgICAgICBub2RlOiBub2RlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGlmIChpc0RldnRvb2xzRW5hYmxlZCkge1xuICAgICAgICAgICAgcmVwb3J0UmVuZGVyaW5nKHRoaXMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNvbXBvbmVudERpZFVwZGF0ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICBpZiAoaXNEZXZ0b29sc0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHJlcG9ydFJlbmRlcmluZyh0aGlzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzaG91bGRDb21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSkge1xuICAgICAgICBpZiAoaXNVc2luZ1N0YXRpY1JlbmRlcmluZykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW21vYngtcmVhY3RdIEl0IHNlZW1zIHRoYXQgYSByZS1yZW5kZXJpbmcgb2YgYSBSZWFjdCBjb21wb25lbnQgaXMgdHJpZ2dlcmVkIHdoaWxlIGluIHN0YXRpYyAoc2VydmVyLXNpZGUpIG1vZGUuIFBsZWFzZSBtYWtlIHN1cmUgY29tcG9uZW50cyBhcmUgcmVuZGVyZWQgb25seSBvbmNlIHNlcnZlci1zaWRlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB1cGRhdGUgb24gYW55IHN0YXRlIGNoYW5nZXMgKGFzIGlzIHRoZSBkZWZhdWx0KVxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gbmV4dFN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB1cGRhdGUgaWYgcHJvcHMgYXJlIHNoYWxsb3dseSBub3QgZXF1YWwsIGluc3BpcmVkIGJ5IFB1cmVSZW5kZXJNaXhpblxuICAgICAgICAvLyB3ZSBjb3VsZCByZXR1cm4ganVzdCAnZmFsc2UnIGhlcmUsIGFuZCBhdm9pZCB0aGUgYHNraXBSZW5kZXJgIGNoZWNrcyBldGNcbiAgICAgICAgLy8gaG93ZXZlciwgaXQgaXMgbmljZXIgaWYgbGlmZWN5Y2xlIGV2ZW50cyBhcmUgdHJpZ2dlcmVkIGxpa2UgdXN1YWxseSxcbiAgICAgICAgLy8gc28gd2UgcmV0dXJuIHRydWUgaGVyZSBpZiBwcm9wcyBhcmUgc2hhbGxvd2x5IG1vZGlmaWVkLlxuICAgICAgICByZXR1cm4gIXNoYWxsb3dFcXVhbCh0aGlzLnByb3BzLCBuZXh0UHJvcHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9ic2VydmVyIGZ1bmN0aW9uIC8gZGVjb3JhdG9yXG4gICAgICovXG59O2Z1bmN0aW9uIG9ic2VydmVyKGFyZzEsIGFyZzIpIHtcbiAgICBpZiAodHlwZW9mIGFyZzEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RvcmUgbmFtZXMgc2hvdWxkIGJlIHByb3ZpZGVkIGFzIGFycmF5XCIpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcxKSkge1xuICAgICAgICAvLyBjb21wb25lbnQgbmVlZHMgc3RvcmVzXG4gICAgICAgIGlmICghd2FybmVkQWJvdXRPYnNlcnZlckluamVjdERlcHJlY2F0aW9uKSB7XG4gICAgICAgICAgICB3YXJuZWRBYm91dE9ic2VydmVySW5qZWN0RGVwcmVjYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdNb2J4IG9ic2VydmVyOiBVc2luZyBvYnNlcnZlciB0byBpbmplY3Qgc3RvcmVzIGlzIGRlcHJlY2F0ZWQgc2luY2UgNC4wLiBVc2UgYEBpbmplY3QoXCJzdG9yZTFcIiwgXCJzdG9yZTJcIikgQG9ic2VydmVyIENvbXBvbmVudENsYXNzYCBvciBgaW5qZWN0KFwic3RvcmUxXCIsIFwic3RvcmUyXCIpKG9ic2VydmVyKGNvbXBvbmVudENsYXNzKSlgIGluc3RlYWQgb2YgYEBvYnNlcnZlcihbXCJzdG9yZTFcIiwgXCJzdG9yZTJcIl0pIENvbXBvbmVudENsYXNzYCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYXJnMikge1xuICAgICAgICAgICAgLy8gaW52b2tlZCBhcyBkZWNvcmF0b3JcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29tcG9uZW50Q2xhc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIoYXJnMSwgY29tcG9uZW50Q2xhc3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpbmplY3QuYXBwbHkobnVsbCwgYXJnMSkob2JzZXJ2ZXIoYXJnMikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBjb21wb25lbnRDbGFzcyA9IGFyZzE7XG5cbiAgICBpZiAoY29tcG9uZW50Q2xhc3MuaXNNb2J4SW5qZWN0b3IgPT09IHRydWUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiTW9ieCBvYnNlcnZlcjogWW91IGFyZSB0cnlpbmcgdG8gdXNlICdvYnNlcnZlcicgb24gYSBjb21wb25lbnQgdGhhdCBhbHJlYWR5IGhhcyAnaW5qZWN0Jy4gUGxlYXNlIGFwcGx5ICdvYnNlcnZlcicgYmVmb3JlIGFwcGx5aW5nICdpbmplY3QnXCIpO1xuICAgIH1cblxuICAgIC8vIFN0YXRlbGVzcyBmdW5jdGlvbiBjb21wb25lbnQ6XG4gICAgLy8gSWYgaXQgaXMgZnVuY3Rpb24gYnV0IGRvZXNuJ3Qgc2VlbSB0byBiZSBhIHJlYWN0IGNsYXNzIGNvbnN0cnVjdG9yLFxuICAgIC8vIHdyYXAgaXQgdG8gYSByZWFjdCBjbGFzcyBhdXRvbWF0aWNhbGx5XG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnRDbGFzcyA9PT0gXCJmdW5jdGlvblwiICYmICghY29tcG9uZW50Q2xhc3MucHJvdG90eXBlIHx8ICFjb21wb25lbnRDbGFzcy5wcm90b3R5cGUucmVuZGVyKSAmJiAhY29tcG9uZW50Q2xhc3MuaXNSZWFjdENsYXNzICYmICFDb21wb25lbnQuaXNQcm90b3R5cGVPZihjb21wb25lbnRDbGFzcykpIHtcbiAgICAgICAgdmFyIF9jbGFzcywgX3RlbXA7XG5cbiAgICAgICAgcmV0dXJuIG9ic2VydmVyKChfdGVtcCA9IF9jbGFzcyA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gICAgICAgICAgICBpbmhlcml0cyhfY2xhc3MsIF9Db21wb25lbnQpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBfY2xhc3MoKSB7XG4gICAgICAgICAgICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgX2NsYXNzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX2NsYXNzLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoX2NsYXNzKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNyZWF0ZUNsYXNzKF9jbGFzcywgW3tcbiAgICAgICAgICAgICAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudENsYXNzLmNhbGwodGhpcywgdGhpcy5wcm9wcywgdGhpcy5jb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG4gICAgICAgICAgICByZXR1cm4gX2NsYXNzO1xuICAgICAgICB9KENvbXBvbmVudCksIF9jbGFzcy5kaXNwbGF5TmFtZSA9IGNvbXBvbmVudENsYXNzLmRpc3BsYXlOYW1lIHx8IGNvbXBvbmVudENsYXNzLm5hbWUsIF9jbGFzcy5jb250ZXh0VHlwZXMgPSBjb21wb25lbnRDbGFzcy5jb250ZXh0VHlwZXMsIF9jbGFzcy5wcm9wVHlwZXMgPSBjb21wb25lbnRDbGFzcy5wcm9wVHlwZXMsIF9jbGFzcy5kZWZhdWx0UHJvcHMgPSBjb21wb25lbnRDbGFzcy5kZWZhdWx0UHJvcHMsIF90ZW1wKSk7XG4gICAgfVxuXG4gICAgaWYgKCFjb21wb25lbnRDbGFzcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcGFzcyBhIHZhbGlkIGNvbXBvbmVudCB0byAnb2JzZXJ2ZXInXCIpO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXQgPSBjb21wb25lbnRDbGFzcy5wcm90b3R5cGUgfHwgY29tcG9uZW50Q2xhc3M7XG4gICAgbWl4aW5MaWZlY3ljbGVFdmVudHModGFyZ2V0KTtcbiAgICBjb21wb25lbnRDbGFzcy5pc01vYlhSZWFjdE9ic2VydmVyID0gdHJ1ZTtcbiAgICByZXR1cm4gY29tcG9uZW50Q2xhc3M7XG59XG5cbmZ1bmN0aW9uIG1peGluTGlmZWN5Y2xlRXZlbnRzKHRhcmdldCkge1xuICAgIHBhdGNoKHRhcmdldCwgXCJjb21wb25lbnRXaWxsTW91bnRcIiwgdHJ1ZSk7W1wiY29tcG9uZW50RGlkTW91bnRcIiwgXCJjb21wb25lbnRXaWxsVW5tb3VudFwiLCBcImNvbXBvbmVudERpZFVwZGF0ZVwiXS5mb3JFYWNoKGZ1bmN0aW9uIChmdW5jTmFtZSkge1xuICAgICAgICBwYXRjaCh0YXJnZXQsIGZ1bmNOYW1lKTtcbiAgICB9KTtcbiAgICBpZiAoIXRhcmdldC5zaG91bGRDb21wb25lbnRVcGRhdGUpIHtcbiAgICAgICAgdGFyZ2V0LnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IHJlYWN0aXZlTWl4aW4uc2hvdWxkQ29tcG9uZW50VXBkYXRlO1xuICAgIH1cbn1cblxuLy8gVE9ETzogc3VwcG9ydCBpbmplY3Rpb24gc29tZWhvdyBhcyB3ZWxsP1xudmFyIE9ic2VydmVyID0gb2JzZXJ2ZXIoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgICBvYnNlcnZlckluamVjdCA9IF9yZWYuaW5qZWN0LFxuICAgICAgICByZW5kZXIgPSBfcmVmLnJlbmRlcjtcblxuICAgIHZhciBjb21wb25lbnQgPSBjaGlsZHJlbiB8fCByZW5kZXI7XG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICghb2JzZXJ2ZXJJbmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudCgpO1xuICAgIH1cbiAgICB2YXIgSW5qZWN0Q29tcG9uZW50ID0gaW5qZWN0KG9ic2VydmVySW5qZWN0KShjb21wb25lbnQpO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEluamVjdENvbXBvbmVudCwgbnVsbCk7XG59KTtcblxuT2JzZXJ2ZXIuZGlzcGxheU5hbWUgPSBcIk9ic2VydmVyXCI7XG5cbnZhciBPYnNlcnZlclByb3BzQ2hlY2sgPSBmdW5jdGlvbiBPYnNlcnZlclByb3BzQ2hlY2socHJvcHMsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIHZhciBleHRyYUtleSA9IGtleSA9PT0gXCJjaGlsZHJlblwiID8gXCJyZW5kZXJcIiA6IFwiY2hpbGRyZW5cIjtcbiAgICBpZiAodHlwZW9mIHByb3BzW2tleV0gPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgcHJvcHNbZXh0cmFLZXldID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcIkludmFsaWQgcHJvcCxkbyBub3QgdXNlIGNoaWxkcmVuIGFuZCByZW5kZXIgaW4gdGhlIHNhbWUgdGltZSBpbmBcIiArIGNvbXBvbmVudE5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcHJvcHNba2V5XSA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBwcm9wc1tleHRyYUtleV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBuZXcgRXJyb3IoXCJJbnZhbGlkIHByb3AgYFwiICsgcHJvcEZ1bGxOYW1lICsgXCJgIG9mIHR5cGUgYFwiICsgX3R5cGVvZihwcm9wc1trZXldKSArIFwiYCBzdXBwbGllZCB0b1wiICsgXCIgYFwiICsgY29tcG9uZW50TmFtZSArIFwiYCwgZXhwZWN0ZWQgYGZ1bmN0aW9uYC5cIik7XG59O1xuXG5PYnNlcnZlci5wcm9wVHlwZXMgPSB7XG4gICAgcmVuZGVyOiBPYnNlcnZlclByb3BzQ2hlY2ssXG4gICAgY2hpbGRyZW46IE9ic2VydmVyUHJvcHNDaGVja1xufTtcblxudmFyIF9jbGFzcztcbnZhciBfdGVtcDtcblxudmFyIHNwZWNpYWxSZWFjdEtleXMgPSB7IGNoaWxkcmVuOiB0cnVlLCBrZXk6IHRydWUsIHJlZjogdHJ1ZSB9O1xuXG52YXIgUHJvdmlkZXIgPSAoX3RlbXAgPSBfY2xhc3MgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICAgIGluaGVyaXRzKFByb3ZpZGVyLCBfQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIFByb3ZpZGVyKCkge1xuICAgICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQcm92aWRlcik7XG4gICAgICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChQcm92aWRlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFByb3ZpZGVyKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfVxuXG4gICAgY3JlYXRlQ2xhc3MoUHJvdmlkZXIsIFt7XG4gICAgICAgIGtleTogXCJyZW5kZXJcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgICAgIHJldHVybiBDaGlsZHJlbi5vbmx5KHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZ2V0Q2hpbGRDb250ZXh0XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgICAgICAgICB2YXIgc3RvcmVzID0ge307XG4gICAgICAgICAgICAvLyBpbmhlcml0IHN0b3Jlc1xuICAgICAgICAgICAgdmFyIGJhc2VTdG9yZXMgPSB0aGlzLmNvbnRleHQubW9ieFN0b3JlcztcbiAgICAgICAgICAgIGlmIChiYXNlU3RvcmVzKSBmb3IgKHZhciBrZXkgaW4gYmFzZVN0b3Jlcykge1xuICAgICAgICAgICAgICAgIHN0b3Jlc1trZXldID0gYmFzZVN0b3Jlc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWRkIG93biBzdG9yZXNcbiAgICAgICAgICAgIGZvciAodmFyIF9rZXkgaW4gdGhpcy5wcm9wcykge1xuICAgICAgICAgICAgICAgIGlmICghc3BlY2lhbFJlYWN0S2V5c1tfa2V5XSAmJiBfa2V5ICE9PSBcInN1cHByZXNzQ2hhbmdlZFN0b3JlV2FybmluZ1wiKSBzdG9yZXNbX2tleV0gPSB0aGlzLnByb3BzW19rZXldO1xuICAgICAgICAgICAgfXJldHVybiB7XG4gICAgICAgICAgICAgICAgbW9ieFN0b3Jlczogc3RvcmVzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgIC8vIE1heWJlIHRoaXMgd2FybmluZyBpcyB0b28gYWdncmVzc2l2ZT9cbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhuZXh0UHJvcHMpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXModGhpcy5wcm9wcykubGVuZ3RoKSBjb25zb2xlLndhcm4oXCJNb2JYIFByb3ZpZGVyOiBUaGUgc2V0IG9mIHByb3ZpZGVkIHN0b3JlcyBoYXMgY2hhbmdlZC4gUGxlYXNlIGF2b2lkIGNoYW5naW5nIHN0b3JlcyBhcyB0aGUgY2hhbmdlIG1pZ2h0IG5vdCBwcm9wYWdhdGUgdG8gYWxsIGNoaWxkcmVuXCIpO1xuICAgICAgICAgICAgaWYgKCFuZXh0UHJvcHMuc3VwcHJlc3NDaGFuZ2VkU3RvcmVXYXJuaW5nKSBmb3IgKHZhciBrZXkgaW4gbmV4dFByb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzcGVjaWFsUmVhY3RLZXlzW2tleV0gJiYgdGhpcy5wcm9wc1trZXldICE9PSBuZXh0UHJvcHNba2V5XSkgY29uc29sZS53YXJuKFwiTW9iWCBQcm92aWRlcjogUHJvdmlkZWQgc3RvcmUgJ1wiICsga2V5ICsgXCInIGhhcyBjaGFuZ2VkLiBQbGVhc2UgYXZvaWQgcmVwbGFjaW5nIHN0b3JlcyBhcyB0aGUgY2hhbmdlIG1pZ2h0IG5vdCBwcm9wYWdhdGUgdG8gYWxsIGNoaWxkcmVuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBQcm92aWRlcjtcbn0oQ29tcG9uZW50KSwgX2NsYXNzLmNvbnRleHRUeXBlcyA9IHtcbiAgICBtb2J4U3RvcmVzOiBvYmplY3RPck9ic2VydmFibGVPYmplY3Rcbn0sIF9jbGFzcy5jaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgICBtb2J4U3RvcmVzOiBvYmplY3RPck9ic2VydmFibGVPYmplY3QuaXNSZXF1aXJlZFxufSwgX3RlbXApO1xuXG5pZiAoIUNvbXBvbmVudCkgdGhyb3cgbmV3IEVycm9yKFwibW9ieC1yZWFjdCByZXF1aXJlcyBSZWFjdCB0byBiZSBhdmFpbGFibGVcIik7XG5pZiAoIWV4dHJhcykgdGhyb3cgbmV3IEVycm9yKFwibW9ieC1yZWFjdCByZXF1aXJlcyBtb2J4IHRvIGJlIGF2YWlsYWJsZVwiKTtcblxuaWYgKHR5cGVvZiB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyA9PT0gXCJmdW5jdGlvblwiKSBleHRyYXMuc2V0UmVhY3Rpb25TY2hlZHVsZXIodW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMpO2Vsc2UgaWYgKHR5cGVvZiB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyQxID09PSBcImZ1bmN0aW9uXCIpIGV4dHJhcy5zZXRSZWFjdGlvblNjaGVkdWxlcih1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyQxKTtcblxudmFyIG9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yKGZuKSB7XG4gICAgcmV0dXJuIGVycm9yc1JlcG9ydGVyLm9uKGZuKTtcbn07XG5cbi8qIERldlRvb2wgc3VwcG9ydCAqL1xuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYW5keWtvZy9tb2J4LWRldnRvb2xzL2Jsb2IvZDg5NzZjMjRiOGNiNzI3ZWQ1OWY5YTBiYzkwNWEwMDlkZjc5ZTIyMS9zcmMvYmFja2VuZC9pbnN0YWxsR2xvYmFsSG9vay5qc1xuXG5pZiAoKHR5cGVvZiBfX01PQlhfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKF9fTU9CWF9ERVZUT09MU19HTE9CQUxfSE9PS19fKSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICB2YXIgbW9ieCQxID0geyBzcHk6IHNweSwgZXh0cmFzOiBleHRyYXMgfTtcbiAgICB2YXIgbW9ieFJlYWN0ID0geyByZW5kZXJSZXBvcnRlcjogcmVuZGVyUmVwb3J0ZXIsIGNvbXBvbmVudEJ5Tm9kZVJlZ2lzdGVyeTogY29tcG9uZW50QnlOb2RlUmVnaXN0ZXJ5LCB0cmFja0NvbXBvbmVudHM6IHRyYWNrQ29tcG9uZW50cyB9O1xuICAgIF9fTU9CWF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmluamVjdE1vYnhSZWFjdChtb2J4UmVhY3QsIG1vYngkMSk7XG59XG5cbmV4cG9ydCB7IHByb3BUeXBlcywgcHJvcFR5cGVzIGFzIFByb3BUeXBlcywgb25FcnJvciwgb2JzZXJ2ZXIsIE9ic2VydmVyLCByZW5kZXJSZXBvcnRlciwgY29tcG9uZW50QnlOb2RlUmVnaXN0ZXJ5LCB0cmFja0NvbXBvbmVudHMsIHVzZVN0YXRpY1JlbmRlcmluZywgUHJvdmlkZXIsIGluamVjdCB9O1xuIiwiLyoqIE1vYlggLSAoYykgTWljaGVsIFdlc3RzdHJhdGUgMjAxNSwgMjAxNiAtIE1JVCBMaWNlbnNlZCAqL1xuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuXHJcbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cblxuLyoqXG4gKiBBbnl0aGluZyB0aGF0IGNhbiBiZSB1c2VkIHRvIF9zdG9yZV8gc3RhdGUgaXMgYW4gQXRvbSBpbiBtb2J4LiBBdG9tcyBoYXZlIHR3byBpbXBvcnRhbnQgam9ic1xuICpcbiAqIDEpIGRldGVjdCB3aGVuIHRoZXkgYXJlIGJlaW5nIF91c2VkXyBhbmQgcmVwb3J0IHRoaXMgKHVzaW5nIHJlcG9ydE9ic2VydmVkKS4gVGhpcyBhbGxvd3MgbW9ieCB0byBtYWtlIHRoZSBjb25uZWN0aW9uIGJldHdlZW4gcnVubmluZyBmdW5jdGlvbnMgYW5kIHRoZSBkYXRhIHRoZXkgdXNlZFxuICogMikgdGhleSBzaG91bGQgbm90aWZ5IG1vYnggd2hlbmV2ZXIgdGhleSBoYXZlIF9jaGFuZ2VkXy4gVGhpcyB3YXkgbW9ieCBjYW4gcmUtcnVuIGFueSBmdW5jdGlvbnMgKGRlcml2YXRpb25zKSB0aGF0IGFyZSB1c2luZyB0aGlzIGF0b20uXG4gKi9cbnZhciBCYXNlQXRvbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGF0b20uIEZvciBkZWJ1Z2dpbmcgcHVycG9zZXMgaXQgaXMgcmVjb21tZW5kZWQgdG8gZ2l2ZSBpdCBhIG5hbWUuXG4gICAgICogVGhlIG9uQmVjb21lT2JzZXJ2ZWQgYW5kIG9uQmVjb21lVW5vYnNlcnZlZCBjYWxsYmFja3MgY2FuIGJlIHVzZWQgZm9yIHJlc291cmNlIG1hbmFnZW1lbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQmFzZUF0b20obmFtZSkge1xuICAgICAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7IG5hbWUgPSBcIkF0b21AXCIgKyBnZXROZXh0SWQoKTsgfVxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmlzUGVuZGluZ1Vub2JzZXJ2YXRpb24gPSB0cnVlOyAvLyBmb3IgZWZmZWN0aXZlIHVub2JzZXJ2aW5nLiBCYXNlQXRvbSBoYXMgdHJ1ZSwgZm9yIGV4dHJhIG9wdGltaXphdGlvbiwgc28gaXRzIG9uQmVjb21lVW5vYnNlcnZlZCBuZXZlciBnZXRzIGNhbGxlZCwgYmVjYXVzZSBpdCdzIG5vdCBuZWVkZWRcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5vYnNlcnZlcnNJbmRleGVzID0ge307XG4gICAgICAgIHRoaXMuZGlmZlZhbHVlID0gMDtcbiAgICAgICAgdGhpcy5sYXN0QWNjZXNzZWRCeSA9IDA7XG4gICAgICAgIHRoaXMubG93ZXN0T2JzZXJ2ZXJTdGF0ZSA9IElEZXJpdmF0aW9uU3RhdGUuTk9UX1RSQUNLSU5HO1xuICAgIH1cbiAgICBCYXNlQXRvbS5wcm90b3R5cGUub25CZWNvbWVVbm9ic2VydmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBub29wXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnZva2UgdGhpcyBtZXRob2QgdG8gbm90aWZ5IG1vYnggdGhhdCB5b3VyIGF0b20gaGFzIGJlZW4gdXNlZCBzb21laG93LlxuICAgICAqL1xuICAgIEJhc2VBdG9tLnByb3RvdHlwZS5yZXBvcnRPYnNlcnZlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVwb3J0T2JzZXJ2ZWQodGhpcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnZva2UgdGhpcyBtZXRob2QgX2FmdGVyXyB0aGlzIG1ldGhvZCBoYXMgY2hhbmdlZCB0byBzaWduYWwgbW9ieCB0aGF0IGFsbCBpdHMgb2JzZXJ2ZXJzIHNob3VsZCBpbnZhbGlkYXRlLlxuICAgICAqL1xuICAgIEJhc2VBdG9tLnByb3RvdHlwZS5yZXBvcnRDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzdGFydEJhdGNoKCk7XG4gICAgICAgIHByb3BhZ2F0ZUNoYW5nZWQodGhpcyk7XG4gICAgICAgIGVuZEJhdGNoKCk7XG4gICAgfTtcbiAgICBCYXNlQXRvbS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgfTtcbiAgICByZXR1cm4gQmFzZUF0b207XG59KCkpO1xudmFyIEF0b20gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBdG9tLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBhdG9tLiBGb3IgZGVidWdnaW5nIHB1cnBvc2VzIGl0IGlzIHJlY29tbWVuZGVkIHRvIGdpdmUgaXQgYSBuYW1lLlxuICAgICAqIFRoZSBvbkJlY29tZU9ic2VydmVkIGFuZCBvbkJlY29tZVVub2JzZXJ2ZWQgY2FsbGJhY2tzIGNhbiBiZSB1c2VkIGZvciByZXNvdXJjZSBtYW5hZ2VtZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEF0b20obmFtZSwgb25CZWNvbWVPYnNlcnZlZEhhbmRsZXIsIG9uQmVjb21lVW5vYnNlcnZlZEhhbmRsZXIpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09IHZvaWQgMCkgeyBuYW1lID0gXCJBdG9tQFwiICsgZ2V0TmV4dElkKCk7IH1cbiAgICAgICAgaWYgKG9uQmVjb21lT2JzZXJ2ZWRIYW5kbGVyID09PSB2b2lkIDApIHsgb25CZWNvbWVPYnNlcnZlZEhhbmRsZXIgPSBub29wOyB9XG4gICAgICAgIGlmIChvbkJlY29tZVVub2JzZXJ2ZWRIYW5kbGVyID09PSB2b2lkIDApIHsgb25CZWNvbWVVbm9ic2VydmVkSGFuZGxlciA9IG5vb3A7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIF90aGlzLm9uQmVjb21lT2JzZXJ2ZWRIYW5kbGVyID0gb25CZWNvbWVPYnNlcnZlZEhhbmRsZXI7XG4gICAgICAgIF90aGlzLm9uQmVjb21lVW5vYnNlcnZlZEhhbmRsZXIgPSBvbkJlY29tZVVub2JzZXJ2ZWRIYW5kbGVyO1xuICAgICAgICBfdGhpcy5pc1BlbmRpbmdVbm9ic2VydmF0aW9uID0gZmFsc2U7IC8vIGZvciBlZmZlY3RpdmUgdW5vYnNlcnZpbmcuXG4gICAgICAgIF90aGlzLmlzQmVpbmdUcmFja2VkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQXRvbS5wcm90b3R5cGUucmVwb3J0T2JzZXJ2ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN0YXJ0QmF0Y2goKTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5yZXBvcnRPYnNlcnZlZC5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAoIXRoaXMuaXNCZWluZ1RyYWNrZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNCZWluZ1RyYWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5vbkJlY29tZU9ic2VydmVkSGFuZGxlcigpO1xuICAgICAgICB9XG4gICAgICAgIGVuZEJhdGNoKCk7XG4gICAgICAgIHJldHVybiAhIWdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbjtcbiAgICAgICAgLy8gcmV0dXJuIGRvZXNuJ3QgcmVhbGx5IGdpdmUgdXNlZnVsIGluZm8sIGJlY2F1c2UgaXQgY2FuIGJlIGFzIHdlbGwgY2FsbGluZyBjb21wdXRlZCB3aGljaCBjYWxscyBhdG9tIChubyByZWFjdGlvbnMpXG4gICAgICAgIC8vIGFsc28gaXQgY291bGQgbm90IHRyaWdnZXIgd2hlbiBjYWxjdWxhdGluZyByZWFjdGlvbiBkZXBlbmRlbnQgb24gQXRvbSBiZWNhdXNlIEF0b20ncyB2YWx1ZSB3YXMgY2FjaGVkIGJ5IGNvbXB1dGVkIGNhbGxlZCBieSBnaXZlbiByZWFjdGlvbi5cbiAgICB9O1xuICAgIEF0b20ucHJvdG90eXBlLm9uQmVjb21lVW5vYnNlcnZlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc0JlaW5nVHJhY2tlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uQmVjb21lVW5vYnNlcnZlZEhhbmRsZXIoKTtcbiAgICB9O1xuICAgIHJldHVybiBBdG9tO1xufShCYXNlQXRvbSkpO1xudmFyIGlzQXRvbSA9IGNyZWF0ZUluc3RhbmNlb2ZQcmVkaWNhdGUoXCJBdG9tXCIsIEJhc2VBdG9tKTtcblxuZnVuY3Rpb24gaGFzSW50ZXJjZXB0b3JzKGludGVyY2VwdGFibGUpIHtcbiAgICByZXR1cm4gaW50ZXJjZXB0YWJsZS5pbnRlcmNlcHRvcnMgJiYgaW50ZXJjZXB0YWJsZS5pbnRlcmNlcHRvcnMubGVuZ3RoID4gMDtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVySW50ZXJjZXB0b3IoaW50ZXJjZXB0YWJsZSwgaGFuZGxlcikge1xuICAgIHZhciBpbnRlcmNlcHRvcnMgPSBpbnRlcmNlcHRhYmxlLmludGVyY2VwdG9ycyB8fCAoaW50ZXJjZXB0YWJsZS5pbnRlcmNlcHRvcnMgPSBbXSk7XG4gICAgaW50ZXJjZXB0b3JzLnB1c2goaGFuZGxlcik7XG4gICAgcmV0dXJuIG9uY2UoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWR4ID0gaW50ZXJjZXB0b3JzLmluZGV4T2YoaGFuZGxlcik7XG4gICAgICAgIGlmIChpZHggIT09IC0xKVxuICAgICAgICAgICAgaW50ZXJjZXB0b3JzLnNwbGljZShpZHgsIDEpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gaW50ZXJjZXB0Q2hhbmdlKGludGVyY2VwdGFibGUsIGNoYW5nZSkge1xuICAgIHZhciBwcmV2VSA9IHVudHJhY2tlZFN0YXJ0KCk7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIGludGVyY2VwdG9ycyA9IGludGVyY2VwdGFibGUuaW50ZXJjZXB0b3JzO1xuICAgICAgICBpZiAoaW50ZXJjZXB0b3JzKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBpbnRlcmNlcHRvcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlID0gaW50ZXJjZXB0b3JzW2ldKGNoYW5nZSk7XG4gICAgICAgICAgICAgICAgaW52YXJpYW50KCFjaGFuZ2UgfHwgY2hhbmdlLnR5cGUsIFwiSW50ZXJjZXB0IGhhbmRsZXJzIHNob3VsZCByZXR1cm4gbm90aGluZyBvciBhIGNoYW5nZSBvYmplY3RcIik7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGFuZ2UpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbmdlO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdW50cmFja2VkRW5kKHByZXZVKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGhhc0xpc3RlbmVycyhsaXN0ZW5hYmxlKSB7XG4gICAgcmV0dXJuIGxpc3RlbmFibGUuY2hhbmdlTGlzdGVuZXJzICYmIGxpc3RlbmFibGUuY2hhbmdlTGlzdGVuZXJzLmxlbmd0aCA+IDA7XG59XG5mdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVyKGxpc3RlbmFibGUsIGhhbmRsZXIpIHtcbiAgICB2YXIgbGlzdGVuZXJzID0gbGlzdGVuYWJsZS5jaGFuZ2VMaXN0ZW5lcnMgfHwgKGxpc3RlbmFibGUuY2hhbmdlTGlzdGVuZXJzID0gW10pO1xuICAgIGxpc3RlbmVycy5wdXNoKGhhbmRsZXIpO1xuICAgIHJldHVybiBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkeCA9IGxpc3RlbmVycy5pbmRleE9mKGhhbmRsZXIpO1xuICAgICAgICBpZiAoaWR4ICE9PSAtMSlcbiAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG5vdGlmeUxpc3RlbmVycyhsaXN0ZW5hYmxlLCBjaGFuZ2UpIHtcbiAgICB2YXIgcHJldlUgPSB1bnRyYWNrZWRTdGFydCgpO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBsaXN0ZW5hYmxlLmNoYW5nZUxpc3RlbmVycztcbiAgICBpZiAoIWxpc3RlbmVycylcbiAgICAgICAgcmV0dXJuO1xuICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5zbGljZSgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBsaXN0ZW5lcnNbaV0oY2hhbmdlKTtcbiAgICB9XG4gICAgdW50cmFja2VkRW5kKHByZXZVKTtcbn1cblxuZnVuY3Rpb24gaXNTcHlFbmFibGVkKCkge1xuICAgIHJldHVybiAhIWdsb2JhbFN0YXRlLnNweUxpc3RlbmVycy5sZW5ndGg7XG59XG5mdW5jdGlvbiBzcHlSZXBvcnQoZXZlbnQpIHtcbiAgICBpZiAoIWdsb2JhbFN0YXRlLnNweUxpc3RlbmVycy5sZW5ndGgpXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgbGlzdGVuZXJzID0gZ2xvYmFsU3RhdGUuc3B5TGlzdGVuZXJzO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgbGlzdGVuZXJzW2ldKGV2ZW50KTtcbn1cbmZ1bmN0aW9uIHNweVJlcG9ydFN0YXJ0KGV2ZW50KSB7XG4gICAgdmFyIGNoYW5nZSA9IG9iamVjdEFzc2lnbih7fSwgZXZlbnQsIHsgc3B5UmVwb3J0U3RhcnQ6IHRydWUgfSk7XG4gICAgc3B5UmVwb3J0KGNoYW5nZSk7XG59XG52YXIgRU5EX0VWRU5UID0geyBzcHlSZXBvcnRFbmQ6IHRydWUgfTtcbmZ1bmN0aW9uIHNweVJlcG9ydEVuZChjaGFuZ2UpIHtcbiAgICBpZiAoY2hhbmdlKVxuICAgICAgICBzcHlSZXBvcnQob2JqZWN0QXNzaWduKHt9LCBjaGFuZ2UsIEVORF9FVkVOVCkpO1xuICAgIGVsc2VcbiAgICAgICAgc3B5UmVwb3J0KEVORF9FVkVOVCk7XG59XG5mdW5jdGlvbiBzcHkobGlzdGVuZXIpIHtcbiAgICBnbG9iYWxTdGF0ZS5zcHlMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgcmV0dXJuIG9uY2UoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWR4ID0gZ2xvYmFsU3RhdGUuc3B5TGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgICBpZiAoaWR4ICE9PSAtMSlcbiAgICAgICAgICAgIGdsb2JhbFN0YXRlLnNweUxpc3RlbmVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gaXRlcmF0b3JTeW1ib2woKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yKSB8fCBcIkBAaXRlcmF0b3JcIjtcbn1cbnZhciBJU19JVEVSQVRJTkdfTUFSS0VSID0gXCJfXyQkaXRlcmF0aW5nXCI7XG5mdW5jdGlvbiBhcnJheUFzSXRlcmF0b3IoYXJyYXkpIHtcbiAgICAvLyByZXR1cm5pbmcgYW4gYXJyYXkgZm9yIGVudHJpZXMoKSwgdmFsdWVzKCkgZXRjIGZvciBtYXBzIHdhcyBhIG1pcy1pbnRlcnByZXRhdGlvbiBvZiB0aGUgc3BlY3MuLixcbiAgICAvLyB5ZXQgaXQgaXMgcXVpdGUgY29udmVuaWVudCB0byBiZSBhYmxlIHRvIHVzZSB0aGUgcmVzcG9uc2UgYm90aCBhcyBhcnJheSBkaXJlY3RseSBhbmQgYXMgaXRlcmF0b3JcbiAgICAvLyBpdCBpcyBzdWJvcHRpbWFsLCBidXQgYWxhcy4uLlxuICAgIGludmFyaWFudChhcnJheVtJU19JVEVSQVRJTkdfTUFSS0VSXSAhPT0gdHJ1ZSwgXCJJbGxlZ2FsIHN0YXRlOiBjYW5ub3QgcmVjeWNsZSBhcnJheSBhcyBpdGVyYXRvclwiKTtcbiAgICBhZGRIaWRkZW5GaW5hbFByb3AoYXJyYXksIElTX0lURVJBVElOR19NQVJLRVIsIHRydWUpO1xuICAgIHZhciBpZHggPSAtMTtcbiAgICBhZGRIaWRkZW5GaW5hbFByb3AoYXJyYXksIFwibmV4dFwiLCBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICBpZHgrKztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IGlkeCA+PSB0aGlzLmxlbmd0aCxcbiAgICAgICAgICAgIHZhbHVlOiBpZHggPCB0aGlzLmxlbmd0aCA/IHRoaXNbaWR4XSA6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBhcnJheTtcbn1cbmZ1bmN0aW9uIGRlY2xhcmVJdGVyYXRvcihwcm90b3RUeXBlLCBpdGVyYXRvckZhY3RvcnkpIHtcbiAgICBhZGRIaWRkZW5GaW5hbFByb3AocHJvdG90VHlwZSwgaXRlcmF0b3JTeW1ib2woKSwgaXRlcmF0b3JGYWN0b3J5KTtcbn1cblxudmFyIE1BWF9TUExJQ0VfU0laRSA9IDEwMDAwOyAvLyBTZWUgZS5nLiBodHRwczovL2dpdGh1Yi5jb20vbW9ieGpzL21vYngvaXNzdWVzLzg1OVxuLy8gRGV0ZWN0cyBidWcgaW4gc2FmYXJpIDkuMS4xIChvciBpT1MgOSBzYWZhcmkgbW9iaWxlKS4gU2VlICMzNjRcbnZhciBzYWZhcmlQcm90b3R5cGVTZXR0ZXJJbmhlcml0YW5jZUJ1ZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHYgPSBmYWxzZTtcbiAgICB2YXIgcCA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwLCBcIjBcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHYgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmNyZWF0ZShwKVtcIjBcIl0gPSAxO1xuICAgIHJldHVybiB2ID09PSBmYWxzZTtcbn0pKCk7XG4vKipcbiAqIFRoaXMgYXJyYXkgYnVmZmVyIGNvbnRhaW5zIHR3byBsaXN0cyBvZiBwcm9wZXJ0aWVzLCBzbyB0aGF0IGFsbCBhcnJheXNcbiAqIGNhbiByZWN5Y2xlIHRoZWlyIHByb3BlcnR5IGRlZmluaXRpb25zLCB3aGljaCBzaWduaWZpY2FudGx5IGltcHJvdmVzIHBlcmZvcm1hbmNlIG9mIGNyZWF0aW5nXG4gKiBwcm9wZXJ0aWVzIG9uIHRoZSBmbHkuXG4gKi9cbnZhciBPQlNFUlZBQkxFX0FSUkFZX0JVRkZFUl9TSVpFID0gMDtcbi8vIFR5cGVzY3JpcHQgd29ya2Fyb3VuZCB0byBtYWtlIHN1cmUgT2JzZXJ2YWJsZUFycmF5IGV4dGVuZHMgQXJyYXlcbnZhciBTdHViQXJyYXkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0dWJBcnJheSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIFN0dWJBcnJheTtcbn0oKSk7XG5mdW5jdGlvbiBpbmhlcml0KGN0b3IsIHByb3RvKSB7XG4gICAgaWYgKHR5cGVvZiBPYmplY3RbXCJzZXRQcm90b3R5cGVPZlwiXSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBPYmplY3RbXCJzZXRQcm90b3R5cGVPZlwiXShjdG9yLnByb3RvdHlwZSwgcHJvdG8pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgY3Rvci5wcm90b3R5cGUuX19wcm90b19fICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGN0b3IucHJvdG90eXBlLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY3RvcltcInByb3RvdHlwZVwiXSA9IHByb3RvO1xuICAgIH1cbn1cbmluaGVyaXQoU3R1YkFycmF5LCBBcnJheS5wcm90b3R5cGUpO1xuLy8gV2VleCBmcmVlemUgQXJyYXkucHJvdG90eXBlXG4vLyBNYWtlIHRoZW0gd3JpdGVhYmxlIGFuZCBjb25maWd1cmFibGUgaW4gcHJvdG90eXBlIGNoYWluXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYWxpYmFiYS93ZWV4L3B1bGwvMTUyOVxuaWYgKE9iamVjdC5pc0Zyb3plbihBcnJheSkpIHtcbiAgICBcbiAgICBbXG4gICAgICAgIFwiY29uc3RydWN0b3JcIixcbiAgICAgICAgXCJwdXNoXCIsXG4gICAgICAgIFwic2hpZnRcIixcbiAgICAgICAgXCJjb25jYXRcIixcbiAgICAgICAgXCJwb3BcIixcbiAgICAgICAgXCJ1bnNoaWZ0XCIsXG4gICAgICAgIFwicmVwbGFjZVwiLFxuICAgICAgICBcImZpbmRcIixcbiAgICAgICAgXCJmaW5kSW5kZXhcIixcbiAgICAgICAgXCJzcGxpY2VcIixcbiAgICAgICAgXCJyZXZlcnNlXCIsXG4gICAgICAgIFwic29ydFwiXG4gICAgXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0dWJBcnJheS5wcm90b3R5cGUsIGtleSwge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogQXJyYXkucHJvdG90eXBlW2tleV1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG52YXIgT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uKG5hbWUsIGVuaGFuY2VyLCBhcnJheSwgb3duZWQpIHtcbiAgICAgICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICAgICAgICB0aGlzLm93bmVkID0gb3duZWQ7XG4gICAgICAgIHRoaXMudmFsdWVzID0gW107XG4gICAgICAgIHRoaXMubGFzdEtub3duTGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5pbnRlcmNlcHRvcnMgPSBudWxsO1xuICAgICAgICB0aGlzLmNoYW5nZUxpc3RlbmVycyA9IG51bGw7XG4gICAgICAgIHRoaXMuYXRvbSA9IG5ldyBCYXNlQXRvbShuYW1lIHx8IFwiT2JzZXJ2YWJsZUFycmF5QFwiICsgZ2V0TmV4dElkKCkpO1xuICAgICAgICB0aGlzLmVuaGFuY2VyID0gZnVuY3Rpb24gKG5ld1YsIG9sZFYpIHsgcmV0dXJuIGVuaGFuY2VyKG5ld1YsIG9sZFYsIG5hbWUgKyBcIlsuLl1cIik7IH07XG4gICAgfVxuICAgIE9ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uLnByb3RvdHlwZS5kZWhhbmNlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVoYW5jZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlaGFuY2VyKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24ucHJvdG90eXBlLmRlaGFuY2VWYWx1ZXMgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgIGlmICh0aGlzLmRlaGFuY2VyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzLm1hcCh0aGlzLmRlaGFuY2VyKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9O1xuICAgIE9ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uLnByb3RvdHlwZS5pbnRlcmNlcHQgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gcmVnaXN0ZXJJbnRlcmNlcHRvcih0aGlzLCBoYW5kbGVyKTtcbiAgICB9O1xuICAgIE9ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uLnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24gKGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpIHtcbiAgICAgICAgaWYgKGZpcmVJbW1lZGlhdGVseSA9PT0gdm9pZCAwKSB7IGZpcmVJbW1lZGlhdGVseSA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChmaXJlSW1tZWRpYXRlbHkpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyKHtcbiAgICAgICAgICAgICAgICBvYmplY3Q6IHRoaXMuYXJyYXksXG4gICAgICAgICAgICAgICAgdHlwZTogXCJzcGxpY2VcIixcbiAgICAgICAgICAgICAgICBpbmRleDogMCxcbiAgICAgICAgICAgICAgICBhZGRlZDogdGhpcy52YWx1ZXMuc2xpY2UoKSxcbiAgICAgICAgICAgICAgICBhZGRlZENvdW50OiB0aGlzLnZhbHVlcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgcmVtb3ZlZDogW10sXG4gICAgICAgICAgICAgICAgcmVtb3ZlZENvdW50OiAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVnaXN0ZXJMaXN0ZW5lcih0aGlzLCBsaXN0ZW5lcik7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbi5wcm90b3R5cGUuZ2V0QXJyYXlMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYXRvbS5yZXBvcnRPYnNlcnZlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXMubGVuZ3RoO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24ucHJvdG90eXBlLnNldEFycmF5TGVuZ3RoID0gZnVuY3Rpb24gKG5ld0xlbmd0aCkge1xuICAgICAgICBpZiAodHlwZW9mIG5ld0xlbmd0aCAhPT0gXCJudW1iZXJcIiB8fCBuZXdMZW5ndGggPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW21vYnguYXJyYXldIE91dCBvZiByYW5nZTogXCIgKyBuZXdMZW5ndGgpO1xuICAgICAgICB2YXIgY3VycmVudExlbmd0aCA9IHRoaXMudmFsdWVzLmxlbmd0aDtcbiAgICAgICAgaWYgKG5ld0xlbmd0aCA9PT0gY3VycmVudExlbmd0aClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZWxzZSBpZiAobmV3TGVuZ3RoID4gY3VycmVudExlbmd0aCkge1xuICAgICAgICAgICAgdmFyIG5ld0l0ZW1zID0gbmV3IEFycmF5KG5ld0xlbmd0aCAtIGN1cnJlbnRMZW5ndGgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdMZW5ndGggLSBjdXJyZW50TGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgbmV3SXRlbXNbaV0gPSB1bmRlZmluZWQ7IC8vIE5vIEFycmF5LmZpbGwgZXZlcnl3aGVyZS4uLlxuICAgICAgICAgICAgdGhpcy5zcGxpY2VXaXRoQXJyYXkoY3VycmVudExlbmd0aCwgMCwgbmV3SXRlbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuc3BsaWNlV2l0aEFycmF5KG5ld0xlbmd0aCwgY3VycmVudExlbmd0aCAtIG5ld0xlbmd0aCk7XG4gICAgfTtcbiAgICAvLyBhZGRzIC8gcmVtb3ZlcyB0aGUgbmVjZXNzYXJ5IG51bWVyaWMgcHJvcGVydGllcyB0byB0aGlzIG9iamVjdFxuICAgIE9ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uLnByb3RvdHlwZS51cGRhdGVBcnJheUxlbmd0aCA9IGZ1bmN0aW9uIChvbGRMZW5ndGgsIGRlbHRhKSB7XG4gICAgICAgIGlmIChvbGRMZW5ndGggIT09IHRoaXMubGFzdEtub3duTGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW21vYnhdIE1vZGlmaWNhdGlvbiBleGNlcHRpb246IHRoZSBpbnRlcm5hbCBzdHJ1Y3R1cmUgb2YgYW4gb2JzZXJ2YWJsZSBhcnJheSB3YXMgY2hhbmdlZC4gRGlkIHlvdSB1c2UgcGVlaygpIHRvIGNoYW5nZSBpdD9cIik7XG4gICAgICAgIHRoaXMubGFzdEtub3duTGVuZ3RoICs9IGRlbHRhO1xuICAgICAgICBpZiAoZGVsdGEgPiAwICYmIG9sZExlbmd0aCArIGRlbHRhICsgMSA+IE9CU0VSVkFCTEVfQVJSQVlfQlVGRkVSX1NJWkUpXG4gICAgICAgICAgICByZXNlcnZlQXJyYXlCdWZmZXIob2xkTGVuZ3RoICsgZGVsdGEgKyAxKTtcbiAgICB9O1xuICAgIE9ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uLnByb3RvdHlwZS5zcGxpY2VXaXRoQXJyYXkgPSBmdW5jdGlvbiAoaW5kZXgsIGRlbGV0ZUNvdW50LCBuZXdJdGVtcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBjaGVja0lmU3RhdGVNb2RpZmljYXRpb25zQXJlQWxsb3dlZCh0aGlzLmF0b20pO1xuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy52YWx1ZXMubGVuZ3RoO1xuICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgZWxzZSBpZiAoaW5kZXggPiBsZW5ndGgpXG4gICAgICAgICAgICBpbmRleCA9IGxlbmd0aDtcbiAgICAgICAgZWxzZSBpZiAoaW5kZXggPCAwKVxuICAgICAgICAgICAgaW5kZXggPSBNYXRoLm1heCgwLCBsZW5ndGggKyBpbmRleCk7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgZGVsZXRlQ291bnQgPSBsZW5ndGggLSBpbmRleDtcbiAgICAgICAgZWxzZSBpZiAoZGVsZXRlQ291bnQgPT09IHVuZGVmaW5lZCB8fCBkZWxldGVDb3VudCA9PT0gbnVsbClcbiAgICAgICAgICAgIGRlbGV0ZUNvdW50ID0gMDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlQ291bnQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihkZWxldGVDb3VudCwgbGVuZ3RoIC0gaW5kZXgpKTtcbiAgICAgICAgaWYgKG5ld0l0ZW1zID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBuZXdJdGVtcyA9IFtdO1xuICAgICAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKHRoaXMpKSB7XG4gICAgICAgICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgICAgICAgICBvYmplY3Q6IHRoaXMuYXJyYXksXG4gICAgICAgICAgICAgICAgdHlwZTogXCJzcGxpY2VcIixcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgcmVtb3ZlZENvdW50OiBkZWxldGVDb3VudCxcbiAgICAgICAgICAgICAgICBhZGRlZDogbmV3SXRlbXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFjaGFuZ2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEVNUFRZX0FSUkFZO1xuICAgICAgICAgICAgZGVsZXRlQ291bnQgPSBjaGFuZ2UucmVtb3ZlZENvdW50O1xuICAgICAgICAgICAgbmV3SXRlbXMgPSBjaGFuZ2UuYWRkZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbmV3SXRlbXMgPSBuZXdJdGVtcy5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIF90aGlzLmVuaGFuY2VyKHYsIHVuZGVmaW5lZCk7IH0pO1xuICAgICAgICB2YXIgbGVuZ3RoRGVsdGEgPSBuZXdJdGVtcy5sZW5ndGggLSBkZWxldGVDb3VudDtcbiAgICAgICAgdGhpcy51cGRhdGVBcnJheUxlbmd0aChsZW5ndGgsIGxlbmd0aERlbHRhKTsgLy8gY3JlYXRlIG9yIHJlbW92ZSBuZXcgZW50cmllc1xuICAgICAgICB2YXIgcmVzID0gdGhpcy5zcGxpY2VJdGVtc0ludG9WYWx1ZXMoaW5kZXgsIGRlbGV0ZUNvdW50LCBuZXdJdGVtcyk7XG4gICAgICAgIGlmIChkZWxldGVDb3VudCAhPT0gMCB8fCBuZXdJdGVtcy5sZW5ndGggIT09IDApXG4gICAgICAgICAgICB0aGlzLm5vdGlmeUFycmF5U3BsaWNlKGluZGV4LCBuZXdJdGVtcywgcmVzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVoYW5jZVZhbHVlcyhyZXMpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24ucHJvdG90eXBlLnNwbGljZUl0ZW1zSW50b1ZhbHVlcyA9IGZ1bmN0aW9uIChpbmRleCwgZGVsZXRlQ291bnQsIG5ld0l0ZW1zKSB7XG4gICAgICAgIGlmIChuZXdJdGVtcy5sZW5ndGggPCBNQVhfU1BMSUNFX1NJWkUpIHtcbiAgICAgICAgICAgIHJldHVybiAoX2EgPSB0aGlzLnZhbHVlcykuc3BsaWNlLmFwcGx5KF9hLCBbaW5kZXgsIGRlbGV0ZUNvdW50XS5jb25jYXQobmV3SXRlbXMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXMgPSB0aGlzLnZhbHVlcy5zbGljZShpbmRleCwgaW5kZXggKyBkZWxldGVDb3VudCk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcyA9IHRoaXMudmFsdWVzXG4gICAgICAgICAgICAgICAgLnNsaWNlKDAsIGluZGV4KVxuICAgICAgICAgICAgICAgIC5jb25jYXQobmV3SXRlbXMsIHRoaXMudmFsdWVzLnNsaWNlKGluZGV4ICsgZGVsZXRlQ291bnQpKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24ucHJvdG90eXBlLm5vdGlmeUFycmF5Q2hpbGRVcGRhdGUgPSBmdW5jdGlvbiAoaW5kZXgsIG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICB2YXIgbm90aWZ5U3B5ID0gIXRoaXMub3duZWQgJiYgaXNTcHlFbmFibGVkKCk7XG4gICAgICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG4gICAgICAgIHZhciBjaGFuZ2UgPSBub3RpZnkgfHwgbm90aWZ5U3B5XG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBvYmplY3Q6IHRoaXMuYXJyYXksXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1cGRhdGVcIixcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICAgICAgICAgIG9sZFZhbHVlOiBvbGRWYWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBpZiAobm90aWZ5U3B5KVxuICAgICAgICAgICAgc3B5UmVwb3J0U3RhcnQoY2hhbmdlKTtcbiAgICAgICAgdGhpcy5hdG9tLnJlcG9ydENoYW5nZWQoKTtcbiAgICAgICAgaWYgKG5vdGlmeSlcbiAgICAgICAgICAgIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBjaGFuZ2UpO1xuICAgICAgICBpZiAobm90aWZ5U3B5KVxuICAgICAgICAgICAgc3B5UmVwb3J0RW5kKCk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbi5wcm90b3R5cGUubm90aWZ5QXJyYXlTcGxpY2UgPSBmdW5jdGlvbiAoaW5kZXgsIGFkZGVkLCByZW1vdmVkKSB7XG4gICAgICAgIHZhciBub3RpZnlTcHkgPSAhdGhpcy5vd25lZCAmJiBpc1NweUVuYWJsZWQoKTtcbiAgICAgICAgdmFyIG5vdGlmeSA9IGhhc0xpc3RlbmVycyh0aGlzKTtcbiAgICAgICAgdmFyIGNoYW5nZSA9IG5vdGlmeSB8fCBub3RpZnlTcHlcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIG9iamVjdDogdGhpcy5hcnJheSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcInNwbGljZVwiLFxuICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICByZW1vdmVkOiByZW1vdmVkLFxuICAgICAgICAgICAgICAgIGFkZGVkOiBhZGRlZCxcbiAgICAgICAgICAgICAgICByZW1vdmVkQ291bnQ6IHJlbW92ZWQubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGFkZGVkQ291bnQ6IGFkZGVkLmxlbmd0aFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBpZiAobm90aWZ5U3B5KVxuICAgICAgICAgICAgc3B5UmVwb3J0U3RhcnQoY2hhbmdlKTtcbiAgICAgICAgdGhpcy5hdG9tLnJlcG9ydENoYW5nZWQoKTtcbiAgICAgICAgLy8gY29uZm9ybTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvb2JzZXJ2ZVxuICAgICAgICBpZiAobm90aWZ5KVxuICAgICAgICAgICAgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIGNoYW5nZSk7XG4gICAgICAgIGlmIChub3RpZnlTcHkpXG4gICAgICAgICAgICBzcHlSZXBvcnRFbmQoKTtcbiAgICB9O1xuICAgIHJldHVybiBPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbjtcbn0oKSk7XG52YXIgT2JzZXJ2YWJsZUFycmF5ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoT2JzZXJ2YWJsZUFycmF5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE9ic2VydmFibGVBcnJheShpbml0aWFsVmFsdWVzLCBlbmhhbmNlciwgbmFtZSwgb3duZWQpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09IHZvaWQgMCkgeyBuYW1lID0gXCJPYnNlcnZhYmxlQXJyYXlAXCIgKyBnZXROZXh0SWQoKTsgfVxuICAgICAgICBpZiAob3duZWQgPT09IHZvaWQgMCkgeyBvd25lZCA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIHZhciBhZG0gPSBuZXcgT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24obmFtZSwgZW5oYW5jZXIsIF90aGlzLCBvd25lZCk7XG4gICAgICAgIGFkZEhpZGRlbkZpbmFsUHJvcChfdGhpcywgXCIkbW9ieFwiLCBhZG0pO1xuICAgICAgICBpZiAoaW5pdGlhbFZhbHVlcyAmJiBpbml0aWFsVmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgX3RoaXMuc3BsaWNlV2l0aEFycmF5KDAsIDAsIGluaXRpYWxWYWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzYWZhcmlQcm90b3R5cGVTZXR0ZXJJbmhlcml0YW5jZUJ1Zykge1xuICAgICAgICAgICAgLy8gU2VlbXMgdGhhdCBTYWZhcmkgd29uJ3QgdXNlIG51bWVyaWMgcHJvdG90eXBlIHNldHRlciB1bnRpbGwgYW55ICogbnVtZXJpYyBwcm9wZXJ0eSBpc1xuICAgICAgICAgICAgLy8gZGVmaW5lZCBvbiB0aGUgaW5zdGFuY2UuIEFmdGVyIHRoYXQgaXQgd29ya3MgZmluZSwgZXZlbiBpZiB0aGlzIHByb3BlcnR5IGlzIGRlbGV0ZWQuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYWRtLmFycmF5LCBcIjBcIiwgRU5UUllfMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYnNlcnZhYmxlQXJyYXkucHJvdG90eXBlLmludGVyY2VwdCA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRtb2J4LmludGVyY2VwdChoYW5kbGVyKTtcbiAgICB9O1xuICAgIE9ic2VydmFibGVBcnJheS5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uIChsaXN0ZW5lciwgZmlyZUltbWVkaWF0ZWx5KSB7XG4gICAgICAgIGlmIChmaXJlSW1tZWRpYXRlbHkgPT09IHZvaWQgMCkgeyBmaXJlSW1tZWRpYXRlbHkgPSBmYWxzZTsgfVxuICAgICAgICByZXR1cm4gdGhpcy4kbW9ieC5vYnNlcnZlKGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZUFycmF5LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BsaWNlKDApO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZUFycmF5LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcnJheXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFycmF5c1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJG1vYnguYXRvbS5yZXBvcnRPYnNlcnZlZCgpO1xuICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseSh0aGlzLnBlZWsoKSwgYXJyYXlzLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gKGlzT2JzZXJ2YWJsZUFycmF5KGEpID8gYS5wZWVrKCkgOiBhKTsgfSkpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZUFycmF5LnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gKG5ld0l0ZW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRtb2J4LnNwbGljZVdpdGhBcnJheSgwLCB0aGlzLiRtb2J4LnZhbHVlcy5sZW5ndGgsIG5ld0l0ZW1zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoaXMgYXJyYXkgYmFjayB0byBhIChzaGFsbG93KSBqYXZhc2NyaXB0IHN0cnVjdHVyZS5cbiAgICAgKiBGb3IgYSBkZWVwIGNsb25lIHVzZSBtb2J4LnRvSlNcbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlQXJyYXkucHJvdG90eXBlLnRvSlMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNsaWNlKCk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlQXJyYXkucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVXNlZCBieSBKU09OLnN0cmluZ2lmeVxuICAgICAgICByZXR1cm4gdGhpcy50b0pTKCk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlQXJyYXkucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJG1vYnguYXRvbS5yZXBvcnRPYnNlcnZlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy4kbW9ieC5kZWhhbmNlVmFsdWVzKHRoaXMuJG1vYngudmFsdWVzKTtcbiAgICB9O1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZpbmRcbiAgICBPYnNlcnZhYmxlQXJyYXkucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAocHJlZGljYXRlLCB0aGlzQXJnLCBmcm9tSW5kZXgpIHtcbiAgICAgICAgaWYgKGZyb21JbmRleCA9PT0gdm9pZCAwKSB7IGZyb21JbmRleCA9IDA7IH1cbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuZmluZEluZGV4LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBpZHggPT09IC0xID8gdW5kZWZpbmVkIDogdGhpcy5nZXQoaWR4KTtcbiAgICB9O1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZpbmRJbmRleFxuICAgIE9ic2VydmFibGVBcnJheS5wcm90b3R5cGUuZmluZEluZGV4ID0gZnVuY3Rpb24gKHByZWRpY2F0ZSwgdGhpc0FyZywgZnJvbUluZGV4KSB7XG4gICAgICAgIGlmIChmcm9tSW5kZXggPT09IHZvaWQgMCkgeyBmcm9tSW5kZXggPSAwOyB9XG4gICAgICAgIHZhciBpdGVtcyA9IHRoaXMucGVlaygpLCBsID0gaXRlbXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gZnJvbUluZGV4OyBpIDwgbDsgaSsrKVxuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKHRoaXNBcmcsIGl0ZW1zW2ldLCBpLCB0aGlzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gICAgLypcbiAgICAgKiBmdW5jdGlvbnMgdGhhdCBkbyBhbHRlciB0aGUgaW50ZXJuYWwgc3RydWN0dXJlIG9mIHRoZSBhcnJheSwgKGJhc2VkIG9uIGxpYi5lczYuZC50cylcbiAgICAgKiBzaW5jZSB0aGVzZSBmdW5jdGlvbnMgYWx0ZXIgdGhlIGlubmVyIHN0cnVjdHVyZSBvZiB0aGUgYXJyYXksIHRoZSBoYXZlIHNpZGUgZWZmZWN0cy5cbiAgICAgKiBCZWNhdXNlIHRoZSBoYXZlIHNpZGUgZWZmZWN0cywgdGhleSBzaG91bGQgbm90IGJlIHVzZWQgaW4gY29tcHV0ZWQgZnVuY3Rpb24sXG4gICAgICogYW5kIGZvciB0aGF0IHJlYXNvbiB0aGUgZG8gbm90IGNhbGwgZGVwZW5kZW5jeVN0YXRlLm5vdGlmeU9ic2VydmVkXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZUFycmF5LnByb3RvdHlwZS5zcGxpY2UgPSBmdW5jdGlvbiAoaW5kZXgsIGRlbGV0ZUNvdW50KSB7XG4gICAgICAgIHZhciBuZXdJdGVtcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgbmV3SXRlbXNbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRtb2J4LnNwbGljZVdpdGhBcnJheShpbmRleCk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJG1vYnguc3BsaWNlV2l0aEFycmF5KGluZGV4LCBkZWxldGVDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuJG1vYnguc3BsaWNlV2l0aEFycmF5KGluZGV4LCBkZWxldGVDb3VudCwgbmV3SXRlbXMpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZUFycmF5LnByb3RvdHlwZS5zcGxpY2VXaXRoQXJyYXkgPSBmdW5jdGlvbiAoaW5kZXgsIGRlbGV0ZUNvdW50LCBuZXdJdGVtcykge1xuICAgICAgICByZXR1cm4gdGhpcy4kbW9ieC5zcGxpY2VXaXRoQXJyYXkoaW5kZXgsIGRlbGV0ZUNvdW50LCBuZXdJdGVtcyk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlQXJyYXkucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpdGVtcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgaXRlbXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWRtID0gdGhpcy4kbW9ieDtcbiAgICAgICAgYWRtLnNwbGljZVdpdGhBcnJheShhZG0udmFsdWVzLmxlbmd0aCwgMCwgaXRlbXMpO1xuICAgICAgICByZXR1cm4gYWRtLnZhbHVlcy5sZW5ndGg7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlQXJyYXkucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BsaWNlKE1hdGgubWF4KHRoaXMuJG1vYngudmFsdWVzLmxlbmd0aCAtIDEsIDApLCAxKVswXTtcbiAgICB9O1xuICAgIE9ic2VydmFibGVBcnJheS5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwbGljZSgwLCAxKVswXTtcbiAgICB9O1xuICAgIE9ic2VydmFibGVBcnJheS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGl0ZW1zID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBpdGVtc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhZG0gPSB0aGlzLiRtb2J4O1xuICAgICAgICBhZG0uc3BsaWNlV2l0aEFycmF5KDAsIDAsIGl0ZW1zKTtcbiAgICAgICAgcmV0dXJuIGFkbS52YWx1ZXMubGVuZ3RoO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZUFycmF5LnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyByZXZlcnNlIGJ5IGRlZmF1bHQgbXV0YXRlcyBpbiBwbGFjZSBiZWZvcmUgcmV0dXJuaW5nIHRoZSByZXN1bHRcbiAgICAgICAgLy8gd2hpY2ggbWFrZXMgaXQgYm90aCBhICdkZXJpdmF0aW9uJyBhbmQgYSAnbXV0YXRpb24nLlxuICAgICAgICAvLyBzbyB3ZSBkZXZpYXRlIGZyb20gdGhlIGRlZmF1bHQgYW5kIGp1c3QgbWFrZSBpdCBhbiBkZXJ2aXRhdGlvblxuICAgICAgICB2YXIgY2xvbmUgPSB0aGlzLnNsaWNlKCk7XG4gICAgICAgIHJldHVybiBjbG9uZS5yZXZlcnNlLmFwcGx5KGNsb25lLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZUFycmF5LnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24gKGNvbXBhcmVGbikge1xuICAgICAgICAvLyBzb3J0IGJ5IGRlZmF1bHQgbXV0YXRlcyBpbiBwbGFjZSBiZWZvcmUgcmV0dXJuaW5nIHRoZSByZXN1bHRcbiAgICAgICAgLy8gd2hpY2ggZ29lcyBhZ2FpbnN0IGFsbCBnb29kIHByYWN0aWNlcy4gTGV0J3Mgbm90IGNoYW5nZSB0aGUgYXJyYXkgaW4gcGxhY2UhXG4gICAgICAgIHZhciBjbG9uZSA9IHRoaXMuc2xpY2UoKTtcbiAgICAgICAgcmV0dXJuIGNsb25lLnNvcnQuYXBwbHkoY2xvbmUsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlQXJyYXkucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgaWR4ID0gdGhpcy4kbW9ieC5kZWhhbmNlVmFsdWVzKHRoaXMuJG1vYngudmFsdWVzKS5pbmRleE9mKHZhbHVlKTtcbiAgICAgICAgaWYgKGlkeCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZUFycmF5LnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24gKGZyb21JbmRleCwgdG9JbmRleCkge1xuICAgICAgICBmdW5jdGlvbiBjaGVja0luZGV4KGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW21vYnguYXJyYXldIEluZGV4IG91dCBvZiBib3VuZHM6IFwiICsgaW5kZXggKyBcIiBpcyBuZWdhdGl2ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsZW5ndGggPSB0aGlzLiRtb2J4LnZhbHVlcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW21vYnguYXJyYXldIEluZGV4IG91dCBvZiBib3VuZHM6IFwiICsgaW5kZXggKyBcIiBpcyBub3Qgc21hbGxlciB0aGFuIFwiICsgbGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGVja0luZGV4LmNhbGwodGhpcywgZnJvbUluZGV4KTtcbiAgICAgICAgY2hlY2tJbmRleC5jYWxsKHRoaXMsIHRvSW5kZXgpO1xuICAgICAgICBpZiAoZnJvbUluZGV4ID09PSB0b0luZGV4KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9sZEl0ZW1zID0gdGhpcy4kbW9ieC52YWx1ZXM7XG4gICAgICAgIHZhciBuZXdJdGVtcztcbiAgICAgICAgaWYgKGZyb21JbmRleCA8IHRvSW5kZXgpIHtcbiAgICAgICAgICAgIG5ld0l0ZW1zID0gb2xkSXRlbXMuc2xpY2UoMCwgZnJvbUluZGV4KS5jb25jYXQob2xkSXRlbXMuc2xpY2UoZnJvbUluZGV4ICsgMSwgdG9JbmRleCArIDEpLCBbXG4gICAgICAgICAgICAgICAgb2xkSXRlbXNbZnJvbUluZGV4XVxuICAgICAgICAgICAgXSwgb2xkSXRlbXMuc2xpY2UodG9JbmRleCArIDEpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRvSW5kZXggPCBmcm9tSW5kZXhcbiAgICAgICAgICAgIG5ld0l0ZW1zID0gb2xkSXRlbXMuc2xpY2UoMCwgdG9JbmRleCkuY29uY2F0KFtcbiAgICAgICAgICAgICAgICBvbGRJdGVtc1tmcm9tSW5kZXhdXG4gICAgICAgICAgICBdLCBvbGRJdGVtcy5zbGljZSh0b0luZGV4LCBmcm9tSW5kZXgpLCBvbGRJdGVtcy5zbGljZShmcm9tSW5kZXggKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXBsYWNlKG5ld0l0ZW1zKTtcbiAgICB9O1xuICAgIC8vIFNlZSAjNzM0LCBpbiBjYXNlIHByb3BlcnR5IGFjY2Vzc29ycyBhcmUgdW5yZWxpYWJsZS4uLlxuICAgIE9ic2VydmFibGVBcnJheS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBpbXBsID0gdGhpcy4kbW9ieDtcbiAgICAgICAgaWYgKGltcGwpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA8IGltcGwudmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGltcGwuYXRvbS5yZXBvcnRPYnNlcnZlZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbXBsLmRlaGFuY2VWYWx1ZShpbXBsLnZhbHVlc1tpbmRleF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW21vYnguYXJyYXldIEF0dGVtcHQgdG8gcmVhZCBhbiBhcnJheSBpbmRleCAoXCIgKyBpbmRleCArIFwiKSB0aGF0IGlzIG91dCBvZiBib3VuZHMgKFwiICsgaW1wbFxuICAgICAgICAgICAgICAgIC52YWx1ZXNcbiAgICAgICAgICAgICAgICAubGVuZ3RoICsgXCIpLiBQbGVhc2UgY2hlY2sgbGVuZ3RoIGZpcnN0LiBPdXQgb2YgYm91bmQgaW5kaWNlcyB3aWxsIG5vdCBiZSB0cmFja2VkIGJ5IE1vYlhcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIC8vIFNlZSAjNzM0LCBpbiBjYXNlIHByb3BlcnR5IGFjY2Vzc29ycyBhcmUgdW5yZWxpYWJsZS4uLlxuICAgIE9ic2VydmFibGVBcnJheS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGluZGV4LCBuZXdWYWx1ZSkge1xuICAgICAgICB2YXIgYWRtID0gdGhpcy4kbW9ieDtcbiAgICAgICAgdmFyIHZhbHVlcyA9IGFkbS52YWx1ZXM7XG4gICAgICAgIGlmIChpbmRleCA8IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBhdCBpbmRleCBpbiByYW5nZVxuICAgICAgICAgICAgY2hlY2tJZlN0YXRlTW9kaWZpY2F0aW9uc0FyZUFsbG93ZWQoYWRtLmF0b20pO1xuICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gdmFsdWVzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChoYXNJbnRlcmNlcHRvcnMoYWRtKSkge1xuICAgICAgICAgICAgICAgIHZhciBjaGFuZ2UgPSBpbnRlcmNlcHRDaGFuZ2UoYWRtLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidXBkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoYW5nZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gY2hhbmdlLm5ld1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3VmFsdWUgPSBhZG0uZW5oYW5jZXIobmV3VmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VkID0gbmV3VmFsdWUgIT09IG9sZFZhbHVlO1xuICAgICAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXNbaW5kZXhdID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgYWRtLm5vdGlmeUFycmF5Q2hpbGRVcGRhdGUoaW5kZXgsIG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5kZXggPT09IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIGFkZCBhIG5ldyBpdGVtXG4gICAgICAgICAgICBhZG0uc3BsaWNlV2l0aEFycmF5KGluZGV4LCAwLCBbbmV3VmFsdWVdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG91dCBvZiBib3VuZHNcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlttb2J4LmFycmF5XSBJbmRleCBvdXQgb2YgYm91bmRzLCBcIiArIGluZGV4ICsgXCIgaXMgbGFyZ2VyIHRoYW4gXCIgKyB2YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE9ic2VydmFibGVBcnJheTtcbn0oU3R1YkFycmF5KSk7XG5kZWNsYXJlSXRlcmF0b3IoT2JzZXJ2YWJsZUFycmF5LnByb3RvdHlwZSwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhcnJheUFzSXRlcmF0b3IodGhpcy5zbGljZSgpKTtcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KE9ic2VydmFibGVBcnJheS5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRtb2J4LmdldEFycmF5TGVuZ3RoKCk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChuZXdMZW5ndGgpIHtcbiAgICAgICAgdGhpcy4kbW9ieC5zZXRBcnJheUxlbmd0aChuZXdMZW5ndGgpO1xuICAgIH1cbn0pO1xuW1xuICAgIFwiZXZlcnlcIixcbiAgICBcImZpbHRlclwiLFxuICAgIFwiZm9yRWFjaFwiLFxuICAgIFwiaW5kZXhPZlwiLFxuICAgIFwiam9pblwiLFxuICAgIFwibGFzdEluZGV4T2ZcIixcbiAgICBcIm1hcFwiLFxuICAgIFwicmVkdWNlXCIsXG4gICAgXCJyZWR1Y2VSaWdodFwiLFxuICAgIFwic2xpY2VcIixcbiAgICBcInNvbWVcIixcbiAgICBcInRvU3RyaW5nXCIsXG4gICAgXCJ0b0xvY2FsZVN0cmluZ1wiXG5dLmZvckVhY2goZnVuY3Rpb24gKGZ1bmNOYW1lKSB7XG4gICAgdmFyIGJhc2VGdW5jID0gQXJyYXkucHJvdG90eXBlW2Z1bmNOYW1lXTtcbiAgICBpbnZhcmlhbnQodHlwZW9mIGJhc2VGdW5jID09PSBcImZ1bmN0aW9uXCIsIFwiQmFzZSBmdW5jdGlvbiBub3QgZGVmaW5lZCBvbiBBcnJheSBwcm90b3R5cGU6ICdcIiArIGZ1bmNOYW1lICsgXCInXCIpO1xuICAgIGFkZEhpZGRlblByb3AoT2JzZXJ2YWJsZUFycmF5LnByb3RvdHlwZSwgZnVuY05hbWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VGdW5jLmFwcGx5KHRoaXMucGVlaygpLCBhcmd1bWVudHMpO1xuICAgIH0pO1xufSk7XG4vKipcbiAqIFdlIGRvbid0IHdhbnQgdGhvc2UgdG8gc2hvdyB1cCBpbiBgZm9yIChjb25zdCBrZXkgaW4gYXIpYCAuLi5cbiAqL1xubWFrZU5vbkVudW1lcmFibGUoT2JzZXJ2YWJsZUFycmF5LnByb3RvdHlwZSwgW1xuICAgIFwiY29uc3RydWN0b3JcIixcbiAgICBcImludGVyY2VwdFwiLFxuICAgIFwib2JzZXJ2ZVwiLFxuICAgIFwiY2xlYXJcIixcbiAgICBcImNvbmNhdFwiLFxuICAgIFwiZ2V0XCIsXG4gICAgXCJyZXBsYWNlXCIsXG4gICAgXCJ0b0pTXCIsXG4gICAgXCJ0b0pTT05cIixcbiAgICBcInBlZWtcIixcbiAgICBcImZpbmRcIixcbiAgICBcImZpbmRJbmRleFwiLFxuICAgIFwic3BsaWNlXCIsXG4gICAgXCJzcGxpY2VXaXRoQXJyYXlcIixcbiAgICBcInB1c2hcIixcbiAgICBcInBvcFwiLFxuICAgIFwic2V0XCIsXG4gICAgXCJzaGlmdFwiLFxuICAgIFwidW5zaGlmdFwiLFxuICAgIFwicmV2ZXJzZVwiLFxuICAgIFwic29ydFwiLFxuICAgIFwicmVtb3ZlXCIsXG4gICAgXCJtb3ZlXCIsXG4gICAgXCJ0b1N0cmluZ1wiLFxuICAgIFwidG9Mb2NhbGVTdHJpbmdcIlxuXSk7XG4vLyBTZWUgIzM2NFxudmFyIEVOVFJZXzAgPSBjcmVhdGVBcnJheUVudHJ5RGVzY3JpcHRvcigwKTtcbmZ1bmN0aW9uIGNyZWF0ZUFycmF5RW50cnlEZXNjcmlwdG9yKGluZGV4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gVE9ETzogQ2hlY2sgYHRoaXNgPywgc2VlICM3NTI/XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoaW5kZXgpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zZXQoaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVBcnJheUJ1ZmZlckl0ZW0oaW5kZXgpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JzZXJ2YWJsZUFycmF5LnByb3RvdHlwZSwgXCJcIiArIGluZGV4LCBjcmVhdGVBcnJheUVudHJ5RGVzY3JpcHRvcihpbmRleCkpO1xufVxuZnVuY3Rpb24gcmVzZXJ2ZUFycmF5QnVmZmVyKG1heCkge1xuICAgIGZvciAodmFyIGluZGV4ID0gT0JTRVJWQUJMRV9BUlJBWV9CVUZGRVJfU0laRTsgaW5kZXggPCBtYXg7IGluZGV4KyspXG4gICAgICAgIGNyZWF0ZUFycmF5QnVmZmVySXRlbShpbmRleCk7XG4gICAgT0JTRVJWQUJMRV9BUlJBWV9CVUZGRVJfU0laRSA9IG1heDtcbn1cbnJlc2VydmVBcnJheUJ1ZmZlcigxMDAwKTtcbnZhciBpc09ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uID0gY3JlYXRlSW5zdGFuY2VvZlByZWRpY2F0ZShcIk9ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uXCIsIE9ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uKTtcbmZ1bmN0aW9uIGlzT2JzZXJ2YWJsZUFycmF5KHRoaW5nKSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHRoaW5nKSAmJiBpc09ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uKHRoaW5nLiRtb2J4KTtcbn1cblxudmFyIFVOQ0hBTkdFRCA9IHt9O1xudmFyIE9ic2VydmFibGVWYWx1ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE9ic2VydmFibGVWYWx1ZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPYnNlcnZhYmxlVmFsdWUodmFsdWUsIGVuaGFuY2VyLCBuYW1lLCBub3RpZnlTcHkpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09IHZvaWQgMCkgeyBuYW1lID0gXCJPYnNlcnZhYmxlVmFsdWVAXCIgKyBnZXROZXh0SWQoKTsgfVxuICAgICAgICBpZiAobm90aWZ5U3B5ID09PSB2b2lkIDApIHsgbm90aWZ5U3B5ID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5lbmhhbmNlciA9IGVuaGFuY2VyO1xuICAgICAgICBfdGhpcy5oYXNVbnJlcG9ydGVkQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmRlaGFuY2VyID0gdW5kZWZpbmVkO1xuICAgICAgICBfdGhpcy52YWx1ZSA9IGVuaGFuY2VyKHZhbHVlLCB1bmRlZmluZWQsIG5hbWUpO1xuICAgICAgICBpZiAobm90aWZ5U3B5ICYmIGlzU3B5RW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAvLyBvbmx5IG5vdGlmeSBzcHkgaWYgdGhpcyBpcyBhIHN0YW5kLWFsb25lIG9ic2VydmFibGVcbiAgICAgICAgICAgIHNweVJlcG9ydCh7IHR5cGU6IFwiY3JlYXRlXCIsIG9iamVjdDogX3RoaXMsIG5ld1ZhbHVlOiBfdGhpcy52YWx1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9ic2VydmFibGVWYWx1ZS5wcm90b3R5cGUuZGVoYW5jZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmRlaGFuY2VyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWhhbmNlcih2YWx1ZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIE9ic2VydmFibGVWYWx1ZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIG5ld1ZhbHVlID0gdGhpcy5wcmVwYXJlTmV3VmFsdWUobmV3VmFsdWUpO1xuICAgICAgICBpZiAobmV3VmFsdWUgIT09IFVOQ0hBTkdFRCkge1xuICAgICAgICAgICAgdmFyIG5vdGlmeVNweSA9IGlzU3B5RW5hYmxlZCgpO1xuICAgICAgICAgICAgaWYgKG5vdGlmeVNweSkge1xuICAgICAgICAgICAgICAgIHNweVJlcG9ydFN0YXJ0KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ1cGRhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlOiBvbGRWYWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXROZXdWYWx1ZShuZXdWYWx1ZSk7XG4gICAgICAgICAgICBpZiAobm90aWZ5U3B5KVxuICAgICAgICAgICAgICAgIHNweVJlcG9ydEVuZCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlVmFsdWUucHJvdG90eXBlLnByZXBhcmVOZXdWYWx1ZSA9IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICBjaGVja0lmU3RhdGVNb2RpZmljYXRpb25zQXJlQWxsb3dlZCh0aGlzKTtcbiAgICAgICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZSh0aGlzLCB7XG4gICAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidXBkYXRlXCIsXG4gICAgICAgICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghY2hhbmdlKVxuICAgICAgICAgICAgICAgIHJldHVybiBVTkNIQU5HRUQ7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGNoYW5nZS5uZXdWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhcHBseSBtb2RpZmllclxuICAgICAgICBuZXdWYWx1ZSA9IHRoaXMuZW5oYW5jZXIobmV3VmFsdWUsIHRoaXMudmFsdWUsIHRoaXMubmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlICE9PSBuZXdWYWx1ZSA/IG5ld1ZhbHVlIDogVU5DSEFOR0VEO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVZhbHVlLnByb3RvdHlwZS5zZXROZXdWYWx1ZSA9IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICB0aGlzLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIHRoaXMucmVwb3J0Q2hhbmdlZCgpO1xuICAgICAgICBpZiAoaGFzTGlzdGVuZXJzKHRoaXMpKSB7XG4gICAgICAgICAgICBub3RpZnlMaXN0ZW5lcnModGhpcywge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidXBkYXRlXCIsXG4gICAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZTogb2xkVmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlVmFsdWUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5kZWhhbmNlVmFsdWUodGhpcy52YWx1ZSk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlVmFsdWUucHJvdG90eXBlLmludGVyY2VwdCA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiByZWdpc3RlckludGVyY2VwdG9yKHRoaXMsIGhhbmRsZXIpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVZhbHVlLnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24gKGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpIHtcbiAgICAgICAgaWYgKGZpcmVJbW1lZGlhdGVseSlcbiAgICAgICAgICAgIGxpc3RlbmVyKHtcbiAgICAgICAgICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1cGRhdGVcIixcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZTogdGhpcy52YWx1ZSxcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZTogdW5kZWZpbmVkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlZ2lzdGVyTGlzdGVuZXIodGhpcywgbGlzdGVuZXIpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVZhbHVlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldCgpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVZhbHVlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZSArIFwiW1wiICsgdGhpcy52YWx1ZSArIFwiXVwiO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVZhbHVlLnByb3RvdHlwZS52YWx1ZU9mID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdG9QcmltaXRpdmUodGhpcy5nZXQoKSk7XG4gICAgfTtcbiAgICByZXR1cm4gT2JzZXJ2YWJsZVZhbHVlO1xufShCYXNlQXRvbSkpO1xuT2JzZXJ2YWJsZVZhbHVlLnByb3RvdHlwZVtwcmltaXRpdmVTeW1ib2woKV0gPSBPYnNlcnZhYmxlVmFsdWUucHJvdG90eXBlLnZhbHVlT2Y7XG52YXIgaXNPYnNlcnZhYmxlVmFsdWUgPSBjcmVhdGVJbnN0YW5jZW9mUHJlZGljYXRlKFwiT2JzZXJ2YWJsZVZhbHVlXCIsIE9ic2VydmFibGVWYWx1ZSk7XG5cbnZhciBtZXNzYWdlcyA9IHtcbiAgICBtMDAxOiBcIkl0IGlzIG5vdCBhbGxvd2VkIHRvIGFzc2lnbiBuZXcgdmFsdWVzIHRvIEBhY3Rpb24gZmllbGRzXCIsXG4gICAgbTAwMjogXCJgcnVuSW5BY3Rpb25gIGV4cGVjdHMgYSBmdW5jdGlvblwiLFxuICAgIG0wMDM6IFwiYHJ1bkluQWN0aW9uYCBleHBlY3RzIGEgZnVuY3Rpb24gd2l0aG91dCBhcmd1bWVudHNcIixcbiAgICBtMDA0OiBcImF1dG9ydW4gZXhwZWN0cyBhIGZ1bmN0aW9uXCIsXG4gICAgbTAwNTogXCJXYXJuaW5nOiBhdHRlbXB0ZWQgdG8gcGFzcyBhbiBhY3Rpb24gdG8gYXV0b3J1bi4gQWN0aW9ucyBhcmUgdW50cmFja2VkIGFuZCB3aWxsIG5vdCB0cmlnZ2VyIG9uIHN0YXRlIGNoYW5nZXMuIFVzZSBgcmVhY3Rpb25gIG9yIHdyYXAgb25seSB5b3VyIHN0YXRlIG1vZGlmaWNhdGlvbiBjb2RlIGluIGFuIGFjdGlvbi5cIixcbiAgICBtMDA2OiBcIldhcm5pbmc6IGF0dGVtcHRlZCB0byBwYXNzIGFuIGFjdGlvbiB0byBhdXRvcnVuQXN5bmMuIEFjdGlvbnMgYXJlIHVudHJhY2tlZCBhbmQgd2lsbCBub3QgdHJpZ2dlciBvbiBzdGF0ZSBjaGFuZ2VzLiBVc2UgYHJlYWN0aW9uYCBvciB3cmFwIG9ubHkgeW91ciBzdGF0ZSBtb2RpZmljYXRpb24gY29kZSBpbiBhbiBhY3Rpb24uXCIsXG4gICAgbTAwNzogXCJyZWFjdGlvbiBvbmx5IGFjY2VwdHMgMiBvciAzIGFyZ3VtZW50cy4gSWYgbWlncmF0aW5nIGZyb20gTW9iWCAyLCBwbGVhc2UgcHJvdmlkZSBhbiBvcHRpb25zIG9iamVjdFwiLFxuICAgIG0wMDg6IFwid3JhcHBpbmcgcmVhY3Rpb24gZXhwcmVzc2lvbiBpbiBgYXNSZWZlcmVuY2VgIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQsIHVzZSBvcHRpb25zIG9iamVjdCBpbnN0ZWFkXCIsXG4gICAgbTAwOTogXCJAY29tcHV0ZWQgY2FuIG9ubHkgYmUgdXNlZCBvbiBnZXR0ZXIgZnVuY3Rpb25zLCBsaWtlOiAnQGNvbXB1dGVkIGdldCBteVByb3BzKCkgeyByZXR1cm4gLi4uOyB9Jy4gSXQgbG9va3MgbGlrZSBpdCB3YXMgdXNlZCBvbiBhIHByb3BlcnR5LlwiLFxuICAgIG0wMTA6IFwiQGNvbXB1dGVkIGNhbiBvbmx5IGJlIHVzZWQgb24gZ2V0dGVyIGZ1bmN0aW9ucywgbGlrZTogJ0Bjb21wdXRlZCBnZXQgbXlQcm9wcygpIHsgcmV0dXJuIC4uLjsgfSdcIixcbiAgICBtMDExOiBcIkZpcnN0IGFyZ3VtZW50IHRvIGBjb21wdXRlZGAgc2hvdWxkIGJlIGFuIGV4cHJlc3Npb24uIElmIHVzaW5nIGNvbXB1dGVkIGFzIGRlY29yYXRvciwgZG9uJ3QgcGFzcyBpdCBhcmd1bWVudHNcIixcbiAgICBtMDEyOiBcImNvbXB1dGVkIHRha2VzIG9uZSBvciB0d28gYXJndW1lbnRzIGlmIHVzZWQgYXMgZnVuY3Rpb25cIixcbiAgICBtMDEzOiBcIlttb2J4LmV4cHJdICdleHByJyBzaG91bGQgb25seSBiZSB1c2VkIGluc2lkZSBvdGhlciByZWFjdGl2ZSBmdW5jdGlvbnMuXCIsXG4gICAgbTAxNDogXCJleHRlbmRPYnNlcnZhYmxlIGV4cGVjdGVkIDIgb3IgbW9yZSBhcmd1bWVudHNcIixcbiAgICBtMDE1OiBcImV4dGVuZE9ic2VydmFibGUgZXhwZWN0cyBhbiBvYmplY3QgYXMgZmlyc3QgYXJndW1lbnRcIixcbiAgICBtMDE2OiBcImV4dGVuZE9ic2VydmFibGUgc2hvdWxkIG5vdCBiZSB1c2VkIG9uIG1hcHMsIHVzZSBtYXAubWVyZ2UgaW5zdGVhZFwiLFxuICAgIG0wMTc6IFwiYWxsIGFyZ3VtZW50cyBvZiBleHRlbmRPYnNlcnZhYmxlIHNob3VsZCBiZSBvYmplY3RzXCIsXG4gICAgbTAxODogXCJleHRlbmRpbmcgYW4gb2JqZWN0IHdpdGggYW5vdGhlciBvYnNlcnZhYmxlIChvYmplY3QpIGlzIG5vdCBzdXBwb3J0ZWQuIFBsZWFzZSBjb25zdHJ1Y3QgYW4gZXhwbGljaXQgcHJvcGVydHltYXAsIHVzaW5nIGB0b0pTYCBpZiBuZWVkLiBTZWUgaXNzdWUgIzU0MFwiLFxuICAgIG0wMTk6IFwiW21vYnguaXNPYnNlcnZhYmxlXSBpc09ic2VydmFibGUob2JqZWN0LCBwcm9wZXJ0eU5hbWUpIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIGFycmF5cyBhbmQgbWFwcy4gVXNlIG1hcC5oYXMgb3IgYXJyYXkubGVuZ3RoIGluc3RlYWQuXCIsXG4gICAgbTAyMDogXCJtb2RpZmllcnMgY2FuIG9ubHkgYmUgdXNlZCBmb3IgaW5kaXZpZHVhbCBvYmplY3QgcHJvcGVydGllc1wiLFxuICAgIG0wMjE6IFwib2JzZXJ2YWJsZSBleHBlY3RzIHplcm8gb3Igb25lIGFyZ3VtZW50c1wiLFxuICAgIG0wMjI6IFwiQG9ic2VydmFibGUgY2FuIG5vdCBiZSB1c2VkIG9uIGdldHRlcnMsIHVzZSBAY29tcHV0ZWQgaW5zdGVhZFwiLFxuICAgIG0wMjQ6IFwid2h5UnVuKCkgY2FuIG9ubHkgYmUgdXNlZCBpZiBhIGRlcml2YXRpb24gaXMgYWN0aXZlLCBvciBieSBwYXNzaW5nIGFuIGNvbXB1dGVkIHZhbHVlIC8gcmVhY3Rpb24gZXhwbGljaXRseS4gSWYgeW91IGludm9rZWQgd2h5UnVuIGZyb20gaW5zaWRlIGEgY29tcHV0YXRpb247IHRoZSBjb21wdXRhdGlvbiBpcyBjdXJyZW50bHkgc3VzcGVuZGVkIGJ1dCByZS1ldmFsdWF0aW5nIGJlY2F1c2Ugc29tZWJvZHkgcmVxdWVzdGVkIGl0cyB2YWx1ZS5cIixcbiAgICBtMDI1OiBcIndoeVJ1biBjYW4gb25seSBiZSB1c2VkIG9uIHJlYWN0aW9ucyBhbmQgY29tcHV0ZWQgdmFsdWVzXCIsXG4gICAgbTAyNjogXCJgYWN0aW9uYCBjYW4gb25seSBiZSBpbnZva2VkIG9uIGZ1bmN0aW9uc1wiLFxuICAgIG0wMjg6IFwiSXQgaXMgbm90IGFsbG93ZWQgdG8gc2V0IGB1c2VTdHJpY3RgIHdoZW4gYSBkZXJpdmF0aW9uIGlzIHJ1bm5pbmdcIixcbiAgICBtMDI5OiBcIklOVEVSTkFMIEVSUk9SIG9ubHkgb25CZWNvbWVVbm9ic2VydmVkIHNob3VsZG4ndCBiZSBjYWxsZWQgdHdpY2UgaW4gYSByb3dcIixcbiAgICBtMDMwYTogXCJTaW5jZSBzdHJpY3QtbW9kZSBpcyBlbmFibGVkLCBjaGFuZ2luZyBvYnNlcnZlZCBvYnNlcnZhYmxlIHZhbHVlcyBvdXRzaWRlIGFjdGlvbnMgaXMgbm90IGFsbG93ZWQuIFBsZWFzZSB3cmFwIHRoZSBjb2RlIGluIGFuIGBhY3Rpb25gIGlmIHRoaXMgY2hhbmdlIGlzIGludGVuZGVkLiBUcmllZCB0byBtb2RpZnk6IFwiLFxuICAgIG0wMzBiOiBcIlNpZGUgZWZmZWN0cyBsaWtlIGNoYW5naW5nIHN0YXRlIGFyZSBub3QgYWxsb3dlZCBhdCB0aGlzIHBvaW50LiBBcmUgeW91IHRyeWluZyB0byBtb2RpZnkgc3RhdGUgZnJvbSwgZm9yIGV4YW1wbGUsIHRoZSByZW5kZXIgZnVuY3Rpb24gb2YgYSBSZWFjdCBjb21wb25lbnQ/IFRyaWVkIHRvIG1vZGlmeTogXCIsXG4gICAgbTAzMTogXCJDb21wdXRlZCB2YWx1ZXMgYXJlIG5vdCBhbGxvd2VkIHRvIGNhdXNlIHNpZGUgZWZmZWN0cyBieSBjaGFuZ2luZyBvYnNlcnZhYmxlcyB0aGF0IGFyZSBhbHJlYWR5IGJlaW5nIG9ic2VydmVkLiBUcmllZCB0byBtb2RpZnk6IFwiLFxuICAgIG0wMzI6IFwiKiBUaGlzIGNvbXB1dGF0aW9uIGlzIHN1c3BlbmRlZCAobm90IGluIHVzZSBieSBhbnkgcmVhY3Rpb24pIGFuZCB3b24ndCBydW4gYXV0b21hdGljYWxseS5cXG5cdERpZG4ndCBleHBlY3QgdGhpcyBjb21wdXRhdGlvbiB0byBiZSBzdXNwZW5kZWQgYXQgdGhpcyBwb2ludD9cXG5cdCAgMS4gTWFrZSBzdXJlIHRoaXMgY29tcHV0YXRpb24gaXMgdXNlZCBieSBhIHJlYWN0aW9uIChyZWFjdGlvbiwgYXV0b3J1biwgb2JzZXJ2ZXIpLlxcblx0ICAyLiBDaGVjayB3aGV0aGVyIHlvdSBhcmUgdXNpbmcgdGhpcyBjb21wdXRhdGlvbiBzeW5jaHJvbm91c2x5IChpbiB0aGUgc2FtZSBzdGFjayBhcyB0aGV5IHJlYWN0aW9uIHRoYXQgbmVlZHMgaXQpLlwiLFxuICAgIG0wMzM6IFwiYG9ic2VydmVgIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgZmlyZSBpbW1lZGlhdGVseSBwcm9wZXJ0eSBmb3Igb2JzZXJ2YWJsZSBtYXBzLlwiLFxuICAgIG0wMzQ6IFwiYG1vYngubWFwYCBpcyBkZXByZWNhdGVkLCB1c2UgYG5ldyBPYnNlcnZhYmxlTWFwYCBvciBgbW9ieC5vYnNlcnZhYmxlLm1hcGAgaW5zdGVhZFwiLFxuICAgIG0wMzU6IFwiQ2Fubm90IG1ha2UgdGhlIGRlc2lnbmF0ZWQgb2JqZWN0IG9ic2VydmFibGU7IGl0IGlzIG5vdCBleHRlbnNpYmxlXCIsXG4gICAgbTAzNjogXCJJdCBpcyBub3QgcG9zc2libGUgdG8gZ2V0IGluZGV4IGF0b21zIGZyb20gYXJyYXlzXCIsXG4gICAgbTAzNzogXCJIaSB0aGVyZSEgSSdtIHNvcnJ5IHlvdSBoYXZlIGp1c3QgcnVuIGludG8gYW4gZXhjZXB0aW9uLlxcbklmIHlvdXIgZGVidWdnZXIgZW5kcyB1cCBoZXJlLCBrbm93IHRoYXQgc29tZSByZWFjdGlvbiAobGlrZSB0aGUgcmVuZGVyKCkgb2YgYW4gb2JzZXJ2ZXIgY29tcG9uZW50LCBhdXRvcnVuIG9yIHJlYWN0aW9uKVxcbnRocmV3IGFuIGV4Y2VwdGlvbiBhbmQgdGhhdCBtb2J4IGNhdWdodCBpdCwgdG8gYXZvaWQgdGhhdCBpdCBicmluZ3MgdGhlIHJlc3Qgb2YgeW91ciBhcHBsaWNhdGlvbiBkb3duLlxcblRoZSBvcmlnaW5hbCBjYXVzZSBvZiB0aGUgZXhjZXB0aW9uICh0aGUgY29kZSB0aGF0IGNhdXNlZCB0aGlzIHJlYWN0aW9uIHRvIHJ1biAoYWdhaW4pKSwgaXMgc3RpbGwgaW4gdGhlIHN0YWNrLlxcblxcbkhvd2V2ZXIsIG1vcmUgaW50ZXJlc3RpbmcgaXMgdGhlIGFjdHVhbCBzdGFjayB0cmFjZSBvZiB0aGUgZXJyb3IgaXRzZWxmLlxcbkhvcGVmdWxseSB0aGUgZXJyb3IgaXMgYW4gaW5zdGFuY2VvZiBFcnJvciwgYmVjYXVzZSBpbiB0aGF0IGNhc2UgeW91IGNhbiBpbnNwZWN0IHRoZSBvcmlnaW5hbCBzdGFjayBvZiB0aGUgZXJyb3IgZnJvbSB3aGVyZSBpdCB3YXMgdGhyb3duLlxcblNlZSBgZXJyb3Iuc3RhY2tgIHByb3BlcnR5LCBvciBwcmVzcyB0aGUgdmVyeSBzdWJ0bGUgXFxcIiguLi4pXFxcIiBsaW5rIHlvdSBzZWUgbmVhciB0aGUgY29uc29sZS5lcnJvciBtZXNzYWdlIHRoYXQgcHJvYmFibHkgYnJvdWdodCB5b3UgaGVyZS5cXG5UaGF0IHN0YWNrIGlzIG1vcmUgaW50ZXJlc3RpbmcgdGhhbiB0aGUgc3RhY2sgb2YgdGhpcyBjb25zb2xlLmVycm9yIGl0c2VsZi5cXG5cXG5JZiB0aGUgZXhjZXB0aW9uIHlvdSBzZWUgaXMgYW4gZXhjZXB0aW9uIHlvdSBjcmVhdGVkIHlvdXJzZWxmLCBtYWtlIHN1cmUgdG8gdXNlIGB0aHJvdyBuZXcgRXJyb3IoXFxcIk9vcHNcXFwiKWAgaW5zdGVhZCBvZiBgdGhyb3cgXFxcIk9vcHNcXFwiYCxcXG5iZWNhdXNlIHRoZSBqYXZhc2NyaXB0IGVudmlyb25tZW50IHdpbGwgb25seSBwcmVzZXJ2ZSB0aGUgb3JpZ2luYWwgc3RhY2sgdHJhY2UgaW4gdGhlIGZpcnN0IGZvcm0uXFxuXFxuWW91IGNhbiBhbHNvIG1ha2Ugc3VyZSB0aGUgZGVidWdnZXIgcGF1c2VzIHRoZSBuZXh0IHRpbWUgdGhpcyB2ZXJ5IHNhbWUgZXhjZXB0aW9uIGlzIHRocm93biBieSBlbmFibGluZyBcXFwiUGF1c2Ugb24gY2F1Z2h0IGV4Y2VwdGlvblxcXCIuXFxuKE5vdGUgdGhhdCBpdCBtaWdodCBwYXVzZSBvbiBtYW55IG90aGVyLCB1bnJlbGF0ZWQgZXhjZXB0aW9uIGFzIHdlbGwpLlxcblxcbklmIHRoYXQgYWxsIGRvZXNuJ3QgaGVscCB5b3Ugb3V0LCBmZWVsIGZyZWUgdG8gb3BlbiBhbiBpc3N1ZSBodHRwczovL2dpdGh1Yi5jb20vbW9ieGpzL21vYngvaXNzdWVzIVxcblwiLFxuICAgIG0wMzg6IFwiTWlzc2luZyBpdGVtcyBpbiB0aGlzIGxpc3Q/XFxuICAgIDEuIENoZWNrIHdoZXRoZXIgYWxsIHVzZWQgdmFsdWVzIGFyZSBwcm9wZXJseSBtYXJrZWQgYXMgb2JzZXJ2YWJsZSAodXNlIGlzT2JzZXJ2YWJsZSB0byB2ZXJpZnkpXFxuICAgIDIuIE1ha2Ugc3VyZSB5b3UgZGlkbid0IGRlcmVmZXJlbmNlIHZhbHVlcyB0b28gZWFybHkuIE1vYlggb2JzZXJ2ZXMgcHJvcHMsIG5vdCBwcmltaXRpdmVzLiBFLmc6IHVzZSAncGVyc29uLm5hbWUnIGluc3RlYWQgb2YgJ25hbWUnIGluIHlvdXIgY29tcHV0YXRpb24uXFxuXCJcbn07XG5mdW5jdGlvbiBnZXRNZXNzYWdlKGlkKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2VzW2lkXTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQWN0aW9uKGFjdGlvbk5hbWUsIGZuKSB7XG4gICAgaW52YXJpYW50KHR5cGVvZiBmbiA9PT0gXCJmdW5jdGlvblwiLCBnZXRNZXNzYWdlKFwibTAyNlwiKSk7XG4gICAgaW52YXJpYW50KHR5cGVvZiBhY3Rpb25OYW1lID09PSBcInN0cmluZ1wiICYmIGFjdGlvbk5hbWUubGVuZ3RoID4gMCwgXCJhY3Rpb25zIHNob3VsZCBoYXZlIHZhbGlkIG5hbWVzLCBnb3Q6ICdcIiArIGFjdGlvbk5hbWUgKyBcIidcIik7XG4gICAgdmFyIHJlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGV4ZWN1dGVBY3Rpb24oYWN0aW9uTmFtZSwgZm4sIHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICByZXMub3JpZ2luYWxGbiA9IGZuO1xuICAgIHJlcy5pc01vYnhBY3Rpb24gPSB0cnVlO1xuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBleGVjdXRlQWN0aW9uKGFjdGlvbk5hbWUsIGZuLCBzY29wZSwgYXJncykge1xuICAgIHZhciBydW5JbmZvID0gc3RhcnRBY3Rpb24oYWN0aW9uTmFtZSwgZm4sIHNjb3BlLCBhcmdzKTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkoc2NvcGUsIGFyZ3MpO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgZW5kQWN0aW9uKHJ1bkluZm8pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN0YXJ0QWN0aW9uKGFjdGlvbk5hbWUsIGZuLCBzY29wZSwgYXJncykge1xuICAgIHZhciBub3RpZnlTcHkgPSBpc1NweUVuYWJsZWQoKSAmJiAhIWFjdGlvbk5hbWU7XG4gICAgdmFyIHN0YXJ0VGltZSA9IDA7XG4gICAgaWYgKG5vdGlmeVNweSkge1xuICAgICAgICBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgbCA9IChhcmdzICYmIGFyZ3MubGVuZ3RoKSB8fCAwO1xuICAgICAgICB2YXIgZmxhdHRlbmRBcmdzID0gbmV3IEFycmF5KGwpO1xuICAgICAgICBpZiAobCA+IDApXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKylcbiAgICAgICAgICAgICAgICBmbGF0dGVuZEFyZ3NbaV0gPSBhcmdzW2ldO1xuICAgICAgICBzcHlSZXBvcnRTdGFydCh7XG4gICAgICAgICAgICB0eXBlOiBcImFjdGlvblwiLFxuICAgICAgICAgICAgbmFtZTogYWN0aW9uTmFtZSxcbiAgICAgICAgICAgIGZuOiBmbixcbiAgICAgICAgICAgIG9iamVjdDogc2NvcGUsXG4gICAgICAgICAgICBhcmd1bWVudHM6IGZsYXR0ZW5kQXJnc1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIHByZXZEZXJpdmF0aW9uID0gdW50cmFja2VkU3RhcnQoKTtcbiAgICBzdGFydEJhdGNoKCk7XG4gICAgdmFyIHByZXZBbGxvd1N0YXRlQ2hhbmdlcyA9IGFsbG93U3RhdGVDaGFuZ2VzU3RhcnQodHJ1ZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJldkRlcml2YXRpb246IHByZXZEZXJpdmF0aW9uLFxuICAgICAgICBwcmV2QWxsb3dTdGF0ZUNoYW5nZXM6IHByZXZBbGxvd1N0YXRlQ2hhbmdlcyxcbiAgICAgICAgbm90aWZ5U3B5OiBub3RpZnlTcHksXG4gICAgICAgIHN0YXJ0VGltZTogc3RhcnRUaW1lXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGVuZEFjdGlvbihydW5JbmZvKSB7XG4gICAgYWxsb3dTdGF0ZUNoYW5nZXNFbmQocnVuSW5mby5wcmV2QWxsb3dTdGF0ZUNoYW5nZXMpO1xuICAgIGVuZEJhdGNoKCk7XG4gICAgdW50cmFja2VkRW5kKHJ1bkluZm8ucHJldkRlcml2YXRpb24pO1xuICAgIGlmIChydW5JbmZvLm5vdGlmeVNweSlcbiAgICAgICAgc3B5UmVwb3J0RW5kKHsgdGltZTogRGF0ZS5ub3coKSAtIHJ1bkluZm8uc3RhcnRUaW1lIH0pO1xufVxuZnVuY3Rpb24gdXNlU3RyaWN0KHN0cmljdCkge1xuICAgIGludmFyaWFudChnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24gPT09IG51bGwsIGdldE1lc3NhZ2UoXCJtMDI4XCIpKTtcbiAgICBnbG9iYWxTdGF0ZS5zdHJpY3RNb2RlID0gc3RyaWN0O1xuICAgIGdsb2JhbFN0YXRlLmFsbG93U3RhdGVDaGFuZ2VzID0gIXN0cmljdDtcbn1cbmZ1bmN0aW9uIGlzU3RyaWN0TW9kZUVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIGdsb2JhbFN0YXRlLnN0cmljdE1vZGU7XG59XG5mdW5jdGlvbiBhbGxvd1N0YXRlQ2hhbmdlcyhhbGxvd1N0YXRlQ2hhbmdlcywgZnVuYykge1xuICAgIC8vIFRPRE86IGRlcHJlY2F0ZSAvIHJlZmFjdG9yIHRoaXMgZnVuY3Rpb24gaW4gbmV4dCBtYWpvclxuICAgIC8vIEN1cnJlbnRseSBvbmx5IHVzZWQgYnkgYEBvYnNlcnZlcmBcbiAgICAvLyBQcm9wb3NlZCBjaGFuZ2U6IHJlbW92ZSBmaXJzdCBwYXJhbSwgcmVuYW1lIHRvIGBmb3JiaWRTdGF0ZUNoYW5nZXNgLFxuICAgIC8vIHJlcXVpcmUgZXJyb3IgY2FsbGJhY2sgaW5zdGVhZCBvZiB0aGUgaGFyZGNvZGVkIGVycm9yIG1lc3NhZ2Ugbm93IHVzZWRcbiAgICAvLyBVc2UgYGluQWN0aW9uYCBpbnN0ZWFkIG9mIGFsbG93U3RhdGVDaGFuZ2VzIGluIGRlcml2YXRpb24udHMgdG8gY2hlY2sgc3RyaWN0TW9kZVxuICAgIHZhciBwcmV2ID0gYWxsb3dTdGF0ZUNoYW5nZXNTdGFydChhbGxvd1N0YXRlQ2hhbmdlcyk7XG4gICAgdmFyIHJlcztcbiAgICB0cnkge1xuICAgICAgICByZXMgPSBmdW5jKCk7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBhbGxvd1N0YXRlQ2hhbmdlc0VuZChwcmV2KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGFsbG93U3RhdGVDaGFuZ2VzU3RhcnQoYWxsb3dTdGF0ZUNoYW5nZXMpIHtcbiAgICB2YXIgcHJldiA9IGdsb2JhbFN0YXRlLmFsbG93U3RhdGVDaGFuZ2VzO1xuICAgIGdsb2JhbFN0YXRlLmFsbG93U3RhdGVDaGFuZ2VzID0gYWxsb3dTdGF0ZUNoYW5nZXM7XG4gICAgcmV0dXJuIHByZXY7XG59XG5mdW5jdGlvbiBhbGxvd1N0YXRlQ2hhbmdlc0VuZChwcmV2KSB7XG4gICAgZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZUNoYW5nZXMgPSBwcmV2O1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBkZWNvcmF0b3IsIHRoYXQgbm9ybWFsaXplcyB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlblxuICogVHlwZVNjcmlwdCBhbmQgQmFiZWwuIE1haW5seSBjYXVzZWQgYnkgdGhlIGZhY3QgdGhhdCBsZWdhY3ktZGVjb3JhdG9yIGNhbm5vdCBhc3NpZ25cbiAqIHZhbHVlcyBkdXJpbmcgaW5zdGFuY2UgY3JlYXRpb24gdG8gcHJvcGVydGllcyB0aGF0IGhhdmUgYSBnZXR0ZXIgc2V0dGVyLlxuICpcbiAqIC0gU2lnaCAtXG4gKlxuICogQWxzbyB0YWtlcyBjYXJlIG9mIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gQGRlY29yYXRvciBmaWVsZCBhbmQgQGRlY29yYXRvcihhcmdzKSBmaWVsZCwgYW5kIGRpZmZlcmVudCBmb3JtcyBvZiB2YWx1ZXMuXG4gKiBGb3IgcGVyZm9ybWFuY2UgKGNwdSBhbmQgbWVtKSByZWFzb25zIHRoZSBwcm9wZXJ0aWVzIGFyZSBhbHdheXMgZGVmaW5lZCBvbiB0aGUgcHJvdG90eXBlIChhdCBsZWFzdCBpbml0aWFsbHkpLlxuICogVGhpcyBtZWFucyB0aGF0IHRoZXNlIHByb3BlcnRpZXMgZGVzcGl0ZSBiZWluZyBlbnVtZXJhYmxlIG1pZ2h0IG5vdCBzaG93IHVwIGluIE9iamVjdC5rZXlzKCkgKGJ1dCB0aGV5IHdpbGwgc2hvdyB1cCBpbiBmb3IuLi5pbiBsb29wcykuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNsYXNzUHJvcGVydHlEZWNvcmF0b3IoXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBpbnZva2VkIG9uY2UsIHdoZW4gdGhlIHByb3BlcnR5IGlzIGFkZGVkIHRvIGEgbmV3IGluc3RhbmNlLlxuICAgICAqIFdoZW4gdGhpcyBoYXBwZW5zIGlzIG5vdCBzdHJpY3RseSBkZXRlcm1pbmVkIGR1ZSB0byBkaWZmZXJlbmNlcyBpbiBUUyBhbmQgQmFiZWw6XG4gICAgICogVHlwZXNjcmlwdDogVXN1YWxseSB3aGVuIGNvbnN0cnVjdGluZyB0aGUgbmV3IGluc3RhbmNlXG4gICAgICogQmFiZWwsIHNvbWV0aW1lcyBUeXBlc2NyaXB0OiBkdXJpbmcgdGhlIGZpcnN0IGdldCAvIHNldFxuICAgICAqIEJvdGg6IHdoZW4gY2FsbGluZyBgcnVuTGF6eUluaXRpYWxpemVycyhpbnN0YW5jZSlgXG4gICAgICovXG4gICAgb25Jbml0aWFsaXplLCBnZXQsIHNldCwgZW51bWVyYWJsZSwgXG4gICAgLyoqXG4gICAgICogQ2FuIHRoaXMgZGVjb3JhdG9yIGludm9rZWQgd2l0aCBhcmd1bWVudHM/IGUuZy4gQGRlY29yYXRvcihhcmdzKVxuICAgICAqL1xuICAgIGFsbG93Q3VzdG9tQXJndW1lbnRzKSB7XG4gICAgZnVuY3Rpb24gY2xhc3NQcm9wZXJ0eURlY29yYXRvcih0YXJnZXQsIGtleSwgZGVzY3JpcHRvciwgY3VzdG9tQXJncywgYXJnTGVuKSB7XG4gICAgICAgIGlmIChhcmdMZW4gPT09IHZvaWQgMCkgeyBhcmdMZW4gPSAwOyB9XG4gICAgICAgIGludmFyaWFudChhbGxvd0N1c3RvbUFyZ3VtZW50cyB8fCBxdWFja3NMaWtlQURlY29yYXRvcihhcmd1bWVudHMpLCBcIlRoaXMgZnVuY3Rpb24gaXMgYSBkZWNvcmF0b3IsIGJ1dCBpdCB3YXNuJ3QgaW52b2tlZCBsaWtlIGEgZGVjb3JhdG9yXCIpO1xuICAgICAgICBpZiAoIWRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIC8vIHR5cGVzY3JpcHQgKGV4Y2VwdCBmb3IgZ2V0dGVyIC8gc2V0dGVycylcbiAgICAgICAgICAgIHZhciBuZXdEZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGVudW1lcmFibGUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX19tb2J4SW5pdGlhbGl6ZWRQcm9wcyB8fCB0aGlzLl9fbW9ieEluaXRpYWxpemVkUHJvcHNba2V5XSAhPT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzY3JpcHRJbml0aWFsaXplUHJvcGVydHkodGhpcywga2V5LCB1bmRlZmluZWQsIG9uSW5pdGlhbGl6ZSwgY3VzdG9tQXJncywgZGVzY3JpcHRvcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXQuY2FsbCh0aGlzLCBrZXkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX19tb2J4SW5pdGlhbGl6ZWRQcm9wcyB8fCB0aGlzLl9fbW9ieEluaXRpYWxpemVkUHJvcHNba2V5XSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXNjcmlwdEluaXRpYWxpemVQcm9wZXJ0eSh0aGlzLCBrZXksIHYsIG9uSW5pdGlhbGl6ZSwgY3VzdG9tQXJncywgZGVzY3JpcHRvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQuY2FsbCh0aGlzLCBrZXksIHYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMyB8fCAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNSAmJiBhcmdMZW4gPCAzKSkge1xuICAgICAgICAgICAgICAgIC8vIFR5cGVzY3JpcHQgdGFyZ2V0IGlzIEVTMywgc28gaXQgd29uJ3QgZGVmaW5lIHByb3BlcnR5IGZvciB1c1xuICAgICAgICAgICAgICAgIC8vIG9yIHVzaW5nIFJlZmxlY3QuZGVjb3JhdGUgcG9seWZpbGwsIHdoaWNoIHdpbGwgcmV0dXJuIG5vIGRlc2NyaXB0b3JcbiAgICAgICAgICAgICAgICAvLyAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb2J4anMvbW9ieC9pc3N1ZXMvMzMzKVxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgbmV3RGVzY3JpcHRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3RGVzY3JpcHRvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGJhYmVsIGFuZCB0eXBlc2NyaXB0IGdldHRlciAvIHNldHRlciBwcm9wc1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh0YXJnZXQsIFwiX19tb2J4TGF6eUluaXRpYWxpemVyc1wiKSkge1xuICAgICAgICAgICAgICAgIGFkZEhpZGRlblByb3AodGFyZ2V0LCBcIl9fbW9ieExhenlJbml0aWFsaXplcnNcIiwgKHRhcmdldC5fX21vYnhMYXp5SW5pdGlhbGl6ZXJzICYmIHRhcmdldC5fX21vYnhMYXp5SW5pdGlhbGl6ZXJzLnNsaWNlKCkpIHx8IFtdIC8vIHN1cHBvcnQgaW5oZXJpdGFuY2VcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlXzEgPSBkZXNjcmlwdG9yLnZhbHVlLCBpbml0aWFsaXplcl8xID0gZGVzY3JpcHRvci5pbml0aWFsaXplcjtcbiAgICAgICAgICAgIHRhcmdldC5fX21vYnhMYXp5SW5pdGlhbGl6ZXJzLnB1c2goZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgb25Jbml0aWFsaXplKGluc3RhbmNlLCBrZXksIGluaXRpYWxpemVyXzEgPyBpbml0aWFsaXplcl8xLmNhbGwoaW5zdGFuY2UpIDogdmFsdWVfMSwgY3VzdG9tQXJncywgZGVzY3JpcHRvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZW51bWVyYWJsZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fbW9ieERpZFJ1bkxhenlJbml0aWFsaXplcnMgIT09IHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBydW5MYXp5SW5pdGlhbGl6ZXJzKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0LmNhbGwodGhpcywga2V5KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX19tb2J4RGlkUnVuTGF6eUluaXRpYWxpemVycyAhPT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bkxhenlJbml0aWFsaXplcnModGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHNldC5jYWxsKHRoaXMsIGtleSwgdik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWxsb3dDdXN0b21Bcmd1bWVudHMpIHtcbiAgICAgICAgLyoqIElmIGN1c3RvbSBhcmd1bWVudHMgYXJlIGFsbG93ZWQsIHdlIHNob3VsZCByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBkZWNvcmF0b3IgKi9cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8qKiBEaXJlY3QgaW52b2NhdGlvbjogQGRlY29yYXRvciBibGEgKi9cbiAgICAgICAgICAgIGlmIChxdWFja3NMaWtlQURlY29yYXRvcihhcmd1bWVudHMpKVxuICAgICAgICAgICAgICAgIHJldHVybiBjbGFzc1Byb3BlcnR5RGVjb3JhdG9yLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAvKiogSW5kaXJlY3QgaW52b2NhdGlvbjogQGRlY29yYXRvcihhcmdzKSBibGEgKi9cbiAgICAgICAgICAgIHZhciBvdXRlckFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICB2YXIgYXJnTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xhc3NQcm9wZXJ0eURlY29yYXRvcih0YXJnZXQsIGtleSwgZGVzY3JpcHRvciwgb3V0ZXJBcmdzLCBhcmdMZW4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzUHJvcGVydHlEZWNvcmF0b3I7XG59XG5mdW5jdGlvbiB0eXBlc2NyaXB0SW5pdGlhbGl6ZVByb3BlcnR5KGluc3RhbmNlLCBrZXksIHYsIG9uSW5pdGlhbGl6ZSwgY3VzdG9tQXJncywgYmFzZURlc2NyaXB0b3IpIHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5KGluc3RhbmNlLCBcIl9fbW9ieEluaXRpYWxpemVkUHJvcHNcIikpXG4gICAgICAgIGFkZEhpZGRlblByb3AoaW5zdGFuY2UsIFwiX19tb2J4SW5pdGlhbGl6ZWRQcm9wc1wiLCB7fSk7XG4gICAgaW5zdGFuY2UuX19tb2J4SW5pdGlhbGl6ZWRQcm9wc1trZXldID0gdHJ1ZTtcbiAgICBvbkluaXRpYWxpemUoaW5zdGFuY2UsIGtleSwgdiwgY3VzdG9tQXJncywgYmFzZURlc2NyaXB0b3IpO1xufVxuZnVuY3Rpb24gcnVuTGF6eUluaXRpYWxpemVycyhpbnN0YW5jZSkge1xuICAgIGlmIChpbnN0YW5jZS5fX21vYnhEaWRSdW5MYXp5SW5pdGlhbGl6ZXJzID09PSB0cnVlKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKGluc3RhbmNlLl9fbW9ieExhenlJbml0aWFsaXplcnMpIHtcbiAgICAgICAgYWRkSGlkZGVuUHJvcChpbnN0YW5jZSwgXCJfX21vYnhEaWRSdW5MYXp5SW5pdGlhbGl6ZXJzXCIsIHRydWUpO1xuICAgICAgICBpbnN0YW5jZS5fX21vYnhEaWRSdW5MYXp5SW5pdGlhbGl6ZXJzICYmXG4gICAgICAgICAgICBpbnN0YW5jZS5fX21vYnhMYXp5SW5pdGlhbGl6ZXJzLmZvckVhY2goZnVuY3Rpb24gKGluaXRpYWxpemVyKSB7IHJldHVybiBpbml0aWFsaXplcihpbnN0YW5jZSk7IH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHF1YWNrc0xpa2VBRGVjb3JhdG9yKGFyZ3MpIHtcbiAgICByZXR1cm4gKGFyZ3MubGVuZ3RoID09PSAyIHx8IGFyZ3MubGVuZ3RoID09PSAzKSAmJiB0eXBlb2YgYXJnc1sxXSA9PT0gXCJzdHJpbmdcIjtcbn1cblxudmFyIGFjdGlvbkZpZWxkRGVjb3JhdG9yID0gY3JlYXRlQ2xhc3NQcm9wZXJ0eURlY29yYXRvcihmdW5jdGlvbiAodGFyZ2V0LCBrZXksIHZhbHVlLCBhcmdzLCBvcmlnaW5hbERlc2NyaXB0b3IpIHtcbiAgICB2YXIgYWN0aW9uTmFtZSA9IGFyZ3MgJiYgYXJncy5sZW5ndGggPT09IDEgPyBhcmdzWzBdIDogdmFsdWUubmFtZSB8fCBrZXkgfHwgXCI8dW5uYW1lZCBhY3Rpb24+XCI7XG4gICAgdmFyIHdyYXBwZWRBY3Rpb24gPSBhY3Rpb24oYWN0aW9uTmFtZSwgdmFsdWUpO1xuICAgIGFkZEhpZGRlblByb3AodGFyZ2V0LCBrZXksIHdyYXBwZWRBY3Rpb24pO1xufSwgZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzW2tleV07XG59LCBmdW5jdGlvbiAoKSB7XG4gICAgaW52YXJpYW50KGZhbHNlLCBnZXRNZXNzYWdlKFwibTAwMVwiKSk7XG59LCBmYWxzZSwgdHJ1ZSk7XG52YXIgYm91bmRBY3Rpb25EZWNvcmF0b3IgPSBjcmVhdGVDbGFzc1Byb3BlcnR5RGVjb3JhdG9yKGZ1bmN0aW9uICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICBkZWZpbmVCb3VuZEFjdGlvbih0YXJnZXQsIGtleSwgdmFsdWUpO1xufSwgZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzW2tleV07XG59LCBmdW5jdGlvbiAoKSB7XG4gICAgaW52YXJpYW50KGZhbHNlLCBnZXRNZXNzYWdlKFwibTAwMVwiKSk7XG59LCBmYWxzZSwgZmFsc2UpO1xudmFyIGFjdGlvbiA9IGZ1bmN0aW9uIGFjdGlvbihhcmcxLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGFyZzEgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUFjdGlvbihhcmcxLm5hbWUgfHwgXCI8dW5uYW1lZCBhY3Rpb24+XCIsIGFyZzEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHR5cGVvZiBhcmcyID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybiBjcmVhdGVBY3Rpb24oYXJnMSwgYXJnMik7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGFyZzEgPT09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBuYW1lZEFjdGlvbkRlY29yYXRvcihhcmcxKTtcbiAgICByZXR1cm4gbmFtZWRBY3Rpb25EZWNvcmF0b3IoYXJnMikuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5hY3Rpb24uYm91bmQgPSBmdW5jdGlvbiBib3VuZEFjdGlvbihhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcxID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdmFyIGFjdGlvbl8xID0gY3JlYXRlQWN0aW9uKFwiPG5vdCB5ZXQgYm91bmQgYWN0aW9uPlwiLCBhcmcxKTtcbiAgICAgICAgYWN0aW9uXzEuYXV0b0JpbmQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gYWN0aW9uXzE7XG4gICAgfVxuICAgIHJldHVybiBib3VuZEFjdGlvbkRlY29yYXRvci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcbmZ1bmN0aW9uIG5hbWVkQWN0aW9uRGVjb3JhdG9yKG5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgcHJvcCwgZGVzY3JpcHRvcikge1xuICAgICAgICBpZiAoZGVzY3JpcHRvciAmJiB0eXBlb2YgZGVzY3JpcHRvci52YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAvLyBUeXBlU2NyaXB0IEBhY3Rpb24gbWV0aG9kKCkgeyB9LiBEZWZpbmVkIG9uIHByb3RvIGJlZm9yZSBiZWluZyBkZWNvcmF0ZWRcbiAgICAgICAgICAgIC8vIERvbid0IHVzZSB0aGUgZmllbGQgZGVjb3JhdG9yIGlmIHdlIGFyZSBqdXN0IGRlY29yYXRpbmcgYSBtZXRob2RcbiAgICAgICAgICAgIGRlc2NyaXB0b3IudmFsdWUgPSBjcmVhdGVBY3Rpb24obmFtZSwgZGVzY3JpcHRvci52YWx1ZSk7XG4gICAgICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXNjcmlwdG9yICE9PSB1bmRlZmluZWQgJiYgZGVzY3JpcHRvci5nZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW21vYnhdIGFjdGlvbiBpcyBub3QgZXhwZWN0ZWQgdG8gYmUgdXNlZCB3aXRoIGdldHRlcnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYm91bmQgaW5zdGFuY2UgbWV0aG9kc1xuICAgICAgICByZXR1cm4gYWN0aW9uRmllbGREZWNvcmF0b3IobmFtZSkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gcnVuSW5BY3Rpb24oYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIHZhciBhY3Rpb25OYW1lID0gdHlwZW9mIGFyZzEgPT09IFwic3RyaW5nXCIgPyBhcmcxIDogYXJnMS5uYW1lIHx8IFwiPHVubmFtZWQgYWN0aW9uPlwiO1xuICAgIHZhciBmbiA9IHR5cGVvZiBhcmcxID09PSBcImZ1bmN0aW9uXCIgPyBhcmcxIDogYXJnMjtcbiAgICB2YXIgc2NvcGUgPSB0eXBlb2YgYXJnMSA9PT0gXCJmdW5jdGlvblwiID8gYXJnMiA6IGFyZzM7XG4gICAgaW52YXJpYW50KHR5cGVvZiBmbiA9PT0gXCJmdW5jdGlvblwiLCBnZXRNZXNzYWdlKFwibTAwMlwiKSk7XG4gICAgaW52YXJpYW50KGZuLmxlbmd0aCA9PT0gMCwgZ2V0TWVzc2FnZShcIm0wMDNcIikpO1xuICAgIGludmFyaWFudCh0eXBlb2YgYWN0aW9uTmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBhY3Rpb25OYW1lLmxlbmd0aCA+IDAsIFwiYWN0aW9ucyBzaG91bGQgaGF2ZSB2YWxpZCBuYW1lcywgZ290OiAnXCIgKyBhY3Rpb25OYW1lICsgXCInXCIpO1xuICAgIHJldHVybiBleGVjdXRlQWN0aW9uKGFjdGlvbk5hbWUsIGZuLCBzY29wZSwgdW5kZWZpbmVkKTtcbn1cbmZ1bmN0aW9uIGlzQWN0aW9uKHRoaW5nKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGluZyA9PT0gXCJmdW5jdGlvblwiICYmIHRoaW5nLmlzTW9ieEFjdGlvbiA9PT0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGRlZmluZUJvdW5kQWN0aW9uKHRhcmdldCwgcHJvcGVydHlOYW1lLCBmbikge1xuICAgIHZhciByZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBleGVjdXRlQWN0aW9uKHByb3BlcnR5TmFtZSwgZm4sIHRhcmdldCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIHJlcy5pc01vYnhBY3Rpb24gPSB0cnVlO1xuICAgIGFkZEhpZGRlblByb3AodGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHJlcyk7XG59XG5cbmZ1bmN0aW9uIGlkZW50aXR5Q29tcGFyZXIoYSwgYikge1xuICAgIHJldHVybiBhID09PSBiO1xufVxuZnVuY3Rpb24gc3RydWN0dXJhbENvbXBhcmVyKGEsIGIpIHtcbiAgICByZXR1cm4gZGVlcEVxdWFsKGEsIGIpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENvbXBhcmVyKGEsIGIpIHtcbiAgICByZXR1cm4gYXJlQm90aE5hTihhLCBiKSB8fCBpZGVudGl0eUNvbXBhcmVyKGEsIGIpO1xufVxudmFyIGNvbXBhcmVyID0ge1xuICAgIGlkZW50aXR5OiBpZGVudGl0eUNvbXBhcmVyLFxuICAgIHN0cnVjdHVyYWw6IHN0cnVjdHVyYWxDb21wYXJlcixcbiAgICBkZWZhdWx0OiBkZWZhdWx0Q29tcGFyZXJcbn07XG5cbmZ1bmN0aW9uIGF1dG9ydW4oYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIHZhciBuYW1lLCB2aWV3LCBzY29wZTtcbiAgICBpZiAodHlwZW9mIGFyZzEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbmFtZSA9IGFyZzE7XG4gICAgICAgIHZpZXcgPSBhcmcyO1xuICAgICAgICBzY29wZSA9IGFyZzM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBuYW1lID0gYXJnMS5uYW1lIHx8IFwiQXV0b3J1bkBcIiArIGdldE5leHRJZCgpO1xuICAgICAgICB2aWV3ID0gYXJnMTtcbiAgICAgICAgc2NvcGUgPSBhcmcyO1xuICAgIH1cbiAgICBpbnZhcmlhbnQodHlwZW9mIHZpZXcgPT09IFwiZnVuY3Rpb25cIiwgZ2V0TWVzc2FnZShcIm0wMDRcIikpO1xuICAgIGludmFyaWFudChpc0FjdGlvbih2aWV3KSA9PT0gZmFsc2UsIGdldE1lc3NhZ2UoXCJtMDA1XCIpKTtcbiAgICBpZiAoc2NvcGUpXG4gICAgICAgIHZpZXcgPSB2aWV3LmJpbmQoc2NvcGUpO1xuICAgIHZhciByZWFjdGlvbiA9IG5ldyBSZWFjdGlvbihuYW1lLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudHJhY2socmVhY3Rpb25SdW5uZXIpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIHJlYWN0aW9uUnVubmVyKCkge1xuICAgICAgICB2aWV3KHJlYWN0aW9uKTtcbiAgICB9XG4gICAgcmVhY3Rpb24uc2NoZWR1bGUoKTtcbiAgICByZXR1cm4gcmVhY3Rpb24uZ2V0RGlzcG9zZXIoKTtcbn1cbmZ1bmN0aW9uIHdoZW4oYXJnMSwgYXJnMiwgYXJnMywgYXJnNCkge1xuICAgIHZhciBuYW1lLCBwcmVkaWNhdGUsIGVmZmVjdCwgc2NvcGU7XG4gICAgaWYgKHR5cGVvZiBhcmcxID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG5hbWUgPSBhcmcxO1xuICAgICAgICBwcmVkaWNhdGUgPSBhcmcyO1xuICAgICAgICBlZmZlY3QgPSBhcmczO1xuICAgICAgICBzY29wZSA9IGFyZzQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBuYW1lID0gXCJXaGVuQFwiICsgZ2V0TmV4dElkKCk7XG4gICAgICAgIHByZWRpY2F0ZSA9IGFyZzE7XG4gICAgICAgIGVmZmVjdCA9IGFyZzI7XG4gICAgICAgIHNjb3BlID0gYXJnMztcbiAgICB9XG4gICAgdmFyIGRpc3Bvc2VyID0gYXV0b3J1bihuYW1lLCBmdW5jdGlvbiAocikge1xuICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwoc2NvcGUpKSB7XG4gICAgICAgICAgICByLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHZhciBwcmV2VW50cmFja2VkID0gdW50cmFja2VkU3RhcnQoKTtcbiAgICAgICAgICAgIGVmZmVjdC5jYWxsKHNjb3BlKTtcbiAgICAgICAgICAgIHVudHJhY2tlZEVuZChwcmV2VW50cmFja2VkKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBkaXNwb3Nlcjtcbn1cbmZ1bmN0aW9uIGF1dG9ydW5Bc3luYyhhcmcxLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gICAgdmFyIG5hbWUsIGZ1bmMsIGRlbGF5LCBzY29wZTtcbiAgICBpZiAodHlwZW9mIGFyZzEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbmFtZSA9IGFyZzE7XG4gICAgICAgIGZ1bmMgPSBhcmcyO1xuICAgICAgICBkZWxheSA9IGFyZzM7XG4gICAgICAgIHNjb3BlID0gYXJnNDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5hbWUgPSBhcmcxLm5hbWUgfHwgXCJBdXRvcnVuQXN5bmNAXCIgKyBnZXROZXh0SWQoKTtcbiAgICAgICAgZnVuYyA9IGFyZzE7XG4gICAgICAgIGRlbGF5ID0gYXJnMjtcbiAgICAgICAgc2NvcGUgPSBhcmczO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoaXNBY3Rpb24oZnVuYykgPT09IGZhbHNlLCBnZXRNZXNzYWdlKFwibTAwNlwiKSk7XG4gICAgaWYgKGRlbGF5ID09PSB2b2lkIDApXG4gICAgICAgIGRlbGF5ID0gMTtcbiAgICBpZiAoc2NvcGUpXG4gICAgICAgIGZ1bmMgPSBmdW5jLmJpbmQoc2NvcGUpO1xuICAgIHZhciBpc1NjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHZhciByID0gbmV3IFJlYWN0aW9uKG5hbWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpc1NjaGVkdWxlZCkge1xuICAgICAgICAgICAgaXNTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaXNTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoIXIuaXNEaXNwb3NlZClcbiAgICAgICAgICAgICAgICAgICAgci50cmFjayhyZWFjdGlvblJ1bm5lcik7XG4gICAgICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBmdW5jdGlvbiByZWFjdGlvblJ1bm5lcigpIHtcbiAgICAgICAgZnVuYyhyKTtcbiAgICB9XG4gICAgci5zY2hlZHVsZSgpO1xuICAgIHJldHVybiByLmdldERpc3Bvc2VyKCk7XG59XG5mdW5jdGlvbiByZWFjdGlvbihleHByZXNzaW9uLCBlZmZlY3QsIGFyZzMpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgZmFpbChnZXRNZXNzYWdlKFwibTAwN1wiKSk7XG4gICAgfVxuICAgIGlmIChpc01vZGlmaWVyRGVzY3JpcHRvcihleHByZXNzaW9uKSkge1xuICAgICAgICBmYWlsKGdldE1lc3NhZ2UoXCJtMDA4XCIpKTtcbiAgICB9XG4gICAgdmFyIG9wdHM7XG4gICAgaWYgKHR5cGVvZiBhcmczID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIG9wdHMgPSBhcmczO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb3B0cyA9IHt9O1xuICAgIH1cbiAgICBvcHRzLm5hbWUgPVxuICAgICAgICBvcHRzLm5hbWUgfHwgZXhwcmVzc2lvbi5uYW1lIHx8IGVmZmVjdC5uYW1lIHx8IFwiUmVhY3Rpb25AXCIgKyBnZXROZXh0SWQoKTtcbiAgICBvcHRzLmZpcmVJbW1lZGlhdGVseSA9IGFyZzMgPT09IHRydWUgfHwgb3B0cy5maXJlSW1tZWRpYXRlbHkgPT09IHRydWU7XG4gICAgb3B0cy5kZWxheSA9IG9wdHMuZGVsYXkgfHwgMDtcbiAgICBvcHRzLmNvbXBhcmVTdHJ1Y3R1cmFsID0gb3B0cy5jb21wYXJlU3RydWN0dXJhbCB8fCBvcHRzLnN0cnVjdCB8fCBmYWxzZTtcbiAgICAvLyBUT0RPOiBjcmVhdGVzIHVnbHkgc3B5IGV2ZW50cywgdXNlIGBlZmZlY3QgPSAocikgPT4gcnVuSW5BY3Rpb24ob3B0cy5uYW1lLCAoKSA9PiBlZmZlY3QocikpYCBpbnN0ZWFkXG4gICAgZWZmZWN0ID0gYWN0aW9uKG9wdHMubmFtZSwgb3B0cy5jb250ZXh0ID8gZWZmZWN0LmJpbmQob3B0cy5jb250ZXh0KSA6IGVmZmVjdCk7XG4gICAgaWYgKG9wdHMuY29udGV4dCkge1xuICAgICAgICBleHByZXNzaW9uID0gZXhwcmVzc2lvbi5iaW5kKG9wdHMuY29udGV4dCk7XG4gICAgfVxuICAgIHZhciBmaXJzdFRpbWUgPSB0cnVlO1xuICAgIHZhciBpc1NjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHZhciB2YWx1ZTtcbiAgICB2YXIgZXF1YWxzID0gb3B0cy5lcXVhbHNcbiAgICAgICAgPyBvcHRzLmVxdWFsc1xuICAgICAgICA6IG9wdHMuY29tcGFyZVN0cnVjdHVyYWwgfHwgb3B0cy5zdHJ1Y3QgPyBjb21wYXJlci5zdHJ1Y3R1cmFsIDogY29tcGFyZXIuZGVmYXVsdDtcbiAgICB2YXIgciA9IG5ldyBSZWFjdGlvbihvcHRzLm5hbWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGZpcnN0VGltZSB8fCBvcHRzLmRlbGF5IDwgMSkge1xuICAgICAgICAgICAgcmVhY3Rpb25SdW5uZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNTY2hlZHVsZWQpIHtcbiAgICAgICAgICAgIGlzU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlzU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmVhY3Rpb25SdW5uZXIoKTtcbiAgICAgICAgICAgIH0sIG9wdHMuZGVsYXkpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gcmVhY3Rpb25SdW5uZXIoKSB7XG4gICAgICAgIGlmIChyLmlzRGlzcG9zZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIHIudHJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5leHRWYWx1ZSA9IGV4cHJlc3Npb24ocik7XG4gICAgICAgICAgICBjaGFuZ2VkID0gZmlyc3RUaW1lIHx8ICFlcXVhbHModmFsdWUsIG5leHRWYWx1ZSk7XG4gICAgICAgICAgICB2YWx1ZSA9IG5leHRWYWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChmaXJzdFRpbWUgJiYgb3B0cy5maXJlSW1tZWRpYXRlbHkpXG4gICAgICAgICAgICBlZmZlY3QodmFsdWUsIHIpO1xuICAgICAgICBpZiAoIWZpcnN0VGltZSAmJiBjaGFuZ2VkID09PSB0cnVlKVxuICAgICAgICAgICAgZWZmZWN0KHZhbHVlLCByKTtcbiAgICAgICAgaWYgKGZpcnN0VGltZSlcbiAgICAgICAgICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICAgIH1cbiAgICByLnNjaGVkdWxlKCk7XG4gICAgcmV0dXJuIHIuZ2V0RGlzcG9zZXIoKTtcbn1cblxuLyoqXG4gKiBBIG5vZGUgaW4gdGhlIHN0YXRlIGRlcGVuZGVuY3kgcm9vdCB0aGF0IG9ic2VydmVzIG90aGVyIG5vZGVzLCBhbmQgY2FuIGJlIG9ic2VydmVkIGl0c2VsZi5cbiAqXG4gKiBDb21wdXRlZFZhbHVlIHdpbGwgcmVtZW1iZXIgdGhlIHJlc3VsdCBvZiB0aGUgY29tcHV0YXRpb24gZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgYmF0Y2gsIG9yXG4gKiB3aGlsZSBiZWluZyBvYnNlcnZlZC5cbiAqXG4gKiBEdXJpbmcgdGhpcyB0aW1lIGl0IHdpbGwgcmVjb21wdXRlIG9ubHkgd2hlbiBvbmUgb2YgaXRzIGRpcmVjdCBkZXBlbmRlbmNpZXMgY2hhbmdlZCxcbiAqIGJ1dCBvbmx5IHdoZW4gaXQgaXMgYmVpbmcgYWNjZXNzZWQgd2l0aCBgQ29tcHV0ZWRWYWx1ZS5nZXQoKWAuXG4gKlxuICogSW1wbGVtZW50YXRpb24gZGVzY3JpcHRpb246XG4gKiAxLiBGaXJzdCB0aW1lIGl0J3MgYmVpbmcgYWNjZXNzZWQgaXQgd2lsbCBjb21wdXRlIGFuZCByZW1lbWJlciByZXN1bHRcbiAqICAgIGdpdmUgYmFjayByZW1lbWJlcmVkIHJlc3VsdCB1bnRpbCAyLiBoYXBwZW5zXG4gKiAyLiBGaXJzdCB0aW1lIGFueSBkZWVwIGRlcGVuZGVuY3kgY2hhbmdlLCBwcm9wYWdhdGUgUE9TU0lCTFlfU1RBTEUgdG8gYWxsIG9ic2VydmVycywgd2FpdCBmb3IgMy5cbiAqIDMuIFdoZW4gaXQncyBiZWluZyBhY2Nlc3NlZCwgcmVjb21wdXRlIGlmIGFueSBzaGFsbG93IGRlcGVuZGVuY3kgY2hhbmdlZC5cbiAqICAgIGlmIHJlc3VsdCBjaGFuZ2VkOiBwcm9wYWdhdGUgU1RBTEUgdG8gYWxsIG9ic2VydmVycywgdGhhdCB3ZXJlIFBPU1NJQkxZX1NUQUxFIGZyb20gdGhlIGxhc3Qgc3RlcC5cbiAqICAgIGdvIHRvIHN0ZXAgMi4gZWl0aGVyIHdheVxuICpcbiAqIElmIGF0IGFueSBwb2ludCBpdCdzIG91dHNpZGUgYmF0Y2ggYW5kIGl0IGlzbid0IG9ic2VydmVkOiByZXNldCBldmVyeXRoaW5nIGFuZCBnbyB0byAxLlxuICovXG52YXIgQ29tcHV0ZWRWYWx1ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGNvbXB1dGVkIHZhbHVlIGJhc2VkIG9uIGEgZnVuY3Rpb24gZXhwcmVzc2lvbi5cbiAgICAgKlxuICAgICAqIFRoZSBgbmFtZWAgcHJvcGVydHkgaXMgZm9yIGRlYnVnIHB1cnBvc2VzIG9ubHkuXG4gICAgICpcbiAgICAgKiBUaGUgYGVxdWFsc2AgcHJvcGVydHkgc3BlY2lmaWVzIHRoZSBjb21wYXJlciBmdW5jdGlvbiB0byB1c2UgdG8gZGV0ZXJtaW5lIGlmIGEgbmV3bHkgcHJvZHVjZWRcbiAgICAgKiB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHByZXZpb3VzIHZhbHVlLiBUd28gY29tcGFyZXJzIGFyZSBwcm92aWRlZCBpbiB0aGUgbGlicmFyeTsgYGRlZmF1bHRDb21wYXJlcmBcbiAgICAgKiBjb21wYXJlcyBiYXNlZCBvbiBpZGVudGl0eSBjb21wYXJpc29uICg9PT0pLCBhbmQgYHN0cnVjdHVhbENvbXBhcmVyYCBkZWVwbHkgY29tcGFyZXMgdGhlIHN0cnVjdHVyZS5cbiAgICAgKiBTdHJ1Y3R1cmFsIGNvbXBhcmlzb24gY2FuIGJlIGNvbnZlbmllbnQgaWYgeW91IGFsd2F5cyBwcm9kdWNlIGFuIG5ldyBhZ2dyZWdhdGVkIG9iamVjdCBhbmRcbiAgICAgKiBkb24ndCB3YW50IHRvIG5vdGlmeSBvYnNlcnZlcnMgaWYgaXQgaXMgc3RydWN0dXJhbGx5IHRoZSBzYW1lLlxuICAgICAqIFRoaXMgaXMgdXNlZnVsIGZvciB3b3JraW5nIHdpdGggdmVjdG9ycywgbW91c2UgY29vcmRpbmF0ZXMgZXRjLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbXB1dGVkVmFsdWUoZGVyaXZhdGlvbiwgc2NvcGUsIGVxdWFscywgbmFtZSwgc2V0dGVyKSB7XG4gICAgICAgIHRoaXMuZGVyaXZhdGlvbiA9IGRlcml2YXRpb247XG4gICAgICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICAgICAgdGhpcy5lcXVhbHMgPSBlcXVhbHM7XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzU3RhdGUgPSBJRGVyaXZhdGlvblN0YXRlLk5PVF9UUkFDS0lORztcbiAgICAgICAgdGhpcy5vYnNlcnZpbmcgPSBbXTsgLy8gbm9kZXMgd2UgYXJlIGxvb2tpbmcgYXQuIE91ciB2YWx1ZSBkZXBlbmRzIG9uIHRoZXNlIG5vZGVzXG4gICAgICAgIHRoaXMubmV3T2JzZXJ2aW5nID0gbnVsbDsgLy8gZHVyaW5nIHRyYWNraW5nIGl0J3MgYW4gYXJyYXkgd2l0aCBuZXcgb2JzZXJ2ZWQgb2JzZXJ2ZXJzXG4gICAgICAgIHRoaXMuaXNQZW5kaW5nVW5vYnNlcnZhdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9ic2VydmVycyA9IFtdO1xuICAgICAgICB0aGlzLm9ic2VydmVyc0luZGV4ZXMgPSB7fTtcbiAgICAgICAgdGhpcy5kaWZmVmFsdWUgPSAwO1xuICAgICAgICB0aGlzLnJ1bklkID0gMDtcbiAgICAgICAgdGhpcy5sYXN0QWNjZXNzZWRCeSA9IDA7XG4gICAgICAgIHRoaXMubG93ZXN0T2JzZXJ2ZXJTdGF0ZSA9IElEZXJpdmF0aW9uU3RhdGUuVVBfVE9fREFURTtcbiAgICAgICAgdGhpcy51bmJvdW5kRGVwc0NvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fX21hcGlkID0gXCIjXCIgKyBnZXROZXh0SWQoKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IG5ldyBDYXVnaHRFeGNlcHRpb24obnVsbCk7XG4gICAgICAgIHRoaXMuaXNDb21wdXRpbmcgPSBmYWxzZTsgLy8gdG8gY2hlY2sgZm9yIGN5Y2xlc1xuICAgICAgICB0aGlzLmlzUnVubmluZ1NldHRlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzVHJhY2luZyA9IFRyYWNlTW9kZS5OT05FO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lIHx8IFwiQ29tcHV0ZWRWYWx1ZUBcIiArIGdldE5leHRJZCgpO1xuICAgICAgICBpZiAoc2V0dGVyKVxuICAgICAgICAgICAgdGhpcy5zZXR0ZXIgPSBjcmVhdGVBY3Rpb24obmFtZSArIFwiLXNldHRlclwiLCBzZXR0ZXIpO1xuICAgIH1cbiAgICBDb21wdXRlZFZhbHVlLnByb3RvdHlwZS5vbkJlY29tZVN0YWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBwcm9wYWdhdGVNYXliZUNoYW5nZWQodGhpcyk7XG4gICAgfTtcbiAgICBDb21wdXRlZFZhbHVlLnByb3RvdHlwZS5vbkJlY29tZVVub2JzZXJ2ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFyT2JzZXJ2aW5nKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGlzIGNvbXB1dGVkIHZhbHVlLlxuICAgICAqIFdpbGwgZXZhbHVhdGUgaXRzIGNvbXB1dGF0aW9uIGZpcnN0IGlmIG5lZWRlZC5cbiAgICAgKi9cbiAgICBDb21wdXRlZFZhbHVlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGludmFyaWFudCghdGhpcy5pc0NvbXB1dGluZywgXCJDeWNsZSBkZXRlY3RlZCBpbiBjb21wdXRhdGlvbiBcIiArIHRoaXMubmFtZSwgdGhpcy5kZXJpdmF0aW9uKTtcbiAgICAgICAgaWYgKGdsb2JhbFN0YXRlLmluQmF0Y2ggPT09IDApIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYW4gbWlub3Igb3B0aW1pemF0aW9uIHdoaWNoIGNvdWxkIGJlIG9taXR0ZWQgdG8gc2ltcGxpZnkgdGhlIGNvZGVcbiAgICAgICAgICAgIC8vIFRoZSBjb21wdXRlZFZhbHVlIGlzIGFjY2Vzc2VkIG91dHNpZGUgb2YgYW55IG1vYnggc3R1ZmYuIEJhdGNoIG9ic2VydmluZyBzaG91bGQgYmUgZW5vdWdoIGFuZCBkb24ndCBuZWVkXG4gICAgICAgICAgICAvLyB0cmFja2luZyBhcyBpdCB3aWxsIG5ldmVyIGJlIGNhbGxlZCBhZ2FpbiBpbnNpZGUgdGhpcyBiYXRjaC5cbiAgICAgICAgICAgIHN0YXJ0QmF0Y2goKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRDb21wdXRlKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNUcmFjaW5nICE9PSBUcmFjZU1vZGUuTk9ORSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlttb2J4LnRyYWNlXSAnXCIgKyB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAubmFtZSArIFwiJyBpcyBiZWluZyByZWFkIG91dHNpZGUgYSByZWFjdGl2ZSBjb250ZXh0IGFuZCBkb2luZyBhIGZ1bGwgcmVjb21wdXRlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5jb21wdXRlVmFsdWUoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5kQmF0Y2goKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcG9ydE9ic2VydmVkKHRoaXMpO1xuICAgICAgICAgICAgaWYgKHNob3VsZENvbXB1dGUodGhpcykpXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tBbmRDb21wdXRlKCkpXG4gICAgICAgICAgICAgICAgICAgIHByb3BhZ2F0ZUNoYW5nZUNvbmZpcm1lZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy52YWx1ZTtcbiAgICAgICAgaWYgKGlzQ2F1Z2h0RXhjZXB0aW9uKHJlc3VsdCkpXG4gICAgICAgICAgICB0aHJvdyByZXN1bHQuY2F1c2U7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBDb21wdXRlZFZhbHVlLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzID0gdGhpcy5jb21wdXRlVmFsdWUoZmFsc2UpO1xuICAgICAgICBpZiAoaXNDYXVnaHRFeGNlcHRpb24ocmVzKSlcbiAgICAgICAgICAgIHRocm93IHJlcy5jYXVzZTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIENvbXB1dGVkVmFsdWUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5zZXR0ZXIpIHtcbiAgICAgICAgICAgIGludmFyaWFudCghdGhpcy5pc1J1bm5pbmdTZXR0ZXIsIFwiVGhlIHNldHRlciBvZiBjb21wdXRlZCB2YWx1ZSAnXCIgKyB0aGlzXG4gICAgICAgICAgICAgICAgLm5hbWUgKyBcIicgaXMgdHJ5aW5nIHRvIHVwZGF0ZSBpdHNlbGYuIERpZCB5b3UgaW50ZW5kIHRvIHVwZGF0ZSBhbiBfb2JzZXJ2YWJsZV8gdmFsdWUsIGluc3RlYWQgb2YgdGhlIGNvbXB1dGVkIHByb3BlcnR5P1wiKTtcbiAgICAgICAgICAgIHRoaXMuaXNSdW5uaW5nU2V0dGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0ZXIuY2FsbCh0aGlzLnNjb3BlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzUnVubmluZ1NldHRlciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGludmFyaWFudChmYWxzZSwgXCJbQ29tcHV0ZWRWYWx1ZSAnXCIgKyB0aGlzXG4gICAgICAgICAgICAgICAgLm5hbWUgKyBcIiddIEl0IGlzIG5vdCBwb3NzaWJsZSB0byBhc3NpZ24gYSBuZXcgdmFsdWUgdG8gYSBjb21wdXRlZCB2YWx1ZS5cIik7XG4gICAgfTtcbiAgICBDb21wdXRlZFZhbHVlLnByb3RvdHlwZS50cmFja0FuZENvbXB1dGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpc1NweUVuYWJsZWQoKSkge1xuICAgICAgICAgICAgc3B5UmVwb3J0KHtcbiAgICAgICAgICAgICAgICBvYmplY3Q6IHRoaXMuc2NvcGUsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb21wdXRlXCIsXG4gICAgICAgICAgICAgICAgZm46IHRoaXMuZGVyaXZhdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgdmFyIHdhc1N1c3BlbmRlZCA9IFxuICAgICAgICAvKiBzZWUgIzEyMDggKi8gdGhpcy5kZXBlbmRlbmNpZXNTdGF0ZSA9PT0gSURlcml2YXRpb25TdGF0ZS5OT1RfVFJBQ0tJTkc7XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9ICh0aGlzLnZhbHVlID0gdGhpcy5jb21wdXRlVmFsdWUodHJ1ZSkpO1xuICAgICAgICByZXR1cm4gKHdhc1N1c3BlbmRlZCB8fFxuICAgICAgICAgICAgaXNDYXVnaHRFeGNlcHRpb24ob2xkVmFsdWUpIHx8XG4gICAgICAgICAgICBpc0NhdWdodEV4Y2VwdGlvbihuZXdWYWx1ZSkgfHxcbiAgICAgICAgICAgICF0aGlzLmVxdWFscyhvbGRWYWx1ZSwgbmV3VmFsdWUpKTtcbiAgICB9O1xuICAgIENvbXB1dGVkVmFsdWUucHJvdG90eXBlLmNvbXB1dGVWYWx1ZSA9IGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICB0aGlzLmlzQ29tcHV0aW5nID0gdHJ1ZTtcbiAgICAgICAgZ2xvYmFsU3RhdGUuY29tcHV0YXRpb25EZXB0aCsrO1xuICAgICAgICB2YXIgcmVzO1xuICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICAgIHJlcyA9IHRyYWNrRGVyaXZlZEZ1bmN0aW9uKHRoaXMsIHRoaXMuZGVyaXZhdGlvbiwgdGhpcy5zY29wZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMuZGVyaXZhdGlvbi5jYWxsKHRoaXMuc2NvcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXMgPSBuZXcgQ2F1Z2h0RXhjZXB0aW9uKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdsb2JhbFN0YXRlLmNvbXB1dGF0aW9uRGVwdGgtLTtcbiAgICAgICAgdGhpcy5pc0NvbXB1dGluZyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgQ29tcHV0ZWRWYWx1ZS5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uIChsaXN0ZW5lciwgZmlyZUltbWVkaWF0ZWx5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBmaXJzdFRpbWUgPSB0cnVlO1xuICAgICAgICB2YXIgcHJldlZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gYXV0b3J1bihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSBfdGhpcy5nZXQoKTtcbiAgICAgICAgICAgIGlmICghZmlyc3RUaW1lIHx8IGZpcmVJbW1lZGlhdGVseSkge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2VSA9IHVudHJhY2tlZFN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInVwZGF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IF90aGlzLFxuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlOiBwcmV2VmFsdWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB1bnRyYWNrZWRFbmQocHJldlUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlyc3RUaW1lID0gZmFsc2U7XG4gICAgICAgICAgICBwcmV2VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb21wdXRlZFZhbHVlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldCgpO1xuICAgIH07XG4gICAgQ29tcHV0ZWRWYWx1ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyBcIltcIiArIHRoaXMuZGVyaXZhdGlvbi50b1N0cmluZygpICsgXCJdXCI7XG4gICAgfTtcbiAgICBDb21wdXRlZFZhbHVlLnByb3RvdHlwZS52YWx1ZU9mID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdG9QcmltaXRpdmUodGhpcy5nZXQoKSk7XG4gICAgfTtcbiAgICBDb21wdXRlZFZhbHVlLnByb3RvdHlwZS53aHlSdW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpc1RyYWNraW5nID0gQm9vbGVhbihnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24pO1xuICAgICAgICB2YXIgb2JzZXJ2aW5nID0gdW5pcXVlKHRoaXMuaXNDb21wdXRpbmcgPyB0aGlzLm5ld09ic2VydmluZyA6IHRoaXMub2JzZXJ2aW5nKS5tYXAoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gZGVwLm5hbWU7IH0pO1xuICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gdW5pcXVlKGdldE9ic2VydmVycyh0aGlzKS5tYXAoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gZGVwLm5hbWU7IH0pKTtcbiAgICAgICAgcmV0dXJuIChcIlxcbldoeVJ1bj8gY29tcHV0YXRpb24gJ1wiICsgdGhpcy5uYW1lICsgXCInOlxcbiAqIFJ1bm5pbmcgYmVjYXVzZTogXCIgKyAoaXNUcmFja2luZ1xuICAgICAgICAgICAgPyBcIlthY3RpdmVdIHRoZSB2YWx1ZSBvZiB0aGlzIGNvbXB1dGF0aW9uIGlzIG5lZWRlZCBieSBhIHJlYWN0aW9uXCJcbiAgICAgICAgICAgIDogdGhpcy5pc0NvbXB1dGluZ1xuICAgICAgICAgICAgICAgID8gXCJbZ2V0XSBUaGUgdmFsdWUgb2YgdGhpcyBjb21wdXRlZCB3YXMgcmVxdWVzdGVkIG91dHNpZGUgYSByZWFjdGlvblwiXG4gICAgICAgICAgICAgICAgOiBcIltpZGxlXSBub3QgcnVubmluZyBhdCB0aGUgbW9tZW50XCIpICsgXCJcXG5cIiArXG4gICAgICAgICAgICAodGhpcy5kZXBlbmRlbmNpZXNTdGF0ZSA9PT0gSURlcml2YXRpb25TdGF0ZS5OT1RfVFJBQ0tJTkdcbiAgICAgICAgICAgICAgICA/IGdldE1lc3NhZ2UoXCJtMDMyXCIpXG4gICAgICAgICAgICAgICAgOiBcIiAqIFRoaXMgY29tcHV0YXRpb24gd2lsbCByZS1ydW4gaWYgYW55IG9mIHRoZSBmb2xsb3dpbmcgb2JzZXJ2YWJsZXMgY2hhbmdlczpcXG4gICAgXCIgKyBqb2luU3RyaW5ncyhvYnNlcnZpbmcpICsgXCJcXG4gICAgXCIgKyAodGhpcy5pc0NvbXB1dGluZyAmJiBpc1RyYWNraW5nXG4gICAgICAgICAgICAgICAgICAgID8gXCIgKC4uLiBvciBhbnkgb2JzZXJ2YWJsZSBhY2Nlc3NlZCBkdXJpbmcgdGhlIHJlbWFpbmRlciBvZiB0aGUgY3VycmVudCBydW4pXCJcbiAgICAgICAgICAgICAgICAgICAgOiBcIlwiKSArIFwiXFxuICAgIFwiICsgZ2V0TWVzc2FnZShcIm0wMzhcIikgKyBcIlxcblxcbiAgKiBJZiB0aGUgb3V0Y29tZSBvZiB0aGlzIGNvbXB1dGF0aW9uIGNoYW5nZXMsIHRoZSBmb2xsb3dpbmcgb2JzZXJ2ZXJzIHdpbGwgYmUgcmUtcnVuOlxcbiAgICBcIiArIGpvaW5TdHJpbmdzKG9ic2VydmVycykgKyBcIlxcblwiKSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29tcHV0ZWRWYWx1ZTtcbn0oKSk7XG5Db21wdXRlZFZhbHVlLnByb3RvdHlwZVtwcmltaXRpdmVTeW1ib2woKV0gPSBDb21wdXRlZFZhbHVlLnByb3RvdHlwZS52YWx1ZU9mO1xudmFyIGlzQ29tcHV0ZWRWYWx1ZSA9IGNyZWF0ZUluc3RhbmNlb2ZQcmVkaWNhdGUoXCJDb21wdXRlZFZhbHVlXCIsIENvbXB1dGVkVmFsdWUpO1xuXG52YXIgT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb24odGFyZ2V0LCBuYW1lKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHt9O1xuICAgICAgICB0aGlzLmNoYW5nZUxpc3RlbmVycyA9IG51bGw7XG4gICAgICAgIHRoaXMuaW50ZXJjZXB0b3JzID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT2JzZXJ2ZXMgdGhpcyBvYmplY3QuIFRyaWdnZXJzIGZvciB0aGUgZXZlbnRzICdhZGQnLCAndXBkYXRlJyBhbmQgJ2RlbGV0ZScuXG4gICAgICogU2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3Qvb2JzZXJ2ZVxuICAgICAqIGZvciBjYWxsYmFjayBkZXRhaWxzXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uLnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBmaXJlSW1tZWRpYXRlbHkpIHtcbiAgICAgICAgaW52YXJpYW50KGZpcmVJbW1lZGlhdGVseSAhPT0gdHJ1ZSwgXCJgb2JzZXJ2ZWAgZG9lc24ndCBzdXBwb3J0IHRoZSBmaXJlIGltbWVkaWF0ZWx5IHByb3BlcnR5IGZvciBvYnNlcnZhYmxlIG9iamVjdHMuXCIpO1xuICAgICAgICByZXR1cm4gcmVnaXN0ZXJMaXN0ZW5lcih0aGlzLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb24ucHJvdG90eXBlLmludGVyY2VwdCA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiByZWdpc3RlckludGVyY2VwdG9yKHRoaXMsIGhhbmRsZXIpO1xuICAgIH07XG4gICAgcmV0dXJuIE9ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvbjtcbn0oKSk7XG5mdW5jdGlvbiBhc09ic2VydmFibGVPYmplY3QodGFyZ2V0LCBuYW1lKSB7XG4gICAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdCh0YXJnZXQpICYmIHRhcmdldC5oYXNPd25Qcm9wZXJ0eShcIiRtb2J4XCIpKVxuICAgICAgICByZXR1cm4gdGFyZ2V0LiRtb2J4O1xuICAgIGludmFyaWFudChPYmplY3QuaXNFeHRlbnNpYmxlKHRhcmdldCksIGdldE1lc3NhZ2UoXCJtMDM1XCIpKTtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodGFyZ2V0KSlcbiAgICAgICAgbmFtZSA9ICh0YXJnZXQuY29uc3RydWN0b3IubmFtZSB8fCBcIk9ic2VydmFibGVPYmplY3RcIikgKyBcIkBcIiArIGdldE5leHRJZCgpO1xuICAgIGlmICghbmFtZSlcbiAgICAgICAgbmFtZSA9IFwiT2JzZXJ2YWJsZU9iamVjdEBcIiArIGdldE5leHRJZCgpO1xuICAgIHZhciBhZG0gPSBuZXcgT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uKHRhcmdldCwgbmFtZSk7XG4gICAgYWRkSGlkZGVuRmluYWxQcm9wKHRhcmdldCwgXCIkbW9ieFwiLCBhZG0pO1xuICAgIHJldHVybiBhZG07XG59XG5mdW5jdGlvbiBkZWZpbmVPYnNlcnZhYmxlUHJvcGVydHlGcm9tRGVzY3JpcHRvcihhZG0sIHByb3BOYW1lLCBkZXNjcmlwdG9yLCBkZWZhdWx0RW5oYW5jZXIpIHtcbiAgICBpZiAoYWRtLnZhbHVlc1twcm9wTmFtZV0gJiYgIWlzQ29tcHV0ZWRWYWx1ZShhZG0udmFsdWVzW3Byb3BOYW1lXSkpIHtcbiAgICAgICAgLy8gYWxyZWFkeSBvYnNlcnZhYmxlIHByb3BlcnR5XG4gICAgICAgIGludmFyaWFudChcInZhbHVlXCIgaW4gZGVzY3JpcHRvciwgXCJUaGUgcHJvcGVydHkgXCIgKyBwcm9wTmFtZSArIFwiIGluIFwiICsgYWRtLm5hbWUgKyBcIiBpcyBhbHJlYWR5IG9ic2VydmFibGUsIGNhbm5vdCByZWRlZmluZSBpdCBhcyBjb21wdXRlZCBwcm9wZXJ0eVwiKTtcbiAgICAgICAgYWRtLnRhcmdldFtwcm9wTmFtZV0gPSBkZXNjcmlwdG9yLnZhbHVlOyAvLyB0aGUgcHJvcGVydHkgc2V0dGVyIHdpbGwgbWFrZSAndmFsdWUnIHJlYWN0aXZlIGlmIG5lZWRlZC5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBub3QgeWV0IG9ic2VydmFibGUgcHJvcGVydHlcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIHtcbiAgICAgICAgLy8gbm90IGEgY29tcHV0ZWQgdmFsdWVcbiAgICAgICAgaWYgKGlzTW9kaWZpZXJEZXNjcmlwdG9yKGRlc2NyaXB0b3IudmFsdWUpKSB7XG4gICAgICAgICAgICAvLyB4IDogcmVmKHNvbWVWYWx1ZSlcbiAgICAgICAgICAgIHZhciBtb2RpZmllckRlc2NyaXB0b3IgPSBkZXNjcmlwdG9yLnZhbHVlO1xuICAgICAgICAgICAgZGVmaW5lT2JzZXJ2YWJsZVByb3BlcnR5KGFkbSwgcHJvcE5hbWUsIG1vZGlmaWVyRGVzY3JpcHRvci5pbml0aWFsVmFsdWUsIG1vZGlmaWVyRGVzY3JpcHRvci5lbmhhbmNlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNBY3Rpb24oZGVzY3JpcHRvci52YWx1ZSkgJiYgZGVzY3JpcHRvci52YWx1ZS5hdXRvQmluZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgZGVmaW5lQm91bmRBY3Rpb24oYWRtLnRhcmdldCwgcHJvcE5hbWUsIGRlc2NyaXB0b3IudmFsdWUub3JpZ2luYWxGbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNDb21wdXRlZFZhbHVlKGRlc2NyaXB0b3IudmFsdWUpKSB7XG4gICAgICAgICAgICAvLyB4OiBjb21wdXRlZChzb21lRXhwcilcbiAgICAgICAgICAgIGRlZmluZUNvbXB1dGVkUHJvcGVydHlGcm9tQ29tcHV0ZWRWYWx1ZShhZG0sIHByb3BOYW1lLCBkZXNjcmlwdG9yLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHg6IHNvbWVWYWx1ZVxuICAgICAgICAgICAgZGVmaW5lT2JzZXJ2YWJsZVByb3BlcnR5KGFkbSwgcHJvcE5hbWUsIGRlc2NyaXB0b3IudmFsdWUsIGRlZmF1bHRFbmhhbmNlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGdldCB4KCkgeyByZXR1cm4gMyB9IHNldCB4KHYpIHsgfVxuICAgICAgICBkZWZpbmVDb21wdXRlZFByb3BlcnR5KGFkbSwgcHJvcE5hbWUsIGRlc2NyaXB0b3IuZ2V0LCBkZXNjcmlwdG9yLnNldCwgY29tcGFyZXIuZGVmYXVsdCwgdHJ1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVmaW5lT2JzZXJ2YWJsZVByb3BlcnR5KGFkbSwgcHJvcE5hbWUsIG5ld1ZhbHVlLCBlbmhhbmNlcikge1xuICAgIGFzc2VydFByb3BlcnR5Q29uZmlndXJhYmxlKGFkbS50YXJnZXQsIHByb3BOYW1lKTtcbiAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKGFkbSkpIHtcbiAgICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZShhZG0sIHtcbiAgICAgICAgICAgIG9iamVjdDogYWRtLnRhcmdldCxcbiAgICAgICAgICAgIG5hbWU6IHByb3BOYW1lLFxuICAgICAgICAgICAgdHlwZTogXCJhZGRcIixcbiAgICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFjaGFuZ2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIG5ld1ZhbHVlID0gY2hhbmdlLm5ld1ZhbHVlO1xuICAgIH1cbiAgICB2YXIgb2JzZXJ2YWJsZSA9IChhZG0udmFsdWVzW3Byb3BOYW1lXSA9IG5ldyBPYnNlcnZhYmxlVmFsdWUobmV3VmFsdWUsIGVuaGFuY2VyLCBhZG0ubmFtZSArIFwiLlwiICsgcHJvcE5hbWUsIGZhbHNlKSk7XG4gICAgbmV3VmFsdWUgPSBvYnNlcnZhYmxlLnZhbHVlOyAvLyBvYnNlcnZhYmxlVmFsdWUgbWlnaHQgaGF2ZSBjaGFuZ2VkIGl0XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFkbS50YXJnZXQsIHByb3BOYW1lLCBnZW5lcmF0ZU9ic2VydmFibGVQcm9wQ29uZmlnKHByb3BOYW1lKSk7XG4gICAgbm90aWZ5UHJvcGVydHlBZGRpdGlvbihhZG0sIGFkbS50YXJnZXQsIHByb3BOYW1lLCBuZXdWYWx1ZSk7XG59XG5mdW5jdGlvbiBkZWZpbmVDb21wdXRlZFByb3BlcnR5KGFkbSwgcHJvcE5hbWUsIGdldHRlciwgc2V0dGVyLCBlcXVhbHMsIGFzSW5zdGFuY2VQcm9wZXJ0eSkge1xuICAgIGlmIChhc0luc3RhbmNlUHJvcGVydHkpXG4gICAgICAgIGFzc2VydFByb3BlcnR5Q29uZmlndXJhYmxlKGFkbS50YXJnZXQsIHByb3BOYW1lKTtcbiAgICBhZG0udmFsdWVzW3Byb3BOYW1lXSA9IG5ldyBDb21wdXRlZFZhbHVlKGdldHRlciwgYWRtLnRhcmdldCwgZXF1YWxzLCBhZG0ubmFtZSArIFwiLlwiICsgcHJvcE5hbWUsIHNldHRlcik7XG4gICAgaWYgKGFzSW5zdGFuY2VQcm9wZXJ0eSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYWRtLnRhcmdldCwgcHJvcE5hbWUsIGdlbmVyYXRlQ29tcHV0ZWRQcm9wQ29uZmlnKHByb3BOYW1lKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWRQcm9wZXJ0eUZyb21Db21wdXRlZFZhbHVlKGFkbSwgcHJvcE5hbWUsIGNvbXB1dGVkVmFsdWUpIHtcbiAgICB2YXIgbmFtZSA9IGFkbS5uYW1lICsgXCIuXCIgKyBwcm9wTmFtZTtcbiAgICBjb21wdXRlZFZhbHVlLm5hbWUgPSBuYW1lO1xuICAgIGlmICghY29tcHV0ZWRWYWx1ZS5zY29wZSlcbiAgICAgICAgY29tcHV0ZWRWYWx1ZS5zY29wZSA9IGFkbS50YXJnZXQ7XG4gICAgYWRtLnZhbHVlc1twcm9wTmFtZV0gPSBjb21wdXRlZFZhbHVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhZG0udGFyZ2V0LCBwcm9wTmFtZSwgZ2VuZXJhdGVDb21wdXRlZFByb3BDb25maWcocHJvcE5hbWUpKTtcbn1cbnZhciBvYnNlcnZhYmxlUHJvcGVydHlDb25maWdzID0ge307XG52YXIgY29tcHV0ZWRQcm9wZXJ0eUNvbmZpZ3MgPSB7fTtcbmZ1bmN0aW9uIGdlbmVyYXRlT2JzZXJ2YWJsZVByb3BDb25maWcocHJvcE5hbWUpIHtcbiAgICByZXR1cm4gKG9ic2VydmFibGVQcm9wZXJ0eUNvbmZpZ3NbcHJvcE5hbWVdIHx8XG4gICAgICAgIChvYnNlcnZhYmxlUHJvcGVydHlDb25maWdzW3Byb3BOYW1lXSA9IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kbW9ieC52YWx1ZXNbcHJvcE5hbWVdLmdldCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICBzZXRQcm9wZXJ0eVZhbHVlKHRoaXMsIHByb3BOYW1lLCB2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVDb21wdXRlZFByb3BDb25maWcocHJvcE5hbWUpIHtcbiAgICByZXR1cm4gKGNvbXB1dGVkUHJvcGVydHlDb25maWdzW3Byb3BOYW1lXSB8fFxuICAgICAgICAoY29tcHV0ZWRQcm9wZXJ0eUNvbmZpZ3NbcHJvcE5hbWVdID0ge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kbW9ieC52YWx1ZXNbcHJvcE5hbWVdLmdldCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kbW9ieC52YWx1ZXNbcHJvcE5hbWVdLnNldCh2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xufVxuZnVuY3Rpb24gc2V0UHJvcGVydHlWYWx1ZShpbnN0YW5jZSwgbmFtZSwgbmV3VmFsdWUpIHtcbiAgICB2YXIgYWRtID0gaW5zdGFuY2UuJG1vYng7XG4gICAgdmFyIG9ic2VydmFibGUgPSBhZG0udmFsdWVzW25hbWVdO1xuICAgIC8vIGludGVyY2VwdFxuICAgIGlmIChoYXNJbnRlcmNlcHRvcnMoYWRtKSkge1xuICAgICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKGFkbSwge1xuICAgICAgICAgICAgdHlwZTogXCJ1cGRhdGVcIixcbiAgICAgICAgICAgIG9iamVjdDogaW5zdGFuY2UsXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWNoYW5nZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbmV3VmFsdWUgPSBjaGFuZ2UubmV3VmFsdWU7XG4gICAgfVxuICAgIG5ld1ZhbHVlID0gb2JzZXJ2YWJsZS5wcmVwYXJlTmV3VmFsdWUobmV3VmFsdWUpO1xuICAgIC8vIG5vdGlmeSBzcHkgJiBvYnNlcnZlcnNcbiAgICBpZiAobmV3VmFsdWUgIT09IFVOQ0hBTkdFRCkge1xuICAgICAgICB2YXIgbm90aWZ5ID0gaGFzTGlzdGVuZXJzKGFkbSk7XG4gICAgICAgIHZhciBub3RpZnlTcHkgPSBpc1NweUVuYWJsZWQoKTtcbiAgICAgICAgdmFyIGNoYW5nZSA9IG5vdGlmeSB8fCBub3RpZnlTcHlcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidXBkYXRlXCIsXG4gICAgICAgICAgICAgICAgb2JqZWN0OiBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZTogb2JzZXJ2YWJsZS52YWx1ZSxcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBpZiAobm90aWZ5U3B5KVxuICAgICAgICAgICAgc3B5UmVwb3J0U3RhcnQoY2hhbmdlKTtcbiAgICAgICAgb2JzZXJ2YWJsZS5zZXROZXdWYWx1ZShuZXdWYWx1ZSk7XG4gICAgICAgIGlmIChub3RpZnkpXG4gICAgICAgICAgICBub3RpZnlMaXN0ZW5lcnMoYWRtLCBjaGFuZ2UpO1xuICAgICAgICBpZiAobm90aWZ5U3B5KVxuICAgICAgICAgICAgc3B5UmVwb3J0RW5kKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gbm90aWZ5UHJvcGVydHlBZGRpdGlvbihhZG0sIG9iamVjdCwgbmFtZSwgbmV3VmFsdWUpIHtcbiAgICB2YXIgbm90aWZ5ID0gaGFzTGlzdGVuZXJzKGFkbSk7XG4gICAgdmFyIG5vdGlmeVNweSA9IGlzU3B5RW5hYmxlZCgpO1xuICAgIHZhciBjaGFuZ2UgPSBub3RpZnkgfHwgbm90aWZ5U3B5XG4gICAgICAgID8ge1xuICAgICAgICAgICAgdHlwZTogXCJhZGRcIixcbiAgICAgICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZVxuICAgICAgICB9XG4gICAgICAgIDogbnVsbDtcbiAgICBpZiAobm90aWZ5U3B5KVxuICAgICAgICBzcHlSZXBvcnRTdGFydChjaGFuZ2UpO1xuICAgIGlmIChub3RpZnkpXG4gICAgICAgIG5vdGlmeUxpc3RlbmVycyhhZG0sIGNoYW5nZSk7XG4gICAgaWYgKG5vdGlmeVNweSlcbiAgICAgICAgc3B5UmVwb3J0RW5kKCk7XG59XG52YXIgaXNPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb24gPSBjcmVhdGVJbnN0YW5jZW9mUHJlZGljYXRlKFwiT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uXCIsIE9ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvbik7XG5mdW5jdGlvbiBpc09ic2VydmFibGVPYmplY3QodGhpbmcpIHtcbiAgICBpZiAoaXNPYmplY3QodGhpbmcpKSB7XG4gICAgICAgIC8vIEluaXRpYWxpemVycyBydW4gbGF6aWx5IHdoZW4gdHJhbnNwaWxpbmcgdG8gYmFiZWwsIHNvIG1ha2Ugc3VyZSB0aGV5IGFyZSBydW4uLi5cbiAgICAgICAgcnVuTGF6eUluaXRpYWxpemVycyh0aGluZyk7XG4gICAgICAgIHJldHVybiBpc09ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvbih0aGluZy4kbW9ieCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGVkIHZhbHVlIGlzIHJlYWN0aXZlLlxuICogQHBhcmFtIHZhbHVlIG9iamVjdCwgZnVuY3Rpb24gb3IgYXJyYXlcbiAqIEBwYXJhbSBwcm9wZXJ0eSBpZiBwcm9wZXJ0eSBpcyBzcGVjaWZpZWQsIGNoZWNrcyB3aGV0aGVyIHZhbHVlLnByb3BlcnR5IGlzIHJlYWN0aXZlLlxuICovXG5mdW5jdGlvbiBpc09ic2VydmFibGUodmFsdWUsIHByb3BlcnR5KSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAocHJvcGVydHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaXNPYnNlcnZhYmxlQXJyYXkodmFsdWUpIHx8IGlzT2JzZXJ2YWJsZU1hcCh2YWx1ZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZ2V0TWVzc2FnZShcIm0wMTlcIikpO1xuICAgICAgICBlbHNlIGlmIChpc09ic2VydmFibGVPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICB2YXIgbyA9IHZhbHVlLiRtb2J4O1xuICAgICAgICAgICAgcmV0dXJuIG8udmFsdWVzICYmICEhby52YWx1ZXNbcHJvcGVydHldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gRm9yIGZpcnN0IGNoZWNrLCBzZWUgIzcwMVxuICAgIHJldHVybiAoaXNPYnNlcnZhYmxlT2JqZWN0KHZhbHVlKSB8fFxuICAgICAgICAhIXZhbHVlLiRtb2J4IHx8XG4gICAgICAgIGlzQXRvbSh2YWx1ZSkgfHxcbiAgICAgICAgaXNSZWFjdGlvbih2YWx1ZSkgfHxcbiAgICAgICAgaXNDb21wdXRlZFZhbHVlKHZhbHVlKSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURlY29yYXRvckZvckVuaGFuY2VyKGVuaGFuY2VyKSB7XG4gICAgaW52YXJpYW50KCEhZW5oYW5jZXIsIFwiOihcIik7XG4gICAgcmV0dXJuIGNyZWF0ZUNsYXNzUHJvcGVydHlEZWNvcmF0b3IoZnVuY3Rpb24gKHRhcmdldCwgbmFtZSwgYmFzZVZhbHVlLCBfLCBiYXNlRGVzY3JpcHRvcikge1xuICAgICAgICBhc3NlcnRQcm9wZXJ0eUNvbmZpZ3VyYWJsZSh0YXJnZXQsIG5hbWUpO1xuICAgICAgICBpbnZhcmlhbnQoIWJhc2VEZXNjcmlwdG9yIHx8ICFiYXNlRGVzY3JpcHRvci5nZXQsIGdldE1lc3NhZ2UoXCJtMDIyXCIpKTtcbiAgICAgICAgdmFyIGFkbSA9IGFzT2JzZXJ2YWJsZU9iamVjdCh0YXJnZXQsIHVuZGVmaW5lZCk7XG4gICAgICAgIGRlZmluZU9ic2VydmFibGVQcm9wZXJ0eShhZG0sIG5hbWUsIGJhc2VWYWx1ZSwgZW5oYW5jZXIpO1xuICAgIH0sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBvYnNlcnZhYmxlID0gdGhpcy4kbW9ieC52YWx1ZXNbbmFtZV07XG4gICAgICAgIGlmIChvYnNlcnZhYmxlID09PSB1bmRlZmluZWQgLy8gU2VlICM1MDVcbiAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGUuZ2V0KCk7XG4gICAgfSwgZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHNldFByb3BlcnR5VmFsdWUodGhpcywgbmFtZSwgdmFsdWUpO1xuICAgIH0sIHRydWUsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kT2JzZXJ2YWJsZSh0YXJnZXQpIHtcbiAgICB2YXIgcHJvcGVydGllcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHByb3BlcnRpZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBleHRlbmRPYnNlcnZhYmxlSGVscGVyKHRhcmdldCwgZGVlcEVuaGFuY2VyLCBwcm9wZXJ0aWVzKTtcbn1cbmZ1bmN0aW9uIGV4dGVuZFNoYWxsb3dPYnNlcnZhYmxlKHRhcmdldCkge1xuICAgIHZhciBwcm9wZXJ0aWVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgcHJvcGVydGllc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIGV4dGVuZE9ic2VydmFibGVIZWxwZXIodGFyZ2V0LCByZWZlcmVuY2VFbmhhbmNlciwgcHJvcGVydGllcyk7XG59XG5mdW5jdGlvbiBleHRlbmRPYnNlcnZhYmxlSGVscGVyKHRhcmdldCwgZGVmYXVsdEVuaGFuY2VyLCBwcm9wZXJ0aWVzKSB7XG4gICAgaW52YXJpYW50KGFyZ3VtZW50cy5sZW5ndGggPj0gMiwgZ2V0TWVzc2FnZShcIm0wMTRcIikpO1xuICAgIGludmFyaWFudCh0eXBlb2YgdGFyZ2V0ID09PSBcIm9iamVjdFwiLCBnZXRNZXNzYWdlKFwibTAxNVwiKSk7XG4gICAgaW52YXJpYW50KCFpc09ic2VydmFibGVNYXAodGFyZ2V0KSwgZ2V0TWVzc2FnZShcIm0wMTZcIikpO1xuICAgIHByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcFNldCkge1xuICAgICAgICBpbnZhcmlhbnQodHlwZW9mIHByb3BTZXQgPT09IFwib2JqZWN0XCIsIGdldE1lc3NhZ2UoXCJtMDE3XCIpKTtcbiAgICAgICAgaW52YXJpYW50KCFpc09ic2VydmFibGUocHJvcFNldCksIGdldE1lc3NhZ2UoXCJtMDE4XCIpKTtcbiAgICB9KTtcbiAgICB2YXIgYWRtID0gYXNPYnNlcnZhYmxlT2JqZWN0KHRhcmdldCk7XG4gICAgdmFyIGRlZmluZWRQcm9wcyA9IHt9O1xuICAgIC8vIE5vdGUgY291bGQgYmUgb3B0aW1pc2VkIGlmIHByb3BlcnRpZXMubGVuZ3RoID09PSAxXG4gICAgZm9yICh2YXIgaSA9IHByb3BlcnRpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIHByb3BTZXQgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFNldClcbiAgICAgICAgICAgIGlmIChkZWZpbmVkUHJvcHNba2V5XSAhPT0gdHJ1ZSAmJiBoYXNPd25Qcm9wZXJ0eShwcm9wU2V0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lZFByb3BzW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgPT09IHByb3BTZXQgJiYgIWlzUHJvcGVydHlDb25maWd1cmFibGUodGFyZ2V0LCBrZXkpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gc2VlICMxMTEsIHNraXAgbm9uLWNvbmZpZ3VyYWJsZSBvciBub24td3JpdGFibGUgcHJvcHMgZm9yIGBvYnNlcnZhYmxlKG9iamVjdClgLlxuICAgICAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm9wU2V0LCBrZXkpO1xuICAgICAgICAgICAgICAgIGRlZmluZU9ic2VydmFibGVQcm9wZXJ0eUZyb21EZXNjcmlwdG9yKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBkZWZhdWx0RW5oYW5jZXIpO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG52YXIgZGVlcERlY29yYXRvciA9IGNyZWF0ZURlY29yYXRvckZvckVuaGFuY2VyKGRlZXBFbmhhbmNlcik7XG52YXIgc2hhbGxvd0RlY29yYXRvciA9IGNyZWF0ZURlY29yYXRvckZvckVuaGFuY2VyKHNoYWxsb3dFbmhhbmNlcik7XG52YXIgcmVmRGVjb3JhdG9yID0gY3JlYXRlRGVjb3JhdG9yRm9yRW5oYW5jZXIocmVmZXJlbmNlRW5oYW5jZXIpO1xudmFyIGRlZXBTdHJ1Y3REZWNvcmF0b3IgPSBjcmVhdGVEZWNvcmF0b3JGb3JFbmhhbmNlcihkZWVwU3RydWN0RW5oYW5jZXIpO1xudmFyIHJlZlN0cnVjdERlY29yYXRvciA9IGNyZWF0ZURlY29yYXRvckZvckVuaGFuY2VyKHJlZlN0cnVjdEVuaGFuY2VyKTtcbi8qKlxuICogVHVybnMgYW4gb2JqZWN0LCBhcnJheSBvciBmdW5jdGlvbiBpbnRvIGEgcmVhY3RpdmUgc3RydWN0dXJlLlxuICogQHBhcmFtIHYgdGhlIHZhbHVlIHdoaWNoIHNob3VsZCBiZWNvbWUgb2JzZXJ2YWJsZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlT2JzZXJ2YWJsZSh2KSB7XG4gICAgaWYgKHYgPT09IHZvaWQgMCkgeyB2ID0gdW5kZWZpbmVkOyB9XG4gICAgLy8gQG9ic2VydmFibGUgc29tZVByb3A7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMV0gPT09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBkZWVwRGVjb3JhdG9yLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgaW52YXJpYW50KGFyZ3VtZW50cy5sZW5ndGggPD0gMSwgZ2V0TWVzc2FnZShcIm0wMjFcIikpO1xuICAgIGludmFyaWFudCghaXNNb2RpZmllckRlc2NyaXB0b3IodiksIGdldE1lc3NhZ2UoXCJtMDIwXCIpKTtcbiAgICAvLyBpdCBpcyBhbiBvYnNlcnZhYmxlIGFscmVhZHksIGRvbmVcbiAgICBpZiAoaXNPYnNlcnZhYmxlKHYpKVxuICAgICAgICByZXR1cm4gdjtcbiAgICAvLyBzb21ldGhpbmcgdGhhdCBjYW4gYmUgY29udmVydGVkIGFuZCBtdXRhdGVkP1xuICAgIHZhciByZXMgPSBkZWVwRW5oYW5jZXIodiwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICAgIC8vIHRoaXMgdmFsdWUgY291bGQgYmUgY29udmVydGVkIHRvIGEgbmV3IG9ic2VydmFibGUgZGF0YSBzdHJ1Y3R1cmUsIHJldHVybiBpdFxuICAgIGlmIChyZXMgIT09IHYpXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgLy8gb3RoZXJ3aXNlLCBqdXN0IGJveCBpdFxuICAgIHJldHVybiBvYnNlcnZhYmxlLmJveCh2KTtcbn1cbnZhciBvYnNlcnZhYmxlRmFjdG9yaWVzID0ge1xuICAgIGJveDogZnVuY3Rpb24gKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMilcbiAgICAgICAgICAgIGluY29ycmVjdGx5VXNlZEFzRGVjb3JhdG9yKFwiYm94XCIpO1xuICAgICAgICByZXR1cm4gbmV3IE9ic2VydmFibGVWYWx1ZSh2YWx1ZSwgZGVlcEVuaGFuY2VyLCBuYW1lKTtcbiAgICB9LFxuICAgIHNoYWxsb3dCb3g6IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpXG4gICAgICAgICAgICBpbmNvcnJlY3RseVVzZWRBc0RlY29yYXRvcihcInNoYWxsb3dCb3hcIik7XG4gICAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZVZhbHVlKHZhbHVlLCByZWZlcmVuY2VFbmhhbmNlciwgbmFtZSk7XG4gICAgfSxcbiAgICBhcnJheTogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZXMsIG5hbWUpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKVxuICAgICAgICAgICAgaW5jb3JyZWN0bHlVc2VkQXNEZWNvcmF0b3IoXCJhcnJheVwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlQXJyYXkoaW5pdGlhbFZhbHVlcywgZGVlcEVuaGFuY2VyLCBuYW1lKTtcbiAgICB9LFxuICAgIHNoYWxsb3dBcnJheTogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZXMsIG5hbWUpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKVxuICAgICAgICAgICAgaW5jb3JyZWN0bHlVc2VkQXNEZWNvcmF0b3IoXCJzaGFsbG93QXJyYXlcIik7XG4gICAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZUFycmF5KGluaXRpYWxWYWx1ZXMsIHJlZmVyZW5jZUVuaGFuY2VyLCBuYW1lKTtcbiAgICB9LFxuICAgIG1hcDogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZXMsIG5hbWUpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKVxuICAgICAgICAgICAgaW5jb3JyZWN0bHlVc2VkQXNEZWNvcmF0b3IoXCJtYXBcIik7XG4gICAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZU1hcChpbml0aWFsVmFsdWVzLCBkZWVwRW5oYW5jZXIsIG5hbWUpO1xuICAgIH0sXG4gICAgc2hhbGxvd01hcDogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZXMsIG5hbWUpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKVxuICAgICAgICAgICAgaW5jb3JyZWN0bHlVc2VkQXNEZWNvcmF0b3IoXCJzaGFsbG93TWFwXCIpO1xuICAgICAgICByZXR1cm4gbmV3IE9ic2VydmFibGVNYXAoaW5pdGlhbFZhbHVlcywgcmVmZXJlbmNlRW5oYW5jZXIsIG5hbWUpO1xuICAgIH0sXG4gICAgb2JqZWN0OiBmdW5jdGlvbiAocHJvcHMsIG5hbWUpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKVxuICAgICAgICAgICAgaW5jb3JyZWN0bHlVc2VkQXNEZWNvcmF0b3IoXCJvYmplY3RcIik7XG4gICAgICAgIHZhciByZXMgPSB7fTtcbiAgICAgICAgLy8gY29udmVydCB0byBvYnNlcnZhYmxlIG9iamVjdFxuICAgICAgICBhc09ic2VydmFibGVPYmplY3QocmVzLCBuYW1lKTtcbiAgICAgICAgLy8gYWRkIHByb3BlcnRpZXNcbiAgICAgICAgZXh0ZW5kT2JzZXJ2YWJsZShyZXMsIHByb3BzKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIHNoYWxsb3dPYmplY3Q6IGZ1bmN0aW9uIChwcm9wcywgbmFtZSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpXG4gICAgICAgICAgICBpbmNvcnJlY3RseVVzZWRBc0RlY29yYXRvcihcInNoYWxsb3dPYmplY3RcIik7XG4gICAgICAgIHZhciByZXMgPSB7fTtcbiAgICAgICAgYXNPYnNlcnZhYmxlT2JqZWN0KHJlcywgbmFtZSk7XG4gICAgICAgIGV4dGVuZFNoYWxsb3dPYnNlcnZhYmxlKHJlcywgcHJvcHMpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgcmVmOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgLy8gYWx0aG91Z2ggcmVmIGNyZWF0ZXMgYWN0dWFsbHkgYSBtb2RpZmllciBkZXNjcmlwdG9yLCB0aGUgdHlwZSBvZiB0aGUgcmVzdWx0aWcgcHJvcGVydGllc1xuICAgICAgICAgICAgLy8gb2YgdGhlIG9iamVjdCBpcyBgVGAgaW4gdGhlIGVuZCwgd2hlbiB0aGUgZGVzY3JpcHRvcnMgYXJlIGludGVycHJldGVkXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTW9kaWZpZXJEZXNjcmlwdG9yKHJlZmVyZW5jZUVuaGFuY2VyLCBhcmd1bWVudHNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJlZkRlY29yYXRvci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBzaGFsbG93OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgLy8gYWx0aG91Z2ggcmVmIGNyZWF0ZXMgYWN0dWFsbHkgYSBtb2RpZmllciBkZXNjcmlwdG9yLCB0aGUgdHlwZSBvZiB0aGUgcmVzdWx0aWcgcHJvcGVydGllc1xuICAgICAgICAgICAgLy8gb2YgdGhlIG9iamVjdCBpcyBgVGAgaW4gdGhlIGVuZCwgd2hlbiB0aGUgZGVzY3JpcHRvcnMgYXJlIGludGVycHJldGVkXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTW9kaWZpZXJEZXNjcmlwdG9yKHNoYWxsb3dFbmhhbmNlciwgYXJndW1lbnRzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzaGFsbG93RGVjb3JhdG9yLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGRlZXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAvLyBhbHRob3VnaCByZWYgY3JlYXRlcyBhY3R1YWxseSBhIG1vZGlmaWVyIGRlc2NyaXB0b3IsIHRoZSB0eXBlIG9mIHRoZSByZXN1bHRpZyBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAvLyBvZiB0aGUgb2JqZWN0IGlzIGBUYCBpbiB0aGUgZW5kLCB3aGVuIHRoZSBkZXNjcmlwdG9ycyBhcmUgaW50ZXJwcmV0ZWRcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVNb2RpZmllckRlc2NyaXB0b3IoZGVlcEVuaGFuY2VyLCBhcmd1bWVudHNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRlZXBEZWNvcmF0b3IuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc3RydWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgLy8gYWx0aG91Z2ggcmVmIGNyZWF0ZXMgYWN0dWFsbHkgYSBtb2RpZmllciBkZXNjcmlwdG9yLCB0aGUgdHlwZSBvZiB0aGUgcmVzdWx0aWcgcHJvcGVydGllc1xuICAgICAgICAgICAgLy8gb2YgdGhlIG9iamVjdCBpcyBgVGAgaW4gdGhlIGVuZCwgd2hlbiB0aGUgZGVzY3JpcHRvcnMgYXJlIGludGVycHJldGVkXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTW9kaWZpZXJEZXNjcmlwdG9yKGRlZXBTdHJ1Y3RFbmhhbmNlciwgYXJndW1lbnRzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkZWVwU3RydWN0RGVjb3JhdG9yLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xudmFyIG9ic2VydmFibGUgPSBjcmVhdGVPYnNlcnZhYmxlO1xuLy8gd2VpcmQgdHJpY2sgdG8ga2VlcCBvdXIgdHlwaW5ncyBuaWNlbHkgd2l0aCBvdXIgZnVuY3MsIGFuZCBzdGlsbCBleHRlbmQgdGhlIG9ic2VydmFibGUgZnVuY3Rpb25cbk9iamVjdC5rZXlzKG9ic2VydmFibGVGYWN0b3JpZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIChvYnNlcnZhYmxlW25hbWVdID0gb2JzZXJ2YWJsZUZhY3Rvcmllc1tuYW1lXSk7IH0pO1xub2JzZXJ2YWJsZS5kZWVwLnN0cnVjdCA9IG9ic2VydmFibGUuc3RydWN0O1xub2JzZXJ2YWJsZS5yZWYuc3RydWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gY3JlYXRlTW9kaWZpZXJEZXNjcmlwdG9yKHJlZlN0cnVjdEVuaGFuY2VyLCBhcmd1bWVudHNbMF0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlZlN0cnVjdERlY29yYXRvci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBpbmNvcnJlY3RseVVzZWRBc0RlY29yYXRvcihtZXRob2ROYW1lKSB7XG4gICAgZmFpbChcIkV4cGVjdGVkIG9uZSBvciB0d28gYXJndW1lbnRzIHRvIG9ic2VydmFibGUuXCIgKyBtZXRob2ROYW1lICsgXCIuIERpZCB5b3UgYWNjaWRlbnRhbGx5IHRyeSB0byB1c2Ugb2JzZXJ2YWJsZS5cIiArIG1ldGhvZE5hbWUgKyBcIiBhcyBkZWNvcmF0b3I/XCIpO1xufVxuXG5mdW5jdGlvbiBpc01vZGlmaWVyRGVzY3JpcHRvcih0aGluZykge1xuICAgIHJldHVybiB0eXBlb2YgdGhpbmcgPT09IFwib2JqZWN0XCIgJiYgdGhpbmcgIT09IG51bGwgJiYgdGhpbmcuaXNNb2J4TW9kaWZpZXJEZXNjcmlwdG9yID09PSB0cnVlO1xufVxuZnVuY3Rpb24gY3JlYXRlTW9kaWZpZXJEZXNjcmlwdG9yKGVuaGFuY2VyLCBpbml0aWFsVmFsdWUpIHtcbiAgICBpbnZhcmlhbnQoIWlzTW9kaWZpZXJEZXNjcmlwdG9yKGluaXRpYWxWYWx1ZSksIFwiTW9kaWZpZXJzIGNhbm5vdCBiZSBuZXN0ZWRcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNNb2J4TW9kaWZpZXJEZXNjcmlwdG9yOiB0cnVlLFxuICAgICAgICBpbml0aWFsVmFsdWU6IGluaXRpYWxWYWx1ZSxcbiAgICAgICAgZW5oYW5jZXI6IGVuaGFuY2VyXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGRlZXBFbmhhbmNlcih2LCBfLCBuYW1lKSB7XG4gICAgaWYgKGlzTW9kaWZpZXJEZXNjcmlwdG9yKHYpKVxuICAgICAgICBmYWlsKFwiWW91IHRyaWVkIHRvIGFzc2lnbiBhIG1vZGlmaWVyIHdyYXBwZWQgdmFsdWUgdG8gYSBjb2xsZWN0aW9uLCBwbGVhc2UgZGVmaW5lIG1vZGlmaWVycyB3aGVuIGNyZWF0aW5nIHRoZSBjb2xsZWN0aW9uLCBub3Qgd2hlbiBtb2RpZnlpbmcgaXRcIik7XG4gICAgLy8gaXQgaXMgYW4gb2JzZXJ2YWJsZSBhbHJlYWR5LCBkb25lXG4gICAgaWYgKGlzT2JzZXJ2YWJsZSh2KSlcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgLy8gc29tZXRoaW5nIHRoYXQgY2FuIGJlIGNvbnZlcnRlZCBhbmQgbXV0YXRlZD9cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2KSlcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGUuYXJyYXkodiwgbmFtZSk7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QodikpXG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlLm9iamVjdCh2LCBuYW1lKTtcbiAgICBpZiAoaXNFUzZNYXAodikpXG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlLm1hcCh2LCBuYW1lKTtcbiAgICByZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dFbmhhbmNlcih2LCBfLCBuYW1lKSB7XG4gICAgaWYgKGlzTW9kaWZpZXJEZXNjcmlwdG9yKHYpKVxuICAgICAgICBmYWlsKFwiWW91IHRyaWVkIHRvIGFzc2lnbiBhIG1vZGlmaWVyIHdyYXBwZWQgdmFsdWUgdG8gYSBjb2xsZWN0aW9uLCBwbGVhc2UgZGVmaW5lIG1vZGlmaWVycyB3aGVuIGNyZWF0aW5nIHRoZSBjb2xsZWN0aW9uLCBub3Qgd2hlbiBtb2RpZnlpbmcgaXRcIik7XG4gICAgaWYgKHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsKVxuICAgICAgICByZXR1cm4gdjtcbiAgICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KHYpIHx8IGlzT2JzZXJ2YWJsZUFycmF5KHYpIHx8IGlzT2JzZXJ2YWJsZU1hcCh2KSlcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodikpXG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlLnNoYWxsb3dBcnJheSh2LCBuYW1lKTtcbiAgICBpZiAoaXNQbGFpbk9iamVjdCh2KSlcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGUuc2hhbGxvd09iamVjdCh2LCBuYW1lKTtcbiAgICBpZiAoaXNFUzZNYXAodikpXG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlLnNoYWxsb3dNYXAodiwgbmFtZSk7XG4gICAgcmV0dXJuIGZhaWwoXCJUaGUgc2hhbGxvdyBtb2RpZmllciAvIGRlY29yYXRvciBjYW4gb25seSB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggYXJyYXlzLCBvYmplY3RzIGFuZCBtYXBzXCIpO1xufVxuZnVuY3Rpb24gcmVmZXJlbmNlRW5oYW5jZXIobmV3VmFsdWUpIHtcbiAgICAvLyBuZXZlciB0dXJuIGludG8gYW4gb2JzZXJ2YWJsZVxuICAgIHJldHVybiBuZXdWYWx1ZTtcbn1cbmZ1bmN0aW9uIGRlZXBTdHJ1Y3RFbmhhbmNlcih2LCBvbGRWYWx1ZSwgbmFtZSkge1xuICAgIC8vIGRvbid0IGNvbmZ1c2Ugc3RydWN0dXJhbGx5IGNvbXBhcmUgZW5oYW5jZXIgd2l0aCByZWYgZW5oYW5jZXIhIFRoZSBsYXR0ZXIgaXMgcHJvYmFibHlcbiAgICAvLyBtb3JlIHN1aXRlZCBmb3IgaW1tdXRhYmxlIG9iamVjdHNcbiAgICBpZiAoZGVlcEVxdWFsKHYsIG9sZFZhbHVlKSlcbiAgICAgICAgcmV0dXJuIG9sZFZhbHVlO1xuICAgIC8vIGl0IGlzIGFuIG9ic2VydmFibGUgYWxyZWFkeSwgZG9uZVxuICAgIGlmIChpc09ic2VydmFibGUodikpXG4gICAgICAgIHJldHVybiB2O1xuICAgIC8vIHNvbWV0aGluZyB0aGF0IGNhbiBiZSBjb252ZXJ0ZWQgYW5kIG11dGF0ZWQ/XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodikpXG4gICAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZUFycmF5KHYsIGRlZXBTdHJ1Y3RFbmhhbmNlciwgbmFtZSk7XG4gICAgaWYgKGlzRVM2TWFwKHYpKVxuICAgICAgICByZXR1cm4gbmV3IE9ic2VydmFibGVNYXAodiwgZGVlcFN0cnVjdEVuaGFuY2VyLCBuYW1lKTtcbiAgICBpZiAoaXNQbGFpbk9iamVjdCh2KSkge1xuICAgICAgICB2YXIgcmVzID0ge307XG4gICAgICAgIGFzT2JzZXJ2YWJsZU9iamVjdChyZXMsIG5hbWUpO1xuICAgICAgICBleHRlbmRPYnNlcnZhYmxlSGVscGVyKHJlcywgZGVlcFN0cnVjdEVuaGFuY2VyLCBbdl0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIHJlZlN0cnVjdEVuaGFuY2VyKHYsIG9sZFZhbHVlLCBuYW1lKSB7XG4gICAgaWYgKGRlZXBFcXVhbCh2LCBvbGRWYWx1ZSkpXG4gICAgICAgIHJldHVybiBvbGRWYWx1ZTtcbiAgICByZXR1cm4gdjtcbn1cblxuLyoqXG4gKiBEdXJpbmcgYSB0cmFuc2FjdGlvbiBubyB2aWV3cyBhcmUgdXBkYXRlZCB1bnRpbCB0aGUgZW5kIG9mIHRoZSB0cmFuc2FjdGlvbi5cbiAqIFRoZSB0cmFuc2FjdGlvbiB3aWxsIGJlIHJ1biBzeW5jaHJvbm91c2x5IG5vbmV0aGVsZXNzLlxuICpcbiAqIEBwYXJhbSBhY3Rpb24gYSBmdW5jdGlvbiB0aGF0IHVwZGF0ZXMgc29tZSByZWFjdGl2ZSBzdGF0ZVxuICogQHJldHVybnMgYW55IHZhbHVlIHRoYXQgd2FzIHJldHVybmVkIGJ5IHRoZSAnYWN0aW9uJyBwYXJhbWV0ZXIuXG4gKi9cbmZ1bmN0aW9uIHRyYW5zYWN0aW9uKGFjdGlvbiwgdGhpc0FyZykge1xuICAgIGlmICh0aGlzQXJnID09PSB2b2lkIDApIHsgdGhpc0FyZyA9IHVuZGVmaW5lZDsgfVxuICAgIHN0YXJ0QmF0Y2goKTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gYWN0aW9uLmFwcGx5KHRoaXNBcmcpO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgZW5kQmF0Y2goKTtcbiAgICB9XG59XG5cbnZhciBPYnNlcnZhYmxlTWFwTWFya2VyID0ge307XG52YXIgT2JzZXJ2YWJsZU1hcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT2JzZXJ2YWJsZU1hcChpbml0aWFsRGF0YSwgZW5oYW5jZXIsIG5hbWUpIHtcbiAgICAgICAgaWYgKGVuaGFuY2VyID09PSB2b2lkIDApIHsgZW5oYW5jZXIgPSBkZWVwRW5oYW5jZXI7IH1cbiAgICAgICAgaWYgKG5hbWUgPT09IHZvaWQgMCkgeyBuYW1lID0gXCJPYnNlcnZhYmxlTWFwQFwiICsgZ2V0TmV4dElkKCk7IH1cbiAgICAgICAgdGhpcy5lbmhhbmNlciA9IGVuaGFuY2VyO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLiRtb2J4ID0gT2JzZXJ2YWJsZU1hcE1hcmtlcjtcbiAgICAgICAgdGhpcy5fZGF0YSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2hhc01hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7IC8vIGhhc01hcCwgbm90IGhhc2hNYXAgPi0pLlxuICAgICAgICB0aGlzLl9rZXlzID0gbmV3IE9ic2VydmFibGVBcnJheSh1bmRlZmluZWQsIHJlZmVyZW5jZUVuaGFuY2VyLCB0aGlzLm5hbWUgKyBcIi5rZXlzKClcIiwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuaW50ZXJjZXB0b3JzID0gbnVsbDtcbiAgICAgICAgdGhpcy5jaGFuZ2VMaXN0ZW5lcnMgPSBudWxsO1xuICAgICAgICB0aGlzLmRlaGFuY2VyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm1lcmdlKGluaXRpYWxEYXRhKTtcbiAgICB9XG4gICAgT2JzZXJ2YWJsZU1hcC5wcm90b3R5cGUuX2hhcyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLl9kYXRhW2tleV0gIT09IFwidW5kZWZpbmVkXCI7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlTWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkS2V5KGtleSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGtleSA9IFwiXCIgKyBrZXk7XG4gICAgICAgIGlmICh0aGlzLl9oYXNNYXBba2V5XSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYXNNYXBba2V5XS5nZXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZUhhc01hcEVudHJ5KGtleSwgZmFsc2UpLmdldCgpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZU1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRWYWxpZEtleShrZXkpO1xuICAgICAgICBrZXkgPSBcIlwiICsga2V5O1xuICAgICAgICB2YXIgaGFzS2V5ID0gdGhpcy5faGFzKGtleSk7XG4gICAgICAgIGlmIChoYXNJbnRlcmNlcHRvcnModGhpcykpIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2UgPSBpbnRlcmNlcHRDaGFuZ2UodGhpcywge1xuICAgICAgICAgICAgICAgIHR5cGU6IGhhc0tleSA/IFwidXBkYXRlXCIgOiBcImFkZFwiLFxuICAgICAgICAgICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgbmFtZToga2V5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghY2hhbmdlKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgdmFsdWUgPSBjaGFuZ2UubmV3VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0tleSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVmFsdWUoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRWYWx1ZShrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIE9ic2VydmFibGVNYXAucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5hc3NlcnRWYWxpZEtleShrZXkpO1xuICAgICAgICBrZXkgPSBcIlwiICsga2V5O1xuICAgICAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKHRoaXMpKSB7XG4gICAgICAgICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImRlbGV0ZVwiLFxuICAgICAgICAgICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgICAgICAgICBuYW1lOiBrZXlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFjaGFuZ2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9oYXMoa2V5KSkge1xuICAgICAgICAgICAgdmFyIG5vdGlmeVNweSA9IGlzU3B5RW5hYmxlZCgpO1xuICAgICAgICAgICAgdmFyIG5vdGlmeSA9IGhhc0xpc3RlbmVycyh0aGlzKTtcbiAgICAgICAgICAgIHZhciBjaGFuZ2UgPSBub3RpZnkgfHwgbm90aWZ5U3B5XG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZGVsZXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWU6IHRoaXMuX2RhdGFba2V5XS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZToga2V5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChub3RpZnlTcHkpXG4gICAgICAgICAgICAgICAgc3B5UmVwb3J0U3RhcnQoY2hhbmdlKTtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fa2V5cy5yZW1vdmUoa2V5KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdXBkYXRlSGFzTWFwRW50cnkoa2V5LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgdmFyIG9ic2VydmFibGUkJDEgPSBfdGhpcy5fZGF0YVtrZXldO1xuICAgICAgICAgICAgICAgIG9ic2VydmFibGUkJDEuc2V0TmV3VmFsdWUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fZGF0YVtrZXldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAobm90aWZ5KVxuICAgICAgICAgICAgICAgIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBjaGFuZ2UpO1xuICAgICAgICAgICAgaWYgKG5vdGlmeVNweSlcbiAgICAgICAgICAgICAgICBzcHlSZXBvcnRFbmQoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIE9ic2VydmFibGVNYXAucHJvdG90eXBlLl91cGRhdGVIYXNNYXBFbnRyeSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIC8vIG9wdGltaXphdGlvbjsgZG9uJ3QgZmlsbCB0aGUgaGFzTWFwIGlmIHdlIGFyZSBub3Qgb2JzZXJ2aW5nLCBvciByZW1vdmUgZW50cnkgaWYgdGhlcmUgYXJlIG5vIG9ic2VydmVycyBhbnltb3JlXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMuX2hhc01hcFtrZXldO1xuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgIGVudHJ5LnNldE5ld1ZhbHVlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5faGFzTWFwW2tleV0gPSBuZXcgT2JzZXJ2YWJsZVZhbHVlKHZhbHVlLCByZWZlcmVuY2VFbmhhbmNlciwgdGhpcy5uYW1lICsgXCIuXCIgKyBrZXkgKyBcIj9cIiwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnRyeTtcbiAgICB9O1xuICAgIE9ic2VydmFibGVNYXAucHJvdG90eXBlLl91cGRhdGVWYWx1ZSA9IGZ1bmN0aW9uIChuYW1lLCBuZXdWYWx1ZSkge1xuICAgICAgICB2YXIgb2JzZXJ2YWJsZSQkMSA9IHRoaXMuX2RhdGFbbmFtZV07XG4gICAgICAgIG5ld1ZhbHVlID0gb2JzZXJ2YWJsZSQkMS5wcmVwYXJlTmV3VmFsdWUobmV3VmFsdWUpO1xuICAgICAgICBpZiAobmV3VmFsdWUgIT09IFVOQ0hBTkdFRCkge1xuICAgICAgICAgICAgdmFyIG5vdGlmeVNweSA9IGlzU3B5RW5hYmxlZCgpO1xuICAgICAgICAgICAgdmFyIG5vdGlmeSA9IGhhc0xpc3RlbmVycyh0aGlzKTtcbiAgICAgICAgICAgIHZhciBjaGFuZ2UgPSBub3RpZnkgfHwgbm90aWZ5U3B5XG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidXBkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWU6IG9ic2VydmFibGUkJDEudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICBpZiAobm90aWZ5U3B5KVxuICAgICAgICAgICAgICAgIHNweVJlcG9ydFN0YXJ0KGNoYW5nZSk7XG4gICAgICAgICAgICBvYnNlcnZhYmxlJCQxLnNldE5ld1ZhbHVlKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIGlmIChub3RpZnkpXG4gICAgICAgICAgICAgICAgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIGNoYW5nZSk7XG4gICAgICAgICAgICBpZiAobm90aWZ5U3B5KVxuICAgICAgICAgICAgICAgIHNweVJlcG9ydEVuZCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlTWFwLnByb3RvdHlwZS5fYWRkVmFsdWUgPSBmdW5jdGlvbiAobmFtZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdHJhbnNhY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9ic2VydmFibGUkJDEgPSAoX3RoaXMuX2RhdGFbbmFtZV0gPSBuZXcgT2JzZXJ2YWJsZVZhbHVlKG5ld1ZhbHVlLCBfdGhpcy5lbmhhbmNlciwgX3RoaXMubmFtZSArIFwiLlwiICsgbmFtZSwgZmFsc2UpKTtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gb2JzZXJ2YWJsZSQkMS52YWx1ZTsgLy8gdmFsdWUgbWlnaHQgaGF2ZSBiZWVuIGNoYW5nZWRcbiAgICAgICAgICAgIF90aGlzLl91cGRhdGVIYXNNYXBFbnRyeShuYW1lLCB0cnVlKTtcbiAgICAgICAgICAgIF90aGlzLl9rZXlzLnB1c2gobmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbm90aWZ5U3B5ID0gaXNTcHlFbmFibGVkKCk7XG4gICAgICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG4gICAgICAgIHZhciBjaGFuZ2UgPSBub3RpZnkgfHwgbm90aWZ5U3B5XG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFkZFwiLFxuICAgICAgICAgICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBpZiAobm90aWZ5U3B5KVxuICAgICAgICAgICAgc3B5UmVwb3J0U3RhcnQoY2hhbmdlKTtcbiAgICAgICAgaWYgKG5vdGlmeSlcbiAgICAgICAgICAgIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBjaGFuZ2UpO1xuICAgICAgICBpZiAobm90aWZ5U3B5KVxuICAgICAgICAgICAgc3B5UmVwb3J0RW5kKCk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGtleSA9IFwiXCIgKyBrZXk7XG4gICAgICAgIGlmICh0aGlzLmhhcyhrZXkpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVoYW5jZVZhbHVlKHRoaXMuX2RhdGFba2V5XS5nZXQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmRlaGFuY2VWYWx1ZSh1bmRlZmluZWQpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZU1hcC5wcm90b3R5cGUuZGVoYW5jZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmRlaGFuY2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlaGFuY2VyKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlTWFwLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJyYXlBc0l0ZXJhdG9yKHRoaXMuX2tleXMuc2xpY2UoKSk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlTWFwLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcnJheUFzSXRlcmF0b3IodGhpcy5fa2V5cy5tYXAodGhpcy5nZXQsIHRoaXMpKTtcbiAgICB9O1xuICAgIE9ic2VydmFibGVNYXAucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBhcnJheUFzSXRlcmF0b3IodGhpcy5fa2V5cy5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gW2tleSwgX3RoaXMuZ2V0KGtleSldOyB9KSk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlTWFwLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMua2V5cygpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzQXJnLCBfdGhpcy5nZXQoa2V5KSwga2V5LCBfdGhpcyk7IH0pO1xuICAgIH07XG4gICAgLyoqIE1lcmdlIGFub3RoZXIgb2JqZWN0IGludG8gdGhpcyBvYmplY3QsIHJldHVybnMgdGhpcy4gKi9cbiAgICBPYnNlcnZhYmxlTWFwLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoaXNPYnNlcnZhYmxlTWFwKG90aGVyKSkge1xuICAgICAgICAgICAgb3RoZXIgPSBvdGhlci50b0pTKCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNhY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGlzUGxhaW5PYmplY3Qob3RoZXIpKVxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKG90aGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIF90aGlzLnNldChrZXksIG90aGVyW2tleV0pOyB9KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob3RoZXIpKVxuICAgICAgICAgICAgICAgIG90aGVyLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfYVswXSwgdmFsdWUgPSBfYVsxXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRVM2TWFwKG90aGVyKSlcbiAgICAgICAgICAgICAgICBvdGhlci5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7IHJldHVybiBfdGhpcy5zZXQoa2V5LCB2YWx1ZSk7IH0pO1xuICAgICAgICAgICAgZWxzZSBpZiAob3RoZXIgIT09IG51bGwgJiYgb3RoZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBmYWlsKFwiQ2Fubm90IGluaXRpYWxpemUgbWFwIGZyb20gXCIgKyBvdGhlcik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIE9ic2VydmFibGVNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0cmFuc2FjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB1bnRyYWNrZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmtleXMoKS5mb3JFYWNoKF90aGlzLmRlbGV0ZSwgX3RoaXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZU1hcC5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdHJhbnNhY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gZ3JhYiBhbGwgdGhlIGtleXMgdGhhdCBhcmUgcHJlc2VudCBpbiB0aGUgbmV3IG1hcCBidXQgbm90IHByZXNlbnQgaW4gdGhlIGN1cnJlbnQgbWFwXG4gICAgICAgICAgICAvLyBhbmQgZGVsZXRlIHRoZW0gZnJvbSB0aGUgbWFwLCB0aGVuIG1lcmdlIHRoZSBuZXcgbWFwXG4gICAgICAgICAgICAvLyB0aGlzIHdpbGwgY2F1c2UgcmVhY3Rpb25zIG9ubHkgb24gY2hhbmdlZCB2YWx1ZXNcbiAgICAgICAgICAgIHZhciBuZXdLZXlzID0gZ2V0TWFwTGlrZUtleXModmFsdWVzKTtcbiAgICAgICAgICAgIHZhciBvbGRLZXlzID0gX3RoaXMua2V5cygpO1xuICAgICAgICAgICAgdmFyIG1pc3NpbmdLZXlzID0gb2xkS2V5cy5maWx0ZXIoZnVuY3Rpb24gKGspIHsgcmV0dXJuIG5ld0tleXMuaW5kZXhPZihrKSA9PT0gLTE7IH0pO1xuICAgICAgICAgICAgbWlzc2luZ0tleXMuZm9yRWFjaChmdW5jdGlvbiAoaykgeyByZXR1cm4gX3RoaXMuZGVsZXRlKGspOyB9KTtcbiAgICAgICAgICAgIF90aGlzLm1lcmdlKHZhbHVlcyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYnNlcnZhYmxlTWFwLnByb3RvdHlwZSwgXCJzaXplXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fa2V5cy5sZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzaGFsbG93IG5vbiBvYnNlcnZhYmxlIG9iamVjdCBjbG9uZSBvZiB0aGlzIG1hcC5cbiAgICAgKiBOb3RlIHRoYXQgdGhlIHZhbHVlcyBtaWdodCBzdGlsbCBiZSBvYnNlcnZhYmxlLiBGb3IgYSBkZWVwIGNsb25lIHVzZSBtb2J4LnRvSlMuXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZU1hcC5wcm90b3R5cGUudG9KUyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJlcyA9IHt9O1xuICAgICAgICB0aGlzLmtleXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIChyZXNba2V5XSA9IF90aGlzLmdldChrZXkpKTsgfSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlTWFwLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFVzZWQgYnkgSlNPTi5zdHJpbmdpZnlcbiAgICAgICAgcmV0dXJuIHRoaXMudG9KUygpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZU1hcC5wcm90b3R5cGUuaXNWYWxpZEtleSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gbnVsbCB8fCBrZXkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGtleSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2Yga2V5ID09PSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlTWFwLnByb3RvdHlwZS5hc3NlcnRWYWxpZEtleSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWRLZXkoa2V5KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlttb2J4Lm1hcF0gSW52YWxpZCBrZXk6ICdcIiArIGtleSArIFwiJywgb25seSBzdHJpbmdzLCBudW1iZXJzIGFuZCBib29sZWFucyBhcmUgYWNjZXB0ZWQgYXMga2V5IGluIG9ic2VydmFibGUgbWFwcy5cIik7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlTWFwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuICh0aGlzLm5hbWUgK1xuICAgICAgICAgICAgXCJbeyBcIiArXG4gICAgICAgICAgICB0aGlzLmtleXMoKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4ga2V5ICsgXCI6IFwiICsgKFwiXCIgKyBfdGhpcy5nZXQoa2V5KSk7IH0pLmpvaW4oXCIsIFwiKSArXG4gICAgICAgICAgICBcIiB9XVwiKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE9ic2VydmVzIHRoaXMgb2JqZWN0LiBUcmlnZ2VycyBmb3IgdGhlIGV2ZW50cyAnYWRkJywgJ3VwZGF0ZScgYW5kICdkZWxldGUnLlxuICAgICAqIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L29ic2VydmVcbiAgICAgKiBmb3IgY2FsbGJhY2sgZGV0YWlsc1xuICAgICAqL1xuICAgIE9ic2VydmFibGVNYXAucHJvdG90eXBlLm9ic2VydmUgPSBmdW5jdGlvbiAobGlzdGVuZXIsIGZpcmVJbW1lZGlhdGVseSkge1xuICAgICAgICBpbnZhcmlhbnQoZmlyZUltbWVkaWF0ZWx5ICE9PSB0cnVlLCBnZXRNZXNzYWdlKFwibTAzM1wiKSk7XG4gICAgICAgIHJldHVybiByZWdpc3Rlckxpc3RlbmVyKHRoaXMsIGxpc3RlbmVyKTtcbiAgICB9O1xuICAgIE9ic2VydmFibGVNYXAucHJvdG90eXBlLmludGVyY2VwdCA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiByZWdpc3RlckludGVyY2VwdG9yKHRoaXMsIGhhbmRsZXIpO1xuICAgIH07XG4gICAgcmV0dXJuIE9ic2VydmFibGVNYXA7XG59KCkpO1xuZGVjbGFyZUl0ZXJhdG9yKE9ic2VydmFibGVNYXAucHJvdG90eXBlLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllcygpO1xufSk7XG5mdW5jdGlvbiBtYXAoaW5pdGlhbFZhbHVlcykge1xuICAgIGRlcHJlY2F0ZWQoXCJgbW9ieC5tYXBgIGlzIGRlcHJlY2F0ZWQsIHVzZSBgbmV3IE9ic2VydmFibGVNYXBgIG9yIGBtb2J4Lm9ic2VydmFibGUubWFwYCBpbnN0ZWFkXCIpO1xuICAgIHJldHVybiBvYnNlcnZhYmxlLm1hcChpbml0aWFsVmFsdWVzKTtcbn1cbi8qICd2YXInIGZpeGVzIHNtYWxsLWJ1aWxkIGlzc3VlICovXG52YXIgaXNPYnNlcnZhYmxlTWFwID0gY3JlYXRlSW5zdGFuY2VvZlByZWRpY2F0ZShcIk9ic2VydmFibGVNYXBcIiwgT2JzZXJ2YWJsZU1hcCk7XG5cbnZhciBFTVBUWV9BUlJBWSA9IFtdO1xuT2JqZWN0LmZyZWV6ZShFTVBUWV9BUlJBWSk7XG5mdW5jdGlvbiBnZXRHbG9iYWwoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiBnbG9iYWw7XG59XG5mdW5jdGlvbiBnZXROZXh0SWQoKSB7XG4gICAgcmV0dXJuICsrZ2xvYmFsU3RhdGUubW9ieEd1aWQ7XG59XG5mdW5jdGlvbiBmYWlsKG1lc3NhZ2UsIHRoaW5nKSB7XG4gICAgaW52YXJpYW50KGZhbHNlLCBtZXNzYWdlLCB0aGluZyk7XG4gICAgdGhyb3cgXCJYXCI7IC8vIHVucmVhY2hhYmxlXG59XG5mdW5jdGlvbiBpbnZhcmlhbnQoY2hlY2ssIG1lc3NhZ2UsIHRoaW5nKSB7XG4gICAgaWYgKCFjaGVjaylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW21vYnhdIEludmFyaWFudCBmYWlsZWQ6IFwiICsgbWVzc2FnZSArICh0aGluZyA/IFwiIGluICdcIiArIHRoaW5nICsgXCInXCIgOiBcIlwiKSk7XG59XG4vKipcbiAqIFByaW50cyBhIGRlcHJlY2F0aW9uIG1lc3NhZ2UsIGJ1dCBvbmx5IG9uZSB0aW1lLlxuICogUmV0dXJucyBmYWxzZSBpZiB0aGUgZGVwcmVjYXRlZCBtZXNzYWdlIHdhcyBhbHJlYWR5IHByaW50ZWQgYmVmb3JlXG4gKi9cbnZhciBkZXByZWNhdGVkTWVzc2FnZXMgPSBbXTtcbmZ1bmN0aW9uIGRlcHJlY2F0ZWQobXNnKSB7XG4gICAgaWYgKGRlcHJlY2F0ZWRNZXNzYWdlcy5pbmRleE9mKG1zZykgIT09IC0xKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGVwcmVjYXRlZE1lc3NhZ2VzLnB1c2gobXNnKTtcbiAgICBjb25zb2xlLmVycm9yKFwiW21vYnhdIERlcHJlY2F0ZWQ6IFwiICsgbXNnKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogTWFrZXMgc3VyZSB0aGF0IHRoZSBwcm92aWRlZCBmdW5jdGlvbiBpcyBpbnZva2VkIGF0IG1vc3Qgb25jZS5cbiAqL1xuZnVuY3Rpb24gb25jZShmdW5jKSB7XG4gICAgdmFyIGludm9rZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW52b2tlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaW52b2tlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cbnZhciBub29wID0gZnVuY3Rpb24gKCkgeyB9O1xuZnVuY3Rpb24gdW5pcXVlKGxpc3QpIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmIChyZXMuaW5kZXhPZihpdGVtKSA9PT0gLTEpXG4gICAgICAgICAgICByZXMucHVzaChpdGVtKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gam9pblN0cmluZ3ModGhpbmdzLCBsaW1pdCwgc2VwYXJhdG9yKSB7XG4gICAgaWYgKGxpbWl0ID09PSB2b2lkIDApIHsgbGltaXQgPSAxMDA7IH1cbiAgICBpZiAoc2VwYXJhdG9yID09PSB2b2lkIDApIHsgc2VwYXJhdG9yID0gXCIgLSBcIjsgfVxuICAgIGlmICghdGhpbmdzKVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB2YXIgc2xpY2VkID0gdGhpbmdzLnNsaWNlKDAsIGxpbWl0KTtcbiAgICByZXR1cm4gXCJcIiArIHNsaWNlZC5qb2luKHNlcGFyYXRvcikgKyAodGhpbmdzLmxlbmd0aCA+IGxpbWl0XG4gICAgICAgID8gXCIgKC4uLiBhbmQgXCIgKyAodGhpbmdzLmxlbmd0aCAtIGxpbWl0KSArIFwibW9yZSlcIlxuICAgICAgICA6IFwiXCIpO1xufVxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xufVxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICAgIHJldHVybiBwcm90byA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fCBwcm90byA9PT0gbnVsbDtcbn1cbmZ1bmN0aW9uIG9iamVjdEFzc2lnbigpIHtcbiAgICB2YXIgcmVzID0gYXJndW1lbnRzWzBdO1xuICAgIGZvciAodmFyIGkgPSAxLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKVxuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5KHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIHJlc1trZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG52YXIgcHJvdG90eXBlSGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqZWN0LCBwcm9wTmFtZSkge1xuICAgIHJldHVybiBwcm90b3R5cGVIYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcE5hbWUpO1xufVxuZnVuY3Rpb24gbWFrZU5vbkVudW1lcmFibGUob2JqZWN0LCBwcm9wTmFtZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhZGRIaWRkZW5Qcm9wKG9iamVjdCwgcHJvcE5hbWVzW2ldLCBvYmplY3RbcHJvcE5hbWVzW2ldXSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkSGlkZGVuUHJvcChvYmplY3QsIHByb3BOYW1lLCB2YWx1ZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BOYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGFkZEhpZGRlbkZpbmFsUHJvcChvYmplY3QsIHByb3BOYW1lLCB2YWx1ZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BOYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfSk7XG59XG5mdW5jdGlvbiBpc1Byb3BlcnR5Q29uZmlndXJhYmxlKG9iamVjdCwgcHJvcCkge1xuICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3ApO1xuICAgIHJldHVybiAhZGVzY3JpcHRvciB8fCAoZGVzY3JpcHRvci5jb25maWd1cmFibGUgIT09IGZhbHNlICYmIGRlc2NyaXB0b3Iud3JpdGFibGUgIT09IGZhbHNlKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFByb3BlcnR5Q29uZmlndXJhYmxlKG9iamVjdCwgcHJvcCkge1xuICAgIGludmFyaWFudChpc1Byb3BlcnR5Q29uZmlndXJhYmxlKG9iamVjdCwgcHJvcCksIFwiQ2Fubm90IG1ha2UgcHJvcGVydHkgJ1wiICsgcHJvcCArIFwiJyBvYnNlcnZhYmxlLCBpdCBpcyBub3QgY29uZmlndXJhYmxlIGFuZCB3cml0YWJsZSBpbiB0aGUgdGFyZ2V0IG9iamVjdFwiKTtcbn1cbmZ1bmN0aW9uIGdldEVudW1lcmFibGVLZXlzKG9iaikge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKVxuICAgICAgICByZXMucHVzaChrZXkpO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIE5haXZlIGRlZXBFcXVhbC4gRG9lc24ndCBjaGVjayBmb3IgcHJvdG90eXBlLCBub24tZW51bWVyYWJsZSBvciBvdXQtb2YtcmFuZ2UgcHJvcGVydGllcyBvbiBhcnJheXMuXG4gKiBJZiB5b3UgaGF2ZSBzdWNoIGEgY2FzZSwgeW91IHByb2JhYmx5IHNob3VsZCB1c2UgdGhpcyBmdW5jdGlvbiBidXQgc29tZXRoaW5nIGZhbmNpZXIgOikuXG4gKi9cbmZ1bmN0aW9uIGRlZXBFcXVhbChhLCBiKSB7XG4gICAgaWYgKGEgPT09IG51bGwgJiYgYiA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGEgPT09IHVuZGVmaW5lZCAmJiBiID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChhcmVCb3RoTmFOKGEsIGIpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodHlwZW9mIGEgIT09IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybiBhID09PSBiO1xuICAgIHZhciBhSXNBcnJheSA9IGlzQXJyYXlMaWtlKGEpO1xuICAgIHZhciBhSXNNYXAgPSBpc01hcExpa2UoYSk7XG4gICAgaWYgKGFJc0FycmF5ICE9PSBpc0FycmF5TGlrZShiKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFJc01hcCAhPT0gaXNNYXBMaWtlKGIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYUlzQXJyYXkpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICBpZiAoIWRlZXBFcXVhbChhW2ldLCBiW2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChhSXNNYXApIHtcbiAgICAgICAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZXF1YWxzXzEgPSB0cnVlO1xuICAgICAgICBhLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIGVxdWFsc18xID0gZXF1YWxzXzEgJiYgZGVlcEVxdWFsKGIuZ2V0KGtleSksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlcXVhbHNfMTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGEgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGIgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKGEgPT09IG51bGwgfHwgYiA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGlzTWFwTGlrZShhKSAmJiBpc01hcExpa2UoYikpIHtcbiAgICAgICAgICAgIGlmIChhLnNpemUgIT09IGIuc2l6ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAvLyBGcmVha2luZyBpbmVmZmljaWVudC4uLi4gQ3JlYXRlIFBSIGlmIHlvdSBydW4gaW50byB0aGlzIDopIE11Y2ggYXBwcmVjaWF0ZWQhXG4gICAgICAgICAgICByZXR1cm4gZGVlcEVxdWFsKG9ic2VydmFibGUuc2hhbGxvd01hcChhKS5lbnRyaWVzKCksIG9ic2VydmFibGUuc2hhbGxvd01hcChiKS5lbnRyaWVzKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZXRFbnVtZXJhYmxlS2V5cyhhKS5sZW5ndGggIT09IGdldEVudW1lcmFibGVLZXlzKGIpLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBhKSB7XG4gICAgICAgICAgICBpZiAoIShwcm9wIGluIGIpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICghZGVlcEVxdWFsKGFbcHJvcF0sIGJbcHJvcF0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VvZlByZWRpY2F0ZShuYW1lLCBjbGF6eikge1xuICAgIHZhciBwcm9wTmFtZSA9IFwiaXNNb2JYXCIgKyBuYW1lO1xuICAgIGNsYXp6LnByb3RvdHlwZVtwcm9wTmFtZV0gPSB0cnVlO1xuICAgIHJldHVybiBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gaXNPYmplY3QoeCkgJiYgeFtwcm9wTmFtZV0gPT09IHRydWU7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFyZUJvdGhOYU4oYSwgYikge1xuICAgIHJldHVybiAodHlwZW9mIGEgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIGIgPT09IFwibnVtYmVyXCIgJiYgaXNOYU4oYSkgJiYgaXNOYU4oYikpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGFyZ3VtZW50IGlzIGFuIGFycmF5LCBkaXNyZWdhcmRpbmcgb2JzZXJ2YWJpbGl0eS5cbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UoeCkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHgpIHx8IGlzT2JzZXJ2YWJsZUFycmF5KHgpO1xufVxuZnVuY3Rpb24gaXNNYXBMaWtlKHgpIHtcbiAgICByZXR1cm4gaXNFUzZNYXAoeCkgfHwgaXNPYnNlcnZhYmxlTWFwKHgpO1xufVxuZnVuY3Rpb24gaXNFUzZNYXAodGhpbmcpIHtcbiAgICBpZiAoZ2V0R2xvYmFsKCkuTWFwICE9PSB1bmRlZmluZWQgJiYgdGhpbmcgaW5zdGFuY2VvZiBnZXRHbG9iYWwoKS5NYXApXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldE1hcExpa2VLZXlzKG1hcCQkMSkge1xuICAgIHZhciBrZXlzO1xuICAgIGlmIChpc1BsYWluT2JqZWN0KG1hcCQkMSkpXG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhtYXAkJDEpO1xuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobWFwJCQxKSlcbiAgICAgICAga2V5cyA9IG1hcCQkMS5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gX2FbMF07XG4gICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9KTtcbiAgICBlbHNlIGlmIChpc01hcExpa2UobWFwJCQxKSlcbiAgICAgICAga2V5cyA9IEFycmF5LmZyb20obWFwJCQxLmtleXMoKSk7XG4gICAgZWxzZVxuICAgICAgICBmYWlsKFwiQ2Fubm90IGdldCBrZXlzIGZyb20gXCIgKyBtYXAkJDEpO1xuICAgIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gcHJpbWl0aXZlU3ltYm9sKCkge1xuICAgIHJldHVybiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC50b1ByaW1pdGl2ZSkgfHwgXCJAQHRvUHJpbWl0aXZlXCI7XG59XG5mdW5jdGlvbiB0b1ByaW1pdGl2ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgPyBcIlwiICsgdmFsdWUgOiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBUaGVzZSB2YWx1ZXMgd2lsbCBwZXJzaXN0IGlmIGdsb2JhbCBzdGF0ZSBpcyByZXNldFxuICovXG52YXIgcGVyc2lzdGVudEtleXMgPSBbXCJtb2J4R3VpZFwiLCBcInJlc2V0SWRcIiwgXCJzcHlMaXN0ZW5lcnNcIiwgXCJzdHJpY3RNb2RlXCIsIFwicnVuSWRcIl07XG52YXIgTW9iWEdsb2JhbHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1vYlhHbG9iYWxzKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogTW9iWEdsb2JhbHMgdmVyc2lvbi5cbiAgICAgICAgICogTW9iWCBjb21wYXRpYmxpdHkgd2l0aCBvdGhlciB2ZXJzaW9ucyBsb2FkZWQgaW4gbWVtb3J5IGFzIGxvbmcgYXMgdGhpcyB2ZXJzaW9uIG1hdGNoZXMuXG4gICAgICAgICAqIEl0IGluZGljYXRlcyB0aGF0IHRoZSBnbG9iYWwgc3RhdGUgc3RpbGwgc3RvcmVzIHNpbWlsYXIgaW5mb3JtYXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmVyc2lvbiA9IDU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDdXJyZW50bHkgcnVubmluZyBkZXJpdmF0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyYWNraW5nRGVyaXZhdGlvbiA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcmUgd2UgcnVubmluZyBhIGNvbXB1dGF0aW9uIGN1cnJlbnRseT8gKG5vdCBhIHJlYWN0aW9uKVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb21wdXRhdGlvbkRlcHRoID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVhY2ggdGltZSBhIGRlcml2YXRpb24gaXMgdHJhY2tlZCwgaXQgaXMgYXNzaWduZWQgYSB1bmlxdWUgcnVuLWlkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJ1bklkID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqICdndWlkJyBmb3IgZ2VuZXJhbCBwdXJwb3NlLiBXaWxsIGJlIHBlcnNpc3RlZCBhbW9uZ3N0IHJlc2V0cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubW9ieEd1aWQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogQXJlIHdlIGluIGEgYmF0Y2ggYmxvY2s/IChhbmQgaG93IG1hbnkgb2YgdGhlbSlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5CYXRjaCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPYnNlcnZhYmxlcyB0aGF0IGRvbid0IGhhdmUgb2JzZXJ2ZXJzIGFueW1vcmUsIGFuZCBhcmUgYWJvdXQgdG8gYmVcbiAgICAgICAgICogc3VzcGVuZGVkLCB1bmxlc3Mgc29tZWJvZHkgZWxzZSBhY2Nlc3NlcyBpdCBpbiB0aGUgc2FtZSBiYXRjaFxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7SU9ic2VydmFibGVbXX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGVuZGluZ1Vub2JzZXJ2YXRpb25zID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IG9mIHNjaGVkdWxlZCwgbm90IHlldCBleGVjdXRlZCwgcmVhY3Rpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wZW5kaW5nUmVhY3Rpb25zID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcmUgd2UgY3VycmVudGx5IHByb2Nlc3NpbmcgcmVhY3Rpb25zP1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc1J1bm5pbmdSZWFjdGlvbnMgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIGl0IGFsbG93ZWQgdG8gY2hhbmdlIG9ic2VydmFibGVzIGF0IHRoaXMgcG9pbnQ/XG4gICAgICAgICAqIEluIGdlbmVyYWwsIE1vYlggZG9lc24ndCBhbGxvdyB0aGF0IHdoZW4gcnVubmluZyBjb21wdXRhdGlvbnMgYW5kIFJlYWN0LnJlbmRlci5cbiAgICAgICAgICogVG8gZW5zdXJlIHRoYXQgdGhvc2UgZnVuY3Rpb25zIHN0YXkgcHVyZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWxsb3dTdGF0ZUNoYW5nZXMgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgc3RyaWN0IG1vZGUgaXMgZW5hYmxlZCwgc3RhdGUgY2hhbmdlcyBhcmUgYnkgZGVmYXVsdCBub3QgYWxsb3dlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdHJpY3RNb2RlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VkIGJ5IGNyZWF0ZVRyYW5zZm9ybWVyIHRvIGRldGVjdCB0aGF0IHRoZSBnbG9iYWwgc3RhdGUgaGFzIGJlZW4gcmVzZXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc2V0SWQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3B5IGNhbGxiYWNrc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zcHlMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdsb2JhbGx5IGF0dGFjaGVkIGVycm9yIGhhbmRsZXJzIHRoYXQgcmVhY3Qgc3BlY2lmaWNhbGx5IHRvIGVycm9ycyBpbiByZWFjdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2xvYmFsUmVhY3Rpb25FcnJvckhhbmRsZXJzID0gW107XG4gICAgfVxuICAgIHJldHVybiBNb2JYR2xvYmFscztcbn0oKSk7XG52YXIgZ2xvYmFsU3RhdGUgPSBuZXcgTW9iWEdsb2JhbHMoKTtcbnZhciBzaGFyZUdsb2JhbFN0YXRlQ2FsbGVkID0gZmFsc2U7XG52YXIgcnVuSW5Jc29sYXRpb25DYWxsZWQgPSBmYWxzZTtcbnZhciB3YXJuZWRBYm91dE11bHRpcGxlSW5zdGFuY2VzID0gZmFsc2U7XG57XG4gICAgdmFyIGdsb2JhbF8xID0gZ2V0R2xvYmFsKCk7XG4gICAgaWYgKCFnbG9iYWxfMS5fX21vYnhJbnN0YW5jZUNvdW50KSB7XG4gICAgICAgIGdsb2JhbF8xLl9fbW9ieEluc3RhbmNlQ291bnQgPSAxO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2xvYmFsXzEuX19tb2J4SW5zdGFuY2VDb3VudCsrO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghc2hhcmVHbG9iYWxTdGF0ZUNhbGxlZCAmJiAhcnVuSW5Jc29sYXRpb25DYWxsZWQgJiYgIXdhcm5lZEFib3V0TXVsdGlwbGVJbnN0YW5jZXMpIHtcbiAgICAgICAgICAgICAgICB3YXJuZWRBYm91dE11bHRpcGxlSW5zdGFuY2VzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbbW9ieF0gV2FybmluZzogdGhlcmUgYXJlIG11bHRpcGxlIG1vYnggaW5zdGFuY2VzIGFjdGl2ZS4gVGhpcyBtaWdodCBsZWFkIHRvIHVuZXhwZWN0ZWQgcmVzdWx0cy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb2J4anMvbW9ieC9pc3N1ZXMvMTA4MiBmb3IgZGV0YWlscy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzb2xhdGVHbG9iYWxTdGF0ZSgpIHtcbiAgICBydW5Jbklzb2xhdGlvbkNhbGxlZCA9IHRydWU7XG4gICAgZ2V0R2xvYmFsKCkuX19tb2J4SW5zdGFuY2VDb3VudC0tO1xufVxuZnVuY3Rpb24gc2hhcmVHbG9iYWxTdGF0ZSgpIHtcbiAgICAvLyBUT0RPOiByZW1vdmUgaW4gNC4wOyBqdXN0IHVzZSBwZWVyIGRlcGVuZGVuY2llcyBpbnN0ZWFkLlxuICAgIGRlcHJlY2F0ZWQoXCJVc2luZyBgc2hhcmVHbG9iYWxTdGF0ZWAgaXMgbm90IHJlY29tbWVuZGVkLCB1c2UgcGVlciBkZXBlbmRlbmNpZXMgaW5zdGVhZC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb2J4anMvbW9ieC9pc3N1ZXMvMTA4MiBmb3IgZGV0YWlscy5cIik7XG4gICAgc2hhcmVHbG9iYWxTdGF0ZUNhbGxlZCA9IHRydWU7XG4gICAgdmFyIGdsb2JhbCA9IGdldEdsb2JhbCgpO1xuICAgIHZhciBvd25TdGF0ZSA9IGdsb2JhbFN0YXRlO1xuICAgIC8qKlxuICAgICAqIEJhY2t3YXJkIGNvbXBhdGliaWxpdHkgY2hlY2tcbiAgICAgKi9cbiAgICBpZiAoZ2xvYmFsLl9fbW9ic2VydmFibGVUcmFja2luZ1N0YWNrIHx8IGdsb2JhbC5fX21vYnNlcnZhYmxlVmlld1N0YWNrKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbbW9ieF0gQW4gaW5jb21wYXRpYmxlIHZlcnNpb24gb2YgbW9ic2VydmFibGUgaXMgYWxyZWFkeSBsb2FkZWQuXCIpO1xuICAgIGlmIChnbG9iYWwuX19tb2J4R2xvYmFsICYmIGdsb2JhbC5fX21vYnhHbG9iYWwudmVyc2lvbiAhPT0gb3duU3RhdGUudmVyc2lvbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW21vYnhdIEFuIGluY29tcGF0aWJsZSB2ZXJzaW9uIG9mIG1vYnggaXMgYWxyZWFkeSBsb2FkZWQuXCIpO1xuICAgIGlmIChnbG9iYWwuX19tb2J4R2xvYmFsKVxuICAgICAgICBnbG9iYWxTdGF0ZSA9IGdsb2JhbC5fX21vYnhHbG9iYWw7XG4gICAgZWxzZVxuICAgICAgICBnbG9iYWwuX19tb2J4R2xvYmFsID0gb3duU3RhdGU7XG59XG5mdW5jdGlvbiBnZXRHbG9iYWxTdGF0ZSgpIHtcbiAgICByZXR1cm4gZ2xvYmFsU3RhdGU7XG59XG5cbi8qKlxuICogRm9yIHRlc3RpbmcgcHVycG9zZXMgb25seTsgdGhpcyB3aWxsIGJyZWFrIHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiBleGlzdGluZyBvYnNlcnZhYmxlcyxcbiAqIGJ1dCBjYW4gYmUgdXNlZCB0byBnZXQgYmFjayBhdCBhIHN0YWJsZSBzdGF0ZSBhZnRlciB0aHJvd2luZyBlcnJvcnNcbiAqL1xuZnVuY3Rpb24gcmVzZXRHbG9iYWxTdGF0ZSgpIHtcbiAgICBnbG9iYWxTdGF0ZS5yZXNldElkKys7XG4gICAgdmFyIGRlZmF1bHRHbG9iYWxzID0gbmV3IE1vYlhHbG9iYWxzKCk7XG4gICAgZm9yICh2YXIga2V5IGluIGRlZmF1bHRHbG9iYWxzKVxuICAgICAgICBpZiAocGVyc2lzdGVudEtleXMuaW5kZXhPZihrZXkpID09PSAtMSlcbiAgICAgICAgICAgIGdsb2JhbFN0YXRlW2tleV0gPSBkZWZhdWx0R2xvYmFsc1trZXldO1xuICAgIGdsb2JhbFN0YXRlLmFsbG93U3RhdGVDaGFuZ2VzID0gIWdsb2JhbFN0YXRlLnN0cmljdE1vZGU7XG59XG5cbmZ1bmN0aW9uIGdldEF0b20odGhpbmcsIHByb3BlcnR5KSB7XG4gICAgaWYgKHR5cGVvZiB0aGluZyA9PT0gXCJvYmplY3RcIiAmJiB0aGluZyAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNPYnNlcnZhYmxlQXJyYXkodGhpbmcpKSB7XG4gICAgICAgICAgICBpbnZhcmlhbnQocHJvcGVydHkgPT09IHVuZGVmaW5lZCwgZ2V0TWVzc2FnZShcIm0wMzZcIikpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaW5nLiRtb2J4LmF0b207XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzT2JzZXJ2YWJsZU1hcCh0aGluZykpIHtcbiAgICAgICAgICAgIHZhciBhbnlUaGluZyA9IHRoaW5nO1xuICAgICAgICAgICAgaWYgKHByb3BlcnR5ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEF0b20oYW55VGhpbmcuX2tleXMpO1xuICAgICAgICAgICAgdmFyIG9ic2VydmFibGUgPSBhbnlUaGluZy5fZGF0YVtwcm9wZXJ0eV0gfHwgYW55VGhpbmcuX2hhc01hcFtwcm9wZXJ0eV07XG4gICAgICAgICAgICBpbnZhcmlhbnQoISFvYnNlcnZhYmxlLCBcInRoZSBlbnRyeSAnXCIgKyBwcm9wZXJ0eSArIFwiJyBkb2VzIG5vdCBleGlzdCBpbiB0aGUgb2JzZXJ2YWJsZSBtYXAgJ1wiICsgZ2V0RGVidWdOYW1lKHRoaW5nKSArIFwiJ1wiKTtcbiAgICAgICAgICAgIHJldHVybiBvYnNlcnZhYmxlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluaXRpYWxpemVycyBydW4gbGF6aWx5IHdoZW4gdHJhbnNwaWxpbmcgdG8gYmFiZWwsIHNvIG1ha2Ugc3VyZSB0aGV5IGFyZSBydW4uLi5cbiAgICAgICAgcnVuTGF6eUluaXRpYWxpemVycyh0aGluZyk7XG4gICAgICAgIGlmIChwcm9wZXJ0eSAmJiAhdGhpbmcuJG1vYngpXG4gICAgICAgICAgICB0aGluZ1twcm9wZXJ0eV07IC8vIFNlZSAjMTA3MiAvLyBUT0RPOiByZW1vdmUgaW4gNC4wXG4gICAgICAgIGlmIChpc09ic2VydmFibGVPYmplY3QodGhpbmcpKSB7XG4gICAgICAgICAgICBpZiAoIXByb3BlcnR5KVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKFwicGxlYXNlIHNwZWNpZnkgYSBwcm9wZXJ0eVwiKTtcbiAgICAgICAgICAgIHZhciBvYnNlcnZhYmxlID0gdGhpbmcuJG1vYngudmFsdWVzW3Byb3BlcnR5XTtcbiAgICAgICAgICAgIGludmFyaWFudCghIW9ic2VydmFibGUsIFwibm8gb2JzZXJ2YWJsZSBwcm9wZXJ0eSAnXCIgKyBwcm9wZXJ0eSArIFwiJyBmb3VuZCBvbiB0aGUgb2JzZXJ2YWJsZSBvYmplY3QgJ1wiICsgZ2V0RGVidWdOYW1lKHRoaW5nKSArIFwiJ1wiKTtcbiAgICAgICAgICAgIHJldHVybiBvYnNlcnZhYmxlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0F0b20odGhpbmcpIHx8IGlzQ29tcHV0ZWRWYWx1ZSh0aGluZykgfHwgaXNSZWFjdGlvbih0aGluZykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdGhpbmcgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBpZiAoaXNSZWFjdGlvbih0aGluZy4kbW9ieCkpIHtcbiAgICAgICAgICAgIC8vIGRpc3Bvc2VyIGZ1bmN0aW9uXG4gICAgICAgICAgICByZXR1cm4gdGhpbmcuJG1vYng7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhaWwoXCJDYW5ub3Qgb2J0YWluIGF0b20gZnJvbSBcIiArIHRoaW5nKTtcbn1cbmZ1bmN0aW9uIGdldEFkbWluaXN0cmF0aW9uKHRoaW5nLCBwcm9wZXJ0eSkge1xuICAgIGludmFyaWFudCh0aGluZywgXCJFeHBlY3Rpbmcgc29tZSBvYmplY3RcIik7XG4gICAgaWYgKHByb3BlcnR5ICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBnZXRBZG1pbmlzdHJhdGlvbihnZXRBdG9tKHRoaW5nLCBwcm9wZXJ0eSkpO1xuICAgIGlmIChpc0F0b20odGhpbmcpIHx8IGlzQ29tcHV0ZWRWYWx1ZSh0aGluZykgfHwgaXNSZWFjdGlvbih0aGluZykpXG4gICAgICAgIHJldHVybiB0aGluZztcbiAgICBpZiAoaXNPYnNlcnZhYmxlTWFwKHRoaW5nKSlcbiAgICAgICAgcmV0dXJuIHRoaW5nO1xuICAgIC8vIEluaXRpYWxpemVycyBydW4gbGF6aWx5IHdoZW4gdHJhbnNwaWxpbmcgdG8gYmFiZWwsIHNvIG1ha2Ugc3VyZSB0aGV5IGFyZSBydW4uLi5cbiAgICBydW5MYXp5SW5pdGlhbGl6ZXJzKHRoaW5nKTtcbiAgICBpZiAodGhpbmcuJG1vYngpXG4gICAgICAgIHJldHVybiB0aGluZy4kbW9ieDtcbiAgICBpbnZhcmlhbnQoZmFsc2UsIFwiQ2Fubm90IG9idGFpbiBhZG1pbmlzdHJhdGlvbiBmcm9tIFwiICsgdGhpbmcpO1xufVxuZnVuY3Rpb24gZ2V0RGVidWdOYW1lKHRoaW5nLCBwcm9wZXJ0eSkge1xuICAgIHZhciBuYW1lZDtcbiAgICBpZiAocHJvcGVydHkgIT09IHVuZGVmaW5lZClcbiAgICAgICAgbmFtZWQgPSBnZXRBdG9tKHRoaW5nLCBwcm9wZXJ0eSk7XG4gICAgZWxzZSBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KHRoaW5nKSB8fCBpc09ic2VydmFibGVNYXAodGhpbmcpKVxuICAgICAgICBuYW1lZCA9IGdldEFkbWluaXN0cmF0aW9uKHRoaW5nKTtcbiAgICBlbHNlXG4gICAgICAgIG5hbWVkID0gZ2V0QXRvbSh0aGluZyk7IC8vIHZhbGlkIGZvciBhcnJheXMgYXMgd2VsbFxuICAgIHJldHVybiBuYW1lZC5uYW1lO1xufVxuXG5mdW5jdGlvbiBnZXREZXBlbmRlbmN5VHJlZSh0aGluZywgcHJvcGVydHkpIHtcbiAgICByZXR1cm4gbm9kZVRvRGVwZW5kZW5jeVRyZWUoZ2V0QXRvbSh0aGluZywgcHJvcGVydHkpKTtcbn1cbmZ1bmN0aW9uIG5vZGVUb0RlcGVuZGVuY3lUcmVlKG5vZGUpIHtcbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiBub2RlLm5hbWVcbiAgICB9O1xuICAgIGlmIChub2RlLm9ic2VydmluZyAmJiBub2RlLm9ic2VydmluZy5sZW5ndGggPiAwKVxuICAgICAgICByZXN1bHQuZGVwZW5kZW5jaWVzID0gdW5pcXVlKG5vZGUub2JzZXJ2aW5nKS5tYXAobm9kZVRvRGVwZW5kZW5jeVRyZWUpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRPYnNlcnZlclRyZWUodGhpbmcsIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIG5vZGVUb09ic2VydmVyVHJlZShnZXRBdG9tKHRoaW5nLCBwcm9wZXJ0eSkpO1xufVxuZnVuY3Rpb24gbm9kZVRvT2JzZXJ2ZXJUcmVlKG5vZGUpIHtcbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiBub2RlLm5hbWVcbiAgICB9O1xuICAgIGlmIChoYXNPYnNlcnZlcnMobm9kZSkpXG4gICAgICAgIHJlc3VsdC5vYnNlcnZlcnMgPSBnZXRPYnNlcnZlcnMobm9kZSkubWFwKG5vZGVUb09ic2VydmVyVHJlZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gaGFzT2JzZXJ2ZXJzKG9ic2VydmFibGUpIHtcbiAgICByZXR1cm4gb2JzZXJ2YWJsZS5vYnNlcnZlcnMgJiYgb2JzZXJ2YWJsZS5vYnNlcnZlcnMubGVuZ3RoID4gMDtcbn1cbmZ1bmN0aW9uIGdldE9ic2VydmVycyhvYnNlcnZhYmxlKSB7XG4gICAgcmV0dXJuIG9ic2VydmFibGUub2JzZXJ2ZXJzO1xufVxuZnVuY3Rpb24gYWRkT2JzZXJ2ZXIob2JzZXJ2YWJsZSwgbm9kZSkge1xuICAgIC8vIGludmFyaWFudChub2RlLmRlcGVuZGVuY2llc1N0YXRlICE9PSAtMSwgXCJJTlRFUk5BTCBFUlJPUiwgY2FuIGFkZCBvbmx5IGRlcGVuZGVuY2llc1N0YXRlICE9PSAtMVwiKTtcbiAgICAvLyBpbnZhcmlhbnQob2JzZXJ2YWJsZS5fb2JzZXJ2ZXJzLmluZGV4T2Yobm9kZSkgPT09IC0xLCBcIklOVEVSTkFMIEVSUk9SIGFkZCBhbHJlYWR5IGFkZGVkIG5vZGVcIik7XG4gICAgLy8gaW52YXJpYW50T2JzZXJ2ZXJzKG9ic2VydmFibGUpO1xuICAgIHZhciBsID0gb2JzZXJ2YWJsZS5vYnNlcnZlcnMubGVuZ3RoO1xuICAgIGlmIChsKSB7XG4gICAgICAgIC8vIGJlY2F1c2Ugb2JqZWN0IGFzc2lnbm1lbnQgaXMgcmVsYXRpdmVseSBleHBlbnNpdmUsIGxldCdzIG5vdCBzdG9yZSBkYXRhIGFib3V0IGluZGV4IDAuXG4gICAgICAgIG9ic2VydmFibGUub2JzZXJ2ZXJzSW5kZXhlc1tub2RlLl9fbWFwaWRdID0gbDtcbiAgICB9XG4gICAgb2JzZXJ2YWJsZS5vYnNlcnZlcnNbbF0gPSBub2RlO1xuICAgIGlmIChvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGUgPiBub2RlLmRlcGVuZGVuY2llc1N0YXRlKVxuICAgICAgICBvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGUgPSBub2RlLmRlcGVuZGVuY2llc1N0YXRlO1xuICAgIC8vIGludmFyaWFudE9ic2VydmVycyhvYnNlcnZhYmxlKTtcbiAgICAvLyBpbnZhcmlhbnQob2JzZXJ2YWJsZS5fb2JzZXJ2ZXJzLmluZGV4T2Yobm9kZSkgIT09IC0xLCBcIklOVEVSTkFMIEVSUk9SIGRpZG4ndCBhZGQgbm9kZVwiKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZU9ic2VydmVyKG9ic2VydmFibGUsIG5vZGUpIHtcbiAgICAvLyBpbnZhcmlhbnQoZ2xvYmFsU3RhdGUuaW5CYXRjaCA+IDAsIFwiSU5URVJOQUwgRVJST1IsIHJlbW92ZSBzaG91bGQgYmUgY2FsbGVkIG9ubHkgaW5zaWRlIGJhdGNoXCIpO1xuICAgIC8vIGludmFyaWFudChvYnNlcnZhYmxlLl9vYnNlcnZlcnMuaW5kZXhPZihub2RlKSAhPT0gLTEsIFwiSU5URVJOQUwgRVJST1IgcmVtb3ZlIGFscmVhZHkgcmVtb3ZlZCBub2RlXCIpO1xuICAgIC8vIGludmFyaWFudE9ic2VydmVycyhvYnNlcnZhYmxlKTtcbiAgICBpZiAob2JzZXJ2YWJsZS5vYnNlcnZlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIGRlbGV0aW5nIGxhc3Qgb2JzZXJ2ZXJcbiAgICAgICAgb2JzZXJ2YWJsZS5vYnNlcnZlcnMubGVuZ3RoID0gMDtcbiAgICAgICAgcXVldWVGb3JVbm9ic2VydmF0aW9uKG9ic2VydmFibGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gZGVsZXRpbmcgZnJvbSBfb2JzZXJ2ZXJzSW5kZXhlcyBpcyBzdHJhaWdodCBmb3J3YXJkLCB0byBkZWxldGUgZnJvbSBfb2JzZXJ2ZXJzLCBsZXQncyBzd2FwIGBub2RlYCB3aXRoIGxhc3QgZWxlbWVudFxuICAgICAgICB2YXIgbGlzdCA9IG9ic2VydmFibGUub2JzZXJ2ZXJzO1xuICAgICAgICB2YXIgbWFwID0gb2JzZXJ2YWJsZS5vYnNlcnZlcnNJbmRleGVzO1xuICAgICAgICB2YXIgZmlsbGVyID0gbGlzdC5wb3AoKTsgLy8gZ2V0IGxhc3QgZWxlbWVudCwgd2hpY2ggc2hvdWxkIGZpbGwgdGhlIHBsYWNlIG9mIGBub2RlYCwgc28gdGhlIGFycmF5IGRvZXNuJ3QgaGF2ZSBob2xlc1xuICAgICAgICBpZiAoZmlsbGVyICE9PSBub2RlKSB7XG4gICAgICAgICAgICAvLyBvdGhlcndpc2Ugbm9kZSB3YXMgdGhlIGxhc3QgZWxlbWVudCwgd2hpY2ggYWxyZWFkeSBnb3QgcmVtb3ZlZCBmcm9tIGFycmF5XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBtYXBbbm9kZS5fX21hcGlkXSB8fCAwOyAvLyBnZXR0aW5nIGluZGV4IG9mIGBub2RlYC4gdGhpcyBpcyB0aGUgb25seSBwbGFjZSB3ZSBhY3R1YWxseSB1c2UgbWFwLlxuICAgICAgICAgICAgaWYgKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gbWFwIHN0b3JlIGFsbCBpbmRleGVzIGJ1dCAwLCBzZWUgY29tbWVudCBpbiBgYWRkT2JzZXJ2ZXJgXG4gICAgICAgICAgICAgICAgbWFwW2ZpbGxlci5fX21hcGlkXSA9IGluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG1hcFtmaWxsZXIuX19tYXBpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaXN0W2luZGV4XSA9IGZpbGxlcjtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgbWFwW25vZGUuX19tYXBpZF07XG4gICAgfVxuICAgIC8vIGludmFyaWFudE9ic2VydmVycyhvYnNlcnZhYmxlKTtcbiAgICAvLyBpbnZhcmlhbnQob2JzZXJ2YWJsZS5fb2JzZXJ2ZXJzLmluZGV4T2Yobm9kZSkgPT09IC0xLCBcIklOVEVSTkFMIEVSUk9SIHJlbW92ZSBhbHJlYWR5IHJlbW92ZWQgbm9kZTJcIik7XG59XG5mdW5jdGlvbiBxdWV1ZUZvclVub2JzZXJ2YXRpb24ob2JzZXJ2YWJsZSkge1xuICAgIGlmICghb2JzZXJ2YWJsZS5pc1BlbmRpbmdVbm9ic2VydmF0aW9uKSB7XG4gICAgICAgIC8vIGludmFyaWFudChnbG9iYWxTdGF0ZS5pbkJhdGNoID4gMCwgXCJJTlRFUk5BTCBFUlJPUiwgcmVtb3ZlIHNob3VsZCBiZSBjYWxsZWQgb25seSBpbnNpZGUgYmF0Y2hcIik7XG4gICAgICAgIC8vIGludmFyaWFudChvYnNlcnZhYmxlLl9vYnNlcnZlcnMubGVuZ3RoID09PSAwLCBcIklOVEVSTkFMIEVSUk9SLCBzaG91bGQgb25seSBxdWV1ZSBmb3IgdW5vYnNlcnZhdGlvbiB1bm9ic2VydmVkIG9ic2VydmFibGVzXCIpO1xuICAgICAgICBvYnNlcnZhYmxlLmlzUGVuZGluZ1Vub2JzZXJ2YXRpb24gPSB0cnVlO1xuICAgICAgICBnbG9iYWxTdGF0ZS5wZW5kaW5nVW5vYnNlcnZhdGlvbnMucHVzaChvYnNlcnZhYmxlKTtcbiAgICB9XG59XG4vKipcbiAqIEJhdGNoIHN0YXJ0cyBhIHRyYW5zYWN0aW9uLCBhdCBsZWFzdCBmb3IgcHVycG9zZXMgb2YgbWVtb2l6aW5nIENvbXB1dGVkVmFsdWVzIHdoZW4gbm90aGluZyBlbHNlIGRvZXMuXG4gKiBEdXJpbmcgYSBiYXRjaCBgb25CZWNvbWVVbm9ic2VydmVkYCB3aWxsIGJlIGNhbGxlZCBhdCBtb3N0IG9uY2UgcGVyIG9ic2VydmFibGUuXG4gKiBBdm9pZHMgdW5uZWNlc3NhcnkgcmVjYWxjdWxhdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0QmF0Y2goKSB7XG4gICAgZ2xvYmFsU3RhdGUuaW5CYXRjaCsrO1xufVxuZnVuY3Rpb24gZW5kQmF0Y2goKSB7XG4gICAgaWYgKC0tZ2xvYmFsU3RhdGUuaW5CYXRjaCA9PT0gMCkge1xuICAgICAgICBydW5SZWFjdGlvbnMoKTtcbiAgICAgICAgLy8gdGhlIGJhdGNoIGlzIGFjdHVhbGx5IGFib3V0IHRvIGZpbmlzaCwgYWxsIHVub2JzZXJ2aW5nIHNob3VsZCBoYXBwZW4gaGVyZS5cbiAgICAgICAgdmFyIGxpc3QgPSBnbG9iYWxTdGF0ZS5wZW5kaW5nVW5vYnNlcnZhdGlvbnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG9ic2VydmFibGUgPSBsaXN0W2ldO1xuICAgICAgICAgICAgb2JzZXJ2YWJsZS5pc1BlbmRpbmdVbm9ic2VydmF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAob2JzZXJ2YWJsZS5vYnNlcnZlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2YWJsZS5vbkJlY29tZVVub2JzZXJ2ZWQoKTtcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiBvbkJlY29tZVVub2JzZXJ2ZWQgbWlnaHQgcHVzaCB0byBgcGVuZGluZ1Vub2JzZXJ2YXRpb25zYFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdsb2JhbFN0YXRlLnBlbmRpbmdVbm9ic2VydmF0aW9ucyA9IFtdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlcG9ydE9ic2VydmVkKG9ic2VydmFibGUpIHtcbiAgICB2YXIgZGVyaXZhdGlvbiA9IGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbjtcbiAgICBpZiAoZGVyaXZhdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogU2ltcGxlIG9wdGltaXphdGlvbiwgZ2l2ZSBlYWNoIGRlcml2YXRpb24gcnVuIGFuIHVuaXF1ZSBpZCAocnVuSWQpXG4gICAgICAgICAqIENoZWNrIGlmIGxhc3QgdGltZSB0aGlzIG9ic2VydmFibGUgd2FzIGFjY2Vzc2VkIHRoZSBzYW1lIHJ1bklkIGlzIHVzZWRcbiAgICAgICAgICogaWYgdGhpcyBpcyB0aGUgY2FzZSwgdGhlIHJlbGF0aW9uIGlzIGFscmVhZHkga25vd25cbiAgICAgICAgICovXG4gICAgICAgIGlmIChkZXJpdmF0aW9uLnJ1bklkICE9PSBvYnNlcnZhYmxlLmxhc3RBY2Nlc3NlZEJ5KSB7XG4gICAgICAgICAgICBvYnNlcnZhYmxlLmxhc3RBY2Nlc3NlZEJ5ID0gZGVyaXZhdGlvbi5ydW5JZDtcbiAgICAgICAgICAgIGRlcml2YXRpb24ubmV3T2JzZXJ2aW5nW2Rlcml2YXRpb24udW5ib3VuZERlcHNDb3VudCsrXSA9IG9ic2VydmFibGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAob2JzZXJ2YWJsZS5vYnNlcnZlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHF1ZXVlRm9yVW5vYnNlcnZhdGlvbihvYnNlcnZhYmxlKTtcbiAgICB9XG59XG4vKipcbiAqIE5PVEU6IGN1cnJlbnQgcHJvcGFnYXRpb24gbWVjaGFuaXNtIHdpbGwgaW4gY2FzZSBvZiBzZWxmIHJlcnVuaW5nIGF1dG9ydW5zIGJlaGF2ZSB1bmV4cGVjdGVkbHlcbiAqIEl0IHdpbGwgcHJvcGFnYXRlIGNoYW5nZXMgdG8gb2JzZXJ2ZXJzIGZyb20gcHJldmlvdXMgcnVuXG4gKiBJdCdzIGhhcmQgb3IgbWF5YmUgaW1wb3NzaWJsZSAod2l0aCByZWFzb25hYmxlIHBlcmYpIHRvIGdldCBpdCByaWdodCB3aXRoIGN1cnJlbnQgYXBwcm9hY2hcbiAqIEhvcGVmdWxseSBzZWxmIHJlcnVuaW5nIGF1dG9ydW5zIGFyZW4ndCBhIGZlYXR1cmUgcGVvcGxlIHNob3VsZCBkZXBlbmQgb25cbiAqIEFsc28gbW9zdCBiYXNpYyB1c2UgY2FzZXMgc2hvdWxkIGJlIG9rXG4gKi9cbi8vIENhbGxlZCBieSBBdG9tIHdoZW4gaXRzIHZhbHVlIGNoYW5nZXNcbmZ1bmN0aW9uIHByb3BhZ2F0ZUNoYW5nZWQob2JzZXJ2YWJsZSkge1xuICAgIC8vIGludmFyaWFudExPUyhvYnNlcnZhYmxlLCBcImNoYW5nZWQgc3RhcnRcIik7XG4gICAgaWYgKG9ic2VydmFibGUubG93ZXN0T2JzZXJ2ZXJTdGF0ZSA9PT0gSURlcml2YXRpb25TdGF0ZS5TVEFMRSlcbiAgICAgICAgcmV0dXJuO1xuICAgIG9ic2VydmFibGUubG93ZXN0T2JzZXJ2ZXJTdGF0ZSA9IElEZXJpdmF0aW9uU3RhdGUuU1RBTEU7XG4gICAgdmFyIG9ic2VydmVycyA9IG9ic2VydmFibGUub2JzZXJ2ZXJzO1xuICAgIHZhciBpID0gb2JzZXJ2ZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHZhciBkID0gb2JzZXJ2ZXJzW2ldO1xuICAgICAgICBpZiAoZC5kZXBlbmRlbmNpZXNTdGF0ZSA9PT0gSURlcml2YXRpb25TdGF0ZS5VUF9UT19EQVRFKSB7XG4gICAgICAgICAgICBpZiAoZC5pc1RyYWNpbmcgIT09IFRyYWNlTW9kZS5OT05FKSB7XG4gICAgICAgICAgICAgICAgbG9nVHJhY2VJbmZvKGQsIG9ic2VydmFibGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZC5vbkJlY29tZVN0YWxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZC5kZXBlbmRlbmNpZXNTdGF0ZSA9IElEZXJpdmF0aW9uU3RhdGUuU1RBTEU7XG4gICAgfVxuICAgIC8vIGludmFyaWFudExPUyhvYnNlcnZhYmxlLCBcImNoYW5nZWQgZW5kXCIpO1xufVxuLy8gQ2FsbGVkIGJ5IENvbXB1dGVkVmFsdWUgd2hlbiBpdCByZWNhbGN1bGF0ZSBhbmQgaXRzIHZhbHVlIGNoYW5nZWRcbmZ1bmN0aW9uIHByb3BhZ2F0ZUNoYW5nZUNvbmZpcm1lZChvYnNlcnZhYmxlKSB7XG4gICAgLy8gaW52YXJpYW50TE9TKG9ic2VydmFibGUsIFwiY29uZmlybWVkIHN0YXJ0XCIpO1xuICAgIGlmIChvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGUgPT09IElEZXJpdmF0aW9uU3RhdGUuU1RBTEUpXG4gICAgICAgIHJldHVybjtcbiAgICBvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGUgPSBJRGVyaXZhdGlvblN0YXRlLlNUQUxFO1xuICAgIHZhciBvYnNlcnZlcnMgPSBvYnNlcnZhYmxlLm9ic2VydmVycztcbiAgICB2YXIgaSA9IG9ic2VydmVycy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICB2YXIgZCA9IG9ic2VydmVyc1tpXTtcbiAgICAgICAgaWYgKGQuZGVwZW5kZW5jaWVzU3RhdGUgPT09IElEZXJpdmF0aW9uU3RhdGUuUE9TU0lCTFlfU1RBTEUpXG4gICAgICAgICAgICBkLmRlcGVuZGVuY2llc1N0YXRlID0gSURlcml2YXRpb25TdGF0ZS5TVEFMRTtcbiAgICAgICAgZWxzZSBpZiAoZC5kZXBlbmRlbmNpZXNTdGF0ZSA9PT0gSURlcml2YXRpb25TdGF0ZS5VUF9UT19EQVRFIC8vIHRoaXMgaGFwcGVucyBkdXJpbmcgY29tcHV0aW5nIG9mIGBkYCwganVzdCBrZWVwIGxvd2VzdE9ic2VydmVyU3RhdGUgdXAgdG8gZGF0ZS5cbiAgICAgICAgKVxuICAgICAgICAgICAgb2JzZXJ2YWJsZS5sb3dlc3RPYnNlcnZlclN0YXRlID0gSURlcml2YXRpb25TdGF0ZS5VUF9UT19EQVRFO1xuICAgIH1cbiAgICAvLyBpbnZhcmlhbnRMT1Mob2JzZXJ2YWJsZSwgXCJjb25maXJtZWQgZW5kXCIpO1xufVxuLy8gVXNlZCBieSBjb21wdXRlZCB3aGVuIGl0cyBkZXBlbmRlbmN5IGNoYW5nZWQsIGJ1dCB3ZSBkb24ndCB3YW4ndCB0byBpbW1lZGlhdGVseSByZWNvbXB1dGUuXG5mdW5jdGlvbiBwcm9wYWdhdGVNYXliZUNoYW5nZWQob2JzZXJ2YWJsZSkge1xuICAgIC8vIGludmFyaWFudExPUyhvYnNlcnZhYmxlLCBcIm1heWJlIHN0YXJ0XCIpO1xuICAgIGlmIChvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGUgIT09IElEZXJpdmF0aW9uU3RhdGUuVVBfVE9fREFURSlcbiAgICAgICAgcmV0dXJuO1xuICAgIG9ic2VydmFibGUubG93ZXN0T2JzZXJ2ZXJTdGF0ZSA9IElEZXJpdmF0aW9uU3RhdGUuUE9TU0lCTFlfU1RBTEU7XG4gICAgdmFyIG9ic2VydmVycyA9IG9ic2VydmFibGUub2JzZXJ2ZXJzO1xuICAgIHZhciBpID0gb2JzZXJ2ZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHZhciBkID0gb2JzZXJ2ZXJzW2ldO1xuICAgICAgICBpZiAoZC5kZXBlbmRlbmNpZXNTdGF0ZSA9PT0gSURlcml2YXRpb25TdGF0ZS5VUF9UT19EQVRFKSB7XG4gICAgICAgICAgICBkLmRlcGVuZGVuY2llc1N0YXRlID0gSURlcml2YXRpb25TdGF0ZS5QT1NTSUJMWV9TVEFMRTtcbiAgICAgICAgICAgIGlmIChkLmlzVHJhY2luZyAhPT0gVHJhY2VNb2RlLk5PTkUpIHtcbiAgICAgICAgICAgICAgICBsb2dUcmFjZUluZm8oZCwgb2JzZXJ2YWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkLm9uQmVjb21lU3RhbGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBpbnZhcmlhbnRMT1Mob2JzZXJ2YWJsZSwgXCJtYXliZSBlbmRcIik7XG59XG5mdW5jdGlvbiBsb2dUcmFjZUluZm8oZGVyaXZhdGlvbiwgb2JzZXJ2YWJsZSkge1xuICAgIGNvbnNvbGUubG9nKFwiW21vYngudHJhY2VdICdcIiArIGRlcml2YXRpb24ubmFtZSArIFwiJyBpcyBpbnZhbGlkYXRlZCBkdWUgdG8gYSBjaGFuZ2UgaW46ICdcIiArIG9ic2VydmFibGUubmFtZSArIFwiJ1wiKTtcbiAgICBpZiAoZGVyaXZhdGlvbi5pc1RyYWNpbmcgPT09IFRyYWNlTW9kZS5CUkVBSykge1xuICAgICAgICB2YXIgbGluZXMgPSBbXTtcbiAgICAgICAgcHJpbnREZXBUcmVlKGdldERlcGVuZGVuY3lUcmVlKGRlcml2YXRpb24pLCBsaW5lcywgMSk7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBuZXcgRnVuY3Rpb24oXCJkZWJ1Z2dlcjtcXG4vKlxcblRyYWNpbmcgJ1wiICsgZGVyaXZhdGlvbi5uYW1lICsgXCInXFxuXFxuWW91IGFyZSBlbnRlcmluZyB0aGlzIGJyZWFrIHBvaW50IGJlY2F1c2UgZGVyaXZhdGlvbiAnXCIgKyBkZXJpdmF0aW9uLm5hbWUgKyBcIicgaXMgYmVpbmcgdHJhY2VkIGFuZCAnXCIgKyBvYnNlcnZhYmxlLm5hbWUgKyBcIicgaXMgbm93IGZvcmNpbmcgaXQgdG8gdXBkYXRlLlxcbkp1c3QgZm9sbG93IHRoZSBzdGFja3RyYWNlIHlvdSBzaG91bGQgbm93IHNlZSBpbiB0aGUgZGV2dG9vbHMgdG8gc2VlIHByZWNpc2VseSB3aGF0IHBpZWNlIG9mIHlvdXIgY29kZSBpcyBjYXVzaW5nIHRoaXMgdXBkYXRlXFxuVGhlIHN0YWNrZnJhbWUgeW91IGFyZSBsb29raW5nIGZvciBpcyBhdCBsZWFzdCB+Ni04IHN0YWNrLWZyYW1lcyB1cC5cXG5cXG5cIiArIChkZXJpdmF0aW9uIGluc3RhbmNlb2YgQ29tcHV0ZWRWYWx1ZSA/IGRlcml2YXRpb24uZGVyaXZhdGlvbi50b1N0cmluZygpIDogXCJcIikgKyBcIlxcblxcblRoZSBkZXBlbmRlbmNpZXMgZm9yIHRoaXMgZGVyaXZhdGlvbiBhcmU6XFxuXFxuXCIgKyBsaW5lcy5qb2luKFwiXFxuXCIpICsgXCJcXG4qL1xcbiAgICBcIikoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwcmludERlcFRyZWUodHJlZSwgbGluZXMsIGRlcHRoKSB7XG4gICAgaWYgKGxpbmVzLmxlbmd0aCA+PSAxMDAwKSB7XG4gICAgICAgIGxpbmVzLnB1c2goXCIoYW5kIG1hbnkgbW9yZSlcIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGluZXMucHVzaChcIlwiICsgbmV3IEFycmF5KGRlcHRoKS5qb2luKFwiXFx0XCIpICsgdHJlZS5uYW1lKTsgLy8gTVdFOiBub3QgdGhlIGZhc3Rlc3QsIGJ1dCB0aGUgZWFzaWVzdCB3YXkgOilcbiAgICBpZiAodHJlZS5kZXBlbmRlbmNpZXMpXG4gICAgICAgIHRyZWUuZGVwZW5kZW5jaWVzLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBwcmludERlcFRyZWUoY2hpbGQsIGxpbmVzLCBkZXB0aCArIDEpOyB9KTtcbn1cblxudmFyIElEZXJpdmF0aW9uU3RhdGU7XG4oZnVuY3Rpb24gKElEZXJpdmF0aW9uU3RhdGUpIHtcbiAgICAvLyBiZWZvcmUgYmVpbmcgcnVuIG9yIChvdXRzaWRlIGJhdGNoIGFuZCBub3QgYmVpbmcgb2JzZXJ2ZWQpXG4gICAgLy8gYXQgdGhpcyBwb2ludCBkZXJpdmF0aW9uIGlzIG5vdCBob2xkaW5nIGFueSBkYXRhIGFib3V0IGRlcGVuZGVuY3kgdHJlZVxuICAgIElEZXJpdmF0aW9uU3RhdGVbSURlcml2YXRpb25TdGF0ZVtcIk5PVF9UUkFDS0lOR1wiXSA9IC0xXSA9IFwiTk9UX1RSQUNLSU5HXCI7XG4gICAgLy8gbm8gc2hhbGxvdyBkZXBlbmRlbmN5IGNoYW5nZWQgc2luY2UgbGFzdCBjb21wdXRhdGlvblxuICAgIC8vIHdvbid0IHJlY2FsY3VsYXRlIGRlcml2YXRpb25cbiAgICAvLyB0aGlzIGlzIHdoYXQgbWFrZXMgbW9ieCBmYXN0XG4gICAgSURlcml2YXRpb25TdGF0ZVtJRGVyaXZhdGlvblN0YXRlW1wiVVBfVE9fREFURVwiXSA9IDBdID0gXCJVUF9UT19EQVRFXCI7XG4gICAgLy8gc29tZSBkZWVwIGRlcGVuZGVuY3kgY2hhbmdlZCwgYnV0IGRvbid0IGtub3cgaWYgc2hhbGxvdyBkZXBlbmRlbmN5IGNoYW5nZWRcbiAgICAvLyB3aWxsIHJlcXVpcmUgdG8gY2hlY2sgZmlyc3QgaWYgVVBfVE9fREFURSBvciBQT1NTSUJMWV9TVEFMRVxuICAgIC8vIGN1cnJlbnRseSBvbmx5IENvbXB1dGVkVmFsdWUgd2lsbCBwcm9wYWdhdGUgUE9TU0lCTFlfU1RBTEVcbiAgICAvL1xuICAgIC8vIGhhdmluZyB0aGlzIHN0YXRlIGlzIHNlY29uZCBiaWcgb3B0aW1pemF0aW9uOlxuICAgIC8vIGRvbid0IGhhdmUgdG8gcmVjb21wdXRlIG9uIGV2ZXJ5IGRlcGVuZGVuY3kgY2hhbmdlLCBidXQgb25seSB3aGVuIGl0J3MgbmVlZGVkXG4gICAgSURlcml2YXRpb25TdGF0ZVtJRGVyaXZhdGlvblN0YXRlW1wiUE9TU0lCTFlfU1RBTEVcIl0gPSAxXSA9IFwiUE9TU0lCTFlfU1RBTEVcIjtcbiAgICAvLyBBIHNoYWxsb3cgZGVwZW5kZW5jeSBoYXMgY2hhbmdlZCBzaW5jZSBsYXN0IGNvbXB1dGF0aW9uIGFuZCB0aGUgZGVyaXZhdGlvblxuICAgIC8vIHdpbGwgbmVlZCB0byByZWNvbXB1dGUgd2hlbiBpdCdzIG5lZWRlZCBuZXh0LlxuICAgIElEZXJpdmF0aW9uU3RhdGVbSURlcml2YXRpb25TdGF0ZVtcIlNUQUxFXCJdID0gMl0gPSBcIlNUQUxFXCI7XG59KShJRGVyaXZhdGlvblN0YXRlIHx8IChJRGVyaXZhdGlvblN0YXRlID0ge30pKTtcbnZhciBUcmFjZU1vZGU7XG4oZnVuY3Rpb24gKFRyYWNlTW9kZSkge1xuICAgIFRyYWNlTW9kZVtUcmFjZU1vZGVbXCJOT05FXCJdID0gMF0gPSBcIk5PTkVcIjtcbiAgICBUcmFjZU1vZGVbVHJhY2VNb2RlW1wiTE9HXCJdID0gMV0gPSBcIkxPR1wiO1xuICAgIFRyYWNlTW9kZVtUcmFjZU1vZGVbXCJCUkVBS1wiXSA9IDJdID0gXCJCUkVBS1wiO1xufSkoVHJhY2VNb2RlIHx8IChUcmFjZU1vZGUgPSB7fSkpO1xudmFyIENhdWdodEV4Y2VwdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2F1Z2h0RXhjZXB0aW9uKGNhdXNlKSB7XG4gICAgICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICAgICAgLy8gRW1wdHlcbiAgICB9XG4gICAgcmV0dXJuIENhdWdodEV4Y2VwdGlvbjtcbn0oKSk7XG5mdW5jdGlvbiBpc0NhdWdodEV4Y2VwdGlvbihlKSB7XG4gICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBDYXVnaHRFeGNlcHRpb247XG59XG4vKipcbiAqIEZpbmRzIG91dCB3aGV0aGVyIGFueSBkZXBlbmRlbmN5IG9mIHRoZSBkZXJpdmF0aW9uIGhhcyBhY3R1YWxseSBjaGFuZ2VkLlxuICogSWYgZGVwZW5kZW5jaWVzU3RhdGUgaXMgMSB0aGVuIGl0IHdpbGwgcmVjYWxjdWxhdGUgZGVwZW5kZW5jaWVzLFxuICogaWYgYW55IGRlcGVuZGVuY3kgY2hhbmdlZCBpdCB3aWxsIHByb3BhZ2F0ZSBpdCBieSBjaGFuZ2luZyBkZXBlbmRlbmNpZXNTdGF0ZSB0byAyLlxuICpcbiAqIEJ5IGl0ZXJhdGluZyBvdmVyIHRoZSBkZXBlbmRlbmNpZXMgaW4gdGhlIHNhbWUgb3JkZXIgdGhhdCB0aGV5IHdlcmUgcmVwb3J0ZWQgYW5kXG4gKiBzdG9wcGluZyBvbiB0aGUgZmlyc3QgY2hhbmdlLCBhbGwgdGhlIHJlY2FsY3VsYXRpb25zIGFyZSBvbmx5IGNhbGxlZCBmb3IgQ29tcHV0ZWRWYWx1ZXNcbiAqIHRoYXQgd2lsbCBiZSB0cmFja2VkIGJ5IGRlcml2YXRpb24uIFRoYXQgaXMgYmVjYXVzZSB3ZSBhc3N1bWUgdGhhdCBpZiB0aGUgZmlyc3QgeFxuICogZGVwZW5kZW5jaWVzIG9mIHRoZSBkZXJpdmF0aW9uIGRvZXNuJ3QgY2hhbmdlIHRoZW4gdGhlIGRlcml2YXRpb24gc2hvdWxkIHJ1biB0aGUgc2FtZSB3YXlcbiAqIHVwIHVudGlsIGFjY2Vzc2luZyB4LXRoIGRlcGVuZGVuY3kuXG4gKi9cbmZ1bmN0aW9uIHNob3VsZENvbXB1dGUoZGVyaXZhdGlvbikge1xuICAgIHN3aXRjaCAoZGVyaXZhdGlvbi5kZXBlbmRlbmNpZXNTdGF0ZSkge1xuICAgICAgICBjYXNlIElEZXJpdmF0aW9uU3RhdGUuVVBfVE9fREFURTpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY2FzZSBJRGVyaXZhdGlvblN0YXRlLk5PVF9UUkFDS0lORzpcbiAgICAgICAgY2FzZSBJRGVyaXZhdGlvblN0YXRlLlNUQUxFOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgSURlcml2YXRpb25TdGF0ZS5QT1NTSUJMWV9TVEFMRToge1xuICAgICAgICAgICAgdmFyIHByZXZVbnRyYWNrZWQgPSB1bnRyYWNrZWRTdGFydCgpOyAvLyBubyBuZWVkIGZvciB0aG9zZSBjb21wdXRlZHMgdG8gYmUgcmVwb3J0ZWQsIHRoZXkgd2lsbCBiZSBwaWNrZWQgdXAgaW4gdHJhY2tEZXJpdmVkRnVuY3Rpb24uXG4gICAgICAgICAgICB2YXIgb2JzID0gZGVyaXZhdGlvbi5vYnNlcnZpbmcsIGwgPSBvYnMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0gb2JzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChpc0NvbXB1dGVkVmFsdWUob2JqKSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmdldCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBhcmUgbm90IGludGVyZXN0ZWQgaW4gdGhlIHZhbHVlICpvciogZXhjZXB0aW9uIGF0IHRoaXMgbW9tZW50LCBidXQgaWYgdGhlcmUgaXMgb25lLCBub3RpZnkgYWxsXG4gICAgICAgICAgICAgICAgICAgICAgICB1bnRyYWNrZWRFbmQocHJldlVudHJhY2tlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBDb21wdXRlZFZhbHVlIGBvYmpgIGFjdHVhbGx5IGNoYW5nZWQgaXQgd2lsbCBiZSBjb21wdXRlZCBhbmQgcHJvcGFnYXRlZCB0byBpdHMgb2JzZXJ2ZXJzLlxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgYGRlcml2YXRpb25gIGlzIGFuIG9ic2VydmVyIG9mIGBvYmpgXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXJpdmF0aW9uLmRlcGVuZGVuY2llc1N0YXRlID09PSBJRGVyaXZhdGlvblN0YXRlLlNUQUxFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bnRyYWNrZWRFbmQocHJldlVudHJhY2tlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoYW5nZURlcGVuZGVuY2llc1N0YXRlVG8wKGRlcml2YXRpb24pO1xuICAgICAgICAgICAgdW50cmFja2VkRW5kKHByZXZVbnRyYWNrZWQpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaXNDb21wdXRpbmdEZXJpdmF0aW9uKCkge1xuICAgIHJldHVybiBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24gIT09IG51bGw7IC8vIGZpbHRlciBvdXQgYWN0aW9ucyBpbnNpZGUgY29tcHV0YXRpb25zXG59XG5mdW5jdGlvbiBjaGVja0lmU3RhdGVNb2RpZmljYXRpb25zQXJlQWxsb3dlZChhdG9tKSB7XG4gICAgdmFyIGhhc09ic2VydmVycyQkMSA9IGF0b20ub2JzZXJ2ZXJzLmxlbmd0aCA+IDA7XG4gICAgLy8gU2hvdWxkIG5ldmVyIGJlIHBvc3NpYmxlIHRvIGNoYW5nZSBhbiBvYnNlcnZlZCBvYnNlcnZhYmxlIGZyb20gaW5zaWRlIGNvbXB1dGVkLCBzZWUgIzc5OFxuICAgIGlmIChnbG9iYWxTdGF0ZS5jb21wdXRhdGlvbkRlcHRoID4gMCAmJiBoYXNPYnNlcnZlcnMkJDEpXG4gICAgICAgIGZhaWwoZ2V0TWVzc2FnZShcIm0wMzFcIikgKyBhdG9tLm5hbWUpO1xuICAgIC8vIFNob3VsZCBub3QgYmUgcG9zc2libGUgdG8gY2hhbmdlIG9ic2VydmVkIHN0YXRlIG91dHNpZGUgc3RyaWN0IG1vZGUsIGV4Y2VwdCBkdXJpbmcgaW5pdGlhbGl6YXRpb24sIHNlZSAjNTYzXG4gICAgaWYgKCFnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlQ2hhbmdlcyAmJiBoYXNPYnNlcnZlcnMkJDEpXG4gICAgICAgIGZhaWwoZ2V0TWVzc2FnZShnbG9iYWxTdGF0ZS5zdHJpY3RNb2RlID8gXCJtMDMwYVwiIDogXCJtMDMwYlwiKSArIGF0b20ubmFtZSk7XG59XG4vKipcbiAqIEV4ZWN1dGVzIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBgZmAgYW5kIHRyYWNrcyB3aGljaCBvYnNlcnZhYmxlcyBhcmUgYmVpbmcgYWNjZXNzZWQuXG4gKiBUaGUgdHJhY2tpbmcgaW5mb3JtYXRpb24gaXMgc3RvcmVkIG9uIHRoZSBgZGVyaXZhdGlvbmAgb2JqZWN0IGFuZCB0aGUgZGVyaXZhdGlvbiBpcyByZWdpc3RlcmVkXG4gKiBhcyBvYnNlcnZlciBvZiBhbnkgb2YgdGhlIGFjY2Vzc2VkIG9ic2VydmFibGVzLlxuICovXG5mdW5jdGlvbiB0cmFja0Rlcml2ZWRGdW5jdGlvbihkZXJpdmF0aW9uLCBmLCBjb250ZXh0KSB7XG4gICAgLy8gcHJlIGFsbG9jYXRlIGFycmF5IGFsbG9jYXRpb24gKyByb29tIGZvciB2YXJpYXRpb24gaW4gZGVwc1xuICAgIC8vIGFycmF5IHdpbGwgYmUgdHJpbW1lZCBieSBiaW5kRGVwZW5kZW5jaWVzXG4gICAgY2hhbmdlRGVwZW5kZW5jaWVzU3RhdGVUbzAoZGVyaXZhdGlvbik7XG4gICAgZGVyaXZhdGlvbi5uZXdPYnNlcnZpbmcgPSBuZXcgQXJyYXkoZGVyaXZhdGlvbi5vYnNlcnZpbmcubGVuZ3RoICsgMTAwKTtcbiAgICBkZXJpdmF0aW9uLnVuYm91bmREZXBzQ291bnQgPSAwO1xuICAgIGRlcml2YXRpb24ucnVuSWQgPSArK2dsb2JhbFN0YXRlLnJ1bklkO1xuICAgIHZhciBwcmV2VHJhY2tpbmcgPSBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb247XG4gICAgZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uID0gZGVyaXZhdGlvbjtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IGYuY2FsbChjb250ZXh0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVzdWx0ID0gbmV3IENhdWdodEV4Y2VwdGlvbihlKTtcbiAgICB9XG4gICAgZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uID0gcHJldlRyYWNraW5nO1xuICAgIGJpbmREZXBlbmRlbmNpZXMoZGVyaXZhdGlvbik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogZGlmZnMgbmV3T2JzZXJ2aW5nIHdpdGggb2JzZXJ2aW5nLlxuICogdXBkYXRlIG9ic2VydmluZyB0byBiZSBuZXdPYnNlcnZpbmcgd2l0aCB1bmlxdWUgb2JzZXJ2YWJsZXNcbiAqIG5vdGlmeSBvYnNlcnZlcnMgdGhhdCBiZWNvbWUgb2JzZXJ2ZWQvdW5vYnNlcnZlZFxuICovXG5mdW5jdGlvbiBiaW5kRGVwZW5kZW5jaWVzKGRlcml2YXRpb24pIHtcbiAgICAvLyBpbnZhcmlhbnQoZGVyaXZhdGlvbi5kZXBlbmRlbmNpZXNTdGF0ZSAhPT0gSURlcml2YXRpb25TdGF0ZS5OT1RfVFJBQ0tJTkcsIFwiSU5URVJOQUwgRVJST1IgYmluZERlcGVuZGVuY2llcyBleHBlY3RzIGRlcml2YXRpb24uZGVwZW5kZW5jaWVzU3RhdGUgIT09IC0xXCIpO1xuICAgIHZhciBwcmV2T2JzZXJ2aW5nID0gZGVyaXZhdGlvbi5vYnNlcnZpbmc7XG4gICAgdmFyIG9ic2VydmluZyA9IChkZXJpdmF0aW9uLm9ic2VydmluZyA9IGRlcml2YXRpb24ubmV3T2JzZXJ2aW5nKTtcbiAgICB2YXIgbG93ZXN0TmV3T2JzZXJ2aW5nRGVyaXZhdGlvblN0YXRlID0gSURlcml2YXRpb25TdGF0ZS5VUF9UT19EQVRFO1xuICAgIC8vIEdvIHRocm91Z2ggYWxsIG5ldyBvYnNlcnZhYmxlcyBhbmQgY2hlY2sgZGlmZlZhbHVlOiAodGhpcyBsaXN0IGNhbiBjb250YWluIGR1cGxpY2F0ZXMpOlxuICAgIC8vICAgMDogZmlyc3Qgb2NjdXJyZW5jZSwgY2hhbmdlIHRvIDEgYW5kIGtlZXAgaXRcbiAgICAvLyAgIDE6IGV4dHJhIG9jY3VycmVuY2UsIGRyb3AgaXRcbiAgICB2YXIgaTAgPSAwLCBsID0gZGVyaXZhdGlvbi51bmJvdW5kRGVwc0NvdW50O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBkZXAgPSBvYnNlcnZpbmdbaV07XG4gICAgICAgIGlmIChkZXAuZGlmZlZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICBkZXAuZGlmZlZhbHVlID0gMTtcbiAgICAgICAgICAgIGlmIChpMCAhPT0gaSlcbiAgICAgICAgICAgICAgICBvYnNlcnZpbmdbaTBdID0gZGVwO1xuICAgICAgICAgICAgaTArKztcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGNhc3QgaXMgJ3NhZmUnIGhlcmUsIGJlY2F1c2UgaWYgZGVwIGlzIElPYnNlcnZhYmxlLCBgZGVwZW5kZW5jaWVzU3RhdGVgIHdpbGwgYmUgdW5kZWZpbmVkLFxuICAgICAgICAvLyBub3QgaGl0dGluZyB0aGUgY29uZGl0aW9uXG4gICAgICAgIGlmIChkZXAuZGVwZW5kZW5jaWVzU3RhdGUgPiBsb3dlc3ROZXdPYnNlcnZpbmdEZXJpdmF0aW9uU3RhdGUpIHtcbiAgICAgICAgICAgIGxvd2VzdE5ld09ic2VydmluZ0Rlcml2YXRpb25TdGF0ZSA9IGRlcC5kZXBlbmRlbmNpZXNTdGF0ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvYnNlcnZpbmcubGVuZ3RoID0gaTA7XG4gICAgZGVyaXZhdGlvbi5uZXdPYnNlcnZpbmcgPSBudWxsOyAvLyBuZXdPYnNlcnZpbmcgc2hvdWxkbid0IGJlIG5lZWRlZCBvdXRzaWRlIHRyYWNraW5nIChzdGF0ZW1lbnQgbW92ZWQgZG93biB0byB3b3JrIGFyb3VuZCBGRiBidWcsIHNlZSAjNjE0KVxuICAgIC8vIEdvIHRocm91Z2ggYWxsIG9sZCBvYnNlcnZhYmxlcyBhbmQgY2hlY2sgZGlmZlZhbHVlOiAoaXQgaXMgdW5pcXVlIGFmdGVyIGxhc3QgYmluZERlcGVuZGVuY2llcylcbiAgICAvLyAgIDA6IGl0J3Mgbm90IGluIG5ldyBvYnNlcnZhYmxlcywgdW5vYnNlcnZlIGl0XG4gICAgLy8gICAxOiBpdCBrZWVwcyBiZWluZyBvYnNlcnZlZCwgZG9uJ3Qgd2FudCB0byBub3RpZnkgaXQuIGNoYW5nZSB0byAwXG4gICAgbCA9IHByZXZPYnNlcnZpbmcubGVuZ3RoO1xuICAgIHdoaWxlIChsLS0pIHtcbiAgICAgICAgdmFyIGRlcCA9IHByZXZPYnNlcnZpbmdbbF07XG4gICAgICAgIGlmIChkZXAuZGlmZlZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICByZW1vdmVPYnNlcnZlcihkZXAsIGRlcml2YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGRlcC5kaWZmVmFsdWUgPSAwO1xuICAgIH1cbiAgICAvLyBHbyB0aHJvdWdoIGFsbCBuZXcgb2JzZXJ2YWJsZXMgYW5kIGNoZWNrIGRpZmZWYWx1ZTogKG5vdyBpdCBzaG91bGQgYmUgdW5pcXVlKVxuICAgIC8vICAgMDogaXQgd2FzIHNldCB0byAwIGluIGxhc3QgbG9vcC4gZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZy5cbiAgICAvLyAgIDE6IGl0IHdhc24ndCBvYnNlcnZlZCwgbGV0J3Mgb2JzZXJ2ZSBpdC4gc2V0IGJhY2sgdG8gMFxuICAgIHdoaWxlIChpMC0tKSB7XG4gICAgICAgIHZhciBkZXAgPSBvYnNlcnZpbmdbaTBdO1xuICAgICAgICBpZiAoZGVwLmRpZmZWYWx1ZSA9PT0gMSkge1xuICAgICAgICAgICAgZGVwLmRpZmZWYWx1ZSA9IDA7XG4gICAgICAgICAgICBhZGRPYnNlcnZlcihkZXAsIGRlcml2YXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFNvbWUgbmV3IG9ic2VydmVkIGRlcml2YXRpb25zIG1heSBiZWNvbWUgc3RhbGUgZHVyaW5nIHRoaXMgZGVyaXZhdGlvbiBjb21wdXRhdGlvblxuICAgIC8vIHNvIHRoZXkgaGF2ZSBoYWQgbm8gY2hhbmNlIHRvIHByb3BhZ2F0ZSBzdGFsZW5lc3MgKCM5MTYpXG4gICAgaWYgKGxvd2VzdE5ld09ic2VydmluZ0Rlcml2YXRpb25TdGF0ZSAhPT0gSURlcml2YXRpb25TdGF0ZS5VUF9UT19EQVRFKSB7XG4gICAgICAgIGRlcml2YXRpb24uZGVwZW5kZW5jaWVzU3RhdGUgPSBsb3dlc3ROZXdPYnNlcnZpbmdEZXJpdmF0aW9uU3RhdGU7XG4gICAgICAgIGRlcml2YXRpb24ub25CZWNvbWVTdGFsZSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsZWFyT2JzZXJ2aW5nKGRlcml2YXRpb24pIHtcbiAgICAvLyBpbnZhcmlhbnQoZ2xvYmFsU3RhdGUuaW5CYXRjaCA+IDAsIFwiSU5URVJOQUwgRVJST1IgY2xlYXJPYnNlcnZpbmcgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IGluc2lkZSBiYXRjaFwiKTtcbiAgICB2YXIgb2JzID0gZGVyaXZhdGlvbi5vYnNlcnZpbmc7XG4gICAgZGVyaXZhdGlvbi5vYnNlcnZpbmcgPSBbXTtcbiAgICB2YXIgaSA9IG9icy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSlcbiAgICAgICAgcmVtb3ZlT2JzZXJ2ZXIob2JzW2ldLCBkZXJpdmF0aW9uKTtcbiAgICBkZXJpdmF0aW9uLmRlcGVuZGVuY2llc1N0YXRlID0gSURlcml2YXRpb25TdGF0ZS5OT1RfVFJBQ0tJTkc7XG59XG5mdW5jdGlvbiB1bnRyYWNrZWQoYWN0aW9uKSB7XG4gICAgdmFyIHByZXYgPSB1bnRyYWNrZWRTdGFydCgpO1xuICAgIHZhciByZXMgPSBhY3Rpb24oKTtcbiAgICB1bnRyYWNrZWRFbmQocHJldik7XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIHVudHJhY2tlZFN0YXJ0KCkge1xuICAgIHZhciBwcmV2ID0gZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uO1xuICAgIGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbiA9IG51bGw7XG4gICAgcmV0dXJuIHByZXY7XG59XG5mdW5jdGlvbiB1bnRyYWNrZWRFbmQocHJldikge1xuICAgIGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbiA9IHByZXY7XG59XG4vKipcbiAqIG5lZWRlZCB0byBrZWVwIGBsb3dlc3RPYnNlcnZlclN0YXRlYCBjb3JyZWN0LiB3aGVuIGNoYW5naW5nIGZyb20gKDIgb3IgMSkgdG8gMFxuICpcbiAqL1xuZnVuY3Rpb24gY2hhbmdlRGVwZW5kZW5jaWVzU3RhdGVUbzAoZGVyaXZhdGlvbikge1xuICAgIGlmIChkZXJpdmF0aW9uLmRlcGVuZGVuY2llc1N0YXRlID09PSBJRGVyaXZhdGlvblN0YXRlLlVQX1RPX0RBVEUpXG4gICAgICAgIHJldHVybjtcbiAgICBkZXJpdmF0aW9uLmRlcGVuZGVuY2llc1N0YXRlID0gSURlcml2YXRpb25TdGF0ZS5VUF9UT19EQVRFO1xuICAgIHZhciBvYnMgPSBkZXJpdmF0aW9uLm9ic2VydmluZztcbiAgICB2YXIgaSA9IG9icy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSlcbiAgICAgICAgb2JzW2ldLmxvd2VzdE9ic2VydmVyU3RhdGUgPSBJRGVyaXZhdGlvblN0YXRlLlVQX1RPX0RBVEU7XG59XG5cbmZ1bmN0aW9uIGxvZyhtc2cpIHtcbiAgICBjb25zb2xlLmxvZyhtc2cpO1xuICAgIHJldHVybiBtc2c7XG59XG5mdW5jdGlvbiB3aHlSdW4odGhpbmcsIHByb3ApIHtcbiAgICBkZXByZWNhdGVkKFwiYHdoeVJ1bmAgaXMgZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBgdHJhY2VgXCIpO1xuICAgIHRoaW5nID0gZ2V0QXRvbUZyb21BcmdzKGFyZ3VtZW50cyk7XG4gICAgaWYgKCF0aGluZylcbiAgICAgICAgcmV0dXJuIGxvZyhnZXRNZXNzYWdlKFwibTAyNFwiKSk7XG4gICAgaWYgKGlzQ29tcHV0ZWRWYWx1ZSh0aGluZykgfHwgaXNSZWFjdGlvbih0aGluZykpXG4gICAgICAgIHJldHVybiBsb2codGhpbmcud2h5UnVuKCkpO1xuICAgIHJldHVybiBmYWlsKGdldE1lc3NhZ2UoXCJtMDI1XCIpKTtcbn1cbmZ1bmN0aW9uIHRyYWNlKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgZW50ZXJCcmVha1BvaW50ID0gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09IFwiYm9vbGVhblwiKVxuICAgICAgICBlbnRlckJyZWFrUG9pbnQgPSBhcmdzLnBvcCgpO1xuICAgIHZhciBkZXJpdmF0aW9uID0gZ2V0QXRvbUZyb21BcmdzKGFyZ3MpO1xuICAgIGlmICghZGVyaXZhdGlvbikge1xuICAgICAgICByZXR1cm4gZmFpbChcIid0cmFjZShicmVhaz8pJyBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBhIHRyYWNrZWQgY29tcHV0ZWQgdmFsdWUgb3IgYSBSZWFjdGlvbi4gQ29uc2lkZXIgcGFzc2luZyBpbiB0aGUgY29tcHV0ZWQgdmFsdWUgb3IgcmVhY3Rpb24gZXhwbGljaXRseVwiKTtcbiAgICB9XG4gICAgaWYgKGRlcml2YXRpb24uaXNUcmFjaW5nID09PSBUcmFjZU1vZGUuTk9ORSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlttb2J4LnRyYWNlXSAnXCIgKyBkZXJpdmF0aW9uLm5hbWUgKyBcIicgdHJhY2luZyBlbmFibGVkXCIpO1xuICAgIH1cbiAgICBkZXJpdmF0aW9uLmlzVHJhY2luZyA9IGVudGVyQnJlYWtQb2ludCA/IFRyYWNlTW9kZS5CUkVBSyA6IFRyYWNlTW9kZS5MT0c7XG59XG5mdW5jdGlvbiBnZXRBdG9tRnJvbUFyZ3MoYXJncykge1xuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbjtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIGdldEF0b20oYXJnc1swXSk7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBnZXRBdG9tKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIH1cbn1cblxudmFyIFJlYWN0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWFjdGlvbihuYW1lLCBvbkludmFsaWRhdGUpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09IHZvaWQgMCkgeyBuYW1lID0gXCJSZWFjdGlvbkBcIiArIGdldE5leHRJZCgpOyB9XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMub25JbnZhbGlkYXRlID0gb25JbnZhbGlkYXRlO1xuICAgICAgICB0aGlzLm9ic2VydmluZyA9IFtdOyAvLyBub2RlcyB3ZSBhcmUgbG9va2luZyBhdC4gT3VyIHZhbHVlIGRlcGVuZHMgb24gdGhlc2Ugbm9kZXNcbiAgICAgICAgdGhpcy5uZXdPYnNlcnZpbmcgPSBbXTtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXNTdGF0ZSA9IElEZXJpdmF0aW9uU3RhdGUuTk9UX1RSQUNLSU5HO1xuICAgICAgICB0aGlzLmRpZmZWYWx1ZSA9IDA7XG4gICAgICAgIHRoaXMucnVuSWQgPSAwO1xuICAgICAgICB0aGlzLnVuYm91bmREZXBzQ291bnQgPSAwO1xuICAgICAgICB0aGlzLl9fbWFwaWQgPSBcIiNcIiArIGdldE5leHRJZCgpO1xuICAgICAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNUcmFja1BlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNUcmFjaW5nID0gVHJhY2VNb2RlLk5PTkU7XG4gICAgfVxuICAgIFJlYWN0aW9uLnByb3RvdHlwZS5vbkJlY29tZVN0YWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNjaGVkdWxlKCk7XG4gICAgfTtcbiAgICBSZWFjdGlvbi5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNTY2hlZHVsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGdsb2JhbFN0YXRlLnBlbmRpbmdSZWFjdGlvbnMucHVzaCh0aGlzKTtcbiAgICAgICAgICAgIHJ1blJlYWN0aW9ucygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWFjdGlvbi5wcm90b3R5cGUuaXNTY2hlZHVsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1NjaGVkdWxlZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGludGVybmFsLCB1c2Ugc2NoZWR1bGUoKSBpZiB5b3UgaW50ZW5kIHRvIGtpY2sgb2ZmIGEgcmVhY3Rpb25cbiAgICAgKi9cbiAgICBSZWFjdGlvbi5wcm90b3R5cGUucnVuUmVhY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICBzdGFydEJhdGNoKCk7XG4gICAgICAgICAgICB0aGlzLl9pc1NjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHNob3VsZENvbXB1dGUodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1RyYWNrUGVuZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkludmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNUcmFja1BlbmRpbmcgJiYgaXNTcHlFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb25JbnZhbGlkYXRlIGRpZG4ndCB0cmlnZ2VyIHRyYWNrIHJpZ2h0IGF3YXkuLlxuICAgICAgICAgICAgICAgICAgICBzcHlSZXBvcnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzY2hlZHVsZWQtcmVhY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbmRCYXRjaCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWFjdGlvbi5wcm90b3R5cGUudHJhY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgc3RhcnRCYXRjaCgpO1xuICAgICAgICB2YXIgbm90aWZ5ID0gaXNTcHlFbmFibGVkKCk7XG4gICAgICAgIHZhciBzdGFydFRpbWU7XG4gICAgICAgIGlmIChub3RpZnkpIHtcbiAgICAgICAgICAgIHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBzcHlSZXBvcnRTdGFydCh7XG4gICAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhY3Rpb25cIixcbiAgICAgICAgICAgICAgICBmbjogZm5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzUnVubmluZyA9IHRydWU7XG4gICAgICAgIHZhciByZXN1bHQgPSB0cmFja0Rlcml2ZWRGdW5jdGlvbih0aGlzLCBmbiwgdW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5faXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzVHJhY2tQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgIC8vIGRpc3Bvc2VkIGR1cmluZyBsYXN0IHJ1bi4gQ2xlYW4gdXAgZXZlcnl0aGluZyB0aGF0IHdhcyBib3VuZCBhZnRlciB0aGUgZGlzcG9zZSBjYWxsLlxuICAgICAgICAgICAgY2xlYXJPYnNlcnZpbmcodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ2F1Z2h0RXhjZXB0aW9uKHJlc3VsdCkpXG4gICAgICAgICAgICB0aGlzLnJlcG9ydEV4Y2VwdGlvbkluRGVyaXZhdGlvbihyZXN1bHQuY2F1c2UpO1xuICAgICAgICBpZiAobm90aWZ5KSB7XG4gICAgICAgICAgICBzcHlSZXBvcnRFbmQoe1xuICAgICAgICAgICAgICAgIHRpbWU6IERhdGUubm93KCkgLSBzdGFydFRpbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVuZEJhdGNoKCk7XG4gICAgfTtcbiAgICBSZWFjdGlvbi5wcm90b3R5cGUucmVwb3J0RXhjZXB0aW9uSW5EZXJpdmF0aW9uID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmVycm9ySGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIoZXJyb3IsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtZXNzYWdlID0gXCJbbW9ieF0gRW5jb3VudGVyZWQgYW4gdW5jYXVnaHQgZXhjZXB0aW9uIHRoYXQgd2FzIHRocm93biBieSBhIHJlYWN0aW9uIG9yIG9ic2VydmVyIGNvbXBvbmVudCwgaW46ICdcIiArIHRoaXM7XG4gICAgICAgIHZhciBtZXNzYWdlVG9Vc2VyID0gZ2V0TWVzc2FnZShcIm0wMzdcIik7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSB8fCBtZXNzYWdlVG9Vc2VyIC8qIGxhdHRlciB3aWxsIG5vdCBiZSB0cnVlLCBtYWtlIHN1cmUgdWdsaWZ5IGRvZXNuJ3QgcmVtb3ZlICovLCBlcnJvcik7XG4gICAgICAgIC8qKiBJZiBkZWJ1Z2dpbmcgYnJvdWdodCB5b3UgaGVyZSwgcGxlYXNlLCByZWFkIHRoZSBhYm92ZSBtZXNzYWdlIDotKS4gVG54ISAqL1xuICAgICAgICBpZiAoaXNTcHlFbmFibGVkKCkpIHtcbiAgICAgICAgICAgIHNweVJlcG9ydCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIG9iamVjdDogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2xvYmFsU3RhdGUuZ2xvYmFsUmVhY3Rpb25FcnJvckhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYoZXJyb3IsIF90aGlzKTsgfSk7XG4gICAgfTtcbiAgICBSZWFjdGlvbi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzUnVubmluZykge1xuICAgICAgICAgICAgICAgIC8vIGlmIGRpc3Bvc2VkIHdoaWxlIHJ1bm5pbmcsIGNsZWFuIHVwIGxhdGVyLiBNYXliZSBub3Qgb3B0aW1hbCwgYnV0IHJhcmUgY2FzZVxuICAgICAgICAgICAgICAgIHN0YXJ0QmF0Y2goKTtcbiAgICAgICAgICAgICAgICBjbGVhck9ic2VydmluZyh0aGlzKTtcbiAgICAgICAgICAgICAgICBlbmRCYXRjaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWFjdGlvbi5wcm90b3R5cGUuZ2V0RGlzcG9zZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByID0gdGhpcy5kaXNwb3NlLmJpbmQodGhpcyk7XG4gICAgICAgIHIuJG1vYnggPSB0aGlzO1xuICAgICAgICByLm9uRXJyb3IgPSByZWdpc3RlckVycm9ySGFuZGxlcjtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICBSZWFjdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlJlYWN0aW9uW1wiICsgdGhpcy5uYW1lICsgXCJdXCI7XG4gICAgfTtcbiAgICBSZWFjdGlvbi5wcm90b3R5cGUud2h5UnVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb2JzZXJ2aW5nID0gdW5pcXVlKHRoaXMuX2lzUnVubmluZyA/IHRoaXMubmV3T2JzZXJ2aW5nIDogdGhpcy5vYnNlcnZpbmcpLm1hcChmdW5jdGlvbiAoZGVwKSB7IHJldHVybiBkZXAubmFtZTsgfSk7XG4gICAgICAgIHJldHVybiBcIlxcbldoeVJ1bj8gcmVhY3Rpb24gJ1wiICsgdGhpcy5uYW1lICsgXCInOlxcbiAqIFN0YXR1czogW1wiICsgKHRoaXMuaXNEaXNwb3NlZFxuICAgICAgICAgICAgPyBcInN0b3BwZWRcIlxuICAgICAgICAgICAgOiB0aGlzLl9pc1J1bm5pbmcgPyBcInJ1bm5pbmdcIiA6IHRoaXMuaXNTY2hlZHVsZWQoKSA/IFwic2NoZWR1bGVkXCIgOiBcImlkbGVcIikgKyBcIl1cXG4gKiBUaGlzIHJlYWN0aW9uIHdpbGwgcmUtcnVuIGlmIGFueSBvZiB0aGUgZm9sbG93aW5nIG9ic2VydmFibGVzIGNoYW5nZXM6XFxuICAgIFwiICsgam9pblN0cmluZ3Mob2JzZXJ2aW5nKSArIFwiXFxuICAgIFwiICsgKHRoaXMuX2lzUnVubmluZ1xuICAgICAgICAgICAgPyBcIiAoLi4uIG9yIGFueSBvYnNlcnZhYmxlIGFjY2Vzc2VkIGR1cmluZyB0aGUgcmVtYWluZGVyIG9mIHRoZSBjdXJyZW50IHJ1bilcIlxuICAgICAgICAgICAgOiBcIlwiKSArIFwiXFxuXFx0XCIgKyBnZXRNZXNzYWdlKFwibTAzOFwiKSArIFwiXFxuXCI7XG4gICAgfTtcbiAgICBSZWFjdGlvbi5wcm90b3R5cGUudHJhY2UgPSBmdW5jdGlvbiAoZW50ZXJCcmVha1BvaW50KSB7XG4gICAgICAgIGlmIChlbnRlckJyZWFrUG9pbnQgPT09IHZvaWQgMCkgeyBlbnRlckJyZWFrUG9pbnQgPSBmYWxzZTsgfVxuICAgICAgICB0cmFjZSh0aGlzLCBlbnRlckJyZWFrUG9pbnQpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlYWN0aW9uO1xufSgpKTtcbmZ1bmN0aW9uIHJlZ2lzdGVyRXJyb3JIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICBpbnZhcmlhbnQodGhpcyAmJiB0aGlzLiRtb2J4ICYmIGlzUmVhY3Rpb24odGhpcy4kbW9ieCksIFwiSW52YWxpZCBgdGhpc2BcIik7XG4gICAgaW52YXJpYW50KCF0aGlzLiRtb2J4LmVycm9ySGFuZGxlciwgXCJPbmx5IG9uZSBvbkVycm9ySGFuZGxlciBjYW4gYmUgcmVnaXN0ZXJlZFwiKTtcbiAgICB0aGlzLiRtb2J4LmVycm9ySGFuZGxlciA9IGhhbmRsZXI7XG59XG5mdW5jdGlvbiBvblJlYWN0aW9uRXJyb3IoaGFuZGxlcikge1xuICAgIGdsb2JhbFN0YXRlLmdsb2JhbFJlYWN0aW9uRXJyb3JIYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpZHggPSBnbG9iYWxTdGF0ZS5nbG9iYWxSZWFjdGlvbkVycm9ySGFuZGxlcnMuaW5kZXhPZihoYW5kbGVyKTtcbiAgICAgICAgaWYgKGlkeCA+PSAwKVxuICAgICAgICAgICAgZ2xvYmFsU3RhdGUuZ2xvYmFsUmVhY3Rpb25FcnJvckhhbmRsZXJzLnNwbGljZShpZHgsIDEpO1xuICAgIH07XG59XG4vKipcbiAqIE1hZ2ljIG51bWJlciBhbGVydCFcbiAqIERlZmluZXMgd2l0aGluIGhvdyBtYW55IHRpbWVzIGEgcmVhY3Rpb24gaXMgYWxsb3dlZCB0byByZS10cmlnZ2VyIGl0c2VsZlxuICogdW50aWwgaXQgaXMgYXNzdW1lZCB0aGF0IHRoaXMgaXMgZ29ubmEgYmUgYSBuZXZlciBlbmRpbmcgbG9vcC4uLlxuICovXG52YXIgTUFYX1JFQUNUSU9OX0lURVJBVElPTlMgPSAxMDA7XG52YXIgcmVhY3Rpb25TY2hlZHVsZXIgPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gZigpOyB9O1xuZnVuY3Rpb24gcnVuUmVhY3Rpb25zKCkge1xuICAgIC8vIFRyYW1wb2xpbmluZywgaWYgcnVuUmVhY3Rpb25zIGFyZSBhbHJlYWR5IHJ1bm5pbmcsIG5ldyByZWFjdGlvbnMgd2lsbCBiZSBwaWNrZWQgdXBcbiAgICBpZiAoZ2xvYmFsU3RhdGUuaW5CYXRjaCA+IDAgfHwgZ2xvYmFsU3RhdGUuaXNSdW5uaW5nUmVhY3Rpb25zKVxuICAgICAgICByZXR1cm47XG4gICAgcmVhY3Rpb25TY2hlZHVsZXIocnVuUmVhY3Rpb25zSGVscGVyKTtcbn1cbmZ1bmN0aW9uIHJ1blJlYWN0aW9uc0hlbHBlcigpIHtcbiAgICBnbG9iYWxTdGF0ZS5pc1J1bm5pbmdSZWFjdGlvbnMgPSB0cnVlO1xuICAgIHZhciBhbGxSZWFjdGlvbnMgPSBnbG9iYWxTdGF0ZS5wZW5kaW5nUmVhY3Rpb25zO1xuICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAvLyBXaGlsZSBydW5uaW5nIHJlYWN0aW9ucywgbmV3IHJlYWN0aW9ucyBtaWdodCBiZSB0cmlnZ2VyZWQuXG4gICAgLy8gSGVuY2Ugd2Ugd29yayB3aXRoIHR3byB2YXJpYWJsZXMgYW5kIGNoZWNrIHdoZXRoZXJcbiAgICAvLyB3ZSBjb252ZXJnZSB0byBubyByZW1haW5pbmcgcmVhY3Rpb25zIGFmdGVyIGEgd2hpbGUuXG4gICAgd2hpbGUgKGFsbFJlYWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmICgrK2l0ZXJhdGlvbnMgPT09IE1BWF9SRUFDVElPTl9JVEVSQVRJT05TKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiUmVhY3Rpb24gZG9lc24ndCBjb252ZXJnZSB0byBhIHN0YWJsZSBzdGF0ZSBhZnRlciBcIiArIE1BWF9SRUFDVElPTl9JVEVSQVRJT05TICsgXCIgaXRlcmF0aW9ucy5cIiArXG4gICAgICAgICAgICAgICAgKFwiIFByb2JhYmx5IHRoZXJlIGlzIGEgY3ljbGUgaW4gdGhlIHJlYWN0aXZlIGZ1bmN0aW9uOiBcIiArIGFsbFJlYWN0aW9uc1swXSkpO1xuICAgICAgICAgICAgYWxsUmVhY3Rpb25zLnNwbGljZSgwKTsgLy8gY2xlYXIgcmVhY3Rpb25zXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlbWFpbmluZ1JlYWN0aW9ucyA9IGFsbFJlYWN0aW9ucy5zcGxpY2UoMCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcmVtYWluaW5nUmVhY3Rpb25zLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgICAgIHJlbWFpbmluZ1JlYWN0aW9uc1tpXS5ydW5SZWFjdGlvbigpO1xuICAgIH1cbiAgICBnbG9iYWxTdGF0ZS5pc1J1bm5pbmdSZWFjdGlvbnMgPSBmYWxzZTtcbn1cbnZhciBpc1JlYWN0aW9uID0gY3JlYXRlSW5zdGFuY2VvZlByZWRpY2F0ZShcIlJlYWN0aW9uXCIsIFJlYWN0aW9uKTtcbmZ1bmN0aW9uIHNldFJlYWN0aW9uU2NoZWR1bGVyKGZuKSB7XG4gICAgdmFyIGJhc2VTY2hlZHVsZXIgPSByZWFjdGlvblNjaGVkdWxlcjtcbiAgICByZWFjdGlvblNjaGVkdWxlciA9IGZ1bmN0aW9uIChmKSB7IHJldHVybiBmbihmdW5jdGlvbiAoKSB7IHJldHVybiBiYXNlU2NoZWR1bGVyKGYpOyB9KTsgfTtcbn1cblxuZnVuY3Rpb24gYXNSZWZlcmVuY2UodmFsdWUpIHtcbiAgICBkZXByZWNhdGVkKFwiYXNSZWZlcmVuY2UgaXMgZGVwcmVjYXRlZCwgdXNlIG9ic2VydmFibGUucmVmIGluc3RlYWRcIik7XG4gICAgcmV0dXJuIG9ic2VydmFibGUucmVmKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGFzU3RydWN0dXJlKHZhbHVlKSB7XG4gICAgZGVwcmVjYXRlZChcImFzU3RydWN0dXJlIGlzIGRlcHJlY2F0ZWQuIFVzZSBvYnNlcnZhYmxlLnN0cnVjdCwgY29tcHV0ZWQuc3RydWN0IG9yIHJlYWN0aW9uIG9wdGlvbnMgaW5zdGVhZC5cIik7XG4gICAgcmV0dXJuIG9ic2VydmFibGUuc3RydWN0KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGFzRmxhdCh2YWx1ZSkge1xuICAgIGRlcHJlY2F0ZWQoXCJhc0ZsYXQgaXMgZGVwcmVjYXRlZCwgdXNlIG9ic2VydmFibGUuc2hhbGxvdyBpbnN0ZWFkXCIpO1xuICAgIHJldHVybiBvYnNlcnZhYmxlLnNoYWxsb3codmFsdWUpO1xufVxuZnVuY3Rpb24gYXNNYXAoZGF0YSkge1xuICAgIGRlcHJlY2F0ZWQoXCJhc01hcCBpcyBkZXByZWNhdGVkLCB1c2Ugb2JzZXJ2YWJsZS5tYXAgb3Igb2JzZXJ2YWJsZS5zaGFsbG93TWFwIGluc3RlYWRcIik7XG4gICAgcmV0dXJuIG9ic2VydmFibGUubWFwKGRhdGEgfHwge30pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wdXRlZERlY29yYXRvcihlcXVhbHMpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2xhc3NQcm9wZXJ0eURlY29yYXRvcihmdW5jdGlvbiAodGFyZ2V0LCBuYW1lLCBfLCBfXywgb3JpZ2luYWxEZXNjcmlwdG9yKSB7XG4gICAgICAgIGludmFyaWFudCh0eXBlb2Ygb3JpZ2luYWxEZXNjcmlwdG9yICE9PSBcInVuZGVmaW5lZFwiLCBnZXRNZXNzYWdlKFwibTAwOVwiKSk7XG4gICAgICAgIGludmFyaWFudCh0eXBlb2Ygb3JpZ2luYWxEZXNjcmlwdG9yLmdldCA9PT0gXCJmdW5jdGlvblwiLCBnZXRNZXNzYWdlKFwibTAxMFwiKSk7XG4gICAgICAgIHZhciBhZG0gPSBhc09ic2VydmFibGVPYmplY3QodGFyZ2V0LCBcIlwiKTtcbiAgICAgICAgZGVmaW5lQ29tcHV0ZWRQcm9wZXJ0eShhZG0sIG5hbWUsIG9yaWdpbmFsRGVzY3JpcHRvci5nZXQsIG9yaWdpbmFsRGVzY3JpcHRvci5zZXQsIGVxdWFscywgZmFsc2UpO1xuICAgIH0sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBvYnNlcnZhYmxlID0gdGhpcy4kbW9ieC52YWx1ZXNbbmFtZV07XG4gICAgICAgIGlmIChvYnNlcnZhYmxlID09PSB1bmRlZmluZWQgLy8gU2VlICM1MDVcbiAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGUuZ2V0KCk7XG4gICAgfSwgZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuJG1vYngudmFsdWVzW25hbWVdLnNldCh2YWx1ZSk7XG4gICAgfSwgZmFsc2UsIGZhbHNlKTtcbn1cbnZhciBjb21wdXRlZERlY29yYXRvciA9IGNyZWF0ZUNvbXB1dGVkRGVjb3JhdG9yKGNvbXBhcmVyLmRlZmF1bHQpO1xudmFyIGNvbXB1dGVkU3RydWN0RGVjb3JhdG9yID0gY3JlYXRlQ29tcHV0ZWREZWNvcmF0b3IoY29tcGFyZXIuc3RydWN0dXJhbCk7XG4vKipcbiAqIERlY29yYXRvciBmb3IgY2xhc3MgcHJvcGVydGllczogQGNvbXB1dGVkIGdldCB2YWx1ZSgpIHsgcmV0dXJuIGV4cHI7IH0uXG4gKiBGb3IgbGVnYWN5IHB1cnBvc2VzIGFsc28gaW52b2thYmxlIGFzIEVTNSBvYnNlcnZhYmxlIGNyZWF0ZWQ6IGBjb21wdXRlZCgoKSA9PiBleHByKWA7XG4gKi9cbnZhciBjb21wdXRlZCA9IGZ1bmN0aW9uIGNvbXB1dGVkKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICBpZiAodHlwZW9mIGFyZzIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGNvbXB1dGVkRGVjb3JhdG9yLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGludmFyaWFudCh0eXBlb2YgYXJnMSA9PT0gXCJmdW5jdGlvblwiLCBnZXRNZXNzYWdlKFwibTAxMVwiKSk7XG4gICAgaW52YXJpYW50KGFyZ3VtZW50cy5sZW5ndGggPCAzLCBnZXRNZXNzYWdlKFwibTAxMlwiKSk7XG4gICAgdmFyIG9wdHMgPSB0eXBlb2YgYXJnMiA9PT0gXCJvYmplY3RcIiA/IGFyZzIgOiB7fTtcbiAgICBvcHRzLnNldHRlciA9IHR5cGVvZiBhcmcyID09PSBcImZ1bmN0aW9uXCIgPyBhcmcyIDogb3B0cy5zZXR0ZXI7XG4gICAgdmFyIGVxdWFscyA9IG9wdHMuZXF1YWxzXG4gICAgICAgID8gb3B0cy5lcXVhbHNcbiAgICAgICAgOiBvcHRzLmNvbXBhcmVTdHJ1Y3R1cmFsIHx8IG9wdHMuc3RydWN0ID8gY29tcGFyZXIuc3RydWN0dXJhbCA6IGNvbXBhcmVyLmRlZmF1bHQ7XG4gICAgcmV0dXJuIG5ldyBDb21wdXRlZFZhbHVlKGFyZzEsIG9wdHMuY29udGV4dCwgZXF1YWxzLCBvcHRzLm5hbWUgfHwgYXJnMS5uYW1lIHx8IFwiXCIsIG9wdHMuc2V0dGVyKTtcbn07XG5jb21wdXRlZC5zdHJ1Y3QgPSBjb21wdXRlZFN0cnVjdERlY29yYXRvcjtcbmNvbXB1dGVkLmVxdWFscyA9IGNyZWF0ZUNvbXB1dGVkRGVjb3JhdG9yO1xuXG5mdW5jdGlvbiBpc0NvbXB1dGVkKHZhbHVlLCBwcm9wZXJ0eSkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdCh2YWx1ZSkgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIXZhbHVlLiRtb2J4LnZhbHVlc1twcm9wZXJ0eV0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBhdG9tID0gZ2V0QXRvbSh2YWx1ZSwgcHJvcGVydHkpO1xuICAgICAgICByZXR1cm4gaXNDb21wdXRlZFZhbHVlKGF0b20pO1xuICAgIH1cbiAgICByZXR1cm4gaXNDb21wdXRlZFZhbHVlKHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gb2JzZXJ2ZSh0aGluZywgcHJvcE9yQ2IsIGNiT3JGaXJlLCBmaXJlSW1tZWRpYXRlbHkpIHtcbiAgICBpZiAodHlwZW9mIGNiT3JGaXJlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybiBvYnNlcnZlT2JzZXJ2YWJsZVByb3BlcnR5KHRoaW5nLCBwcm9wT3JDYiwgY2JPckZpcmUsIGZpcmVJbW1lZGlhdGVseSk7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gb2JzZXJ2ZU9ic2VydmFibGUodGhpbmcsIHByb3BPckNiLCBjYk9yRmlyZSk7XG59XG5mdW5jdGlvbiBvYnNlcnZlT2JzZXJ2YWJsZSh0aGluZywgbGlzdGVuZXIsIGZpcmVJbW1lZGlhdGVseSkge1xuICAgIHJldHVybiBnZXRBZG1pbmlzdHJhdGlvbih0aGluZykub2JzZXJ2ZShsaXN0ZW5lciwgZmlyZUltbWVkaWF0ZWx5KTtcbn1cbmZ1bmN0aW9uIG9ic2VydmVPYnNlcnZhYmxlUHJvcGVydHkodGhpbmcsIHByb3BlcnR5LCBsaXN0ZW5lciwgZmlyZUltbWVkaWF0ZWx5KSB7XG4gICAgcmV0dXJuIGdldEFkbWluaXN0cmF0aW9uKHRoaW5nLCBwcm9wZXJ0eSkub2JzZXJ2ZShsaXN0ZW5lciwgZmlyZUltbWVkaWF0ZWx5KTtcbn1cblxuZnVuY3Rpb24gaW50ZXJjZXB0KHRoaW5nLCBwcm9wT3JIYW5kbGVyLCBoYW5kbGVyKSB7XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybiBpbnRlcmNlcHRQcm9wZXJ0eSh0aGluZywgcHJvcE9ySGFuZGxlciwgaGFuZGxlcik7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gaW50ZXJjZXB0SW50ZXJjZXB0YWJsZSh0aGluZywgcHJvcE9ySGFuZGxlcik7XG59XG5mdW5jdGlvbiBpbnRlcmNlcHRJbnRlcmNlcHRhYmxlKHRoaW5nLCBoYW5kbGVyKSB7XG4gICAgcmV0dXJuIGdldEFkbWluaXN0cmF0aW9uKHRoaW5nKS5pbnRlcmNlcHQoaGFuZGxlcik7XG59XG5mdW5jdGlvbiBpbnRlcmNlcHRQcm9wZXJ0eSh0aGluZywgcHJvcGVydHksIGhhbmRsZXIpIHtcbiAgICByZXR1cm4gZ2V0QWRtaW5pc3RyYXRpb24odGhpbmcsIHByb3BlcnR5KS5pbnRlcmNlcHQoaGFuZGxlcik7XG59XG5cbi8qKlxuICogZXhwciBjYW4gYmUgdXNlZCB0byBjcmVhdGUgdGVtcG9yYXJpbHkgdmlld3MgaW5zaWRlIHZpZXdzLlxuICogVGhpcyBjYW4gYmUgaW1wcm92ZWQgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZSBpZiBhIHZhbHVlIGNoYW5nZXMgb2Z0ZW4sIGJ1dCB1c3VhbGx5IGRvZXNuJ3QgYWZmZWN0IHRoZSBvdXRjb21lIG9mIGFuIGV4cHJlc3Npb24uXG4gKlxuICogSW4gdGhlIGZvbGxvd2luZyBleGFtcGxlIHRoZSBleHByZXNzaW9uIHByZXZlbnRzIHRoYXQgYSBjb21wb25lbnQgaXMgcmVyZW5kZXIgX2VhY2ggdGltZV8gdGhlIHNlbGVjdGlvbiBjaGFuZ2VzO1xuICogaW5zdGVhZCBpdCB3aWxsIG9ubHkgcmVyZW5kZXJzIHdoZW4gdGhlIGN1cnJlbnQgdG9kbyBpcyAoZGUpc2VsZWN0ZWQuXG4gKlxuICogcmVhY3RpdmVDb21wb25lbnQoKHByb3BzKSA9PiB7XG4gKiAgICAgY29uc3QgdG9kbyA9IHByb3BzLnRvZG87XG4gKiAgICAgY29uc3QgaXNTZWxlY3RlZCA9IG1vYnguZXhwcigoKSA9PiBwcm9wcy52aWV3U3RhdGUuc2VsZWN0aW9uID09PSB0b2RvKTtcbiAqICAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9e2lzU2VsZWN0ZWQgPyBcInRvZG8gdG9kby1zZWxlY3RlZFwiIDogXCJ0b2RvXCJ9Pnt0b2RvLnRpdGxlfTwvZGl2PlxuICogfSk7XG4gKlxuICovXG5mdW5jdGlvbiBleHByKGV4cHIsIHNjb3BlKSB7XG4gICAgaWYgKCFpc0NvbXB1dGluZ0Rlcml2YXRpb24oKSlcbiAgICAgICAgY29uc29sZS53YXJuKGdldE1lc3NhZ2UoXCJtMDEzXCIpKTtcbiAgICAvLyBvcHRpbWl6YXRpb246IHdvdWxkIGJlIG1vcmUgZWZmaWNpZW50IGlmIHRoZSBleHByIGl0c2VsZiB3b3VsZG4ndCBiZSBldmFsdWF0ZWQgZmlyc3Qgb24gdGhlIG5leHQgY2hhbmdlLCBidXQganVzdCBhICdjaGFuZ2VkJyBzaWduYWwgd291bGQgYmUgZmlyZWRcbiAgICByZXR1cm4gY29tcHV0ZWQoZXhwciwgeyBjb250ZXh0OiBzY29wZSB9KS5nZXQoKTtcbn1cblxuZnVuY3Rpb24gdG9KUyhzb3VyY2UsIGRldGVjdEN5Y2xlcywgX19hbHJlYWR5U2Vlbikge1xuICAgIGlmIChkZXRlY3RDeWNsZXMgPT09IHZvaWQgMCkgeyBkZXRlY3RDeWNsZXMgPSB0cnVlOyB9XG4gICAgaWYgKF9fYWxyZWFkeVNlZW4gPT09IHZvaWQgMCkgeyBfX2FscmVhZHlTZWVuID0gW107IH1cbiAgICAvLyBvcHRpbWl6YXRpb246IHVzaW5nIEVTNiBtYXAgd291bGQgYmUgbW9yZSBlZmZpY2llbnQhXG4gICAgLy8gb3B0aW1pemF0aW9uOiBsaWZ0IHRoaXMgZnVuY3Rpb24gb3V0c2lkZSB0b0pTLCB0aGlzIG1ha2VzIHJlY3Vyc2lvbiBleHBlbnNpdmVcbiAgICBmdW5jdGlvbiBjYWNoZSh2YWx1ZSkge1xuICAgICAgICBpZiAoZGV0ZWN0Q3ljbGVzKVxuICAgICAgICAgICAgX19hbHJlYWR5U2Vlbi5wdXNoKFtzb3VyY2UsIHZhbHVlXSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKGlzT2JzZXJ2YWJsZShzb3VyY2UpKSB7XG4gICAgICAgIGlmIChkZXRlY3RDeWNsZXMgJiYgX19hbHJlYWR5U2VlbiA9PT0gbnVsbClcbiAgICAgICAgICAgIF9fYWxyZWFkeVNlZW4gPSBbXTtcbiAgICAgICAgaWYgKGRldGVjdEN5Y2xlcyAmJiBzb3VyY2UgIT09IG51bGwgJiYgdHlwZW9mIHNvdXJjZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBfX2FscmVhZHlTZWVuLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAoX19hbHJlYWR5U2VlbltpXVswXSA9PT0gc291cmNlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hbHJlYWR5U2VlbltpXVsxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNPYnNlcnZhYmxlQXJyYXkoc291cmNlKSkge1xuICAgICAgICAgICAgdmFyIHJlcyA9IGNhY2hlKFtdKTtcbiAgICAgICAgICAgIHZhciB0b0FkZCA9IHNvdXJjZS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB0b0pTKHZhbHVlLCBkZXRlY3RDeWNsZXMsIF9fYWxyZWFkeVNlZW4pOyB9KTtcbiAgICAgICAgICAgIHJlcy5sZW5ndGggPSB0b0FkZC5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRvQWRkLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgICAgICAgICByZXNbaV0gPSB0b0FkZFtpXTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdChzb3VyY2UpKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gY2FjaGUoe30pO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSlcbiAgICAgICAgICAgICAgICByZXNba2V5XSA9IHRvSlMoc291cmNlW2tleV0sIGRldGVjdEN5Y2xlcywgX19hbHJlYWR5U2Vlbik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc09ic2VydmFibGVNYXAoc291cmNlKSkge1xuICAgICAgICAgICAgdmFyIHJlc18xID0gY2FjaGUoe30pO1xuICAgICAgICAgICAgc291cmNlLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHsgcmV0dXJuIChyZXNfMVtrZXldID0gdG9KUyh2YWx1ZSwgZGV0ZWN0Q3ljbGVzLCBfX2FscmVhZHlTZWVuKSk7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc18xO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc09ic2VydmFibGVWYWx1ZShzb3VyY2UpKVxuICAgICAgICAgICAgcmV0dXJuIHRvSlMoc291cmNlLmdldCgpLCBkZXRlY3RDeWNsZXMsIF9fYWxyZWFkeVNlZW4pO1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2Zvcm1lcih0cmFuc2Zvcm1lciwgb25DbGVhbnVwKSB7XG4gICAgaW52YXJpYW50KHR5cGVvZiB0cmFuc2Zvcm1lciA9PT0gXCJmdW5jdGlvblwiICYmIHRyYW5zZm9ybWVyLmxlbmd0aCA8IDIsIFwiY3JlYXRlVHJhbnNmb3JtZXIgZXhwZWN0cyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBvbmUgYXJndW1lbnRcIik7XG4gICAgLy8gTWVtb2l6ZXM6IG9iamVjdCBpZCAtPiByZWFjdGl2ZSB2aWV3IHRoYXQgYXBwbGllcyB0cmFuc2Zvcm1lciB0byB0aGUgb2JqZWN0XG4gICAgdmFyIG9iamVjdENhY2hlID0ge307XG4gICAgLy8gSWYgdGhlIHJlc2V0SWQgY2hhbmdlcywgd2Ugd2lsbCBjbGVhciB0aGUgb2JqZWN0IGNhY2hlLCBzZWUgIzE2M1xuICAgIC8vIFRoaXMgY29uc3RydWN0aW9uIGlzIHVzZWQgdG8gYXZvaWQgbGVha2luZyByZWZzIHRvIHRoZSBvYmplY3RDYWNoZSBkaXJlY3RseVxuICAgIHZhciByZXNldElkID0gZ2xvYmFsU3RhdGUucmVzZXRJZDtcbiAgICAvLyBMb2NhbCB0cmFuc2Zvcm1lciBjbGFzcyBzcGVjaWZpY2FsbHkgZm9yIHRoaXMgdHJhbnNmb3JtZXJcbiAgICB2YXIgVHJhbnNmb3JtZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoVHJhbnNmb3JtZXIsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFRyYW5zZm9ybWVyKHNvdXJjZUlkZW50aWZpZXIsIHNvdXJjZU9iamVjdCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJhbnNmb3JtZXIoc291cmNlT2JqZWN0KTsgfSwgdW5kZWZpbmVkLCBjb21wYXJlci5kZWZhdWx0LCBcIlRyYW5zZm9ybWVyLVwiICsgdHJhbnNmb3JtZXIubmFtZSArIFwiLVwiICsgc291cmNlSWRlbnRpZmllciwgdW5kZWZpbmVkKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuc291cmNlSWRlbnRpZmllciA9IHNvdXJjZUlkZW50aWZpZXI7XG4gICAgICAgICAgICBfdGhpcy5zb3VyY2VPYmplY3QgPSBzb3VyY2VPYmplY3Q7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgVHJhbnNmb3JtZXIucHJvdG90eXBlLm9uQmVjb21lVW5vYnNlcnZlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsYXN0VmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5vbkJlY29tZVVub2JzZXJ2ZWQuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGRlbGV0ZSBvYmplY3RDYWNoZVt0aGlzLnNvdXJjZUlkZW50aWZpZXJdO1xuICAgICAgICAgICAgaWYgKG9uQ2xlYW51cClcbiAgICAgICAgICAgICAgICBvbkNsZWFudXAobGFzdFZhbHVlLCB0aGlzLnNvdXJjZU9iamVjdCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBUcmFuc2Zvcm1lcjtcbiAgICB9KENvbXB1dGVkVmFsdWUpKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICBpZiAocmVzZXRJZCAhPT0gZ2xvYmFsU3RhdGUucmVzZXRJZCkge1xuICAgICAgICAgICAgb2JqZWN0Q2FjaGUgPSB7fTtcbiAgICAgICAgICAgIHJlc2V0SWQgPSBnbG9iYWxTdGF0ZS5yZXNldElkO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpZGVudGlmaWVyID0gZ2V0TWVtb2l6YXRpb25JZChvYmplY3QpO1xuICAgICAgICB2YXIgcmVhY3RpdmVUcmFuc2Zvcm1lciA9IG9iamVjdENhY2hlW2lkZW50aWZpZXJdO1xuICAgICAgICBpZiAocmVhY3RpdmVUcmFuc2Zvcm1lcilcbiAgICAgICAgICAgIHJldHVybiByZWFjdGl2ZVRyYW5zZm9ybWVyLmdldCgpO1xuICAgICAgICAvLyBOb3QgaW4gY2FjaGU7IGNyZWF0ZSBhIHJlYWN0aXZlIHZpZXdcbiAgICAgICAgcmVhY3RpdmVUcmFuc2Zvcm1lciA9IG9iamVjdENhY2hlW2lkZW50aWZpZXJdID0gbmV3IFRyYW5zZm9ybWVyKGlkZW50aWZpZXIsIG9iamVjdCk7XG4gICAgICAgIHJldHVybiByZWFjdGl2ZVRyYW5zZm9ybWVyLmdldCgpO1xuICAgIH07XG59XG5mdW5jdGlvbiBnZXRNZW1vaXphdGlvbklkKG9iamVjdCkge1xuICAgIGlmICh0eXBlb2Ygb2JqZWN0ID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBvYmplY3QgPT09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqZWN0ICE9PSBcIm9iamVjdFwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbbW9ieF0gdHJhbnNmb3JtIGV4cGVjdGVkIHNvbWUga2luZCBvZiBvYmplY3Qgb3IgcHJpbWl0aXZlIHZhbHVlLCBnb3Q6IFwiICsgb2JqZWN0KTtcbiAgICB2YXIgdGlkID0gb2JqZWN0LiR0cmFuc2Zvcm1JZDtcbiAgICBpZiAodGlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGlkID0gZ2V0TmV4dElkKCk7XG4gICAgICAgIGFkZEhpZGRlblByb3Aob2JqZWN0LCBcIiR0cmFuc2Zvcm1JZFwiLCB0aWQpO1xuICAgIH1cbiAgICByZXR1cm4gdGlkO1xufVxuXG5mdW5jdGlvbiBpbnRlcmNlcHRSZWFkcyh0aGluZywgcHJvcE9ySGFuZGxlciwgaGFuZGxlcikge1xuICAgIHZhciB0YXJnZXQ7XG4gICAgaWYgKGlzT2JzZXJ2YWJsZU1hcCh0aGluZykgfHwgaXNPYnNlcnZhYmxlQXJyYXkodGhpbmcpIHx8IGlzT2JzZXJ2YWJsZVZhbHVlKHRoaW5nKSkge1xuICAgICAgICB0YXJnZXQgPSBnZXRBZG1pbmlzdHJhdGlvbih0aGluZyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdCh0aGluZykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wT3JIYW5kbGVyICE9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoXCJJbnRlcmNlcHRSZWFkcyBjYW4gb25seSBiZSB1c2VkIHdpdGggYSBzcGVjaWZpYyBwcm9wZXJ0eSwgbm90IHdpdGggYW4gb2JqZWN0IGluIGdlbmVyYWxcIik7XG4gICAgICAgIHRhcmdldCA9IGdldEFkbWluaXN0cmF0aW9uKHRoaW5nLCBwcm9wT3JIYW5kbGVyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWlsKFwiRXhwZWN0ZWQgb2JzZXJ2YWJsZSBtYXAsIG9iamVjdCBvciBhcnJheSBhcyBmaXJzdCBhcnJheVwiKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldC5kZWhhbmNlciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gZmFpbChcIkFuIGludGVyY2VwdCByZWFkZXIgd2FzIGFscmVhZHkgZXN0YWJsaXNoZWRcIik7XG4gICAgdGFyZ2V0LmRlaGFuY2VyID0gdHlwZW9mIHByb3BPckhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIiA/IHByb3BPckhhbmRsZXIgOiBoYW5kbGVyO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRhcmdldC5kZWhhbmNlciA9IHVuZGVmaW5lZDtcbiAgICB9O1xufVxuXG4vKipcbiAqIChjKSBNaWNoZWwgV2VzdHN0cmF0ZSAyMDE1IC0gMjAxNlxuICogTUlUIExpY2Vuc2VkXG4gKlxuICogV2VsY29tZSB0byB0aGUgbW9ieCBzb3VyY2VzISBUbyBnZXQgYW4gZ2xvYmFsIG92ZXJ2aWV3IG9mIGhvdyBNb2JYIGludGVybmFsbHkgd29ya3MsXG4gKiB0aGlzIGlzIGEgZ29vZCBwbGFjZSB0byBzdGFydDpcbiAqIGh0dHBzOi8vbWVkaXVtLmNvbS9AbXdlc3RzdHJhdGUvYmVjb21pbmctZnVsbHktcmVhY3RpdmUtYW4taW4tZGVwdGgtZXhwbGFuYXRpb24tb2YtbW9ic2VydmFibGUtNTU5OTUyNjJhMjU0Iy54dmJoNnFkNzRcbiAqXG4gKiBTb3VyY2UgZm9sZGVyczpcbiAqID09PT09PT09PT09PT09PVxuICpcbiAqIC0gYXBpLyAgICAgTW9zdCBvZiB0aGUgcHVibGljIHN0YXRpYyBtZXRob2RzIGV4cG9zZWQgYnkgdGhlIG1vZHVsZSBjYW4gYmUgZm91bmQgaGVyZS5cbiAqIC0gY29yZS8gICAgSW1wbGVtZW50YXRpb24gb2YgdGhlIE1vYlggYWxnb3JpdGhtOyBhdG9tcywgZGVyaXZhdGlvbnMsIHJlYWN0aW9ucywgZGVwZW5kZW5jeSB0cmVlcywgb3B0aW1pemF0aW9ucy4gQ29vbCBzdHVmZiBjYW4gYmUgZm91bmQgaGVyZS5cbiAqIC0gdHlwZXMvICAgQWxsIHRoZSBtYWdpYyB0aGF0IGlzIG5lZWQgdG8gaGF2ZSBvYnNlcnZhYmxlIG9iamVjdHMsIGFycmF5cyBhbmQgdmFsdWVzIGlzIGluIHRoaXMgZm9sZGVyLiBJbmNsdWRpbmcgdGhlIG1vZGlmaWVycyBsaWtlIGBhc0ZsYXRgLlxuICogLSB1dGlscy8gICBVdGlsaXR5IHN0dWZmLlxuICpcbiAqL1xudmFyIGV4dHJhcyA9IHtcbiAgICBhbGxvd1N0YXRlQ2hhbmdlczogYWxsb3dTdGF0ZUNoYW5nZXMsXG4gICAgZGVlcEVxdWFsOiBkZWVwRXF1YWwsXG4gICAgZ2V0QXRvbTogZ2V0QXRvbSxcbiAgICBnZXREZWJ1Z05hbWU6IGdldERlYnVnTmFtZSxcbiAgICBnZXREZXBlbmRlbmN5VHJlZTogZ2V0RGVwZW5kZW5jeVRyZWUsXG4gICAgZ2V0QWRtaW5pc3RyYXRpb246IGdldEFkbWluaXN0cmF0aW9uLFxuICAgIGdldEdsb2JhbFN0YXRlOiBnZXRHbG9iYWxTdGF0ZSxcbiAgICBnZXRPYnNlcnZlclRyZWU6IGdldE9ic2VydmVyVHJlZSxcbiAgICBpbnRlcmNlcHRSZWFkczogaW50ZXJjZXB0UmVhZHMsXG4gICAgaXNDb21wdXRpbmdEZXJpdmF0aW9uOiBpc0NvbXB1dGluZ0Rlcml2YXRpb24sXG4gICAgaXNTcHlFbmFibGVkOiBpc1NweUVuYWJsZWQsXG4gICAgb25SZWFjdGlvbkVycm9yOiBvblJlYWN0aW9uRXJyb3IsXG4gICAgcmVzZXJ2ZUFycmF5QnVmZmVyOiByZXNlcnZlQXJyYXlCdWZmZXIsXG4gICAgcmVzZXRHbG9iYWxTdGF0ZTogcmVzZXRHbG9iYWxTdGF0ZSxcbiAgICBpc29sYXRlR2xvYmFsU3RhdGU6IGlzb2xhdGVHbG9iYWxTdGF0ZSxcbiAgICBzaGFyZUdsb2JhbFN0YXRlOiBzaGFyZUdsb2JhbFN0YXRlLFxuICAgIHNweVJlcG9ydDogc3B5UmVwb3J0LFxuICAgIHNweVJlcG9ydEVuZDogc3B5UmVwb3J0RW5kLFxuICAgIHNweVJlcG9ydFN0YXJ0OiBzcHlSZXBvcnRTdGFydCxcbiAgICBzZXRSZWFjdGlvblNjaGVkdWxlcjogc2V0UmVhY3Rpb25TY2hlZHVsZXJcbn07XG52YXIgZXZlcnl0aGluZyA9IHtcbiAgICBSZWFjdGlvbjogUmVhY3Rpb24sXG4gICAgdW50cmFja2VkOiB1bnRyYWNrZWQsXG4gICAgQXRvbTogQXRvbSxcbiAgICBCYXNlQXRvbTogQmFzZUF0b20sXG4gICAgdXNlU3RyaWN0OiB1c2VTdHJpY3QsXG4gICAgaXNTdHJpY3RNb2RlRW5hYmxlZDogaXNTdHJpY3RNb2RlRW5hYmxlZCxcbiAgICBzcHk6IHNweSxcbiAgICBjb21wYXJlcjogY29tcGFyZXIsXG4gICAgYXNSZWZlcmVuY2U6IGFzUmVmZXJlbmNlLFxuICAgIGFzRmxhdDogYXNGbGF0LFxuICAgIGFzU3RydWN0dXJlOiBhc1N0cnVjdHVyZSxcbiAgICBhc01hcDogYXNNYXAsXG4gICAgaXNNb2RpZmllckRlc2NyaXB0b3I6IGlzTW9kaWZpZXJEZXNjcmlwdG9yLFxuICAgIGlzT2JzZXJ2YWJsZU9iamVjdDogaXNPYnNlcnZhYmxlT2JqZWN0LFxuICAgIGlzQm94ZWRPYnNlcnZhYmxlOiBpc09ic2VydmFibGVWYWx1ZSxcbiAgICBpc09ic2VydmFibGVBcnJheTogaXNPYnNlcnZhYmxlQXJyYXksXG4gICAgT2JzZXJ2YWJsZU1hcDogT2JzZXJ2YWJsZU1hcCxcbiAgICBpc09ic2VydmFibGVNYXA6IGlzT2JzZXJ2YWJsZU1hcCxcbiAgICBtYXA6IG1hcCxcbiAgICB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb24sXG4gICAgb2JzZXJ2YWJsZTogb2JzZXJ2YWJsZSxcbiAgICBjb21wdXRlZDogY29tcHV0ZWQsXG4gICAgaXNPYnNlcnZhYmxlOiBpc09ic2VydmFibGUsXG4gICAgaXNDb21wdXRlZDogaXNDb21wdXRlZCxcbiAgICBleHRlbmRPYnNlcnZhYmxlOiBleHRlbmRPYnNlcnZhYmxlLFxuICAgIGV4dGVuZFNoYWxsb3dPYnNlcnZhYmxlOiBleHRlbmRTaGFsbG93T2JzZXJ2YWJsZSxcbiAgICBvYnNlcnZlOiBvYnNlcnZlLFxuICAgIGludGVyY2VwdDogaW50ZXJjZXB0LFxuICAgIGF1dG9ydW46IGF1dG9ydW4sXG4gICAgYXV0b3J1bkFzeW5jOiBhdXRvcnVuQXN5bmMsXG4gICAgd2hlbjogd2hlbixcbiAgICByZWFjdGlvbjogcmVhY3Rpb24sXG4gICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgaXNBY3Rpb246IGlzQWN0aW9uLFxuICAgIHJ1bkluQWN0aW9uOiBydW5JbkFjdGlvbixcbiAgICBleHByOiBleHByLFxuICAgIHRvSlM6IHRvSlMsXG4gICAgY3JlYXRlVHJhbnNmb3JtZXI6IGNyZWF0ZVRyYW5zZm9ybWVyLFxuICAgIHdoeVJ1bjogd2h5UnVuLFxuICAgIGlzQXJyYXlMaWtlOiBpc0FycmF5TGlrZSxcbiAgICBleHRyYXM6IGV4dHJhc1xufTtcbnZhciB3YXJuZWRBYm91dERlZmF1bHRFeHBvcnQgPSBmYWxzZTtcbnZhciBfbG9vcF8xID0gZnVuY3Rpb24gKHApIHtcbiAgICB2YXIgdmFsID0gZXZlcnl0aGluZ1twXTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXZlcnl0aGluZywgcCwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghd2FybmVkQWJvdXREZWZhdWx0RXhwb3J0KSB7XG4gICAgICAgICAgICAgICAgd2FybmVkQWJvdXREZWZhdWx0RXhwb3J0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVc2luZyBkZWZhdWx0IGV4cG9ydCAoYGltcG9ydCBtb2J4IGZyb20gJ21vYngnYCkgaXMgZGVwcmVjYXRlZCBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiYW5kIHdvbuKAmXQgd29yayBpbiBtb2J4QDQuMC4wXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIlVzZSBgaW1wb3J0ICogYXMgbW9ieCBmcm9tICdtb2J4J2AgaW5zdGVhZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5mb3IgKHZhciBwIGluIGV2ZXJ5dGhpbmcpIHtcbiAgICBfbG9vcF8xKHApO1xufVxuaWYgKHR5cGVvZiBfX01PQlhfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gXCJvYmplY3RcIikge1xuICAgIF9fTU9CWF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmluamVjdE1vYngoeyBzcHk6IHNweSwgZXh0cmFzOiBleHRyYXMgfSk7XG59XG5cbmV4cG9ydCB7IGV4dHJhcywgUmVhY3Rpb24sIHVudHJhY2tlZCwgSURlcml2YXRpb25TdGF0ZSwgQXRvbSwgQmFzZUF0b20sIHVzZVN0cmljdCwgaXNTdHJpY3RNb2RlRW5hYmxlZCwgc3B5LCBjb21wYXJlciwgYXNSZWZlcmVuY2UsIGFzRmxhdCwgYXNTdHJ1Y3R1cmUsIGFzTWFwLCBpc01vZGlmaWVyRGVzY3JpcHRvciwgaXNPYnNlcnZhYmxlT2JqZWN0LCBpc09ic2VydmFibGVWYWx1ZSBhcyBpc0JveGVkT2JzZXJ2YWJsZSwgaXNPYnNlcnZhYmxlQXJyYXksIE9ic2VydmFibGVNYXAsIGlzT2JzZXJ2YWJsZU1hcCwgbWFwLCB0cmFuc2FjdGlvbiwgb2JzZXJ2YWJsZSwgY29tcHV0ZWQsIGlzT2JzZXJ2YWJsZSwgaXNDb21wdXRlZCwgZXh0ZW5kT2JzZXJ2YWJsZSwgZXh0ZW5kU2hhbGxvd09ic2VydmFibGUsIG9ic2VydmUsIGludGVyY2VwdCwgYXV0b3J1biwgYXV0b3J1bkFzeW5jLCB3aGVuLCByZWFjdGlvbiwgYWN0aW9uLCBpc0FjdGlvbiwgcnVuSW5BY3Rpb24sIGV4cHIsIHRvSlMsIGNyZWF0ZVRyYW5zZm9ybWVyLCB3aHlSdW4sIHRyYWNlLCBpc0FycmF5TGlrZSB9O2V4cG9ydCBkZWZhdWx0IGV2ZXJ5dGhpbmc7XG4iLCIvKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG4gIHZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuICB2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuICB2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBnZXRTdGFjayBSZXR1cm5zIHRoZSBjb21wb25lbnQgc3RhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGdldFN0YWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKHR5cGVTcGVjcy5oYXNPd25Qcm9wZXJ0eSh0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGludmFyaWFudCh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gPT09ICdmdW5jdGlvbicsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tICcgKyAndGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCVzYC4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSk7XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmcoIWVycm9yIHx8IGVycm9yIGluc3RhbmNlb2YgRXJyb3IsICclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvcik7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIHN0YWNrID0gZ2V0U3RhY2sgPyBnZXRTdGFjaygpIDogJyc7XG5cbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkICVzIHR5cGU6ICVzJXMnLCBsb2NhdGlvbiwgZXJyb3IubWVzc2FnZSwgc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tQcm9wVHlwZXM7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcbiIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMi4wXG4gKiByZWFjdC1kb20uZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgRXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJ2ZianMvbGliL0V2ZW50TGlzdGVuZXInKTtcbnZhciBnZXRBY3RpdmVFbGVtZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudCcpO1xudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2ZianMvbGliL3NoYWxsb3dFcXVhbCcpO1xudmFyIGNvbnRhaW5zTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2NvbnRhaW5zTm9kZScpO1xudmFyIGZvY3VzTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2ZvY3VzTm9kZScpO1xudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMnKTtcbnZhciBoeXBoZW5hdGVTdHlsZU5hbWUgPSByZXF1aXJlKCdmYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUnKTtcbnZhciBjYW1lbGl6ZVN0eWxlTmFtZSA9IHJlcXVpcmUoJ2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lJyk7XG5cbi8qKlxuICogV0FSTklORzogRE8gTk9UIG1hbnVhbGx5IHJlcXVpcmUgdGhpcyBtb2R1bGUuXG4gKiBUaGlzIGlzIGEgcmVwbGFjZW1lbnQgZm9yIGBpbnZhcmlhbnQoLi4uKWAgdXNlZCBieSB0aGUgZXJyb3IgY29kZSBzeXN0ZW1cbiAqIGFuZCB3aWxsIF9vbmx5XyBiZSByZXF1aXJlZCBieSB0aGUgY29ycmVzcG9uZGluZyBiYWJlbCBwYXNzLlxuICogSXQgYWx3YXlzIHRocm93cy5cbiAqL1xuXG4hUmVhY3QgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTSB3YXMgbG9hZGVkIGJlZm9yZSBSZWFjdC4gTWFrZSBzdXJlIHlvdSBsb2FkIHRoZSBSZWFjdCBwYWNrYWdlIGJlZm9yZSBsb2FkaW5nIFJlYWN0RE9NLicpIDogdm9pZCAwO1xuXG4vLyBUaGVzZSBhdHRyaWJ1dGVzIHNob3VsZCBiZSBhbGwgbG93ZXJjYXNlIHRvIGFsbG93IGZvclxuLy8gY2FzZSBpbnNlbnNpdGl2ZSBjaGVja3NcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAgY2hpbGRyZW46IHRydWUsXG4gIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB0cnVlLFxuICBkZWZhdWx0VmFsdWU6IHRydWUsXG4gIGRlZmF1bHRDaGVja2VkOiB0cnVlLFxuICBpbm5lckhUTUw6IHRydWUsXG4gIHN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZzogdHJ1ZSxcbiAgc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nOiB0cnVlLFxuICBzdHlsZTogdHJ1ZVxufTtcblxuZnVuY3Rpb24gY2hlY2tNYXNrKHZhbHVlLCBiaXRtYXNrKSB7XG4gIHJldHVybiAodmFsdWUgJiBiaXRtYXNrKSA9PT0gYml0bWFzaztcbn1cblxudmFyIERPTVByb3BlcnR5SW5qZWN0aW9uID0ge1xuICAvKipcbiAgICogTWFwcGluZyBmcm9tIG5vcm1hbGl6ZWQsIGNhbWVsY2FzZWQgcHJvcGVydHkgbmFtZXMgdG8gYSBjb25maWd1cmF0aW9uIHRoYXRcbiAgICogc3BlY2lmaWVzIGhvdyB0aGUgYXNzb2NpYXRlZCBET00gcHJvcGVydHkgc2hvdWxkIGJlIGFjY2Vzc2VkIG9yIHJlbmRlcmVkLlxuICAgKi9cbiAgTVVTVF9VU0VfUFJPUEVSVFk6IDB4MSxcbiAgSEFTX0JPT0xFQU5fVkFMVUU6IDB4NCxcbiAgSEFTX05VTUVSSUNfVkFMVUU6IDB4OCxcbiAgSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUU6IDB4MTAgfCAweDgsXG4gIEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUU6IDB4MjAsXG4gIEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRTogMHg0MCxcblxuICAvKipcbiAgICogSW5qZWN0IHNvbWUgc3BlY2lhbGl6ZWQga25vd2xlZGdlIGFib3V0IHRoZSBET00uIFRoaXMgdGFrZXMgYSBjb25maWcgb2JqZWN0XG4gICAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiBQcm9wZXJ0aWVzOiBvYmplY3QgbWFwcGluZyBET00gcHJvcGVydHkgbmFtZSB0byBvbmUgb2YgdGhlXG4gICAqIERPTVByb3BlcnR5SW5qZWN0aW9uIGNvbnN0YW50cyBvciBudWxsLiBJZiB5b3VyIGF0dHJpYnV0ZSBpc24ndCBpbiBoZXJlLFxuICAgKiBpdCB3b24ndCBnZXQgd3JpdHRlbiB0byB0aGUgRE9NLlxuICAgKlxuICAgKiBET01BdHRyaWJ1dGVOYW1lczogb2JqZWN0IG1hcHBpbmcgUmVhY3QgYXR0cmlidXRlIG5hbWUgdG8gdGhlIERPTVxuICAgKiBhdHRyaWJ1dGUgbmFtZS4gQXR0cmlidXRlIG5hbWVzIG5vdCBzcGVjaWZpZWQgdXNlIHRoZSAqKmxvd2VyY2FzZSoqXG4gICAqIG5vcm1hbGl6ZWQgbmFtZS5cbiAgICpcbiAgICogRE9NQXR0cmlidXRlTmFtZXNwYWNlczogb2JqZWN0IG1hcHBpbmcgUmVhY3QgYXR0cmlidXRlIG5hbWUgdG8gdGhlIERPTVxuICAgKiBhdHRyaWJ1dGUgbmFtZXNwYWNlIFVSTC4gKEF0dHJpYnV0ZSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSBubyBuYW1lc3BhY2UuKVxuICAgKlxuICAgKiBET01Qcm9wZXJ0eU5hbWVzOiBzaW1pbGFyIHRvIERPTUF0dHJpYnV0ZU5hbWVzIGJ1dCBmb3IgRE9NIHByb3BlcnRpZXMuXG4gICAqIFByb3BlcnR5IG5hbWVzIG5vdCBzcGVjaWZpZWQgdXNlIHRoZSBub3JtYWxpemVkIG5hbWUuXG4gICAqXG4gICAqIERPTU11dGF0aW9uTWV0aG9kczogUHJvcGVydGllcyB0aGF0IHJlcXVpcmUgc3BlY2lhbCBtdXRhdGlvbiBtZXRob2RzLiBJZlxuICAgKiBgdmFsdWVgIGlzIHVuZGVmaW5lZCwgdGhlIG11dGF0aW9uIG1ldGhvZCBzaG91bGQgdW5zZXQgdGhlIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZG9tUHJvcGVydHlDb25maWcgdGhlIGNvbmZpZyBhcyBkZXNjcmliZWQgYWJvdmUuXG4gICAqL1xuICBpbmplY3RET01Qcm9wZXJ0eUNvbmZpZzogZnVuY3Rpb24gKGRvbVByb3BlcnR5Q29uZmlnKSB7XG4gICAgdmFyIEluamVjdGlvbiA9IERPTVByb3BlcnR5SW5qZWN0aW9uO1xuICAgIHZhciBQcm9wZXJ0aWVzID0gZG9tUHJvcGVydHlDb25maWcuUHJvcGVydGllcyB8fCB7fTtcbiAgICB2YXIgRE9NQXR0cmlidXRlTmFtZXNwYWNlcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzcGFjZXMgfHwge307XG4gICAgdmFyIERPTUF0dHJpYnV0ZU5hbWVzID0gZG9tUHJvcGVydHlDb25maWcuRE9NQXR0cmlidXRlTmFtZXMgfHwge307XG4gICAgdmFyIERPTU11dGF0aW9uTWV0aG9kcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTU11dGF0aW9uTWV0aG9kcyB8fCB7fTtcblxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIFByb3BlcnRpZXMpIHtcbiAgICAgICEhcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgPyBpbnZhcmlhbnQoZmFsc2UsIFwiaW5qZWN0RE9NUHJvcGVydHlDb25maWcoLi4uKTogWW91J3JlIHRyeWluZyB0byBpbmplY3QgRE9NIHByb3BlcnR5ICclcycgd2hpY2ggaGFzIGFscmVhZHkgYmVlbiBpbmplY3RlZC4gWW91IG1heSBiZSBhY2NpZGVudGFsbHkgaW5qZWN0aW5nIHRoZSBzYW1lIERPTSBwcm9wZXJ0eSBjb25maWcgdHdpY2UsIG9yIHlvdSBtYXkgYmUgaW5qZWN0aW5nIHR3byBjb25maWdzIHRoYXQgaGF2ZSBjb25mbGljdGluZyBwcm9wZXJ0eSBuYW1lcy5cIiwgcHJvcE5hbWUpIDogdm9pZCAwO1xuXG4gICAgICB2YXIgbG93ZXJDYXNlZCA9IHByb3BOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgcHJvcENvbmZpZyA9IFByb3BlcnRpZXNbcHJvcE5hbWVdO1xuXG4gICAgICB2YXIgcHJvcGVydHlJbmZvID0ge1xuICAgICAgICBhdHRyaWJ1dGVOYW1lOiBsb3dlckNhc2VkLFxuICAgICAgICBhdHRyaWJ1dGVOYW1lc3BhY2U6IG51bGwsXG4gICAgICAgIHByb3BlcnR5TmFtZTogcHJvcE5hbWUsXG4gICAgICAgIG11dGF0aW9uTWV0aG9kOiBudWxsLFxuXG4gICAgICAgIG11c3RVc2VQcm9wZXJ0eTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5NVVNUX1VTRV9QUk9QRVJUWSksXG4gICAgICAgIGhhc0Jvb2xlYW5WYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfQk9PTEVBTl9WQUxVRSksXG4gICAgICAgIGhhc051bWVyaWNWYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfTlVNRVJJQ19WQUxVRSksXG4gICAgICAgIGhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFKSxcbiAgICAgICAgaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFKSxcbiAgICAgICAgaGFzU3RyaW5nQm9vbGVhblZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSlcbiAgICAgIH07XG4gICAgICAhKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgKyBwcm9wZXJ0eUluZm8uaGFzTnVtZXJpY1ZhbHVlICsgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgPD0gMSkgPyBpbnZhcmlhbnQoZmFsc2UsIFwiRE9NUHJvcGVydHk6IFZhbHVlIGNhbiBiZSBvbmUgb2YgYm9vbGVhbiwgb3ZlcmxvYWRlZCBib29sZWFuLCBvciBudW1lcmljIHZhbHVlLCBidXQgbm90IGEgY29tYmluYXRpb246ICVzXCIsIHByb3BOYW1lKSA6IHZvaWQgMDtcblxuICAgICAgaWYgKERPTUF0dHJpYnV0ZU5hbWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IERPTUF0dHJpYnV0ZU5hbWVzW3Byb3BOYW1lXTtcblxuICAgICAgICBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChET01BdHRyaWJ1dGVOYW1lc3BhY2VzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZXNwYWNlID0gRE9NQXR0cmlidXRlTmFtZXNwYWNlc1twcm9wTmFtZV07XG4gICAgICB9XG5cbiAgICAgIGlmIChET01NdXRhdGlvbk1ldGhvZHMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZCA9IERPTU11dGF0aW9uTWV0aG9kc1twcm9wTmFtZV07XG4gICAgICB9XG5cbiAgICAgIC8vIERvd25jYXNlIHJlZmVyZW5jZXMgdG8gd2hpdGVsaXN0IHByb3BlcnRpZXMgdG8gY2hlY2sgZm9yIG1lbWJlcnNoaXBcbiAgICAgIC8vIHdpdGhvdXQgY2FzZS1zZW5zaXRpdml0eS4gVGhpcyBhbGxvd3MgdGhlIHdoaXRlbGlzdCB0byBwaWNrIHVwXG4gICAgICAvLyBgYWxsb3dmdWxsc2NyZWVuYCwgd2hpY2ggc2hvdWxkIGJlIHdyaXR0ZW4gdXNpbmcgdGhlIHByb3BlcnR5IGNvbmZpZ3VyYXRpb25cbiAgICAgIC8vIGZvciBgYWxsb3dGdWxsc2NyZWVuYFxuICAgICAgcHJvcGVydGllc1twcm9wTmFtZV0gPSBwcm9wZXJ0eUluZm87XG4gICAgfVxuICB9XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG52YXIgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiA9IFwiOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRFwiO1xuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG52YXIgQVRUUklCVVRFX05BTUVfQ0hBUiA9IEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgKyBcIlxcXFwtLjAtOVxcXFx1MDBCN1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTIwM0YtXFxcXHUyMDQwXCI7XG5cblxudmFyIFJPT1RfQVRUUklCVVRFX05BTUUgPSAnZGF0YS1yZWFjdHJvb3QnO1xuXG4vKipcbiAqIE1hcCBmcm9tIHByb3BlcnR5IFwic3RhbmRhcmQgbmFtZVwiIHRvIGFuIG9iamVjdCB3aXRoIGluZm8gYWJvdXQgaG93IHRvIHNldFxuICogdGhlIHByb3BlcnR5IGluIHRoZSBET00uIEVhY2ggb2JqZWN0IGNvbnRhaW5zOlxuICpcbiAqIGF0dHJpYnV0ZU5hbWU6XG4gKiAgIFVzZWQgd2hlbiByZW5kZXJpbmcgbWFya3VwIG9yIHdpdGggYCpBdHRyaWJ1dGUoKWAuXG4gKiBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAqIHByb3BlcnR5TmFtZTpcbiAqICAgVXNlZCBvbiBET00gbm9kZSBpbnN0YW5jZXMuIChUaGlzIGluY2x1ZGVzIHByb3BlcnRpZXMgdGhhdCBtdXRhdGUgZHVlIHRvXG4gKiAgIGV4dGVybmFsIGZhY3RvcnMuKVxuICogbXV0YXRpb25NZXRob2Q6XG4gKiAgIElmIG5vbi1udWxsLCB1c2VkIGluc3RlYWQgb2YgdGhlIHByb3BlcnR5IG9yIGBzZXRBdHRyaWJ1dGUoKWAgYWZ0ZXJcbiAqICAgaW5pdGlhbCByZW5kZXIuXG4gKiBtdXN0VXNlUHJvcGVydHk6XG4gKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgYWNjZXNzZWQgYW5kIG11dGF0ZWQgYXMgYW4gb2JqZWN0IHByb3BlcnR5LlxuICogaGFzQm9vbGVhblZhbHVlOlxuICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgcmVtb3ZlZCB3aGVuIHNldCB0byBhIGZhbHNleSB2YWx1ZS5cbiAqIGhhc051bWVyaWNWYWx1ZTpcbiAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgbXVzdCBiZSBudW1lcmljIG9yIHBhcnNlIGFzIGEgbnVtZXJpYyBhbmQgc2hvdWxkIGJlXG4gKiAgIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gKiBoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZTpcbiAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgbXVzdCBiZSBwb3NpdGl2ZSBudW1lcmljIG9yIHBhcnNlIGFzIGEgcG9zaXRpdmVcbiAqICAgbnVtZXJpYyBhbmQgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gKiBoYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOlxuICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBjYW4gYmUgdXNlZCBhcyBhIGZsYWcgYXMgd2VsbCBhcyB3aXRoIGEgdmFsdWUuXG4gKiAgIFJlbW92ZWQgd2hlbiBzdHJpY3RseSBlcXVhbCB0byBmYWxzZTsgcHJlc2VudCB3aXRob3V0IGEgdmFsdWUgd2hlblxuICogICBzdHJpY3RseSBlcXVhbCB0byB0cnVlOyBwcmVzZW50IHdpdGggYSB2YWx1ZSBvdGhlcndpc2UuXG4gKi9cbnZhciBwcm9wZXJ0aWVzID0ge307XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBwcm9wZXJ0eSBuYW1lIGlzIGEgd3JpdGVhYmxlIGF0dHJpYnV0ZS5cbiAqIEBtZXRob2RcbiAqL1xuZnVuY3Rpb24gc2hvdWxkU2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSB7XG4gIGlmIChpc1Jlc2VydmVkUHJvcChuYW1lKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobmFtZS5sZW5ndGggPiAyICYmIChuYW1lWzBdID09PSAnbycgfHwgbmFtZVswXSA9PT0gJ08nKSAmJiAobmFtZVsxXSA9PT0gJ24nIHx8IG5hbWVbMV0gPT09ICdOJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiBzaG91bGRBdHRyaWJ1dGVBY2NlcHRCb29sZWFuVmFsdWUobmFtZSk7XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICBjYXNlICdudW1iZXInOlxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBmdW5jdGlvbiwgc3ltYm9sXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UHJvcGVydHlJbmZvKG5hbWUpIHtcbiAgcmV0dXJuIHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBwcm9wZXJ0aWVzW25hbWVdIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gc2hvdWxkQXR0cmlidXRlQWNjZXB0Qm9vbGVhblZhbHVlKG5hbWUpIHtcbiAgaWYgKGlzUmVzZXJ2ZWRQcm9wKG5hbWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhuYW1lKTtcbiAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgIHJldHVybiBwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNTdHJpbmdCb29sZWFuVmFsdWUgfHwgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU7XG4gIH1cbiAgdmFyIHByZWZpeCA9IG5hbWUudG9Mb3dlckNhc2UoKS5zbGljZSgwLCA1KTtcbiAgcmV0dXJuIHByZWZpeCA9PT0gJ2RhdGEtJyB8fCBwcmVmaXggPT09ICdhcmlhLSc7XG59XG5cbi8qKlxuICogQ2hlY2tzIHRvIHNlZSBpZiBhIHByb3BlcnR5IG5hbWUgaXMgd2l0aGluIHRoZSBsaXN0IG9mIHByb3BlcnRpZXNcbiAqIHJlc2VydmVkIGZvciBpbnRlcm5hbCBSZWFjdCBvcGVyYXRpb25zLiBUaGVzZSBwcm9wZXJ0aWVzIHNob3VsZFxuICogbm90IGJlIHNldCBvbiBhbiBIVE1MIGVsZW1lbnQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtib29sZWFufSBJZiB0aGUgbmFtZSBpcyB3aXRoaW4gcmVzZXJ2ZWQgcHJvcHNcbiAqL1xuZnVuY3Rpb24gaXNSZXNlcnZlZFByb3AobmFtZSkge1xuICByZXR1cm4gUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkobmFtZSk7XG59XG5cbnZhciBpbmplY3Rpb24gPSBET01Qcm9wZXJ0eUluamVjdGlvbjtcblxudmFyIE1VU1RfVVNFX1BST1BFUlRZID0gaW5qZWN0aW9uLk1VU1RfVVNFX1BST1BFUlRZO1xudmFyIEhBU19CT09MRUFOX1ZBTFVFID0gaW5qZWN0aW9uLkhBU19CT09MRUFOX1ZBTFVFO1xudmFyIEhBU19OVU1FUklDX1ZBTFVFID0gaW5qZWN0aW9uLkhBU19OVU1FUklDX1ZBTFVFO1xudmFyIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFID0gaW5qZWN0aW9uLkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFO1xudmFyIEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUgPSBpbmplY3Rpb24uSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRTtcbnZhciBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUgPSBpbmplY3Rpb24uSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFO1xuXG52YXIgSFRNTERPTVByb3BlcnR5Q29uZmlnID0ge1xuICAvLyBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoaXMgbGlzdCwgYmUgc3VyZSB0byBhbHNvIGFkZCB0aGVtIHRvXG4gIC8vIHRoZSBgcG9zc2libGVTdGFuZGFyZE5hbWVzYCBtb2R1bGUgdG8gZW5zdXJlIGNhc2luZyBhbmQgaW5jb3JyZWN0XG4gIC8vIG5hbWUgd2FybmluZ3MuXG4gIFByb3BlcnRpZXM6IHtcbiAgICBhbGxvd0Z1bGxTY3JlZW46IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIC8vIHNwZWNpZmllcyB0YXJnZXQgY29udGV4dCBmb3IgbGlua3Mgd2l0aCBgcHJlbG9hZGAgdHlwZVxuICAgIGFzeW5jOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICAvLyBOb3RlOiB0aGVyZSBpcyBhIHNwZWNpYWwgY2FzZSB0aGF0IHByZXZlbnRzIGl0IGZyb20gYmVpbmcgd3JpdHRlbiB0byB0aGUgRE9NXG4gICAgLy8gb24gdGhlIGNsaWVudCBzaWRlIGJlY2F1c2UgdGhlIGJyb3dzZXJzIGFyZSBpbmNvbnNpc3RlbnQuIEluc3RlYWQgd2UgY2FsbCBmb2N1cygpLlxuICAgIGF1dG9Gb2N1czogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgYXV0b1BsYXk6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNhcHR1cmU6IEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUsXG4gICAgY2hlY2tlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjb2xzOiBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICBjb250ZW50RWRpdGFibGU6IEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSxcbiAgICBjb250cm9sczogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgJ2RlZmF1bHQnOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkZWZlcjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZGlzYWJsZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGRvd25sb2FkOiBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFLFxuICAgIGRyYWdnYWJsZTogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFLFxuICAgIGZvcm1Ob1ZhbGlkYXRlOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBoaWRkZW46IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGxvb3A6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIC8vIENhdXRpb247IGBvcHRpb24uc2VsZWN0ZWRgIGlzIG5vdCB1cGRhdGVkIGlmIGBzZWxlY3QubXVsdGlwbGVgIGlzXG4gICAgLy8gZGlzYWJsZWQgd2l0aCBgcmVtb3ZlQXR0cmlidXRlYC5cbiAgICBtdWx0aXBsZTogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBtdXRlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBub1ZhbGlkYXRlOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBvcGVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBwbGF5c0lubGluZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcmVhZE9ubHk6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJlcXVpcmVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByZXZlcnNlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcm93czogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgcm93U3BhbjogSEFTX05VTUVSSUNfVkFMVUUsXG4gICAgc2NvcGVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBzZWFtbGVzczogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2VsZWN0ZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2l6ZTogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgc3RhcnQ6IEhBU19OVU1FUklDX1ZBTFVFLFxuICAgIC8vIHN1cHBvcnQgZm9yIHByb2plY3RpbmcgcmVndWxhciBET00gRWxlbWVudHMgdmlhIFYxIG5hbWVkIHNsb3RzICggc2hhZG93IGRvbSApXG4gICAgc3BhbjogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgc3BlbGxDaGVjazogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFLFxuICAgIC8vIFN0eWxlIG11c3QgYmUgZXhwbGljaXRseSBzZXQgaW4gdGhlIGF0dHJpYnV0ZSBsaXN0LiBSZWFjdCBjb21wb25lbnRzXG4gICAgLy8gZXhwZWN0IGEgc3R5bGUgb2JqZWN0XG4gICAgc3R5bGU6IDAsXG4gICAgLy8gS2VlcCBpdCBpbiB0aGUgd2hpdGVsaXN0IGJlY2F1c2UgaXQgaXMgY2FzZS1zZW5zaXRpdmUgZm9yIFNWRy5cbiAgICB0YWJJbmRleDogMCxcbiAgICAvLyBpdGVtU2NvcGUgaXMgZm9yIGZvciBNaWNyb2RhdGEgc3VwcG9ydC5cbiAgICAvLyBTZWUgaHR0cDovL3NjaGVtYS5vcmcvZG9jcy9ncy5odG1sXG4gICAgaXRlbVNjb3BlOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICAvLyBUaGVzZSBhdHRyaWJ1dGVzIG11c3Qgc3RheSBpbiB0aGUgd2hpdGUtbGlzdCBiZWNhdXNlIHRoZXkgaGF2ZVxuICAgIC8vIGRpZmZlcmVudCBhdHRyaWJ1dGUgbmFtZXMgKHNlZSBET01BdHRyaWJ1dGVOYW1lcyBiZWxvdylcbiAgICBhY2NlcHRDaGFyc2V0OiAwLFxuICAgIGNsYXNzTmFtZTogMCxcbiAgICBodG1sRm9yOiAwLFxuICAgIGh0dHBFcXVpdjogMCxcbiAgICAvLyBBdHRyaWJ1dGVzIHdpdGggbXV0YXRpb24gbWV0aG9kcyBtdXN0IGJlIHNwZWNpZmllZCBpbiB0aGUgd2hpdGVsaXN0XG4gICAgLy8gU2V0IHRoZSBzdHJpbmcgYm9vbGVhbiBmbGFnIHRvIGFsbG93IHRoZSBiZWhhdmlvclxuICAgIHZhbHVlOiBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUVcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXM6IHtcbiAgICBhY2NlcHRDaGFyc2V0OiAnYWNjZXB0LWNoYXJzZXQnLFxuICAgIGNsYXNzTmFtZTogJ2NsYXNzJyxcbiAgICBodG1sRm9yOiAnZm9yJyxcbiAgICBodHRwRXF1aXY6ICdodHRwLWVxdWl2J1xuICB9LFxuICBET01NdXRhdGlvbk1ldGhvZHM6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG5vZGUsIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ3ZhbHVlJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIE51bWJlciBpbnB1dHMgZ2V0IHNwZWNpYWwgdHJlYXRtZW50IGR1ZSB0byBzb21lIGVkZ2UgY2FzZXMgaW5cbiAgICAgIC8vIENocm9tZS4gTGV0IGV2ZXJ5dGhpbmcgZWxzZSBhc3NpZ24gdGhlIHZhbHVlIGF0dHJpYnV0ZSBhcyBub3JtYWwuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNTMjaXNzdWVjb21tZW50LTIzNjA3NDMyNlxuICAgICAgaWYgKG5vZGUudHlwZSAhPT0gJ251bWJlcicgfHwgbm9kZS5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykgPT09IGZhbHNlKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCd2YWx1ZScsICcnICsgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnZhbGlkaXR5ICYmICFub2RlLnZhbGlkaXR5LmJhZElucHV0ICYmIG5vZGUub3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBub2RlKSB7XG4gICAgICAgIC8vIERvbid0IGFzc2lnbiBhbiBhdHRyaWJ1dGUgaWYgdmFsaWRhdGlvbiByZXBvcnRzIGJhZFxuICAgICAgICAvLyBpbnB1dC4gQ2hyb21lIHdpbGwgY2xlYXIgdGhlIHZhbHVlLiBBZGRpdGlvbmFsbHksIGRvbid0XG4gICAgICAgIC8vIG9wZXJhdGUgb24gaW5wdXRzIHRoYXQgaGF2ZSBmb2N1cywgb3RoZXJ3aXNlIENocm9tZSBtaWdodFxuICAgICAgICAvLyBzdHJpcCBvZmYgdHJhaWxpbmcgZGVjaW1hbCBwbGFjZXMgYW5kIGNhdXNlIHRoZSB1c2VyJ3NcbiAgICAgICAgLy8gY3Vyc29yIHBvc2l0aW9uIHRvIGp1bXAgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgaW5wdXQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEluIFJlYWN0RE9NSW5wdXQsIHdlIGhhdmUgYW4gb25CbHVyIGV2ZW50IHRoYXQgd2lsbCB0cmlnZ2VyXG4gICAgICAgIC8vIHRoaXMgZnVuY3Rpb24gYWdhaW4gd2hlbiBmb2N1cyBpcyBsb3N0LlxuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgndmFsdWUnLCAnJyArIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUkMSA9IGluamVjdGlvbi5IQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUU7XG5cblxudmFyIE5TID0ge1xuICB4bGluazogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuICB4bWw6ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnXG59O1xuXG4vKipcbiAqIFRoaXMgaXMgYSBsaXN0IG9mIGFsbCBTVkcgYXR0cmlidXRlcyB0aGF0IG5lZWQgc3BlY2lhbCBjYXNpbmcsXG4gKiBuYW1lc3BhY2luZywgb3IgYm9vbGVhbiB2YWx1ZSBhc3NpZ25tZW50LlxuICpcbiAqIFdoZW4gYWRkaW5nIGF0dHJpYnV0ZXMgdG8gdGhpcyBsaXN0LCBiZSBzdXJlIHRvIGFsc28gYWRkIHRoZW0gdG9cbiAqIHRoZSBgcG9zc2libGVTdGFuZGFyZE5hbWVzYCBtb2R1bGUgdG8gZW5zdXJlIGNhc2luZyBhbmQgaW5jb3JyZWN0XG4gKiBuYW1lIHdhcm5pbmdzLlxuICpcbiAqIFNWRyBBdHRyaWJ1dGVzIExpc3Q6XG4gKiBodHRwczovL3d3dy53My5vcmcvVFIvU1ZHL2F0dGluZGV4Lmh0bWxcbiAqIFNNSUwgU3BlYzpcbiAqIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9zbWlsXG4gKi9cbnZhciBBVFRSUyA9IFsnYWNjZW50LWhlaWdodCcsICdhbGlnbm1lbnQtYmFzZWxpbmUnLCAnYXJhYmljLWZvcm0nLCAnYmFzZWxpbmUtc2hpZnQnLCAnY2FwLWhlaWdodCcsICdjbGlwLXBhdGgnLCAnY2xpcC1ydWxlJywgJ2NvbG9yLWludGVycG9sYXRpb24nLCAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ2NvbG9yLXByb2ZpbGUnLCAnY29sb3ItcmVuZGVyaW5nJywgJ2RvbWluYW50LWJhc2VsaW5lJywgJ2VuYWJsZS1iYWNrZ3JvdW5kJywgJ2ZpbGwtb3BhY2l0eScsICdmaWxsLXJ1bGUnLCAnZmxvb2QtY29sb3InLCAnZmxvb2Qtb3BhY2l0eScsICdmb250LWZhbWlseScsICdmb250LXNpemUnLCAnZm9udC1zaXplLWFkanVzdCcsICdmb250LXN0cmV0Y2gnLCAnZm9udC1zdHlsZScsICdmb250LXZhcmlhbnQnLCAnZm9udC13ZWlnaHQnLCAnZ2x5cGgtbmFtZScsICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJywgJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJywgJ2hvcml6LWFkdi14JywgJ2hvcml6LW9yaWdpbi14JywgJ2ltYWdlLXJlbmRlcmluZycsICdsZXR0ZXItc3BhY2luZycsICdsaWdodGluZy1jb2xvcicsICdtYXJrZXItZW5kJywgJ21hcmtlci1taWQnLCAnbWFya2VyLXN0YXJ0JywgJ292ZXJsaW5lLXBvc2l0aW9uJywgJ292ZXJsaW5lLXRoaWNrbmVzcycsICdwYWludC1vcmRlcicsICdwYW5vc2UtMScsICdwb2ludGVyLWV2ZW50cycsICdyZW5kZXJpbmctaW50ZW50JywgJ3NoYXBlLXJlbmRlcmluZycsICdzdG9wLWNvbG9yJywgJ3N0b3Atb3BhY2l0eScsICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJywgJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJywgJ3N0cm9rZS1kYXNoYXJyYXknLCAnc3Ryb2tlLWRhc2hvZmZzZXQnLCAnc3Ryb2tlLWxpbmVjYXAnLCAnc3Ryb2tlLWxpbmVqb2luJywgJ3N0cm9rZS1taXRlcmxpbWl0JywgJ3N0cm9rZS1vcGFjaXR5JywgJ3N0cm9rZS13aWR0aCcsICd0ZXh0LWFuY2hvcicsICd0ZXh0LWRlY29yYXRpb24nLCAndGV4dC1yZW5kZXJpbmcnLCAndW5kZXJsaW5lLXBvc2l0aW9uJywgJ3VuZGVybGluZS10aGlja25lc3MnLCAndW5pY29kZS1iaWRpJywgJ3VuaWNvZGUtcmFuZ2UnLCAndW5pdHMtcGVyLWVtJywgJ3YtYWxwaGFiZXRpYycsICd2LWhhbmdpbmcnLCAndi1pZGVvZ3JhcGhpYycsICd2LW1hdGhlbWF0aWNhbCcsICd2ZWN0b3ItZWZmZWN0JywgJ3ZlcnQtYWR2LXknLCAndmVydC1vcmlnaW4teCcsICd2ZXJ0LW9yaWdpbi15JywgJ3dvcmQtc3BhY2luZycsICd3cml0aW5nLW1vZGUnLCAneC1oZWlnaHQnLCAneGxpbms6YWN0dWF0ZScsICd4bGluazphcmNyb2xlJywgJ3hsaW5rOmhyZWYnLCAneGxpbms6cm9sZScsICd4bGluazpzaG93JywgJ3hsaW5rOnRpdGxlJywgJ3hsaW5rOnR5cGUnLCAneG1sOmJhc2UnLCAneG1sbnM6eGxpbmsnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJ107XG5cbnZhciBTVkdET01Qcm9wZXJ0eUNvbmZpZyA9IHtcbiAgUHJvcGVydGllczoge1xuICAgIGF1dG9SZXZlcnNlOiBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUkMSxcbiAgICBleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkOiBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUkMSxcbiAgICBwcmVzZXJ2ZUFscGhhOiBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUkMVxuICB9LFxuICBET01BdHRyaWJ1dGVOYW1lczoge1xuICAgIGF1dG9SZXZlcnNlOiAnYXV0b1JldmVyc2UnLFxuICAgIGV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQ6ICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJyxcbiAgICBwcmVzZXJ2ZUFscGhhOiAncHJlc2VydmVBbHBoYSdcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXNwYWNlczoge1xuICAgIHhsaW5rQWN0dWF0ZTogTlMueGxpbmssXG4gICAgeGxpbmtBcmNyb2xlOiBOUy54bGluayxcbiAgICB4bGlua0hyZWY6IE5TLnhsaW5rLFxuICAgIHhsaW5rUm9sZTogTlMueGxpbmssXG4gICAgeGxpbmtTaG93OiBOUy54bGluayxcbiAgICB4bGlua1RpdGxlOiBOUy54bGluayxcbiAgICB4bGlua1R5cGU6IE5TLnhsaW5rLFxuICAgIHhtbEJhc2U6IE5TLnhtbCxcbiAgICB4bWxMYW5nOiBOUy54bWwsXG4gICAgeG1sU3BhY2U6IE5TLnhtbFxuICB9XG59O1xuXG52YXIgQ0FNRUxJWkUgPSAvW1xcLVxcOl0oW2Etel0pL2c7XG52YXIgY2FwaXRhbGl6ZSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICByZXR1cm4gdG9rZW5bMV0udG9VcHBlckNhc2UoKTtcbn07XG5cbkFUVFJTLmZvckVhY2goZnVuY3Rpb24gKG9yaWdpbmFsKSB7XG4gIHZhciByZWFjdE5hbWUgPSBvcmlnaW5hbC5yZXBsYWNlKENBTUVMSVpFLCBjYXBpdGFsaXplKTtcblxuICBTVkdET01Qcm9wZXJ0eUNvbmZpZy5Qcm9wZXJ0aWVzW3JlYWN0TmFtZV0gPSAwO1xuICBTVkdET01Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lc1tyZWFjdE5hbWVdID0gb3JpZ2luYWw7XG59KTtcblxuaW5qZWN0aW9uLmluamVjdERPTVByb3BlcnR5Q29uZmlnKEhUTUxET01Qcm9wZXJ0eUNvbmZpZyk7XG5pbmplY3Rpb24uaW5qZWN0RE9NUHJvcGVydHlDb25maWcoU1ZHRE9NUHJvcGVydHlDb25maWcpO1xuXG52YXIgUmVhY3RFcnJvclV0aWxzID0ge1xuICAvLyBVc2VkIGJ5IEZpYmVyIHRvIHNpbXVsYXRlIGEgdHJ5LWNhdGNoLlxuICBfY2F1Z2h0RXJyb3I6IG51bGwsXG4gIF9oYXNDYXVnaHRFcnJvcjogZmFsc2UsXG5cbiAgLy8gVXNlZCBieSBldmVudCBzeXN0ZW0gdG8gY2FwdHVyZS9yZXRocm93IHRoZSBmaXJzdCBlcnJvci5cbiAgX3JldGhyb3dFcnJvcjogbnVsbCxcbiAgX2hhc1JldGhyb3dFcnJvcjogZmFsc2UsXG5cbiAgaW5qZWN0aW9uOiB7XG4gICAgaW5qZWN0RXJyb3JVdGlsczogZnVuY3Rpb24gKGluamVjdGVkRXJyb3JVdGlscykge1xuICAgICAgISh0eXBlb2YgaW5qZWN0ZWRFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdJbmplY3RlZCBpbnZva2VHdWFyZGVkQ2FsbGJhY2soKSBtdXN0IGJlIGEgZnVuY3Rpb24uJykgOiB2b2lkIDA7XG4gICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgPSBpbmplY3RlZEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2FsbCBhIGZ1bmN0aW9uIHdoaWxlIGd1YXJkaW5nIGFnYWluc3QgZXJyb3JzIHRoYXQgaGFwcGVucyB3aXRoaW4gaXQuXG4gICAqIFJldHVybnMgYW4gZXJyb3IgaWYgaXQgdGhyb3dzLCBvdGhlcndpc2UgbnVsbC5cbiAgICpcbiAgICogSW4gcHJvZHVjdGlvbiwgdGhpcyBpcyBpbXBsZW1lbnRlZCB1c2luZyBhIHRyeS1jYXRjaC4gVGhlIHJlYXNvbiB3ZSBkb24ndFxuICAgKiB1c2UgYSB0cnktY2F0Y2ggZGlyZWN0bHkgaXMgc28gdGhhdCB3ZSBjYW4gc3dhcCBvdXQgYSBkaWZmZXJlbnRcbiAgICogaW1wbGVtZW50YXRpb24gaW4gREVWIG1vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHRoZSBndWFyZCB0byB1c2UgZm9yIGxvZ2dpbmcgb3IgZGVidWdnaW5nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZVxuICAgKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gdXNlIHdoZW4gY2FsbGluZyB0aGUgZnVuY3Rpb25cbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzIEFyZ3VtZW50cyBmb3IgZnVuY3Rpb25cbiAgICovXG4gIGludm9rZUd1YXJkZWRDYWxsYmFjazogZnVuY3Rpb24gKG5hbWUsIGZ1bmMsIGNvbnRleHQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2suYXBwbHkoUmVhY3RFcnJvclV0aWxzLCBhcmd1bWVudHMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTYW1lIGFzIGludm9rZUd1YXJkZWRDYWxsYmFjaywgYnV0IGluc3RlYWQgb2YgcmV0dXJuaW5nIGFuIGVycm9yLCBpdCBzdG9yZXNcbiAgICogaXQgaW4gYSBnbG9iYWwgc28gaXQgY2FuIGJlIHJldGhyb3duIGJ5IGByZXRocm93Q2F1Z2h0RXJyb3JgIGxhdGVyLlxuICAgKiBUT0RPOiBTZWUgaWYgX2NhdWdodEVycm9yIGFuZCBfcmV0aHJvd0Vycm9yIGNhbiBiZSB1bmlmaWVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2VcbiAgICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIHVzZSB3aGVuIGNhbGxpbmcgdGhlIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgZm9yIGZ1bmN0aW9uXG4gICAqL1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3I6IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChSZWFjdEVycm9yVXRpbHMuaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgdmFyIGVycm9yID0gUmVhY3RFcnJvclV0aWxzLmNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgIGlmICghUmVhY3RFcnJvclV0aWxzLl9oYXNSZXRocm93RXJyb3IpIHtcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9oYXNSZXRocm93RXJyb3IgPSB0cnVlO1xuICAgICAgICBSZWFjdEVycm9yVXRpbHMuX3JldGhyb3dFcnJvciA9IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRHVyaW5nIGV4ZWN1dGlvbiBvZiBndWFyZGVkIGZ1bmN0aW9ucyB3ZSB3aWxsIGNhcHR1cmUgdGhlIGZpcnN0IGVycm9yIHdoaWNoXG4gICAqIHdlIHdpbGwgcmV0aHJvdyB0byBiZSBoYW5kbGVkIGJ5IHRoZSB0b3AgbGV2ZWwgZXJyb3IgaGFuZGxlci5cbiAgICovXG4gIHJldGhyb3dDYXVnaHRFcnJvcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZXRocm93Q2F1Z2h0RXJyb3IuYXBwbHkoUmVhY3RFcnJvclV0aWxzLCBhcmd1bWVudHMpO1xuICB9LFxuXG4gIGhhc0NhdWdodEVycm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlYWN0RXJyb3JVdGlscy5faGFzQ2F1Z2h0RXJyb3I7XG4gIH0sXG5cbiAgY2xlYXJDYXVnaHRFcnJvcjogZnVuY3Rpb24gKCkge1xuICAgIGlmIChSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yKSB7XG4gICAgICB2YXIgZXJyb3IgPSBSZWFjdEVycm9yVXRpbHMuX2NhdWdodEVycm9yO1xuICAgICAgUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvciA9IG51bGw7XG4gICAgICBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yID0gZmFsc2U7XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ2NsZWFyQ2F1Z2h0RXJyb3Igd2FzIGNhbGxlZCBidXQgbm8gZXJyb3Igd2FzIGNhcHR1cmVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGludm9rZUd1YXJkZWRDYWxsYmFjayA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIFJlYWN0RXJyb3JVdGlscy5faGFzQ2F1Z2h0RXJyb3IgPSBmYWxzZTtcbiAgUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvciA9IG51bGw7XG4gIHZhciBmdW5jQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XG4gIHRyeSB7XG4gICAgZnVuYy5hcHBseShjb250ZXh0LCBmdW5jQXJncyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvciA9IGVycm9yO1xuICAgIFJlYWN0RXJyb3JVdGlscy5faGFzQ2F1Z2h0RXJyb3IgPSB0cnVlO1xuICB9XG59O1xuXG57XG4gIC8vIEluIERFViBtb2RlLCB3ZSBzd2FwIG91dCBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgZm9yIGEgc3BlY2lhbCB2ZXJzaW9uXG4gIC8vIHRoYXQgcGxheXMgbW9yZSBuaWNlbHkgd2l0aCB0aGUgYnJvd3NlcidzIERldlRvb2xzLiBUaGUgaWRlYSBpcyB0byBwcmVzZXJ2ZVxuICAvLyBcIlBhdXNlIG9uIGV4Y2VwdGlvbnNcIiBiZWhhdmlvci4gQmVjYXVzZSBSZWFjdCB3cmFwcyBhbGwgdXNlci1wcm92aWRlZFxuICAvLyBmdW5jdGlvbnMgaW4gaW52b2tlR3VhcmRlZENhbGxiYWNrLCBhbmQgdGhlIHByb2R1Y3Rpb24gdmVyc2lvbiBvZlxuICAvLyBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgdXNlcyBhIHRyeS1jYXRjaCwgYWxsIHVzZXIgZXhjZXB0aW9ucyBhcmUgdHJlYXRlZFxuICAvLyBsaWtlIGNhdWdodCBleGNlcHRpb25zLCBhbmQgdGhlIERldlRvb2xzIHdvbid0IHBhdXNlIHVubGVzcyB0aGUgZGV2ZWxvcGVyXG4gIC8vIHRha2VzIHRoZSBleHRyYSBzdGVwIG9mIGVuYWJsaW5nIHBhdXNlIG9uIGNhdWdodCBleGNlcHRpb25zLiBUaGlzIGlzXG4gIC8vIHVudGludHVpdGl2ZSwgdGhvdWdoLCBiZWNhdXNlIGV2ZW4gdGhvdWdoIFJlYWN0IGhhcyBjYXVnaHQgdGhlIGVycm9yLCBmcm9tXG4gIC8vIHRoZSBkZXZlbG9wZXIncyBwZXJzcGVjdGl2ZSwgdGhlIGVycm9yIGlzIHVuY2F1Z2h0LlxuICAvL1xuICAvLyBUbyBwcmVzZXJ2ZSB0aGUgZXhwZWN0ZWQgXCJQYXVzZSBvbiBleGNlcHRpb25zXCIgYmVoYXZpb3IsIHdlIGRvbid0IHVzZSBhXG4gIC8vIHRyeS1jYXRjaCBpbiBERVYuIEluc3RlYWQsIHdlIHN5bmNocm9ub3VzbHkgZGlzcGF0Y2ggYSBmYWtlIGV2ZW50IHRvIGEgZmFrZVxuICAvLyBET00gbm9kZSwgYW5kIGNhbGwgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2sgZnJvbSBpbnNpZGUgYW4gZXZlbnQgaGFuZGxlclxuICAvLyBmb3IgdGhhdCBmYWtlIGV2ZW50LiBJZiB0aGUgY2FsbGJhY2sgdGhyb3dzLCB0aGUgZXJyb3IgaXMgXCJjYXB0dXJlZFwiIHVzaW5nXG4gIC8vIGEgZ2xvYmFsIGV2ZW50IGhhbmRsZXIuIEJ1dCBiZWNhdXNlIHRoZSBlcnJvciBoYXBwZW5zIGluIGEgZGlmZmVyZW50XG4gIC8vIGV2ZW50IGxvb3AgY29udGV4dCwgaXQgZG9lcyBub3QgaW50ZXJydXB0IHRoZSBub3JtYWwgcHJvZ3JhbSBmbG93LlxuICAvLyBFZmZlY3RpdmVseSwgdGhpcyBnaXZlcyB1cyB0cnktY2F0Y2ggYmVoYXZpb3Igd2l0aG91dCBhY3R1YWxseSB1c2luZ1xuICAvLyB0cnktY2F0Y2guIE5lYXQhXG5cbiAgLy8gQ2hlY2sgdGhhdCB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgQVBJcyB3ZSBuZWVkIHRvIGltcGxlbWVudCBvdXIgc3BlY2lhbFxuICAvLyBERVYgdmVyc2lvbiBvZiBpbnZva2VHdWFyZGVkQ2FsbGJhY2tcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZGlzcGF0Y2hFdmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBmYWtlTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3JlYWN0Jyk7XG5cbiAgICB2YXIgaW52b2tlR3VhcmRlZENhbGxiYWNrRGV2ID0gZnVuY3Rpb24gKG5hbWUsIGZ1bmMsIGNvbnRleHQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAgIC8vIEtlZXBzIHRyYWNrIG9mIHdoZXRoZXIgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2sgdGhyZXcgYW4gZXJyb3IuIFdlXG4gICAgICAvLyBzZXQgdGhpcyB0byB0cnVlIGF0IHRoZSBiZWdpbm5pbmcsIHRoZW4gc2V0IGl0IHRvIGZhbHNlIHJpZ2h0IGFmdGVyXG4gICAgICAvLyBjYWxsaW5nIHRoZSBmdW5jdGlvbi4gSWYgdGhlIGZ1bmN0aW9uIGVycm9ycywgYGRpZEVycm9yYCB3aWxsIG5ldmVyIGJlXG4gICAgICAvLyBzZXQgdG8gZmFsc2UuIFRoaXMgc3RyYXRlZ3kgd29ya3MgZXZlbiBpZiB0aGUgYnJvd3NlciBpcyBmbGFreSBhbmRcbiAgICAgIC8vIGZhaWxzIHRvIGNhbGwgb3VyIGdsb2JhbCBlcnJvciBoYW5kbGVyLCBiZWNhdXNlIGl0IGRvZXNuJ3QgcmVseSBvblxuICAgICAgLy8gdGhlIGVycm9yIGV2ZW50IGF0IGFsbC5cbiAgICAgIHZhciBkaWRFcnJvciA9IHRydWU7XG5cbiAgICAgIC8vIENyZWF0ZSBhbiBldmVudCBoYW5kbGVyIGZvciBvdXIgZmFrZSBldmVudC4gV2Ugd2lsbCBzeW5jaHJvbm91c2x5XG4gICAgICAvLyBkaXNwYXRjaCBvdXIgZmFrZSBldmVudCB1c2luZyBgZGlzcGF0Y2hFdmVudGAuIEluc2lkZSB0aGUgaGFuZGxlciwgd2VcbiAgICAgIC8vIGNhbGwgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2suXG4gICAgICB2YXIgZnVuY0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpO1xuICAgICAgZnVuY3Rpb24gY2FsbENhbGxiYWNrKCkge1xuICAgICAgICAvLyBXZSBpbW1lZGlhdGVseSByZW1vdmUgdGhlIGNhbGxiYWNrIGZyb20gZXZlbnQgbGlzdGVuZXJzIHNvIHRoYXRcbiAgICAgICAgLy8gbmVzdGVkIGBpbnZva2VHdWFyZGVkQ2FsbGJhY2tgIGNhbGxzIGRvIG5vdCBjbGFzaC4gT3RoZXJ3aXNlLCBhXG4gICAgICAgIC8vIG5lc3RlZCBjYWxsIHdvdWxkIHRyaWdnZXIgdGhlIGZha2UgZXZlbnQgaGFuZGxlcnMgb2YgYW55IGNhbGwgaGlnaGVyXG4gICAgICAgIC8vIGluIHRoZSBzdGFjay5cbiAgICAgICAgZmFrZU5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBjYWxsQ2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBmdW5jQXJncyk7XG4gICAgICAgIGRpZEVycm9yID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBhIGdsb2JhbCBlcnJvciBldmVudCBoYW5kbGVyLiBXZSB1c2UgdGhpcyB0byBjYXB0dXJlIHRoZSB2YWx1ZVxuICAgICAgLy8gdGhhdCB3YXMgdGhyb3duLiBJdCdzIHBvc3NpYmxlIHRoYXQgdGhpcyBlcnJvciBoYW5kbGVyIHdpbGwgZmlyZSBtb3JlXG4gICAgICAvLyB0aGFuIG9uY2U7IGZvciBleGFtcGxlLCBpZiBub24tUmVhY3QgY29kZSBhbHNvIGNhbGxzIGBkaXNwYXRjaEV2ZW50YFxuICAgICAgLy8gYW5kIGEgaGFuZGxlciBmb3IgdGhhdCBldmVudCB0aHJvd3MuIFdlIHNob3VsZCBiZSByZXNpbGllbnQgdG8gbW9zdCBvZlxuICAgICAgLy8gdGhvc2UgY2FzZXMuIEV2ZW4gaWYgb3VyIGVycm9yIGV2ZW50IGhhbmRsZXIgZmlyZXMgbW9yZSB0aGFuIG9uY2UsIHRoZVxuICAgICAgLy8gbGFzdCBlcnJvciBldmVudCBpcyBhbHdheXMgdXNlZC4gSWYgdGhlIGNhbGxiYWNrIGFjdHVhbGx5IGRvZXMgZXJyb3IsXG4gICAgICAvLyB3ZSBrbm93IHRoYXQgdGhlIGxhc3QgZXJyb3IgZXZlbnQgaXMgdGhlIGNvcnJlY3Qgb25lLCBiZWNhdXNlIGl0J3Mgbm90XG4gICAgICAvLyBwb3NzaWJsZSBmb3IgYW55dGhpbmcgZWxzZSB0byBoYXZlIGhhcHBlbmVkIGluIGJldHdlZW4gb3VyIGNhbGxiYWNrXG4gICAgICAvLyBlcnJvcmluZyBhbmQgdGhlIGNvZGUgdGhhdCBmb2xsb3dzIHRoZSBgZGlzcGF0Y2hFdmVudGAgY2FsbCBiZWxvdy4gSWZcbiAgICAgIC8vIHRoZSBjYWxsYmFjayBkb2Vzbid0IGVycm9yLCBidXQgdGhlIGVycm9yIGV2ZW50IHdhcyBmaXJlZCwgd2Uga25vdyB0b1xuICAgICAgLy8gaWdub3JlIGl0IGJlY2F1c2UgYGRpZEVycm9yYCB3aWxsIGJlIGZhbHNlLCBhcyBkZXNjcmliZWQgYWJvdmUuXG4gICAgICB2YXIgZXJyb3IgPSB2b2lkIDA7XG4gICAgICAvLyBVc2UgdGhpcyB0byB0cmFjayB3aGV0aGVyIHRoZSBlcnJvciBldmVudCBpcyBldmVyIGNhbGxlZC5cbiAgICAgIHZhciBkaWRTZXRFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIGlzQ3Jvc3NPcmlnaW5FcnJvciA9IGZhbHNlO1xuXG4gICAgICBmdW5jdGlvbiBvbkVycm9yKGV2ZW50KSB7XG4gICAgICAgIGVycm9yID0gZXZlbnQuZXJyb3I7XG4gICAgICAgIGRpZFNldEVycm9yID0gdHJ1ZTtcbiAgICAgICAgaWYgKGVycm9yID09PSBudWxsICYmIGV2ZW50LmNvbG5vID09PSAwICYmIGV2ZW50LmxpbmVubyA9PT0gMCkge1xuICAgICAgICAgIGlzQ3Jvc3NPcmlnaW5FcnJvciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIGEgZmFrZSBldmVudCB0eXBlLlxuICAgICAgdmFyIGV2dFR5cGUgPSAncmVhY3QtJyArIChuYW1lID8gbmFtZSA6ICdpbnZva2VndWFyZGVkY2FsbGJhY2snKTtcblxuICAgICAgLy8gQXR0YWNoIG91ciBldmVudCBoYW5kbGVyc1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICBmYWtlTm9kZS5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGNhbGxDYWxsYmFjaywgZmFsc2UpO1xuXG4gICAgICAvLyBTeW5jaHJvbm91c2x5IGRpc3BhdGNoIG91ciBmYWtlIGV2ZW50LiBJZiB0aGUgdXNlci1wcm92aWRlZCBmdW5jdGlvblxuICAgICAgLy8gZXJyb3JzLCBpdCB3aWxsIHRyaWdnZXIgb3VyIGdsb2JhbCBlcnJvciBoYW5kbGVyLlxuICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgZXZ0LmluaXRFdmVudChldnRUeXBlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgZmFrZU5vZGUuZGlzcGF0Y2hFdmVudChldnQpO1xuXG4gICAgICBpZiAoZGlkRXJyb3IpIHtcbiAgICAgICAgaWYgKCFkaWRTZXRFcnJvcikge1xuICAgICAgICAgIC8vIFRoZSBjYWxsYmFjayBlcnJvcmVkLCBidXQgdGhlIGVycm9yIGV2ZW50IG5ldmVyIGZpcmVkLlxuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdBbiBlcnJvciB3YXMgdGhyb3duIGluc2lkZSBvbmUgb2YgeW91ciBjb21wb25lbnRzLCBidXQgUmVhY3QgJyArIFwiZG9lc24ndCBrbm93IHdoYXQgaXQgd2FzLiBUaGlzIGlzIGxpa2VseSBkdWUgdG8gYnJvd3NlciBcIiArICdmbGFraW5lc3MuIFJlYWN0IGRvZXMgaXRzIGJlc3QgdG8gcHJlc2VydmUgdGhlIFwiUGF1c2Ugb24gJyArICdleGNlcHRpb25zXCIgYmVoYXZpb3Igb2YgdGhlIERldlRvb2xzLCB3aGljaCByZXF1aXJlcyBzb21lICcgKyBcIkRFVi1tb2RlIG9ubHkgdHJpY2tzLiBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlc2UgZG9uJ3Qgd29yayBpbiBcIiArICd5b3VyIGJyb3dzZXIuIFRyeSB0cmlnZ2VyaW5nIHRoZSBlcnJvciBpbiBwcm9kdWN0aW9uIG1vZGUsICcgKyAnb3Igc3dpdGNoaW5nIHRvIGEgbW9kZXJuIGJyb3dzZXIuIElmIHlvdSBzdXNwZWN0IHRoYXQgdGhpcyBpcyAnICsgJ2FjdHVhbGx5IGFuIGlzc3VlIHdpdGggUmVhY3QsIHBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQ3Jvc3NPcmlnaW5FcnJvcikge1xuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKFwiQSBjcm9zcy1vcmlnaW4gZXJyb3Igd2FzIHRocm93bi4gUmVhY3QgZG9lc24ndCBoYXZlIGFjY2VzcyB0byBcIiArICd0aGUgYWN0dWFsIGVycm9yIG9iamVjdCBpbiBkZXZlbG9wbWVudC4gJyArICdTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1jcm9zc29yaWdpbi1lcnJvciBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTtcbiAgICAgICAgfVxuICAgICAgICBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yID0gdHJ1ZTtcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvciA9IGVycm9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvciA9IGZhbHNlO1xuICAgICAgICBSZWFjdEVycm9yVXRpbHMuX2NhdWdodEVycm9yID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIG91ciBldmVudCBsaXN0ZW5lcnNcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgIH07XG5cbiAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgPSBpbnZva2VHdWFyZGVkQ2FsbGJhY2tEZXY7XG4gIH1cbn1cblxudmFyIHJldGhyb3dDYXVnaHRFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKFJlYWN0RXJyb3JVdGlscy5faGFzUmV0aHJvd0Vycm9yKSB7XG4gICAgdmFyIGVycm9yID0gUmVhY3RFcnJvclV0aWxzLl9yZXRocm93RXJyb3I7XG4gICAgUmVhY3RFcnJvclV0aWxzLl9yZXRocm93RXJyb3IgPSBudWxsO1xuICAgIFJlYWN0RXJyb3JVdGlscy5faGFzUmV0aHJvd0Vycm9yID0gZmFsc2U7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8qKlxuICogSW5qZWN0YWJsZSBvcmRlcmluZyBvZiBldmVudCBwbHVnaW5zLlxuICovXG52YXIgZXZlbnRQbHVnaW5PcmRlciA9IG51bGw7XG5cbi8qKlxuICogSW5qZWN0YWJsZSBtYXBwaW5nIGZyb20gbmFtZXMgdG8gZXZlbnQgcGx1Z2luIG1vZHVsZXMuXG4gKi9cbnZhciBuYW1lc1RvUGx1Z2lucyA9IHt9O1xuXG4vKipcbiAqIFJlY29tcHV0ZXMgdGhlIHBsdWdpbiBsaXN0IHVzaW5nIHRoZSBpbmplY3RlZCBwbHVnaW5zIGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKSB7XG4gIGlmICghZXZlbnRQbHVnaW5PcmRlcikge1xuICAgIC8vIFdhaXQgdW50aWwgYW4gYGV2ZW50UGx1Z2luT3JkZXJgIGlzIGluamVjdGVkLlxuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIG5hbWVzVG9QbHVnaW5zKSB7XG4gICAgdmFyIHBsdWdpbk1vZHVsZSA9IG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgIHZhciBwbHVnaW5JbmRleCA9IGV2ZW50UGx1Z2luT3JkZXIuaW5kZXhPZihwbHVnaW5OYW1lKTtcbiAgICAhKHBsdWdpbkluZGV4ID4gLTEpID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCBldmVudCBwbHVnaW5zIHRoYXQgZG8gbm90IGV4aXN0IGluIHRoZSBwbHVnaW4gb3JkZXJpbmcsIGAlc2AuJywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgaWYgKHBsdWdpbnNbcGx1Z2luSW5kZXhdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgIXBsdWdpbk1vZHVsZS5leHRyYWN0RXZlbnRzID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogRXZlbnQgcGx1Z2lucyBtdXN0IGltcGxlbWVudCBhbiBgZXh0cmFjdEV2ZW50c2AgbWV0aG9kLCBidXQgYCVzYCBkb2VzIG5vdC4nLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICBwbHVnaW5zW3BsdWdpbkluZGV4XSA9IHBsdWdpbk1vZHVsZTtcbiAgICB2YXIgcHVibGlzaGVkRXZlbnRzID0gcGx1Z2luTW9kdWxlLmV2ZW50VHlwZXM7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHB1Ymxpc2hlZEV2ZW50cykge1xuICAgICAgIXB1Ymxpc2hFdmVudEZvclBsdWdpbihwdWJsaXNoZWRFdmVudHNbZXZlbnROYW1lXSwgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogRmFpbGVkIHRvIHB1Ymxpc2ggZXZlbnQgYCVzYCBmb3IgcGx1Z2luIGAlc2AuJywgZXZlbnROYW1lLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBQdWJsaXNoZXMgYW4gZXZlbnQgc28gdGhhdCBpdCBjYW4gYmUgZGlzcGF0Y2hlZCBieSB0aGUgc3VwcGxpZWQgcGx1Z2luLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBEaXNwYXRjaCBjb25maWd1cmF0aW9uIGZvciB0aGUgZXZlbnQuXG4gKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luTW9kdWxlIFBsdWdpbiBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IHdhcyBzdWNjZXNzZnVsbHkgcHVibGlzaGVkLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVibGlzaEV2ZW50Rm9yUGx1Z2luKGRpc3BhdGNoQ29uZmlnLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkge1xuICAhIWV2ZW50TmFtZURpc3BhdGNoQ29uZmlncy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5IdWI6IE1vcmUgdGhhbiBvbmUgcGx1Z2luIGF0dGVtcHRlZCB0byBwdWJsaXNoIHRoZSBzYW1lIGV2ZW50IG5hbWUsIGAlc2AuJywgZXZlbnROYW1lKSA6IHZvaWQgMDtcbiAgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzW2V2ZW50TmFtZV0gPSBkaXNwYXRjaENvbmZpZztcblxuICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMgPSBkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcztcbiAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgZm9yICh2YXIgcGhhc2VOYW1lIGluIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgICBpZiAocGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkocGhhc2VOYW1lKSkge1xuICAgICAgICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZSA9IHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3BoYXNlTmFtZV07XG4gICAgICAgIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGEgcmVnaXN0cmF0aW9uIG5hbWUgdGhhdCBpcyB1c2VkIHRvIGlkZW50aWZ5IGRpc3BhdGNoZWQgZXZlbnRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIFJlZ2lzdHJhdGlvbiBuYW1lIHRvIGFkZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBQbHVnaW5Nb2R1bGUgUGx1Z2luIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUocmVnaXN0cmF0aW9uTmFtZSwgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFyZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSByZWdpc3RyYXRpb24gbmFtZSwgYCVzYC4nLCByZWdpc3RyYXRpb25OYW1lKSA6IHZvaWQgMDtcbiAgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0gPSBwbHVnaW5Nb2R1bGU7XG4gIHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV0gPSBwbHVnaW5Nb2R1bGUuZXZlbnRUeXBlc1tldmVudE5hbWVdLmRlcGVuZGVuY2llcztcblxuICB7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gcmVnaXN0cmF0aW9uTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdID0gcmVnaXN0cmF0aW9uTmFtZTtcblxuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSAnb25Eb3VibGVDbGljaycpIHtcbiAgICAgIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMub25kYmxjbGljayA9IHJlZ2lzdHJhdGlvbk5hbWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIHBsdWdpbnMgc28gdGhhdCB0aGV5IGNhbiBleHRyYWN0IGFuZCBkaXNwYXRjaCBldmVudHMuXG4gKlxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWJ9XG4gKi9cblxuLyoqXG4gKiBPcmRlcmVkIGxpc3Qgb2YgaW5qZWN0ZWQgcGx1Z2lucy5cbiAqL1xudmFyIHBsdWdpbnMgPSBbXTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gZXZlbnQgbmFtZSB0byBkaXNwYXRjaCBjb25maWdcbiAqL1xudmFyIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyA9IHt9O1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBwbHVnaW4gbW9kdWxlXG4gKi9cbnZhciByZWdpc3RyYXRpb25OYW1lTW9kdWxlcyA9IHt9O1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBldmVudCBuYW1lXG4gKi9cbnZhciByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzID0ge307XG5cbi8qKlxuICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSByZWdpc3RyYXRpb24gbmFtZXMgdG8gdGhlIHByb3Blcmx5IGNhc2VkIHZlcnNpb24sXG4gKiB1c2VkIHRvIHdhcm4gaW4gdGhlIGNhc2Ugb2YgbWlzc2luZyBldmVudCBoYW5kbGVycy4gQXZhaWxhYmxlXG4gKiBvbmx5IGluIHRydWUuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyA9IHt9O1xuLy8gVHJ1c3QgdGhlIGRldmVsb3BlciB0byBvbmx5IHVzZSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzIGluIHRydWVcblxuLyoqXG4gKiBJbmplY3RzIGFuIG9yZGVyaW5nIG9mIHBsdWdpbnMgKGJ5IHBsdWdpbiBuYW1lKS4gVGhpcyBhbGxvd3MgdGhlIG9yZGVyaW5nXG4gKiB0byBiZSBkZWNvdXBsZWQgZnJvbSBpbmplY3Rpb24gb2YgdGhlIGFjdHVhbCBwbHVnaW5zIHNvIHRoYXQgb3JkZXJpbmcgaXNcbiAqIGFsd2F5cyBkZXRlcm1pbmlzdGljIHJlZ2FyZGxlc3Mgb2YgcGFja2FnaW5nLCBvbi10aGUtZmx5IGluamVjdGlvbiwgZXRjLlxuICpcbiAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICogQGludGVybmFsXG4gKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5PcmRlcn1cbiAqL1xuZnVuY3Rpb24gaW5qZWN0RXZlbnRQbHVnaW5PcmRlcihpbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIpIHtcbiAgISFldmVudFBsdWdpbk9yZGVyID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCBldmVudCBwbHVnaW4gb3JkZXJpbmcgbW9yZSB0aGFuIG9uY2UuIFlvdSBhcmUgbGlrZWx5IHRyeWluZyB0byBsb2FkIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdC4nKSA6IHZvaWQgMDtcbiAgLy8gQ2xvbmUgdGhlIG9yZGVyaW5nIHNvIGl0IGNhbm5vdCBiZSBkeW5hbWljYWxseSBtdXRhdGVkLlxuICBldmVudFBsdWdpbk9yZGVyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKTtcbiAgcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKTtcbn1cblxuLyoqXG4gKiBJbmplY3RzIHBsdWdpbnMgdG8gYmUgdXNlZCBieSBgRXZlbnRQbHVnaW5IdWJgLiBUaGUgcGx1Z2luIG5hbWVzIG11c3QgYmVcbiAqIGluIHRoZSBvcmRlcmluZyBpbmplY3RlZCBieSBgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcmAuXG4gKlxuICogUGx1Z2lucyBjYW4gYmUgaW5qZWN0ZWQgYXMgcGFydCBvZiBwYWdlIGluaXRpYWxpemF0aW9uIG9yIG9uLXRoZS1mbHkuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gKiBAaW50ZXJuYWxcbiAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWV9XG4gKi9cbmZ1bmN0aW9uIGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZShpbmplY3RlZE5hbWVzVG9QbHVnaW5zKSB7XG4gIHZhciBpc09yZGVyaW5nRGlydHkgPSBmYWxzZTtcbiAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBpbmplY3RlZE5hbWVzVG9QbHVnaW5zKSB7XG4gICAgaWYgKCFpbmplY3RlZE5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIHBsdWdpbk1vZHVsZSA9IGluamVjdGVkTmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgaWYgKCFuYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSB8fCBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSAhPT0gcGx1Z2luTW9kdWxlKSB7XG4gICAgICAhIW5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCB0d28gZGlmZmVyZW50IGV2ZW50IHBsdWdpbnMgdXNpbmcgdGhlIHNhbWUgbmFtZSwgYCVzYC4nLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICAgIG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdID0gcGx1Z2luTW9kdWxlO1xuICAgICAgaXNPcmRlcmluZ0RpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzT3JkZXJpbmdEaXJ0eSkge1xuICAgIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG4gIH1cbn1cblxudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSBPYmplY3QuZnJlZXplKHtcblx0cGx1Z2luczogcGx1Z2lucyxcblx0ZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzOiBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MsXG5cdHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzOiByZWdpc3RyYXRpb25OYW1lTW9kdWxlcyxcblx0cmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llczogcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyxcblx0cG9zc2libGVSZWdpc3RyYXRpb25OYW1lczogcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyxcblx0aW5qZWN0RXZlbnRQbHVnaW5PcmRlcjogaW5qZWN0RXZlbnRQbHVnaW5PcmRlcixcblx0aW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWVcbn0pO1xuXG52YXIgZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSA9IG51bGw7XG52YXIgZ2V0SW5zdGFuY2VGcm9tTm9kZSA9IG51bGw7XG52YXIgZ2V0Tm9kZUZyb21JbnN0YW5jZSA9IG51bGw7XG5cbnZhciBpbmplY3Rpb24kMiA9IHtcbiAgaW5qZWN0Q29tcG9uZW50VHJlZTogZnVuY3Rpb24gKEluamVjdGVkKSB7XG4gICAgZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSA9IEluamVjdGVkLmdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGU7XG4gICAgZ2V0SW5zdGFuY2VGcm9tTm9kZSA9IEluamVjdGVkLmdldEluc3RhbmNlRnJvbU5vZGU7XG4gICAgZ2V0Tm9kZUZyb21JbnN0YW5jZSA9IEluamVjdGVkLmdldE5vZGVGcm9tSW5zdGFuY2U7XG5cbiAgICB7XG4gICAgICB3YXJuaW5nKGdldE5vZGVGcm9tSW5zdGFuY2UgJiYgZ2V0SW5zdGFuY2VGcm9tTm9kZSwgJ0V2ZW50UGx1Z2luVXRpbHMuaW5qZWN0aW9uLmluamVjdENvbXBvbmVudFRyZWUoLi4uKTogSW5qZWN0ZWQgJyArICdtb2R1bGUgaXMgbWlzc2luZyBnZXROb2RlRnJvbUluc3RhbmNlIG9yIGdldEluc3RhbmNlRnJvbU5vZGUuJyk7XG4gICAgfVxuICB9XG59O1xuXG5cblxuXG5cblxudmFyIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzO1xue1xuICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgICB2YXIgZGlzcGF0Y2hJbnN0YW5jZXMgPSBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXM7XG5cbiAgICB2YXIgbGlzdGVuZXJzSXNBcnIgPSBBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXJzKTtcbiAgICB2YXIgbGlzdGVuZXJzTGVuID0gbGlzdGVuZXJzSXNBcnIgPyBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGggOiBkaXNwYXRjaExpc3RlbmVycyA/IDEgOiAwO1xuXG4gICAgdmFyIGluc3RhbmNlc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaEluc3RhbmNlcyk7XG4gICAgdmFyIGluc3RhbmNlc0xlbiA9IGluc3RhbmNlc0lzQXJyID8gZGlzcGF0Y2hJbnN0YW5jZXMubGVuZ3RoIDogZGlzcGF0Y2hJbnN0YW5jZXMgPyAxIDogMDtcblxuICAgIHdhcm5pbmcoaW5zdGFuY2VzSXNBcnIgPT09IGxpc3RlbmVyc0lzQXJyICYmIGluc3RhbmNlc0xlbiA9PT0gbGlzdGVuZXJzTGVuLCAnRXZlbnRQbHVnaW5VdGlsczogSW52YWxpZCBgZXZlbnRgLicpO1xuICB9O1xufVxuXG4vKipcbiAqIERpc3BhdGNoIHRoZSBldmVudCB0byB0aGUgbGlzdGVuZXIuXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBTeW50aGV0aWNFdmVudCB0byBoYW5kbGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2ltdWxhdGVkIElmIHRoZSBldmVudCBpcyBzaW11bGF0ZWQgKGNoYW5nZXMgZXhuIGJlaGF2aW9yKVxuICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgQXBwbGljYXRpb24tbGV2ZWwgY2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gaW5zdCBJbnRlcm5hbCBjb21wb25lbnQgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGxpc3RlbmVyLCBpbnN0KSB7XG4gIHZhciB0eXBlID0gZXZlbnQudHlwZSB8fCAndW5rbm93bi1ldmVudCc7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBnZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrQW5kQ2F0Y2hGaXJzdEVycm9yKHR5cGUsIGxpc3RlbmVyLCB1bmRlZmluZWQsIGV2ZW50KTtcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGw7XG59XG5cbi8qKlxuICogU3RhbmRhcmQvc2ltcGxlIGl0ZXJhdGlvbiB0aHJvdWdoIGFuIGV2ZW50J3MgY29sbGVjdGVkIGRpc3BhdGNoZXMuXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcihldmVudCwgc2ltdWxhdGVkKSB7XG4gIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSW5zdGFuY2VzID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuICB7XG4gICAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMoZXZlbnQpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXJzKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gTGlzdGVuZXJzIGFuZCBJbnN0YW5jZXMgYXJlIHR3byBwYXJhbGxlbCBhcnJheXMgdGhhdCBhcmUgYWx3YXlzIGluIHN5bmMuXG4gICAgICBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgZGlzcGF0Y2hMaXN0ZW5lcnNbaV0sIGRpc3BhdGNoSW5zdGFuY2VzW2ldKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMpIHtcbiAgICBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgZGlzcGF0Y2hMaXN0ZW5lcnMsIGRpc3BhdGNoSW5zdGFuY2VzKTtcbiAgfVxuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBudWxsO1xufVxuXG4vKipcbiAqIEBzZWUgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGxcbiAqL1xuXG5cbi8qKlxuICogRXhlY3V0aW9uIG9mIGEgXCJkaXJlY3RcIiBkaXNwYXRjaCAtIHRoZXJlIG11c3QgYmUgYXQgbW9zdCBvbmUgZGlzcGF0Y2hcbiAqIGFjY3VtdWxhdGVkIG9uIHRoZSBldmVudCBvciBpdCBpcyBjb25zaWRlcmVkIGFuIGVycm9yLiBJdCBkb2Vzbid0IHJlYWxseSBtYWtlXG4gKiBzZW5zZSBmb3IgYW4gZXZlbnQgd2l0aCBtdWx0aXBsZSBkaXNwYXRjaGVzIChidWJibGVkKSB0byBrZWVwIHRyYWNrIG9mIHRoZVxuICogcmV0dXJuIHZhbHVlcyBhdCBlYWNoIGRpc3BhdGNoIGV4ZWN1dGlvbiwgYnV0IGl0IGRvZXMgdGVuZCB0byBtYWtlIHNlbnNlIHdoZW5cbiAqIGRlYWxpbmcgd2l0aCBcImRpcmVjdFwiIGRpc3BhdGNoZXMuXG4gKlxuICogQHJldHVybiB7Kn0gVGhlIHJldHVybiB2YWx1ZSBvZiBleGVjdXRpbmcgdGhlIHNpbmdsZSBkaXNwYXRjaC5cbiAqL1xuXG5cbi8qKlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWZmIG51bWJlciBvZiBkaXNwYXRjaGVzIGFjY3VtdWxhdGVkIGlzIGdyZWF0ZXIgdGhhbiAwLlxuICovXG5cbi8qKlxuICogQWNjdW11bGF0ZXMgaXRlbXMgdGhhdCBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCBpbnRvIHRoZSBmaXJzdCBvbmUuIFRoaXNcbiAqIGlzIHVzZWQgdG8gY29uc2VydmUgbWVtb3J5IGJ5IGF2b2lkaW5nIGFycmF5IGFsbG9jYXRpb25zLCBhbmQgdGh1cyBzYWNyaWZpY2VzXG4gKiBBUEkgY2xlYW5uZXNzLiBTaW5jZSBgY3VycmVudGAgY2FuIGJlIG51bGwgYmVmb3JlIGJlaW5nIHBhc3NlZCBpbiBhbmQgbm90XG4gKiBudWxsIGFmdGVyIHRoaXMgZnVuY3Rpb24sIG1ha2Ugc3VyZSB0byBhc3NpZ24gaXQgYmFjayB0byBgY3VycmVudGA6XG4gKlxuICogYGEgPSBhY2N1bXVsYXRlSW50byhhLCBiKTtgXG4gKlxuICogVGhpcyBBUEkgc2hvdWxkIGJlIHNwYXJpbmdseSB1c2VkLiBUcnkgYGFjY3VtdWxhdGVgIGZvciBzb21ldGhpbmcgY2xlYW5lci5cbiAqXG4gKiBAcmV0dXJuIHsqfGFycmF5PCo+fSBBbiBhY2N1bXVsYXRpb24gb2YgaXRlbXMuXG4gKi9cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUludG8oY3VycmVudCwgbmV4dCkge1xuICAhKG5leHQgIT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdhY2N1bXVsYXRlSW50byguLi4pOiBBY2N1bXVsYXRlZCBpdGVtcyBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZC4nKSA6IHZvaWQgMDtcblxuICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cblxuICAvLyBCb3RoIGFyZSBub3QgZW1wdHkuIFdhcm5pbmc6IE5ldmVyIGNhbGwgeC5jb25jYXQoeSkgd2hlbiB5b3UgYXJlIG5vdFxuICAvLyBjZXJ0YWluIHRoYXQgeCBpcyBhbiBBcnJheSAoeCBjb3VsZCBiZSBhIHN0cmluZyB3aXRoIGNvbmNhdCBtZXRob2QpLlxuICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50KSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgICBjdXJyZW50LnB1c2guYXBwbHkoY3VycmVudCwgbmV4dCk7XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG4gICAgY3VycmVudC5wdXNoKG5leHQpO1xuICAgIHJldHVybiBjdXJyZW50O1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobmV4dCkpIHtcbiAgICAvLyBBIGJpdCB0b28gZGFuZ2Vyb3VzIHRvIG11dGF0ZSBgbmV4dGAuXG4gICAgcmV0dXJuIFtjdXJyZW50XS5jb25jYXQobmV4dCk7XG4gIH1cblxuICByZXR1cm4gW2N1cnJlbnQsIG5leHRdO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YXJyYXl9IGFyciBhbiBcImFjY3VtdWxhdGlvblwiIG9mIGl0ZW1zIHdoaWNoIGlzIGVpdGhlciBhbiBBcnJheSBvclxuICogYSBzaW5nbGUgaXRlbS4gVXNlZnVsIHdoZW4gcGFpcmVkIHdpdGggdGhlIGBhY2N1bXVsYXRlYCBtb2R1bGUuIFRoaXMgaXMgYVxuICogc2ltcGxlIHV0aWxpdHkgdGhhdCBhbGxvd3MgdXMgdG8gcmVhc29uIGFib3V0IGEgY29sbGVjdGlvbiBvZiBpdGVtcywgYnV0XG4gKiBoYW5kbGluZyB0aGUgY2FzZSB3aGVuIHRoZXJlIGlzIGV4YWN0bHkgb25lIGl0ZW0gKGFuZCB3ZSBkbyBub3QgbmVlZCB0b1xuICogYWxsb2NhdGUgYW4gYXJyYXkpLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgQ2FsbGJhY2sgaW52b2tlZCB3aXRoIGVhY2ggZWxlbWVudCBvciBhIGNvbGxlY3Rpb24uXG4gKiBAcGFyYW0gez99IFtzY29wZV0gU2NvcGUgdXNlZCBhcyBgdGhpc2AgaW4gYSBjYWxsYmFjay5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaEFjY3VtdWxhdGVkKGFyciwgY2IsIHNjb3BlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBhcnIuZm9yRWFjaChjYiwgc2NvcGUpO1xuICB9IGVsc2UgaWYgKGFycikge1xuICAgIGNiLmNhbGwoc2NvcGUsIGFycik7XG4gIH1cbn1cblxuLyoqXG4gKiBJbnRlcm5hbCBxdWV1ZSBvZiBldmVudHMgdGhhdCBoYXZlIGFjY3VtdWxhdGVkIHRoZWlyIGRpc3BhdGNoZXMgYW5kIGFyZVxuICogd2FpdGluZyB0byBoYXZlIHRoZWlyIGRpc3BhdGNoZXMgZXhlY3V0ZWQuXG4gKi9cbnZhciBldmVudFF1ZXVlID0gbnVsbDtcblxuLyoqXG4gKiBEaXNwYXRjaGVzIGFuIGV2ZW50IGFuZCByZWxlYXNlcyBpdCBiYWNrIGludG8gdGhlIHBvb2wsIHVubGVzcyBwZXJzaXN0ZW50LlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gZXZlbnQgU3ludGhldGljIGV2ZW50IHRvIGJlIGRpc3BhdGNoZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbXVsYXRlZCBJZiB0aGUgZXZlbnQgaXMgc2ltdWxhdGVkIChjaGFuZ2VzIGV4biBiZWhhdmlvcilcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UgPSBmdW5jdGlvbiAoZXZlbnQsIHNpbXVsYXRlZCkge1xuICBpZiAoZXZlbnQpIHtcbiAgICBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIoZXZlbnQsIHNpbXVsYXRlZCk7XG5cbiAgICBpZiAoIWV2ZW50LmlzUGVyc2lzdGVudCgpKSB7XG4gICAgICBldmVudC5jb25zdHJ1Y3Rvci5yZWxlYXNlKGV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlU2ltdWxhdGVkID0gZnVuY3Rpb24gKGUpIHtcbiAgcmV0dXJuIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZShlLCB0cnVlKTtcbn07XG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlVG9wTGV2ZWwgPSBmdW5jdGlvbiAoZSkge1xuICByZXR1cm4gZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlKGUsIGZhbHNlKTtcbn07XG5cbmZ1bmN0aW9uIGlzSW50ZXJhY3RpdmUodGFnKSB7XG4gIHJldHVybiB0YWcgPT09ICdidXR0b24nIHx8IHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICdzZWxlY3QnIHx8IHRhZyA9PT0gJ3RleHRhcmVhJztcbn1cblxuZnVuY3Rpb24gc2hvdWxkUHJldmVudE1vdXNlRXZlbnQobmFtZSwgdHlwZSwgcHJvcHMpIHtcbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgY2FzZSAnb25DbGljayc6XG4gICAgY2FzZSAnb25DbGlja0NhcHR1cmUnOlxuICAgIGNhc2UgJ29uRG91YmxlQ2xpY2snOlxuICAgIGNhc2UgJ29uRG91YmxlQ2xpY2tDYXB0dXJlJzpcbiAgICBjYXNlICdvbk1vdXNlRG93bic6XG4gICAgY2FzZSAnb25Nb3VzZURvd25DYXB0dXJlJzpcbiAgICBjYXNlICdvbk1vdXNlTW92ZSc6XG4gICAgY2FzZSAnb25Nb3VzZU1vdmVDYXB0dXJlJzpcbiAgICBjYXNlICdvbk1vdXNlVXAnOlxuICAgIGNhc2UgJ29uTW91c2VVcENhcHR1cmUnOlxuICAgICAgcmV0dXJuICEhKHByb3BzLmRpc2FibGVkICYmIGlzSW50ZXJhY3RpdmUodHlwZSkpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIGEgdW5pZmllZCBpbnRlcmZhY2UgZm9yIGV2ZW50IHBsdWdpbnMgdG8gYmUgaW5zdGFsbGVkIGFuZCBjb25maWd1cmVkLlxuICpcbiAqIEV2ZW50IHBsdWdpbnMgY2FuIGltcGxlbWVudCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICBgZXh0cmFjdEV2ZW50c2Age2Z1bmN0aW9uKHN0cmluZywgRE9NRXZlbnRUYXJnZXQsIHN0cmluZywgb2JqZWN0KTogKn1cbiAqICAgICBSZXF1aXJlZC4gV2hlbiBhIHRvcC1sZXZlbCBldmVudCBpcyBmaXJlZCwgdGhpcyBtZXRob2QgaXMgZXhwZWN0ZWQgdG9cbiAqICAgICBleHRyYWN0IHN5bnRoZXRpYyBldmVudHMgdGhhdCB3aWxsIGluIHR1cm4gYmUgcXVldWVkIGFuZCBkaXNwYXRjaGVkLlxuICpcbiAqICAgYGV2ZW50VHlwZXNgIHtvYmplY3R9XG4gKiAgICAgT3B0aW9uYWwsIHBsdWdpbnMgdGhhdCBmaXJlIGV2ZW50cyBtdXN0IHB1Ymxpc2ggYSBtYXBwaW5nIG9mIHJlZ2lzdHJhdGlvblxuICogICAgIG5hbWVzIHRoYXQgYXJlIHVzZWQgdG8gcmVnaXN0ZXIgbGlzdGVuZXJzLiBWYWx1ZXMgb2YgdGhpcyBtYXBwaW5nIG11c3RcbiAqICAgICBiZSBvYmplY3RzIHRoYXQgY29udGFpbiBgcmVnaXN0cmF0aW9uTmFtZWAgb3IgYHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzYC5cbiAqXG4gKiAgIGBleGVjdXRlRGlzcGF0Y2hgIHtmdW5jdGlvbihvYmplY3QsIGZ1bmN0aW9uLCBzdHJpbmcpfVxuICogICAgIE9wdGlvbmFsLCBhbGxvd3MgcGx1Z2lucyB0byBvdmVycmlkZSBob3cgYW4gZXZlbnQgZ2V0cyBkaXNwYXRjaGVkLiBCeVxuICogICAgIGRlZmF1bHQsIHRoZSBsaXN0ZW5lciBpcyBzaW1wbHkgaW52b2tlZC5cbiAqXG4gKiBFYWNoIHBsdWdpbiB0aGF0IGlzIGluamVjdGVkIGludG8gYEV2ZW50c1BsdWdpbkh1YmAgaXMgaW1tZWRpYXRlbHkgb3BlcmFibGUuXG4gKlxuICogQHB1YmxpY1xuICovXG5cbi8qKlxuICogTWV0aG9kcyBmb3IgaW5qZWN0aW5nIGRlcGVuZGVuY2llcy5cbiAqL1xudmFyIGluamVjdGlvbiQxID0ge1xuICAvKipcbiAgICogQHBhcmFtIHthcnJheX0gSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGluamVjdEV2ZW50UGx1Z2luT3JkZXI6IGluamVjdEV2ZW50UGx1Z2luT3JkZXIsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zIE1hcCBmcm9tIG5hbWVzIHRvIHBsdWdpbiBtb2R1bGVzLlxuICAgKi9cbiAgaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGluc3QgVGhlIGluc3RhbmNlLCB3aGljaCBpcyB0aGUgc291cmNlIG9mIGV2ZW50cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAqIEByZXR1cm4gez9mdW5jdGlvbn0gVGhlIHN0b3JlZCBjYWxsYmFjay5cbiAqL1xuZnVuY3Rpb24gZ2V0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICB2YXIgbGlzdGVuZXI7XG5cbiAgLy8gVE9ETzogc2hvdWxkUHJldmVudE1vdXNlRXZlbnQgaXMgRE9NLXNwZWNpZmljIGFuZCBkZWZpbml0ZWx5IHNob3VsZCBub3RcbiAgLy8gbGl2ZSBoZXJlOyBuZWVkcyB0byBiZSBtb3ZlZCB0byBhIGJldHRlciBwbGFjZSBzb29uXG4gIHZhciBzdGF0ZU5vZGUgPSBpbnN0LnN0YXRlTm9kZTtcbiAgaWYgKCFzdGF0ZU5vZGUpIHtcbiAgICAvLyBXb3JrIGluIHByb2dyZXNzIChleDogb25sb2FkIGV2ZW50cyBpbiBpbmNyZW1lbnRhbCBtb2RlKS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgcHJvcHMgPSBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlKHN0YXRlTm9kZSk7XG4gIGlmICghcHJvcHMpIHtcbiAgICAvLyBXb3JrIGluIHByb2dyZXNzLlxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxpc3RlbmVyID0gcHJvcHNbcmVnaXN0cmF0aW9uTmFtZV07XG4gIGlmIChzaG91bGRQcmV2ZW50TW91c2VFdmVudChyZWdpc3RyYXRpb25OYW1lLCBpbnN0LnR5cGUsIHByb3BzKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gICEoIWxpc3RlbmVyIHx8IHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBgJXNgIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IGEgdmFsdWUgb2YgYCVzYCB0eXBlLicsIHJlZ2lzdHJhdGlvbk5hbWUsIHR5cGVvZiBsaXN0ZW5lcikgOiB2b2lkIDA7XG4gIHJldHVybiBsaXN0ZW5lcjtcbn1cblxuLyoqXG4gKiBBbGxvd3MgcmVnaXN0ZXJlZCBwbHVnaW5zIGFuIG9wcG9ydHVuaXR5IHRvIGV4dHJhY3QgZXZlbnRzIGZyb20gdG9wLWxldmVsXG4gKiBuYXRpdmUgYnJvd3NlciBldmVudHMuXG4gKlxuICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgZXZlbnRzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb3QgZXZlcnkgcGx1Z2luIGluIHRoZSBvcmRlcmluZyBtYXkgYmUgbG9hZGVkIGF0IHJ1bnRpbWUuXG4gICAgdmFyIHBvc3NpYmxlUGx1Z2luID0gcGx1Z2luc1tpXTtcbiAgICBpZiAocG9zc2libGVQbHVnaW4pIHtcbiAgICAgIHZhciBleHRyYWN0ZWRFdmVudHMgPSBwb3NzaWJsZVBsdWdpbi5leHRyYWN0RXZlbnRzKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgIGlmIChleHRyYWN0ZWRFdmVudHMpIHtcbiAgICAgICAgZXZlbnRzID0gYWNjdW11bGF0ZUludG8oZXZlbnRzLCBleHRyYWN0ZWRFdmVudHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZXZlbnRzO1xufVxuXG4vKipcbiAqIEVucXVldWVzIGEgc3ludGhldGljIGV2ZW50IHRoYXQgc2hvdWxkIGJlIGRpc3BhdGNoZWQgd2hlblxuICogYHByb2Nlc3NFdmVudFF1ZXVlYCBpcyBpbnZva2VkLlxuICpcbiAqIEBwYXJhbSB7Kn0gZXZlbnRzIEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGVucXVldWVFdmVudHMoZXZlbnRzKSB7XG4gIGlmIChldmVudHMpIHtcbiAgICBldmVudFF1ZXVlID0gYWNjdW11bGF0ZUludG8oZXZlbnRRdWV1ZSwgZXZlbnRzKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoZXMgYWxsIHN5bnRoZXRpYyBldmVudHMgb24gdGhlIGV2ZW50IHF1ZXVlLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBwcm9jZXNzRXZlbnRRdWV1ZShzaW11bGF0ZWQpIHtcbiAgLy8gU2V0IGBldmVudFF1ZXVlYCB0byBudWxsIGJlZm9yZSBwcm9jZXNzaW5nIGl0IHNvIHRoYXQgd2UgY2FuIHRlbGwgaWYgbW9yZVxuICAvLyBldmVudHMgZ2V0IGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcuXG4gIHZhciBwcm9jZXNzaW5nRXZlbnRRdWV1ZSA9IGV2ZW50UXVldWU7XG4gIGV2ZW50UXVldWUgPSBudWxsO1xuXG4gIGlmICghcHJvY2Vzc2luZ0V2ZW50UXVldWUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoc2ltdWxhdGVkKSB7XG4gICAgZm9yRWFjaEFjY3VtdWxhdGVkKHByb2Nlc3NpbmdFdmVudFF1ZXVlLCBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQpO1xuICB9IGVsc2Uge1xuICAgIGZvckVhY2hBY2N1bXVsYXRlZChwcm9jZXNzaW5nRXZlbnRRdWV1ZSwgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlVG9wTGV2ZWwpO1xuICB9XG4gICEhZXZlbnRRdWV1ZSA/IGludmFyaWFudChmYWxzZSwgJ3Byb2Nlc3NFdmVudFF1ZXVlKCk6IEFkZGl0aW9uYWwgZXZlbnRzIHdlcmUgZW5xdWV1ZWQgd2hpbGUgcHJvY2Vzc2luZyBhbiBldmVudCBxdWV1ZS4gU3VwcG9ydCBmb3IgdGhpcyBoYXMgbm90IHlldCBiZWVuIGltcGxlbWVudGVkLicpIDogdm9pZCAwO1xuICAvLyBUaGlzIHdvdWxkIGJlIGEgZ29vZCB0aW1lIHRvIHJldGhyb3cgaWYgYW55IG9mIHRoZSBldmVudCBoYW5kbGVycyB0aHJldy5cbiAgUmVhY3RFcnJvclV0aWxzLnJldGhyb3dDYXVnaHRFcnJvcigpO1xufVxuXG52YXIgRXZlbnRQbHVnaW5IdWIgPSBPYmplY3QuZnJlZXplKHtcblx0aW5qZWN0aW9uOiBpbmplY3Rpb24kMSxcblx0Z2V0TGlzdGVuZXI6IGdldExpc3RlbmVyLFxuXHRleHRyYWN0RXZlbnRzOiBleHRyYWN0RXZlbnRzLFxuXHRlbnF1ZXVlRXZlbnRzOiBlbnF1ZXVlRXZlbnRzLFxuXHRwcm9jZXNzRXZlbnRRdWV1ZTogcHJvY2Vzc0V2ZW50UXVldWVcbn0pO1xuXG52YXIgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCA9IDA7IC8vIEJlZm9yZSB3ZSBrbm93IHdoZXRoZXIgaXQgaXMgZnVuY3Rpb25hbCBvciBjbGFzc1xudmFyIEZ1bmN0aW9uYWxDb21wb25lbnQgPSAxO1xudmFyIENsYXNzQ29tcG9uZW50ID0gMjtcbnZhciBIb3N0Um9vdCA9IDM7IC8vIFJvb3Qgb2YgYSBob3N0IHRyZWUuIENvdWxkIGJlIG5lc3RlZCBpbnNpZGUgYW5vdGhlciBub2RlLlxudmFyIEhvc3RQb3J0YWwgPSA0OyAvLyBBIHN1YnRyZWUuIENvdWxkIGJlIGFuIGVudHJ5IHBvaW50IHRvIGEgZGlmZmVyZW50IHJlbmRlcmVyLlxudmFyIEhvc3RDb21wb25lbnQgPSA1O1xudmFyIEhvc3RUZXh0ID0gNjtcbnZhciBDYWxsQ29tcG9uZW50ID0gNztcbnZhciBDYWxsSGFuZGxlclBoYXNlID0gODtcbnZhciBSZXR1cm5Db21wb25lbnQgPSA5O1xudmFyIEZyYWdtZW50ID0gMTA7XG5cbnZhciByYW5kb21LZXkgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcbnZhciBpbnRlcm5hbEluc3RhbmNlS2V5ID0gJ19fcmVhY3RJbnRlcm5hbEluc3RhbmNlJCcgKyByYW5kb21LZXk7XG52YXIgaW50ZXJuYWxFdmVudEhhbmRsZXJzS2V5ID0gJ19fcmVhY3RFdmVudEhhbmRsZXJzJCcgKyByYW5kb21LZXk7XG5cbmZ1bmN0aW9uIHByZWNhY2hlRmliZXJOb2RlJDEoaG9zdEluc3QsIG5vZGUpIHtcbiAgbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSA9IGhvc3RJbnN0O1xufVxuXG4vKipcbiAqIEdpdmVuIGEgRE9NIG5vZGUsIHJldHVybiB0aGUgY2xvc2VzdCBSZWFjdERPTUNvbXBvbmVudCBvclxuICogUmVhY3RET01UZXh0Q29tcG9uZW50IGluc3RhbmNlIGFuY2VzdG9yLlxuICovXG5mdW5jdGlvbiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShub2RlKSB7XG4gIGlmIChub2RlW2ludGVybmFsSW5zdGFuY2VLZXldKSB7XG4gICAgcmV0dXJuIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gIH1cblxuICAvLyBXYWxrIHVwIHRoZSB0cmVlIHVudGlsIHdlIGZpbmQgYW4gYW5jZXN0b3Igd2hvc2UgaW5zdGFuY2Ugd2UgaGF2ZSBjYWNoZWQuXG4gIHZhciBwYXJlbnRzID0gW107XG4gIHdoaWxlICghbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSkge1xuICAgIHBhcmVudHMucHVzaChub2RlKTtcbiAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUb3Agb2YgdGhlIHRyZWUuIFRoaXMgbm9kZSBtdXN0IG5vdCBiZSBwYXJ0IG9mIGEgUmVhY3QgdHJlZSAob3IgaXNcbiAgICAgIC8vIHVubW91bnRlZCwgcG90ZW50aWFsbHkpLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNsb3Nlc3QgPSB2b2lkIDA7XG4gIHZhciBpbnN0ID0gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtcbiAgaWYgKGluc3QudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGluc3QudGFnID09PSBIb3N0VGV4dCkge1xuICAgIC8vIEluIEZpYmVyLCB0aGlzIHdpbGwgYWx3YXlzIGJlIHRoZSBkZWVwZXN0IHJvb3QuXG4gICAgcmV0dXJuIGluc3Q7XG4gIH1cbiAgZm9yICg7IG5vZGUgJiYgKGluc3QgPSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldKTsgbm9kZSA9IHBhcmVudHMucG9wKCkpIHtcbiAgICBjbG9zZXN0ID0gaW5zdDtcbiAgfVxuXG4gIHJldHVybiBjbG9zZXN0O1xufVxuXG4vKipcbiAqIEdpdmVuIGEgRE9NIG5vZGUsIHJldHVybiB0aGUgUmVhY3RET01Db21wb25lbnQgb3IgUmVhY3RET01UZXh0Q29tcG9uZW50XG4gKiBpbnN0YW5jZSwgb3IgbnVsbCBpZiB0aGUgbm9kZSB3YXMgbm90IHJlbmRlcmVkIGJ5IHRoaXMgUmVhY3QuXG4gKi9cbmZ1bmN0aW9uIGdldEluc3RhbmNlRnJvbU5vZGUkMShub2RlKSB7XG4gIHZhciBpbnN0ID0gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtcbiAgaWYgKGluc3QpIHtcbiAgICBpZiAoaW5zdC50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgaW5zdC50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICByZXR1cm4gaW5zdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgUmVhY3RET01Db21wb25lbnQgb3IgUmVhY3RET01UZXh0Q29tcG9uZW50LCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmdcbiAqIERPTSBub2RlLlxuICovXG5mdW5jdGlvbiBnZXROb2RlRnJvbUluc3RhbmNlJDEoaW5zdCkge1xuICBpZiAoaW5zdC50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgaW5zdC50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgLy8gSW4gRmliZXIgdGhpcywgaXMganVzdCB0aGUgc3RhdGUgbm9kZSByaWdodCBub3cuIFdlIGFzc3VtZSBpdCB3aWxsIGJlXG4gICAgLy8gYSBob3N0IGNvbXBvbmVudCBvciBob3N0IHRleHQuXG4gICAgcmV0dXJuIGluc3Quc3RhdGVOb2RlO1xuICB9XG5cbiAgLy8gV2l0aG91dCB0aGlzIGZpcnN0IGludmFyaWFudCwgcGFzc2luZyBhIG5vbi1ET00tY29tcG9uZW50IHRyaWdnZXJzIHRoZSBuZXh0XG4gIC8vIGludmFyaWFudCBmb3IgYSBtaXNzaW5nIHBhcmVudCwgd2hpY2ggaXMgc3VwZXIgY29uZnVzaW5nLlxuICBpbnZhcmlhbnQoZmFsc2UsICdnZXROb2RlRnJvbUluc3RhbmNlOiBJbnZhbGlkIGFyZ3VtZW50LicpO1xufVxuXG5mdW5jdGlvbiBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlJDEobm9kZSkge1xuICByZXR1cm4gbm9kZVtpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXldIHx8IG51bGw7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUZpYmVyUHJvcHMkMShub2RlLCBwcm9wcykge1xuICBub2RlW2ludGVybmFsRXZlbnRIYW5kbGVyc0tleV0gPSBwcm9wcztcbn1cblxudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IE9iamVjdC5mcmVlemUoe1xuXHRwcmVjYWNoZUZpYmVyTm9kZTogcHJlY2FjaGVGaWJlck5vZGUkMSxcblx0Z2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGU6IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlLFxuXHRnZXRJbnN0YW5jZUZyb21Ob2RlOiBnZXRJbnN0YW5jZUZyb21Ob2RlJDEsXG5cdGdldE5vZGVGcm9tSW5zdGFuY2U6IGdldE5vZGVGcm9tSW5zdGFuY2UkMSxcblx0Z2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZTogZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSQxLFxuXHR1cGRhdGVGaWJlclByb3BzOiB1cGRhdGVGaWJlclByb3BzJDFcbn0pO1xuXG5mdW5jdGlvbiBnZXRQYXJlbnQoaW5zdCkge1xuICBkbyB7XG4gICAgaW5zdCA9IGluc3RbJ3JldHVybiddO1xuICAgIC8vIFRPRE86IElmIHRoaXMgaXMgYSBIb3N0Um9vdCB3ZSBtaWdodCB3YW50IHRvIGJhaWwgb3V0LlxuICAgIC8vIFRoYXQgaXMgZGVwZW5kaW5nIG9uIGlmIHdlIHdhbnQgbmVzdGVkIHN1YnRyZWVzIChsYXllcnMpIHRvIGJ1YmJsZVxuICAgIC8vIGV2ZW50cyB0byB0aGVpciBwYXJlbnQuIFdlIGNvdWxkIGFsc28gZ28gdGhyb3VnaCBwYXJlbnROb2RlIG9uIHRoZVxuICAgIC8vIGhvc3Qgbm9kZSBidXQgdGhhdCB3b3VsZG4ndCB3b3JrIGZvciBSZWFjdCBOYXRpdmUgYW5kIGRvZXNuJ3QgbGV0IHVzXG4gICAgLy8gZG8gdGhlIHBvcnRhbCBmZWF0dXJlLlxuICB9IHdoaWxlIChpbnN0ICYmIGluc3QudGFnICE9PSBIb3N0Q29tcG9uZW50KTtcbiAgaWYgKGluc3QpIHtcbiAgICByZXR1cm4gaW5zdDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxvd2VzdCBjb21tb24gYW5jZXN0b3Igb2YgQSBhbmQgQiwgb3IgbnVsbCBpZiB0aGV5IGFyZSBpblxuICogZGlmZmVyZW50IHRyZWVzLlxuICovXG5mdW5jdGlvbiBnZXRMb3dlc3RDb21tb25BbmNlc3RvcihpbnN0QSwgaW5zdEIpIHtcbiAgdmFyIGRlcHRoQSA9IDA7XG4gIGZvciAodmFyIHRlbXBBID0gaW5zdEE7IHRlbXBBOyB0ZW1wQSA9IGdldFBhcmVudCh0ZW1wQSkpIHtcbiAgICBkZXB0aEErKztcbiAgfVxuICB2YXIgZGVwdGhCID0gMDtcbiAgZm9yICh2YXIgdGVtcEIgPSBpbnN0QjsgdGVtcEI7IHRlbXBCID0gZ2V0UGFyZW50KHRlbXBCKSkge1xuICAgIGRlcHRoQisrO1xuICB9XG5cbiAgLy8gSWYgQSBpcyBkZWVwZXIsIGNyYXdsIHVwLlxuICB3aGlsZSAoZGVwdGhBIC0gZGVwdGhCID4gMCkge1xuICAgIGluc3RBID0gZ2V0UGFyZW50KGluc3RBKTtcbiAgICBkZXB0aEEtLTtcbiAgfVxuXG4gIC8vIElmIEIgaXMgZGVlcGVyLCBjcmF3bCB1cC5cbiAgd2hpbGUgKGRlcHRoQiAtIGRlcHRoQSA+IDApIHtcbiAgICBpbnN0QiA9IGdldFBhcmVudChpbnN0Qik7XG4gICAgZGVwdGhCLS07XG4gIH1cblxuICAvLyBXYWxrIGluIGxvY2tzdGVwIHVudGlsIHdlIGZpbmQgYSBtYXRjaC5cbiAgdmFyIGRlcHRoID0gZGVwdGhBO1xuICB3aGlsZSAoZGVwdGgtLSkge1xuICAgIGlmIChpbnN0QSA9PT0gaW5zdEIgfHwgaW5zdEEgPT09IGluc3RCLmFsdGVybmF0ZSkge1xuICAgICAgcmV0dXJuIGluc3RBO1xuICAgIH1cbiAgICBpbnN0QSA9IGdldFBhcmVudChpbnN0QSk7XG4gICAgaW5zdEIgPSBnZXRQYXJlbnQoaW5zdEIpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJldHVybiBpZiBBIGlzIGFuIGFuY2VzdG9yIG9mIEIuXG4gKi9cblxuXG4vKipcbiAqIFJldHVybiB0aGUgcGFyZW50IGluc3RhbmNlIG9mIHRoZSBwYXNzZWQtaW4gaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudEluc3RhbmNlKGluc3QpIHtcbiAgcmV0dXJuIGdldFBhcmVudChpbnN0KTtcbn1cblxuLyoqXG4gKiBTaW11bGF0ZXMgdGhlIHRyYXZlcnNhbCBvZiBhIHR3by1waGFzZSwgY2FwdHVyZS9idWJibGUgZXZlbnQgZGlzcGF0Y2guXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlVHdvUGhhc2UoaW5zdCwgZm4sIGFyZykge1xuICB2YXIgcGF0aCA9IFtdO1xuICB3aGlsZSAoaW5zdCkge1xuICAgIHBhdGgucHVzaChpbnN0KTtcbiAgICBpbnN0ID0gZ2V0UGFyZW50KGluc3QpO1xuICB9XG4gIHZhciBpO1xuICBmb3IgKGkgPSBwYXRoLmxlbmd0aDsgaS0tID4gMDspIHtcbiAgICBmbihwYXRoW2ldLCAnY2FwdHVyZWQnLCBhcmcpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4ocGF0aFtpXSwgJ2J1YmJsZWQnLCBhcmcpO1xuICB9XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIHRoZSBJRCBoaWVyYXJjaHkgYW5kIGludm9rZXMgdGhlIHN1cHBsaWVkIGBjYmAgb24gYW55IElEcyB0aGF0XG4gKiBzaG91bGQgd291bGQgcmVjZWl2ZSBhIGBtb3VzZUVudGVyYCBvciBgbW91c2VMZWF2ZWAgZXZlbnQuXG4gKlxuICogRG9lcyBub3QgaW52b2tlIHRoZSBjYWxsYmFjayBvbiB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgYmVjYXVzZSBub3RoaW5nXG4gKiBcImVudGVyZWRcIiBvciBcImxlZnRcIiB0aGF0IGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgZm4sIGFyZ0Zyb20sIGFyZ1RvKSB7XG4gIHZhciBjb21tb24gPSBmcm9tICYmIHRvID8gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoZnJvbSwgdG8pIDogbnVsbDtcbiAgdmFyIHBhdGhGcm9tID0gW107XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKCFmcm9tKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGZyb20gPT09IGNvbW1vbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBhbHRlcm5hdGUgPSBmcm9tLmFsdGVybmF0ZTtcbiAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsICYmIGFsdGVybmF0ZSA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcGF0aEZyb20ucHVzaChmcm9tKTtcbiAgICBmcm9tID0gZ2V0UGFyZW50KGZyb20pO1xuICB9XG4gIHZhciBwYXRoVG8gPSBbXTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoIXRvKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHRvID09PSBjb21tb24pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgX2FsdGVybmF0ZSA9IHRvLmFsdGVybmF0ZTtcbiAgICBpZiAoX2FsdGVybmF0ZSAhPT0gbnVsbCAmJiBfYWx0ZXJuYXRlID09PSBjb21tb24pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwYXRoVG8ucHVzaCh0byk7XG4gICAgdG8gPSBnZXRQYXJlbnQodG8pO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aEZyb20ubGVuZ3RoOyBpKyspIHtcbiAgICBmbihwYXRoRnJvbVtpXSwgJ2J1YmJsZWQnLCBhcmdGcm9tKTtcbiAgfVxuICBmb3IgKHZhciBfaSA9IHBhdGhUby5sZW5ndGg7IF9pLS0gPiAwOykge1xuICAgIGZuKHBhdGhUb1tfaV0sICdjYXB0dXJlZCcsIGFyZ1RvKTtcbiAgfVxufVxuXG4vKipcbiAqIFNvbWUgZXZlbnQgdHlwZXMgaGF2ZSBhIG5vdGlvbiBvZiBkaWZmZXJlbnQgcmVnaXN0cmF0aW9uIG5hbWVzIGZvciBkaWZmZXJlbnRcbiAqIFwicGhhc2VzXCIgb2YgcHJvcGFnYXRpb24uIFRoaXMgZmluZHMgbGlzdGVuZXJzIGJ5IGEgZ2l2ZW4gcGhhc2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RlbmVyQXRQaGFzZShpbnN0LCBldmVudCwgcHJvcGFnYXRpb25QaGFzZSkge1xuICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3Byb3BhZ2F0aW9uUGhhc2VdO1xuICByZXR1cm4gZ2V0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG59XG5cbi8qKlxuICogQSBzbWFsbCBzZXQgb2YgcHJvcGFnYXRpb24gcGF0dGVybnMsIGVhY2ggb2Ygd2hpY2ggd2lsbCBhY2NlcHQgYSBzbWFsbCBhbW91bnRcbiAqIG9mIGluZm9ybWF0aW9uLCBhbmQgZ2VuZXJhdGUgYSBzZXQgb2YgXCJkaXNwYXRjaCByZWFkeSBldmVudCBvYmplY3RzXCIgLSB3aGljaFxuICogYXJlIHNldHMgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gYW5ub3RhdGVkIHdpdGggYSBzZXQgb2YgZGlzcGF0Y2hlZFxuICogbGlzdGVuZXIgZnVuY3Rpb25zL2lkcy4gVGhlIEFQSSBpcyBkZXNpZ25lZCB0aGlzIHdheSB0byBkaXNjb3VyYWdlIHRoZXNlXG4gKiBwcm9wYWdhdGlvbiBzdHJhdGVnaWVzIGZyb20gYWN0dWFsbHkgZXhlY3V0aW5nIHRoZSBkaXNwYXRjaGVzLCBzaW5jZSB3ZVxuICogYWx3YXlzIHdhbnQgdG8gY29sbGVjdCB0aGUgZW50aXJlIHNldCBvZiBkaXNwYXRjaGVzIGJlZm9yZSBleGVjdXRpbmcgZXZlbiBhXG4gKiBzaW5nbGUgb25lLlxuICovXG5cbi8qKlxuICogVGFncyBhIGBTeW50aGV0aWNFdmVudGAgd2l0aCBkaXNwYXRjaGVkIGxpc3RlbmVycy4gQ3JlYXRpbmcgdGhpcyBmdW5jdGlvblxuICogaGVyZSwgYWxsb3dzIHVzIHRvIG5vdCBoYXZlIHRvIGJpbmQgb3IgY3JlYXRlIGZ1bmN0aW9ucyBmb3IgZWFjaCBldmVudC5cbiAqIE11dGF0aW5nIHRoZSBldmVudCdzIG1lbWJlcnMgYWxsb3dzIHVzIHRvIG5vdCBoYXZlIHRvIGNyZWF0ZSBhIHdyYXBwaW5nXG4gKiBcImRpc3BhdGNoXCIgb2JqZWN0IHRoYXQgcGFpcnMgdGhlIGV2ZW50IHdpdGggdGhlIGxpc3RlbmVyLlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzKGluc3QsIHBoYXNlLCBldmVudCkge1xuICB7XG4gICAgd2FybmluZyhpbnN0LCAnRGlzcGF0Y2hpbmcgaW5zdCBtdXN0IG5vdCBiZSBudWxsJyk7XG4gIH1cbiAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJBdFBoYXNlKGluc3QsIGV2ZW50LCBwaGFzZSk7XG4gIGlmIChsaXN0ZW5lcikge1xuICAgIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycywgbGlzdGVuZXIpO1xuICAgIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcywgaW5zdCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb2xsZWN0IGRpc3BhdGNoZXMgKG11c3QgYmUgZW50aXJlbHkgY29sbGVjdGVkIGJlZm9yZSBkaXNwYXRjaGluZyAtIHNlZSB1bml0XG4gKiB0ZXN0cykuIExhemlseSBhbGxvY2F0ZSB0aGUgYXJyYXkgdG8gY29uc2VydmUgbWVtb3J5LiAgV2UgbXVzdCBsb29wIHRocm91Z2hcbiAqIGVhY2ggZXZlbnQgYW5kIHBlcmZvcm0gdGhlIHRyYXZlcnNhbCBmb3IgZWFjaCBvbmUuIFdlIGNhbm5vdCBwZXJmb3JtIGFcbiAqIHNpbmdsZSB0cmF2ZXJzYWwgZm9yIHRoZSBlbnRpcmUgY29sbGVjdGlvbiBvZiBldmVudHMgYmVjYXVzZSBlYWNoIGV2ZW50IG1heVxuICogaGF2ZSBhIGRpZmZlcmVudCB0YXJnZXQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGUoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgdHJhdmVyc2VUd29QaGFzZShldmVudC5fdGFyZ2V0SW5zdCwgYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcywgZXZlbnQpO1xuICB9XG59XG5cbi8qKlxuICogU2FtZSBhcyBgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZWAsIGJ1dCBza2lwcyBvdmVyIHRoZSB0YXJnZXRJRC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZVNraXBUYXJnZXQoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgdmFyIHRhcmdldEluc3QgPSBldmVudC5fdGFyZ2V0SW5zdDtcbiAgICB2YXIgcGFyZW50SW5zdCA9IHRhcmdldEluc3QgPyBnZXRQYXJlbnRJbnN0YW5jZSh0YXJnZXRJbnN0KSA6IG51bGw7XG4gICAgdHJhdmVyc2VUd29QaGFzZShwYXJlbnRJbnN0LCBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzLCBldmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBY2N1bXVsYXRlcyB3aXRob3V0IHJlZ2FyZCB0byBkaXJlY3Rpb24sIGRvZXMgbm90IGxvb2sgZm9yIHBoYXNlZFxuICogcmVnaXN0cmF0aW9uIG5hbWVzLiBTYW1lIGFzIGBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZWAgYnV0IHdpdGhvdXRcbiAqIHJlcXVpcmluZyB0aGF0IHRoZSBgZGlzcGF0Y2hNYXJrZXJgIGJlIHRoZSBzYW1lIGFzIHRoZSBkaXNwYXRjaGVkIElELlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlzcGF0Y2hlcyhpbnN0LCBpZ25vcmVkRGlyZWN0aW9uLCBldmVudCkge1xuICBpZiAoaW5zdCAmJiBldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lO1xuICAgIHZhciBsaXN0ZW5lciA9IGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMsIGluc3QpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdGVzIGRpc3BhdGNoZXMgb24gYW4gYFN5bnRoZXRpY0V2ZW50YCwgYnV0IG9ubHkgZm9yIHRoZVxuICogYGRpc3BhdGNoTWFya2VyYC5cbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgYWNjdW11bGF0ZURpc3BhdGNoZXMoZXZlbnQuX3RhcmdldEluc3QsIG51bGwsIGV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbSwgdG8pIHtcbiAgdHJhdmVyc2VFbnRlckxlYXZlKGZyb20sIHRvLCBhY2N1bXVsYXRlRGlzcGF0Y2hlcywgbGVhdmUsIGVudGVyKTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXMoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKTtcbn1cblxudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSBPYmplY3QuZnJlZXplKHtcblx0YWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlczogYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyxcblx0YWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQ6IGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0LFxuXHRhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyxcblx0YWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXM6IGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzXG59KTtcblxudmFyIGNvbnRlbnRLZXkgPSBudWxsO1xuXG4vKipcbiAqIEdldHMgdGhlIGtleSB1c2VkIHRvIGFjY2VzcyB0ZXh0IGNvbnRlbnQgb24gYSBET00gbm9kZS5cbiAqXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBLZXkgdXNlZCB0byBhY2Nlc3MgdGV4dCBjb250ZW50LlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldFRleHRDb250ZW50QWNjZXNzb3IoKSB7XG4gIGlmICghY29udGVudEtleSAmJiBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgICAvLyBQcmVmZXIgdGV4dENvbnRlbnQgdG8gaW5uZXJUZXh0IGJlY2F1c2UgbWFueSBicm93c2VycyBzdXBwb3J0IGJvdGggYnV0XG4gICAgLy8gU1ZHIDx0ZXh0PiBlbGVtZW50cyBkb24ndCBzdXBwb3J0IGlubmVyVGV4dCBldmVuIHdoZW4gPGRpdj4gZG9lcy5cbiAgICBjb250ZW50S2V5ID0gJ3RleHRDb250ZW50JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgPyAndGV4dENvbnRlbnQnIDogJ2lubmVyVGV4dCc7XG4gIH1cbiAgcmV0dXJuIGNvbnRlbnRLZXk7XG59XG5cbi8qKlxuICogVGhpcyBoZWxwZXIgb2JqZWN0IHN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCB0ZXh0IGNvbnRlbnQgb2YgYSB0YXJnZXQgbm9kZSxcbiAqIGFsbG93aW5nIGNvbXBhcmlzb24gb2YgY29udGVudCBiZWZvcmUgYW5kIGFmdGVyIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogSWRlbnRpZnkgdGhlIG5vZGUgd2hlcmUgc2VsZWN0aW9uIGN1cnJlbnRseSBiZWdpbnMsIHRoZW4gb2JzZXJ2ZVxuICogYm90aCBpdHMgdGV4dCBjb250ZW50IGFuZCBpdHMgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgRE9NLiBTaW5jZSB0aGVcbiAqIGJyb3dzZXIgbWF5IG5hdGl2ZWx5IHJlcGxhY2UgdGhlIHRhcmdldCBub2RlIGR1cmluZyBjb21wb3NpdGlvbiwgd2UgY2FuXG4gKiB1c2UgaXRzIHBvc2l0aW9uIHRvIGZpbmQgaXRzIHJlcGxhY2VtZW50LlxuICpcbiAqXG4gKi9cbnZhciBjb21wb3NpdGlvblN0YXRlID0ge1xuICBfcm9vdDogbnVsbCxcbiAgX3N0YXJ0VGV4dDogbnVsbCxcbiAgX2ZhbGxiYWNrVGV4dDogbnVsbFxufTtcblxuZnVuY3Rpb24gaW5pdGlhbGl6ZShuYXRpdmVFdmVudFRhcmdldCkge1xuICBjb21wb3NpdGlvblN0YXRlLl9yb290ID0gbmF0aXZlRXZlbnRUYXJnZXQ7XG4gIGNvbXBvc2l0aW9uU3RhdGUuX3N0YXJ0VGV4dCA9IGdldFRleHQoKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlc2V0KCkge1xuICBjb21wb3NpdGlvblN0YXRlLl9yb290ID0gbnVsbDtcbiAgY29tcG9zaXRpb25TdGF0ZS5fc3RhcnRUZXh0ID0gbnVsbDtcbiAgY29tcG9zaXRpb25TdGF0ZS5fZmFsbGJhY2tUZXh0ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YSgpIHtcbiAgaWYgKGNvbXBvc2l0aW9uU3RhdGUuX2ZhbGxiYWNrVGV4dCkge1xuICAgIHJldHVybiBjb21wb3NpdGlvblN0YXRlLl9mYWxsYmFja1RleHQ7XG4gIH1cblxuICB2YXIgc3RhcnQ7XG4gIHZhciBzdGFydFZhbHVlID0gY29tcG9zaXRpb25TdGF0ZS5fc3RhcnRUZXh0O1xuICB2YXIgc3RhcnRMZW5ndGggPSBzdGFydFZhbHVlLmxlbmd0aDtcbiAgdmFyIGVuZDtcbiAgdmFyIGVuZFZhbHVlID0gZ2V0VGV4dCgpO1xuICB2YXIgZW5kTGVuZ3RoID0gZW5kVmFsdWUubGVuZ3RoO1xuXG4gIGZvciAoc3RhcnQgPSAwOyBzdGFydCA8IHN0YXJ0TGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRdICE9PSBlbmRWYWx1ZVtzdGFydF0pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBtaW5FbmQgPSBzdGFydExlbmd0aCAtIHN0YXJ0O1xuICBmb3IgKGVuZCA9IDE7IGVuZCA8PSBtaW5FbmQ7IGVuZCsrKSB7XG4gICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRMZW5ndGggLSBlbmRdICE9PSBlbmRWYWx1ZVtlbmRMZW5ndGggLSBlbmRdKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgc2xpY2VUYWlsID0gZW5kID4gMSA/IDEgLSBlbmQgOiB1bmRlZmluZWQ7XG4gIGNvbXBvc2l0aW9uU3RhdGUuX2ZhbGxiYWNrVGV4dCA9IGVuZFZhbHVlLnNsaWNlKHN0YXJ0LCBzbGljZVRhaWwpO1xuICByZXR1cm4gY29tcG9zaXRpb25TdGF0ZS5fZmFsbGJhY2tUZXh0O1xufVxuXG5mdW5jdGlvbiBnZXRUZXh0KCkge1xuICBpZiAoJ3ZhbHVlJyBpbiBjb21wb3NpdGlvblN0YXRlLl9yb290KSB7XG4gICAgcmV0dXJuIGNvbXBvc2l0aW9uU3RhdGUuX3Jvb3QudmFsdWU7XG4gIH1cbiAgcmV0dXJuIGNvbXBvc2l0aW9uU3RhdGUuX3Jvb3RbZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpXTtcbn1cblxuLyogZXNsaW50IHZhbGlkLXR5cGVvZjogMCAqL1xuXG52YXIgZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkgPSBmYWxzZTtcbnZhciBpc1Byb3h5U3VwcG9ydGVkID0gdHlwZW9mIFByb3h5ID09PSAnZnVuY3Rpb24nO1xudmFyIEVWRU5UX1BPT0xfU0laRSA9IDEwO1xuXG52YXIgc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXMgPSBbJ2Rpc3BhdGNoQ29uZmlnJywgJ190YXJnZXRJbnN0JywgJ25hdGl2ZUV2ZW50JywgJ2lzRGVmYXVsdFByZXZlbnRlZCcsICdpc1Byb3BhZ2F0aW9uU3RvcHBlZCcsICdfZGlzcGF0Y2hMaXN0ZW5lcnMnLCAnX2Rpc3BhdGNoSW5zdGFuY2VzJ107XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBFdmVudEludGVyZmFjZSA9IHtcbiAgdHlwZTogbnVsbCxcbiAgdGFyZ2V0OiBudWxsLFxuICAvLyBjdXJyZW50VGFyZ2V0IGlzIHNldCB3aGVuIGRpc3BhdGNoaW5nOyBubyB1c2UgaW4gY29weWluZyBpdCBoZXJlXG4gIGN1cnJlbnRUYXJnZXQ6IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsLFxuICBldmVudFBoYXNlOiBudWxsLFxuICBidWJibGVzOiBudWxsLFxuICBjYW5jZWxhYmxlOiBudWxsLFxuICB0aW1lU3RhbXA6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBldmVudC50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcbiAgfSxcbiAgZGVmYXVsdFByZXZlbnRlZDogbnVsbCxcbiAgaXNUcnVzdGVkOiBudWxsXG59O1xuXG4vKipcbiAqIFN5bnRoZXRpYyBldmVudHMgYXJlIGRpc3BhdGNoZWQgYnkgZXZlbnQgcGx1Z2lucywgdHlwaWNhbGx5IGluIHJlc3BvbnNlIHRvIGFcbiAqIHRvcC1sZXZlbCBldmVudCBkZWxlZ2F0aW9uIGhhbmRsZXIuXG4gKlxuICogVGhlc2Ugc3lzdGVtcyBzaG91bGQgZ2VuZXJhbGx5IHVzZSBwb29saW5nIHRvIHJlZHVjZSB0aGUgZnJlcXVlbmN5IG9mIGdhcmJhZ2VcbiAqIGNvbGxlY3Rpb24uIFRoZSBzeXN0ZW0gc2hvdWxkIGNoZWNrIGBpc1BlcnNpc3RlbnRgIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZVxuICogZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGludG8gdGhlIHBvb2wgYWZ0ZXIgYmVpbmcgZGlzcGF0Y2hlZC4gVXNlcnMgdGhhdFxuICogbmVlZCBhIHBlcnNpc3RlZCBldmVudCBzaG91bGQgaW52b2tlIGBwZXJzaXN0YC5cbiAqXG4gKiBTeW50aGV0aWMgZXZlbnRzIChhbmQgc3ViY2xhc3NlcykgaW1wbGVtZW50IHRoZSBET00gTGV2ZWwgMyBFdmVudHMgQVBJIGJ5XG4gKiBub3JtYWxpemluZyBicm93c2VyIHF1aXJrcy4gU3ViY2xhc3NlcyBkbyBub3QgbmVjZXNzYXJpbHkgaGF2ZSB0byBpbXBsZW1lbnQgYVxuICogRE9NIGludGVyZmFjZTsgY3VzdG9tIGFwcGxpY2F0aW9uLXNwZWNpZmljIGV2ZW50cyBjYW4gYWxzbyBzdWJjbGFzcyB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0SW5zdCBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IG5hdGl2ZUV2ZW50VGFyZ2V0IFRhcmdldCBub2RlLlxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNFdmVudChkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHtcbiAgICAvLyB0aGVzZSBoYXZlIGEgZ2V0dGVyL3NldHRlciBmb3Igd2FybmluZ3NcbiAgICBkZWxldGUgdGhpcy5uYXRpdmVFdmVudDtcbiAgICBkZWxldGUgdGhpcy5wcmV2ZW50RGVmYXVsdDtcbiAgICBkZWxldGUgdGhpcy5zdG9wUHJvcGFnYXRpb247XG4gIH1cblxuICB0aGlzLmRpc3BhdGNoQ29uZmlnID0gZGlzcGF0Y2hDb25maWc7XG4gIHRoaXMuX3RhcmdldEluc3QgPSB0YXJnZXRJbnN0O1xuICB0aGlzLm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG5cbiAgdmFyIEludGVyZmFjZSA9IHRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO1xuICBmb3IgKHZhciBwcm9wTmFtZSBpbiBJbnRlcmZhY2UpIHtcbiAgICBpZiAoIUludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB7XG4gICAgICBkZWxldGUgdGhpc1twcm9wTmFtZV07IC8vIHRoaXMgaGFzIGEgZ2V0dGVyL3NldHRlciBmb3Igd2FybmluZ3NcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6ZSA9IEludGVyZmFjZVtwcm9wTmFtZV07XG4gICAgaWYgKG5vcm1hbGl6ZSkge1xuICAgICAgdGhpc1twcm9wTmFtZV0gPSBub3JtYWxpemUobmF0aXZlRXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvcE5hbWUgPT09ICd0YXJnZXQnKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gbmF0aXZlRXZlbnRUYXJnZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW3Byb3BOYW1lXSA9IG5hdGl2ZUV2ZW50W3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZGVmYXVsdFByZXZlbnRlZCA9IG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgIT0gbnVsbCA/IG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgOiBuYXRpdmVFdmVudC5yZXR1cm5WYWx1ZSA9PT0gZmFsc2U7XG4gIGlmIChkZWZhdWx0UHJldmVudGVkKSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZTtcbiAgfVxuICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlO1xuICByZXR1cm4gdGhpcztcbn1cblxuX2Fzc2lnbihTeW50aGV0aWNFdmVudC5wcm90b3R5cGUsIHtcbiAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgIHZhciBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgaWYgKCFldmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBldmVudC5yZXR1cm5WYWx1ZSAhPT0gJ3Vua25vd24nKSB7XG4gICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgaWYgKCFldmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV2ZW50LmNhbmNlbEJ1YmJsZSAhPT0gJ3Vua25vd24nKSB7XG4gICAgICAvLyBUaGUgQ2hhbmdlRXZlbnRQbHVnaW4gcmVnaXN0ZXJzIGEgXCJwcm9wZXJ0eWNoYW5nZVwiIGV2ZW50IGZvclxuICAgICAgLy8gSUUuIFRoaXMgZXZlbnQgZG9lcyBub3Qgc3VwcG9ydCBidWJibGluZyBvciBjYW5jZWxsaW5nLCBhbmRcbiAgICAgIC8vIGFueSByZWZlcmVuY2VzIHRvIGNhbmNlbEJ1YmJsZSB0aHJvdyBcIk1lbWJlciBub3QgZm91bmRcIi4gIEFcbiAgICAgIC8vIHR5cGVvZiBjaGVjayBvZiBcInVua25vd25cIiBjaXJjdW12ZW50cyB0aGlzIGlzc3VlIChhbmQgaXMgYWxzb1xuICAgICAgLy8gSUUgc3BlY2lmaWMpLlxuICAgICAgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdlIHJlbGVhc2UgYWxsIGRpc3BhdGNoZWQgYFN5bnRoZXRpY0V2ZW50YHMgYWZ0ZXIgZWFjaCBldmVudCBsb29wLCBhZGRpbmdcbiAgICogdGhlbSBiYWNrIGludG8gdGhlIHBvb2wuIFRoaXMgYWxsb3dzIGEgd2F5IHRvIGhvbGQgb250byBhIHJlZmVyZW5jZSB0aGF0XG4gICAqIHdvbid0IGJlIGFkZGVkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICovXG4gIHBlcnNpc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlzUGVyc2lzdGVudCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBldmVudCBzaG91bGQgYmUgcmVsZWFzZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoaXMgc2hvdWxkIG5vdCBiZSByZWxlYXNlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNQZXJzaXN0ZW50OiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UsXG5cbiAgLyoqXG4gICAqIGBQb29sZWRDbGFzc2AgbG9va3MgZm9yIGBkZXN0cnVjdG9yYCBvbiBlYWNoIGluc3RhbmNlIGl0IHJlbGVhc2VzLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBJbnRlcmZhY2UgPSB0aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBJbnRlcmZhY2UpIHtcbiAgICAgIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIHByb3BOYW1lLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKHByb3BOYW1lLCBJbnRlcmZhY2VbcHJvcE5hbWVdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXNbc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXNbaV1dID0gbnVsbDtcbiAgICB9XG4gICAge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICduYXRpdmVFdmVudCcsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oJ25hdGl2ZUV2ZW50JywgbnVsbCkpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdwcmV2ZW50RGVmYXVsdCcsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oJ3ByZXZlbnREZWZhdWx0JywgZW1wdHlGdW5jdGlvbikpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzdG9wUHJvcGFnYXRpb24nLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCdzdG9wUHJvcGFnYXRpb24nLCBlbXB0eUZ1bmN0aW9uKSk7XG4gICAgfVxuICB9XG59KTtcblxuU3ludGhldGljRXZlbnQuSW50ZXJmYWNlID0gRXZlbnRJbnRlcmZhY2U7XG5cbi8qKlxuICogSGVscGVyIHRvIHJlZHVjZSBib2lsZXJwbGF0ZSB3aGVuIGNyZWF0aW5nIHN1YmNsYXNzZXMuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3NcbiAqIEBwYXJhbSB7P29iamVjdH0gSW50ZXJmYWNlXG4gKi9cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyA9IGZ1bmN0aW9uIChDbGFzcywgSW50ZXJmYWNlKSB7XG4gIHZhciBTdXBlciA9IHRoaXM7XG5cbiAgdmFyIEUgPSBmdW5jdGlvbiAoKSB7fTtcbiAgRS5wcm90b3R5cGUgPSBTdXBlci5wcm90b3R5cGU7XG4gIHZhciBwcm90b3R5cGUgPSBuZXcgRSgpO1xuXG4gIF9hc3NpZ24ocHJvdG90eXBlLCBDbGFzcy5wcm90b3R5cGUpO1xuICBDbGFzcy5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gIENsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENsYXNzO1xuXG4gIENsYXNzLkludGVyZmFjZSA9IF9hc3NpZ24oe30sIFN1cGVyLkludGVyZmFjZSwgSW50ZXJmYWNlKTtcbiAgQ2xhc3MuYXVnbWVudENsYXNzID0gU3VwZXIuYXVnbWVudENsYXNzO1xuICBhZGRFdmVudFBvb2xpbmdUbyhDbGFzcyk7XG59O1xuXG4vKiogUHJveHlpbmcgYWZ0ZXIgZXZlcnl0aGluZyBzZXQgb24gU3ludGhldGljRXZlbnRcbiAqIHRvIHJlc29sdmUgUHJveHkgaXNzdWUgb24gc29tZSBXZWJLaXQgYnJvd3NlcnNcbiAqIGluIHdoaWNoIHNvbWUgRXZlbnQgcHJvcGVydGllcyBhcmUgc2V0IHRvIHVuZGVmaW5lZCAoR0gjMTAwMTApXG4gKi9cbntcbiAgaWYgKGlzUHJveHlTdXBwb3J0ZWQpIHtcbiAgICAvKmVzbGludC1kaXNhYmxlIG5vLWZ1bmMtYXNzaWduICovXG4gICAgU3ludGhldGljRXZlbnQgPSBuZXcgUHJveHkoU3ludGhldGljRXZlbnQsIHtcbiAgICAgIGNvbnN0cnVjdDogZnVuY3Rpb24gKHRhcmdldCwgYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseSh0YXJnZXQsIE9iamVjdC5jcmVhdGUodGFyZ2V0LnByb3RvdHlwZSksIGFyZ3MpO1xuICAgICAgfSxcbiAgICAgIGFwcGx5OiBmdW5jdGlvbiAoY29uc3RydWN0b3IsIHRoYXQsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eShjb25zdHJ1Y3Rvci5hcHBseSh0aGF0LCBhcmdzKSwge1xuICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9wICE9PSAnaXNQZXJzaXN0ZW50JyAmJiAhdGFyZ2V0LmNvbnN0cnVjdG9yLkludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiBzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllcy5pbmRleE9mKHByb3ApID09PSAtMSkge1xuICAgICAgICAgICAgICB3YXJuaW5nKGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5IHx8IHRhcmdldC5pc1BlcnNpc3RlbnQoKSwgXCJUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdSdyZSBcIiArIFwic2VlaW5nIHRoaXMsIHlvdSdyZSBhZGRpbmcgYSBuZXcgcHJvcGVydHkgaW4gdGhlIHN5bnRoZXRpYyBldmVudCBvYmplY3QuIFwiICsgJ1RoZSBwcm9wZXJ0eSBpcyBuZXZlciByZWxlYXNlZC4gU2VlICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1ldmVudC1wb29saW5nIGZvciBtb3JlIGluZm9ybWF0aW9uLicpO1xuICAgICAgICAgICAgICBkaWRXYXJuRm9yQWRkZWROZXdQcm9wZXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLyplc2xpbnQtZW5hYmxlIG5vLWZ1bmMtYXNzaWduICovXG4gIH1cbn1cblxuYWRkRXZlbnRQb29saW5nVG8oU3ludGhldGljRXZlbnQpO1xuXG4vKipcbiAqIEhlbHBlciB0byBudWxsaWZ5IHN5bnRoZXRpY0V2ZW50IGluc3RhbmNlIHByb3BlcnRpZXMgd2hlbiBkZXN0cnVjdGluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wTmFtZVxuICogQHBhcmFtIHs/b2JqZWN0fSBnZXRWYWxcbiAqIEByZXR1cm4ge29iamVjdH0gZGVmaW5lUHJvcGVydHkgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24ocHJvcE5hbWUsIGdldFZhbCkge1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBnZXRWYWwgPT09ICdmdW5jdGlvbic7XG4gIHJldHVybiB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHNldDogc2V0LFxuICAgIGdldDogZ2V0XG4gIH07XG5cbiAgZnVuY3Rpb24gc2V0KHZhbCkge1xuICAgIHZhciBhY3Rpb24gPSBpc0Z1bmN0aW9uID8gJ3NldHRpbmcgdGhlIG1ldGhvZCcgOiAnc2V0dGluZyB0aGUgcHJvcGVydHknO1xuICAgIHdhcm4oYWN0aW9uLCAnVGhpcyBpcyBlZmZlY3RpdmVseSBhIG5vLW9wJyk7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldCgpIHtcbiAgICB2YXIgYWN0aW9uID0gaXNGdW5jdGlvbiA/ICdhY2Nlc3NpbmcgdGhlIG1ldGhvZCcgOiAnYWNjZXNzaW5nIHRoZSBwcm9wZXJ0eSc7XG4gICAgdmFyIHJlc3VsdCA9IGlzRnVuY3Rpb24gPyAnVGhpcyBpcyBhIG5vLW9wIGZ1bmN0aW9uJyA6ICdUaGlzIGlzIHNldCB0byBudWxsJztcbiAgICB3YXJuKGFjdGlvbiwgcmVzdWx0KTtcbiAgICByZXR1cm4gZ2V0VmFsO1xuICB9XG5cbiAgZnVuY3Rpb24gd2FybihhY3Rpb24sIHJlc3VsdCkge1xuICAgIHZhciB3YXJuaW5nQ29uZGl0aW9uID0gZmFsc2U7XG4gICAgd2FybmluZyh3YXJuaW5nQ29uZGl0aW9uLCBcIlRoaXMgc3ludGhldGljIGV2ZW50IGlzIHJldXNlZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gSWYgeW91J3JlIHNlZWluZyB0aGlzLCBcIiArIFwieW91J3JlICVzIGAlc2Agb24gYSByZWxlYXNlZC9udWxsaWZpZWQgc3ludGhldGljIGV2ZW50LiAlcy4gXCIgKyAnSWYgeW91IG11c3Qga2VlcCB0aGUgb3JpZ2luYWwgc3ludGhldGljIGV2ZW50IGFyb3VuZCwgdXNlIGV2ZW50LnBlcnNpc3QoKS4gJyArICdTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1ldmVudC1wb29saW5nIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGFjdGlvbiwgcHJvcE5hbWUsIHJlc3VsdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UG9vbGVkRXZlbnQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVJbnN0KSB7XG4gIHZhciBFdmVudENvbnN0cnVjdG9yID0gdGhpcztcbiAgaWYgKEV2ZW50Q29uc3RydWN0b3IuZXZlbnRQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEV2ZW50Q29uc3RydWN0b3IuZXZlbnRQb29sLnBvcCgpO1xuICAgIEV2ZW50Q29uc3RydWN0b3IuY2FsbChpbnN0YW5jZSwgZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVJbnN0KTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cbiAgcmV0dXJuIG5ldyBFdmVudENvbnN0cnVjdG9yKGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlSW5zdCk7XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2VQb29sZWRFdmVudChldmVudCkge1xuICB2YXIgRXZlbnRDb25zdHJ1Y3RvciA9IHRoaXM7XG4gICEoZXZlbnQgaW5zdGFuY2VvZiBFdmVudENvbnN0cnVjdG9yKSA/IGludmFyaWFudChmYWxzZSwgJ1RyeWluZyB0byByZWxlYXNlIGFuIGV2ZW50IGluc3RhbmNlICBpbnRvIGEgcG9vbCBvZiBhIGRpZmZlcmVudCB0eXBlLicpIDogdm9pZCAwO1xuICBldmVudC5kZXN0cnVjdG9yKCk7XG4gIGlmIChFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbC5sZW5ndGggPCBFVkVOVF9QT09MX1NJWkUpIHtcbiAgICBFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbC5wdXNoKGV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRFdmVudFBvb2xpbmdUbyhFdmVudENvbnN0cnVjdG9yKSB7XG4gIEV2ZW50Q29uc3RydWN0b3IuZXZlbnRQb29sID0gW107XG4gIEV2ZW50Q29uc3RydWN0b3IuZ2V0UG9vbGVkID0gZ2V0UG9vbGVkRXZlbnQ7XG4gIEV2ZW50Q29uc3RydWN0b3IucmVsZWFzZSA9IHJlbGVhc2VQb29sZWRFdmVudDtcbn1cblxudmFyIFN5bnRoZXRpY0V2ZW50JDEgPSBTeW50aGV0aWNFdmVudDtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWNvbXBvc2l0aW9uZXZlbnRzXG4gKi9cbnZhciBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQ29tcG9zaXRpb25FdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQkMS5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQkMS5hdWdtZW50Q2xhc3MoU3ludGhldGljQ29tcG9zaXRpb25FdmVudCwgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNVxuICogICAgICAvI2V2ZW50cy1pbnB1dGV2ZW50c1xuICovXG52YXIgSW5wdXRFdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0lucHV0RXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50JDEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50JDEuYXVnbWVudENsYXNzKFN5bnRoZXRpY0lucHV0RXZlbnQsIElucHV0RXZlbnRJbnRlcmZhY2UpO1xuXG52YXIgRU5EX0tFWUNPREVTID0gWzksIDEzLCAyNywgMzJdOyAvLyBUYWIsIFJldHVybiwgRXNjLCBTcGFjZVxudmFyIFNUQVJUX0tFWUNPREUgPSAyMjk7XG5cbnZhciBjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdDb21wb3NpdGlvbkV2ZW50JyBpbiB3aW5kb3c7XG5cbnZhciBkb2N1bWVudE1vZGUgPSBudWxsO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkge1xuICBkb2N1bWVudE1vZGUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGU7XG59XG5cbi8vIFdlYmtpdCBvZmZlcnMgYSB2ZXJ5IHVzZWZ1bCBgdGV4dElucHV0YCBldmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvXG4vLyBkaXJlY3RseSByZXByZXNlbnQgYGJlZm9yZUlucHV0YC4gVGhlIElFIGB0ZXh0aW5wdXRgIGV2ZW50IGlzIG5vdCBhc1xuLy8gdXNlZnVsLCBzbyB3ZSBkb24ndCB1c2UgaXQuXG52YXIgY2FuVXNlVGV4dElucHV0RXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ1RleHRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGUgJiYgIWlzUHJlc3RvKCk7XG5cbi8vIEluIElFOSssIHdlIGhhdmUgYWNjZXNzIHRvIGNvbXBvc2l0aW9uIGV2ZW50cywgYnV0IHRoZSBkYXRhIHN1cHBsaWVkXG4vLyBieSB0aGUgbmF0aXZlIGNvbXBvc2l0aW9uZW5kIGV2ZW50IG1heSBiZSBpbmNvcnJlY3QuIEphcGFuZXNlIGlkZW9ncmFwaGljXG4vLyBzcGFjZXMsIGZvciBpbnN0YW5jZSAoXFx1MzAwMCkgYXJlIG5vdCByZWNvcmRlZCBjb3JyZWN0bHkuXG52YXIgdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgKCFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50IHx8IGRvY3VtZW50TW9kZSAmJiBkb2N1bWVudE1vZGUgPiA4ICYmIGRvY3VtZW50TW9kZSA8PSAxMSk7XG5cbi8qKlxuICogT3BlcmEgPD0gMTIgaW5jbHVkZXMgVGV4dEV2ZW50IGluIHdpbmRvdywgYnV0IGRvZXMgbm90IGZpcmVcbiAqIHRleHQgaW5wdXQgZXZlbnRzLiBSZWx5IG9uIGtleXByZXNzIGluc3RlYWQuXG4gKi9cbmZ1bmN0aW9uIGlzUHJlc3RvKCkge1xuICB2YXIgb3BlcmEgPSB3aW5kb3cub3BlcmE7XG4gIHJldHVybiB0eXBlb2Ygb3BlcmEgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvcGVyYS52ZXJzaW9uID09PSAnZnVuY3Rpb24nICYmIHBhcnNlSW50KG9wZXJhLnZlcnNpb24oKSwgMTApIDw9IDEyO1xufVxuXG52YXIgU1BBQ0VCQVJfQ09ERSA9IDMyO1xudmFyIFNQQUNFQkFSX0NIQVIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFNQQUNFQkFSX0NPREUpO1xuXG4vLyBFdmVudHMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgbmFtZXMuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgYmVmb3JlSW5wdXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQmVmb3JlSW5wdXQnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkJlZm9yZUlucHV0Q2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BDb21wb3NpdGlvbkVuZCcsICd0b3BLZXlQcmVzcycsICd0b3BUZXh0SW5wdXQnLCAndG9wUGFzdGUnXVxuICB9LFxuICBjb21wb3NpdGlvbkVuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25Db21wb3NpdGlvbkVuZCcsXG4gICAgICBjYXB0dXJlZDogJ29uQ29tcG9zaXRpb25FbmRDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ29tcG9zaXRpb25FbmQnLCAndG9wS2V5RG93bicsICd0b3BLZXlQcmVzcycsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nXVxuICB9LFxuICBjb21wb3NpdGlvblN0YXJ0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNvbXBvc2l0aW9uU3RhcnQnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uU3RhcnRDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ29tcG9zaXRpb25TdGFydCcsICd0b3BLZXlEb3duJywgJ3RvcEtleVByZXNzJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93biddXG4gIH0sXG4gIGNvbXBvc2l0aW9uVXBkYXRlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNvbXBvc2l0aW9uVXBkYXRlJyxcbiAgICAgIGNhcHR1cmVkOiAnb25Db21wb3NpdGlvblVwZGF0ZUNhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDb21wb3NpdGlvblVwZGF0ZScsICd0b3BLZXlEb3duJywgJ3RvcEtleVByZXNzJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93biddXG4gIH1cbn07XG5cbi8vIFRyYWNrIHdoZXRoZXIgd2UndmUgZXZlciBoYW5kbGVkIGEga2V5cHJlc3Mgb24gdGhlIHNwYWNlIGtleS5cbnZhciBoYXNTcGFjZUtleXByZXNzID0gZmFsc2U7XG5cbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgYSBuYXRpdmUga2V5cHJlc3MgZXZlbnQgaXMgYXNzdW1lZCB0byBiZSBhIGNvbW1hbmQuXG4gKiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgRmlyZWZveCBmaXJlcyBga2V5cHJlc3NgIGV2ZW50cyBmb3Iga2V5IGNvbW1hbmRzXG4gKiAoY3V0LCBjb3B5LCBzZWxlY3QtYWxsLCBldGMuKSBldmVuIHRob3VnaCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiAobmF0aXZlRXZlbnQuY3RybEtleSB8fCBuYXRpdmVFdmVudC5hbHRLZXkgfHwgbmF0aXZlRXZlbnQubWV0YUtleSkgJiZcbiAgLy8gY3RybEtleSAmJiBhbHRLZXkgaXMgZXF1aXZhbGVudCB0byBBbHRHciwgYW5kIGlzIG5vdCBhIGNvbW1hbmQuXG4gICEobmF0aXZlRXZlbnQuY3RybEtleSAmJiBuYXRpdmVFdmVudC5hbHRLZXkpO1xufVxuXG4vKipcbiAqIFRyYW5zbGF0ZSBuYXRpdmUgdG9wIGxldmVsIGV2ZW50cyBpbnRvIGV2ZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUodG9wTGV2ZWxUeXBlKSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25TdGFydCc6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0O1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uRW5kJzpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kO1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uVXBkYXRlJzpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uVXBkYXRlO1xuICB9XG59XG5cbi8qKlxuICogRG9lcyBvdXIgZmFsbGJhY2sgYmVzdC1ndWVzcyBtb2RlbCB0aGluayB0aGlzIGV2ZW50IHNpZ25pZmllcyB0aGF0XG4gKiBjb21wb3NpdGlvbiBoYXMgYmVndW4/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09ICd0b3BLZXlEb3duJyAmJiBuYXRpdmVFdmVudC5rZXlDb2RlID09PSBTVEFSVF9LRVlDT0RFO1xufVxuXG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIG1vZGUgdGhpbmsgdGhhdCB0aGlzIGV2ZW50IGlzIHRoZSBlbmQgb2YgY29tcG9zaXRpb24/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgJ3RvcEtleVVwJzpcbiAgICAgIC8vIENvbW1hbmQga2V5cyBpbnNlcnQgb3IgY2xlYXIgSU1FIGlucHV0LlxuICAgICAgcmV0dXJuIEVORF9LRVlDT0RFUy5pbmRleE9mKG5hdGl2ZUV2ZW50LmtleUNvZGUpICE9PSAtMTtcbiAgICBjYXNlICd0b3BLZXlEb3duJzpcbiAgICAgIC8vIEV4cGVjdCBJTUUga2V5Q29kZSBvbiBlYWNoIGtleWRvd24uIElmIHdlIGdldCBhbnkgb3RoZXJcbiAgICAgIC8vIGNvZGUgd2UgbXVzdCBoYXZlIGV4aXRlZCBlYXJsaWVyLlxuICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmtleUNvZGUgIT09IFNUQVJUX0tFWUNPREU7XG4gICAgY2FzZSAndG9wS2V5UHJlc3MnOlxuICAgIGNhc2UgJ3RvcE1vdXNlRG93bic6XG4gICAgY2FzZSAndG9wQmx1cic6XG4gICAgICAvLyBFdmVudHMgYXJlIG5vdCBwb3NzaWJsZSB3aXRob3V0IGNhbmNlbGxpbmcgSU1FLlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEdvb2dsZSBJbnB1dCBUb29scyBwcm92aWRlcyBjb21wb3NpdGlvbiBkYXRhIHZpYSBhIEN1c3RvbUV2ZW50LFxuICogd2l0aCB0aGUgYGRhdGFgIHByb3BlcnR5IHBvcHVsYXRlZCBpbiB0aGUgYGRldGFpbGAgb2JqZWN0LiBJZiB0aGlzXG4gKiBpcyBhdmFpbGFibGUgb24gdGhlIGV2ZW50IG9iamVjdCwgdXNlIGl0LiBJZiBub3QsIHRoaXMgaXMgYSBwbGFpblxuICogY29tcG9zaXRpb24gZXZlbnQgYW5kIHdlIGhhdmUgbm90aGluZyBzcGVjaWFsIHRvIGV4dHJhY3QuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBkZXRhaWwgPSBuYXRpdmVFdmVudC5kZXRhaWw7XG4gIGlmICh0eXBlb2YgZGV0YWlsID09PSAnb2JqZWN0JyAmJiAnZGF0YScgaW4gZGV0YWlsKSB7XG4gICAgcmV0dXJuIGRldGFpbC5kYXRhO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBUcmFjayB0aGUgY3VycmVudCBJTUUgY29tcG9zaXRpb24gc3RhdHVzLCBpZiBhbnkuXG52YXIgaXNDb21wb3NpbmcgPSBmYWxzZTtcblxuLyoqXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RDb21wb3NpdGlvbkV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBldmVudFR5cGU7XG4gIHZhciBmYWxsYmFja0RhdGE7XG5cbiAgaWYgKGNhblVzZUNvbXBvc2l0aW9uRXZlbnQpIHtcbiAgICBldmVudFR5cGUgPSBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSh0b3BMZXZlbFR5cGUpO1xuICB9IGVsc2UgaWYgKCFpc0NvbXBvc2luZykge1xuICAgIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICBldmVudFR5cGUgPSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kO1xuICB9XG5cbiAgaWYgKCFldmVudFR5cGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSkge1xuICAgIC8vIFRoZSBjdXJyZW50IGNvbXBvc2l0aW9uIGlzIHN0b3JlZCBzdGF0aWNhbGx5IGFuZCBtdXN0IG5vdCBiZVxuICAgIC8vIG92ZXJ3cml0dGVuIHdoaWxlIGNvbXBvc2l0aW9uIGNvbnRpbnVlcy5cbiAgICBpZiAoIWlzQ29tcG9zaW5nICYmIGV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0KSB7XG4gICAgICBpc0NvbXBvc2luZyA9IGluaXRpYWxpemUobmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kKSB7XG4gICAgICBpZiAoaXNDb21wb3NpbmcpIHtcbiAgICAgICAgZmFsbGJhY2tEYXRhID0gZ2V0RGF0YSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICBpZiAoZmFsbGJhY2tEYXRhKSB7XG4gICAgLy8gSW5qZWN0IGRhdGEgZ2VuZXJhdGVkIGZyb20gZmFsbGJhY2sgcGF0aCBpbnRvIHRoZSBzeW50aGV0aWMgZXZlbnQuXG4gICAgLy8gVGhpcyBtYXRjaGVzIHRoZSBwcm9wZXJ0eSBvZiBuYXRpdmUgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZS5cbiAgICBldmVudC5kYXRhID0gZmFsbGJhY2tEYXRhO1xuICB9IGVsc2Uge1xuICAgIHZhciBjdXN0b21EYXRhID0gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7XG4gICAgaWYgKGN1c3RvbURhdGEgIT09IG51bGwpIHtcbiAgICAgIGV2ZW50LmRhdGEgPSBjdXN0b21EYXRhO1xuICAgIH1cbiAgfVxuXG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUb3BMZXZlbFR5cGVzfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEJyb3dzZXJFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBUaGUgc3RyaW5nIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBgYmVmb3JlSW5wdXRgIGV2ZW50LlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvbkVuZCc6XG4gICAgICByZXR1cm4gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7XG4gICAgY2FzZSAndG9wS2V5UHJlc3MnOlxuICAgICAgLyoqXG4gICAgICAgKiBJZiBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRzIGFyZSBhdmFpbGFibGUsIG91ciBnb2FsIGlzIHRvIG1ha2VcbiAgICAgICAqIHVzZSBvZiB0aGVtLiBIb3dldmVyLCB0aGVyZSBpcyBhIHNwZWNpYWwgY2FzZTogdGhlIHNwYWNlYmFyIGtleS5cbiAgICAgICAqIEluIFdlYmtpdCwgcHJldmVudGluZyBkZWZhdWx0IG9uIGEgc3BhY2ViYXIgYHRleHRJbnB1dGAgZXZlbnRcbiAgICAgICAqIGNhbmNlbHMgY2hhcmFjdGVyIGluc2VydGlvbiwgYnV0IGl0ICphbHNvKiBjYXVzZXMgdGhlIGJyb3dzZXJcbiAgICAgICAqIHRvIGZhbGwgYmFjayB0byBpdHMgZGVmYXVsdCBzcGFjZWJhciBiZWhhdmlvciBvZiBzY3JvbGxpbmcgdGhlXG4gICAgICAgKiBwYWdlLlxuICAgICAgICpcbiAgICAgICAqIFRyYWNraW5nIGF0OlxuICAgICAgICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM1NTEwM1xuICAgICAgICpcbiAgICAgICAqIFRvIGF2b2lkIHRoaXMgaXNzdWUsIHVzZSB0aGUga2V5cHJlc3MgZXZlbnQgYXMgaWYgbm8gYHRleHRJbnB1dGBcbiAgICAgICAqIGV2ZW50IGlzIGF2YWlsYWJsZS5cbiAgICAgICAqL1xuICAgICAgdmFyIHdoaWNoID0gbmF0aXZlRXZlbnQud2hpY2g7XG4gICAgICBpZiAod2hpY2ggIT09IFNQQUNFQkFSX0NPREUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGhhc1NwYWNlS2V5cHJlc3MgPSB0cnVlO1xuICAgICAgcmV0dXJuIFNQQUNFQkFSX0NIQVI7XG5cbiAgICBjYXNlICd0b3BUZXh0SW5wdXQnOlxuICAgICAgLy8gUmVjb3JkIHRoZSBjaGFyYWN0ZXJzIHRvIGJlIGFkZGVkIHRvIHRoZSBET00uXG4gICAgICB2YXIgY2hhcnMgPSBuYXRpdmVFdmVudC5kYXRhO1xuXG4gICAgICAvLyBJZiBpdCdzIGEgc3BhY2ViYXIgY2hhcmFjdGVyLCBhc3N1bWUgdGhhdCB3ZSBoYXZlIGFscmVhZHkgaGFuZGxlZFxuICAgICAgLy8gaXQgYXQgdGhlIGtleXByZXNzIGxldmVsIGFuZCBiYWlsIGltbWVkaWF0ZWx5LiBBbmRyb2lkIENocm9tZVxuICAgICAgLy8gZG9lc24ndCBnaXZlIHVzIGtleWNvZGVzLCBzbyB3ZSBuZWVkIHRvIGJsYWNrbGlzdCBpdC5cbiAgICAgIGlmIChjaGFycyA9PT0gU1BBQ0VCQVJfQ0hBUiAmJiBoYXNTcGFjZUtleXByZXNzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hhcnM7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gRm9yIG90aGVyIG5hdGl2ZSBldmVudCB0eXBlcywgZG8gbm90aGluZy5cbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRm9yIGJyb3dzZXJzIHRoYXQgZG8gbm90IHByb3ZpZGUgdGhlIGB0ZXh0SW5wdXRgIGV2ZW50LCBleHRyYWN0IHRoZVxuICogYXBwcm9wcmlhdGUgc3RyaW5nIHRvIHVzZSBmb3IgU3ludGhldGljSW5wdXRFdmVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBCcm93c2VyRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gVGhlIGZhbGxiYWNrIHN0cmluZyBmb3IgdGhpcyBgYmVmb3JlSW5wdXRgIGV2ZW50LlxuICovXG5mdW5jdGlvbiBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGNvbXBvc2luZyAoSU1FKSBhbmQgdXNpbmcgYSBmYWxsYmFjayB0byBkbyBzbyxcbiAgLy8gdHJ5IHRvIGV4dHJhY3QgdGhlIGNvbXBvc2VkIGNoYXJhY3RlcnMgZnJvbSB0aGUgZmFsbGJhY2sgb2JqZWN0LlxuICAvLyBJZiBjb21wb3NpdGlvbiBldmVudCBpcyBhdmFpbGFibGUsIHdlIGV4dHJhY3QgYSBzdHJpbmcgb25seSBhdFxuICAvLyBjb21wb3NpdGlvbmV2ZW50LCBvdGhlcndpc2UgZXh0cmFjdCBpdCBhdCBmYWxsYmFjayBldmVudHMuXG4gIGlmIChpc0NvbXBvc2luZykge1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BDb21wb3NpdGlvbkVuZCcgfHwgIWNhblVzZUNvbXBvc2l0aW9uRXZlbnQgJiYgaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgICB2YXIgY2hhcnMgPSBnZXREYXRhKCk7XG4gICAgICByZXNldCgpO1xuICAgICAgaXNDb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybiBjaGFycztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgJ3RvcFBhc3RlJzpcbiAgICAgIC8vIElmIGEgcGFzdGUgZXZlbnQgb2NjdXJzIGFmdGVyIGEga2V5cHJlc3MsIHRocm93IG91dCB0aGUgaW5wdXRcbiAgICAgIC8vIGNoYXJzLiBQYXN0ZSBldmVudHMgc2hvdWxkIG5vdCBsZWFkIHRvIEJlZm9yZUlucHV0IGV2ZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICAgIC8qKlxuICAgICAgICogQXMgb2YgdjI3LCBGaXJlZm94IG1heSBmaXJlIGtleXByZXNzIGV2ZW50cyBldmVuIHdoZW4gbm8gY2hhcmFjdGVyXG4gICAgICAgKiB3aWxsIGJlIGluc2VydGVkLiBBIGZldyBwb3NzaWJpbGl0aWVzOlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyBgMGAuIEFycm93IGtleXMsIEVzYyBrZXksIGV0Yy5cbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgdGhlIHByZXNzZWQga2V5IGNvZGUsIGJ1dCBubyBjaGFyIGlzIGF2YWlsYWJsZS5cbiAgICAgICAqICAgRXg6ICdBbHRHciArIGRgIGluIFBvbGlzaC4gVGhlcmUgaXMgbm8gbW9kaWZpZWQgY2hhcmFjdGVyIGZvclxuICAgICAgICogICB0aGlzIGtleSBjb21iaW5hdGlvbiBhbmQgbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkIGludG8gdGhlXG4gICAgICAgKiAgIGRvY3VtZW50LCBidXQgRkYgZmlyZXMgdGhlIGtleXByZXNzIGZvciBjaGFyIGNvZGUgYDEwMGAgYW55d2F5LlxuICAgICAgICogICBObyBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgYSBjb21tYW5kIGNvbWJpbmF0aW9uIGlzXG4gICAgICAgKiAgIGJlaW5nIHVzZWQuIEV4OiBgQ21kK0NgLiBObyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQsIGFuZCBub1xuICAgICAgICogICBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgKi9cbiAgICAgIGlmICghaXNLZXlwcmVzc0NvbW1hbmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgIC8vIElFIGZpcmVzIHRoZSBga2V5cHJlc3NgIGV2ZW50IHdoZW4gYSB1c2VyIHR5cGVzIGFuIGVtb2ppIHZpYVxuICAgICAgICAvLyBUb3VjaCBrZXlib2FyZCBvZiBXaW5kb3dzLiAgSW4gc3VjaCBhIGNhc2UsIHRoZSBgY2hhcmAgcHJvcGVydHlcbiAgICAgICAgLy8gaG9sZHMgYW4gZW1vamkgY2hhcmFjdGVyIGxpa2UgYFxcdUQ4M0RcXHVERTBBYC4gIEJlY2F1c2UgaXRzIGxlbmd0aFxuICAgICAgICAvLyBpcyAyLCB0aGUgcHJvcGVydHkgYHdoaWNoYCBkb2VzIG5vdCByZXByZXNlbnQgYW4gZW1vamkgY29ycmVjdGx5LlxuICAgICAgICAvLyBJbiBzdWNoIGEgY2FzZSwgd2UgZGlyZWN0bHkgcmV0dXJuIHRoZSBgY2hhcmAgcHJvcGVydHkgaW5zdGVhZCBvZlxuICAgICAgICAvLyB1c2luZyBgd2hpY2hgLlxuICAgICAgICBpZiAobmF0aXZlRXZlbnQuY2hhciAmJiBuYXRpdmVFdmVudC5jaGFyLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICByZXR1cm4gbmF0aXZlRXZlbnQuY2hhcjtcbiAgICAgICAgfSBlbHNlIGlmIChuYXRpdmVFdmVudC53aGljaCkge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG5hdGl2ZUV2ZW50LndoaWNoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25FbmQnOlxuICAgICAgcmV0dXJuIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhID8gbnVsbCA6IG5hdGl2ZUV2ZW50LmRhdGE7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRXh0cmFjdCBhIFN5bnRoZXRpY0lucHV0RXZlbnQgZm9yIGBiZWZvcmVJbnB1dGAsIGJhc2VkIG9uIGVpdGhlciBuYXRpdmVcbiAqIGB0ZXh0SW5wdXRgIG9yIGZhbGxiYWNrIGJlaGF2aW9yLlxuICpcbiAqIEByZXR1cm4gez9vYmplY3R9IEEgU3ludGhldGljSW5wdXRFdmVudC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGNoYXJzO1xuXG4gIGlmIChjYW5Vc2VUZXh0SW5wdXRFdmVudCkge1xuICAgIGNoYXJzID0gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBjaGFycyA9IGdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcbiAgfVxuXG4gIC8vIElmIG5vIGNoYXJhY3RlcnMgYXJlIGJlaW5nIGluc2VydGVkLCBubyBCZWZvcmVJbnB1dCBldmVudCBzaG91bGRcbiAgLy8gYmUgZmlyZWQuXG4gIGlmICghY2hhcnMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0lucHV0RXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMuYmVmb3JlSW5wdXQsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgZXZlbnQuZGF0YSA9IGNoYXJzO1xuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBgb25CZWZvcmVJbnB1dGAgZXZlbnQgdG8gbWF0Y2hcbiAqIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMTMxMTA1LyNldmVudHMtaW5wdXRldmVudHMuXG4gKlxuICogVGhpcyBldmVudCBwbHVnaW4gaXMgYmFzZWQgb24gdGhlIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudFxuICogYXZhaWxhYmxlIGluIENocm9tZSwgU2FmYXJpLCBPcGVyYSwgYW5kIElFLiBUaGlzIGV2ZW50IGZpcmVzIGFmdGVyXG4gKiBgb25LZXlQcmVzc2AgYW5kIGBvbkNvbXBvc2l0aW9uRW5kYCwgYnV0IGJlZm9yZSBgb25JbnB1dGAuXG4gKlxuICogYGJlZm9yZUlucHV0YCBpcyBzcGVjJ2QgYnV0IG5vdCBpbXBsZW1lbnRlZCBpbiBhbnkgYnJvd3NlcnMsIGFuZFxuICogdGhlIGBpbnB1dGAgZXZlbnQgZG9lcyBub3QgcHJvdmlkZSBhbnkgdXNlZnVsIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgaGFzXG4gKiBhY3R1YWxseSBiZWVuIGFkZGVkLCBjb250cmFyeSB0byB0aGUgc3BlYy4gVGh1cywgYHRleHRJbnB1dGAgaXMgdGhlIGJlc3RcbiAqIGF2YWlsYWJsZSBldmVudCB0byBpZGVudGlmeSB0aGUgY2hhcmFjdGVycyB0aGF0IGhhdmUgYWN0dWFsbHkgYmVlbiBpbnNlcnRlZFxuICogaW50byB0aGUgdGFyZ2V0IG5vZGUuXG4gKlxuICogVGhpcyBwbHVnaW4gaXMgYWxzbyByZXNwb25zaWJsZSBmb3IgZW1pdHRpbmcgYGNvbXBvc2l0aW9uYCBldmVudHMsIHRodXNcbiAqIGFsbG93aW5nIHVzIHRvIHNoYXJlIGNvbXBvc2l0aW9uIGZhbGxiYWNrIGNvZGUgZm9yIGJvdGggYGJlZm9yZUlucHV0YCBhbmRcbiAqIGBjb21wb3NpdGlvbmAgZXZlbnQgdHlwZXMuXG4gKi9cbnZhciBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luID0ge1xuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHJldHVybiBbZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpLCBleHRyYWN0QmVmb3JlSW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCldO1xuICB9XG59O1xuXG4vLyBVc2UgdG8gcmVzdG9yZSBjb250cm9sbGVkIHN0YXRlIGFmdGVyIGEgY2hhbmdlIGV2ZW50IGhhcyBmaXJlZC5cblxudmFyIGZpYmVySG9zdENvbXBvbmVudCA9IG51bGw7XG5cbnZhciBSZWFjdENvbnRyb2xsZWRDb21wb25lbnRJbmplY3Rpb24gPSB7XG4gIGluamVjdEZpYmVyQ29udHJvbGxlZEhvc3RDb21wb25lbnQ6IGZ1bmN0aW9uIChob3N0Q29tcG9uZW50SW1wbCkge1xuICAgIC8vIFRoZSBmaWJlciBpbXBsZW1lbnRhdGlvbiBkb2Vzbid0IHVzZSBkeW5hbWljIGRpc3BhdGNoIHNvIHdlIG5lZWQgdG9cbiAgICAvLyBpbmplY3QgdGhlIGltcGxlbWVudGF0aW9uLlxuICAgIGZpYmVySG9zdENvbXBvbmVudCA9IGhvc3RDb21wb25lbnRJbXBsO1xuICB9XG59O1xuXG52YXIgcmVzdG9yZVRhcmdldCA9IG51bGw7XG52YXIgcmVzdG9yZVF1ZXVlID0gbnVsbDtcblxuZnVuY3Rpb24gcmVzdG9yZVN0YXRlT2ZUYXJnZXQodGFyZ2V0KSB7XG4gIC8vIFdlIHBlcmZvcm0gdGhpcyB0cmFuc2xhdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBldmVudCBsb29wIHNvIHRoYXQgd2VcbiAgLy8gYWx3YXlzIHJlY2VpdmUgdGhlIGNvcnJlY3QgZmliZXIgaGVyZVxuICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEluc3RhbmNlRnJvbU5vZGUodGFyZ2V0KTtcbiAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgLy8gVW5tb3VudGVkXG4gICAgcmV0dXJuO1xuICB9XG4gICEoZmliZXJIb3N0Q29tcG9uZW50ICYmIHR5cGVvZiBmaWJlckhvc3RDb21wb25lbnQucmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdGaWJlciBuZWVkcyB0byBiZSBpbmplY3RlZCB0byBoYW5kbGUgYSBmaWJlciB0YXJnZXQgZm9yIGNvbnRyb2xsZWQgZXZlbnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICB2YXIgcHJvcHMgPSBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlKGludGVybmFsSW5zdGFuY2Uuc3RhdGVOb2RlKTtcbiAgZmliZXJIb3N0Q29tcG9uZW50LnJlc3RvcmVDb250cm9sbGVkU3RhdGUoaW50ZXJuYWxJbnN0YW5jZS5zdGF0ZU5vZGUsIGludGVybmFsSW5zdGFuY2UudHlwZSwgcHJvcHMpO1xufVxuXG52YXIgaW5qZWN0aW9uJDMgPSBSZWFjdENvbnRyb2xsZWRDb21wb25lbnRJbmplY3Rpb247XG5cbmZ1bmN0aW9uIGVucXVldWVTdGF0ZVJlc3RvcmUodGFyZ2V0KSB7XG4gIGlmIChyZXN0b3JlVGFyZ2V0KSB7XG4gICAgaWYgKHJlc3RvcmVRdWV1ZSkge1xuICAgICAgcmVzdG9yZVF1ZXVlLnB1c2godGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdG9yZVF1ZXVlID0gW3RhcmdldF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlc3RvcmVUYXJnZXQgPSB0YXJnZXQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZVN0YXRlSWZOZWVkZWQoKSB7XG4gIGlmICghcmVzdG9yZVRhcmdldCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgdGFyZ2V0ID0gcmVzdG9yZVRhcmdldDtcbiAgdmFyIHF1ZXVlZFRhcmdldHMgPSByZXN0b3JlUXVldWU7XG4gIHJlc3RvcmVUYXJnZXQgPSBudWxsO1xuICByZXN0b3JlUXVldWUgPSBudWxsO1xuXG4gIHJlc3RvcmVTdGF0ZU9mVGFyZ2V0KHRhcmdldCk7XG4gIGlmIChxdWV1ZWRUYXJnZXRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZWRUYXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN0b3JlU3RhdGVPZlRhcmdldChxdWV1ZWRUYXJnZXRzW2ldKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q29udHJvbGxlZENvbXBvbmVudCA9IE9iamVjdC5mcmVlemUoe1xuXHRpbmplY3Rpb246IGluamVjdGlvbiQzLFxuXHRlbnF1ZXVlU3RhdGVSZXN0b3JlOiBlbnF1ZXVlU3RhdGVSZXN0b3JlLFxuXHRyZXN0b3JlU3RhdGVJZk5lZWRlZDogcmVzdG9yZVN0YXRlSWZOZWVkZWRcbn0pO1xuXG4vLyBVc2VkIGFzIGEgd2F5IHRvIGNhbGwgYmF0Y2hlZFVwZGF0ZXMgd2hlbiB3ZSBkb24ndCBoYXZlIGEgcmVmZXJlbmNlIHRvXG4vLyB0aGUgcmVuZGVyZXIuIFN1Y2ggYXMgd2hlbiB3ZSdyZSBkaXNwYXRjaGluZyBldmVudHMgb3IgaWYgdGhpcmQgcGFydHlcbi8vIGxpYnJhcmllcyBuZWVkIHRvIGNhbGwgYmF0Y2hlZFVwZGF0ZXMuIEV2ZW50dWFsbHksIHRoaXMgQVBJIHdpbGwgZ28gYXdheSB3aGVuXG4vLyBldmVyeXRoaW5nIGlzIGJhdGNoZWQgYnkgZGVmYXVsdC4gV2UnbGwgdGhlbiBoYXZlIGEgc2ltaWxhciBBUEkgdG8gb3B0LW91dCBvZlxuLy8gc2NoZWR1bGVkIHdvcmsgYW5kIGluc3RlYWQgZG8gc3luY2hyb25vdXMgd29yay5cblxuLy8gRGVmYXVsdHNcbnZhciBmaWJlckJhdGNoZWRVcGRhdGVzID0gZnVuY3Rpb24gKGZuLCBib29ra2VlcGluZykge1xuICByZXR1cm4gZm4oYm9va2tlZXBpbmcpO1xufTtcblxudmFyIGlzTmVzdGluZ0JhdGNoZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzKGZuLCBib29ra2VlcGluZykge1xuICBpZiAoaXNOZXN0aW5nQmF0Y2hlZCkge1xuICAgIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgaW5zaWRlIGFub3RoZXIgYmF0Y2gsIHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdFxuICAgIC8vIGZ1bGx5IGNvbXBsZXRlcyBiZWZvcmUgcmVzdG9yaW5nIHN0YXRlLiBUaGVyZWZvcmUsIHdlIGFkZCB0aGUgdGFyZ2V0IHRvXG4gICAgLy8gYSBxdWV1ZSBvZiB3b3JrLlxuICAgIHJldHVybiBmaWJlckJhdGNoZWRVcGRhdGVzKGZuLCBib29ra2VlcGluZyk7XG4gIH1cbiAgaXNOZXN0aW5nQmF0Y2hlZCA9IHRydWU7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZpYmVyQmF0Y2hlZFVwZGF0ZXMoZm4sIGJvb2trZWVwaW5nKTtcbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBIZXJlIHdlIHdhaXQgdW50aWwgYWxsIHVwZGF0ZXMgaGF2ZSBwcm9wYWdhdGVkLCB3aGljaCBpcyBpbXBvcnRhbnRcbiAgICAvLyB3aGVuIHVzaW5nIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3aXRoaW4gbGF5ZXJzOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY5OFxuICAgIC8vIFRoZW4gd2UgcmVzdG9yZSBzdGF0ZSBvZiBhbnkgY29udHJvbGxlZCBjb21wb25lbnQuXG4gICAgaXNOZXN0aW5nQmF0Y2hlZCA9IGZhbHNlO1xuICAgIHJlc3RvcmVTdGF0ZUlmTmVlZGVkKCk7XG4gIH1cbn1cblxudmFyIFJlYWN0R2VuZXJpY0JhdGNoaW5nSW5qZWN0aW9uID0ge1xuICBpbmplY3RGaWJlckJhdGNoZWRVcGRhdGVzOiBmdW5jdGlvbiAoX2JhdGNoZWRVcGRhdGVzKSB7XG4gICAgZmliZXJCYXRjaGVkVXBkYXRlcyA9IF9iYXRjaGVkVXBkYXRlcztcbiAgfVxufTtcblxudmFyIGluamVjdGlvbiQ0ID0gUmVhY3RHZW5lcmljQmF0Y2hpbmdJbmplY3Rpb247XG5cbi8qKlxuICogQHNlZSBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtaW5wdXQtZWxlbWVudC5odG1sI2lucHV0LXR5cGUtYXR0ci1zdW1tYXJ5XG4gKi9cbnZhciBzdXBwb3J0ZWRJbnB1dFR5cGVzID0ge1xuICBjb2xvcjogdHJ1ZSxcbiAgZGF0ZTogdHJ1ZSxcbiAgZGF0ZXRpbWU6IHRydWUsXG4gICdkYXRldGltZS1sb2NhbCc6IHRydWUsXG4gIGVtYWlsOiB0cnVlLFxuICBtb250aDogdHJ1ZSxcbiAgbnVtYmVyOiB0cnVlLFxuICBwYXNzd29yZDogdHJ1ZSxcbiAgcmFuZ2U6IHRydWUsXG4gIHNlYXJjaDogdHJ1ZSxcbiAgdGVsOiB0cnVlLFxuICB0ZXh0OiB0cnVlLFxuICB0aW1lOiB0cnVlLFxuICB1cmw6IHRydWUsXG4gIHdlZWs6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGlzVGV4dElucHV0RWxlbWVudChlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnaW5wdXQnKSB7XG4gICAgcmV0dXJuICEhc3VwcG9ydGVkSW5wdXRUeXBlc1tlbGVtLnR5cGVdO1xuICB9XG5cbiAgaWYgKG5vZGVOYW1lID09PSAndGV4dGFyZWEnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogSFRNTCBub2RlVHlwZSB2YWx1ZXMgdGhhdCByZXByZXNlbnQgdGhlIHR5cGUgb2YgdGhlIG5vZGVcbiAqL1xuXG52YXIgRUxFTUVOVF9OT0RFID0gMTtcbnZhciBURVhUX05PREUgPSAzO1xudmFyIENPTU1FTlRfTk9ERSA9IDg7XG52YXIgRE9DVU1FTlRfTk9ERSA9IDk7XG52YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERSA9IDExO1xuXG4vKipcbiAqIEdldHMgdGhlIHRhcmdldCBub2RlIGZyb20gYSBuYXRpdmUgYnJvd3NlciBldmVudCBieSBhY2NvdW50aW5nIGZvclxuICogaW5jb25zaXN0ZW5jaWVzIGluIGJyb3dzZXIgRE9NIEFQSXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7RE9NRXZlbnRUYXJnZXR9IFRhcmdldCBub2RlLlxuICovXG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkge1xuICB2YXIgdGFyZ2V0ID0gbmF0aXZlRXZlbnQudGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQgfHwgd2luZG93O1xuXG4gIC8vIE5vcm1hbGl6ZSBTVkcgPHVzZT4gZWxlbWVudCBldmVudHMgIzQ5NjNcbiAgaWYgKHRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudCkge1xuICAgIHRhcmdldCA9IHRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudDtcbiAgfVxuXG4gIC8vIFNhZmFyaSBtYXkgZmlyZSBldmVudHMgb24gdGV4dCBub2RlcyAoTm9kZS5URVhUX05PREUgaXMgMykuXG4gIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9qcy9ldmVudHNfcHJvcGVydGllcy5odG1sXG4gIHJldHVybiB0YXJnZXQubm9kZVR5cGUgPT09IFRFWFRfTk9ERSA/IHRhcmdldC5wYXJlbnROb2RlIDogdGFyZ2V0O1xufVxuXG52YXIgdXNlSGFzRmVhdHVyZTtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgdXNlSGFzRmVhdHVyZSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uICYmIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUgJiZcbiAgLy8gYWx3YXlzIHJldHVybnMgdHJ1ZSBpbiBuZXdlciBicm93c2VycyBhcyBwZXIgdGhlIHN0YW5kYXJkLlxuICAvLyBAc2VlIGh0dHA6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZG9taW1wbGVtZW50YXRpb24taGFzZmVhdHVyZVxuICBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCcnLCAnJykgIT09IHRydWU7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFuIGV2ZW50IGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBleGVjdXRpb24gZW52aXJvbm1lbnQuXG4gKlxuICogTk9URTogVGhpcyB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseSBmb3Igbm9uLWdlbmVyaWMgZXZlbnRzIHN1Y2ggYXMgYGNoYW5nZWAsXG4gKiBgcmVzZXRgLCBgbG9hZGAsIGBlcnJvcmAsIGFuZCBgc2VsZWN0YC5cbiAqXG4gKiBCb3Jyb3dzIGZyb20gTW9kZXJuaXpyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVTdWZmaXggRXZlbnQgbmFtZSwgZS5nLiBcImNsaWNrXCIuXG4gKiBAcGFyYW0gez9ib29sZWFufSBjYXB0dXJlIENoZWNrIGlmIHRoZSBjYXB0dXJlIHBoYXNlIGlzIHN1cHBvcnRlZC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IGlzIHN1cHBvcnRlZC5cbiAqIEBpbnRlcm5hbFxuICogQGxpY2Vuc2UgTW9kZXJuaXpyIDMuMC4wcHJlIChDdXN0b20gQnVpbGQpIHwgTUlUXG4gKi9cbmZ1bmN0aW9uIGlzRXZlbnRTdXBwb3J0ZWQoZXZlbnROYW1lU3VmZml4LCBjYXB0dXJlKSB7XG4gIGlmICghRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NIHx8IGNhcHR1cmUgJiYgISgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gZG9jdW1lbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGV2ZW50TmFtZSA9ICdvbicgKyBldmVudE5hbWVTdWZmaXg7XG4gIHZhciBpc1N1cHBvcnRlZCA9IGV2ZW50TmFtZSBpbiBkb2N1bWVudDtcblxuICBpZiAoIWlzU3VwcG9ydGVkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShldmVudE5hbWUsICdyZXR1cm47Jyk7XG4gICAgaXNTdXBwb3J0ZWQgPSB0eXBlb2YgZWxlbWVudFtldmVudE5hbWVdID09PSAnZnVuY3Rpb24nO1xuICB9XG5cbiAgaWYgKCFpc1N1cHBvcnRlZCAmJiB1c2VIYXNGZWF0dXJlICYmIGV2ZW50TmFtZVN1ZmZpeCA9PT0gJ3doZWVsJykge1xuICAgIC8vIFRoaXMgaXMgdGhlIG9ubHkgd2F5IHRvIHRlc3Qgc3VwcG9ydCBmb3IgdGhlIGB3aGVlbGAgZXZlbnQgaW4gSUU5Ky5cbiAgICBpc1N1cHBvcnRlZCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoJ0V2ZW50cy53aGVlbCcsICczLjAnKTtcbiAgfVxuXG4gIHJldHVybiBpc1N1cHBvcnRlZDtcbn1cblxuZnVuY3Rpb24gaXNDaGVja2FibGUoZWxlbSkge1xuICB2YXIgdHlwZSA9IGVsZW0udHlwZTtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIG5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgKHR5cGUgPT09ICdjaGVja2JveCcgfHwgdHlwZSA9PT0gJ3JhZGlvJyk7XG59XG5cbmZ1bmN0aW9uIGdldFRyYWNrZXIobm9kZSkge1xuICByZXR1cm4gbm9kZS5fdmFsdWVUcmFja2VyO1xufVxuXG5mdW5jdGlvbiBkZXRhY2hUcmFja2VyKG5vZGUpIHtcbiAgbm9kZS5fdmFsdWVUcmFja2VyID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVGcm9tTm9kZShub2RlKSB7XG4gIHZhciB2YWx1ZSA9ICcnO1xuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAoaXNDaGVja2FibGUobm9kZSkpIHtcbiAgICB2YWx1ZSA9IG5vZGUuY2hlY2tlZCA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBub2RlLnZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB0cmFja1ZhbHVlT25Ob2RlKG5vZGUpIHtcbiAgdmFyIHZhbHVlRmllbGQgPSBpc0NoZWNrYWJsZShub2RlKSA/ICdjaGVja2VkJyA6ICd2YWx1ZSc7XG4gIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihub2RlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgdmFsdWVGaWVsZCk7XG5cbiAgdmFyIGN1cnJlbnRWYWx1ZSA9ICcnICsgbm9kZVt2YWx1ZUZpZWxkXTtcblxuICAvLyBpZiBzb21lb25lIGhhcyBhbHJlYWR5IGRlZmluZWQgYSB2YWx1ZSBvciBTYWZhcmksIHRoZW4gYmFpbFxuICAvLyBhbmQgZG9uJ3QgdHJhY2sgdmFsdWUgd2lsbCBjYXVzZSBvdmVyIHJlcG9ydGluZyBvZiBjaGFuZ2VzLFxuICAvLyBidXQgaXQncyBiZXR0ZXIgdGhlbiBhIGhhcmQgZmFpbHVyZVxuICAvLyAobmVlZGVkIGZvciBjZXJ0YWluIHRlc3RzIHRoYXQgc3B5T24gaW5wdXQgdmFsdWVzIGFuZCBTYWZhcmkpXG4gIGlmIChub2RlLmhhc093blByb3BlcnR5KHZhbHVlRmllbGQpIHx8IHR5cGVvZiBkZXNjcmlwdG9yLmdldCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZGVzY3JpcHRvci5zZXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobm9kZSwgdmFsdWVGaWVsZCwge1xuICAgIGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZGVzY3JpcHRvci5nZXQuY2FsbCh0aGlzKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50VmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgZGVzY3JpcHRvci5zZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgdHJhY2tlciA9IHtcbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZTtcbiAgICB9LFxuICAgIHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgfSxcbiAgICBzdG9wVHJhY2tpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGRldGFjaFRyYWNrZXIobm9kZSk7XG4gICAgICBkZWxldGUgbm9kZVt2YWx1ZUZpZWxkXTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB0cmFja2VyO1xufVxuXG5mdW5jdGlvbiB0cmFjayhub2RlKSB7XG4gIGlmIChnZXRUcmFja2VyKG5vZGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVE9ETzogT25jZSBpdCdzIGp1c3QgRmliZXIgd2UgY2FuIG1vdmUgdGhpcyB0byBub2RlLl93cmFwcGVyU3RhdGVcbiAgbm9kZS5fdmFsdWVUcmFja2VyID0gdHJhY2tWYWx1ZU9uTm9kZShub2RlKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlVmFsdWVJZkNoYW5nZWQobm9kZSkge1xuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgdHJhY2tlciA9IGdldFRyYWNrZXIobm9kZSk7XG4gIC8vIGlmIHRoZXJlIGlzIG5vIHRyYWNrZXIgYXQgdGhpcyBwb2ludCBpdCdzIHVubGlrZWx5XG4gIC8vIHRoYXQgdHJ5aW5nIGFnYWluIHdpbGwgc3VjY2VlZFxuICBpZiAoIXRyYWNrZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBsYXN0VmFsdWUgPSB0cmFja2VyLmdldFZhbHVlKCk7XG4gIHZhciBuZXh0VmFsdWUgPSBnZXRWYWx1ZUZyb21Ob2RlKG5vZGUpO1xuICBpZiAobmV4dFZhbHVlICE9PSBsYXN0VmFsdWUpIHtcbiAgICB0cmFja2VyLnNldFZhbHVlKG5leHRWYWx1ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgZXZlbnRUeXBlcyQxID0ge1xuICBjaGFuZ2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ2hhbmdlJyxcbiAgICAgIGNhcHR1cmVkOiAnb25DaGFuZ2VDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ2hhbmdlJywgJ3RvcENsaWNrJywgJ3RvcEZvY3VzJywgJ3RvcElucHV0JywgJ3RvcEtleURvd24nLCAndG9wS2V5VXAnLCAndG9wU2VsZWN0aW9uQ2hhbmdlJ11cbiAgfVxufTtcblxuZnVuY3Rpb24gY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KGluc3QsIG5hdGl2ZUV2ZW50LCB0YXJnZXQpIHtcbiAgdmFyIGV2ZW50ID0gU3ludGhldGljRXZlbnQkMS5nZXRQb29sZWQoZXZlbnRUeXBlcyQxLmNoYW5nZSwgaW5zdCwgbmF0aXZlRXZlbnQsIHRhcmdldCk7XG4gIGV2ZW50LnR5cGUgPSAnY2hhbmdlJztcbiAgLy8gRmxhZyB0aGlzIGV2ZW50IGxvb3AgYXMgbmVlZGluZyBzdGF0ZSByZXN0b3JlLlxuICBlbnF1ZXVlU3RhdGVSZXN0b3JlKHRhcmdldCk7XG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG4vKipcbiAqIEZvciBJRSBzaGltc1xuICovXG52YXIgYWN0aXZlRWxlbWVudCA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2hhbmdlYCBldmVudFxuICovXG5mdW5jdGlvbiBzaG91bGRVc2VDaGFuZ2VFdmVudChlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbm9kZU5hbWUgPT09ICdzZWxlY3QnIHx8IG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW0udHlwZSA9PT0gJ2ZpbGUnO1xufVxuXG5mdW5jdGlvbiBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBldmVudCA9IGNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChhY3RpdmVFbGVtZW50SW5zdCwgbmF0aXZlRXZlbnQsIGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KSk7XG5cbiAgLy8gSWYgY2hhbmdlIGFuZCBwcm9wZXJ0eWNoYW5nZSBidWJibGVkLCB3ZSdkIGp1c3QgYmluZCB0byBpdCBsaWtlIGFsbCB0aGVcbiAgLy8gb3RoZXIgZXZlbnRzIGFuZCBoYXZlIGl0IGdvIHRocm91Z2ggUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLiBTaW5jZSBpdFxuICAvLyBkb2Vzbid0LCB3ZSBtYW51YWxseSBsaXN0ZW4gZm9yIHRoZSBldmVudHMgYW5kIHNvIHdlIGhhdmUgdG8gZW5xdWV1ZSBhbmRcbiAgLy8gcHJvY2VzcyB0aGUgYWJzdHJhY3QgZXZlbnQgbWFudWFsbHkuXG4gIC8vXG4gIC8vIEJhdGNoaW5nIGlzIG5lY2Vzc2FyeSBoZXJlIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IGFsbCBldmVudCBoYW5kbGVycyBydW5cbiAgLy8gYmVmb3JlIHRoZSBuZXh0IHJlcmVuZGVyIChpbmNsdWRpbmcgZXZlbnQgaGFuZGxlcnMgYXR0YWNoZWQgdG8gYW5jZXN0b3JcbiAgLy8gZWxlbWVudHMgaW5zdGVhZCBvZiBkaXJlY3RseSBvbiB0aGUgaW5wdXQpLiBXaXRob3V0IHRoaXMsIGNvbnRyb2xsZWRcbiAgLy8gY29tcG9uZW50cyBkb24ndCB3b3JrIHByb3Blcmx5IGluIGNvbmp1bmN0aW9uIHdpdGggZXZlbnQgYnViYmxpbmcgYmVjYXVzZVxuICAvLyB0aGUgY29tcG9uZW50IGlzIHJlcmVuZGVyZWQgYW5kIHRoZSB2YWx1ZSByZXZlcnRlZCBiZWZvcmUgYWxsIHRoZSBldmVudFxuICAvLyBoYW5kbGVycyBjYW4gcnVuLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MDguXG4gIGJhdGNoZWRVcGRhdGVzKHJ1bkV2ZW50SW5CYXRjaCwgZXZlbnQpO1xufVxuXG5mdW5jdGlvbiBydW5FdmVudEluQmF0Y2goZXZlbnQpIHtcbiAgZW5xdWV1ZUV2ZW50cyhldmVudCk7XG4gIHByb2Nlc3NFdmVudFF1ZXVlKGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3QpIHtcbiAgdmFyIHRhcmdldE5vZGUgPSBnZXROb2RlRnJvbUluc3RhbmNlJDEodGFyZ2V0SW5zdCk7XG4gIGlmICh1cGRhdGVWYWx1ZUlmQ2hhbmdlZCh0YXJnZXROb2RlKSkge1xuICAgIHJldHVybiB0YXJnZXRJbnN0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcENoYW5nZScpIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgaW5wdXRgIGV2ZW50XG4gKi9cbnZhciBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSBmYWxzZTtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgLy8gSUU5IGNsYWltcyB0byBzdXBwb3J0IHRoZSBpbnB1dCBldmVudCBidXQgZmFpbHMgdG8gdHJpZ2dlciBpdCB3aGVuXG4gIC8vIGRlbGV0aW5nIHRleHQsIHNvIHdlIGlnbm9yZSBpdHMgaW5wdXQgZXZlbnRzLlxuICBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSBpc0V2ZW50U3VwcG9ydGVkKCdpbnB1dCcpICYmICghZG9jdW1lbnQuZG9jdW1lbnRNb2RlIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA+IDkpO1xufVxuXG4vKipcbiAqIChGb3IgSUUgPD05KSBTdGFydHMgdHJhY2tpbmcgcHJvcGVydHljaGFuZ2UgZXZlbnRzIG9uIHRoZSBwYXNzZWQtaW4gZWxlbWVudFxuICogYW5kIG92ZXJyaWRlIHRoZSB2YWx1ZSBwcm9wZXJ0eSBzbyB0aGF0IHdlIGNhbiBkaXN0aW5ndWlzaCB1c2VyIGV2ZW50cyBmcm9tXG4gKiB2YWx1ZSBjaGFuZ2VzIGluIEpTLlxuICovXG5mdW5jdGlvbiBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXQ7XG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgYWN0aXZlRWxlbWVudC5hdHRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcbn1cblxuLyoqXG4gKiAoRm9yIElFIDw9OSkgUmVtb3ZlcyB0aGUgZXZlbnQgbGlzdGVuZXJzIGZyb20gdGhlIGN1cnJlbnRseS10cmFja2VkIGVsZW1lbnQsXG4gKiBpZiBhbnkgZXhpc3RzLlxuICovXG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpIHtcbiAgaWYgKCFhY3RpdmVFbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFjdGl2ZUVsZW1lbnQuZGV0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7XG4gIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG59XG5cbi8qKlxuICogKEZvciBJRSA8PTkpIEhhbmRsZXMgYSBwcm9wZXJ0eWNoYW5nZSBldmVudCwgc2VuZGluZyBhIGBjaGFuZ2VgIGV2ZW50IGlmXG4gKiB0aGUgdmFsdWUgb2YgdGhlIGFjdGl2ZSBlbGVtZW50IGhhcyBjaGFuZ2VkLlxuICovXG5mdW5jdGlvbiBoYW5kbGVQcm9wZXJ0eUNoYW5nZShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQucHJvcGVydHlOYW1lICE9PSAndmFsdWUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChnZXRJbnN0SWZWYWx1ZUNoYW5nZWQoYWN0aXZlRWxlbWVudEluc3QpKSB7XG4gICAgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudFBvbHlmaWxsKHRvcExldmVsVHlwZSwgdGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BGb2N1cycpIHtcbiAgICAvLyBJbiBJRTksIHByb3BlcnR5Y2hhbmdlIGZpcmVzIGZvciBtb3N0IGlucHV0IGV2ZW50cyBidXQgaXMgYnVnZ3kgYW5kXG4gICAgLy8gZG9lc24ndCBmaXJlIHdoZW4gdGV4dCBpcyBkZWxldGVkLCBidXQgY29udmVuaWVudGx5LCBzZWxlY3Rpb25jaGFuZ2VcbiAgICAvLyBhcHBlYXJzIHRvIGZpcmUgaW4gYWxsIG9mIHRoZSByZW1haW5pbmcgY2FzZXMgc28gd2UgY2F0Y2ggdGhvc2UgYW5kXG4gICAgLy8gZm9yd2FyZCB0aGUgZXZlbnQgaWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkXG4gICAgLy8gSW4gZWl0aGVyIGNhc2UsIHdlIGRvbid0IHdhbnQgdG8gY2FsbCB0aGUgZXZlbnQgaGFuZGxlciBpZiB0aGUgdmFsdWVcbiAgICAvLyBpcyBjaGFuZ2VkIGZyb20gSlMgc28gd2UgcmVkZWZpbmUgYSBzZXR0ZXIgZm9yIGAudmFsdWVgIHRoYXQgdXBkYXRlc1xuICAgIC8vIG91ciBhY3RpdmVFbGVtZW50VmFsdWUgdmFyaWFibGUsIGFsbG93aW5nIHVzIHRvIGlnbm9yZSB0aG9zZSBjaGFuZ2VzXG4gICAgLy9cbiAgICAvLyBzdG9wV2F0Y2hpbmcoKSBzaG91bGQgYmUgYSBub29wIGhlcmUgYnV0IHdlIGNhbGwgaXQganVzdCBpbiBjYXNlIHdlXG4gICAgLy8gbWlzc2VkIGEgYmx1ciBldmVudCBzb21laG93LlxuICAgIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCk7XG4gICAgc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SW5zdCk7XG4gIH0gZWxzZSBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wQmx1cicpIHtcbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICB9XG59XG5cbi8vIEZvciBJRTggYW5kIElFOS5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50UG9seWZpbGwodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BTZWxlY3Rpb25DaGFuZ2UnIHx8IHRvcExldmVsVHlwZSA9PT0gJ3RvcEtleVVwJyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BLZXlEb3duJykge1xuICAgIC8vIE9uIHRoZSBzZWxlY3Rpb25jaGFuZ2UgZXZlbnQsIHRoZSB0YXJnZXQgaXMganVzdCBkb2N1bWVudCB3aGljaCBpc24ndFxuICAgIC8vIGhlbHBmdWwgZm9yIHVzIHNvIGp1c3QgY2hlY2sgYWN0aXZlRWxlbWVudCBpbnN0ZWFkLlxuICAgIC8vXG4gICAgLy8gOTklIG9mIHRoZSB0aW1lLCBrZXlkb3duIGFuZCBrZXl1cCBhcmVuJ3QgbmVjZXNzYXJ5LiBJRTggZmFpbHMgdG8gZmlyZVxuICAgIC8vIHByb3BlcnR5Y2hhbmdlIG9uIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhZnRlciBzZXR0aW5nIGB2YWx1ZWAgZnJvbSBhXG4gICAgLy8gc2NyaXB0IGFuZCBmaXJlcyBvbmx5IGtleWRvd24sIGtleXByZXNzLCBrZXl1cC4gQ2F0Y2hpbmcga2V5dXAgdXN1YWxseVxuICAgIC8vIGdldHMgaXQgYW5kIGNhdGNoaW5nIGtleWRvd24gbGV0cyB1cyBmaXJlIGFuIGV2ZW50IGZvciB0aGUgZmlyc3RcbiAgICAvLyBrZXlzdHJva2UgaWYgdXNlciBkb2VzIGEga2V5IHJlcGVhdCAoaXQnbGwgYmUgYSBsaXR0bGUgZGVsYXllZDogcmlnaHRcbiAgICAvLyBiZWZvcmUgdGhlIHNlY29uZCBrZXlzdHJva2UpLiBPdGhlciBpbnB1dCBtZXRob2RzIChlLmcuLCBwYXN0ZSkgc2VlbSB0b1xuICAgIC8vIGZpcmUgc2VsZWN0aW9uY2hhbmdlIG5vcm1hbGx5LlxuICAgIHJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQoYWN0aXZlRWxlbWVudEluc3QpO1xuICB9XG59XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBjbGlja2AgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2xpY2tFdmVudChlbGVtKSB7XG4gIC8vIFVzZSB0aGUgYGNsaWNrYCBldmVudCB0byBkZXRlY3QgY2hhbmdlcyB0byBjaGVja2JveCBhbmQgcmFkaW8gaW5wdXRzLlxuICAvLyBUaGlzIGFwcHJvYWNoIHdvcmtzIGFjcm9zcyBhbGwgYnJvd3NlcnMsIHdoZXJlYXMgYGNoYW5nZWAgZG9lcyBub3QgZmlyZVxuICAvLyB1bnRpbCBgYmx1cmAgaW4gSUU4LlxuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lO1xuICByZXR1cm4gbm9kZU5hbWUgJiYgbm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JyAmJiAoZWxlbS50eXBlID09PSAnY2hlY2tib3gnIHx8IGVsZW0udHlwZSA9PT0gJ3JhZGlvJyk7XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wQ2xpY2snKSB7XG4gICAgcmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRPckNoYW5nZUV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wSW5wdXQnIHx8IHRvcExldmVsVHlwZSA9PT0gJ3RvcENoYW5nZScpIHtcbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUNvbnRyb2xsZWRJbnB1dEJsdXIoaW5zdCwgbm9kZSkge1xuICAvLyBUT0RPOiBJbiBJRSwgaW5zdCBpcyBvY2Nhc2lvbmFsbHkgbnVsbC4gV2h5P1xuICBpZiAoaW5zdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRmliZXIgYW5kIFJlYWN0RE9NIGtlZXAgd3JhcHBlciBzdGF0ZSBpbiBzZXBhcmF0ZSBwbGFjZXNcbiAgdmFyIHN0YXRlID0gaW5zdC5fd3JhcHBlclN0YXRlIHx8IG5vZGUuX3dyYXBwZXJTdGF0ZTtcblxuICBpZiAoIXN0YXRlIHx8ICFzdGF0ZS5jb250cm9sbGVkIHx8IG5vZGUudHlwZSAhPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBJZiBjb250cm9sbGVkLCBhc3NpZ24gdGhlIHZhbHVlIGF0dHJpYnV0ZSB0byB0aGUgY3VycmVudCB2YWx1ZSBvbiBibHVyXG4gIHZhciB2YWx1ZSA9ICcnICsgbm9kZS52YWx1ZTtcbiAgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKCd2YWx1ZScpICE9PSB2YWx1ZSkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHZhbHVlKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uQ2hhbmdlYCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgY2hhbmdlIGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuIFRoaXMgZXZlbnQgZmlyZXMgYXQgYSB0aW1lIHdoZW4gaXQncyBwb3NzaWJsZSB0b1xuICogY2hhbmdlIHRoZSBlbGVtZW50J3MgdmFsdWUgd2l0aG91dCBzZWVpbmcgYSBmbGlja2VyLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIHNlbGVjdFxuICovXG52YXIgQ2hhbmdlRXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMkMSxcblxuICBfaXNJbnB1dEV2ZW50U3VwcG9ydGVkOiBpc0lucHV0RXZlbnRTdXBwb3J0ZWQsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIHRhcmdldE5vZGUgPSB0YXJnZXRJbnN0ID8gZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKHRhcmdldEluc3QpIDogd2luZG93O1xuXG4gICAgdmFyIGdldFRhcmdldEluc3RGdW5jLCBoYW5kbGVFdmVudEZ1bmM7XG4gICAgaWYgKHNob3VsZFVzZUNoYW5nZUV2ZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudDtcbiAgICB9IGVsc2UgaWYgKGlzVGV4dElucHV0RWxlbWVudCh0YXJnZXROb2RlKSkge1xuICAgICAgaWYgKGlzSW5wdXRFdmVudFN1cHBvcnRlZCkge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dE9yQ2hhbmdlRXZlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50UG9seWZpbGw7XG4gICAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRQb2x5ZmlsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNob3VsZFVzZUNsaWNrRXZlbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGdldFRhcmdldEluc3RGdW5jKSB7XG4gICAgICB2YXIgaW5zdCA9IGdldFRhcmdldEluc3RGdW5jKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCk7XG4gICAgICBpZiAoaW5zdCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoaW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYW5kbGVFdmVudEZ1bmMpIHtcbiAgICAgIGhhbmRsZUV2ZW50RnVuYyh0b3BMZXZlbFR5cGUsIHRhcmdldE5vZGUsIHRhcmdldEluc3QpO1xuICAgIH1cblxuICAgIC8vIFdoZW4gYmx1cnJpbmcsIHNldCB0aGUgdmFsdWUgYXR0cmlidXRlIGZvciBudW1iZXIgaW5wdXRzXG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcEJsdXInKSB7XG4gICAgICBoYW5kbGVDb250cm9sbGVkSW5wdXRCbHVyKHRhcmdldEluc3QsIHRhcmdldE5vZGUpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBNb2R1bGUgdGhhdCBpcyBpbmplY3RhYmxlIGludG8gYEV2ZW50UGx1Z2luSHViYCwgdGhhdCBzcGVjaWZpZXMgYVxuICogZGV0ZXJtaW5pc3RpYyBvcmRlcmluZyBvZiBgRXZlbnRQbHVnaW5gcy4gQSBjb252ZW5pZW50IHdheSB0byByZWFzb24gYWJvdXRcbiAqIHBsdWdpbnMsIHdpdGhvdXQgaGF2aW5nIHRvIHBhY2thZ2UgZXZlcnkgb25lIG9mIHRoZW0uIFRoaXMgaXMgYmV0dGVyIHRoYW5cbiAqIGhhdmluZyBwbHVnaW5zIGJlIG9yZGVyZWQgaW4gdGhlIHNhbWUgb3JkZXIgdGhhdCB0aGV5IGFyZSBpbmplY3RlZCBiZWNhdXNlXG4gKiB0aGF0IG9yZGVyaW5nIHdvdWxkIGJlIGluZmx1ZW5jZWQgYnkgdGhlIHBhY2thZ2luZyBvcmRlci5cbiAqIGBSZXNwb25kZXJFdmVudFBsdWdpbmAgbXVzdCBvY2N1ciBiZWZvcmUgYFNpbXBsZUV2ZW50UGx1Z2luYCBzbyB0aGF0XG4gKiBwcmV2ZW50aW5nIGRlZmF1bHQgb24gZXZlbnRzIGlzIGNvbnZlbmllbnQgaW4gYFNpbXBsZUV2ZW50UGx1Z2luYCBoYW5kbGVycy5cbiAqL1xudmFyIERPTUV2ZW50UGx1Z2luT3JkZXIgPSBbJ1Jlc3BvbmRlckV2ZW50UGx1Z2luJywgJ1NpbXBsZUV2ZW50UGx1Z2luJywgJ1RhcEV2ZW50UGx1Z2luJywgJ0VudGVyTGVhdmVFdmVudFBsdWdpbicsICdDaGFuZ2VFdmVudFBsdWdpbicsICdTZWxlY3RFdmVudFBsdWdpbicsICdCZWZvcmVJbnB1dEV2ZW50UGx1Z2luJ107XG5cbi8qKlxuICogQGludGVyZmFjZSBVSUV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFVJRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHZpZXc6IG51bGwsXG4gIGRldGFpbDogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1VJRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50JDEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50JDEuYXVnbWVudENsYXNzKFN5bnRoZXRpY1VJRXZlbnQsIFVJRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIFRyYW5zbGF0aW9uIGZyb20gbW9kaWZpZXIga2V5IHRvIHRoZSBhc3NvY2lhdGVkIHByb3BlcnR5IGluIHRoZSBldmVudC5cbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNrZXlzLU1vZGlmaWVyc1xuICovXG5cbnZhciBtb2RpZmllcktleVRvUHJvcCA9IHtcbiAgQWx0OiAnYWx0S2V5JyxcbiAgQ29udHJvbDogJ2N0cmxLZXknLFxuICBNZXRhOiAnbWV0YUtleScsXG4gIFNoaWZ0OiAnc2hpZnRLZXknXG59O1xuXG4vLyBJRTggZG9lcyBub3QgaW1wbGVtZW50IGdldE1vZGlmaWVyU3RhdGUgc28gd2Ugc2ltcGx5IG1hcCBpdCB0byB0aGUgb25seVxuLy8gbW9kaWZpZXIga2V5cyBleHBvc2VkIGJ5IHRoZSBldmVudCBpdHNlbGYsIGRvZXMgbm90IHN1cHBvcnQgTG9jay1rZXlzLlxuLy8gQ3VycmVudGx5LCBhbGwgbWFqb3IgYnJvd3NlcnMgZXhjZXB0IENocm9tZSBzZWVtcyB0byBzdXBwb3J0IExvY2sta2V5cy5cbmZ1bmN0aW9uIG1vZGlmaWVyU3RhdGVHZXR0ZXIoa2V5QXJnKSB7XG4gIHZhciBzeW50aGV0aWNFdmVudCA9IHRoaXM7XG4gIHZhciBuYXRpdmVFdmVudCA9IHN5bnRoZXRpY0V2ZW50Lm5hdGl2ZUV2ZW50O1xuICBpZiAobmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZSkge1xuICAgIHJldHVybiBuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKGtleUFyZyk7XG4gIH1cbiAgdmFyIGtleVByb3AgPSBtb2RpZmllcktleVRvUHJvcFtrZXlBcmddO1xuICByZXR1cm4ga2V5UHJvcCA/ICEhbmF0aXZlRXZlbnRba2V5UHJvcF0gOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RXZlbnRNb2RpZmllclN0YXRlKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiBtb2RpZmllclN0YXRlR2V0dGVyO1xufVxuXG4vKipcbiAqIEBpbnRlcmZhY2UgTW91c2VFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBNb3VzZUV2ZW50SW50ZXJmYWNlID0ge1xuICBzY3JlZW5YOiBudWxsLFxuICBzY3JlZW5ZOiBudWxsLFxuICBjbGllbnRYOiBudWxsLFxuICBjbGllbnRZOiBudWxsLFxuICBwYWdlWDogbnVsbCxcbiAgcGFnZVk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgYnV0dG9uOiBudWxsLFxuICBidXR0b25zOiBudWxsLFxuICByZWxhdGVkVGFyZ2V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQucmVsYXRlZFRhcmdldCB8fCAoZXZlbnQuZnJvbUVsZW1lbnQgPT09IGV2ZW50LnNyY0VsZW1lbnQgPyBldmVudC50b0VsZW1lbnQgOiBldmVudC5mcm9tRWxlbWVudCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY01vdXNlRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY01vdXNlRXZlbnQsIE1vdXNlRXZlbnRJbnRlcmZhY2UpO1xuXG52YXIgZXZlbnRUeXBlcyQyID0ge1xuICBtb3VzZUVudGVyOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZTogJ29uTW91c2VFbnRlcicsXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcE1vdXNlT3V0JywgJ3RvcE1vdXNlT3ZlciddXG4gIH0sXG4gIG1vdXNlTGVhdmU6IHtcbiAgICByZWdpc3RyYXRpb25OYW1lOiAnb25Nb3VzZUxlYXZlJyxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wTW91c2VPdXQnLCAndG9wTW91c2VPdmVyJ11cbiAgfVxufTtcblxudmFyIEVudGVyTGVhdmVFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyQyLFxuXG4gIC8qKlxuICAgKiBGb3IgYWxtb3N0IGV2ZXJ5IGludGVyYWN0aW9uIHdlIGNhcmUgYWJvdXQsIHRoZXJlIHdpbGwgYmUgYm90aCBhIHRvcC1sZXZlbFxuICAgKiBgbW91c2VvdmVyYCBhbmQgYG1vdXNlb3V0YCBldmVudCB0aGF0IG9jY3Vycy4gT25seSB1c2UgYG1vdXNlb3V0YCBzbyB0aGF0XG4gICAqIHdlIGRvIG5vdCBleHRyYWN0IGR1cGxpY2F0ZSBldmVudHMuIEhvd2V2ZXIsIG1vdmluZyB0aGUgbW91c2UgaW50byB0aGVcbiAgICogYnJvd3NlciBmcm9tIG91dHNpZGUgd2lsbCBub3QgZmlyZSBhIGBtb3VzZW91dGAgZXZlbnQuIEluIHRoaXMgY2FzZSwgd2UgdXNlXG4gICAqIHRoZSBgbW91c2VvdmVyYCB0b3AtbGV2ZWwgZXZlbnQuXG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wTW91c2VPdmVyJyAmJiAobmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC5mcm9tRWxlbWVudCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodG9wTGV2ZWxUeXBlICE9PSAndG9wTW91c2VPdXQnICYmIHRvcExldmVsVHlwZSAhPT0gJ3RvcE1vdXNlT3ZlcicpIHtcbiAgICAgIC8vIE11c3Qgbm90IGJlIGEgbW91c2UgaW4gb3IgbW91c2Ugb3V0IC0gaWdub3JpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgd2luO1xuICAgIGlmIChuYXRpdmVFdmVudFRhcmdldC53aW5kb3cgPT09IG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgICAvLyBgbmF0aXZlRXZlbnRUYXJnZXRgIGlzIHByb2JhYmx5IGEgd2luZG93IG9iamVjdC5cbiAgICAgIHdpbiA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXG4gICAgICB2YXIgZG9jID0gbmF0aXZlRXZlbnRUYXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgd2luID0gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3c7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW4gPSB3aW5kb3c7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZyb207XG4gICAgdmFyIHRvO1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BNb3VzZU91dCcpIHtcbiAgICAgIGZyb20gPSB0YXJnZXRJbnN0O1xuICAgICAgdmFyIHJlbGF0ZWQgPSBuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnRvRWxlbWVudDtcbiAgICAgIHRvID0gcmVsYXRlZCA/IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHJlbGF0ZWQpIDogbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTW92aW5nIHRvIGEgbm9kZSBmcm9tIG91dHNpZGUgdGhlIHdpbmRvdy5cbiAgICAgIGZyb20gPSBudWxsO1xuICAgICAgdG8gPSB0YXJnZXRJbnN0O1xuICAgIH1cblxuICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgLy8gTm90aGluZyBwZXJ0YWlucyB0byBvdXIgbWFuYWdlZCBjb21wb25lbnRzLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGZyb21Ob2RlID0gZnJvbSA9PSBudWxsID8gd2luIDogZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKGZyb20pO1xuICAgIHZhciB0b05vZGUgPSB0byA9PSBudWxsID8gd2luIDogZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKHRvKTtcblxuICAgIHZhciBsZWF2ZSA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMkMi5tb3VzZUxlYXZlLCBmcm9tLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGxlYXZlLnR5cGUgPSAnbW91c2VsZWF2ZSc7XG4gICAgbGVhdmUudGFyZ2V0ID0gZnJvbU5vZGU7XG4gICAgbGVhdmUucmVsYXRlZFRhcmdldCA9IHRvTm9kZTtcblxuICAgIHZhciBlbnRlciA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMkMi5tb3VzZUVudGVyLCB0bywgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBlbnRlci50eXBlID0gJ21vdXNlZW50ZXInO1xuICAgIGVudGVyLnRhcmdldCA9IHRvTm9kZTtcbiAgICBlbnRlci5yZWxhdGVkVGFyZ2V0ID0gZnJvbU5vZGU7XG5cbiAgICBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMobGVhdmUsIGVudGVyLCBmcm9tLCB0byk7XG5cbiAgICByZXR1cm4gW2xlYXZlLCBlbnRlcl07XG4gIH1cbn07XG5cbi8qKlxuICogYFJlYWN0SW5zdGFuY2VNYXBgIG1haW50YWlucyBhIG1hcHBpbmcgZnJvbSBhIHB1YmxpYyBmYWNpbmcgc3RhdGVmdWxcbiAqIGluc3RhbmNlIChrZXkpIGFuZCB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gKHZhbHVlKS4gVGhpcyBhbGxvd3MgcHVibGljXG4gKiBtZXRob2RzIHRvIGFjY2VwdCB0aGUgdXNlciBmYWNpbmcgaW5zdGFuY2UgYXMgYW4gYXJndW1lbnQgYW5kIG1hcCB0aGVtIGJhY2tcbiAqIHRvIGludGVybmFsIG1ldGhvZHMuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgbW9kdWxlIGlzIGN1cnJlbnRseSBzaGFyZWQgYW5kIGFzc3VtZWQgdG8gYmUgc3RhdGVsZXNzLlxuICogSWYgdGhpcyBiZWNvbWVzIGFuIGFjdHVhbCBNYXAsIHRoYXQgd2lsbCBicmVhay5cbiAqL1xuXG4vKipcbiAqIFRoaXMgQVBJIHNob3VsZCBiZSBjYWxsZWQgYGRlbGV0ZWAgYnV0IHdlJ2QgaGF2ZSB0byBtYWtlIHN1cmUgdG8gYWx3YXlzXG4gKiB0cmFuc2Zvcm0gdGhlc2UgdG8gc3RyaW5ncyBmb3IgSUUgc3VwcG9ydC4gV2hlbiB0aGlzIHRyYW5zZm9ybSBpcyBmdWxseVxuICogc3VwcG9ydGVkIHdlIGNhbiByZW5hbWUgaXQuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXQoa2V5KSB7XG4gIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxGaWJlcjtcbn1cblxuZnVuY3Rpb24gaGFzKGtleSkge1xuICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsRmliZXIgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAga2V5Ll9yZWFjdEludGVybmFsRmliZXIgPSB2YWx1ZTtcbn1cblxudmFyIFJlYWN0SW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0SW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB7XG4gIHZhciB0eXBlID0gZmliZXIudHlwZTtcblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBEb24ndCBjaGFuZ2UgdGhlc2UgdHdvIHZhbHVlczpcbnZhciBOb0VmZmVjdCA9IDA7IC8vICAgICAgICAgICAwYjAwMDAwMDAwXG52YXIgUGVyZm9ybWVkV29yayA9IDE7IC8vICAgICAgMGIwMDAwMDAwMVxuXG4vLyBZb3UgY2FuIGNoYW5nZSB0aGUgcmVzdCAoYW5kIGFkZCBtb3JlKS5cbnZhciBQbGFjZW1lbnQgPSAyOyAvLyAgICAgICAgICAwYjAwMDAwMDEwXG52YXIgVXBkYXRlID0gNDsgLy8gICAgICAgICAgICAgMGIwMDAwMDEwMFxudmFyIFBsYWNlbWVudEFuZFVwZGF0ZSA9IDY7IC8vIDBiMDAwMDAxMTBcbnZhciBEZWxldGlvbiA9IDg7IC8vICAgICAgICAgICAwYjAwMDAxMDAwXG52YXIgQ29udGVudFJlc2V0ID0gMTY7IC8vICAgICAgMGIwMDAxMDAwMFxudmFyIENhbGxiYWNrID0gMzI7IC8vICAgICAgICAgIDBiMDAxMDAwMDBcbnZhciBFcnIgPSA2NDsgLy8gICAgICAgICAgICAgICAwYjAxMDAwMDAwXG52YXIgUmVmID0gMTI4OyAvLyAgICAgICAgICAgICAgMGIxMDAwMDAwMFxuXG52YXIgTU9VTlRJTkcgPSAxO1xudmFyIE1PVU5URUQgPSAyO1xudmFyIFVOTU9VTlRFRCA9IDM7XG5cbmZ1bmN0aW9uIGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikge1xuICB2YXIgbm9kZSA9IGZpYmVyO1xuICBpZiAoIWZpYmVyLmFsdGVybmF0ZSkge1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIGFsdGVybmF0ZSwgdGhpcyBtaWdodCBiZSBhIG5ldyB0cmVlIHRoYXQgaXNuJ3QgaW5zZXJ0ZWRcbiAgICAvLyB5ZXQuIElmIGl0IGlzLCB0aGVuIGl0IHdpbGwgaGF2ZSBhIHBlbmRpbmcgaW5zZXJ0aW9uIGVmZmVjdCBvbiBpdC5cbiAgICBpZiAoKG5vZGUuZWZmZWN0VGFnICYgUGxhY2VtZW50KSAhPT0gTm9FZmZlY3QpIHtcbiAgICAgIHJldHVybiBNT1VOVElORztcbiAgICB9XG4gICAgd2hpbGUgKG5vZGVbJ3JldHVybiddKSB7XG4gICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBpZiAoKG5vZGUuZWZmZWN0VGFnICYgUGxhY2VtZW50KSAhPT0gTm9FZmZlY3QpIHtcbiAgICAgICAgcmV0dXJuIE1PVU5USU5HO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAobm9kZVsncmV0dXJuJ10pIHtcbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gIH1cbiAgaWYgKG5vZGUudGFnID09PSBIb3N0Um9vdCkge1xuICAgIC8vIFRPRE86IENoZWNrIGlmIHRoaXMgd2FzIGEgbmVzdGVkIEhvc3RSb290IHdoZW4gdXNlZCB3aXRoXG4gICAgLy8gcmVuZGVyQ29udGFpbmVySW50b1N1YnRyZWUuXG4gICAgcmV0dXJuIE1PVU5URUQ7XG4gIH1cbiAgLy8gSWYgd2UgZGlkbid0IGhpdCB0aGUgcm9vdCwgdGhhdCBtZWFucyB0aGF0IHdlJ3JlIGluIGFuIGRpc2Nvbm5lY3RlZCB0cmVlXG4gIC8vIHRoYXQgaGFzIGJlZW4gdW5tb3VudGVkLlxuICByZXR1cm4gVU5NT1VOVEVEO1xufVxuXG5mdW5jdGlvbiBpc0ZpYmVyTW91bnRlZChmaWJlcikge1xuICByZXR1cm4gaXNGaWJlck1vdW50ZWRJbXBsKGZpYmVyKSA9PT0gTU9VTlRFRDtcbn1cblxuZnVuY3Rpb24gaXNNb3VudGVkKGNvbXBvbmVudCkge1xuICB7XG4gICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICBpZiAob3duZXIgIT09IG51bGwgJiYgb3duZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgdmFyIG93bmVyRmliZXIgPSBvd25lcjtcbiAgICAgIHZhciBpbnN0YW5jZSA9IG93bmVyRmliZXIuc3RhdGVOb2RlO1xuICAgICAgd2FybmluZyhpbnN0YW5jZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIsICclcyBpcyBhY2Nlc3NpbmcgaXNNb3VudGVkIGluc2lkZSBpdHMgcmVuZGVyKCkgZnVuY3Rpb24uICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lKG93bmVyRmliZXIpIHx8ICdBIGNvbXBvbmVudCcpO1xuICAgICAgaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgZmliZXIgPSBnZXQoY29tcG9uZW50KTtcbiAgaWYgKCFmaWJlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNGaWJlck1vdW50ZWRJbXBsKGZpYmVyKSA9PT0gTU9VTlRFRDtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SXNNb3VudGVkKGZpYmVyKSB7XG4gICEoaXNGaWJlck1vdW50ZWRJbXBsKGZpYmVyKSA9PT0gTU9VTlRFRCkgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJykgOiB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKGZpYmVyKSB7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG4gIGlmICghYWx0ZXJuYXRlKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gYWx0ZXJuYXRlLCB0aGVuIHdlIG9ubHkgbmVlZCB0byBjaGVjayBpZiBpdCBpcyBtb3VudGVkLlxuICAgIHZhciBzdGF0ZSA9IGlzRmliZXJNb3VudGVkSW1wbChmaWJlcik7XG4gICAgIShzdGF0ZSAhPT0gVU5NT1VOVEVEKSA/IGludmFyaWFudChmYWxzZSwgJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKSA6IHZvaWQgMDtcbiAgICBpZiAoc3RhdGUgPT09IE1PVU5USU5HKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGZpYmVyO1xuICB9XG4gIC8vIElmIHdlIGhhdmUgdHdvIHBvc3NpYmxlIGJyYW5jaGVzLCB3ZSdsbCB3YWxrIGJhY2t3YXJkcyB1cCB0byB0aGUgcm9vdFxuICAvLyB0byBzZWUgd2hhdCBwYXRoIHRoZSByb290IHBvaW50cyB0by4gT24gdGhlIHdheSB3ZSBtYXkgaGl0IG9uZSBvZiB0aGVcbiAgLy8gc3BlY2lhbCBjYXNlcyBhbmQgd2UnbGwgZGVhbCB3aXRoIHRoZW0uXG4gIHZhciBhID0gZmliZXI7XG4gIHZhciBiID0gYWx0ZXJuYXRlO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBwYXJlbnRBID0gYVsncmV0dXJuJ107XG4gICAgdmFyIHBhcmVudEIgPSBwYXJlbnRBID8gcGFyZW50QS5hbHRlcm5hdGUgOiBudWxsO1xuICAgIGlmICghcGFyZW50QSB8fCAhcGFyZW50Qikge1xuICAgICAgLy8gV2UncmUgYXQgdGhlIHJvb3QuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBJZiBib3RoIGNvcGllcyBvZiB0aGUgcGFyZW50IGZpYmVyIHBvaW50IHRvIHRoZSBzYW1lIGNoaWxkLCB3ZSBjYW5cbiAgICAvLyBhc3N1bWUgdGhhdCB0aGUgY2hpbGQgaXMgY3VycmVudC4gVGhpcyBoYXBwZW5zIHdoZW4gd2UgYmFpbG91dCBvbiBsb3dcbiAgICAvLyBwcmlvcml0eTogdGhlIGJhaWxlZCBvdXQgZmliZXIncyBjaGlsZCByZXVzZXMgdGhlIGN1cnJlbnQgY2hpbGQuXG4gICAgaWYgKHBhcmVudEEuY2hpbGQgPT09IHBhcmVudEIuY2hpbGQpIHtcbiAgICAgIHZhciBjaGlsZCA9IHBhcmVudEEuY2hpbGQ7XG4gICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkID09PSBhKSB7XG4gICAgICAgICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEEgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgICAgICAgIGFzc2VydElzTW91bnRlZChwYXJlbnRBKTtcbiAgICAgICAgICByZXR1cm4gZmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkID09PSBiKSB7XG4gICAgICAgICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEIgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgICAgICAgIGFzc2VydElzTW91bnRlZChwYXJlbnRBKTtcbiAgICAgICAgICByZXR1cm4gYWx0ZXJuYXRlO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgIH1cbiAgICAgIC8vIFdlIHNob3VsZCBuZXZlciBoYXZlIGFuIGFsdGVybmF0ZSBmb3IgYW55IG1vdW50aW5nIG5vZGUuIFNvIHRoZSBvbmx5XG4gICAgICAvLyB3YXkgdGhpcyBjb3VsZCBwb3NzaWJseSBoYXBwZW4gaXMgaWYgdGhpcyB3YXMgdW5tb3VudGVkLCBpZiBhdCBhbGwuXG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgfVxuXG4gICAgaWYgKGFbJ3JldHVybiddICE9PSBiWydyZXR1cm4nXSkge1xuICAgICAgLy8gVGhlIHJldHVybiBwb2ludGVyIG9mIEEgYW5kIHRoZSByZXR1cm4gcG9pbnRlciBvZiBCIHBvaW50IHRvIGRpZmZlcmVudFxuICAgICAgLy8gZmliZXJzLiBXZSBhc3N1bWUgdGhhdCByZXR1cm4gcG9pbnRlcnMgbmV2ZXIgY3Jpc3MtY3Jvc3MsIHNvIEEgbXVzdFxuICAgICAgLy8gYmVsb25nIHRvIHRoZSBjaGlsZCBzZXQgb2YgQS5yZXR1cm4sIGFuZCBCIG11c3QgYmVsb25nIHRvIHRoZSBjaGlsZFxuICAgICAgLy8gc2V0IG9mIEIucmV0dXJuLlxuICAgICAgYSA9IHBhcmVudEE7XG4gICAgICBiID0gcGFyZW50QjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIHJldHVybiBwb2ludGVycyBwb2ludCB0byB0aGUgc2FtZSBmaWJlci4gV2UnbGwgaGF2ZSB0byB1c2UgdGhlXG4gICAgICAvLyBkZWZhdWx0LCBzbG93IHBhdGg6IHNjYW4gdGhlIGNoaWxkIHNldHMgb2YgZWFjaCBwYXJlbnQgYWx0ZXJuYXRlIHRvIHNlZVxuICAgICAgLy8gd2hpY2ggY2hpbGQgYmVsb25ncyB0byB3aGljaCBzZXQuXG4gICAgICAvL1xuICAgICAgLy8gU2VhcmNoIHBhcmVudCBBJ3MgY2hpbGQgc2V0XG4gICAgICB2YXIgZGlkRmluZENoaWxkID0gZmFsc2U7XG4gICAgICB2YXIgX2NoaWxkID0gcGFyZW50QS5jaGlsZDtcbiAgICAgIHdoaWxlIChfY2hpbGQpIHtcbiAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9jaGlsZCA9PT0gYikge1xuICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgYSA9IHBhcmVudEI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgX2NoaWxkID0gX2NoaWxkLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICBpZiAoIWRpZEZpbmRDaGlsZCkge1xuICAgICAgICAvLyBTZWFyY2ggcGFyZW50IEIncyBjaGlsZCBzZXRcbiAgICAgICAgX2NoaWxkID0gcGFyZW50Qi5jaGlsZDtcbiAgICAgICAgd2hpbGUgKF9jaGlsZCkge1xuICAgICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChfY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgICBiID0gcGFyZW50QjtcbiAgICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgICFkaWRGaW5kQ2hpbGQgPyBpbnZhcmlhbnQoZmFsc2UsICdDaGlsZCB3YXMgbm90IGZvdW5kIGluIGVpdGhlciBwYXJlbnQgc2V0LiBUaGlzIGluZGljYXRlcyBhIGJ1ZyBpbiBSZWFjdCByZWxhdGVkIHRvIHRoZSByZXR1cm4gcG9pbnRlci4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgIShhLmFsdGVybmF0ZSA9PT0gYikgPyBpbnZhcmlhbnQoZmFsc2UsICdSZXR1cm4gZmliZXJzIHNob3VsZCBhbHdheXMgYmUgZWFjaCBvdGhlcnNcXCcgYWx0ZXJuYXRlcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgfVxuICAvLyBJZiB0aGUgcm9vdCBpcyBub3QgYSBob3N0IGNvbnRhaW5lciwgd2UncmUgaW4gYSBkaXNjb25uZWN0ZWQgdHJlZS4gSS5lLlxuICAvLyB1bm1vdW50ZWQuXG4gICEoYS50YWcgPT09IEhvc3RSb290KSA/IGludmFyaWFudChmYWxzZSwgJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKSA6IHZvaWQgMDtcbiAgaWYgKGEuc3RhdGVOb2RlLmN1cnJlbnQgPT09IGEpIHtcbiAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQSBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgcmV0dXJuIGZpYmVyO1xuICB9XG4gIC8vIE90aGVyd2lzZSBCIGhhcyB0byBiZSBjdXJyZW50IGJyYW5jaC5cbiAgcmV0dXJuIGFsdGVybmF0ZTtcbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXIocGFyZW50KSB7XG4gIHZhciBjdXJyZW50UGFyZW50ID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgocGFyZW50KTtcbiAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBOZXh0IHdlJ2xsIGRyaWxsIGRvd24gdGhpcyBjb21wb25lbnQgdG8gZmluZCB0aGUgZmlyc3QgSG9zdENvbXBvbmVudC9UZXh0LlxuICB2YXIgbm9kZSA9IGN1cnJlbnRQYXJlbnQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkKSB7XG4gICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobm9kZSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHdoaWxlICghbm9kZS5zaWJsaW5nKSB7XG4gICAgICBpZiAoIW5vZGVbJ3JldHVybiddIHx8IG5vZGVbJ3JldHVybiddID09PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgIH1cbiAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxuICAvLyBGbG93IG5lZWRzIHRoZSByZXR1cm4gbnVsbCBoZXJlLCBidXQgRVNMaW50IGNvbXBsYWlucyBhYm91dCBpdC5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVucmVhY2hhYmxlXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHMocGFyZW50KSB7XG4gIHZhciBjdXJyZW50UGFyZW50ID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgocGFyZW50KTtcbiAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBOZXh0IHdlJ2xsIGRyaWxsIGRvd24gdGhpcyBjb21wb25lbnQgdG8gZmluZCB0aGUgZmlyc3QgSG9zdENvbXBvbmVudC9UZXh0LlxuICB2YXIgbm9kZSA9IGN1cnJlbnRQYXJlbnQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICYmIG5vZGUudGFnICE9PSBIb3N0UG9ydGFsKSB7XG4gICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobm9kZSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHdoaWxlICghbm9kZS5zaWJsaW5nKSB7XG4gICAgICBpZiAoIW5vZGVbJ3JldHVybiddIHx8IG5vZGVbJ3JldHVybiddID09PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgIH1cbiAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxuICAvLyBGbG93IG5lZWRzIHRoZSByZXR1cm4gbnVsbCBoZXJlLCBidXQgRVNMaW50IGNvbXBsYWlucyBhYm91dCBpdC5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVucmVhY2hhYmxlXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgQ0FMTEJBQ0tfQk9PS0tFRVBJTkdfUE9PTF9TSVpFID0gMTA7XG52YXIgY2FsbGJhY2tCb29ra2VlcGluZ1Bvb2wgPSBbXTtcblxuLyoqXG4gKiBGaW5kIHRoZSBkZWVwZXN0IFJlYWN0IGNvbXBvbmVudCBjb21wbGV0ZWx5IGNvbnRhaW5pbmcgdGhlIHJvb3Qgb2YgdGhlXG4gKiBwYXNzZWQtaW4gaW5zdGFuY2UgKGZvciB1c2Ugd2hlbiBlbnRpcmUgUmVhY3QgdHJlZXMgYXJlIG5lc3RlZCB3aXRoaW4gZWFjaFxuICogb3RoZXIpLiBJZiBSZWFjdCB0cmVlcyBhcmUgbm90IG5lc3RlZCwgcmV0dXJucyBudWxsLlxuICovXG5mdW5jdGlvbiBmaW5kUm9vdENvbnRhaW5lck5vZGUoaW5zdCkge1xuICAvLyBUT0RPOiBJdCBtYXkgYmUgYSBnb29kIGlkZWEgdG8gY2FjaGUgdGhpcyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IERPTVxuICAvLyB0cmF2ZXJzYWwsIGJ1dCBjYWNoaW5nIGlzIGRpZmZpY3VsdCB0byBkbyBjb3JyZWN0bHkgd2l0aG91dCB1c2luZyBhXG4gIC8vIG11dGF0aW9uIG9ic2VydmVyIHRvIGxpc3RlbiBmb3IgYWxsIERPTSBjaGFuZ2VzLlxuICB3aGlsZSAoaW5zdFsncmV0dXJuJ10pIHtcbiAgICBpbnN0ID0gaW5zdFsncmV0dXJuJ107XG4gIH1cbiAgaWYgKGluc3QudGFnICE9PSBIb3N0Um9vdCkge1xuICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB3ZSdyZSBpbiBhIGRldGFjaGVkIHRyZWUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGluc3Quc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG59XG5cbi8vIFVzZWQgdG8gc3RvcmUgYW5jZXN0b3IgaGllcmFyY2h5IGluIHRvcCBsZXZlbCBjYWxsYmFja1xuZnVuY3Rpb24gZ2V0VG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQsIHRhcmdldEluc3QpIHtcbiAgaWYgKGNhbGxiYWNrQm9va2tlZXBpbmdQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IGNhbGxiYWNrQm9va2tlZXBpbmdQb29sLnBvcCgpO1xuICAgIGluc3RhbmNlLnRvcExldmVsVHlwZSA9IHRvcExldmVsVHlwZTtcbiAgICBpbnN0YW5jZS5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICAgIGluc3RhbmNlLnRhcmdldEluc3QgPSB0YXJnZXRJbnN0O1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHRvcExldmVsVHlwZTogdG9wTGV2ZWxUeXBlLFxuICAgIG5hdGl2ZUV2ZW50OiBuYXRpdmVFdmVudCxcbiAgICB0YXJnZXRJbnN0OiB0YXJnZXRJbnN0LFxuICAgIGFuY2VzdG9yczogW11cbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVsZWFzZVRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyhpbnN0YW5jZSkge1xuICBpbnN0YW5jZS50b3BMZXZlbFR5cGUgPSBudWxsO1xuICBpbnN0YW5jZS5uYXRpdmVFdmVudCA9IG51bGw7XG4gIGluc3RhbmNlLnRhcmdldEluc3QgPSBudWxsO1xuICBpbnN0YW5jZS5hbmNlc3RvcnMubGVuZ3RoID0gMDtcbiAgaWYgKGNhbGxiYWNrQm9va2tlZXBpbmdQb29sLmxlbmd0aCA8IENBTExCQUNLX0JPT0tLRUVQSU5HX1BPT0xfU0laRSkge1xuICAgIGNhbGxiYWNrQm9va2tlZXBpbmdQb29sLnB1c2goaW5zdGFuY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVRvcExldmVsSW1wbChib29rS2VlcGluZykge1xuICB2YXIgdGFyZ2V0SW5zdCA9IGJvb2tLZWVwaW5nLnRhcmdldEluc3Q7XG5cbiAgLy8gTG9vcCB0aHJvdWdoIHRoZSBoaWVyYXJjaHksIGluIGNhc2UgdGhlcmUncyBhbnkgbmVzdGVkIGNvbXBvbmVudHMuXG4gIC8vIEl0J3MgaW1wb3J0YW50IHRoYXQgd2UgYnVpbGQgdGhlIGFycmF5IG9mIGFuY2VzdG9ycyBiZWZvcmUgY2FsbGluZyBhbnlcbiAgLy8gZXZlbnQgaGFuZGxlcnMsIGJlY2F1c2UgZXZlbnQgaGFuZGxlcnMgY2FuIG1vZGlmeSB0aGUgRE9NLCBsZWFkaW5nIHRvXG4gIC8vIGluY29uc2lzdGVuY2llcyB3aXRoIFJlYWN0TW91bnQncyBub2RlIGNhY2hlLiBTZWUgIzExMDUuXG4gIHZhciBhbmNlc3RvciA9IHRhcmdldEluc3Q7XG4gIGRvIHtcbiAgICBpZiAoIWFuY2VzdG9yKSB7XG4gICAgICBib29rS2VlcGluZy5hbmNlc3RvcnMucHVzaChhbmNlc3Rvcik7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIHJvb3QgPSBmaW5kUm9vdENvbnRhaW5lck5vZGUoYW5jZXN0b3IpO1xuICAgIGlmICghcm9vdCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5wdXNoKGFuY2VzdG9yKTtcbiAgICBhbmNlc3RvciA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHJvb3QpO1xuICB9IHdoaWxlIChhbmNlc3Rvcik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBib29rS2VlcGluZy5hbmNlc3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICB0YXJnZXRJbnN0ID0gYm9va0tlZXBpbmcuYW5jZXN0b3JzW2ldO1xuICAgIF9oYW5kbGVUb3BMZXZlbChib29rS2VlcGluZy50b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChib29rS2VlcGluZy5uYXRpdmVFdmVudCkpO1xuICB9XG59XG5cbi8vIFRPRE86IGNhbiB3ZSBzdG9wIGV4cG9ydGluZyB0aGVzZT9cbnZhciBfZW5hYmxlZCA9IHRydWU7XG52YXIgX2hhbmRsZVRvcExldmVsID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBzZXRIYW5kbGVUb3BMZXZlbChoYW5kbGVUb3BMZXZlbCkge1xuICBfaGFuZGxlVG9wTGV2ZWwgPSBoYW5kbGVUb3BMZXZlbDtcbn1cblxuZnVuY3Rpb24gc2V0RW5hYmxlZChlbmFibGVkKSB7XG4gIF9lbmFibGVkID0gISFlbmFibGVkO1xufVxuXG5mdW5jdGlvbiBpc0VuYWJsZWQoKSB7XG4gIHJldHVybiBfZW5hYmxlZDtcbn1cblxuLyoqXG4gKiBUcmFwcyB0b3AtbGV2ZWwgZXZlbnRzIGJ5IHVzaW5nIGV2ZW50IGJ1YmJsaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEJyb3dzZXJFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFuZGxlckJhc2VOYW1lIEV2ZW50IG5hbWUgKGUuZy4gXCJjbGlja1wiKS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50IEVsZW1lbnQgb24gd2hpY2ggdG8gYXR0YWNoIGxpc3RlbmVyLlxuICogQHJldHVybiB7P29iamVjdH0gQW4gb2JqZWN0IHdpdGggYSByZW1vdmUgZnVuY3Rpb24gd2hpY2ggd2lsbCBmb3JjZWZ1bGx5XG4gKiAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgZWxlbWVudCkge1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gRXZlbnRMaXN0ZW5lci5saXN0ZW4oZWxlbWVudCwgaGFuZGxlckJhc2VOYW1lLCBkaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgdG9wTGV2ZWxUeXBlKSk7XG59XG5cbi8qKlxuICogVHJhcHMgYSB0b3AtbGV2ZWwgZXZlbnQgYnkgdXNpbmcgZXZlbnQgY2FwdHVyaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEJyb3dzZXJFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFuZGxlckJhc2VOYW1lIEV2ZW50IG5hbWUgKGUuZy4gXCJjbGlja1wiKS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50IEVsZW1lbnQgb24gd2hpY2ggdG8gYXR0YWNoIGxpc3RlbmVyLlxuICogQHJldHVybiB7P29iamVjdH0gQW4gb2JqZWN0IHdpdGggYSByZW1vdmUgZnVuY3Rpb24gd2hpY2ggd2lsbCBmb3JjZWZ1bGx5XG4gKiAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdHJhcENhcHR1cmVkRXZlbnQodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIEV2ZW50TGlzdGVuZXIuY2FwdHVyZShlbGVtZW50LCBoYW5kbGVyQmFzZU5hbWUsIGRpc3BhdGNoRXZlbnQuYmluZChudWxsLCB0b3BMZXZlbFR5cGUpKTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIGlmICghX2VuYWJsZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbmF0aXZlRXZlbnRUYXJnZXQgPSBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCk7XG4gIHZhciB0YXJnZXRJbnN0ID0gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobmF0aXZlRXZlbnRUYXJnZXQpO1xuICBpZiAodGFyZ2V0SW5zdCAhPT0gbnVsbCAmJiB0eXBlb2YgdGFyZ2V0SW5zdC50YWcgPT09ICdudW1iZXInICYmICFpc0ZpYmVyTW91bnRlZCh0YXJnZXRJbnN0KSkge1xuICAgIC8vIElmIHdlIGdldCBhbiBldmVudCAoZXg6IGltZyBvbmxvYWQpIGJlZm9yZSBjb21taXR0aW5nIHRoYXRcbiAgICAvLyBjb21wb25lbnQncyBtb3VudCwgaWdub3JlIGl0IGZvciBub3cgKHRoYXQgaXMsIHRyZWF0IGl0IGFzIGlmIGl0IHdhcyBhblxuICAgIC8vIGV2ZW50IG9uIGEgbm9uLVJlYWN0IHRyZWUpLiBXZSBtaWdodCBhbHNvIGNvbnNpZGVyIHF1ZXVlaW5nIGV2ZW50cyBhbmRcbiAgICAvLyBkaXNwYXRjaGluZyB0aGVtIGFmdGVyIHRoZSBtb3VudC5cbiAgICB0YXJnZXRJbnN0ID0gbnVsbDtcbiAgfVxuXG4gIHZhciBib29rS2VlcGluZyA9IGdldFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50LCB0YXJnZXRJbnN0KTtcblxuICB0cnkge1xuICAgIC8vIEV2ZW50IHF1ZXVlIGJlaW5nIHByb2Nlc3NlZCBpbiB0aGUgc2FtZSBjeWNsZSBhbGxvd3NcbiAgICAvLyBgcHJldmVudERlZmF1bHRgLlxuICAgIGJhdGNoZWRVcGRhdGVzKGhhbmRsZVRvcExldmVsSW1wbCwgYm9va0tlZXBpbmcpO1xuICB9IGZpbmFsbHkge1xuICAgIHJlbGVhc2VUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcoYm9va0tlZXBpbmcpO1xuICB9XG59XG5cbnZhciBSZWFjdERPTUV2ZW50TGlzdGVuZXIgPSBPYmplY3QuZnJlZXplKHtcblx0Z2V0IF9lbmFibGVkICgpIHsgcmV0dXJuIF9lbmFibGVkOyB9LFxuXHRnZXQgX2hhbmRsZVRvcExldmVsICgpIHsgcmV0dXJuIF9oYW5kbGVUb3BMZXZlbDsgfSxcblx0c2V0SGFuZGxlVG9wTGV2ZWw6IHNldEhhbmRsZVRvcExldmVsLFxuXHRzZXRFbmFibGVkOiBzZXRFbmFibGVkLFxuXHRpc0VuYWJsZWQ6IGlzRW5hYmxlZCxcblx0dHJhcEJ1YmJsZWRFdmVudDogdHJhcEJ1YmJsZWRFdmVudCxcblx0dHJhcENhcHR1cmVkRXZlbnQ6IHRyYXBDYXB0dXJlZEV2ZW50LFxuXHRkaXNwYXRjaEV2ZW50OiBkaXNwYXRjaEV2ZW50XG59KTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIG1hcHBpbmcgb2Ygc3RhbmRhcmQgdmVuZG9yIHByZWZpeGVzIHVzaW5nIHRoZSBkZWZpbmVkIHN0eWxlIHByb3BlcnR5IGFuZCBldmVudCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZVByb3BcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIG1ha2VQcmVmaXhNYXAoc3R5bGVQcm9wLCBldmVudE5hbWUpIHtcbiAgdmFyIHByZWZpeGVzID0ge307XG5cbiAgcHJlZml4ZXNbc3R5bGVQcm9wLnRvTG93ZXJDYXNlKCldID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHByZWZpeGVzWydXZWJraXQnICsgc3R5bGVQcm9wXSA9ICd3ZWJraXQnICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snTW96JyArIHN0eWxlUHJvcF0gPSAnbW96JyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ21zJyArIHN0eWxlUHJvcF0gPSAnTVMnICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snTycgKyBzdHlsZVByb3BdID0gJ28nICsgZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgcmV0dXJuIHByZWZpeGVzO1xufVxuXG4vKipcbiAqIEEgbGlzdCBvZiBldmVudCBuYW1lcyB0byBhIGNvbmZpZ3VyYWJsZSBsaXN0IG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xudmFyIHZlbmRvclByZWZpeGVzID0ge1xuICBhbmltYXRpb25lbmQ6IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25FbmQnKSxcbiAgYW5pbWF0aW9uaXRlcmF0aW9uOiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uSXRlcmF0aW9uJyksXG4gIGFuaW1hdGlvbnN0YXJ0OiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uU3RhcnQnKSxcbiAgdHJhbnNpdGlvbmVuZDogbWFrZVByZWZpeE1hcCgnVHJhbnNpdGlvbicsICdUcmFuc2l0aW9uRW5kJylcbn07XG5cbi8qKlxuICogRXZlbnQgbmFtZXMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBkZXRlY3RlZCBhbmQgcHJlZml4ZWQgKGlmIGFwcGxpY2FibGUpLlxuICovXG52YXIgcHJlZml4ZWRFdmVudE5hbWVzID0ge307XG5cbi8qKlxuICogRWxlbWVudCB0byBjaGVjayBmb3IgcHJlZml4ZXMgb24uXG4gKi9cbnZhciBzdHlsZSA9IHt9O1xuXG4vKipcbiAqIEJvb3RzdHJhcCBpZiBhIERPTSBleGlzdHMuXG4gKi9cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcblxuICAvLyBPbiBzb21lIHBsYXRmb3JtcywgaW4gcGFydGljdWxhciBzb21lIHJlbGVhc2VzIG9mIEFuZHJvaWQgNC54LFxuICAvLyB0aGUgdW4tcHJlZml4ZWQgXCJhbmltYXRpb25cIiBhbmQgXCJ0cmFuc2l0aW9uXCIgcHJvcGVydGllcyBhcmUgZGVmaW5lZCBvbiB0aGVcbiAgLy8gc3R5bGUgb2JqZWN0IGJ1dCB0aGUgZXZlbnRzIHRoYXQgZmlyZSB3aWxsIHN0aWxsIGJlIHByZWZpeGVkLCBzbyB3ZSBuZWVkXG4gIC8vIHRvIGNoZWNrIGlmIHRoZSB1bi1wcmVmaXhlZCBldmVudHMgYXJlIHVzYWJsZSwgYW5kIGlmIG5vdCByZW1vdmUgdGhlbSBmcm9tIHRoZSBtYXAuXG4gIGlmICghKCdBbmltYXRpb25FdmVudCcgaW4gd2luZG93KSkge1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25lbmQuYW5pbWF0aW9uO1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25pdGVyYXRpb24uYW5pbWF0aW9uO1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25zdGFydC5hbmltYXRpb247XG4gIH1cblxuICAvLyBTYW1lIGFzIGFib3ZlXG4gIGlmICghKCdUcmFuc2l0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMudHJhbnNpdGlvbmVuZC50cmFuc2l0aW9uO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gZGV0ZXJtaW5lIHRoZSBjb3JyZWN0IHZlbmRvciBwcmVmaXhlZCBldmVudCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKGV2ZW50TmFtZSkge1xuICBpZiAocHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV07XG4gIH0gZWxzZSBpZiAoIXZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gZXZlbnROYW1lO1xuICB9XG5cbiAgdmFyIHByZWZpeE1hcCA9IHZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV07XG5cbiAgZm9yICh2YXIgc3R5bGVQcm9wIGluIHByZWZpeE1hcCkge1xuICAgIGlmIChwcmVmaXhNYXAuaGFzT3duUHJvcGVydHkoc3R5bGVQcm9wKSAmJiBzdHlsZVByb3AgaW4gc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXSA9IHByZWZpeE1hcFtzdHlsZVByb3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBUeXBlcyBvZiByYXcgc2lnbmFscyBmcm9tIHRoZSBicm93c2VyIGNhdWdodCBhdCB0aGUgdG9wIGxldmVsLlxuICpcbiAqIEZvciBldmVudHMgbGlrZSAnc3VibWl0JyB3aGljaCBkb24ndCBjb25zaXN0ZW50bHkgYnViYmxlICh3aGljaCB3ZVxuICogdHJhcCBhdCBhIGxvd2VyIG5vZGUgdGhhbiBgZG9jdW1lbnRgKSwgYmluZGluZyBhdCBgZG9jdW1lbnRgIHdvdWxkXG4gKiBjYXVzZSBkdXBsaWNhdGUgZXZlbnRzIHNvIHdlIGRvbid0IGluY2x1ZGUgdGhlbSBoZXJlLlxuICovXG52YXIgdG9wTGV2ZWxUeXBlcyQxID0ge1xuICB0b3BBYm9ydDogJ2Fib3J0JyxcbiAgdG9wQW5pbWF0aW9uRW5kOiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uZW5kJykgfHwgJ2FuaW1hdGlvbmVuZCcsXG4gIHRvcEFuaW1hdGlvbkl0ZXJhdGlvbjogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbml0ZXJhdGlvbicpIHx8ICdhbmltYXRpb25pdGVyYXRpb24nLFxuICB0b3BBbmltYXRpb25TdGFydDogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbnN0YXJ0JykgfHwgJ2FuaW1hdGlvbnN0YXJ0JyxcbiAgdG9wQmx1cjogJ2JsdXInLFxuICB0b3BDYW5jZWw6ICdjYW5jZWwnLFxuICB0b3BDYW5QbGF5OiAnY2FucGxheScsXG4gIHRvcENhblBsYXlUaHJvdWdoOiAnY2FucGxheXRocm91Z2gnLFxuICB0b3BDaGFuZ2U6ICdjaGFuZ2UnLFxuICB0b3BDbGljazogJ2NsaWNrJyxcbiAgdG9wQ2xvc2U6ICdjbG9zZScsXG4gIHRvcENvbXBvc2l0aW9uRW5kOiAnY29tcG9zaXRpb25lbmQnLFxuICB0b3BDb21wb3NpdGlvblN0YXJ0OiAnY29tcG9zaXRpb25zdGFydCcsXG4gIHRvcENvbXBvc2l0aW9uVXBkYXRlOiAnY29tcG9zaXRpb251cGRhdGUnLFxuICB0b3BDb250ZXh0TWVudTogJ2NvbnRleHRtZW51JyxcbiAgdG9wQ29weTogJ2NvcHknLFxuICB0b3BDdXQ6ICdjdXQnLFxuICB0b3BEb3VibGVDbGljazogJ2RibGNsaWNrJyxcbiAgdG9wRHJhZzogJ2RyYWcnLFxuICB0b3BEcmFnRW5kOiAnZHJhZ2VuZCcsXG4gIHRvcERyYWdFbnRlcjogJ2RyYWdlbnRlcicsXG4gIHRvcERyYWdFeGl0OiAnZHJhZ2V4aXQnLFxuICB0b3BEcmFnTGVhdmU6ICdkcmFnbGVhdmUnLFxuICB0b3BEcmFnT3ZlcjogJ2RyYWdvdmVyJyxcbiAgdG9wRHJhZ1N0YXJ0OiAnZHJhZ3N0YXJ0JyxcbiAgdG9wRHJvcDogJ2Ryb3AnLFxuICB0b3BEdXJhdGlvbkNoYW5nZTogJ2R1cmF0aW9uY2hhbmdlJyxcbiAgdG9wRW1wdGllZDogJ2VtcHRpZWQnLFxuICB0b3BFbmNyeXB0ZWQ6ICdlbmNyeXB0ZWQnLFxuICB0b3BFbmRlZDogJ2VuZGVkJyxcbiAgdG9wRXJyb3I6ICdlcnJvcicsXG4gIHRvcEZvY3VzOiAnZm9jdXMnLFxuICB0b3BJbnB1dDogJ2lucHV0JyxcbiAgdG9wS2V5RG93bjogJ2tleWRvd24nLFxuICB0b3BLZXlQcmVzczogJ2tleXByZXNzJyxcbiAgdG9wS2V5VXA6ICdrZXl1cCcsXG4gIHRvcExvYWRlZERhdGE6ICdsb2FkZWRkYXRhJyxcbiAgdG9wTG9hZDogJ2xvYWQnLFxuICB0b3BMb2FkZWRNZXRhZGF0YTogJ2xvYWRlZG1ldGFkYXRhJyxcbiAgdG9wTG9hZFN0YXJ0OiAnbG9hZHN0YXJ0JyxcbiAgdG9wTW91c2VEb3duOiAnbW91c2Vkb3duJyxcbiAgdG9wTW91c2VNb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgdG9wTW91c2VPdXQ6ICdtb3VzZW91dCcsXG4gIHRvcE1vdXNlT3ZlcjogJ21vdXNlb3ZlcicsXG4gIHRvcE1vdXNlVXA6ICdtb3VzZXVwJyxcbiAgdG9wUGFzdGU6ICdwYXN0ZScsXG4gIHRvcFBhdXNlOiAncGF1c2UnLFxuICB0b3BQbGF5OiAncGxheScsXG4gIHRvcFBsYXlpbmc6ICdwbGF5aW5nJyxcbiAgdG9wUHJvZ3Jlc3M6ICdwcm9ncmVzcycsXG4gIHRvcFJhdGVDaGFuZ2U6ICdyYXRlY2hhbmdlJyxcbiAgdG9wU2Nyb2xsOiAnc2Nyb2xsJyxcbiAgdG9wU2Vla2VkOiAnc2Vla2VkJyxcbiAgdG9wU2Vla2luZzogJ3NlZWtpbmcnLFxuICB0b3BTZWxlY3Rpb25DaGFuZ2U6ICdzZWxlY3Rpb25jaGFuZ2UnLFxuICB0b3BTdGFsbGVkOiAnc3RhbGxlZCcsXG4gIHRvcFN1c3BlbmQ6ICdzdXNwZW5kJyxcbiAgdG9wVGV4dElucHV0OiAndGV4dElucHV0JyxcbiAgdG9wVGltZVVwZGF0ZTogJ3RpbWV1cGRhdGUnLFxuICB0b3BUb2dnbGU6ICd0b2dnbGUnLFxuICB0b3BUb3VjaENhbmNlbDogJ3RvdWNoY2FuY2VsJyxcbiAgdG9wVG91Y2hFbmQ6ICd0b3VjaGVuZCcsXG4gIHRvcFRvdWNoTW92ZTogJ3RvdWNobW92ZScsXG4gIHRvcFRvdWNoU3RhcnQ6ICd0b3VjaHN0YXJ0JyxcbiAgdG9wVHJhbnNpdGlvbkVuZDogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ3RyYW5zaXRpb25lbmQnKSB8fCAndHJhbnNpdGlvbmVuZCcsXG4gIHRvcFZvbHVtZUNoYW5nZTogJ3ZvbHVtZWNoYW5nZScsXG4gIHRvcFdhaXRpbmc6ICd3YWl0aW5nJyxcbiAgdG9wV2hlZWw6ICd3aGVlbCdcbn07XG5cbnZhciBCcm93c2VyRXZlbnRDb25zdGFudHMgPSB7XG4gIHRvcExldmVsVHlwZXM6IHRvcExldmVsVHlwZXMkMVxufTtcblxuZnVuY3Rpb24gcnVuRXZlbnRRdWV1ZUluQmF0Y2goZXZlbnRzKSB7XG4gIGVucXVldWVFdmVudHMoZXZlbnRzKTtcbiAgcHJvY2Vzc0V2ZW50UXVldWUoZmFsc2UpO1xufVxuXG4vKipcbiAqIFN0cmVhbXMgYSBmaXJlZCB0b3AtbGV2ZWwgZXZlbnQgdG8gYEV2ZW50UGx1Z2luSHViYCB3aGVyZSBwbHVnaW5zIGhhdmUgdGhlXG4gKiBvcHBvcnR1bml0eSB0byBjcmVhdGUgYFJlYWN0RXZlbnRgcyB0byBiZSBkaXNwYXRjaGVkLlxuICovXG5mdW5jdGlvbiBoYW5kbGVUb3BMZXZlbCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgZXZlbnRzID0gZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gIHJ1bkV2ZW50UXVldWVJbkJhdGNoKGV2ZW50cyk7XG59XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gQnJvd3NlckV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbi8qKlxuICogU3VtbWFyeSBvZiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBldmVudCBoYW5kbGluZzpcbiAqXG4gKiAgLSBUb3AtbGV2ZWwgZGVsZWdhdGlvbiBpcyB1c2VkIHRvIHRyYXAgbW9zdCBuYXRpdmUgYnJvd3NlciBldmVudHMuIFRoaXNcbiAqICAgIG1heSBvbmx5IG9jY3VyIGluIHRoZSBtYWluIHRocmVhZCBhbmQgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mXG4gKiAgICBSZWFjdERPTUV2ZW50TGlzdGVuZXIsIHdoaWNoIGlzIGluamVjdGVkIGFuZCBjYW4gdGhlcmVmb3JlIHN1cHBvcnRcbiAqICAgIHBsdWdnYWJsZSBldmVudCBzb3VyY2VzLiBUaGlzIGlzIHRoZSBvbmx5IHdvcmsgdGhhdCBvY2N1cnMgaW4gdGhlIG1haW5cbiAqICAgIHRocmVhZC5cbiAqXG4gKiAgLSBXZSBub3JtYWxpemUgYW5kIGRlLWR1cGxpY2F0ZSBldmVudHMgdG8gYWNjb3VudCBmb3IgYnJvd3NlciBxdWlya3MuIFRoaXNcbiAqICAgIG1heSBiZSBkb25lIGluIHRoZSB3b3JrZXIgdGhyZWFkLlxuICpcbiAqICAtIEZvcndhcmQgdGhlc2UgbmF0aXZlIGV2ZW50cyAod2l0aCB0aGUgYXNzb2NpYXRlZCB0b3AtbGV2ZWwgdHlwZSB1c2VkIHRvXG4gKiAgICB0cmFwIGl0KSB0byBgRXZlbnRQbHVnaW5IdWJgLCB3aGljaCBpbiB0dXJuIHdpbGwgYXNrIHBsdWdpbnMgaWYgdGhleSB3YW50XG4gKiAgICB0byBleHRyYWN0IGFueSBzeW50aGV0aWMgZXZlbnRzLlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHdpbGwgdGhlbiBwcm9jZXNzIGVhY2ggZXZlbnQgYnkgYW5ub3RhdGluZyB0aGVtIHdpdGhcbiAqICAgIFwiZGlzcGF0Y2hlc1wiLCBhIHNlcXVlbmNlIG9mIGxpc3RlbmVycyBhbmQgSURzIHRoYXQgY2FyZSBhYm91dCB0aGF0IGV2ZW50LlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHRoZW4gZGlzcGF0Y2hlcyB0aGUgZXZlbnRzLlxuICpcbiAqIE92ZXJ2aWV3IG9mIFJlYWN0IGFuZCB0aGUgZXZlbnQgc3lzdGVtOlxuICpcbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgICAgRE9NICAgICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqICAgICAgIHwgICAgICAgICAgIC5cbiAqICAgICAgIHYgICAgICAgICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgUmVhY3RFdmVudCB8ICAgIC5cbiAqIHwgIExpc3RlbmVyICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgICstLS0tLS0tLSt8U2ltcGxlRXZlbnR8XG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgfCAgICAgICAgIHxQbHVnaW4gICAgIHxcbiAqICstLS0tLXwtLS0tLS0rICAgIC4gICAgICAgICAgICAgICB2ICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58RXZlbnRQbHVnaW5IdWJ8ICAgICAgICAgICAgICAgICAgICB8ICAgIEV2ZW50ICAgfFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8IFByb3BhZ2F0b3JzfFxuICogfCBSZWFjdEV2ZW50IHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICB8VGFwRXZlbnQgICB8ICB8LS0tLS0tLS0tLS0tfFxuICogfCAgRW1pdHRlciAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8PC0tLSt8UGx1Z2luICAgICB8ICB8b3RoZXIgcGx1Z2lufFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8ICB1dGlsaXRpZXMgfFxuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rXG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgIF4gICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICAgfCAgICAgICAgfEVudGVyL0xlYXZlfFxuICogICAgICAgKyAgICAgICAgICAgLiAgICAgICAgICAgICAgICArLS0tLS0tLSt8UGx1Z2luICAgICB8XG4gKiArLS0tLS0tLS0tLS0tLSsgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgYXBwbGljYXRpb24gfCAgIC5cbiAqIHwtLS0tLS0tLS0tLS0tfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqICstLS0tLS0tLS0tLS0tKyAgIC5cbiAqICAgICAgICAgICAgICAgICAgIC5cbiAqICAgIFJlYWN0IENvcmUgICAgIC4gIEdlbmVyYWwgUHVycG9zZSBFdmVudCBQbHVnaW4gU3lzdGVtXG4gKi9cblxudmFyIGFscmVhZHlMaXN0ZW5pbmdUbyA9IHt9O1xudmFyIHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlciA9IDA7XG5cbi8qKlxuICogVG8gZW5zdXJlIG5vIGNvbmZsaWN0cyB3aXRoIG90aGVyIHBvdGVudGlhbCBSZWFjdCBpbnN0YW5jZXMgb24gdGhlIHBhZ2VcbiAqL1xudmFyIHRvcExpc3RlbmVyc0lES2V5ID0gJ19yZWFjdExpc3RlbmVyc0lEJyArICgnJyArIE1hdGgucmFuZG9tKCkpLnNsaWNlKDIpO1xuXG5mdW5jdGlvbiBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KSB7XG4gIC8vIEluIElFOCwgYG1vdW50QXRgIGlzIGEgaG9zdCBvYmplY3QgYW5kIGRvZXNuJ3QgaGF2ZSBgaGFzT3duUHJvcGVydHlgXG4gIC8vIGRpcmVjdGx5LlxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb3VudEF0LCB0b3BMaXN0ZW5lcnNJREtleSkpIHtcbiAgICBtb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XSA9IHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlcisrO1xuICAgIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV0gPSB7fTtcbiAgfVxuICByZXR1cm4gYWxyZWFkeUxpc3RlbmluZ1RvW21vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldXTtcbn1cblxuLyoqXG4gKiBXZSBsaXN0ZW4gZm9yIGJ1YmJsZWQgdG91Y2ggZXZlbnRzIG9uIHRoZSBkb2N1bWVudCBvYmplY3QuXG4gKlxuICogRmlyZWZveCB2OC4wMSAoYW5kIHBvc3NpYmx5IG90aGVycykgZXhoaWJpdGVkIHN0cmFuZ2UgYmVoYXZpb3Igd2hlblxuICogbW91bnRpbmcgYG9ubW91c2Vtb3ZlYCBldmVudHMgYXQgc29tZSBub2RlIHRoYXQgd2FzIG5vdCB0aGUgZG9jdW1lbnRcbiAqIGVsZW1lbnQuIFRoZSBzeW1wdG9tcyB3ZXJlIHRoYXQgaWYgeW91ciBtb3VzZSBpcyBub3QgbW92aW5nIG92ZXIgc29tZXRoaW5nXG4gKiBjb250YWluZWQgd2l0aGluIHRoYXQgbW91bnQgcG9pbnQgKGZvciBleGFtcGxlIG9uIHRoZSBiYWNrZ3JvdW5kKSB0aGVcbiAqIHRvcC1sZXZlbCBsaXN0ZW5lcnMgZm9yIGBvbm1vdXNlbW92ZWAgd29uJ3QgYmUgY2FsbGVkLiBIb3dldmVyLCBpZiB5b3VcbiAqIHJlZ2lzdGVyIHRoZSBgbW91c2Vtb3ZlYCBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LCB0aGVuIGl0IHdpbGwgb2YgY291cnNlXG4gKiBjYXRjaCBhbGwgYG1vdXNlbW92ZWBzLiBUaGlzIGFsb25nIHdpdGggaU9TIHF1aXJrcywganVzdGlmaWVzIHJlc3RyaWN0aW5nXG4gKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIHRvIHRoZSBkb2N1bWVudCBvYmplY3Qgb25seSwgYXQgbGVhc3QgZm9yIHRoZXNlXG4gKiBtb3ZlbWVudCB0eXBlcyBvZiBldmVudHMgYW5kIHBvc3NpYmx5IGFsbCBldmVudHMuXG4gKlxuICogQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxuICpcbiAqIEFsc28sIGBrZXl1cGAvYGtleXByZXNzYC9ga2V5ZG93bmAgZG8gbm90IGJ1YmJsZSB0byB0aGUgd2luZG93IG9uIElFLCBidXRcbiAqIHRoZXkgYnViYmxlIHRvIGRvY3VtZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZW50RG9jdW1lbnRIYW5kbGUgRG9jdW1lbnQgd2hpY2ggb3ducyB0aGUgY29udGFpbmVyXG4gKi9cbmZ1bmN0aW9uIGxpc3RlblRvKHJlZ2lzdHJhdGlvbk5hbWUsIGNvbnRlbnREb2N1bWVudEhhbmRsZSkge1xuICB2YXIgbW91bnRBdCA9IGNvbnRlbnREb2N1bWVudEhhbmRsZTtcbiAgdmFyIGlzTGlzdGVuaW5nID0gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCk7XG4gIHZhciBkZXBlbmRlbmNpZXMgPSByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNbaV07XG4gICAgaWYgKCEoaXNMaXN0ZW5pbmcuaGFzT3duUHJvcGVydHkoZGVwZW5kZW5jeSkgJiYgaXNMaXN0ZW5pbmdbZGVwZW5kZW5jeV0pKSB7XG4gICAgICBpZiAoZGVwZW5kZW5jeSA9PT0gJ3RvcFNjcm9sbCcpIHtcbiAgICAgICAgdHJhcENhcHR1cmVkRXZlbnQoJ3RvcFNjcm9sbCcsICdzY3JvbGwnLCBtb3VudEF0KTtcbiAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gJ3RvcEZvY3VzJyB8fCBkZXBlbmRlbmN5ID09PSAndG9wQmx1cicpIHtcbiAgICAgICAgdHJhcENhcHR1cmVkRXZlbnQoJ3RvcEZvY3VzJywgJ2ZvY3VzJywgbW91bnRBdCk7XG4gICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KCd0b3BCbHVyJywgJ2JsdXInLCBtb3VudEF0KTtcblxuICAgICAgICAvLyB0byBtYWtlIHN1cmUgYmx1ciBhbmQgZm9jdXMgZXZlbnQgbGlzdGVuZXJzIGFyZSBvbmx5IGF0dGFjaGVkIG9uY2VcbiAgICAgICAgaXNMaXN0ZW5pbmcudG9wQmx1ciA9IHRydWU7XG4gICAgICAgIGlzTGlzdGVuaW5nLnRvcEZvY3VzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gJ3RvcENhbmNlbCcpIHtcbiAgICAgICAgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ2NhbmNlbCcsIHRydWUpKSB7XG4gICAgICAgICAgdHJhcENhcHR1cmVkRXZlbnQoJ3RvcENhbmNlbCcsICdjYW5jZWwnLCBtb3VudEF0KTtcbiAgICAgICAgfVxuICAgICAgICBpc0xpc3RlbmluZy50b3BDYW5jZWwgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChkZXBlbmRlbmN5ID09PSAndG9wQ2xvc2UnKSB7XG4gICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdjbG9zZScsIHRydWUpKSB7XG4gICAgICAgICAgdHJhcENhcHR1cmVkRXZlbnQoJ3RvcENsb3NlJywgJ2Nsb3NlJywgbW91bnRBdCk7XG4gICAgICAgIH1cbiAgICAgICAgaXNMaXN0ZW5pbmcudG9wQ2xvc2UgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0b3BMZXZlbFR5cGVzLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpKSB7XG4gICAgICAgIHRyYXBCdWJibGVkRXZlbnQoZGVwZW5kZW5jeSwgdG9wTGV2ZWxUeXBlc1tkZXBlbmRlbmN5XSwgbW91bnRBdCk7XG4gICAgICB9XG5cbiAgICAgIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNMaXN0ZW5pbmdUb0FsbERlcGVuZGVuY2llcyhyZWdpc3RyYXRpb25OYW1lLCBtb3VudEF0KSB7XG4gIHZhciBpc0xpc3RlbmluZyA9IGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpO1xuICB2YXIgZGVwZW5kZW5jaWVzID0gcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY2llc1tpXTtcbiAgICBpZiAoIShpc0xpc3RlbmluZy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSAmJiBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogR2l2ZW4gYW55IG5vZGUgcmV0dXJuIHRoZSBmaXJzdCBsZWFmIG5vZGUgd2l0aG91dCBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEByZXR1cm4ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cbmZ1bmN0aW9uIGdldExlYWZOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUgJiYgbm9kZS5maXJzdENoaWxkKSB7XG4gICAgbm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG5leHQgc2libGluZyB3aXRoaW4gYSBjb250YWluZXIuIFRoaXMgd2lsbCB3YWxrIHVwIHRoZVxuICogRE9NIGlmIGEgbm9kZSdzIHNpYmxpbmdzIGhhdmUgYmVlbiBleGhhdXN0ZWQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL1xuZnVuY3Rpb24gZ2V0U2libGluZ05vZGUobm9kZSkge1xuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5leHRTaWJsaW5nKSB7XG4gICAgICByZXR1cm4gbm9kZS5uZXh0U2libGluZztcbiAgICB9XG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCBvYmplY3QgZGVzY3JpYmluZyB0aGUgbm9kZXMgd2hpY2ggY29udGFpbiBjaGFyYWN0ZXJzIGF0IG9mZnNldC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IHJvb3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQocm9vdCwgb2Zmc2V0KSB7XG4gIHZhciBub2RlID0gZ2V0TGVhZk5vZGUocm9vdCk7XG4gIHZhciBub2RlU3RhcnQgPSAwO1xuICB2YXIgbm9kZUVuZCA9IDA7XG5cbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICBub2RlRW5kID0gbm9kZVN0YXJ0ICsgbm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG5cbiAgICAgIGlmIChub2RlU3RhcnQgPD0gb2Zmc2V0ICYmIG5vZGVFbmQgPj0gb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICBvZmZzZXQ6IG9mZnNldCAtIG5vZGVTdGFydFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBub2RlU3RhcnQgPSBub2RlRW5kO1xuICAgIH1cblxuICAgIG5vZGUgPSBnZXRMZWFmTm9kZShnZXRTaWJsaW5nTm9kZShub2RlKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG91dGVyTm9kZVxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0T2Zmc2V0cyhvdXRlck5vZGUpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24gJiYgd2luZG93LmdldFNlbGVjdGlvbigpO1xuXG4gIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0ID0gc2VsZWN0aW9uLmFuY2hvck9mZnNldCxcbiAgICAgIGZvY3VzTm9kZSQkMSA9IHNlbGVjdGlvbi5mb2N1c05vZGUsXG4gICAgICBmb2N1c09mZnNldCA9IHNlbGVjdGlvbi5mb2N1c09mZnNldDtcblxuICAvLyBJbiBGaXJlZm94LCBhbmNob3JOb2RlIGFuZCBmb2N1c05vZGUgY2FuIGJlIFwiYW5vbnltb3VzIGRpdnNcIiwgZS5nLiB0aGVcbiAgLy8gdXAvZG93biBidXR0b25zIG9uIGFuIDxpbnB1dCB0eXBlPVwibnVtYmVyXCI+LiBBbm9ueW1vdXMgZGl2cyBkbyBub3Qgc2VlbSB0b1xuICAvLyBleHBvc2UgcHJvcGVydGllcywgdHJpZ2dlcmluZyBhIFwiUGVybWlzc2lvbiBkZW5pZWQgZXJyb3JcIiBpZiBhbnkgb2YgaXRzXG4gIC8vIHByb3BlcnRpZXMgYXJlIGFjY2Vzc2VkLiBUaGUgb25seSBzZWVtaW5nbHkgcG9zc2libGUgd2F5IHRvIGF2b2lkIGVycm9yaW5nXG4gIC8vIGlzIHRvIGFjY2VzcyBhIHByb3BlcnR5IHRoYXQgdHlwaWNhbGx5IHdvcmtzIGZvciBub24tYW5vbnltb3VzIGRpdnMgYW5kXG4gIC8vIGNhdGNoIGFueSBlcnJvciB0aGF0IG1heSBvdGhlcndpc2UgYXJpc2UuIFNlZVxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0yMDg0MjdcblxuICB0cnkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICAgIGFuY2hvck5vZGUubm9kZVR5cGU7XG4gICAgZm9jdXNOb2RlJCQxLm5vZGVUeXBlO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBnZXRNb2Rlcm5PZmZzZXRzRnJvbVBvaW50cyhvdXRlck5vZGUsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlJCQxLCBmb2N1c09mZnNldCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB7c3RhcnQsIGVuZH0gd2hlcmUgYHN0YXJ0YCBpcyB0aGUgY2hhcmFjdGVyL2NvZGVwb2ludCBpbmRleCBvZlxuICogKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCkgd2l0aGluIHRoZSB0ZXh0Q29udGVudCBvZiBgb3V0ZXJOb2RlYCwgYW5kXG4gKiBgZW5kYCBpcyB0aGUgaW5kZXggb2YgKGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpLlxuICpcbiAqIFJldHVybnMgbnVsbCBpZiB5b3UgcGFzcyBpbiBnYXJiYWdlIGlucHV0IGJ1dCB3ZSBzaG91bGQgcHJvYmFibHkganVzdCBjcmFzaC5cbiAqXG4gKiBFeHBvcnRlZCBvbmx5IGZvciB0ZXN0aW5nLlxuICovXG5mdW5jdGlvbiBnZXRNb2Rlcm5PZmZzZXRzRnJvbVBvaW50cyhvdXRlck5vZGUsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlJCQxLCBmb2N1c09mZnNldCkge1xuICB2YXIgbGVuZ3RoID0gMDtcbiAgdmFyIHN0YXJ0ID0gLTE7XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIGluZGV4V2l0aGluQW5jaG9yID0gMDtcbiAgdmFyIGluZGV4V2l0aGluRm9jdXMgPSAwO1xuICB2YXIgbm9kZSA9IG91dGVyTm9kZTtcbiAgdmFyIHBhcmVudE5vZGUgPSBudWxsO1xuXG4gIG91dGVyOiB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBuZXh0ID0gbnVsbDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAobm9kZSA9PT0gYW5jaG9yTm9kZSAmJiAoYW5jaG9yT2Zmc2V0ID09PSAwIHx8IG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkpIHtcbiAgICAgICAgc3RhcnQgPSBsZW5ndGggKyBhbmNob3JPZmZzZXQ7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gZm9jdXNOb2RlJCQxICYmIChmb2N1c09mZnNldCA9PT0gMCB8fCBub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpKSB7XG4gICAgICAgIGVuZCA9IGxlbmd0aCArIGZvY3VzT2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICAgIGxlbmd0aCArPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmICgobmV4dCA9IG5vZGUuZmlyc3RDaGlsZCkgPT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBNb3ZpbmcgZnJvbSBgbm9kZWAgdG8gaXRzIGZpcnN0IGNoaWxkIGBuZXh0YC5cbiAgICAgIHBhcmVudE5vZGUgPSBub2RlO1xuICAgICAgbm9kZSA9IG5leHQ7XG4gICAgfVxuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChub2RlID09PSBvdXRlck5vZGUpIHtcbiAgICAgICAgLy8gSWYgYG91dGVyTm9kZWAgaGFzIGNoaWxkcmVuLCB0aGlzIGlzIGFsd2F5cyB0aGUgc2Vjb25kIHRpbWUgdmlzaXRpbmdcbiAgICAgICAgLy8gaXQuIElmIGl0IGhhcyBubyBjaGlsZHJlbiwgdGhpcyBpcyBzdGlsbCB0aGUgZmlyc3QgbG9vcCwgYW5kIHRoZSBvbmx5XG4gICAgICAgIC8vIHZhbGlkIHNlbGVjdGlvbiBpcyBhbmNob3JOb2RlIGFuZCBmb2N1c05vZGUgYm90aCBlcXVhbCB0byB0aGlzIG5vZGVcbiAgICAgICAgLy8gYW5kIGJvdGggb2Zmc2V0cyAwLCBpbiB3aGljaCBjYXNlIHdlIHdpbGwgaGF2ZSBoYW5kbGVkIGFib3ZlLlxuICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnROb2RlID09PSBhbmNob3JOb2RlICYmICsraW5kZXhXaXRoaW5BbmNob3IgPT09IGFuY2hvck9mZnNldCkge1xuICAgICAgICBzdGFydCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnROb2RlID09PSBmb2N1c05vZGUkJDEgJiYgKytpbmRleFdpdGhpbkZvY3VzID09PSBmb2N1c09mZnNldCkge1xuICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAoKG5leHQgPSBub2RlLm5leHRTaWJsaW5nKSAhPT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBwYXJlbnROb2RlO1xuICAgICAgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICAvLyBNb3ZpbmcgZnJvbSBgbm9kZWAgdG8gaXRzIG5leHQgc2libGluZyBgbmV4dGAuXG4gICAgbm9kZSA9IG5leHQ7XG4gIH1cblxuICBpZiAoc3RhcnQgPT09IC0xIHx8IGVuZCA9PT0gLTEpIHtcbiAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4uIChXb3VsZCBoYXBwZW4gaWYgdGhlIGFuY2hvci9mb2N1cyBub2RlcyBhcmVuJ3RcbiAgICAvLyBhY3R1YWxseSBpbnNpZGUgdGhlIHBhc3NlZC1pbiBub2RlLilcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHN0YXJ0LFxuICAgIGVuZDogZW5kXG4gIH07XG59XG5cbi8qKlxuICogSW4gbW9kZXJuIG5vbi1JRSBicm93c2Vycywgd2UgY2FuIHN1cHBvcnQgYm90aCBmb3J3YXJkIGFuZCBiYWNrd2FyZFxuICogc2VsZWN0aW9ucy5cbiAqXG4gKiBOb3RlOiBJRTEwKyBzdXBwb3J0cyB0aGUgU2VsZWN0aW9uIG9iamVjdCwgYnV0IGl0IGRvZXMgbm90IHN1cHBvcnRcbiAqIHRoZSBgZXh0ZW5kYCBtZXRob2QsIHdoaWNoIG1lYW5zIHRoYXQgZXZlbiBpbiBtb2Rlcm4gSUUsIGl0J3Mgbm90IHBvc3NpYmxlXG4gKiB0byBwcm9ncmFtbWF0aWNhbGx5IGNyZWF0ZSBhIGJhY2t3YXJkIHNlbGVjdGlvbi4gVGh1cywgZm9yIGFsbCBJRVxuICogdmVyc2lvbnMsIHdlIHVzZSB0aGUgb2xkIElFIEFQSSB0byBjcmVhdGUgb3VyIHNlbGVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xuICovXG5mdW5jdGlvbiBzZXRPZmZzZXRzKG5vZGUsIG9mZnNldHMpIHtcbiAgaWYgKCF3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgdmFyIGxlbmd0aCA9IG5vZGVbZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpXS5sZW5ndGg7XG4gIHZhciBzdGFydCA9IE1hdGgubWluKG9mZnNldHMuc3RhcnQsIGxlbmd0aCk7XG4gIHZhciBlbmQgPSBvZmZzZXRzLmVuZCA9PT0gdW5kZWZpbmVkID8gc3RhcnQgOiBNYXRoLm1pbihvZmZzZXRzLmVuZCwgbGVuZ3RoKTtcblxuICAvLyBJRSAxMSB1c2VzIG1vZGVybiBzZWxlY3Rpb24sIGJ1dCBkb2Vzbid0IHN1cHBvcnQgdGhlIGV4dGVuZCBtZXRob2QuXG4gIC8vIEZsaXAgYmFja3dhcmQgc2VsZWN0aW9ucywgc28gd2UgY2FuIHNldCB3aXRoIGEgc2luZ2xlIHJhbmdlLlxuICBpZiAoIXNlbGVjdGlvbi5leHRlbmQgJiYgc3RhcnQgPiBlbmQpIHtcbiAgICB2YXIgdGVtcCA9IGVuZDtcbiAgICBlbmQgPSBzdGFydDtcbiAgICBzdGFydCA9IHRlbXA7XG4gIH1cblxuICB2YXIgc3RhcnRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIHN0YXJ0KTtcbiAgdmFyIGVuZE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgZW5kKTtcblxuICBpZiAoc3RhcnRNYXJrZXIgJiYgZW5kTWFya2VyKSB7XG4gICAgaWYgKHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAxICYmIHNlbGVjdGlvbi5hbmNob3JOb2RlID09PSBzdGFydE1hcmtlci5ub2RlICYmIHNlbGVjdGlvbi5hbmNob3JPZmZzZXQgPT09IHN0YXJ0TWFya2VyLm9mZnNldCAmJiBzZWxlY3Rpb24uZm9jdXNOb2RlID09PSBlbmRNYXJrZXIubm9kZSAmJiBzZWxlY3Rpb24uZm9jdXNPZmZzZXQgPT09IGVuZE1hcmtlci5vZmZzZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICByYW5nZS5zZXRTdGFydChzdGFydE1hcmtlci5ub2RlLCBzdGFydE1hcmtlci5vZmZzZXQpO1xuICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcblxuICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgIHNlbGVjdGlvbi5leHRlbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZS5zZXRFbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJbkRvY3VtZW50KG5vZGUpIHtcbiAgcmV0dXJuIGNvbnRhaW5zTm9kZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIG5vZGUpO1xufVxuXG4vKipcbiAqIEBSZWFjdElucHV0U2VsZWN0aW9uOiBSZWFjdCBpbnB1dCBzZWxlY3Rpb24gbW9kdWxlLiBCYXNlZCBvbiBTZWxlY3Rpb24uanMsXG4gKiBidXQgbW9kaWZpZWQgdG8gYmUgc3VpdGFibGUgZm9yIHJlYWN0IGFuZCBoYXMgYSBjb3VwbGUgb2YgYnVnIGZpeGVzIChkb2Vzbid0XG4gKiBhc3N1bWUgYnV0dG9ucyBoYXZlIHJhbmdlIHNlbGVjdGlvbnMgYWxsb3dlZCkuXG4gKiBJbnB1dCBzZWxlY3Rpb24gbW9kdWxlIGZvciBSZWFjdC5cbiAqL1xuXG5mdW5jdGlvbiBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbm9kZU5hbWUgJiYgKG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW0udHlwZSA9PT0gJ3RleHQnIHx8IG5vZGVOYW1lID09PSAndGV4dGFyZWEnIHx8IGVsZW0uY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpO1xufVxuXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbigpIHtcbiAgdmFyIGZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuICByZXR1cm4ge1xuICAgIGZvY3VzZWRFbGVtOiBmb2N1c2VkRWxlbSxcbiAgICBzZWxlY3Rpb25SYW5nZTogaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGZvY3VzZWRFbGVtKSA/IGdldFNlbGVjdGlvbiQxKGZvY3VzZWRFbGVtKSA6IG51bGxcbiAgfTtcbn1cblxuLyoqXG4gKiBAcmVzdG9yZVNlbGVjdGlvbjogSWYgYW55IHNlbGVjdGlvbiBpbmZvcm1hdGlvbiB3YXMgcG90ZW50aWFsbHkgbG9zdCxcbiAqIHJlc3RvcmUgaXQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gcGVyZm9ybWluZyBvcGVyYXRpb25zIHRoYXQgY291bGQgcmVtb3ZlIGRvbVxuICogbm9kZXMgYW5kIHBsYWNlIHRoZW0gYmFjayBpbiwgcmVzdWx0aW5nIGluIGZvY3VzIGJlaW5nIGxvc3QuXG4gKi9cbmZ1bmN0aW9uIHJlc3RvcmVTZWxlY3Rpb24ocHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbikge1xuICB2YXIgY3VyRm9jdXNlZEVsZW0gPSBnZXRBY3RpdmVFbGVtZW50KCk7XG4gIHZhciBwcmlvckZvY3VzZWRFbGVtID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5mb2N1c2VkRWxlbTtcbiAgdmFyIHByaW9yU2VsZWN0aW9uUmFuZ2UgPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLnNlbGVjdGlvblJhbmdlO1xuICBpZiAoY3VyRm9jdXNlZEVsZW0gIT09IHByaW9yRm9jdXNlZEVsZW0gJiYgaXNJbkRvY3VtZW50KHByaW9yRm9jdXNlZEVsZW0pKSB7XG4gICAgaWYgKGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgICAgc2V0U2VsZWN0aW9uKHByaW9yRm9jdXNlZEVsZW0sIHByaW9yU2VsZWN0aW9uUmFuZ2UpO1xuICAgIH1cblxuICAgIC8vIEZvY3VzaW5nIGEgbm9kZSBjYW4gY2hhbmdlIHRoZSBzY3JvbGwgcG9zaXRpb24sIHdoaWNoIGlzIHVuZGVzaXJhYmxlXG4gICAgdmFyIGFuY2VzdG9ycyA9IFtdO1xuICAgIHZhciBhbmNlc3RvciA9IHByaW9yRm9jdXNlZEVsZW07XG4gICAgd2hpbGUgKGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50Tm9kZSkge1xuICAgICAgaWYgKGFuY2VzdG9yLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgYW5jZXN0b3JzLnB1c2goe1xuICAgICAgICAgIGVsZW1lbnQ6IGFuY2VzdG9yLFxuICAgICAgICAgIGxlZnQ6IGFuY2VzdG9yLnNjcm9sbExlZnQsXG4gICAgICAgICAgdG9wOiBhbmNlc3Rvci5zY3JvbGxUb3BcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9jdXNOb2RlKHByaW9yRm9jdXNlZEVsZW0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmNlc3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpbmZvID0gYW5jZXN0b3JzW2ldO1xuICAgICAgaW5mby5lbGVtZW50LnNjcm9sbExlZnQgPSBpbmZvLmxlZnQ7XG4gICAgICBpbmZvLmVsZW1lbnQuc2Nyb2xsVG9wID0gaW5mby50b3A7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQGdldFNlbGVjdGlvbjogR2V0cyB0aGUgc2VsZWN0aW9uIGJvdW5kcyBvZiBhIGZvY3VzZWQgdGV4dGFyZWEsIGlucHV0IG9yXG4gKiBjb250ZW50RWRpdGFibGUgbm9kZS5cbiAqIC1AaW5wdXQ6IExvb2sgdXAgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0XG4gKiAtQHJldHVybiB7c3RhcnQ6IHNlbGVjdGlvblN0YXJ0LCBlbmQ6IHNlbGVjdGlvbkVuZH1cbiAqL1xuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uJDEoaW5wdXQpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IHZvaWQgMDtcblxuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgIC8vIE1vZGVybiBicm93c2VyIHdpdGggaW5wdXQgb3IgdGV4dGFyZWEuXG4gICAgc2VsZWN0aW9uID0ge1xuICAgICAgc3RhcnQ6IGlucHV0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBpbnB1dC5zZWxlY3Rpb25FbmRcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIENvbnRlbnQgZWRpdGFibGUgb3Igb2xkIElFIHRleHRhcmVhLlxuICAgIHNlbGVjdGlvbiA9IGdldE9mZnNldHMoaW5wdXQpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGVjdGlvbiB8fCB7IHN0YXJ0OiAwLCBlbmQ6IDAgfTtcbn1cblxuLyoqXG4gKiBAc2V0U2VsZWN0aW9uOiBTZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgdGV4dGFyZWEgb3IgaW5wdXQgYW5kIGZvY3VzZXNcbiAqIHRoZSBpbnB1dC5cbiAqIC1AaW5wdXQgICAgIFNldCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXQgb3IgdGV4dGFyZWFcbiAqIC1Ab2Zmc2V0cyAgIE9iamVjdCBvZiBzYW1lIGZvcm0gdGhhdCBpcyByZXR1cm5lZCBmcm9tIGdldCpcbiAqL1xuZnVuY3Rpb24gc2V0U2VsZWN0aW9uKGlucHV0LCBvZmZzZXRzKSB7XG4gIHZhciBzdGFydCA9IG9mZnNldHMuc3RhcnQsXG4gICAgICBlbmQgPSBvZmZzZXRzLmVuZDtcblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSBzdGFydDtcbiAgfVxuXG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIGlucHV0KSB7XG4gICAgaW5wdXQuc2VsZWN0aW9uU3RhcnQgPSBzdGFydDtcbiAgICBpbnB1dC5zZWxlY3Rpb25FbmQgPSBNYXRoLm1pbihlbmQsIGlucHV0LnZhbHVlLmxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgc2V0T2Zmc2V0cyhpbnB1dCwgb2Zmc2V0cyk7XG4gIH1cbn1cblxudmFyIHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUgPD0gMTE7XG5cbnZhciBldmVudFR5cGVzJDMgPSB7XG4gIHNlbGVjdDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25TZWxlY3QnLFxuICAgICAgY2FwdHVyZWQ6ICdvblNlbGVjdENhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDb250ZXh0TWVudScsICd0b3BGb2N1cycsICd0b3BLZXlEb3duJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93bicsICd0b3BNb3VzZVVwJywgJ3RvcFNlbGVjdGlvbkNoYW5nZSddXG4gIH1cbn07XG5cbnZhciBhY3RpdmVFbGVtZW50JDEgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJbnN0JDEgPSBudWxsO1xudmFyIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xudmFyIG1vdXNlRG93biA9IGZhbHNlO1xuXG4vKipcbiAqIEdldCBhbiBvYmplY3Qgd2hpY2ggaXMgYSB1bmlxdWUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBub3QgYmUgY29uc2lzdGVudCBhY3Jvc3Mgbm9kZXMgb3IgYnJvd3NlcnMsIGJ1dFxuICogdHdvIGlkZW50aWNhbCBzZWxlY3Rpb25zIG9uIHRoZSBzYW1lIG5vZGUgd2lsbCByZXR1cm4gaWRlbnRpY2FsIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbihub2RlKSB7XG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIG5vZGUgJiYgaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKG5vZGUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBub2RlLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBub2RlLnNlbGVjdGlvbkVuZFxuICAgIH07XG4gIH0gZWxzZSBpZiAod2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvck5vZGU6IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0OiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlOiBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXQ6IHNlbGVjdGlvbi5mb2N1c09mZnNldFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBQb2xsIHNlbGVjdGlvbiB0byBzZWUgd2hldGhlciBpdCdzIGNoYW5nZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAvLyBFbnN1cmUgd2UgaGF2ZSB0aGUgcmlnaHQgZWxlbWVudCwgYW5kIHRoYXQgdGhlIHVzZXIgaXMgbm90IGRyYWdnaW5nIGFcbiAgLy8gc2VsZWN0aW9uICh0aGlzIG1hdGNoZXMgbmF0aXZlIGBzZWxlY3RgIGV2ZW50IGJlaGF2aW9yKS4gSW4gSFRNTDUsIHNlbGVjdFxuICAvLyBmaXJlcyBvbmx5IG9uIGlucHV0IGFuZCB0ZXh0YXJlYSB0aHVzIGlmIHRoZXJlJ3Mgbm8gZm9jdXNlZCBlbGVtZW50IHdlXG4gIC8vIHdvbid0IGRpc3BhdGNoLlxuICBpZiAobW91c2VEb3duIHx8IGFjdGl2ZUVsZW1lbnQkMSA9PSBudWxsIHx8IGFjdGl2ZUVsZW1lbnQkMSAhPT0gZ2V0QWN0aXZlRWxlbWVudCgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBPbmx5IGZpcmUgd2hlbiBzZWxlY3Rpb24gaGFzIGFjdHVhbGx5IGNoYW5nZWQuXG4gIHZhciBjdXJyZW50U2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKGFjdGl2ZUVsZW1lbnQkMSk7XG4gIGlmICghbGFzdFNlbGVjdGlvbiB8fCAhc2hhbGxvd0VxdWFsKGxhc3RTZWxlY3Rpb24sIGN1cnJlbnRTZWxlY3Rpb24pKSB7XG4gICAgbGFzdFNlbGVjdGlvbiA9IGN1cnJlbnRTZWxlY3Rpb247XG5cbiAgICB2YXIgc3ludGhldGljRXZlbnQgPSBTeW50aGV0aWNFdmVudCQxLmdldFBvb2xlZChldmVudFR5cGVzJDMuc2VsZWN0LCBhY3RpdmVFbGVtZW50SW5zdCQxLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgc3ludGhldGljRXZlbnQudHlwZSA9ICdzZWxlY3QnO1xuICAgIHN5bnRoZXRpY0V2ZW50LnRhcmdldCA9IGFjdGl2ZUVsZW1lbnQkMTtcblxuICAgIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoc3ludGhldGljRXZlbnQpO1xuXG4gICAgcmV0dXJuIHN5bnRoZXRpY0V2ZW50O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25TZWxlY3RgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBzZWxlY3QgZXZlbnRzXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy5cbiAqXG4gKiBTdXBwb3J0ZWQgZWxlbWVudHMgYXJlOlxuICogLSBpbnB1dCAoc2VlIGBpc1RleHRJbnB1dEVsZW1lbnRgKVxuICogLSB0ZXh0YXJlYVxuICogLSBjb250ZW50RWRpdGFibGVcbiAqXG4gKiBUaGlzIGRpZmZlcnMgZnJvbSBuYXRpdmUgYnJvd3NlciBpbXBsZW1lbnRhdGlvbnMgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICogLSBGaXJlcyBvbiBjb250ZW50RWRpdGFibGUgZmllbGRzIGFzIHdlbGwgYXMgaW5wdXRzLlxuICogLSBGaXJlcyBmb3IgY29sbGFwc2VkIHNlbGVjdGlvbi5cbiAqIC0gRmlyZXMgYWZ0ZXIgdXNlciBpbnB1dC5cbiAqL1xudmFyIFNlbGVjdEV2ZW50UGx1Z2luID0ge1xuICBldmVudFR5cGVzOiBldmVudFR5cGVzJDMsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGRvYyA9IG5hdGl2ZUV2ZW50VGFyZ2V0LndpbmRvdyA9PT0gbmF0aXZlRXZlbnRUYXJnZXQgPyBuYXRpdmVFdmVudFRhcmdldC5kb2N1bWVudCA6IG5hdGl2ZUV2ZW50VGFyZ2V0Lm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFID8gbmF0aXZlRXZlbnRUYXJnZXQgOiBuYXRpdmVFdmVudFRhcmdldC5vd25lckRvY3VtZW50O1xuICAgIC8vIFRyYWNrIHdoZXRoZXIgYWxsIGxpc3RlbmVycyBleGlzdHMgZm9yIHRoaXMgcGx1Z2luLiBJZiBub25lIGV4aXN0LCB3ZSBkb1xuICAgIC8vIG5vdCBleHRyYWN0IGV2ZW50cy4gU2VlICMzNjM5LlxuICAgIGlmICghZG9jIHx8ICFpc0xpc3RlbmluZ1RvQWxsRGVwZW5kZW5jaWVzKCdvblNlbGVjdCcsIGRvYykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXROb2RlID0gdGFyZ2V0SW5zdCA/IGdldE5vZGVGcm9tSW5zdGFuY2UkMSh0YXJnZXRJbnN0KSA6IHdpbmRvdztcblxuICAgIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgICAvLyBUcmFjayB0aGUgaW5wdXQgbm9kZSB0aGF0IGhhcyBmb2N1cy5cbiAgICAgIGNhc2UgJ3RvcEZvY3VzJzpcbiAgICAgICAgaWYgKGlzVGV4dElucHV0RWxlbWVudCh0YXJnZXROb2RlKSB8fCB0YXJnZXROb2RlLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudCQxID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50SW5zdCQxID0gdGFyZ2V0SW5zdDtcbiAgICAgICAgICBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcEJsdXInOlxuICAgICAgICBhY3RpdmVFbGVtZW50JDEgPSBudWxsO1xuICAgICAgICBhY3RpdmVFbGVtZW50SW5zdCQxID0gbnVsbDtcbiAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gRG9uJ3QgZmlyZSB0aGUgZXZlbnQgd2hpbGUgdGhlIHVzZXIgaXMgZHJhZ2dpbmcuIFRoaXMgbWF0Y2hlcyB0aGVcbiAgICAgIC8vIHNlbWFudGljcyBvZiB0aGUgbmF0aXZlIHNlbGVjdCBldmVudC5cbiAgICAgIGNhc2UgJ3RvcE1vdXNlRG93bic6XG4gICAgICAgIG1vdXNlRG93biA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQ29udGV4dE1lbnUnOlxuICAgICAgY2FzZSAndG9wTW91c2VVcCc6XG4gICAgICAgIG1vdXNlRG93biA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgIC8vIENocm9tZSBhbmQgSUUgZmlyZSBub24tc3RhbmRhcmQgZXZlbnQgd2hlbiBzZWxlY3Rpb24gaXMgY2hhbmdlZCAoYW5kXG4gICAgICAvLyBzb21ldGltZXMgd2hlbiBpdCBoYXNuJ3QpLiBJRSdzIGV2ZW50IGZpcmVzIG91dCBvZiBvcmRlciB3aXRoIHJlc3BlY3RcbiAgICAgIC8vIHRvIGtleSBhbmQgaW5wdXQgZXZlbnRzIG9uIGRlbGV0aW9uLCBzbyB3ZSBkaXNjYXJkIGl0LlxuICAgICAgLy9cbiAgICAgIC8vIEZpcmVmb3ggZG9lc24ndCBzdXBwb3J0IHNlbGVjdGlvbmNoYW5nZSwgc28gY2hlY2sgc2VsZWN0aW9uIHN0YXR1c1xuICAgICAgLy8gYWZ0ZXIgZWFjaCBrZXkgZW50cnkuIFRoZSBzZWxlY3Rpb24gY2hhbmdlcyBhZnRlciBrZXlkb3duIGFuZCBiZWZvcmVcbiAgICAgIC8vIGtleXVwLCBidXQgd2UgY2hlY2sgb24ga2V5ZG93biBhcyB3ZWxsIGluIHRoZSBjYXNlIG9mIGhvbGRpbmcgZG93biBhXG4gICAgICAvLyBrZXksIHdoZW4gbXVsdGlwbGUga2V5ZG93biBldmVudHMgYXJlIGZpcmVkIGJ1dCBvbmx5IG9uZSBrZXl1cCBpcy5cbiAgICAgIC8vIFRoaXMgaXMgYWxzbyBvdXIgYXBwcm9hY2ggZm9yIElFIGhhbmRsaW5nLCBmb3IgdGhlIHJlYXNvbiBhYm92ZS5cbiAgICAgIGNhc2UgJ3RvcFNlbGVjdGlvbkNoYW5nZSc6XG4gICAgICAgIGlmIChza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSAndG9wS2V5RG93bic6XG4gICAgICBjYXNlICd0b3BLZXlVcCc6XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1hbmltYXRpb25zLyNBbmltYXRpb25FdmVudC1pbnRlcmZhY2VcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0FuaW1hdGlvbkV2ZW50XG4gKi9cbnZhciBBbmltYXRpb25FdmVudEludGVyZmFjZSA9IHtcbiAgYW5pbWF0aW9uTmFtZTogbnVsbCxcbiAgZWxhcHNlZFRpbWU6IG51bGwsXG4gIHBzZXVkb0VsZW1lbnQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNBbmltYXRpb25FdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQkMS5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQkMS5hdWdtZW50Q2xhc3MoU3ludGhldGljQW5pbWF0aW9uRXZlbnQsIEFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NsaXBib2FyZC1hcGlzL1xuICovXG52YXIgQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGNsaXBib2FyZERhdGE6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnY2xpcGJvYXJkRGF0YScgaW4gZXZlbnQgPyBldmVudC5jbGlwYm9hcmREYXRhIDogd2luZG93LmNsaXBib2FyZERhdGE7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNDbGlwYm9hcmRFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQkMS5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQkMS5hdWdtZW50Q2xhc3MoU3ludGhldGljQ2xpcGJvYXJkRXZlbnQsIENsaXBib2FyZEV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEZvY3VzRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRm9jdXNFdmVudEludGVyZmFjZSA9IHtcbiAgcmVsYXRlZFRhcmdldDogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRm9jdXNFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljRm9jdXNFdmVudCwgRm9jdXNFdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogYGNoYXJDb2RlYCByZXByZXNlbnRzIHRoZSBhY3R1YWwgXCJjaGFyYWN0ZXIgY29kZVwiIGFuZCBpcyBzYWZlIHRvIHVzZSB3aXRoXG4gKiBgU3RyaW5nLmZyb21DaGFyQ29kZWAuIEFzIHN1Y2gsIG9ubHkga2V5cyB0aGF0IGNvcnJlc3BvbmQgdG8gcHJpbnRhYmxlXG4gKiBjaGFyYWN0ZXJzIHByb2R1Y2UgYSB2YWxpZCBgY2hhckNvZGVgLCB0aGUgb25seSBleGNlcHRpb24gdG8gdGhpcyBpcyBFbnRlci5cbiAqIFRoZSBUYWIta2V5IGlzIGNvbnNpZGVyZWQgbm9uLXByaW50YWJsZSBhbmQgZG9lcyBub3QgaGF2ZSBhIGBjaGFyQ29kZWAsXG4gKiBwcmVzdW1hYmx5IGJlY2F1c2UgaXQgZG9lcyBub3QgcHJvZHVjZSBhIHRhYi1jaGFyYWN0ZXIgaW4gYnJvd3NlcnMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7bnVtYmVyfSBOb3JtYWxpemVkIGBjaGFyQ29kZWAgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGNoYXJDb2RlO1xuICB2YXIga2V5Q29kZSA9IG5hdGl2ZUV2ZW50LmtleUNvZGU7XG5cbiAgaWYgKCdjaGFyQ29kZScgaW4gbmF0aXZlRXZlbnQpIHtcbiAgICBjaGFyQ29kZSA9IG5hdGl2ZUV2ZW50LmNoYXJDb2RlO1xuXG4gICAgLy8gRkYgZG9lcyBub3Qgc2V0IGBjaGFyQ29kZWAgZm9yIHRoZSBFbnRlci1rZXksIGNoZWNrIGFnYWluc3QgYGtleUNvZGVgLlxuICAgIGlmIChjaGFyQ29kZSA9PT0gMCAmJiBrZXlDb2RlID09PSAxMykge1xuICAgICAgY2hhckNvZGUgPSAxMztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBgY2hhckNvZGVgLCBidXQgYGtleUNvZGVgIGhhcyB0aGUgY29ycmVjdCB2YWx1ZS5cbiAgICBjaGFyQ29kZSA9IGtleUNvZGU7XG4gIH1cblxuICAvLyBTb21lIG5vbi1wcmludGFibGUga2V5cyBhcmUgcmVwb3J0ZWQgaW4gYGNoYXJDb2RlYC9ga2V5Q29kZWAsIGRpc2NhcmQgdGhlbS5cbiAgLy8gTXVzdCBub3QgZGlzY2FyZCB0aGUgKG5vbi0pcHJpbnRhYmxlIEVudGVyLWtleS5cbiAgaWYgKGNoYXJDb2RlID49IDMyIHx8IGNoYXJDb2RlID09PSAxMykge1xuICAgIHJldHVybiBjaGFyQ29kZTtcbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6YXRpb24gb2YgZGVwcmVjYXRlZCBIVE1MNSBga2V5YCB2YWx1ZXNcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQjS2V5X25hbWVzXG4gKi9cbnZhciBub3JtYWxpemVLZXkgPSB7XG4gIEVzYzogJ0VzY2FwZScsXG4gIFNwYWNlYmFyOiAnICcsXG4gIExlZnQ6ICdBcnJvd0xlZnQnLFxuICBVcDogJ0Fycm93VXAnLFxuICBSaWdodDogJ0Fycm93UmlnaHQnLFxuICBEb3duOiAnQXJyb3dEb3duJyxcbiAgRGVsOiAnRGVsZXRlJyxcbiAgV2luOiAnT1MnLFxuICBNZW51OiAnQ29udGV4dE1lbnUnLFxuICBBcHBzOiAnQ29udGV4dE1lbnUnLFxuICBTY3JvbGw6ICdTY3JvbGxMb2NrJyxcbiAgTW96UHJpbnRhYmxlS2V5OiAnVW5pZGVudGlmaWVkJ1xufTtcblxuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIGxlZ2FjeSBga2V5Q29kZWAgdG8gSFRNTDUgYGtleWBcbiAqIE9ubHkgc3BlY2lhbCBrZXlzIHN1cHBvcnRlZCwgYWxsIG90aGVycyBkZXBlbmQgb24ga2V5Ym9hcmQgbGF5b3V0IG9yIGJyb3dzZXJcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQjS2V5X25hbWVzXG4gKi9cbnZhciB0cmFuc2xhdGVUb0tleSA9IHtcbiAgJzgnOiAnQmFja3NwYWNlJyxcbiAgJzknOiAnVGFiJyxcbiAgJzEyJzogJ0NsZWFyJyxcbiAgJzEzJzogJ0VudGVyJyxcbiAgJzE2JzogJ1NoaWZ0JyxcbiAgJzE3JzogJ0NvbnRyb2wnLFxuICAnMTgnOiAnQWx0JyxcbiAgJzE5JzogJ1BhdXNlJyxcbiAgJzIwJzogJ0NhcHNMb2NrJyxcbiAgJzI3JzogJ0VzY2FwZScsXG4gICczMic6ICcgJyxcbiAgJzMzJzogJ1BhZ2VVcCcsXG4gICczNCc6ICdQYWdlRG93bicsXG4gICczNSc6ICdFbmQnLFxuICAnMzYnOiAnSG9tZScsXG4gICczNyc6ICdBcnJvd0xlZnQnLFxuICAnMzgnOiAnQXJyb3dVcCcsXG4gICczOSc6ICdBcnJvd1JpZ2h0JyxcbiAgJzQwJzogJ0Fycm93RG93bicsXG4gICc0NSc6ICdJbnNlcnQnLFxuICAnNDYnOiAnRGVsZXRlJyxcbiAgJzExMic6ICdGMScsXG4gICcxMTMnOiAnRjInLFxuICAnMTE0JzogJ0YzJyxcbiAgJzExNSc6ICdGNCcsXG4gICcxMTYnOiAnRjUnLFxuICAnMTE3JzogJ0Y2JyxcbiAgJzExOCc6ICdGNycsXG4gICcxMTknOiAnRjgnLFxuICAnMTIwJzogJ0Y5JyxcbiAgJzEyMSc6ICdGMTAnLFxuICAnMTIyJzogJ0YxMScsXG4gICcxMjMnOiAnRjEyJyxcbiAgJzE0NCc6ICdOdW1Mb2NrJyxcbiAgJzE0NSc6ICdTY3JvbGxMb2NrJyxcbiAgJzIyNCc6ICdNZXRhJ1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgYGtleWAgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGdldEV2ZW50S2V5KG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChuYXRpdmVFdmVudC5rZXkpIHtcbiAgICAvLyBOb3JtYWxpemUgaW5jb25zaXN0ZW50IHZhbHVlcyByZXBvcnRlZCBieSBicm93c2VycyBkdWUgdG9cbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgb2YgYSB3b3JraW5nIGRyYWZ0IHNwZWNpZmljYXRpb24uXG5cbiAgICAvLyBGaXJlRm94IGltcGxlbWVudHMgYGtleWAgYnV0IHJldHVybnMgYE1velByaW50YWJsZUtleWAgZm9yIGFsbFxuICAgIC8vIHByaW50YWJsZSBjaGFyYWN0ZXJzIChub3JtYWxpemVkIHRvIGBVbmlkZW50aWZpZWRgKSwgaWdub3JlIGl0LlxuICAgIHZhciBrZXkgPSBub3JtYWxpemVLZXlbbmF0aXZlRXZlbnQua2V5XSB8fCBuYXRpdmVFdmVudC5rZXk7XG4gICAgaWYgKGtleSAhPT0gJ1VuaWRlbnRpZmllZCcpIHtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICB9XG5cbiAgLy8gQnJvd3NlciBkb2VzIG5vdCBpbXBsZW1lbnQgYGtleWAsIHBvbHlmaWxsIGFzIG11Y2ggb2YgaXQgYXMgd2UgY2FuLlxuICBpZiAobmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgIHZhciBjaGFyQ29kZSA9IGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpO1xuXG4gICAgLy8gVGhlIGVudGVyLWtleSBpcyB0ZWNobmljYWxseSBib3RoIHByaW50YWJsZSBhbmQgbm9uLXByaW50YWJsZSBhbmQgY2FuXG4gICAgLy8gdGh1cyBiZSBjYXB0dXJlZCBieSBga2V5cHJlc3NgLCBubyBvdGhlciBub24tcHJpbnRhYmxlIGtleSBzaG91bGQuXG4gICAgcmV0dXJuIGNoYXJDb2RlID09PSAxMyA/ICdFbnRlcicgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgfVxuICBpZiAobmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAvLyBXaGlsZSB1c2VyIGtleWJvYXJkIGxheW91dCBkZXRlcm1pbmVzIHRoZSBhY3R1YWwgbWVhbmluZyBvZiBlYWNoXG4gICAgLy8gYGtleUNvZGVgIHZhbHVlLCBhbG1vc3QgYWxsIGZ1bmN0aW9uIGtleXMgaGF2ZSBhIHVuaXZlcnNhbCB2YWx1ZS5cbiAgICByZXR1cm4gdHJhbnNsYXRlVG9LZXlbbmF0aXZlRXZlbnQua2V5Q29kZV0gfHwgJ1VuaWRlbnRpZmllZCc7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIEBpbnRlcmZhY2UgS2V5Ym9hcmRFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBLZXlib2FyZEV2ZW50SW50ZXJmYWNlID0ge1xuICBrZXk6IGdldEV2ZW50S2V5LFxuICBsb2NhdGlvbjogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgcmVwZWF0OiBudWxsLFxuICBsb2NhbGU6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgLy8gTGVnYWN5IEludGVyZmFjZVxuICBjaGFyQ29kZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYGNoYXJDb2RlYCBpcyB0aGUgcmVzdWx0IG9mIGEgS2V5UHJlc3MgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gdGhlIGFjdHVhbCBwcmludGFibGUgY2hhcmFjdGVyLlxuXG4gICAgLy8gS2V5UHJlc3MgaXMgZGVwcmVjYXRlZCwgYnV0IGl0cyByZXBsYWNlbWVudCBpcyBub3QgeWV0IGZpbmFsIGFuZCBub3RcbiAgICAvLyBpbXBsZW1lbnRlZCBpbiBhbnkgbWFqb3IgYnJvd3Nlci4gT25seSBLZXlQcmVzcyBoYXMgY2hhckNvZGUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICAgIHJldHVybiBnZXRFdmVudENoYXJDb2RlKGV2ZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIGtleUNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBrZXlDb2RlYCBpcyB0aGUgcmVzdWx0IG9mIGEgS2V5RG93bi9VcCBldmVudCBhbmQgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2ZcbiAgICAvLyBwaHlzaWNhbCBrZXlib2FyZCBrZXkuXG5cbiAgICAvLyBUaGUgYWN0dWFsIG1lYW5pbmcgb2YgdGhlIHZhbHVlIGRlcGVuZHMgb24gdGhlIHVzZXJzJyBrZXlib2FyZCBsYXlvdXRcbiAgICAvLyB3aGljaCBjYW5ub3QgYmUgZGV0ZWN0ZWQuIEFzc3VtaW5nIHRoYXQgaXQgaXMgYSBVUyBrZXlib2FyZCBsYXlvdXRcbiAgICAvLyBwcm92aWRlcyBhIHN1cnByaXNpbmdseSBhY2N1cmF0ZSBtYXBwaW5nIGZvciBVUyBhbmQgRXVyb3BlYW4gdXNlcnMuXG4gICAgLy8gRHVlIHRvIHRoaXMsIGl0IGlzIGxlZnQgdG8gdGhlIHVzZXIgdG8gaW1wbGVtZW50IGF0IHRoaXMgdGltZS5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAgIHJldHVybiBldmVudC5rZXlDb2RlO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAgd2hpY2g6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGB3aGljaGAgaXMgYW4gYWxpYXMgZm9yIGVpdGhlciBga2V5Q29kZWAgb3IgYGNoYXJDb2RlYCBkZXBlbmRpbmcgb24gdGhlXG4gICAgLy8gdHlwZSBvZiB0aGUgZXZlbnQuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICAgIHJldHVybiBnZXRFdmVudENoYXJDb2RlKGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0tleWJvYXJkRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0tleWJvYXJkRXZlbnQsIEtleWJvYXJkRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRHJhZ0V2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIERyYWdFdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YVRyYW5zZmVyOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNNb3VzZUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNEcmFnRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY01vdXNlRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY01vdXNlRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0RyYWdFdmVudCwgRHJhZ0V2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFRvdWNoRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvdG91Y2gtZXZlbnRzL1xuICovXG52YXIgVG91Y2hFdmVudEludGVyZmFjZSA9IHtcbiAgdG91Y2hlczogbnVsbCxcbiAgdGFyZ2V0VG91Y2hlczogbnVsbCxcbiAgY2hhbmdlZFRvdWNoZXM6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljVG91Y2hFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljVG91Y2hFdmVudCwgVG91Y2hFdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDA5L1dELWNzczMtdHJhbnNpdGlvbnMtMjAwOTAzMjAvI3RyYW5zaXRpb24tZXZlbnRzLVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVHJhbnNpdGlvbkV2ZW50XG4gKi9cbnZhciBUcmFuc2l0aW9uRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHByb3BlcnR5TmFtZTogbnVsbCxcbiAgZWxhcHNlZFRpbWU6IG51bGwsXG4gIHBzZXVkb0VsZW1lbnQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50JDEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50JDEuYXVnbWVudENsYXNzKFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudCwgVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFdoZWVsRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgV2hlZWxFdmVudEludGVyZmFjZSA9IHtcbiAgZGVsdGFYOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWCcgaW4gZXZlbnQgPyBldmVudC5kZWx0YVggOiAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVhgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAocmlnaHQgaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhWCcgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVggOiAwO1xuICB9LFxuICBkZWx0YVk6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnZGVsdGFZJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWSA6IC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWWAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YVknIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGFZIDogLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFgIGZvciBJRTw5IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhIDogMDtcbiAgfSxcbiAgZGVsdGFaOiBudWxsLFxuXG4gIC8vIEJyb3dzZXJzIHdpdGhvdXQgXCJkZWx0YU1vZGVcIiBpcyByZXBvcnRpbmcgaW4gcmF3IHdoZWVsIGRlbHRhIHdoZXJlIG9uZVxuICAvLyBub3RjaCBvbiB0aGUgc2Nyb2xsIGlzIGFsd2F5cyArLy0gMTIwLCByb3VnaGx5IGVxdWl2YWxlbnQgdG8gcGl4ZWxzLlxuICAvLyBBIGdvb2QgYXBwcm94aW1hdGlvbiBvZiBET01fREVMVEFfTElORSAoMSkgaXMgNSUgb2Ygdmlld3BvcnQgc2l6ZSBvclxuICAvLyB+NDAgcGl4ZWxzLCBmb3IgRE9NX0RFTFRBX1NDUkVFTiAoMikgaXQgaXMgODcuNSUgb2Ygdmlld3BvcnQgc2l6ZS5cbiAgZGVsdGFNb2RlOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNNb3VzZUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNXaGVlbEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNNb3VzZUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNNb3VzZUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNXaGVlbEV2ZW50LCBXaGVlbEV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBUdXJuc1xuICogWydhYm9ydCcsIC4uLl1cbiAqIGludG9cbiAqIGV2ZW50VHlwZXMgPSB7XG4gKiAgICdhYm9ydCc6IHtcbiAqICAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICogICAgICAgYnViYmxlZDogJ29uQWJvcnQnLFxuICogICAgICAgY2FwdHVyZWQ6ICdvbkFib3J0Q2FwdHVyZScsXG4gKiAgICAgfSxcbiAqICAgICBkZXBlbmRlbmNpZXM6IFsndG9wQWJvcnQnXSxcbiAqICAgfSxcbiAqICAgLi4uXG4gKiB9O1xuICogdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnID0ge1xuICogICAndG9wQWJvcnQnOiB7IHNhbWVDb25maWcgfVxuICogfTtcbiAqL1xudmFyIGV2ZW50VHlwZXMkNCA9IHt9O1xudmFyIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZyA9IHt9O1xuWydhYm9ydCcsICdhbmltYXRpb25FbmQnLCAnYW5pbWF0aW9uSXRlcmF0aW9uJywgJ2FuaW1hdGlvblN0YXJ0JywgJ2JsdXInLCAnY2FuY2VsJywgJ2NhblBsYXknLCAnY2FuUGxheVRocm91Z2gnLCAnY2xpY2snLCAnY2xvc2UnLCAnY29udGV4dE1lbnUnLCAnY29weScsICdjdXQnLCAnZG91YmxlQ2xpY2snLCAnZHJhZycsICdkcmFnRW5kJywgJ2RyYWdFbnRlcicsICdkcmFnRXhpdCcsICdkcmFnTGVhdmUnLCAnZHJhZ092ZXInLCAnZHJhZ1N0YXJ0JywgJ2Ryb3AnLCAnZHVyYXRpb25DaGFuZ2UnLCAnZW1wdGllZCcsICdlbmNyeXB0ZWQnLCAnZW5kZWQnLCAnZXJyb3InLCAnZm9jdXMnLCAnaW5wdXQnLCAnaW52YWxpZCcsICdrZXlEb3duJywgJ2tleVByZXNzJywgJ2tleVVwJywgJ2xvYWQnLCAnbG9hZGVkRGF0YScsICdsb2FkZWRNZXRhZGF0YScsICdsb2FkU3RhcnQnLCAnbW91c2VEb3duJywgJ21vdXNlTW92ZScsICdtb3VzZU91dCcsICdtb3VzZU92ZXInLCAnbW91c2VVcCcsICdwYXN0ZScsICdwYXVzZScsICdwbGF5JywgJ3BsYXlpbmcnLCAncHJvZ3Jlc3MnLCAncmF0ZUNoYW5nZScsICdyZXNldCcsICdzY3JvbGwnLCAnc2Vla2VkJywgJ3NlZWtpbmcnLCAnc3RhbGxlZCcsICdzdWJtaXQnLCAnc3VzcGVuZCcsICd0aW1lVXBkYXRlJywgJ3RvZ2dsZScsICd0b3VjaENhbmNlbCcsICd0b3VjaEVuZCcsICd0b3VjaE1vdmUnLCAndG91Y2hTdGFydCcsICd0cmFuc2l0aW9uRW5kJywgJ3ZvbHVtZUNoYW5nZScsICd3YWl0aW5nJywgJ3doZWVsJ10uZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdmFyIGNhcGl0YWxpemVkRXZlbnQgPSBldmVudFswXS50b1VwcGVyQ2FzZSgpICsgZXZlbnQuc2xpY2UoMSk7XG4gIHZhciBvbkV2ZW50ID0gJ29uJyArIGNhcGl0YWxpemVkRXZlbnQ7XG4gIHZhciB0b3BFdmVudCA9ICd0b3AnICsgY2FwaXRhbGl6ZWRFdmVudDtcblxuICB2YXIgdHlwZSA9IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogb25FdmVudCxcbiAgICAgIGNhcHR1cmVkOiBvbkV2ZW50ICsgJ0NhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BFdmVudF1cbiAgfTtcbiAgZXZlbnRUeXBlcyQ0W2V2ZW50XSA9IHR5cGU7XG4gIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BFdmVudF0gPSB0eXBlO1xufSk7XG5cbi8vIE9ubHkgdXNlZCBpbiBERVYgZm9yIGV4aGF1c3RpdmVuZXNzIHZhbGlkYXRpb24uXG52YXIga25vd25IVE1MVG9wTGV2ZWxUeXBlcyA9IFsndG9wQWJvcnQnLCAndG9wQ2FuY2VsJywgJ3RvcENhblBsYXknLCAndG9wQ2FuUGxheVRocm91Z2gnLCAndG9wQ2xvc2UnLCAndG9wRHVyYXRpb25DaGFuZ2UnLCAndG9wRW1wdGllZCcsICd0b3BFbmNyeXB0ZWQnLCAndG9wRW5kZWQnLCAndG9wRXJyb3InLCAndG9wSW5wdXQnLCAndG9wSW52YWxpZCcsICd0b3BMb2FkJywgJ3RvcExvYWRlZERhdGEnLCAndG9wTG9hZGVkTWV0YWRhdGEnLCAndG9wTG9hZFN0YXJ0JywgJ3RvcFBhdXNlJywgJ3RvcFBsYXknLCAndG9wUGxheWluZycsICd0b3BQcm9ncmVzcycsICd0b3BSYXRlQ2hhbmdlJywgJ3RvcFJlc2V0JywgJ3RvcFNlZWtlZCcsICd0b3BTZWVraW5nJywgJ3RvcFN0YWxsZWQnLCAndG9wU3VibWl0JywgJ3RvcFN1c3BlbmQnLCAndG9wVGltZVVwZGF0ZScsICd0b3BUb2dnbGUnLCAndG9wVm9sdW1lQ2hhbmdlJywgJ3RvcFdhaXRpbmcnXTtcblxudmFyIFNpbXBsZUV2ZW50UGx1Z2luID0ge1xuICBldmVudFR5cGVzOiBldmVudFR5cGVzJDQsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGRpc3BhdGNoQ29uZmlnID0gdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnW3RvcExldmVsVHlwZV07XG4gICAgaWYgKCFkaXNwYXRjaENvbmZpZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBFdmVudENvbnN0cnVjdG9yO1xuICAgIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgICBjYXNlICd0b3BLZXlQcmVzcyc6XG4gICAgICAgIC8vIEZpcmVmb3ggY3JlYXRlcyBhIGtleXByZXNzIGV2ZW50IGZvciBmdW5jdGlvbiBrZXlzIHRvby4gVGhpcyByZW1vdmVzXG4gICAgICAgIC8vIHRoZSB1bndhbnRlZCBrZXlwcmVzcyBldmVudHMuIEVudGVyIGlzIGhvd2V2ZXIgYm90aCBwcmludGFibGUgYW5kXG4gICAgICAgIC8vIG5vbi1wcmludGFibGUuIE9uZSB3b3VsZCBleHBlY3QgVGFiIHRvIGJlIGFzIHdlbGwgKGJ1dCBpdCBpc24ndCkuXG4gICAgICAgIGlmIChnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlICd0b3BLZXlEb3duJzpcbiAgICAgIGNhc2UgJ3RvcEtleVVwJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQmx1cic6XG4gICAgICBjYXNlICd0b3BGb2N1cyc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcENsaWNrJzpcbiAgICAgICAgLy8gRmlyZWZveCBjcmVhdGVzIGEgY2xpY2sgZXZlbnQgb24gcmlnaHQgbW91c2UgY2xpY2tzLiBUaGlzIHJlbW92ZXMgdGhlXG4gICAgICAgIC8vIHVud2FudGVkIGNsaWNrIGV2ZW50cy5cbiAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmJ1dHRvbiA9PT0gMikge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlICd0b3BEb3VibGVDbGljayc6XG4gICAgICBjYXNlICd0b3BNb3VzZURvd24nOlxuICAgICAgY2FzZSAndG9wTW91c2VNb3ZlJzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlVXAnOlxuICAgICAgLy8gVE9ETzogRGlzYWJsZWQgZWxlbWVudHMgc2hvdWxkIG5vdCByZXNwb25kIHRvIG1vdXNlIGV2ZW50c1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSAndG9wTW91c2VPdXQnOlxuICAgICAgY2FzZSAndG9wTW91c2VPdmVyJzpcbiAgICAgIGNhc2UgJ3RvcENvbnRleHRNZW51JzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY01vdXNlRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wRHJhZyc6XG4gICAgICBjYXNlICd0b3BEcmFnRW5kJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdFbnRlcic6XG4gICAgICBjYXNlICd0b3BEcmFnRXhpdCc6XG4gICAgICBjYXNlICd0b3BEcmFnTGVhdmUnOlxuICAgICAgY2FzZSAndG9wRHJhZ092ZXInOlxuICAgICAgY2FzZSAndG9wRHJhZ1N0YXJ0JzpcbiAgICAgIGNhc2UgJ3RvcERyb3AnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRHJhZ0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcFRvdWNoQ2FuY2VsJzpcbiAgICAgIGNhc2UgJ3RvcFRvdWNoRW5kJzpcbiAgICAgIGNhc2UgJ3RvcFRvdWNoTW92ZSc6XG4gICAgICBjYXNlICd0b3BUb3VjaFN0YXJ0JzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1RvdWNoRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQW5pbWF0aW9uRW5kJzpcbiAgICAgIGNhc2UgJ3RvcEFuaW1hdGlvbkl0ZXJhdGlvbic6XG4gICAgICBjYXNlICd0b3BBbmltYXRpb25TdGFydCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNBbmltYXRpb25FdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BUcmFuc2l0aW9uRW5kJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BTY3JvbGwnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVUlFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BXaGVlbCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNXaGVlbEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcENvcHknOlxuICAgICAgY2FzZSAndG9wQ3V0JzpcbiAgICAgIGNhc2UgJ3RvcFBhc3RlJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoa25vd25IVE1MVG9wTGV2ZWxUeXBlcy5pbmRleE9mKHRvcExldmVsVHlwZSkgPT09IC0xKSB7XG4gICAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnU2ltcGxlRXZlbnRQbHVnaW46IFVuaGFuZGxlZCBldmVudCB0eXBlLCBgJXNgLiBUaGlzIHdhcm5pbmcgJyArICdpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCB0b3BMZXZlbFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBIVE1MIEV2ZW50c1xuICAgICAgICAvLyBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZGV4Lmh0bWwjZXZlbnRzLTBcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0V2ZW50JDE7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgZXZlbnQgPSBFdmVudENvbnN0cnVjdG9yLmdldFBvb2xlZChkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbn07XG5cbnNldEhhbmRsZVRvcExldmVsKGhhbmRsZVRvcExldmVsKTtcblxuLyoqXG4gKiBJbmplY3QgbW9kdWxlcyBmb3IgcmVzb2x2aW5nIERPTSBoaWVyYXJjaHkgYW5kIHBsdWdpbiBvcmRlcmluZy5cbiAqL1xuaW5qZWN0aW9uJDEuaW5qZWN0RXZlbnRQbHVnaW5PcmRlcihET01FdmVudFBsdWdpbk9yZGVyKTtcbmluamVjdGlvbiQyLmluamVjdENvbXBvbmVudFRyZWUoUmVhY3RET01Db21wb25lbnRUcmVlKTtcblxuLyoqXG4gKiBTb21lIGltcG9ydGFudCBldmVudCBwbHVnaW5zIGluY2x1ZGVkIGJ5IGRlZmF1bHQgKHdpdGhvdXQgaGF2aW5nIHRvIHJlcXVpcmVcbiAqIHRoZW0pLlxuICovXG5pbmplY3Rpb24kMS5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWUoe1xuICBTaW1wbGVFdmVudFBsdWdpbjogU2ltcGxlRXZlbnRQbHVnaW4sXG4gIEVudGVyTGVhdmVFdmVudFBsdWdpbjogRW50ZXJMZWF2ZUV2ZW50UGx1Z2luLFxuICBDaGFuZ2VFdmVudFBsdWdpbjogQ2hhbmdlRXZlbnRQbHVnaW4sXG4gIFNlbGVjdEV2ZW50UGx1Z2luOiBTZWxlY3RFdmVudFBsdWdpbixcbiAgQmVmb3JlSW5wdXRFdmVudFBsdWdpbjogQmVmb3JlSW5wdXRFdmVudFBsdWdpblxufSk7XG5cbnZhciBlbmFibGVBc3luY1N1YnRyZWVBUEkgPSB0cnVlO1xudmFyIGVuYWJsZUFzeW5jU2NoZWR1bGluZ0J5RGVmYXVsdEluUmVhY3RET00gPSBmYWxzZTtcbi8vIEV4cG9ydHMgUmVhY3RET00uY3JlYXRlUm9vdFxudmFyIGVuYWJsZUNyZWF0ZVJvb3QgPSBmYWxzZTtcbnZhciBlbmFibGVVc2VyVGltaW5nQVBJID0gdHJ1ZTtcblxuLy8gTXV0YXRpbmcgbW9kZSAoUmVhY3QgRE9NLCBSZWFjdCBBUlQsIFJlYWN0IE5hdGl2ZSk6XG52YXIgZW5hYmxlTXV0YXRpbmdSZWNvbmNpbGVyID0gdHJ1ZTtcbi8vIEV4cGVyaW1lbnRhbCBub29wIG1vZGUgKGN1cnJlbnRseSB1bnVzZWQpOlxudmFyIGVuYWJsZU5vb3BSZWNvbmNpbGVyID0gZmFsc2U7XG4vLyBFeHBlcmltZW50YWwgcGVyc2lzdGVudCBtb2RlIChDUyk6XG52YXIgZW5hYmxlUGVyc2lzdGVudFJlY29uY2lsZXIgPSBmYWxzZTtcblxuLy8gSGVscHMgaWRlbnRpZnkgc2lkZSBlZmZlY3RzIGluIGJlZ2luLXBoYXNlIGxpZmVjeWNsZSBob29rcyBhbmQgc2V0U3RhdGUgcmVkdWNlcnM6XG52YXIgZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzID0gZmFsc2U7XG5cbi8vIE9ubHkgdXNlZCBpbiB3d3cgYnVpbGRzLlxuXG52YXIgdmFsdWVTdGFjayA9IFtdO1xuXG57XG4gIHZhciBmaWJlclN0YWNrID0gW107XG59XG5cbnZhciBpbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjcmVhdGVDdXJzb3IoZGVmYXVsdFZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgY3VycmVudDogZGVmYXVsdFZhbHVlXG4gIH07XG59XG5cblxuXG5mdW5jdGlvbiBwb3AoY3Vyc29yLCBmaWJlcikge1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1VuZXhwZWN0ZWQgcG9wLicpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAgaWYgKGZpYmVyICE9PSBmaWJlclN0YWNrW2luZGV4XSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1VuZXhwZWN0ZWQgRmliZXIgcG9wcGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIGN1cnNvci5jdXJyZW50ID0gdmFsdWVTdGFja1tpbmRleF07XG5cbiAgdmFsdWVTdGFja1tpbmRleF0gPSBudWxsO1xuXG4gIHtcbiAgICBmaWJlclN0YWNrW2luZGV4XSA9IG51bGw7XG4gIH1cblxuICBpbmRleC0tO1xufVxuXG5mdW5jdGlvbiBwdXNoKGN1cnNvciwgdmFsdWUsIGZpYmVyKSB7XG4gIGluZGV4Kys7XG5cbiAgdmFsdWVTdGFja1tpbmRleF0gPSBjdXJzb3IuY3VycmVudDtcblxuICB7XG4gICAgZmliZXJTdGFja1tpbmRleF0gPSBmaWJlcjtcbiAgfVxuXG4gIGN1cnNvci5jdXJyZW50ID0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHJlc2V0JDEoKSB7XG4gIHdoaWxlIChpbmRleCA+IC0xKSB7XG4gICAgdmFsdWVTdGFja1tpbmRleF0gPSBudWxsO1xuXG4gICAge1xuICAgICAgZmliZXJTdGFja1tpbmRleF0gPSBudWxsO1xuICAgIH1cblxuICAgIGluZGV4LS07XG4gIH1cbn1cblxudmFyIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUgPSBmdW5jdGlvbiAobmFtZSwgc291cmNlLCBvd25lck5hbWUpIHtcbiAgcmV0dXJuICdcXG4gICAgaW4gJyArIChuYW1lIHx8ICdVbmtub3duJykgKyAoc291cmNlID8gJyAoYXQgJyArIHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJykgKyAnOicgKyBzb3VyY2UubGluZU51bWJlciArICcpJyA6IG93bmVyTmFtZSA/ICcgKGNyZWF0ZWQgYnkgJyArIG93bmVyTmFtZSArICcpJyA6ICcnKTtcbn07XG5cbmZ1bmN0aW9uIGRlc2NyaWJlRmliZXIoZmliZXIpIHtcbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50OlxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgdmFyIG93bmVyID0gZmliZXIuX2RlYnVnT3duZXI7XG4gICAgICB2YXIgc291cmNlID0gZmliZXIuX2RlYnVnU291cmNlO1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKTtcbiAgICAgIHZhciBvd25lck5hbWUgPSBudWxsO1xuICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgIG93bmVyTmFtZSA9IGdldENvbXBvbmVudE5hbWUob3duZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lck5hbWUpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBjYW4gb25seSBiZSBjYWxsZWQgd2l0aCBhIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIgYW5kXG4vLyBvbmx5IGR1cmluZyBiZWdpbiBvciBjb21wbGV0ZSBwaGFzZS4gRG8gbm90IGNhbGwgaXQgdW5kZXIgYW55IG90aGVyXG4vLyBjaXJjdW1zdGFuY2VzLlxuZnVuY3Rpb24gZ2V0U3RhY2tBZGRlbmR1bUJ5V29ya0luUHJvZ3Jlc3NGaWJlcih3b3JrSW5Qcm9ncmVzcykge1xuICB2YXIgaW5mbyA9ICcnO1xuICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzO1xuICBkbyB7XG4gICAgaW5mbyArPSBkZXNjcmliZUZpYmVyKG5vZGUpO1xuICAgIC8vIE90aGVyd2lzZSB0aGlzIHJldHVybiBwb2ludGVyIG1pZ2h0IHBvaW50IHRvIHRoZSB3cm9uZyB0cmVlOlxuICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgfSB3aGlsZSAobm9kZSk7XG4gIHJldHVybiBpbmZvO1xufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXJPd25lck5hbWUoKSB7XG4gIHtcbiAgICB2YXIgZmliZXIgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQ7XG4gICAgaWYgKGZpYmVyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIG93bmVyID0gZmliZXIuX2RlYnVnT3duZXI7XG4gICAgaWYgKG93bmVyICE9PSBudWxsICYmIHR5cGVvZiBvd25lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKG93bmVyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0oKSB7XG4gIHtcbiAgICB2YXIgZmliZXIgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQ7XG4gICAgaWYgKGZpYmVyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gU2FmZSBiZWNhdXNlIGlmIGN1cnJlbnQgZmliZXIgZXhpc3RzLCB3ZSBhcmUgcmVjb25jaWxpbmcsXG4gICAgLy8gYW5kIGl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgdmVyc2lvbi5cbiAgICByZXR1cm4gZ2V0U3RhY2tBZGRlbmR1bUJ5V29ya0luUHJvZ3Jlc3NGaWJlcihmaWJlcik7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHJlc2V0Q3VycmVudEZpYmVyKCkge1xuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IG51bGw7XG4gIFJlYWN0RGVidWdDdXJyZW50RmliZXIuY3VycmVudCA9IG51bGw7XG4gIFJlYWN0RGVidWdDdXJyZW50RmliZXIucGhhc2UgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBzZXRDdXJyZW50RmliZXIoZmliZXIpIHtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQgPSBmaWJlcjtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRQaGFzZShwaGFzZSkge1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnBoYXNlID0gcGhhc2U7XG59XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZpYmVyID0ge1xuICBjdXJyZW50OiBudWxsLFxuICBwaGFzZTogbnVsbCxcbiAgcmVzZXRDdXJyZW50RmliZXI6IHJlc2V0Q3VycmVudEZpYmVyLFxuICBzZXRDdXJyZW50RmliZXI6IHNldEN1cnJlbnRGaWJlcixcbiAgc2V0Q3VycmVudFBoYXNlOiBzZXRDdXJyZW50UGhhc2UsXG4gIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZTogZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lLFxuICBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtOiBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtXG59O1xuXG4vLyBQcmVmaXggbWVhc3VyZW1lbnRzIHNvIHRoYXQgaXQncyBwb3NzaWJsZSB0byBmaWx0ZXIgdGhlbS5cbi8vIExvbmdlciBwcmVmaXhlcyBhcmUgaGFyZCB0byByZWFkIGluIERldlRvb2xzLlxudmFyIHJlYWN0RW1vamkgPSAnXFx1MjY5Qic7XG52YXIgd2FybmluZ0Vtb2ppID0gJ1xcdTI2RDQnO1xudmFyIHN1cHBvcnRzVXNlclRpbWluZyA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm1hcmsgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLmNsZWFyTWFya3MgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm1lYXN1cmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLmNsZWFyTWVhc3VyZXMgPT09ICdmdW5jdGlvbic7XG5cbi8vIEtlZXAgdHJhY2sgb2YgY3VycmVudCBmaWJlciBzbyB0aGF0IHdlIGtub3cgdGhlIHBhdGggdG8gdW53aW5kIG9uIHBhdXNlLlxuLy8gVE9ETzogdGhpcyBsb29rcyB0aGUgc2FtZSBhcyBuZXh0VW5pdE9mV29yayBpbiBzY2hlZHVsZXIuIENhbiB3ZSB1bmlmeSB0aGVtP1xudmFyIGN1cnJlbnRGaWJlciA9IG51bGw7XG4vLyBJZiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIHVzZXIgY29kZSwgd2hpY2ggZmliZXIgYW5kIG1ldGhvZCBpcyBpdD9cbi8vIFJldXNpbmcgYGN1cnJlbnRGaWJlcmAgd291bGQgYmUgY29uZnVzaW5nIGZvciB0aGlzIGJlY2F1c2UgdXNlciBjb2RlIGZpYmVyXG4vLyBjYW4gY2hhbmdlIGR1cmluZyBjb21taXQgcGhhc2UgdG9vLCBidXQgd2UgZG9uJ3QgbmVlZCB0byB1bndpbmQgaXQgKHNpbmNlXG4vLyBsaWZlY3ljbGVzIGluIHRoZSBjb21taXQgcGhhc2UgZG9uJ3QgcmVzZW1ibGUgYSB0cmVlKS5cbnZhciBjdXJyZW50UGhhc2UgPSBudWxsO1xudmFyIGN1cnJlbnRQaGFzZUZpYmVyID0gbnVsbDtcbi8vIERpZCBsaWZlY3ljbGUgaG9vayBzY2hlZHVsZSBhbiB1cGRhdGU/IFRoaXMgaXMgb2Z0ZW4gYSBwZXJmb3JtYW5jZSBwcm9ibGVtLFxuLy8gc28gd2Ugd2lsbCBrZWVwIHRyYWNrIG9mIGl0LCBhbmQgaW5jbHVkZSBpdCBpbiB0aGUgcmVwb3J0LlxuLy8gVHJhY2sgY29tbWl0cyBjYXVzZWQgYnkgY2FzY2FkaW5nIHVwZGF0ZXMuXG52YXIgaXNDb21taXR0aW5nID0gZmFsc2U7XG52YXIgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0ID0gZmFsc2U7XG52YXIgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50UGhhc2UgPSBmYWxzZTtcbnZhciBjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID0gMDtcbnZhciBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG52YXIgaXNXYWl0aW5nRm9yQ2FsbGJhY2sgPSBmYWxzZTtcbi8vIER1cmluZyBjb21taXRzLCB3ZSBvbmx5IHNob3cgYSBtZWFzdXJlbWVudCBvbmNlIHBlciBtZXRob2QgbmFtZVxuLy8gdG8gYXZvaWQgc3RyZXRjaCB0aGUgY29tbWl0IHBoYXNlIHdpdGggbWVhc3VyZW1lbnQgb3ZlcmhlYWQuXG52YXIgbGFiZWxzSW5DdXJyZW50Q29tbWl0ID0gbmV3IFNldCgpO1xuXG52YXIgZm9ybWF0TWFya05hbWUgPSBmdW5jdGlvbiAobWFya05hbWUpIHtcbiAgcmV0dXJuIHJlYWN0RW1vamkgKyAnICcgKyBtYXJrTmFtZTtcbn07XG5cbnZhciBmb3JtYXRMYWJlbCA9IGZ1bmN0aW9uIChsYWJlbCwgd2FybmluZyQkMSkge1xuICB2YXIgcHJlZml4ID0gd2FybmluZyQkMSA/IHdhcm5pbmdFbW9qaSArICcgJyA6IHJlYWN0RW1vamkgKyAnICc7XG4gIHZhciBzdWZmaXggPSB3YXJuaW5nJCQxID8gJyBXYXJuaW5nOiAnICsgd2FybmluZyQkMSA6ICcnO1xuICByZXR1cm4gJycgKyBwcmVmaXggKyBsYWJlbCArIHN1ZmZpeDtcbn07XG5cbnZhciBiZWdpbk1hcmsgPSBmdW5jdGlvbiAobWFya05hbWUpIHtcbiAgcGVyZm9ybWFuY2UubWFyayhmb3JtYXRNYXJrTmFtZShtYXJrTmFtZSkpO1xufTtcblxudmFyIGNsZWFyTWFyayA9IGZ1bmN0aW9uIChtYXJrTmFtZSkge1xuICBwZXJmb3JtYW5jZS5jbGVhck1hcmtzKGZvcm1hdE1hcmtOYW1lKG1hcmtOYW1lKSk7XG59O1xuXG52YXIgZW5kTWFyayA9IGZ1bmN0aW9uIChsYWJlbCwgbWFya05hbWUsIHdhcm5pbmckJDEpIHtcbiAgdmFyIGZvcm1hdHRlZE1hcmtOYW1lID0gZm9ybWF0TWFya05hbWUobWFya05hbWUpO1xuICB2YXIgZm9ybWF0dGVkTGFiZWwgPSBmb3JtYXRMYWJlbChsYWJlbCwgd2FybmluZyQkMSk7XG4gIHRyeSB7XG4gICAgcGVyZm9ybWFuY2UubWVhc3VyZShmb3JtYXR0ZWRMYWJlbCwgZm9ybWF0dGVkTWFya05hbWUpO1xuICB9IGNhdGNoIChlcnIpIHt9XG4gIC8vIElmIHByZXZpb3VzIG1hcmsgd2FzIG1pc3NpbmcgZm9yIHNvbWUgcmVhc29uLCB0aGlzIHdpbGwgdGhyb3cuXG4gIC8vIFRoaXMgY291bGQgb25seSBoYXBwZW4gaWYgUmVhY3QgY3Jhc2hlZCBpbiBhbiB1bmV4cGVjdGVkIHBsYWNlIGVhcmxpZXIuXG4gIC8vIERvbid0IHBpbGUgb24gd2l0aCBtb3JlIGVycm9ycy5cblxuICAvLyBDbGVhciBtYXJrcyBpbW1lZGlhdGVseSB0byBhdm9pZCBncm93aW5nIGJ1ZmZlci5cbiAgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyhmb3JtYXR0ZWRNYXJrTmFtZSk7XG4gIHBlcmZvcm1hbmNlLmNsZWFyTWVhc3VyZXMoZm9ybWF0dGVkTGFiZWwpO1xufTtcblxudmFyIGdldEZpYmVyTWFya05hbWUgPSBmdW5jdGlvbiAobGFiZWwsIGRlYnVnSUQpIHtcbiAgcmV0dXJuIGxhYmVsICsgJyAoIycgKyBkZWJ1Z0lEICsgJyknO1xufTtcblxudmFyIGdldEZpYmVyTGFiZWwgPSBmdW5jdGlvbiAoY29tcG9uZW50TmFtZSwgaXNNb3VudGVkLCBwaGFzZSkge1xuICBpZiAocGhhc2UgPT09IG51bGwpIHtcbiAgICAvLyBUaGVzZSBhcmUgY29tcG9zaXRlIGNvbXBvbmVudCB0b3RhbCB0aW1lIG1lYXN1cmVtZW50cy5cbiAgICByZXR1cm4gY29tcG9uZW50TmFtZSArICcgWycgKyAoaXNNb3VudGVkID8gJ3VwZGF0ZScgOiAnbW91bnQnKSArICddJztcbiAgfSBlbHNlIHtcbiAgICAvLyBDb21wb3NpdGUgY29tcG9uZW50IG1ldGhvZHMuXG4gICAgcmV0dXJuIGNvbXBvbmVudE5hbWUgKyAnLicgKyBwaGFzZTtcbiAgfVxufTtcblxudmFyIGJlZ2luRmliZXJNYXJrID0gZnVuY3Rpb24gKGZpYmVyLCBwaGFzZSkge1xuICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdVbmtub3duJztcbiAgdmFyIGRlYnVnSUQgPSBmaWJlci5fZGVidWdJRDtcbiAgdmFyIGlzTW91bnRlZCA9IGZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbDtcbiAgdmFyIGxhYmVsID0gZ2V0RmliZXJMYWJlbChjb21wb25lbnROYW1lLCBpc01vdW50ZWQsIHBoYXNlKTtcblxuICBpZiAoaXNDb21taXR0aW5nICYmIGxhYmVsc0luQ3VycmVudENvbW1pdC5oYXMobGFiZWwpKSB7XG4gICAgLy8gRHVyaW5nIHRoZSBjb21taXQgcGhhc2UsIHdlIGRvbid0IHNob3cgZHVwbGljYXRlIGxhYmVscyBiZWNhdXNlXG4gICAgLy8gdGhlcmUgaXMgYSBmaXhlZCBvdmVyaGVhZCBmb3IgZXZlcnkgbWVhc3VyZW1lbnQsIGFuZCB3ZSBkb24ndFxuICAgIC8vIHdhbnQgdG8gc3RyZXRjaCB0aGUgY29tbWl0IHBoYXNlIGJleW9uZCBuZWNlc3NhcnkuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxhYmVsc0luQ3VycmVudENvbW1pdC5hZGQobGFiZWwpO1xuXG4gIHZhciBtYXJrTmFtZSA9IGdldEZpYmVyTWFya05hbWUobGFiZWwsIGRlYnVnSUQpO1xuICBiZWdpbk1hcmsobWFya05hbWUpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBjbGVhckZpYmVyTWFyayA9IGZ1bmN0aW9uIChmaWJlciwgcGhhc2UpIHtcbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnVW5rbm93bic7XG4gIHZhciBkZWJ1Z0lEID0gZmliZXIuX2RlYnVnSUQ7XG4gIHZhciBpc01vdW50ZWQgPSBmaWJlci5hbHRlcm5hdGUgIT09IG51bGw7XG4gIHZhciBsYWJlbCA9IGdldEZpYmVyTGFiZWwoY29tcG9uZW50TmFtZSwgaXNNb3VudGVkLCBwaGFzZSk7XG4gIHZhciBtYXJrTmFtZSA9IGdldEZpYmVyTWFya05hbWUobGFiZWwsIGRlYnVnSUQpO1xuICBjbGVhck1hcmsobWFya05hbWUpO1xufTtcblxudmFyIGVuZEZpYmVyTWFyayA9IGZ1bmN0aW9uIChmaWJlciwgcGhhc2UsIHdhcm5pbmckJDEpIHtcbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnVW5rbm93bic7XG4gIHZhciBkZWJ1Z0lEID0gZmliZXIuX2RlYnVnSUQ7XG4gIHZhciBpc01vdW50ZWQgPSBmaWJlci5hbHRlcm5hdGUgIT09IG51bGw7XG4gIHZhciBsYWJlbCA9IGdldEZpYmVyTGFiZWwoY29tcG9uZW50TmFtZSwgaXNNb3VudGVkLCBwaGFzZSk7XG4gIHZhciBtYXJrTmFtZSA9IGdldEZpYmVyTWFya05hbWUobGFiZWwsIGRlYnVnSUQpO1xuICBlbmRNYXJrKGxhYmVsLCBtYXJrTmFtZSwgd2FybmluZyQkMSk7XG59O1xuXG52YXIgc2hvdWxkSWdub3JlRmliZXIgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgLy8gSG9zdCBjb21wb25lbnRzIHNob3VsZCBiZSBza2lwcGVkIGluIHRoZSB0aW1lbGluZS5cbiAgLy8gV2UgY291bGQgY2hlY2sgdHlwZW9mIGZpYmVyLnR5cGUsIGJ1dCBkb2VzIHRoaXMgd29yayB3aXRoIFJOP1xuICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgIGNhc2UgUmV0dXJuQ29tcG9uZW50OlxuICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG52YXIgY2xlYXJQZW5kaW5nUGhhc2VNZWFzdXJlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKGN1cnJlbnRQaGFzZSAhPT0gbnVsbCAmJiBjdXJyZW50UGhhc2VGaWJlciAhPT0gbnVsbCkge1xuICAgIGNsZWFyRmliZXJNYXJrKGN1cnJlbnRQaGFzZUZpYmVyLCBjdXJyZW50UGhhc2UpO1xuICB9XG4gIGN1cnJlbnRQaGFzZUZpYmVyID0gbnVsbDtcbiAgY3VycmVudFBoYXNlID0gbnVsbDtcbiAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50UGhhc2UgPSBmYWxzZTtcbn07XG5cbnZhciBwYXVzZVRpbWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gU3RvcHMgYWxsIGN1cnJlbnRseSBhY3RpdmUgbWVhc3VyZW1lbnRzIHNvIHRoYXQgdGhleSBjYW4gYmUgcmVzdW1lZFxuICAvLyBpZiB3ZSBjb250aW51ZSBpbiBhIGxhdGVyIGRlZmVycmVkIGxvb3AgZnJvbSB0aGUgc2FtZSB1bml0IG9mIHdvcmsuXG4gIHZhciBmaWJlciA9IGN1cnJlbnRGaWJlcjtcbiAgd2hpbGUgKGZpYmVyKSB7XG4gICAgaWYgKGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nKSB7XG4gICAgICBlbmRGaWJlck1hcmsoZmliZXIsIG51bGwsIG51bGwpO1xuICAgIH1cbiAgICBmaWJlciA9IGZpYmVyWydyZXR1cm4nXTtcbiAgfVxufTtcblxudmFyIHJlc3VtZVRpbWVyc1JlY3Vyc2l2ZWx5ID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gIGlmIChmaWJlclsncmV0dXJuJ10gIT09IG51bGwpIHtcbiAgICByZXN1bWVUaW1lcnNSZWN1cnNpdmVseShmaWJlclsncmV0dXJuJ10pO1xuICB9XG4gIGlmIChmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgIGJlZ2luRmliZXJNYXJrKGZpYmVyLCBudWxsKTtcbiAgfVxufTtcblxudmFyIHJlc3VtZVRpbWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gUmVzdW1lcyBhbGwgbWVhc3VyZW1lbnRzIHRoYXQgd2VyZSBhY3RpdmUgZHVyaW5nIHRoZSBsYXN0IGRlZmVycmVkIGxvb3AuXG4gIGlmIChjdXJyZW50RmliZXIgIT09IG51bGwpIHtcbiAgICByZXN1bWVUaW1lcnNSZWN1cnNpdmVseShjdXJyZW50RmliZXIpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWNvcmRFZmZlY3QoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQrKztcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRTY2hlZHVsZVVwZGF0ZSgpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoaXNDb21taXR0aW5nKSB7XG4gICAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFBoYXNlICE9PSBudWxsICYmIGN1cnJlbnRQaGFzZSAhPT0gJ2NvbXBvbmVudFdpbGxNb3VudCcgJiYgY3VycmVudFBoYXNlICE9PSAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycpIHtcbiAgICAgIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRSZXF1ZXN0Q2FsbGJhY2tUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nICYmICFpc1dhaXRpbmdGb3JDYWxsYmFjaykge1xuICAgICAgaXNXYWl0aW5nRm9yQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgYmVnaW5NYXJrKCcoV2FpdGluZyBmb3IgYXN5bmMgY2FsbGJhY2suLi4pJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BSZXF1ZXN0Q2FsbGJhY2tUaW1lcihkaWRFeHBpcmUpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICBpc1dhaXRpbmdGb3JDYWxsYmFjayA9IGZhbHNlO1xuICAgICAgdmFyIHdhcm5pbmckJDEgPSBkaWRFeHBpcmUgPyAnUmVhY3Qgd2FzIGJsb2NrZWQgYnkgbWFpbiB0aHJlYWQnIDogbnVsbDtcbiAgICAgIGVuZE1hcmsoJyhXYWl0aW5nIGZvciBhc3luYyBjYWxsYmFjay4uLiknLCAnKFdhaXRpbmcgZm9yIGFzeW5jIGNhbGxiYWNrLi4uKScsIHdhcm5pbmckJDEpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydFdvcmtUaW1lcihmaWJlcikge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nIHx8IHNob3VsZElnbm9yZUZpYmVyKGZpYmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBwYXVzZSwgdGhpcyBpcyB0aGUgZmliZXIgdG8gdW53aW5kIGZyb20uXG4gICAgY3VycmVudEZpYmVyID0gZmliZXI7XG4gICAgaWYgKCFiZWdpbkZpYmVyTWFyayhmaWJlciwgbnVsbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbmNlbFdvcmtUaW1lcihmaWJlcikge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nIHx8IHNob3VsZElnbm9yZUZpYmVyKGZpYmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBSZW1lbWJlciB3ZSBzaG91bGRuJ3QgY29tcGxldGUgbWVhc3VyZW1lbnQgZm9yIHRoaXMgZmliZXIuXG4gICAgLy8gT3RoZXJ3aXNlIGZsYW1lY2hhcnQgd2lsbCBiZSBkZWVwIGV2ZW4gZm9yIHNtYWxsIHVwZGF0ZXMuXG4gICAgZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcgPSBmYWxzZTtcbiAgICBjbGVhckZpYmVyTWFyayhmaWJlciwgbnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcFdvcmtUaW1lcihmaWJlcikge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nIHx8IHNob3VsZElnbm9yZUZpYmVyKGZpYmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBwYXVzZSwgaXRzIHBhcmVudCBpcyB0aGUgZmliZXIgdG8gdW53aW5kIGZyb20uXG4gICAgY3VycmVudEZpYmVyID0gZmliZXJbJ3JldHVybiddO1xuICAgIGlmICghZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcgPSBmYWxzZTtcbiAgICBlbmRGaWJlck1hcmsoZmliZXIsIG51bGwsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BGYWlsZWRXb3JrVGltZXIoZmliZXIpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZyB8fCBzaG91bGRJZ25vcmVGaWJlcihmaWJlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgd2UgcGF1c2UsIGl0cyBwYXJlbnQgaXMgdGhlIGZpYmVyIHRvIHVud2luZCBmcm9tLlxuICAgIGN1cnJlbnRGaWJlciA9IGZpYmVyWydyZXR1cm4nXTtcbiAgICBpZiAoIWZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgdmFyIHdhcm5pbmckJDEgPSAnQW4gZXJyb3Igd2FzIHRocm93biBpbnNpZGUgdGhpcyBlcnJvciBib3VuZGFyeSc7XG4gICAgZW5kRmliZXJNYXJrKGZpYmVyLCBudWxsLCB3YXJuaW5nJCQxKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydFBoYXNlVGltZXIoZmliZXIsIHBoYXNlKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2xlYXJQZW5kaW5nUGhhc2VNZWFzdXJlbWVudCgpO1xuICAgIGlmICghYmVnaW5GaWJlck1hcmsoZmliZXIsIHBoYXNlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjdXJyZW50UGhhc2VGaWJlciA9IGZpYmVyO1xuICAgIGN1cnJlbnRQaGFzZSA9IHBoYXNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BQaGFzZVRpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjdXJyZW50UGhhc2UgIT09IG51bGwgJiYgY3VycmVudFBoYXNlRmliZXIgIT09IG51bGwpIHtcbiAgICAgIHZhciB3YXJuaW5nJCQxID0gaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50UGhhc2UgPyAnU2NoZWR1bGVkIGEgY2FzY2FkaW5nIHVwZGF0ZScgOiBudWxsO1xuICAgICAgZW5kRmliZXJNYXJrKGN1cnJlbnRQaGFzZUZpYmVyLCBjdXJyZW50UGhhc2UsIHdhcm5pbmckJDEpO1xuICAgIH1cbiAgICBjdXJyZW50UGhhc2UgPSBudWxsO1xuICAgIGN1cnJlbnRQaGFzZUZpYmVyID0gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydFdvcmtMb29wVGltZXIobmV4dFVuaXRPZldvcmspIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBjdXJyZW50RmliZXIgPSBuZXh0VW5pdE9mV29yaztcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID0gMDtcbiAgICAvLyBUaGlzIGlzIHRvcCBsZXZlbCBjYWxsLlxuICAgIC8vIEFueSBvdGhlciBtZWFzdXJlbWVudHMgYXJlIHBlcmZvcm1lZCB3aXRoaW4uXG4gICAgYmVnaW5NYXJrKCcoUmVhY3QgVHJlZSBSZWNvbmNpbGlhdGlvbiknKTtcbiAgICAvLyBSZXN1bWUgYW55IG1lYXN1cmVtZW50cyB0aGF0IHdlcmUgaW4gcHJvZ3Jlc3MgZHVyaW5nIHRoZSBsYXN0IGxvb3AuXG4gICAgcmVzdW1lVGltZXJzKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcFdvcmtMb29wVGltZXIoaW50ZXJydXB0ZWRCeSkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB3YXJuaW5nJCQxID0gbnVsbDtcbiAgICBpZiAoaW50ZXJydXB0ZWRCeSAhPT0gbnVsbCkge1xuICAgICAgaWYgKGludGVycnVwdGVkQnkudGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgICB3YXJuaW5nJCQxID0gJ0EgdG9wLWxldmVsIHVwZGF0ZSBpbnRlcnJ1cHRlZCB0aGUgcHJldmlvdXMgcmVuZGVyJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShpbnRlcnJ1cHRlZEJ5KSB8fCAnVW5rbm93bic7XG4gICAgICAgIHdhcm5pbmckJDEgPSAnQW4gdXBkYXRlIHRvICcgKyBjb21wb25lbnROYW1lICsgJyBpbnRlcnJ1cHRlZCB0aGUgcHJldmlvdXMgcmVuZGVyJztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3AgPiAxKSB7XG4gICAgICB3YXJuaW5nJCQxID0gJ1RoZXJlIHdlcmUgY2FzY2FkaW5nIHVwZGF0ZXMnO1xuICAgIH1cbiAgICBjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID0gMDtcbiAgICAvLyBQYXVzZSBhbnkgbWVhc3VyZW1lbnRzIHVudGlsIHRoZSBuZXh0IGxvb3AuXG4gICAgcGF1c2VUaW1lcnMoKTtcbiAgICBlbmRNYXJrKCcoUmVhY3QgVHJlZSBSZWNvbmNpbGlhdGlvbiknLCAnKFJlYWN0IFRyZWUgUmVjb25jaWxpYXRpb24pJywgd2FybmluZyQkMSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRDb21taXRUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpc0NvbW1pdHRpbmcgPSB0cnVlO1xuICAgIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudENvbW1pdCA9IGZhbHNlO1xuICAgIGxhYmVsc0luQ3VycmVudENvbW1pdC5jbGVhcigpO1xuICAgIGJlZ2luTWFyaygnKENvbW1pdHRpbmcgQ2hhbmdlcyknKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wQ29tbWl0VGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgd2FybmluZyQkMSA9IG51bGw7XG4gICAgaWYgKGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudENvbW1pdCkge1xuICAgICAgd2FybmluZyQkMSA9ICdMaWZlY3ljbGUgaG9vayBzY2hlZHVsZWQgYSBjYXNjYWRpbmcgdXBkYXRlJztcbiAgICB9IGVsc2UgaWYgKGNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3AgPiAwKSB7XG4gICAgICB3YXJuaW5nJCQxID0gJ0NhdXNlZCBieSBhIGNhc2NhZGluZyB1cGRhdGUgaW4gZWFybGllciBjb21taXQnO1xuICAgIH1cbiAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSBmYWxzZTtcbiAgICBjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wKys7XG4gICAgaXNDb21taXR0aW5nID0gZmFsc2U7XG4gICAgbGFiZWxzSW5DdXJyZW50Q29tbWl0LmNsZWFyKCk7XG5cbiAgICBlbmRNYXJrKCcoQ29tbWl0dGluZyBDaGFuZ2VzKScsICcoQ29tbWl0dGluZyBDaGFuZ2VzKScsIHdhcm5pbmckJDEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29tbWl0SG9zdEVmZmVjdHNUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG4gICAgYmVnaW5NYXJrKCcoQ29tbWl0dGluZyBIb3N0IEVmZmVjdHMpJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNvdW50ID0gZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQ7XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGVuZE1hcmsoJyhDb21taXR0aW5nIEhvc3QgRWZmZWN0czogJyArIGNvdW50ICsgJyBUb3RhbCknLCAnKENvbW1pdHRpbmcgSG9zdCBFZmZlY3RzKScsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29tbWl0TGlmZUN5Y2xlc1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBiZWdpbk1hcmsoJyhDYWxsaW5nIExpZmVjeWNsZSBNZXRob2RzKScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BDb21taXRMaWZlQ3ljbGVzVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNvdW50ID0gZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQ7XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGVuZE1hcmsoJyhDYWxsaW5nIExpZmVjeWNsZSBNZXRob2RzOiAnICsgY291bnQgKyAnIFRvdGFsKScsICcoQ2FsbGluZyBMaWZlY3ljbGUgTWV0aG9kcyknLCBudWxsKTtcbiAgfVxufVxuXG57XG4gIHZhciB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHQgPSB7fTtcbn1cblxuLy8gQSBjdXJzb3IgdG8gdGhlIGN1cnJlbnQgbWVyZ2VkIGNvbnRleHQgb2JqZWN0IG9uIHRoZSBzdGFjay5cbnZhciBjb250ZXh0U3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoZW1wdHlPYmplY3QpO1xuLy8gQSBjdXJzb3IgdG8gYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgY29udGV4dCBoYXMgY2hhbmdlZC5cbnZhciBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKGZhbHNlKTtcbi8vIEtlZXAgdHJhY2sgb2YgdGhlIHByZXZpb3VzIGNvbnRleHQgb2JqZWN0IHRoYXQgd2FzIG9uIHRoZSBzdGFjay5cbi8vIFdlIHVzZSB0aGlzIHRvIGdldCBhY2Nlc3MgdG8gdGhlIHBhcmVudCBjb250ZXh0IGFmdGVyIHdlIGhhdmUgYWxyZWFkeVxuLy8gcHVzaGVkIHRoZSBuZXh0IGNvbnRleHQgcHJvdmlkZXIsIGFuZCBub3cgbmVlZCB0byBtZXJnZSB0aGVpciBjb250ZXh0cy5cbnZhciBwcmV2aW91c0NvbnRleHQgPSBlbXB0eU9iamVjdDtcblxuZnVuY3Rpb24gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKSB7XG4gIHZhciBoYXNPd25Db250ZXh0ID0gaXNDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICBpZiAoaGFzT3duQ29udGV4dCkge1xuICAgIC8vIElmIHRoZSBmaWJlciBpcyBhIGNvbnRleHQgcHJvdmlkZXIgaXRzZWxmLCB3aGVuIHdlIHJlYWQgaXRzIGNvbnRleHRcbiAgICAvLyB3ZSBoYXZlIGFscmVhZHkgcHVzaGVkIGl0cyBvd24gY2hpbGQgY29udGV4dCBvbiB0aGUgc3RhY2suIEEgY29udGV4dFxuICAgIC8vIHByb3ZpZGVyIHNob3VsZCBub3QgXCJzZWVcIiBpdHMgb3duIGNoaWxkIGNvbnRleHQuIFRoZXJlZm9yZSB3ZSByZWFkIHRoZVxuICAgIC8vIHByZXZpb3VzIChwYXJlbnQpIGNvbnRleHQgaW5zdGVhZCBmb3IgYSBjb250ZXh0IHByb3ZpZGVyLlxuICAgIHJldHVybiBwcmV2aW91c0NvbnRleHQ7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50O1xufVxuXG5mdW5jdGlvbiBjYWNoZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCwgbWFza2VkQ29udGV4dCkge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQgPSB1bm1hc2tlZENvbnRleHQ7XG4gIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0ID0gbWFza2VkQ29udGV4dDtcbn1cblxuZnVuY3Rpb24gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KSB7XG4gIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgdmFyIGNvbnRleHRUeXBlcyA9IHR5cGUuY29udGV4dFR5cGVzO1xuICBpZiAoIWNvbnRleHRUeXBlcykge1xuICAgIHJldHVybiBlbXB0eU9iamVjdDtcbiAgfVxuXG4gIC8vIEF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIHVubWFza2VkIGNvbnRleHQgaGFzIGNoYW5nZWQuXG4gIC8vIEZhaWxpbmcgdG8gZG8gdGhpcyB3aWxsIHJlc3VsdCBpbiB1bm5lY2Vzc2FyeSBjYWxscyB0byBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLlxuICAvLyBUaGlzIG1heSB0cmlnZ2VyIGluZmluaXRlIGxvb3BzIGlmIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgY2FsbHMgc2V0U3RhdGUuXG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQgPT09IHVubWFza2VkQ29udGV4dCkge1xuICAgIHJldHVybiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dDtcbiAgfVxuXG4gIHZhciBjb250ZXh0ID0ge307XG4gIGZvciAodmFyIGtleSBpbiBjb250ZXh0VHlwZXMpIHtcbiAgICBjb250ZXh0W2tleV0gPSB1bm1hc2tlZENvbnRleHRba2V5XTtcbiAgfVxuXG4gIHtcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpIHx8ICdVbmtub3duJztcbiAgICBjaGVja1Byb3BUeXBlcyhjb250ZXh0VHlwZXMsIGNvbnRleHQsICdjb250ZXh0JywgbmFtZSwgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtKTtcbiAgfVxuXG4gIC8vIENhY2hlIHVubWFza2VkIGNvbnRleHQgc28gd2UgY2FuIGF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIG5lY2Vzc2FyeS5cbiAgLy8gQ29udGV4dCBpcyBjcmVhdGVkIGJlZm9yZSB0aGUgY2xhc3MgY29tcG9uZW50IGlzIGluc3RhbnRpYXRlZCBzbyBjaGVjayBmb3IgaW5zdGFuY2UuXG4gIGlmIChpbnN0YW5jZSkge1xuICAgIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5mdW5jdGlvbiBoYXNDb250ZXh0Q2hhbmdlZCgpIHtcbiAgcmV0dXJuIGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IuY3VycmVudDtcbn1cblxuZnVuY3Rpb24gaXNDb250ZXh0Q29uc3VtZXIoZmliZXIpIHtcbiAgcmV0dXJuIGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQgJiYgZmliZXIudHlwZS5jb250ZXh0VHlwZXMgIT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIoZmliZXIpIHtcbiAgcmV0dXJuIGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQgJiYgZmliZXIudHlwZS5jaGlsZENvbnRleHRUeXBlcyAhPSBudWxsO1xufVxuXG5mdW5jdGlvbiBwb3BDb250ZXh0UHJvdmlkZXIoZmliZXIpIHtcbiAgaWYgKCFpc0NvbnRleHRQcm92aWRlcihmaWJlcikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZmliZXIpO1xuICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHBvcFRvcExldmVsQ29udGV4dE9iamVjdChmaWJlcikge1xuICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZmliZXIpO1xuICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3QoZmliZXIsIGNvbnRleHQsIGRpZENoYW5nZSkge1xuICAhKGNvbnRleHRTdGFja0N1cnNvci5jdXJzb3IgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmV4cGVjdGVkIGNvbnRleHQgZm91bmQgb24gc3RhY2suIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIGNvbnRleHQsIGZpYmVyKTtcbiAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRDaGFuZ2UsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0NoaWxkQ29udGV4dChmaWJlciwgcGFyZW50Q29udGV4dCkge1xuICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gIHZhciBjaGlsZENvbnRleHRUeXBlcyA9IGZpYmVyLnR5cGUuY2hpbGRDb250ZXh0VHlwZXM7XG5cbiAgLy8gVE9ETyAoYnZhdWdobikgUmVwbGFjZSB0aGlzIGJlaGF2aW9yIHdpdGggYW4gaW52YXJpYW50KCkgaW4gdGhlIGZ1dHVyZS5cbiAgLy8gSXQgaGFzIG9ubHkgYmVlbiBhZGRlZCBpbiBGaWJlciB0byBtYXRjaCB0aGUgKHVuaW50ZW50aW9uYWwpIGJlaGF2aW9yIGluIFN0YWNrLlxuICBpZiAodHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nO1xuXG4gICAgICBpZiAoIXdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dFtjb21wb25lbnROYW1lXSkge1xuICAgICAgICB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHRbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMuY2hpbGRDb250ZXh0VHlwZXMgaXMgc3BlY2lmaWVkIGJ1dCB0aGVyZSBpcyBubyBnZXRDaGlsZENvbnRleHQoKSBtZXRob2QgJyArICdvbiB0aGUgaW5zdGFuY2UuIFlvdSBjYW4gZWl0aGVyIGRlZmluZSBnZXRDaGlsZENvbnRleHQoKSBvbiAlcyBvciByZW1vdmUgJyArICdjaGlsZENvbnRleHRUeXBlcyBmcm9tIGl0LicsIGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyZW50Q29udGV4dDtcbiAgfVxuXG4gIHZhciBjaGlsZENvbnRleHQgPSB2b2lkIDA7XG4gIHtcbiAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZSgnZ2V0Q2hpbGRDb250ZXh0Jyk7XG4gIH1cbiAgc3RhcnRQaGFzZVRpbWVyKGZpYmVyLCAnZ2V0Q2hpbGRDb250ZXh0Jyk7XG4gIGNoaWxkQ29udGV4dCA9IGluc3RhbmNlLmdldENoaWxkQ29udGV4dCgpO1xuICBzdG9wUGhhc2VUaW1lcigpO1xuICB7XG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UobnVsbCk7XG4gIH1cbiAgZm9yICh2YXIgY29udGV4dEtleSBpbiBjaGlsZENvbnRleHQpIHtcbiAgICAhKGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0VHlwZXMpID8gaW52YXJpYW50KGZhbHNlLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGtleSBcIiVzXCIgaXMgbm90IGRlZmluZWQgaW4gY2hpbGRDb250ZXh0VHlwZXMuJywgZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nLCBjb250ZXh0S2V5KSA6IHZvaWQgMDtcbiAgfVxuICB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnVW5rbm93bic7XG4gICAgY2hlY2tQcm9wVHlwZXMoY2hpbGRDb250ZXh0VHlwZXMsIGNoaWxkQ29udGV4dCwgJ2NoaWxkIGNvbnRleHQnLCBuYW1lLFxuICAgIC8vIEluIHByYWN0aWNlLCB0aGVyZSBpcyBvbmUgY2FzZSBpbiB3aGljaCB3ZSB3b24ndCBnZXQgYSBzdGFjay4gSXQncyB3aGVuXG4gICAgLy8gc29tZWJvZHkgY2FsbHMgdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIoKSBhbmQgd2UgcHJvY2Vzc1xuICAgIC8vIGNvbnRleHQgZnJvbSB0aGUgcGFyZW50IGNvbXBvbmVudCBpbnN0YW5jZS4gVGhlIHN0YWNrIHdpbGwgYmUgbWlzc2luZ1xuICAgIC8vIGJlY2F1c2UgaXQncyBvdXRzaWRlIG9mIHRoZSByZWNvbmNpbGlhdGlvbiwgYW5kIHNvIHRoZSBwb2ludGVyIGhhcyBub3RcbiAgICAvLyBiZWVuIHNldC4gVGhpcyBpcyByYXJlIGFuZCBkb2Vzbid0IG1hdHRlci4gV2UnbGwgYWxzbyByZW1vdmUgdGhhdCBBUEkuXG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtKTtcbiAgfVxuXG4gIHJldHVybiBfYXNzaWduKHt9LCBwYXJlbnRDb250ZXh0LCBjaGlsZENvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKSB7XG4gIGlmICghaXNDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAvLyBXZSBwdXNoIHRoZSBjb250ZXh0IGFzIGVhcmx5IGFzIHBvc3NpYmxlIHRvIGVuc3VyZSBzdGFjayBpbnRlZ3JpdHkuXG4gIC8vIElmIHRoZSBpbnN0YW5jZSBkb2VzIG5vdCBleGlzdCB5ZXQsIHdlIHdpbGwgcHVzaCBudWxsIGF0IGZpcnN0LFxuICAvLyBhbmQgcmVwbGFjZSBpdCBvbiB0aGUgc3RhY2sgbGF0ZXIgd2hlbiBpbnZhbGlkYXRpbmcgdGhlIGNvbnRleHQuXG4gIHZhciBtZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCA9IGluc3RhbmNlICYmIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0IHx8IGVtcHR5T2JqZWN0O1xuXG4gIC8vIFJlbWVtYmVyIHRoZSBwYXJlbnQgY29udGV4dCBzbyB3ZSBjYW4gbWVyZ2Ugd2l0aCBpdCBsYXRlci5cbiAgLy8gSW5oZXJpdCB0aGUgcGFyZW50J3MgZGlkLXBlcmZvcm0td29yayB2YWx1ZSB0byBhdm9pZCBpbmFkdmVydGVudGx5IGJsb2NraW5nIHVwZGF0ZXMuXG4gIHByZXZpb3VzQ29udGV4dCA9IGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50O1xuICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLmN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgZGlkQ2hhbmdlKSB7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgIWluc3RhbmNlID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgdG8gaGF2ZSBhbiBpbnN0YW5jZSBieSB0aGlzIHBvaW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gIGlmIChkaWRDaGFuZ2UpIHtcbiAgICAvLyBNZXJnZSBwYXJlbnQgYW5kIG93biBjb250ZXh0LlxuICAgIC8vIFNraXAgdGhpcyBpZiB3ZSdyZSBub3QgdXBkYXRpbmcgZHVlIHRvIHNDVS5cbiAgICAvLyBUaGlzIGF2b2lkcyB1bm5lY2Vzc2FyaWx5IHJlY29tcHV0aW5nIG1lbW9pemVkIHZhbHVlcy5cbiAgICB2YXIgbWVyZ2VkQ29udGV4dCA9IHByb2Nlc3NDaGlsZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHByZXZpb3VzQ29udGV4dCk7XG4gICAgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQgPSBtZXJnZWRDb250ZXh0O1xuXG4gICAgLy8gUmVwbGFjZSB0aGUgb2xkIChvciBlbXB0eSkgY29udGV4dCB3aXRoIHRoZSBuZXcgb25lLlxuICAgIC8vIEl0IGlzIGltcG9ydGFudCB0byB1bndpbmQgdGhlIGNvbnRleHQgaW4gdGhlIHJldmVyc2Ugb3JkZXIuXG4gICAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIHdvcmtJblByb2dyZXNzKTtcbiAgICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgLy8gTm93IHB1c2ggdGhlIG5ldyBjb250ZXh0IGFuZCBtYXJrIHRoYXQgaXQgaGFzIGNoYW5nZWQuXG4gICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG1lcmdlZENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZENoYW5nZSwgd29ya0luUHJvZ3Jlc3MpO1xuICB9IGVsc2Uge1xuICAgIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRDaGFuZ2UsIHdvcmtJblByb2dyZXNzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNldENvbnRleHQoKSB7XG4gIHByZXZpb3VzQ29udGV4dCA9IGVtcHR5T2JqZWN0O1xuICBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCA9IGVtcHR5T2JqZWN0O1xuICBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLmN1cnJlbnQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQoZmliZXIpIHtcbiAgLy8gQ3VycmVudGx5IHRoaXMgaXMgb25seSB1c2VkIHdpdGggcmVuZGVyU3VidHJlZUludG9Db250YWluZXI7IG5vdCBzdXJlIGlmIGl0XG4gIC8vIG1ha2VzIHNlbnNlIGVsc2V3aGVyZVxuICAhKGlzRmliZXJNb3VudGVkKGZpYmVyKSAmJiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHN1YnRyZWUgcGFyZW50IHRvIGJlIGEgbW91bnRlZCBjbGFzcyBjb21wb25lbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgd2hpbGUgKG5vZGUudGFnICE9PSBIb3N0Um9vdCkge1xuICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihub2RlKSkge1xuICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0O1xuICAgIH1cbiAgICB2YXIgcGFyZW50ID0gbm9kZVsncmV0dXJuJ107XG4gICAgIXBhcmVudCA/IGludmFyaWFudChmYWxzZSwgJ0ZvdW5kIHVuZXhwZWN0ZWQgZGV0YWNoZWQgc3VidHJlZSBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgbm9kZSA9IHBhcmVudDtcbiAgfVxuICByZXR1cm4gbm9kZS5zdGF0ZU5vZGUuY29udGV4dDtcbn1cblxudmFyIE5vV29yayA9IDA7IC8vIFRPRE86IFVzZSBhbiBvcGFxdWUgdHlwZSBvbmNlIEVTTGludCBldCBhbCBzdXBwb3J0IHRoZSBzeW50YXhcblxudmFyIFN5bmMgPSAxO1xudmFyIE5ldmVyID0gMjE0NzQ4MzY0NzsgLy8gTWF4IGludDMyOiBNYXRoLnBvdygyLCAzMSkgLSAxXG5cbnZhciBVTklUX1NJWkUgPSAxMDtcbnZhciBNQUdJQ19OVU1CRVJfT0ZGU0VUID0gMjtcblxuLy8gMSB1bml0IG9mIGV4cGlyYXRpb24gdGltZSByZXByZXNlbnRzIDEwbXMuXG5mdW5jdGlvbiBtc1RvRXhwaXJhdGlvblRpbWUobXMpIHtcbiAgLy8gQWx3YXlzIGFkZCBhbiBvZmZzZXQgc28gdGhhdCB3ZSBkb24ndCBjbGFzaCB3aXRoIHRoZSBtYWdpYyBudW1iZXIgZm9yIE5vV29yay5cbiAgcmV0dXJuIChtcyAvIFVOSVRfU0laRSB8IDApICsgTUFHSUNfTlVNQkVSX09GRlNFVDtcbn1cblxuZnVuY3Rpb24gZXhwaXJhdGlvblRpbWVUb01zKGV4cGlyYXRpb25UaW1lKSB7XG4gIHJldHVybiAoZXhwaXJhdGlvblRpbWUgLSBNQUdJQ19OVU1CRVJfT0ZGU0VUKSAqIFVOSVRfU0laRTtcbn1cblxuZnVuY3Rpb24gY2VpbGluZyhudW0sIHByZWNpc2lvbikge1xuICByZXR1cm4gKChudW0gLyBwcmVjaXNpb24gfCAwKSArIDEpICogcHJlY2lzaW9uO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlRXhwaXJhdGlvbkJ1Y2tldChjdXJyZW50VGltZSwgZXhwaXJhdGlvbkluTXMsIGJ1Y2tldFNpemVNcykge1xuICByZXR1cm4gY2VpbGluZyhjdXJyZW50VGltZSArIGV4cGlyYXRpb25Jbk1zIC8gVU5JVF9TSVpFLCBidWNrZXRTaXplTXMgLyBVTklUX1NJWkUpO1xufVxuXG52YXIgTm9Db250ZXh0ID0gMDtcbnZhciBBc3luY1VwZGF0ZXMgPSAxO1xuXG57XG4gIHZhciBoYXNCYWRNYXBQb2x5ZmlsbCA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBub25FeHRlbnNpYmxlT2JqZWN0ID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXcgKi9cbiAgICBcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLW5ldyAqL1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gVE9ETzogQ29uc2lkZXIgd2FybmluZyBhYm91dCBiYWQgcG9seWZpbGxzXG4gICAgaGFzQmFkTWFwUG9seWZpbGwgPSB0cnVlO1xuICB9XG59XG5cbi8vIEEgRmliZXIgaXMgd29yayBvbiBhIENvbXBvbmVudCB0aGF0IG5lZWRzIHRvIGJlIGRvbmUgb3Igd2FzIGRvbmUuIFRoZXJlIGNhblxuLy8gYmUgbW9yZSB0aGFuIG9uZSBwZXIgY29tcG9uZW50LlxuXG5cbntcbiAgdmFyIGRlYnVnQ291bnRlciA9IDE7XG59XG5cbmZ1bmN0aW9uIEZpYmVyTm9kZSh0YWcsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKSB7XG4gIC8vIEluc3RhbmNlXG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmtleSA9IGtleTtcbiAgdGhpcy50eXBlID0gbnVsbDtcbiAgdGhpcy5zdGF0ZU5vZGUgPSBudWxsO1xuXG4gIC8vIEZpYmVyXG4gIHRoaXNbJ3JldHVybiddID0gbnVsbDtcbiAgdGhpcy5jaGlsZCA9IG51bGw7XG4gIHRoaXMuc2libGluZyA9IG51bGw7XG4gIHRoaXMuaW5kZXggPSAwO1xuXG4gIHRoaXMucmVmID0gbnVsbDtcblxuICB0aGlzLnBlbmRpbmdQcm9wcyA9IG51bGw7XG4gIHRoaXMubWVtb2l6ZWRQcm9wcyA9IG51bGw7XG4gIHRoaXMudXBkYXRlUXVldWUgPSBudWxsO1xuICB0aGlzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuXG4gIHRoaXMuaW50ZXJuYWxDb250ZXh0VGFnID0gaW50ZXJuYWxDb250ZXh0VGFnO1xuXG4gIC8vIEVmZmVjdHNcbiAgdGhpcy5lZmZlY3RUYWcgPSBOb0VmZmVjdDtcbiAgdGhpcy5uZXh0RWZmZWN0ID0gbnVsbDtcblxuICB0aGlzLmZpcnN0RWZmZWN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0RWZmZWN0ID0gbnVsbDtcblxuICB0aGlzLmV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuXG4gIHRoaXMuYWx0ZXJuYXRlID0gbnVsbDtcblxuICB7XG4gICAgdGhpcy5fZGVidWdJRCA9IGRlYnVnQ291bnRlcisrO1xuICAgIHRoaXMuX2RlYnVnU291cmNlID0gbnVsbDtcbiAgICB0aGlzLl9kZWJ1Z093bmVyID0gbnVsbDtcbiAgICB0aGlzLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgaWYgKCFoYXNCYWRNYXBQb2x5ZmlsbCAmJiB0eXBlb2YgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnModGhpcyk7XG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgaXMgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgcmF0aGVyIHRoYW4gYSBQT0pPIGNvbnN0cnVjdG9yLCBzdGlsbFxuLy8gcGxlYXNlIGVuc3VyZSB3ZSBkbyB0aGUgZm9sbG93aW5nOlxuLy8gMSkgTm9ib2R5IHNob3VsZCBhZGQgYW55IGluc3RhbmNlIG1ldGhvZHMgb24gdGhpcy4gSW5zdGFuY2UgbWV0aG9kcyBjYW4gYmVcbi8vICAgIG1vcmUgZGlmZmljdWx0IHRvIHByZWRpY3Qgd2hlbiB0aGV5IGdldCBvcHRpbWl6ZWQgYW5kIHRoZXkgYXJlIGFsbW9zdFxuLy8gICAgbmV2ZXIgaW5saW5lZCBwcm9wZXJseSBpbiBzdGF0aWMgY29tcGlsZXJzLlxuLy8gMikgTm9ib2R5IHNob3VsZCByZWx5IG9uIGBpbnN0YW5jZW9mIEZpYmVyYCBmb3IgdHlwZSB0ZXN0aW5nLiBXZSBzaG91bGRcbi8vICAgIGFsd2F5cyBrbm93IHdoZW4gaXQgaXMgYSBmaWJlci5cbi8vIDMpIFdlIG1pZ2h0IHdhbnQgdG8gZXhwZXJpbWVudCB3aXRoIHVzaW5nIG51bWVyaWMga2V5cyBzaW5jZSB0aGV5IGFyZSBlYXNpZXJcbi8vICAgIHRvIG9wdGltaXplIGluIGEgbm9uLUpJVCBlbnZpcm9ubWVudC5cbi8vIDQpIFdlIGNhbiBlYXNpbHkgZ28gZnJvbSBhIGNvbnN0cnVjdG9yIHRvIGEgY3JlYXRlRmliZXIgb2JqZWN0IGxpdGVyYWwgaWYgdGhhdFxuLy8gICAgaXMgZmFzdGVyLlxuLy8gNSkgSXQgc2hvdWxkIGJlIGVhc3kgdG8gcG9ydCB0aGlzIHRvIGEgQyBzdHJ1Y3QgYW5kIGtlZXAgYSBDIGltcGxlbWVudGF0aW9uXG4vLyAgICBjb21wYXRpYmxlLlxudmFyIGNyZWF0ZUZpYmVyID0gZnVuY3Rpb24gKHRhZywga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpIHtcbiAgLy8gJEZsb3dGaXhNZTogdGhlIHNoYXBlcyBhcmUgZXhhY3QgaGVyZSBidXQgRmxvdyBkb2Vzbid0IGxpa2UgY29uc3RydWN0b3JzXG4gIHJldHVybiBuZXcgRmliZXJOb2RlKHRhZywga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xufTtcblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICByZXR1cm4gISEoQ29tcG9uZW50LnByb3RvdHlwZSAmJiBDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG4vLyBUaGlzIGlzIHVzZWQgdG8gY3JlYXRlIGFuIGFsdGVybmF0ZSBmaWJlciB0byBkbyB3b3JrIG9uLlxuZnVuY3Rpb24gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudCwgcGVuZGluZ1Byb3BzLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgd29ya0luUHJvZ3Jlc3MgPSBjdXJyZW50LmFsdGVybmF0ZTtcbiAgaWYgKHdvcmtJblByb2dyZXNzID09PSBudWxsKSB7XG4gICAgLy8gV2UgdXNlIGEgZG91YmxlIGJ1ZmZlcmluZyBwb29saW5nIHRlY2huaXF1ZSBiZWNhdXNlIHdlIGtub3cgdGhhdCB3ZSdsbFxuICAgIC8vIG9ubHkgZXZlciBuZWVkIGF0IG1vc3QgdHdvIHZlcnNpb25zIG9mIGEgdHJlZS4gV2UgcG9vbCB0aGUgXCJvdGhlclwiIHVudXNlZFxuICAgIC8vIG5vZGUgdGhhdCB3ZSdyZSBmcmVlIHRvIHJldXNlLiBUaGlzIGlzIGxhemlseSBjcmVhdGVkIHRvIGF2b2lkIGFsbG9jYXRpbmdcbiAgICAvLyBleHRyYSBvYmplY3RzIGZvciB0aGluZ3MgdGhhdCBhcmUgbmV2ZXIgdXBkYXRlZC4gSXQgYWxzbyBhbGxvdyB1cyB0b1xuICAgIC8vIHJlY2xhaW0gdGhlIGV4dHJhIG1lbW9yeSBpZiBuZWVkZWQuXG4gICAgd29ya0luUHJvZ3Jlc3MgPSBjcmVhdGVGaWJlcihjdXJyZW50LnRhZywgY3VycmVudC5rZXksIGN1cnJlbnQuaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlO1xuICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuXG4gICAge1xuICAgICAgLy8gREVWLW9ubHkgZmllbGRzXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdJRCA9IGN1cnJlbnQuX2RlYnVnSUQ7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdTb3VyY2UgPSBjdXJyZW50Ll9kZWJ1Z1NvdXJjZTtcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z093bmVyID0gY3VycmVudC5fZGVidWdPd25lcjtcbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBjdXJyZW50O1xuICAgIGN1cnJlbnQuYWx0ZXJuYXRlID0gd29ya0luUHJvZ3Jlc3M7XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgYWxyZWFkeSBoYXZlIGFuIGFsdGVybmF0ZS5cbiAgICAvLyBSZXNldCB0aGUgZWZmZWN0IHRhZy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgPSBOb0VmZmVjdDtcblxuICAgIC8vIFRoZSBlZmZlY3QgbGlzdCBpcyBubyBsb25nZXIgdmFsaWQuXG4gICAgd29ya0luUHJvZ3Jlc3MubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgPSBudWxsO1xuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzID0gcGVuZGluZ1Byb3BzO1xuXG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuXG4gIC8vIFRoZXNlIHdpbGwgYmUgb3ZlcnJpZGRlbiBkdXJpbmcgdGhlIHBhcmVudCdzIHJlY29uY2lsaWF0aW9uXG4gIHdvcmtJblByb2dyZXNzLnNpYmxpbmcgPSBjdXJyZW50LnNpYmxpbmc7XG4gIHdvcmtJblByb2dyZXNzLmluZGV4ID0gY3VycmVudC5pbmRleDtcbiAgd29ya0luUHJvZ3Jlc3MucmVmID0gY3VycmVudC5yZWY7XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVIb3N0Um9vdEZpYmVyKCkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0Um9vdCwgbnVsbCwgTm9Db250ZXh0KTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIGludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIG93bmVyID0gbnVsbDtcbiAge1xuICAgIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gIH1cblxuICB2YXIgZmliZXIgPSB2b2lkIDA7XG4gIHZhciB0eXBlID0gZWxlbWVudC50eXBlLFxuICAgICAga2V5ID0gZWxlbWVudC5rZXk7XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZmliZXIgPSBzaG91bGRDb25zdHJ1Y3QodHlwZSkgPyBjcmVhdGVGaWJlcihDbGFzc0NvbXBvbmVudCwga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpIDogY3JlYXRlRmliZXIoSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCwga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICAgIGZpYmVyLnR5cGUgPSB0eXBlO1xuICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGVsZW1lbnQucHJvcHM7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0Q29tcG9uZW50LCBrZXksIGludGVybmFsQ29udGV4dFRhZyk7XG4gICAgZmliZXIudHlwZSA9IHR5cGU7XG4gICAgZmliZXIucGVuZGluZ1Byb3BzID0gZWxlbWVudC5wcm9wcztcbiAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiB0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgLy8gQ3VycmVudGx5IGFzc3VtZWQgdG8gYmUgYSBjb250aW51YXRpb24gYW5kIHRoZXJlZm9yZSBpcyBhIGZpYmVyIGFscmVhZHkuXG4gICAgLy8gVE9ETzogVGhlIHlpZWxkIHN5c3RlbSBpcyBjdXJyZW50bHkgYnJva2VuIGZvciB1cGRhdGVzIGluIHNvbWUgY2FzZXMuXG4gICAgLy8gVGhlIHJlaWZpZWQgeWllbGQgc3RvcmVzIGEgZmliZXIsIGJ1dCB3ZSBkb24ndCBrbm93IHdoaWNoIGZpYmVyIHRoYXQgaXM7XG4gICAgLy8gdGhlIGN1cnJlbnQgb3IgYSB3b3JrSW5Qcm9ncmVzcz8gV2hlbiB0aGUgY29udGludWF0aW9uIGdldHMgcmVuZGVyZWQgaGVyZVxuICAgIC8vIHdlIGRvbid0IGtub3cgaWYgd2UgY2FuIHJldXNlIHRoYXQgZmliZXIgb3IgaWYgd2UgbmVlZCB0byBjbG9uZSBpdC5cbiAgICAvLyBUaGVyZSBpcyBwcm9iYWJseSBhIGNsZXZlciB3YXkgdG8gcmVzdHJ1Y3R1cmUgdGhpcy5cbiAgICBmaWJlciA9IHR5cGU7XG4gICAgZmliZXIucGVuZGluZ1Byb3BzID0gZWxlbWVudC5wcm9wcztcbiAgfSBlbHNlIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIHtcbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG4gICAgICB2YXIgb3duZXJOYW1lID0gb3duZXIgPyBnZXRDb21wb25lbnROYW1lKG93bmVyKSA6IG51bGw7XG4gICAgICBpZiAob3duZXJOYW1lKSB7XG4gICAgICAgIGluZm8gKz0gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgb3duZXJOYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG4gICAgaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGUgPT0gbnVsbCA/IHR5cGUgOiB0eXBlb2YgdHlwZSwgaW5mbyk7XG4gIH1cblxuICB7XG4gICAgZmliZXIuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgIGZpYmVyLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gIH1cblxuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuXG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudHMsIGludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUsIGtleSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihGcmFnbWVudCwga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICBmaWJlci5wZW5kaW5nUHJvcHMgPSBlbGVtZW50cztcbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21UZXh0KGNvbnRlbnQsIGludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdFRleHQsIG51bGwsIGludGVybmFsQ29udGV4dFRhZyk7XG4gIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGNvbnRlbnQ7XG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tSG9zdEluc3RhbmNlRm9yRGVsZXRpb24oKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RDb21wb25lbnQsIG51bGwsIE5vQ29udGV4dCk7XG4gIGZpYmVyLnR5cGUgPSAnREVMRVRFRCc7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tQ2FsbChjYWxsLCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKENhbGxDb21wb25lbnQsIGNhbGwua2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICBmaWJlci50eXBlID0gY2FsbC5oYW5kbGVyO1xuICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjYWxsO1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVJldHVybihyZXR1cm5Ob2RlLCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKFJldHVybkNvbXBvbmVudCwgbnVsbCwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RQb3J0YWwsIHBvcnRhbC5rZXksIGludGVybmFsQ29udGV4dFRhZyk7XG4gIGZpYmVyLnBlbmRpbmdQcm9wcyA9IHBvcnRhbC5jaGlsZHJlbiB8fCBbXTtcbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgZmliZXIuc3RhdGVOb2RlID0ge1xuICAgIGNvbnRhaW5lckluZm86IHBvcnRhbC5jb250YWluZXJJbmZvLFxuICAgIHBlbmRpbmdDaGlsZHJlbjogbnVsbCwgLy8gVXNlZCBieSBwZXJzaXN0ZW50IHVwZGF0ZXNcbiAgICBpbXBsZW1lbnRhdGlvbjogcG9ydGFsLmltcGxlbWVudGF0aW9uXG4gIH07XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIGh5ZHJhdGUpIHtcbiAgLy8gQ3ljbGljIGNvbnN0cnVjdGlvbi4gVGhpcyBjaGVhdHMgdGhlIHR5cGUgc3lzdGVtIHJpZ2h0IG5vdyBiZWNhdXNlXG4gIC8vIHN0YXRlTm9kZSBpcyBhbnkuXG4gIHZhciB1bmluaXRpYWxpemVkRmliZXIgPSBjcmVhdGVIb3N0Um9vdEZpYmVyKCk7XG4gIHZhciByb290ID0ge1xuICAgIGN1cnJlbnQ6IHVuaW5pdGlhbGl6ZWRGaWJlcixcbiAgICBjb250YWluZXJJbmZvOiBjb250YWluZXJJbmZvLFxuICAgIHBlbmRpbmdDaGlsZHJlbjogbnVsbCxcbiAgICByZW1haW5pbmdFeHBpcmF0aW9uVGltZTogTm9Xb3JrLFxuICAgIGlzUmVhZHlGb3JDb21taXQ6IGZhbHNlLFxuICAgIGZpbmlzaGVkV29yazogbnVsbCxcbiAgICBjb250ZXh0OiBudWxsLFxuICAgIHBlbmRpbmdDb250ZXh0OiBudWxsLFxuICAgIGh5ZHJhdGU6IGh5ZHJhdGUsXG4gICAgbmV4dFNjaGVkdWxlZFJvb3Q6IG51bGxcbiAgfTtcbiAgdW5pbml0aWFsaXplZEZpYmVyLnN0YXRlTm9kZSA9IHJvb3Q7XG4gIHJldHVybiByb290O1xufVxuXG52YXIgb25Db21taXRGaWJlclJvb3QgPSBudWxsO1xudmFyIG9uQ29tbWl0RmliZXJVbm1vdW50ID0gbnVsbDtcbnZhciBoYXNMb2dnZWRFcnJvciA9IGZhbHNlO1xuXG5mdW5jdGlvbiBjYXRjaEVycm9ycyhmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4oYXJnKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICh0cnVlICYmICFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICBoYXNMb2dnZWRFcnJvciA9IHRydWU7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCBEZXZUb29scyBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMnLCBlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5qZWN0SW50ZXJuYWxzKGludGVybmFscykge1xuICBpZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBObyBEZXZUb29sc1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaG9vayA9IF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcbiAgaWYgKGhvb2suaXNEaXNhYmxlZCkge1xuICAgIC8vIFRoaXMgaXNuJ3QgYSByZWFsIHByb3BlcnR5IG9uIHRoZSBob29rLCBidXQgaXQgY2FuIGJlIHNldCB0byBvcHQgb3V0XG4gICAgLy8gb2YgRGV2VG9vbHMgaW50ZWdyYXRpb24gYW5kIGFzc29jaWF0ZWQgd2FybmluZ3MgYW5kIGxvZ3MuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zODc3XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCFob29rLnN1cHBvcnRzRmliZXIpIHtcbiAgICB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVGhlIGluc3RhbGxlZCB2ZXJzaW9uIG9mIFJlYWN0IERldlRvb2xzIGlzIHRvbyBvbGQgYW5kIHdpbGwgbm90IHdvcmsgJyArICd3aXRoIHRoZSBjdXJyZW50IHZlcnNpb24gb2YgUmVhY3QuIFBsZWFzZSB1cGRhdGUgUmVhY3QgRGV2VG9vbHMuICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1kZXZ0b29scycpO1xuICAgIH1cbiAgICAvLyBEZXZUb29scyBleGlzdHMsIGV2ZW4gdGhvdWdoIGl0IGRvZXNuJ3Qgc3VwcG9ydCBGaWJlci5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB0cnkge1xuICAgIHZhciByZW5kZXJlcklEID0gaG9vay5pbmplY3QoaW50ZXJuYWxzKTtcbiAgICAvLyBXZSBoYXZlIHN1Y2Nlc3NmdWxseSBpbmplY3RlZCwgc28gbm93IGl0IGlzIHNhZmUgdG8gc2V0IHVwIGhvb2tzLlxuICAgIG9uQ29tbWl0RmliZXJSb290ID0gY2F0Y2hFcnJvcnMoZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgIHJldHVybiBob29rLm9uQ29tbWl0RmliZXJSb290KHJlbmRlcmVySUQsIHJvb3QpO1xuICAgIH0pO1xuICAgIG9uQ29tbWl0RmliZXJVbm1vdW50ID0gY2F0Y2hFcnJvcnMoZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICByZXR1cm4gaG9vay5vbkNvbW1pdEZpYmVyVW5tb3VudChyZW5kZXJlcklELCBmaWJlcik7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIENhdGNoIGFsbCBlcnJvcnMgYmVjYXVzZSBpdCBpcyB1bnNhZmUgdG8gdGhyb3cgZHVyaW5nIGluaXRpYWxpemF0aW9uLlxuICAgIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCBEZXZUb29scyBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMuJywgZXJyKTtcbiAgICB9XG4gIH1cbiAgLy8gRGV2VG9vbHMgZXhpc3RzXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBvbkNvbW1pdFJvb3Qocm9vdCkge1xuICBpZiAodHlwZW9mIG9uQ29tbWl0RmliZXJSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb25Db21taXRGaWJlclJvb3Qocm9vdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25Db21taXRVbm1vdW50KGZpYmVyKSB7XG4gIGlmICh0eXBlb2Ygb25Db21taXRGaWJlclVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvbkNvbW1pdEZpYmVyVW5tb3VudChmaWJlcik7XG4gIH1cbn1cblxue1xuICB2YXIgZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSA9IGZhbHNlO1xufVxuXG4vLyBDYWxsYmFja3MgYXJlIG5vdCB2YWxpZGF0ZWQgdW50aWwgaW52b2NhdGlvblxuXG5cbi8vIFNpbmdseSBsaW5rZWQtbGlzdCBvZiB1cGRhdGVzLiBXaGVuIGFuIHVwZGF0ZSBpcyBzY2hlZHVsZWQsIGl0IGlzIGFkZGVkIHRvXG4vLyB0aGUgcXVldWUgb2YgdGhlIGN1cnJlbnQgZmliZXIgYW5kIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLiBUaGUgdHdvIHF1ZXVlc1xuLy8gYXJlIHNlcGFyYXRlIGJ1dCB0aGV5IHNoYXJlIGEgcGVyc2lzdGVudCBzdHJ1Y3R1cmUuXG4vL1xuLy8gRHVyaW5nIHJlY29uY2lsaWF0aW9uLCB1cGRhdGVzIGFyZSByZW1vdmVkIGZyb20gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIsXG4vLyBidXQgdGhleSByZW1haW4gb24gdGhlIGN1cnJlbnQgZmliZXIuIFRoYXQgZW5zdXJlcyB0aGF0IGlmIGEgd29yay1pbi1wcm9ncmVzc1xuLy8gaXMgYWJvcnRlZCwgdGhlIGFib3J0ZWQgdXBkYXRlcyBhcmUgcmVjb3ZlcmVkIGJ5IGNsb25pbmcgZnJvbSBjdXJyZW50LlxuLy9cbi8vIFRoZSB3b3JrLWluLXByb2dyZXNzIHF1ZXVlIGlzIGFsd2F5cyBhIHN1YnNldCBvZiB0aGUgY3VycmVudCBxdWV1ZS5cbi8vXG4vLyBXaGVuIHRoZSB0cmVlIGlzIGNvbW1pdHRlZCwgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgYmVjb21lcyB0aGUgY3VycmVudC5cblxuXG5mdW5jdGlvbiBjcmVhdGVVcGRhdGVRdWV1ZShiYXNlU3RhdGUpIHtcbiAgdmFyIHF1ZXVlID0ge1xuICAgIGJhc2VTdGF0ZTogYmFzZVN0YXRlLFxuICAgIGV4cGlyYXRpb25UaW1lOiBOb1dvcmssXG4gICAgZmlyc3Q6IG51bGwsXG4gICAgbGFzdDogbnVsbCxcbiAgICBjYWxsYmFja0xpc3Q6IG51bGwsXG4gICAgaGFzRm9yY2VVcGRhdGU6IGZhbHNlLFxuICAgIGlzSW5pdGlhbGl6ZWQ6IGZhbHNlXG4gIH07XG4gIHtcbiAgICBxdWV1ZS5pc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gcXVldWU7XG59XG5cbmZ1bmN0aW9uIGluc2VydFVwZGF0ZUludG9RdWV1ZShxdWV1ZSwgdXBkYXRlKSB7XG4gIC8vIEFwcGVuZCB0aGUgdXBkYXRlIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4gIGlmIChxdWV1ZS5sYXN0ID09PSBudWxsKSB7XG4gICAgLy8gUXVldWUgaXMgZW1wdHlcbiAgICBxdWV1ZS5maXJzdCA9IHF1ZXVlLmxhc3QgPSB1cGRhdGU7XG4gIH0gZWxzZSB7XG4gICAgcXVldWUubGFzdC5uZXh0ID0gdXBkYXRlO1xuICAgIHF1ZXVlLmxhc3QgPSB1cGRhdGU7XG4gIH1cbiAgaWYgKHF1ZXVlLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgcXVldWUuZXhwaXJhdGlvblRpbWUgPiB1cGRhdGUuZXhwaXJhdGlvblRpbWUpIHtcbiAgICBxdWV1ZS5leHBpcmF0aW9uVGltZSA9IHVwZGF0ZS5leHBpcmF0aW9uVGltZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnNlcnRVcGRhdGVJbnRvRmliZXIoZmliZXIsIHVwZGF0ZSkge1xuICAvLyBXZSdsbCBoYXZlIGF0IGxlYXN0IG9uZSBhbmQgYXQgbW9zdCB0d28gZGlzdGluY3QgdXBkYXRlIHF1ZXVlcy5cbiAgdmFyIGFsdGVybmF0ZUZpYmVyID0gZmliZXIuYWx0ZXJuYXRlO1xuICB2YXIgcXVldWUxID0gZmliZXIudXBkYXRlUXVldWU7XG4gIGlmIChxdWV1ZTEgPT09IG51bGwpIHtcbiAgICAvLyBUT0RPOiBXZSBkb24ndCBrbm93IHdoYXQgdGhlIGJhc2Ugc3RhdGUgd2lsbCBiZSB1bnRpbCB3ZSBiZWdpbiB3b3JrLlxuICAgIC8vIEl0IGRlcGVuZHMgb24gd2hpY2ggZmliZXIgaXMgdGhlIG5leHQgY3VycmVudC4gSW5pdGlhbGl6ZSB3aXRoIGFuIGVtcHR5XG4gICAgLy8gYmFzZSBzdGF0ZSwgdGhlbiBzZXQgdG8gdGhlIG1lbW9pemVkU3RhdGUgd2hlbiByZW5kZXJpbmcuIE5vdCBzdXBlclxuICAgIC8vIGhhcHB5IHdpdGggdGhpcyBhcHByb2FjaC5cbiAgICBxdWV1ZTEgPSBmaWJlci51cGRhdGVRdWV1ZSA9IGNyZWF0ZVVwZGF0ZVF1ZXVlKG51bGwpO1xuICB9XG5cbiAgdmFyIHF1ZXVlMiA9IHZvaWQgMDtcbiAgaWYgKGFsdGVybmF0ZUZpYmVyICE9PSBudWxsKSB7XG4gICAgcXVldWUyID0gYWx0ZXJuYXRlRmliZXIudXBkYXRlUXVldWU7XG4gICAgaWYgKHF1ZXVlMiA9PT0gbnVsbCkge1xuICAgICAgcXVldWUyID0gYWx0ZXJuYXRlRmliZXIudXBkYXRlUXVldWUgPSBjcmVhdGVVcGRhdGVRdWV1ZShudWxsKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcXVldWUyID0gbnVsbDtcbiAgfVxuICBxdWV1ZTIgPSBxdWV1ZTIgIT09IHF1ZXVlMSA/IHF1ZXVlMiA6IG51bGw7XG5cbiAgLy8gV2FybiBpZiBhbiB1cGRhdGUgaXMgc2NoZWR1bGVkIGZyb20gaW5zaWRlIGFuIHVwZGF0ZXIgZnVuY3Rpb24uXG4gIHtcbiAgICBpZiAoKHF1ZXVlMS5pc1Byb2Nlc3NpbmcgfHwgcXVldWUyICE9PSBudWxsICYmIHF1ZXVlMi5pc1Byb2Nlc3NpbmcpICYmICFkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnQW4gdXBkYXRlIChzZXRTdGF0ZSwgcmVwbGFjZVN0YXRlLCBvciBmb3JjZVVwZGF0ZSkgd2FzIHNjaGVkdWxlZCAnICsgJ2Zyb20gaW5zaWRlIGFuIHVwZGF0ZSBmdW5jdGlvbi4gVXBkYXRlIGZ1bmN0aW9ucyBzaG91bGQgYmUgcHVyZSwgJyArICd3aXRoIHplcm8gc2lkZS1lZmZlY3RzLiBDb25zaWRlciB1c2luZyBjb21wb25lbnREaWRVcGRhdGUgb3IgYSAnICsgJ2NhbGxiYWNrLicpO1xuICAgICAgZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgdGhlcmUncyBvbmx5IG9uZSBxdWV1ZSwgYWRkIHRoZSB1cGRhdGUgdG8gdGhhdCBxdWV1ZSBhbmQgZXhpdC5cbiAgaWYgKHF1ZXVlMiA9PT0gbnVsbCkge1xuICAgIGluc2VydFVwZGF0ZUludG9RdWV1ZShxdWV1ZTEsIHVwZGF0ZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgZWl0aGVyIHF1ZXVlIGlzIGVtcHR5LCB3ZSBuZWVkIHRvIGFkZCB0byBib3RoIHF1ZXVlcy5cbiAgaWYgKHF1ZXVlMS5sYXN0ID09PSBudWxsIHx8IHF1ZXVlMi5sYXN0ID09PSBudWxsKSB7XG4gICAgaW5zZXJ0VXBkYXRlSW50b1F1ZXVlKHF1ZXVlMSwgdXBkYXRlKTtcbiAgICBpbnNlcnRVcGRhdGVJbnRvUXVldWUocXVldWUyLCB1cGRhdGUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIElmIGJvdGggbGlzdHMgYXJlIG5vdCBlbXB0eSwgdGhlIGxhc3QgdXBkYXRlIGlzIHRoZSBzYW1lIGZvciBib3RoIGxpc3RzXG4gIC8vIGJlY2F1c2Ugb2Ygc3RydWN0dXJhbCBzaGFyaW5nLiBTbywgd2Ugc2hvdWxkIG9ubHkgYXBwZW5kIHRvIG9uZSBvZlxuICAvLyB0aGUgbGlzdHMuXG4gIGluc2VydFVwZGF0ZUludG9RdWV1ZShxdWV1ZTEsIHVwZGF0ZSk7XG4gIC8vIEJ1dCB3ZSBzdGlsbCBuZWVkIHRvIHVwZGF0ZSB0aGUgYGxhc3RgIHBvaW50ZXIgb2YgcXVldWUyLlxuICBxdWV1ZTIubGFzdCA9IHVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gZ2V0VXBkYXRlRXhwaXJhdGlvblRpbWUoZmliZXIpIHtcbiAgaWYgKGZpYmVyLnRhZyAhPT0gQ2xhc3NDb21wb25lbnQgJiYgZmliZXIudGFnICE9PSBIb3N0Um9vdCkge1xuICAgIHJldHVybiBOb1dvcms7XG4gIH1cbiAgdmFyIHVwZGF0ZVF1ZXVlID0gZmliZXIudXBkYXRlUXVldWU7XG4gIGlmICh1cGRhdGVRdWV1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBOb1dvcms7XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZVF1ZXVlLmV4cGlyYXRpb25UaW1lO1xufVxuXG5mdW5jdGlvbiBnZXRTdGF0ZUZyb21VcGRhdGUodXBkYXRlLCBpbnN0YW5jZSwgcHJldlN0YXRlLCBwcm9wcykge1xuICB2YXIgcGFydGlhbFN0YXRlID0gdXBkYXRlLnBhcnRpYWxTdGF0ZTtcbiAgaWYgKHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgdXBkYXRlRm4gPSBwYXJ0aWFsU3RhdGU7XG5cbiAgICAvLyBJbnZva2Ugc2V0U3RhdGUgY2FsbGJhY2sgYW4gZXh0cmEgdGltZSB0byBoZWxwIGRldGVjdCBzaWRlLWVmZmVjdHMuXG4gICAgaWYgKGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cykge1xuICAgICAgdXBkYXRlRm4uY2FsbChpbnN0YW5jZSwgcHJldlN0YXRlLCBwcm9wcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZUZuLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgcHJvcHMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXJ0aWFsU3RhdGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1VwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBxdWV1ZSwgaW5zdGFuY2UsIHByb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnVwZGF0ZVF1ZXVlID09PSBxdWV1ZSkge1xuICAgIC8vIFdlIG5lZWQgdG8gY3JlYXRlIGEgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSwgYnkgY2xvbmluZyB0aGUgY3VycmVudCBxdWV1ZS5cbiAgICB2YXIgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgcXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IHtcbiAgICAgIGJhc2VTdGF0ZTogY3VycmVudFF1ZXVlLmJhc2VTdGF0ZSxcbiAgICAgIGV4cGlyYXRpb25UaW1lOiBjdXJyZW50UXVldWUuZXhwaXJhdGlvblRpbWUsXG4gICAgICBmaXJzdDogY3VycmVudFF1ZXVlLmZpcnN0LFxuICAgICAgbGFzdDogY3VycmVudFF1ZXVlLmxhc3QsXG4gICAgICBpc0luaXRpYWxpemVkOiBjdXJyZW50UXVldWUuaXNJbml0aWFsaXplZCxcbiAgICAgIC8vIFRoZXNlIGZpZWxkcyBhcmUgbm8gbG9uZ2VyIHZhbGlkIGJlY2F1c2UgdGhleSB3ZXJlIGFscmVhZHkgY29tbWl0dGVkLlxuICAgICAgLy8gUmVzZXQgdGhlbS5cbiAgICAgIGNhbGxiYWNrTGlzdDogbnVsbCxcbiAgICAgIGhhc0ZvcmNlVXBkYXRlOiBmYWxzZVxuICAgIH07XG4gIH1cblxuICB7XG4gICAgLy8gU2V0IHRoaXMgZmxhZyBzbyB3ZSBjYW4gd2FybiBpZiBzZXRTdGF0ZSBpcyBjYWxsZWQgaW5zaWRlIHRoZSB1cGRhdGVcbiAgICAvLyBmdW5jdGlvbiBvZiBhbm90aGVyIHNldFN0YXRlLlxuICAgIHF1ZXVlLmlzUHJvY2Vzc2luZyA9IHRydWU7XG4gIH1cblxuICAvLyBSZXNldCB0aGUgcmVtYWluaW5nIGV4cGlyYXRpb24gdGltZS4gSWYgd2Ugc2tpcCBvdmVyIGFueSB1cGRhdGVzLCB3ZSdsbFxuICAvLyBpbmNyZWFzZSB0aGlzIGFjY29yZGluZ2x5LlxuICBxdWV1ZS5leHBpcmF0aW9uVGltZSA9IE5vV29yaztcblxuICAvLyBUT0RPOiBXZSBkb24ndCBrbm93IHdoYXQgdGhlIGJhc2Ugc3RhdGUgd2lsbCBiZSB1bnRpbCB3ZSBiZWdpbiB3b3JrLlxuICAvLyBJdCBkZXBlbmRzIG9uIHdoaWNoIGZpYmVyIGlzIHRoZSBuZXh0IGN1cnJlbnQuIEluaXRpYWxpemUgd2l0aCBhbiBlbXB0eVxuICAvLyBiYXNlIHN0YXRlLCB0aGVuIHNldCB0byB0aGUgbWVtb2l6ZWRTdGF0ZSB3aGVuIHJlbmRlcmluZy4gTm90IHN1cGVyXG4gIC8vIGhhcHB5IHdpdGggdGhpcyBhcHByb2FjaC5cbiAgdmFyIHN0YXRlID0gdm9pZCAwO1xuICBpZiAocXVldWUuaXNJbml0aWFsaXplZCkge1xuICAgIHN0YXRlID0gcXVldWUuYmFzZVN0YXRlO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlID0gcXVldWUuYmFzZVN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICBxdWV1ZS5pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgfVxuICB2YXIgZG9udE11dGF0ZVByZXZTdGF0ZSA9IHRydWU7XG4gIHZhciB1cGRhdGUgPSBxdWV1ZS5maXJzdDtcbiAgdmFyIGRpZFNraXAgPSBmYWxzZTtcbiAgd2hpbGUgKHVwZGF0ZSAhPT0gbnVsbCkge1xuICAgIHZhciB1cGRhdGVFeHBpcmF0aW9uVGltZSA9IHVwZGF0ZS5leHBpcmF0aW9uVGltZTtcbiAgICBpZiAodXBkYXRlRXhwaXJhdGlvblRpbWUgPiByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgICAgLy8gVGhpcyB1cGRhdGUgZG9lcyBub3QgaGF2ZSBzdWZmaWNpZW50IHByaW9yaXR5LiBTa2lwIGl0LlxuICAgICAgdmFyIHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gcXVldWUuZXhwaXJhdGlvblRpbWU7XG4gICAgICBpZiAocmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA+IHVwZGF0ZUV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVtYWluaW5nIGV4cGlyYXRpb24gdGltZS5cbiAgICAgICAgcXVldWUuZXhwaXJhdGlvblRpbWUgPSB1cGRhdGVFeHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICAgIGlmICghZGlkU2tpcCkge1xuICAgICAgICBkaWRTa2lwID0gdHJ1ZTtcbiAgICAgICAgcXVldWUuYmFzZVN0YXRlID0gc3RhdGU7XG4gICAgICB9XG4gICAgICAvLyBDb250aW51ZSB0byB0aGUgbmV4dCB1cGRhdGUuXG4gICAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIFRoaXMgdXBkYXRlIGRvZXMgaGF2ZSBzdWZmaWNpZW50IHByaW9yaXR5LlxuXG4gICAgLy8gSWYgbm8gcHJldmlvdXMgdXBkYXRlcyB3ZXJlIHNraXBwZWQsIGRyb3AgdGhpcyB1cGRhdGUgZnJvbSB0aGUgcXVldWUgYnlcbiAgICAvLyBhZHZhbmNpbmcgdGhlIGhlYWQgb2YgdGhlIGxpc3QuXG4gICAgaWYgKCFkaWRTa2lwKSB7XG4gICAgICBxdWV1ZS5maXJzdCA9IHVwZGF0ZS5uZXh0O1xuICAgICAgaWYgKHF1ZXVlLmZpcnN0ID09PSBudWxsKSB7XG4gICAgICAgIHF1ZXVlLmxhc3QgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFByb2Nlc3MgdGhlIHVwZGF0ZVxuICAgIHZhciBfcGFydGlhbFN0YXRlID0gdm9pZCAwO1xuICAgIGlmICh1cGRhdGUuaXNSZXBsYWNlKSB7XG4gICAgICBzdGF0ZSA9IGdldFN0YXRlRnJvbVVwZGF0ZSh1cGRhdGUsIGluc3RhbmNlLCBzdGF0ZSwgcHJvcHMpO1xuICAgICAgZG9udE11dGF0ZVByZXZTdGF0ZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9wYXJ0aWFsU3RhdGUgPSBnZXRTdGF0ZUZyb21VcGRhdGUodXBkYXRlLCBpbnN0YW5jZSwgc3RhdGUsIHByb3BzKTtcbiAgICAgIGlmIChfcGFydGlhbFN0YXRlKSB7XG4gICAgICAgIGlmIChkb250TXV0YXRlUHJldlN0YXRlKSB7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZTogSWRrIGhvdyB0byB0eXBlIHRoaXMgcHJvcGVybHkuXG4gICAgICAgICAgc3RhdGUgPSBfYXNzaWduKHt9LCBzdGF0ZSwgX3BhcnRpYWxTdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUgPSBfYXNzaWduKHN0YXRlLCBfcGFydGlhbFN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBkb250TXV0YXRlUHJldlN0YXRlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh1cGRhdGUuaXNGb3JjZWQpIHtcbiAgICAgIHF1ZXVlLmhhc0ZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHVwZGF0ZS5jYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgLy8gQXBwZW5kIHRvIGxpc3Qgb2YgY2FsbGJhY2tzLlxuICAgICAgdmFyIF9jYWxsYmFja0xpc3QgPSBxdWV1ZS5jYWxsYmFja0xpc3Q7XG4gICAgICBpZiAoX2NhbGxiYWNrTGlzdCA9PT0gbnVsbCkge1xuICAgICAgICBfY2FsbGJhY2tMaXN0ID0gcXVldWUuY2FsbGJhY2tMaXN0ID0gW107XG4gICAgICB9XG4gICAgICBfY2FsbGJhY2tMaXN0LnB1c2godXBkYXRlKTtcbiAgICB9XG4gICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gIH1cblxuICBpZiAocXVldWUuY2FsbGJhY2tMaXN0ICE9PSBudWxsKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IENhbGxiYWNrO1xuICB9IGVsc2UgaWYgKHF1ZXVlLmZpcnN0ID09PSBudWxsICYmICFxdWV1ZS5oYXNGb3JjZVVwZGF0ZSkge1xuICAgIC8vIFRoZSBxdWV1ZSBpcyBlbXB0eS4gV2UgY2FuIHJlc2V0IGl0LlxuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgfVxuXG4gIGlmICghZGlkU2tpcCkge1xuICAgIGRpZFNraXAgPSB0cnVlO1xuICAgIHF1ZXVlLmJhc2VTdGF0ZSA9IHN0YXRlO1xuICB9XG5cbiAge1xuICAgIC8vIE5vIGxvbmdlciBwcm9jZXNzaW5nLlxuICAgIHF1ZXVlLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG5mdW5jdGlvbiBjb21taXRDYWxsYmFja3MocXVldWUsIGNvbnRleHQpIHtcbiAgdmFyIGNhbGxiYWNrTGlzdCA9IHF1ZXVlLmNhbGxiYWNrTGlzdDtcbiAgaWYgKGNhbGxiYWNrTGlzdCA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBTZXQgdGhlIGxpc3QgdG8gbnVsbCB0byBtYWtlIHN1cmUgdGhleSBkb24ndCBnZXQgY2FsbGVkIG1vcmUgdGhhbiBvbmNlLlxuICBxdWV1ZS5jYWxsYmFja0xpc3QgPSBudWxsO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciB1cGRhdGUgPSBjYWxsYmFja0xpc3RbaV07XG4gICAgdmFyIF9jYWxsYmFjayA9IHVwZGF0ZS5jYWxsYmFjaztcbiAgICAvLyBUaGlzIHVwZGF0ZSBtaWdodCBiZSBwcm9jZXNzZWQgYWdhaW4uIENsZWFyIHRoZSBjYWxsYmFjayBzbyBpdCdzIG9ubHlcbiAgICAvLyBjYWxsZWQgb25jZS5cbiAgICB1cGRhdGUuY2FsbGJhY2sgPSBudWxsO1xuICAgICEodHlwZW9mIF9jYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCBhcyBjYWxsYmFjay4gRXhwZWN0ZWQgYSBmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMnLCBfY2FsbGJhY2spIDogdm9pZCAwO1xuICAgIF9jYWxsYmFjay5jYWxsKGNvbnRleHQpO1xuICB9XG59XG5cbnZhciBmYWtlSW50ZXJuYWxJbnN0YW5jZSA9IHt9O1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG57XG4gIHZhciBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQgPSB7fTtcblxuICB2YXIgd2Fybk9uSW52YWxpZENhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2FybmluZyhjYWxsYmFjayA9PT0gbnVsbCB8fCB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicsICclcyguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGVyTmFtZSwgY2FsbGJhY2spO1xuICB9O1xuXG4gIC8vIFRoaXMgaXMgc28gZ3Jvc3MgYnV0IGl0J3MgYXQgbGVhc3Qgbm9uLWNyaXRpY2FsIGFuZCBjYW4gYmUgcmVtb3ZlZCBpZlxuICAvLyBpdCBjYXVzZXMgcHJvYmxlbXMuIFRoaXMgaXMgbWVhbnQgdG8gZ2l2ZSBhIG5pY2VyIGVycm9yIG1lc3NhZ2UgZm9yXG4gIC8vIFJlYWN0RE9NMTUudW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocmVhY3RET00xNkNvbXBvbmVudCxcbiAgLy8gLi4uKSkgd2hpY2ggb3RoZXJ3aXNlIHRocm93cyBhIFwiX3Byb2Nlc3NDaGlsZENvbnRleHQgaXMgbm90IGEgZnVuY3Rpb25cIlxuICAvLyBleGNlcHRpb24uXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmYWtlSW50ZXJuYWxJbnN0YW5jZSwgJ19wcm9jZXNzQ2hpbGRDb250ZXh0Jywge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdfcHJvY2Vzc0NoaWxkQ29udGV4dCBpcyBub3QgYXZhaWxhYmxlIGluIFJlYWN0IDE2Ky4gVGhpcyBsaWtlbHkgbWVhbnMgeW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGFuZCBhcmUgYXR0ZW1wdGluZyB0byBuZXN0IGEgUmVhY3QgMTUgdHJlZSBpbnNpZGUgYSBSZWFjdCAxNiB0cmVlIHVzaW5nIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyLCB3aGljaCBpc25cXCd0IHN1cHBvcnRlZC4gVHJ5IHRvIG1ha2Ugc3VyZSB5b3UgaGF2ZSBvbmx5IG9uZSBjb3B5IG9mIFJlYWN0IChhbmQgaWRlYWxseSwgc3dpdGNoIHRvIFJlYWN0RE9NLmNyZWF0ZVBvcnRhbCkuJyk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmZyZWV6ZShmYWtlSW50ZXJuYWxJbnN0YW5jZSk7XG59XG5cbnZhciBSZWFjdEZpYmVyQ2xhc3NDb21wb25lbnQgPSBmdW5jdGlvbiAoc2NoZWR1bGVXb3JrLCBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyLCBtZW1vaXplUHJvcHMsIG1lbW9pemVTdGF0ZSkge1xuICAvLyBDbGFzcyBjb21wb25lbnQgc3RhdGUgdXBkYXRlclxuICB2YXIgdXBkYXRlciA9IHtcbiAgICBpc01vdW50ZWQ6IGlzTW91bnRlZCxcbiAgICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChpbnN0YW5jZSwgcGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGZpYmVyID0gZ2V0KGluc3RhbmNlKTtcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbiAgICAgIH1cbiAgICAgIHZhciBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoZmliZXIpO1xuICAgICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgICAgICBwYXJ0aWFsU3RhdGU6IHBhcnRpYWxTdGF0ZSxcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICBpc1JlcGxhY2U6IGZhbHNlLFxuICAgICAgICBpc0ZvcmNlZDogZmFsc2UsXG4gICAgICAgIG5leHRDYWxsYmFjazogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGluc2VydFVwZGF0ZUludG9GaWJlcihmaWJlciwgdXBkYXRlKTtcbiAgICAgIHNjaGVkdWxlV29yayhmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH0sXG4gICAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKGluc3RhbmNlLCBzdGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBmaWJlciA9IGdldChpbnN0YW5jZSk7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrID09PSB1bmRlZmluZWQgPyBudWxsIDogY2FsbGJhY2s7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3JlcGxhY2VTdGF0ZScpO1xuICAgICAgfVxuICAgICAgdmFyIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihmaWJlcik7XG4gICAgICB2YXIgdXBkYXRlID0ge1xuICAgICAgICBleHBpcmF0aW9uVGltZTogZXhwaXJhdGlvblRpbWUsXG4gICAgICAgIHBhcnRpYWxTdGF0ZTogc3RhdGUsXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgaXNSZXBsYWNlOiB0cnVlLFxuICAgICAgICBpc0ZvcmNlZDogZmFsc2UsXG4gICAgICAgIG5leHRDYWxsYmFjazogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGluc2VydFVwZGF0ZUludG9GaWJlcihmaWJlciwgdXBkYXRlKTtcbiAgICAgIHNjaGVkdWxlV29yayhmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH0sXG4gICAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgZmliZXIgPSBnZXQoaW5zdGFuY2UpO1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuICAgICAge1xuICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xuICAgICAgfVxuICAgICAgdmFyIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihmaWJlcik7XG4gICAgICB2YXIgdXBkYXRlID0ge1xuICAgICAgICBleHBpcmF0aW9uVGltZTogZXhwaXJhdGlvblRpbWUsXG4gICAgICAgIHBhcnRpYWxTdGF0ZTogbnVsbCxcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICBpc1JlcGxhY2U6IGZhbHNlLFxuICAgICAgICBpc0ZvcmNlZDogdHJ1ZSxcbiAgICAgICAgbmV4dENhbGxiYWNrOiBudWxsLFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgICAgaW5zZXJ0VXBkYXRlSW50b0ZpYmVyKGZpYmVyLCB1cGRhdGUpO1xuICAgICAgc2NoZWR1bGVXb3JrKGZpYmVyLCBleHBpcmF0aW9uVGltZSk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLCBvbGRQcm9wcywgbmV3UHJvcHMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCkge1xuICAgIGlmIChvbGRQcm9wcyA9PT0gbnVsbCB8fCB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZS5oYXNGb3JjZVVwZGF0ZSkge1xuICAgICAgLy8gSWYgdGhlIHdvcmtJblByb2dyZXNzIGFscmVhZHkgaGFzIGFuIFVwZGF0ZSBlZmZlY3QsIHJldHVybiB0cnVlXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgIGlmICh0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsICdzaG91bGRDb21wb25lbnRVcGRhdGUnKTtcbiAgICAgIHZhciBzaG91bGRVcGRhdGUgPSBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXdDb250ZXh0KTtcbiAgICAgIHN0b3BQaGFzZVRpbWVyKCk7XG5cbiAgICAgIC8vIFNpbXVsYXRlIGFuIGFzeW5jIGJhaWxvdXQvaW50ZXJydXB0aW9uIGJ5IGludm9raW5nIGxpZmVjeWNsZSB0d2ljZS5cbiAgICAgIGlmIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgd2FybmluZyhzaG91bGRVcGRhdGUgIT09IHVuZGVmaW5lZCwgJyVzLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpOiBSZXR1cm5lZCB1bmRlZmluZWQgaW5zdGVhZCBvZiBhICcgKyAnYm9vbGVhbiB2YWx1ZS4gTWFrZSBzdXJlIHRvIHJldHVybiB0cnVlIG9yIGZhbHNlLicsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpIHx8ICdVbmtub3duJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzaG91bGRVcGRhdGU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUucHJvdG90eXBlICYmIHR5cGUucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50KSB7XG4gICAgICByZXR1cm4gIXNoYWxsb3dFcXVhbChvbGRQcm9wcywgbmV3UHJvcHMpIHx8ICFzaGFsbG93RXF1YWwob2xkU3RhdGUsIG5ld1N0YXRlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrQ2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHZhciByZW5kZXJQcmVzZW50ID0gaW5zdGFuY2UucmVuZGVyO1xuXG4gICAgICBpZiAoIXJlbmRlclByZXNlbnQpIHtcbiAgICAgICAgaWYgKHR5cGUucHJvdG90eXBlICYmIHR5cGVvZiB0eXBlLnByb3RvdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogZGlkIHlvdSBhY2NpZGVudGFsbHkgcmV0dXJuIGFuIG9iamVjdCBmcm9tIHRoZSBjb25zdHJ1Y3Rvcj8nLCBuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogeW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBkZWZpbmUgYHJlbmRlcmAuJywgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG5vR2V0SW5pdGlhbFN0YXRlT25FUzYgPSAhaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlIHx8IGluc3RhbmNlLmdldEluaXRpYWxTdGF0ZS5pc1JlYWN0Q2xhc3NBcHByb3ZlZCB8fCBpbnN0YW5jZS5zdGF0ZTtcbiAgICAgIHdhcm5pbmcobm9HZXRJbml0aWFsU3RhdGVPbkVTNiwgJ2dldEluaXRpYWxTdGF0ZSB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdEaWQgeW91IG1lYW4gdG8gZGVmaW5lIGEgc3RhdGUgcHJvcGVydHkgaW5zdGVhZD8nLCBuYW1lKTtcbiAgICAgIHZhciBub0dldERlZmF1bHRQcm9wc09uRVM2ID0gIWluc3RhbmNlLmdldERlZmF1bHRQcm9wcyB8fCBpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQ7XG4gICAgICB3YXJuaW5nKG5vR2V0RGVmYXVsdFByb3BzT25FUzYsICdnZXREZWZhdWx0UHJvcHMgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnVXNlIGEgc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBkZWZhdWx0UHJvcHMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICAgIHZhciBub0luc3RhbmNlUHJvcFR5cGVzID0gIWluc3RhbmNlLnByb3BUeXBlcztcbiAgICAgIHdhcm5pbmcobm9JbnN0YW5jZVByb3BUeXBlcywgJ3Byb3BUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIHByb3BUeXBlcyBpbnN0ZWFkLicsIG5hbWUpO1xuICAgICAgdmFyIG5vSW5zdGFuY2VDb250ZXh0VHlwZXMgPSAhaW5zdGFuY2UuY29udGV4dFR5cGVzO1xuICAgICAgd2FybmluZyhub0luc3RhbmNlQ29udGV4dFR5cGVzLCAnY29udGV4dFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgY29udGV4dFR5cGVzIGluc3RlYWQuJywgbmFtZSk7XG4gICAgICB2YXIgbm9Db21wb25lbnRTaG91bGRVcGRhdGUgPSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50U2hvdWxkVXBkYXRlICE9PSAnZnVuY3Rpb24nO1xuICAgICAgd2FybmluZyhub0NvbXBvbmVudFNob3VsZFVwZGF0ZSwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICsgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICsgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsIG5hbWUpO1xuICAgICAgaWYgKHR5cGUucHJvdG90eXBlICYmIHR5cGUucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ICYmIHR5cGVvZiBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpLiAnICsgJ3Nob3VsZENvbXBvbmVudFVwZGF0ZSBzaG91bGQgbm90IGJlIHVzZWQgd2hlbiBleHRlbmRpbmcgUmVhY3QuUHVyZUNvbXBvbmVudC4gJyArICdQbGVhc2UgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudCBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgaXMgdXNlZC4nLCBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnQSBwdXJlIGNvbXBvbmVudCcpO1xuICAgICAgfVxuICAgICAgdmFyIG5vQ29tcG9uZW50RGlkVW5tb3VudCA9IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVbm1vdW50ICE9PSAnZnVuY3Rpb24nO1xuICAgICAgd2FybmluZyhub0NvbXBvbmVudERpZFVubW91bnQsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50RGlkVW5tb3VudCgpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0RpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsVW5tb3VudCgpPycsIG5hbWUpO1xuICAgICAgdmFyIG5vQ29tcG9uZW50RGlkUmVjZWl2ZVByb3BzID0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyAhPT0gJ2Z1bmN0aW9uJztcbiAgICAgIHdhcm5pbmcobm9Db21wb25lbnREaWRSZWNlaXZlUHJvcHMsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzKCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnSWYgeW91IG1lYW50IHRvIHVwZGF0ZSB0aGUgc3RhdGUgaW4gcmVzcG9uc2UgdG8gY2hhbmdpbmcgcHJvcHMsICcgKyAndXNlIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKS4gSWYgeW91IG1lYW50IHRvIGZldGNoIGRhdGEgb3IgJyArICdydW4gc2lkZS1lZmZlY3RzIG9yIG11dGF0aW9ucyBhZnRlciBSZWFjdCBoYXMgdXBkYXRlZCB0aGUgVUksIHVzZSBjb21wb25lbnREaWRVcGRhdGUoKS4nLCBuYW1lKTtcbiAgICAgIHZhciBub0NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgPSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyAhPT0gJ2Z1bmN0aW9uJztcbiAgICAgIHdhcm5pbmcobm9Db21wb25lbnRXaWxsUmVjaWV2ZVByb3BzLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCBuYW1lKTtcbiAgICAgIHZhciBoYXNNdXRhdGVkUHJvcHMgPSBpbnN0YW5jZS5wcm9wcyAhPT0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgd2FybmluZyhpbnN0YW5jZS5wcm9wcyA9PT0gdW5kZWZpbmVkIHx8ICFoYXNNdXRhdGVkUHJvcHMsICclcyguLi4pOiBXaGVuIGNhbGxpbmcgc3VwZXIoKSBpbiBgJXNgLCBtYWtlIHN1cmUgdG8gcGFzcyAnICsgXCJ1cCB0aGUgc2FtZSBwcm9wcyB0aGF0IHlvdXIgY29tcG9uZW50J3MgY29uc3RydWN0b3Igd2FzIHBhc3NlZC5cIiwgbmFtZSwgbmFtZSk7XG4gICAgICB2YXIgbm9JbnN0YW5jZURlZmF1bHRQcm9wcyA9ICFpbnN0YW5jZS5kZWZhdWx0UHJvcHM7XG4gICAgICB3YXJuaW5nKG5vSW5zdGFuY2VEZWZhdWx0UHJvcHMsICdTZXR0aW5nIGRlZmF1bHRQcm9wcyBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIGlnbm9yZWQuJyArICcgSW5zdGVhZCwgZGVmaW5lIGRlZmF1bHRQcm9wcyBhcyBhIHN0YXRpYyBwcm9wZXJ0eSBvbiAlcy4nLCBuYW1lLCBuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgc3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcbiAgICBpZiAoc3RhdGUgJiYgKHR5cGVvZiBzdGF0ZSAhPT0gJ29iamVjdCcgfHwgaXNBcnJheShzdGF0ZSkpKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXMuc3RhdGU6IG11c3QgYmUgc2V0IHRvIGFuIG9iamVjdCBvciBudWxsJywgZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd2FybmluZyh0eXBlb2Ygd29ya0luUHJvZ3Jlc3MudHlwZS5jaGlsZENvbnRleHRUeXBlcyA9PT0gJ29iamVjdCcsICclcy5nZXRDaGlsZENvbnRleHQoKTogY2hpbGRDb250ZXh0VHlwZXMgbXVzdCBiZSBkZWZpbmVkIGluIG9yZGVyIHRvICcgKyAndXNlIGdldENoaWxkQ29udGV4dCgpLicsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXNldElucHV0UG9pbnRlcnMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKSB7XG4gICAgaW5zdGFuY2UucHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkb3B0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpIHtcbiAgICBpbnN0YW5jZS51cGRhdGVyID0gdXBkYXRlcjtcbiAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBpbnN0YW5jZTtcbiAgICAvLyBUaGUgaW5zdGFuY2UgbmVlZHMgYWNjZXNzIHRvIHRoZSBmaWJlciBzbyB0aGF0IGl0IGNhbiBzY2hlZHVsZSB1cGRhdGVzXG4gICAgc2V0KGluc3RhbmNlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAge1xuICAgICAgaW5zdGFuY2UuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSA9IGZha2VJbnRlcm5hbEluc3RhbmNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnN0cnVjdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHByb3BzKSB7XG4gICAgdmFyIGN0b3IgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBuZWVkc0NvbnRleHQgPSBpc0NvbnRleHRDb25zdW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIGNvbnRleHQgPSBuZWVkc0NvbnRleHQgPyBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpIDogZW1wdHlPYmplY3Q7XG4gICAgdmFyIGluc3RhbmNlID0gbmV3IGN0b3IocHJvcHMsIGNvbnRleHQpO1xuICAgIGFkb3B0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuXG4gICAgLy8gQ2FjaGUgdW5tYXNrZWQgY29udGV4dCBzbyB3ZSBjYW4gYXZvaWQgcmVjcmVhdGluZyBtYXNrZWQgY29udGV4dCB1bmxlc3MgbmVjZXNzYXJ5LlxuICAgIC8vIFJlYWN0RmliZXJDb250ZXh0IHVzdWFsbHkgdXBkYXRlcyB0aGlzIGNhY2hlIGJ1dCBjYW4ndCBmb3IgbmV3bHktY3JlYXRlZCBpbnN0YW5jZXMuXG4gICAgaWYgKG5lZWRzQ29udGV4dCkge1xuICAgICAgY2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQsIGNvbnRleHQpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsTW91bnQod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKSB7XG4gICAgc3RhcnRQaGFzZVRpbWVyKHdvcmtJblByb2dyZXNzLCAnY29tcG9uZW50V2lsbE1vdW50Jyk7XG4gICAgdmFyIG9sZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgc3RvcFBoYXNlVGltZXIoKTtcblxuICAgIC8vIFNpbXVsYXRlIGFuIGFzeW5jIGJhaWxvdXQvaW50ZXJydXB0aW9uIGJ5IGludm9raW5nIGxpZmVjeWNsZSB0d2ljZS5cbiAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzKSB7XG4gICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICB9XG5cbiAgICBpZiAob2xkU3RhdGUgIT09IGluc3RhbmNlLnN0YXRlKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICclcy5jb21wb25lbnRXaWxsTW91bnQoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvIHRoaXMuc3RhdGUgaXMgJyArIFwiZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiICsgJ2NvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykpO1xuICAgICAgfVxuICAgICAgdXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLCBuZXdQcm9wcywgbmV3Q29udGV4dCkge1xuICAgIHN0YXJ0UGhhc2VUaW1lcih3b3JrSW5Qcm9ncmVzcywgJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnKTtcbiAgICB2YXIgb2xkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLCBuZXdDb250ZXh0KTtcbiAgICBzdG9wUGhhc2VUaW1lcigpO1xuXG4gICAgLy8gU2ltdWxhdGUgYW4gYXN5bmMgYmFpbG91dC9pbnRlcnJ1cHRpb24gYnkgaW52b2tpbmcgbGlmZWN5Y2xlIHR3aWNlLlxuICAgIGlmIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMpIHtcbiAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIG5ld0NvbnRleHQpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5zdGF0ZSAhPT0gb2xkU3RhdGUpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnQ29tcG9uZW50JztcbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnRbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpOiBBc3NpZ25pbmcgZGlyZWN0bHkgdG8gJyArIFwidGhpcy5zdGF0ZSBpcyBkZXByZWNhdGVkIChleGNlcHQgaW5zaWRlIGEgY29tcG9uZW50J3MgXCIgKyAnY29uc3RydWN0b3IpLiBVc2Ugc2V0U3RhdGUgaW5zdGVhZC4nLCBjb21wb25lbnROYW1lKTtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnRbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB1cGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUoaW5zdGFuY2UsIGluc3RhbmNlLnN0YXRlLCBudWxsKTtcbiAgICB9XG4gIH1cblxuICAvLyBJbnZva2VzIHRoZSBtb3VudCBsaWZlLWN5Y2xlcyBvbiBhIHByZXZpb3VzbHkgbmV2ZXIgcmVuZGVyZWQgaW5zdGFuY2UuXG4gIGZ1bmN0aW9uIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuICAgIHtcbiAgICAgIGNoZWNrQ2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIHZhciBzdGF0ZSA9IGluc3RhbmNlLnN0YXRlIHx8IG51bGw7XG5cbiAgICB2YXIgcHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgIXByb3BzID8gaW52YXJpYW50KGZhbHNlLCAnVGhlcmUgbXVzdCBiZSBwZW5kaW5nIHByb3BzIGZvciBhbiBpbml0aWFsIG1vdW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAgdmFyIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICBpbnN0YW5jZS5wcm9wcyA9IHByb3BzO1xuICAgIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHN0YXRlO1xuICAgIGluc3RhbmNlLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgICBpbnN0YW5jZS5jb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcblxuICAgIGlmIChlbmFibGVBc3luY1N1YnRyZWVBUEkgJiYgd29ya0luUHJvZ3Jlc3MudHlwZSAhPSBudWxsICYmIHdvcmtJblByb2dyZXNzLnR5cGUucHJvdG90eXBlICE9IG51bGwgJiYgd29ya0luUHJvZ3Jlc3MudHlwZS5wcm90b3R5cGUudW5zdGFibGVfaXNBc3luY1JlYWN0Q29tcG9uZW50ID09PSB0cnVlKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5pbnRlcm5hbENvbnRleHRUYWcgfD0gQXN5bmNVcGRhdGVzO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG4gICAgICAvLyBJZiB3ZSBoYWQgYWRkaXRpb25hbCBzdGF0ZSB1cGRhdGVzIGR1cmluZyB0aGlzIGxpZmUtY3ljbGUsIGxldCdzXG4gICAgICAvLyBwcm9jZXNzIHRoZW0gbm93LlxuICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gICAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgaW5zdGFuY2Uuc3RhdGUgPSBwcm9jZXNzVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHVwZGF0ZVF1ZXVlLCBpbnN0YW5jZSwgcHJvcHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxsZWQgb24gYSBwcmVleGlzdGluZyBjbGFzcyBpbnN0YW5jZS4gUmV0dXJucyBmYWxzZSBpZiBhIHJlc3VtZWQgcmVuZGVyXG4gIC8vIGNvdWxkIGJlIHJldXNlZC5cbiAgLy8gZnVuY3Rpb24gcmVzdW1lTW91bnRDbGFzc0luc3RhbmNlKFxuICAvLyAgIHdvcmtJblByb2dyZXNzOiBGaWJlcixcbiAgLy8gICBwcmlvcml0eUxldmVsOiBQcmlvcml0eUxldmVsLFxuICAvLyApOiBib29sZWFuIHtcbiAgLy8gICBjb25zdCBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgLy8gICByZXNldElucHV0UG9pbnRlcnMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcblxuICAvLyAgIGxldCBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIC8vICAgbGV0IG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAvLyAgIGlmICghbmV3UHJvcHMpIHtcbiAgLy8gICAgIC8vIElmIHRoZXJlIGlzbid0IGFueSBuZXcgcHJvcHMsIHRoZW4gd2UnbGwgcmV1c2UgdGhlIG1lbW9pemVkIHByb3BzLlxuICAvLyAgICAgLy8gVGhpcyBjb3VsZCBiZSBmcm9tIGFscmVhZHkgY29tcGxldGVkIHdvcmsuXG4gIC8vICAgICBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gIC8vICAgICBpbnZhcmlhbnQoXG4gIC8vICAgICAgIG5ld1Byb3BzICE9IG51bGwsXG4gIC8vICAgICAgICdUaGVyZSBzaG91bGQgYWx3YXlzIGJlIHBlbmRpbmcgb3IgbWVtb2l6ZWQgcHJvcHMuIFRoaXMgZXJyb3IgaXMgJyArXG4gIC8vICAgICAgICAgJ2xpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsXG4gIC8vICAgICApO1xuICAvLyAgIH1cbiAgLy8gICBjb25zdCBuZXdVbm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAvLyAgIGNvbnN0IG5ld0NvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBuZXdVbm1hc2tlZENvbnRleHQpO1xuXG4gIC8vICAgY29uc3Qgb2xkQ29udGV4dCA9IGluc3RhbmNlLmNvbnRleHQ7XG4gIC8vICAgY29uc3Qgb2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuXG4gIC8vICAgaWYgKFxuICAvLyAgICAgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgJiZcbiAgLy8gICAgIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMgfHwgb2xkQ29udGV4dCAhPT0gbmV3Q29udGV4dClcbiAgLy8gICApIHtcbiAgLy8gICAgIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKFxuICAvLyAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgLy8gICAgICAgaW5zdGFuY2UsXG4gIC8vICAgICAgIG5ld1Byb3BzLFxuICAvLyAgICAgICBuZXdDb250ZXh0LFxuICAvLyAgICAgKTtcbiAgLy8gICB9XG5cbiAgLy8gICAvLyBQcm9jZXNzIHRoZSB1cGRhdGUgcXVldWUgYmVmb3JlIGNhbGxpbmcgc2hvdWxkQ29tcG9uZW50VXBkYXRlXG4gIC8vICAgY29uc3QgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgLy8gICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgLy8gICAgIG5ld1N0YXRlID0gcHJvY2Vzc1VwZGF0ZVF1ZXVlKFxuICAvLyAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgLy8gICAgICAgdXBkYXRlUXVldWUsXG4gIC8vICAgICAgIGluc3RhbmNlLFxuICAvLyAgICAgICBuZXdTdGF0ZSxcbiAgLy8gICAgICAgbmV3UHJvcHMsXG4gIC8vICAgICAgIHByaW9yaXR5TGV2ZWwsXG4gIC8vICAgICApO1xuICAvLyAgIH1cblxuICAvLyAgIC8vIFRPRE86IFNob3VsZCB3ZSBkZWFsIHdpdGggYSBzZXRTdGF0ZSB0aGF0IGhhcHBlbmVkIGFmdGVyIHRoZSBsYXN0XG4gIC8vICAgLy8gY29tcG9uZW50V2lsbE1vdW50IGFuZCBiZWZvcmUgdGhpcyBjb21wb25lbnRXaWxsTW91bnQ/IFByb2JhYmx5XG4gIC8vICAgLy8gdW5zdXBwb3J0ZWQgYW55d2F5LlxuXG4gIC8vICAgaWYgKFxuICAvLyAgICAgIWNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKFxuICAvLyAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgLy8gICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyxcbiAgLy8gICAgICAgbmV3UHJvcHMsXG4gIC8vICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUsXG4gIC8vICAgICAgIG5ld1N0YXRlLFxuICAvLyAgICAgICBuZXdDb250ZXh0LFxuICAvLyAgICAgKVxuICAvLyAgICkge1xuICAvLyAgICAgLy8gVXBkYXRlIHRoZSBleGlzdGluZyBpbnN0YW5jZSdzIHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgcG9pbnRlcnMgZXZlblxuICAvLyAgICAgLy8gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LlxuICAvLyAgICAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgLy8gICAgIGluc3RhbmNlLnN0YXRlID0gbmV3U3RhdGU7XG4gIC8vICAgICBpbnN0YW5jZS5jb250ZXh0ID0gbmV3Q29udGV4dDtcbiAgLy8gICAgIHJldHVybiBmYWxzZTtcbiAgLy8gICB9XG5cbiAgLy8gICAvLyBVcGRhdGUgdGhlIGlucHV0IHBvaW50ZXJzIG5vdyBzbyB0aGF0IHRoZXkgYXJlIGNvcnJlY3Qgd2hlbiB3ZSBjYWxsXG4gIC8vICAgLy8gY29tcG9uZW50V2lsbE1vdW50XG4gIC8vICAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgLy8gICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICAvLyAgIGluc3RhbmNlLmNvbnRleHQgPSBuZXdDb250ZXh0O1xuXG4gIC8vICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gICAgIGNhbGxDb21wb25lbnRXaWxsTW91bnQod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcbiAgLy8gICAgIC8vIGNvbXBvbmVudFdpbGxNb3VudCBtYXkgaGF2ZSBjYWxsZWQgc2V0U3RhdGUuIFByb2Nlc3MgdGhlIHVwZGF0ZSBxdWV1ZS5cbiAgLy8gICAgIGNvbnN0IG5ld1VwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIC8vICAgICBpZiAobmV3VXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgLy8gICAgICAgbmV3U3RhdGUgPSBwcm9jZXNzVXBkYXRlUXVldWUoXG4gIC8vICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gIC8vICAgICAgICAgbmV3VXBkYXRlUXVldWUsXG4gIC8vICAgICAgICAgaW5zdGFuY2UsXG4gIC8vICAgICAgICAgbmV3U3RhdGUsXG4gIC8vICAgICAgICAgbmV3UHJvcHMsXG4gIC8vICAgICAgICAgcHJpb3JpdHlMZXZlbCxcbiAgLy8gICAgICAgKTtcbiAgLy8gICAgIH1cbiAgLy8gICB9XG5cbiAgLy8gICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAvLyAgIH1cblxuICAvLyAgIGluc3RhbmNlLnN0YXRlID0gbmV3U3RhdGU7XG5cbiAgLy8gICByZXR1cm4gdHJ1ZTtcbiAgLy8gfVxuXG4gIC8vIEludm9rZXMgdGhlIHVwZGF0ZSBsaWZlLWN5Y2xlcyBhbmQgcmV0dXJucyBmYWxzZSBpZiBpdCBzaG91bGRuJ3QgcmVyZW5kZXIuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNsYXNzSW5zdGFuY2UoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIHJlc2V0SW5wdXRQb2ludGVycyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuXG4gICAgdmFyIG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKCFuZXdQcm9wcykge1xuICAgICAgLy8gSWYgdGhlcmUgYXJlbid0IGFueSBuZXcgcHJvcHMsIHRoZW4gd2UnbGwgcmV1c2UgdGhlIG1lbW9pemVkIHByb3BzLlxuICAgICAgLy8gVGhpcyBjb3VsZCBiZSBmcm9tIGFscmVhZHkgY29tcGxldGVkIHdvcmsuXG4gICAgICBuZXdQcm9wcyA9IG9sZFByb3BzO1xuICAgICAgIShuZXdQcm9wcyAhPSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1RoZXJlIHNob3VsZCBhbHdheXMgYmUgcGVuZGluZyBvciBtZW1vaXplZCBwcm9wcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICB9XG4gICAgdmFyIG9sZENvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xuICAgIHZhciBuZXdVbm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBuZXdDb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgbmV3VW5tYXNrZWRDb250ZXh0KTtcblxuICAgIC8vIE5vdGU6IER1cmluZyB0aGVzZSBsaWZlLWN5Y2xlcywgaW5zdGFuY2UucHJvcHMvaW5zdGFuY2Uuc3RhdGUgYXJlIHdoYXRcbiAgICAvLyBldmVyIHRoZSBwcmV2aW91c2x5IGF0dGVtcHRlZCB0byByZW5kZXIgLSBub3QgdGhlIFwiY3VycmVudFwiLiBIb3dldmVyLFxuICAgIC8vIGR1cmluZyBjb21wb25lbnREaWRVcGRhdGUgd2UgcGFzcyB0aGUgXCJjdXJyZW50XCIgcHJvcHMuXG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgKG9sZFByb3BzICE9PSBuZXdQcm9wcyB8fCBvbGRDb250ZXh0ICE9PSBuZXdDb250ZXh0KSkge1xuICAgICAgY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLCBuZXdQcm9wcywgbmV3Q29udGV4dCk7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSB0aGUgbmV4dCBzdGF0ZSB1c2luZyB0aGUgbWVtb2l6ZWQgc3RhdGUgYW5kIHRoZSB1cGRhdGUgcXVldWUuXG4gICAgdmFyIG9sZFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAvLyBUT0RPOiBQcmV2aW91cyBzdGF0ZSBjYW4gYmUgbnVsbC5cbiAgICB2YXIgbmV3U3RhdGUgPSB2b2lkIDA7XG4gICAgaWYgKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICBuZXdTdGF0ZSA9IHByb2Nlc3NVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUsIGluc3RhbmNlLCBuZXdQcm9wcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdGF0ZSA9IG9sZFN0YXRlO1xuICAgIH1cblxuICAgIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMgJiYgb2xkU3RhdGUgPT09IG5ld1N0YXRlICYmICFoYXNDb250ZXh0Q2hhbmdlZCgpICYmICEod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgIT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUuaGFzRm9yY2VVcGRhdGUpKSB7XG4gICAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcbiAgICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAob2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBzaG91bGRVcGRhdGUgPSBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgb2xkUHJvcHMsIG5ld1Byb3BzLCBvbGRTdGF0ZSwgbmV3U3RhdGUsIG5ld0NvbnRleHQpO1xuXG4gICAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHN0YXJ0UGhhc2VUaW1lcih3b3JrSW5Qcm9ncmVzcywgJ2NvbXBvbmVudFdpbGxVcGRhdGUnKTtcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZShuZXdQcm9wcywgbmV3U3RhdGUsIG5ld0NvbnRleHQpO1xuICAgICAgICBzdG9wUGhhc2VUaW1lcigpO1xuXG4gICAgICAgIC8vIFNpbXVsYXRlIGFuIGFzeW5jIGJhaWxvdXQvaW50ZXJydXB0aW9uIGJ5IGludm9raW5nIGxpZmVjeWNsZSB0d2ljZS5cbiAgICAgICAgaWYgKGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cykge1xuICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXdDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKG9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybmVkIGZhbHNlLCB3ZSBzaG91bGQgc3RpbGwgdXBkYXRlIHRoZVxuICAgICAgLy8gbWVtb2l6ZWQgcHJvcHMvc3RhdGUgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIHdvcmsgY2FuIGJlIHJldXNlZC5cbiAgICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV3UHJvcHMpO1xuICAgICAgbWVtb2l6ZVN0YXRlKHdvcmtJblByb2dyZXNzLCBuZXdTdGF0ZSk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHRoZSBleGlzdGluZyBpbnN0YW5jZSdzIHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgcG9pbnRlcnMgZXZlblxuICAgIC8vIGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5zIGZhbHNlLlxuICAgIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gICAgaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICBpbnN0YW5jZS5jb250ZXh0ID0gbmV3Q29udGV4dDtcblxuICAgIHJldHVybiBzaG91bGRVcGRhdGU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGFkb3B0Q2xhc3NJbnN0YW5jZTogYWRvcHRDbGFzc0luc3RhbmNlLFxuICAgIGNvbnN0cnVjdENsYXNzSW5zdGFuY2U6IGNvbnN0cnVjdENsYXNzSW5zdGFuY2UsXG4gICAgbW91bnRDbGFzc0luc3RhbmNlOiBtb3VudENsYXNzSW5zdGFuY2UsXG4gICAgLy8gcmVzdW1lTW91bnRDbGFzc0luc3RhbmNlLFxuICAgIHVwZGF0ZUNsYXNzSW5zdGFuY2U6IHVwZGF0ZUNsYXNzSW5zdGFuY2VcbiAgfTtcbn07XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2xbJ2ZvciddO1xuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xudmFyIFJFQUNUX0NBTExfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmNhbGwnKSA6IDB4ZWFjODtcbnZhciBSRUFDVF9SRVRVUk5fVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LnJldHVybicpIDogMHhlYWM5O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QucG9ydGFsJykgOiAweGVhY2E7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmZyYWdtZW50JykgOiAweGVhY2I7XG5cbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcblxuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cblxue1xuICB2YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xuICAvKipcbiAgICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICAgKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAgICogdXBkYXRlcy5cbiAgICovXG4gIHZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcbiAgdmFyIG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZyA9IHt9O1xuXG4gIHZhciB3YXJuRm9yTWlzc2luZ0tleSA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCA9PT0gbnVsbCB8fCB0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY2hpbGQuX3N0b3JlIHx8IGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgfHwgY2hpbGQua2V5ICE9IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgISh0eXBlb2YgY2hpbGQuX3N0b3JlID09PSAnb2JqZWN0JykgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdCBDb21wb25lbnQgaW4gd2FybkZvck1pc3NpbmdLZXkgc2hvdWxkIGhhdmUgYSBfc3RvcmUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgY2hpbGQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG5cbiAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9ICdFYWNoIGNoaWxkIGluIGFuIGFycmF5IG9yIGl0ZXJhdG9yIHNob3VsZCBoYXZlIGEgdW5pcXVlICcgKyAnXCJrZXlcIiBwcm9wLiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWtleXMgZm9yICcgKyAnbW9yZSBpbmZvcm1hdGlvbi4nICsgKGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMSgpIHx8ICcnKTtcbiAgICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7XG5cbiAgICB3YXJuaW5nKGZhbHNlLCAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBvciBpdGVyYXRvciBzaG91bGQgaGF2ZSBhIHVuaXF1ZSAnICsgJ1wia2V5XCIgcHJvcC4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciAnICsgJ21vcmUgaW5mb3JtYXRpb24uJXMnLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEoKSk7XG4gIH07XG59XG5cbnZhciBpc0FycmF5JDEgPSBBcnJheS5pc0FycmF5O1xuXG5mdW5jdGlvbiBjb2VyY2VSZWYoY3VycmVudCwgZWxlbWVudCkge1xuICB2YXIgbWl4ZWRSZWYgPSBlbGVtZW50LnJlZjtcbiAgaWYgKG1peGVkUmVmICE9PSBudWxsICYmIHR5cGVvZiBtaXhlZFJlZiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChlbGVtZW50Ll9vd25lcikge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgaW5zdCA9IHZvaWQgMDtcbiAgICAgIGlmIChvd25lcikge1xuICAgICAgICB2YXIgb3duZXJGaWJlciA9IG93bmVyO1xuICAgICAgICAhKG93bmVyRmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTdGF0ZWxlc3MgZnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgaGF2ZSByZWZzLicpIDogdm9pZCAwO1xuICAgICAgICBpbnN0ID0gb3duZXJGaWJlci5zdGF0ZU5vZGU7XG4gICAgICB9XG4gICAgICAhaW5zdCA/IGludmFyaWFudChmYWxzZSwgJ01pc3Npbmcgb3duZXIgZm9yIHN0cmluZyByZWYgJXMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgbWl4ZWRSZWYpIDogdm9pZCAwO1xuICAgICAgdmFyIHN0cmluZ1JlZiA9ICcnICsgbWl4ZWRSZWY7XG4gICAgICAvLyBDaGVjayBpZiBwcmV2aW91cyBzdHJpbmcgcmVmIG1hdGNoZXMgbmV3IHN0cmluZyByZWZcbiAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQucmVmICE9PSBudWxsICYmIGN1cnJlbnQucmVmLl9zdHJpbmdSZWYgPT09IHN0cmluZ1JlZikge1xuICAgICAgICByZXR1cm4gY3VycmVudC5yZWY7XG4gICAgICB9XG4gICAgICB2YXIgcmVmID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZWZzID0gaW5zdC5yZWZzID09PSBlbXB0eU9iamVjdCA/IGluc3QucmVmcyA9IHt9IDogaW5zdC5yZWZzO1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICBkZWxldGUgcmVmc1tzdHJpbmdSZWZdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZnNbc3RyaW5nUmVmXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmVmLl9zdHJpbmdSZWYgPSBzdHJpbmdSZWY7XG4gICAgICByZXR1cm4gcmVmO1xuICAgIH0gZWxzZSB7XG4gICAgICAhKHR5cGVvZiBtaXhlZFJlZiA9PT0gJ3N0cmluZycpID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgcmVmIHRvIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmcuJykgOiB2b2lkIDA7XG4gICAgICAhZWxlbWVudC5fb3duZXIgPyBpbnZhcmlhbnQoZmFsc2UsICdFbGVtZW50IHJlZiB3YXMgc3BlY2lmaWVkIGFzIGEgc3RyaW5nICglcykgYnV0IG5vIG93bmVyIHdhcyBzZXQuIFlvdSBtYXkgaGF2ZSBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgbG9hZGVkLiAoZGV0YWlsczogaHR0cHM6Ly9mYi5tZS9yZWFjdC1yZWZzLW11c3QtaGF2ZS1vd25lcikuJywgbWl4ZWRSZWYpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWl4ZWRSZWY7XG59XG5cbmZ1bmN0aW9uIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpIHtcbiAgaWYgKHJldHVybkZpYmVyLnR5cGUgIT09ICd0ZXh0YXJlYScpIHtcbiAgICB2YXIgYWRkZW5kdW0gPSAnJztcbiAgICB7XG4gICAgICBhZGRlbmR1bSA9ICcgSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSAnICsgJ2luc3RlYWQuJyArIChnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEoKSB8fCAnJyk7XG4gICAgfVxuICAgIGludmFyaWFudChmYWxzZSwgJ09iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogJXMpLiVzJywgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0NoaWxkKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKG5ld0NoaWxkKS5qb2luKCcsICcpICsgJ30nIDogbmV3Q2hpbGQsIGFkZGVuZHVtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuT25GdW5jdGlvblR5cGUoKSB7XG4gIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gJ0Z1bmN0aW9ucyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuIFRoaXMgbWF5IGhhcHBlbiBpZiAnICsgJ3lvdSByZXR1cm4gYSBDb21wb25lbnQgaW5zdGVhZCBvZiA8Q29tcG9uZW50IC8+IGZyb20gcmVuZGVyLiAnICsgJ09yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LicgKyAoZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkgfHwgJycpO1xuXG4gIGlmIChvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTtcblxuICB3YXJuaW5nKGZhbHNlLCAnRnVuY3Rpb25zIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC4gVGhpcyBtYXkgaGFwcGVuIGlmICcgKyAneW91IHJldHVybiBhIENvbXBvbmVudCBpbnN0ZWFkIG9mIDxDb21wb25lbnQgLz4gZnJvbSByZW5kZXIuICcgKyAnT3IgbWF5YmUgeW91IG1lYW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiByZXR1cm4gaXQuJXMnLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEoKSB8fCAnJyk7XG59XG5cbi8vIFRoaXMgd3JhcHBlciBmdW5jdGlvbiBleGlzdHMgYmVjYXVzZSBJIGV4cGVjdCB0byBjbG9uZSB0aGUgY29kZSBpbiBlYWNoIHBhdGhcbi8vIHRvIGJlIGFibGUgdG8gb3B0aW1pemUgZWFjaCBwYXRoIGluZGl2aWR1YWxseSBieSBicmFuY2hpbmcgZWFybHkuIFRoaXMgbmVlZHNcbi8vIGEgY29tcGlsZXIgb3Igd2UgY2FuIGRvIGl0IG1hbnVhbGx5LiBIZWxwZXJzIHRoYXQgZG9uJ3QgbmVlZCB0aGlzIGJyYW5jaGluZ1xuLy8gbGl2ZSBvdXRzaWRlIG9mIHRoaXMgZnVuY3Rpb24uXG5mdW5jdGlvbiBDaGlsZFJlY29uY2lsZXIoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICBmdW5jdGlvbiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGRUb0RlbGV0ZSkge1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gRGVsZXRpb25zIGFyZSBhZGRlZCBpbiByZXZlcnNlZCBvcmRlciBzbyB3ZSBhZGQgaXQgdG8gdGhlIGZyb250LlxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSByZXR1cm4gZmliZXIncyBlZmZlY3QgbGlzdCBpcyBlbXB0eSBleGNlcHQgZm9yXG4gICAgLy8gZGVsZXRpb25zLCBzbyB3ZSBjYW4ganVzdCBhcHBlbmQgdGhlIGRlbGV0aW9uIHRvIHRoZSBsaXN0LiBUaGUgcmVtYWluaW5nXG4gICAgLy8gZWZmZWN0cyBhcmVuJ3QgYWRkZWQgdW50aWwgdGhlIGNvbXBsZXRlIHBoYXNlLiBPbmNlIHdlIGltcGxlbWVudFxuICAgIC8vIHJlc3VtaW5nLCB0aGlzIG1heSBub3QgYmUgdHJ1ZS5cbiAgICB2YXIgbGFzdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3Q7XG4gICAgaWYgKGxhc3QgIT09IG51bGwpIHtcbiAgICAgIGxhc3QubmV4dEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICB9XG4gICAgY2hpbGRUb0RlbGV0ZS5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgICBjaGlsZFRvRGVsZXRlLmVmZmVjdFRhZyA9IERlbGV0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSB7XG4gICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBOb29wLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogRm9yIHRoZSBzaG91bGRDbG9uZSBjYXNlLCB0aGlzIGNvdWxkIGJlIG1pY3JvLW9wdGltaXplZCBhIGJpdCBieVxuICAgIC8vIGFzc3VtaW5nIHRoYXQgYWZ0ZXIgdGhlIGZpcnN0IGNoaWxkIHdlJ3ZlIGFscmVhZHkgYWRkZWQgZXZlcnl0aGluZy5cbiAgICB2YXIgY2hpbGRUb0RlbGV0ZSA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHdoaWxlIChjaGlsZFRvRGVsZXRlICE9PSBudWxsKSB7XG4gICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGRUb0RlbGV0ZSk7XG4gICAgICBjaGlsZFRvRGVsZXRlID0gY2hpbGRUb0RlbGV0ZS5zaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcFJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCkge1xuICAgIC8vIEFkZCB0aGUgcmVtYWluaW5nIGNoaWxkcmVuIHRvIGEgdGVtcG9yYXJ5IG1hcCBzbyB0aGF0IHdlIGNhbiBmaW5kIHRoZW0gYnlcbiAgICAvLyBrZXlzIHF1aWNrbHkuIEltcGxpY2l0IChudWxsKSBrZXlzIGdldCBhZGRlZCB0byB0aGlzIHNldCB3aXRoIHRoZWlyIGluZGV4XG4gICAgdmFyIGV4aXN0aW5nQ2hpbGRyZW4gPSBuZXcgTWFwKCk7XG5cbiAgICB2YXIgZXhpc3RpbmdDaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHdoaWxlIChleGlzdGluZ0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBpZiAoZXhpc3RpbmdDaGlsZC5rZXkgIT09IG51bGwpIHtcbiAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5zZXQoZXhpc3RpbmdDaGlsZC5rZXksIGV4aXN0aW5nQ2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5zZXQoZXhpc3RpbmdDaGlsZC5pbmRleCwgZXhpc3RpbmdDaGlsZCk7XG4gICAgICB9XG4gICAgICBleGlzdGluZ0NoaWxkID0gZXhpc3RpbmdDaGlsZC5zaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gZXhpc3RpbmdDaGlsZHJlbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVzZUZpYmVyKGZpYmVyLCBwZW5kaW5nUHJvcHMsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gV2UgY3VycmVudGx5IHNldCBzaWJsaW5nIHRvIG51bGwgYW5kIGluZGV4IHRvIDAgaGVyZSBiZWNhdXNlIGl0IGlzIGVhc3lcbiAgICAvLyB0byBmb3JnZXQgdG8gZG8gYmVmb3JlIHJldHVybmluZyBpdC4gRS5nLiBmb3IgdGhlIHNpbmdsZSBjaGlsZCBjYXNlLlxuICAgIHZhciBjbG9uZSA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGZpYmVyLCBwZW5kaW5nUHJvcHMsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBjbG9uZS5pbmRleCA9IDA7XG4gICAgY2xvbmUuc2libGluZyA9IG51bGw7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG5cbiAgZnVuY3Rpb24gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJbmRleCkge1xuICAgIG5ld0ZpYmVyLmluZGV4ID0gbmV3SW5kZXg7XG4gICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBOb29wLlxuICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgICB9XG4gICAgdmFyIGN1cnJlbnQgPSBuZXdGaWJlci5hbHRlcm5hdGU7XG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIHZhciBvbGRJbmRleCA9IGN1cnJlbnQuaW5kZXg7XG4gICAgICBpZiAob2xkSW5kZXggPCBsYXN0UGxhY2VkSW5kZXgpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIG1vdmUuXG4gICAgICAgIG5ld0ZpYmVyLmVmZmVjdFRhZyA9IFBsYWNlbWVudDtcbiAgICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXRlbSBjYW4gc3RheSBpbiBwbGFjZS5cbiAgICAgICAgcmV0dXJuIG9sZEluZGV4O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGluc2VydGlvbi5cbiAgICAgIG5ld0ZpYmVyLmVmZmVjdFRhZyA9IFBsYWNlbWVudDtcbiAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGxhY2VTaW5nbGVDaGlsZChuZXdGaWJlcikge1xuICAgIC8vIFRoaXMgaXMgc2ltcGxlciBmb3IgdGhlIHNpbmdsZSBjaGlsZCBjYXNlLiBXZSBvbmx5IG5lZWQgdG8gZG8gYVxuICAgIC8vIHBsYWNlbWVudCBmb3IgaW5zZXJ0aW5nIG5ldyBjaGlsZHJlbi5cbiAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgIG5ld0ZpYmVyLmVmZmVjdFRhZyA9IFBsYWNlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0ZpYmVyO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnQsIHRleHRDb250ZW50LCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBIb3N0VGV4dCkge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQodGV4dENvbnRlbnQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIHRleHRDb250ZW50LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50LCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQudHlwZSA9PT0gZWxlbWVudC50eXBlKSB7XG4gICAgICAvLyBNb3ZlIGJhc2VkIG9uIGluZGV4XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBlbGVtZW50LnByb3BzLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZy5yZWYgPSBjb2VyY2VSZWYoY3VycmVudCwgZWxlbWVudCk7XG4gICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHtcbiAgICAgICAgZXhpc3RpbmcuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgICAgICBleGlzdGluZy5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWQucmVmID0gY29lcmNlUmVmKGN1cnJlbnQsIGVsZW1lbnQpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNhbGwocmV0dXJuRmliZXIsIGN1cnJlbnQsIGNhbGwsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVE9ETzogU2hvdWxkIHRoaXMgYWxzbyBjb21wYXJlIGhhbmRsZXIgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcmV1c2U/XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IENhbGxDb21wb25lbnQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21DYWxsKGNhbGwsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNb3ZlIGJhc2VkIG9uIGluZGV4XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBjYWxsLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVSZXR1cm4ocmV0dXJuRmliZXIsIGN1cnJlbnQsIHJldHVybk5vZGUsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IFJldHVybkNvbXBvbmVudCkge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVJldHVybihyZXR1cm5Ob2RlLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWQudHlwZSA9IHJldHVybk5vZGUudmFsdWU7XG4gICAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE1vdmUgYmFzZWQgb24gaW5kZXhcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIG51bGwsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nLnR5cGUgPSByZXR1cm5Ob2RlLnZhbHVlO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50LCBwb3J0YWwsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEhvc3RQb3J0YWwgfHwgY3VycmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyAhPT0gcG9ydGFsLmNvbnRhaW5lckluZm8gfHwgY3VycmVudC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24gIT09IHBvcnRhbC5pbXBsZW1lbnRhdGlvbikge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIHBvcnRhbC5jaGlsZHJlbiB8fCBbXSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIGN1cnJlbnQsIGZyYWdtZW50LCBleHBpcmF0aW9uVGltZSwga2V5KSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEZyYWdtZW50KSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZnJhZ21lbnQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUsIGtleSk7XG4gICAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZVxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgZnJhZ21lbnQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cy4gSWYgdGhlIHByZXZpb3VzIG5vZGUgaXMgaW1wbGljaXRseSBrZXllZFxuICAgICAgLy8gd2UgY2FuIGNvbnRpbnVlIHRvIHJlcGxhY2UgaXQgd2l0aG91dCBhYm9ydGluZyBldmVuIGlmIGl0IGlzIG5vdCBhIHRleHRcbiAgICAgIC8vIG5vZGUuXG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQoJycgKyBuZXdDaGlsZCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgICAgICAgICAgdmFyIF9jcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQobmV3Q2hpbGQucHJvcHMuY2hpbGRyZW4sIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUsIG5ld0NoaWxkLmtleSk7XG4gICAgICAgICAgICAgIF9jcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgX2NyZWF0ZWQyID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChuZXdDaGlsZCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICAgIF9jcmVhdGVkMi5yZWYgPSBjb2VyY2VSZWYobnVsbCwgbmV3Q2hpbGQpO1xuICAgICAgICAgICAgICBfY3JlYXRlZDJbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfQ0FMTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3JlYXRlZDMgPSBjcmVhdGVGaWJlckZyb21DYWxsKG5ld0NoaWxkLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIF9jcmVhdGVkM1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDM7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUkVUVVJOX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9jcmVhdGVkNCA9IGNyZWF0ZUZpYmVyRnJvbVJldHVybihuZXdDaGlsZCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICBfY3JlYXRlZDQudHlwZSA9IG5ld0NoaWxkLnZhbHVlO1xuICAgICAgICAgICAgX2NyZWF0ZWQ0WydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVkNDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2NyZWF0ZWQ1ID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKG5ld0NoaWxkLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIF9jcmVhdGVkNVsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDU7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheSQxKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICB2YXIgX2NyZWF0ZWQ2ID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQobmV3Q2hpbGQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUsIG51bGwpO1xuICAgICAgICBfY3JlYXRlZDZbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgIHJldHVybiBfY3JlYXRlZDY7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVXBkYXRlIHRoZSBmaWJlciBpZiB0aGUga2V5cyBtYXRjaCwgb3RoZXJ3aXNlIHJldHVybiBudWxsLlxuXG4gICAgdmFyIGtleSA9IG9sZEZpYmVyICE9PSBudWxsID8gb2xkRmliZXIua2V5IDogbnVsbDtcblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIFRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBrZXlzLiBJZiB0aGUgcHJldmlvdXMgbm9kZSBpcyBpbXBsaWNpdGx5IGtleWVkXG4gICAgICAvLyB3ZSBjYW4gY29udGludWUgdG8gcmVwbGFjZSBpdCB3aXRob3V0IGFib3J0aW5nIGV2ZW4gaWYgaXQgaXMgbm90IGEgdGV4dFxuICAgICAgLy8gbm9kZS5cbiAgICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIG9sZEZpYmVyLCAnJyArIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgIGlmIChuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW4sIGV4cGlyYXRpb25UaW1lLCBrZXkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX0NBTExfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUNhbGwocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUkVUVVJOX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gUmV0dXJucyBkb24ndCBoYXZlIGtleXMuIElmIHRoZSBwcmV2aW91cyBub2RlIGlzIGltcGxpY2l0bHkga2V5ZWRcbiAgICAgICAgICAgIC8vIHdlIGNhbiBjb250aW51ZSB0byByZXBsYWNlIGl0IHdpdGhvdXQgYWJvcnRpbmcgZXZlbiBpZiBpdCBpcyBub3QgYVxuICAgICAgICAgICAgLy8geWllbGQuXG4gICAgICAgICAgICBpZiAoa2V5ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVSZXR1cm4ocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheSQxKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cywgc28gd2UgbmVpdGhlciBoYXZlIHRvIGNoZWNrIHRoZSBvbGQgbm9yXG4gICAgICAvLyBuZXcgbm9kZSBmb3IgdGhlIGtleS4gSWYgYm90aCBhcmUgdGV4dCBub2RlcywgdGhleSBtYXRjaC5cbiAgICAgIHZhciBtYXRjaGVkRmliZXIgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGw7XG4gICAgICByZXR1cm4gdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIG1hdGNoZWRGaWJlciwgJycgKyBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3Q2hpbGQua2V5ID09PSBudWxsID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5KSB8fCBudWxsO1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyLCBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbiwgZXhwaXJhdGlvblRpbWUsIG5ld0NoaWxkLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9DQUxMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9tYXRjaGVkRmliZXIyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3Q2hpbGQua2V5ID09PSBudWxsID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5KSB8fCBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUNhbGwocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1JFVFVSTl9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFJldHVybnMgZG9uJ3QgaGF2ZSBrZXlzLCBzbyB3ZSBuZWl0aGVyIGhhdmUgdG8gY2hlY2sgdGhlIG9sZCBub3JcbiAgICAgICAgICAgIC8vIG5ldyBub2RlIGZvciB0aGUga2V5LiBJZiBib3RoIGFyZSByZXR1cm5zLCB0aGV5IG1hdGNoLlxuICAgICAgICAgICAgdmFyIF9tYXRjaGVkRmliZXIzID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVJldHVybihyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlcjMsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9tYXRjaGVkRmliZXI0ID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3Q2hpbGQua2V5ID09PSBudWxsID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5KSB8fCBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlcjQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheSQxKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICB2YXIgX21hdGNoZWRGaWJlcjUgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGw7XG4gICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlcjUsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogV2FybnMgaWYgdGhlcmUgaXMgYSBkdXBsaWNhdGUgb3IgbWlzc2luZyBrZXlcbiAgICovXG4gIGZ1bmN0aW9uIHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cykge1xuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnIHx8IGNoaWxkID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBrbm93bktleXM7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGNoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICBjYXNlIFJFQUNUX0NBTExfVFlQRTpcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICB3YXJuRm9yTWlzc2luZ0tleShjaGlsZCk7XG4gICAgICAgICAgdmFyIGtleSA9IGNoaWxkLmtleTtcbiAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoa25vd25LZXlzID09PSBudWxsKSB7XG4gICAgICAgICAgICBrbm93bktleXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBrbm93bktleXMuYWRkKGtleSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFrbm93bktleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIGtub3duS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnRW5jb3VudGVyZWQgdHdvIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUga2V5LCBgJXNgLiAnICsgJ0tleXMgc2hvdWxkIGJlIHVuaXF1ZSBzbyB0aGF0IGNvbXBvbmVudHMgbWFpbnRhaW4gdGhlaXIgaWRlbnRpdHkgJyArICdhY3Jvc3MgdXBkYXRlcy4gTm9uLXVuaXF1ZSBrZXlzIG1heSBjYXVzZSBjaGlsZHJlbiB0byBiZSAnICsgJ2R1cGxpY2F0ZWQgYW5kL29yIG9taXR0ZWQg4oCUIHRoZSBiZWhhdmlvciBpcyB1bnN1cHBvcnRlZCBhbmQgJyArICdjb3VsZCBjaGFuZ2UgaW4gYSBmdXR1cmUgdmVyc2lvbi4lcycsIGtleSwgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga25vd25LZXlzO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5BcnJheShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkcmVuLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoaXMgYWxnb3JpdGhtIGNhbid0IG9wdGltaXplIGJ5IHNlYXJjaGluZyBmcm9tIGJvdGhzIGVuZHMgc2luY2Ugd2VcbiAgICAvLyBkb24ndCBoYXZlIGJhY2twb2ludGVycyBvbiBmaWJlcnMuIEknbSB0cnlpbmcgdG8gc2VlIGhvdyBmYXIgd2UgY2FuIGdldFxuICAgIC8vIHdpdGggdGhhdCBtb2RlbC4gSWYgaXQgZW5kcyB1cCBub3QgYmVpbmcgd29ydGggdGhlIHRyYWRlb2Zmcywgd2UgY2FuXG4gICAgLy8gYWRkIGl0IGxhdGVyLlxuXG4gICAgLy8gRXZlbiB3aXRoIGEgdHdvIGVuZGVkIG9wdGltaXphdGlvbiwgd2UnZCB3YW50IHRvIG9wdGltaXplIGZvciB0aGUgY2FzZVxuICAgIC8vIHdoZXJlIHRoZXJlIGFyZSBmZXcgY2hhbmdlcyBhbmQgYnJ1dGUgZm9yY2UgdGhlIGNvbXBhcmlzb24gaW5zdGVhZCBvZlxuICAgIC8vIGdvaW5nIGZvciB0aGUgTWFwLiBJdCdkIGxpa2UgdG8gZXhwbG9yZSBoaXR0aW5nIHRoYXQgcGF0aCBmaXJzdCBpblxuICAgIC8vIGZvcndhcmQtb25seSBtb2RlIGFuZCBvbmx5IGdvIGZvciB0aGUgTWFwIG9uY2Ugd2Ugbm90aWNlIHRoYXQgd2UgbmVlZFxuICAgIC8vIGxvdHMgb2YgbG9vayBhaGVhZC4gVGhpcyBkb2Vzbid0IGhhbmRsZSByZXZlcnNhbCBhcyB3ZWxsIGFzIHR3byBlbmRlZFxuICAgIC8vIHNlYXJjaCBidXQgdGhhdCdzIHVudXN1YWwuIEJlc2lkZXMsIGZvciB0aGUgdHdvIGVuZGVkIG9wdGltaXphdGlvbiB0b1xuICAgIC8vIHdvcmsgb24gSXRlcmFibGVzLCB3ZSdkIG5lZWQgdG8gY29weSB0aGUgd2hvbGUgc2V0LlxuXG4gICAgLy8gSW4gdGhpcyBmaXJzdCBpdGVyYXRpb24sIHdlJ2xsIGp1c3QgbGl2ZSB3aXRoIGhpdHRpbmcgdGhlIGJhZCBjYXNlXG4gICAgLy8gKGFkZGluZyBldmVyeXRoaW5nIHRvIGEgTWFwKSBpbiBmb3IgZXZlcnkgaW5zZXJ0L21vdmUuXG5cbiAgICAvLyBJZiB5b3UgY2hhbmdlIHRoaXMgY29kZSwgYWxzbyB1cGRhdGUgcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcigpIHdoaWNoXG4gICAgLy8gdXNlcyB0aGUgc2FtZSBhbGdvcml0aG0uXG5cbiAgICB7XG4gICAgICAvLyBGaXJzdCwgdmFsaWRhdGUga2V5cy5cbiAgICAgIHZhciBrbm93bktleXMgPSBudWxsO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBuZXdDaGlsZHJlbltpXTtcbiAgICAgICAga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShjaGlsZCwga25vd25LZXlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzTmV3RmliZXIgPSBudWxsO1xuXG4gICAgdmFyIG9sZEZpYmVyID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgdmFyIGxhc3RQbGFjZWRJbmRleCA9IDA7XG4gICAgdmFyIG5ld0lkeCA9IDA7XG4gICAgdmFyIG5leHRPbGRGaWJlciA9IG51bGw7XG4gICAgZm9yICg7IG9sZEZpYmVyICE9PSBudWxsICYmIG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgIGlmIChvbGRGaWJlci5pbmRleCA+IG5ld0lkeCkge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlcjtcbiAgICAgICAgb2xkRmliZXIgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXIuc2libGluZztcbiAgICAgIH1cbiAgICAgIHZhciBuZXdGaWJlciA9IHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZHJlbltuZXdJZHhdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAobmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBicmVha3Mgb24gZW1wdHkgc2xvdHMgbGlrZSBudWxsIGNoaWxkcmVuLiBUaGF0J3NcbiAgICAgICAgLy8gdW5mb3J0dW5hdGUgYmVjYXVzZSBpdCB0cmlnZ2VycyB0aGUgc2xvdyBwYXRoIGFsbCB0aGUgdGltZS4gV2UgbmVlZFxuICAgICAgICAvLyBhIGJldHRlciB3YXkgdG8gY29tbXVuaWNhdGUgd2hldGhlciB0aGlzIHdhcyBhIG1pc3Mgb3IgbnVsbCxcbiAgICAgICAgLy8gYm9vbGVhbiwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgaWYgKG9sZEZpYmVyICYmIG5ld0ZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIHNsb3QsIGJ1dCB3ZSBkaWRuJ3QgcmV1c2UgdGhlIGV4aXN0aW5nIGZpYmVyLCBzbyB3ZVxuICAgICAgICAgIC8vIG5lZWQgdG8gZGVsZXRlIHRoZSBleGlzdGluZyBjaGlsZC5cbiAgICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXdGaWJlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IERlZmVyIHNpYmxpbmdzIGlmIHdlJ3JlIG5vdCBhdCB0aGUgcmlnaHQgaW5kZXggZm9yIHRoaXMgc2xvdC5cbiAgICAgICAgLy8gSS5lLiBpZiB3ZSBoYWQgbnVsbCB2YWx1ZXMgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gZGVmZXIgdGhpc1xuICAgICAgICAvLyBmb3IgZWFjaCBudWxsIHZhbHVlLiBIb3dldmVyLCB3ZSBhbHNvIGRvbid0IHdhbnQgdG8gY2FsbCB1cGRhdGVTbG90XG4gICAgICAgIC8vIHdpdGggdGhlIHByZXZpb3VzIG9uZS5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV3RmliZXI7XG4gICAgICB9XG4gICAgICBwcmV2aW91c05ld0ZpYmVyID0gbmV3RmliZXI7XG4gICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICB9XG5cbiAgICBpZiAobmV3SWR4ID09PSBuZXdDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbmV3IGNoaWxkcmVuLiBXZSBjYW4gZGVsZXRlIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBleGlzdGluZyBjaGlsZHJlbiB3ZSBjYW4gY2hvb3NlIGEgZmFzdCBwYXRoXG4gICAgICAvLyBzaW5jZSB0aGUgcmVzdCB3aWxsIGFsbCBiZSBpbnNlcnRpb25zLlxuICAgICAgZm9yICg7IG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgICAgdmFyIF9uZXdGaWJlciA9IGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZHJlbltuZXdJZHhdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGlmICghX25ld0ZpYmVyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIC8vIEFkZCBhbGwgY2hpbGRyZW4gdG8gYSBrZXkgbWFwIGZvciBxdWljayBsb29rdXBzLlxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcblxuICAgIC8vIEtlZXAgc2Nhbm5pbmcgYW5kIHVzZSB0aGUgbWFwIHRvIHJlc3RvcmUgZGVsZXRlZCBpdGVtcyBhcyBtb3Zlcy5cbiAgICBmb3IgKDsgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBuZXdJZHgrKykge1xuICAgICAgdmFyIF9uZXdGaWJlcjIgPSB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIG5ld0NoaWxkcmVuW25ld0lkeF0sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChfbmV3RmliZXIyKSB7XG4gICAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgICAgaWYgKF9uZXdGaWJlcjIuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV3IGZpYmVyIGlzIGEgd29yayBpbiBwcm9ncmVzcywgYnV0IGlmIHRoZXJlIGV4aXN0cyBhXG4gICAgICAgICAgICAvLyBjdXJyZW50LCB0aGF0IG1lYW5zIHRoYXQgd2UgcmV1c2VkIHRoZSBmaWJlci4gV2UgbmVlZCB0byBkZWxldGVcbiAgICAgICAgICAgIC8vIGl0IGZyb20gdGhlIGNoaWxkIGxpc3Qgc28gdGhhdCB3ZSBkb24ndCBhZGQgaXQgdG8gdGhlIGRlbGV0aW9uXG4gICAgICAgICAgICAvLyBsaXN0LlxuICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlblsnZGVsZXRlJ10oX25ld0ZpYmVyMi5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBfbmV3RmliZXIyLmtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyMiwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXIyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjI7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIEFueSBleGlzdGluZyBjaGlsZHJlbiB0aGF0IHdlcmVuJ3QgY29uc3VtZWQgYWJvdmUgd2VyZSBkZWxldGVkLiBXZSBuZWVkXG4gICAgICAvLyB0byBhZGQgdGhlbSB0byB0aGUgZGVsZXRpb24gbGlzdC5cbiAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZHJlbkl0ZXJhYmxlLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoaXMgaXMgdGhlIHNhbWUgaW1wbGVtZW50YXRpb24gYXMgcmVjb25jaWxlQ2hpbGRyZW5BcnJheSgpLFxuICAgIC8vIGJ1dCB1c2luZyB0aGUgaXRlcmF0b3IgaW5zdGVhZC5cblxuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcbiAgICAhKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSA/IGludmFyaWFudChmYWxzZSwgJ0FuIG9iamVjdCBpcyBub3QgYW4gaXRlcmFibGUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgICB7XG4gICAgICAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGRyZW5JdGVyYWJsZS5lbnRyaWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBwb3NzaWJsZU1hcCA9IG5ld0NoaWxkcmVuSXRlcmFibGU7XG4gICAgICAgIGlmIChwb3NzaWJsZU1hcC5lbnRyaWVzID09PSBpdGVyYXRvckZuKSB7XG4gICAgICAgICAgd2FybmluZyhkaWRXYXJuQWJvdXRNYXBzLCAnVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgJyArICd1bmV4cGVjdGVkIHJlc3VsdHMuIENvbnZlcnQgaXQgdG8gYSBzZXF1ZW5jZS9pdGVyYWJsZSBvZiBrZXllZCAnICsgJ1JlYWN0RWxlbWVudHMgaW5zdGVhZC4lcycsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMSgpKTtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBGaXJzdCwgdmFsaWRhdGUga2V5cy5cbiAgICAgIC8vIFdlJ2xsIGdldCBhIGRpZmZlcmVudCBpdGVyYXRvciBsYXRlciBmb3IgdGhlIG1haW4gcGFzcy5cbiAgICAgIHZhciBfbmV3Q2hpbGRyZW4gPSBpdGVyYXRvckZuLmNhbGwobmV3Q2hpbGRyZW5JdGVyYWJsZSk7XG4gICAgICBpZiAoX25ld0NoaWxkcmVuKSB7XG4gICAgICAgIHZhciBrbm93bktleXMgPSBudWxsO1xuICAgICAgICB2YXIgX3N0ZXAgPSBfbmV3Q2hpbGRyZW4ubmV4dCgpO1xuICAgICAgICBmb3IgKDsgIV9zdGVwLmRvbmU7IF9zdGVwID0gX25ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgICAgIHZhciBjaGlsZCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbmV3Q2hpbGRyZW4gPSBpdGVyYXRvckZuLmNhbGwobmV3Q2hpbGRyZW5JdGVyYWJsZSk7XG4gICAgIShuZXdDaGlsZHJlbiAhPSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0FuIGl0ZXJhYmxlIG9iamVjdCBwcm92aWRlZCBubyBpdGVyYXRvci4nKSA6IHZvaWQgMDtcblxuICAgIHZhciByZXN1bHRpbmdGaXJzdENoaWxkID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXNOZXdGaWJlciA9IG51bGw7XG5cbiAgICB2YXIgb2xkRmliZXIgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB2YXIgbGFzdFBsYWNlZEluZGV4ID0gMDtcbiAgICB2YXIgbmV3SWR4ID0gMDtcbiAgICB2YXIgbmV4dE9sZEZpYmVyID0gbnVsbDtcblxuICAgIHZhciBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpO1xuICAgIGZvciAoOyBvbGRGaWJlciAhPT0gbnVsbCAmJiAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgaWYgKG9sZEZpYmVyLmluZGV4ID4gbmV3SWR4KSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyO1xuICAgICAgICBvbGRGaWJlciA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlci5zaWJsaW5nO1xuICAgICAgfVxuICAgICAgdmFyIG5ld0ZpYmVyID0gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIHN0ZXAudmFsdWUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChuZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGJyZWFrcyBvbiBlbXB0eSBzbG90cyBsaWtlIG51bGwgY2hpbGRyZW4uIFRoYXQnc1xuICAgICAgICAvLyB1bmZvcnR1bmF0ZSBiZWNhdXNlIGl0IHRyaWdnZXJzIHRoZSBzbG93IHBhdGggYWxsIHRoZSB0aW1lLiBXZSBuZWVkXG4gICAgICAgIC8vIGEgYmV0dGVyIHdheSB0byBjb21tdW5pY2F0ZSB3aGV0aGVyIHRoaXMgd2FzIGEgbWlzcyBvciBudWxsLFxuICAgICAgICAvLyBib29sZWFuLCB1bmRlZmluZWQsIGV0Yy5cbiAgICAgICAgaWYgKCFvbGRGaWJlcikge1xuICAgICAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgaWYgKG9sZEZpYmVyICYmIG5ld0ZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIHNsb3QsIGJ1dCB3ZSBkaWRuJ3QgcmV1c2UgdGhlIGV4aXN0aW5nIGZpYmVyLCBzbyB3ZVxuICAgICAgICAgIC8vIG5lZWQgdG8gZGVsZXRlIHRoZSBleGlzdGluZyBjaGlsZC5cbiAgICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXdGaWJlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IERlZmVyIHNpYmxpbmdzIGlmIHdlJ3JlIG5vdCBhdCB0aGUgcmlnaHQgaW5kZXggZm9yIHRoaXMgc2xvdC5cbiAgICAgICAgLy8gSS5lLiBpZiB3ZSBoYWQgbnVsbCB2YWx1ZXMgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gZGVmZXIgdGhpc1xuICAgICAgICAvLyBmb3IgZWFjaCBudWxsIHZhbHVlLiBIb3dldmVyLCB3ZSBhbHNvIGRvbid0IHdhbnQgdG8gY2FsbCB1cGRhdGVTbG90XG4gICAgICAgIC8vIHdpdGggdGhlIHByZXZpb3VzIG9uZS5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV3RmliZXI7XG4gICAgICB9XG4gICAgICBwcmV2aW91c05ld0ZpYmVyID0gbmV3RmliZXI7XG4gICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICB9XG5cbiAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIG5ldyBjaGlsZHJlbi4gV2UgY2FuIGRlbGV0ZSB0aGUgcmVzdC5cbiAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgZXhpc3RpbmcgY2hpbGRyZW4gd2UgY2FuIGNob29zZSBhIGZhc3QgcGF0aFxuICAgICAgLy8gc2luY2UgdGhlIHJlc3Qgd2lsbCBhbGwgYmUgaW5zZXJ0aW9ucy5cbiAgICAgIGZvciAoOyAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgICB2YXIgX25ld0ZpYmVyMyA9IGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBzdGVwLnZhbHVlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGlmIChfbmV3RmliZXIzID09PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIzLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXIzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjM7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjM7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICAvLyBBZGQgYWxsIGNoaWxkcmVuIHRvIGEga2V5IG1hcCBmb3IgcXVpY2sgbG9va3Vwcy5cbiAgICB2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG1hcFJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG5cbiAgICAvLyBLZWVwIHNjYW5uaW5nIGFuZCB1c2UgdGhlIG1hcCB0byByZXN0b3JlIGRlbGV0ZWQgaXRlbXMgYXMgbW92ZXMuXG4gICAgZm9yICg7ICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICB2YXIgX25ld0ZpYmVyNCA9IHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgc3RlcC52YWx1ZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKF9uZXdGaWJlcjQgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgICBpZiAoX25ld0ZpYmVyNC5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRoZSBuZXcgZmliZXIgaXMgYSB3b3JrIGluIHByb2dyZXNzLCBidXQgaWYgdGhlcmUgZXhpc3RzIGFcbiAgICAgICAgICAgIC8vIGN1cnJlbnQsIHRoYXQgbWVhbnMgdGhhdCB3ZSByZXVzZWQgdGhlIGZpYmVyLiBXZSBuZWVkIHRvIGRlbGV0ZVxuICAgICAgICAgICAgLy8gaXQgZnJvbSB0aGUgY2hpbGQgbGlzdCBzbyB0aGF0IHdlIGRvbid0IGFkZCBpdCB0byB0aGUgZGVsZXRpb25cbiAgICAgICAgICAgIC8vIGxpc3QuXG4gICAgICAgICAgICBleGlzdGluZ0NoaWxkcmVuWydkZWxldGUnXShfbmV3RmliZXI0LmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IF9uZXdGaWJlcjQua2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXI0LCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyNDtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gX25ld0ZpYmVyNDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gQW55IGV4aXN0aW5nIGNoaWxkcmVuIHRoYXQgd2VyZW4ndCBjb25zdW1lZCBhYm92ZSB3ZXJlIGRlbGV0ZWQuIFdlIG5lZWRcbiAgICAgIC8vIHRvIGFkZCB0aGVtIHRvIHRoZSBkZWxldGlvbiBsaXN0LlxuICAgICAgZXhpc3RpbmdDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gY2hlY2sgZm9yIGtleXMgb24gdGV4dCBub2RlcyBzaW5jZSB3ZSBkb24ndCBoYXZlIGFcbiAgICAvLyB3YXkgdG8gZGVmaW5lIHRoZW0uXG4gICAgaWYgKGN1cnJlbnRGaXJzdENoaWxkICE9PSBudWxsICYmIGN1cnJlbnRGaXJzdENoaWxkLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIC8vIFdlIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBub2RlIHNvIGxldCdzIGp1c3QgdXBkYXRlIGl0IGFuZCBkZWxldGVcbiAgICAgIC8vIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmcpO1xuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudEZpcnN0Q2hpbGQsIHRleHRDb250ZW50LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gICAgLy8gVGhlIGV4aXN0aW5nIGZpcnN0IGNoaWxkIGlzIG5vdCBhIHRleHQgbm9kZSBzbyB3ZSBuZWVkIHRvIGNyZWF0ZSBvbmVcbiAgICAvLyBhbmQgZGVsZXRlIHRoZSBleGlzdGluZyBvbmVzLlxuICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCk7XG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KHRleHRDb250ZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIGVsZW1lbnQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETzogSWYga2V5ID09PSBudWxsIGFuZCBjaGlsZC5rZXkgPT09IG51bGwsIHRoZW4gdGhpcyBvbmx5IGFwcGxpZXMgdG9cbiAgICAgIC8vIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIGlmIChjaGlsZC50YWcgPT09IEZyYWdtZW50ID8gZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIDogY2hpbGQudHlwZSA9PT0gZWxlbWVudC50eXBlKSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgPyBlbGVtZW50LnByb3BzLmNoaWxkcmVuIDogZWxlbWVudC5wcm9wcywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIGV4aXN0aW5nLnJlZiA9IGNvZXJjZVJlZihjaGlsZCwgZWxlbWVudCk7XG4gICAgICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAge1xuICAgICAgICAgICAgZXhpc3RpbmcuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgICAgICAgICAgZXhpc3RpbmcuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChlbGVtZW50LnByb3BzLmNoaWxkcmVuLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBlbGVtZW50LmtleSk7XG4gICAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfY3JlYXRlZDcgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgX2NyZWF0ZWQ3LnJlZiA9IGNvZXJjZVJlZihjdXJyZW50Rmlyc3RDaGlsZCwgZWxlbWVudCk7XG4gICAgICBfY3JlYXRlZDdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gX2NyZWF0ZWQ3O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZUNhbGwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBjYWxsLCBleHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBrZXkgPSBjYWxsLmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4gICAgICAvLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICBpZiAoY2hpbGQudGFnID09PSBDYWxsQ29tcG9uZW50KSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBjYWxsLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21DYWxsKGNhbGwsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgcmV0dXJuIGNyZWF0ZWQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVSZXR1cm4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCByZXR1cm5Ob2RlLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBjaGVjayBmb3Iga2V5cyBvbiB5aWVsZHMgc2luY2UgdGhleSdyZSBzdGF0ZWxlc3MuXG4gICAgdmFyIGNoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBpZiAoY2hpbGQudGFnID09PSBSZXR1cm5Db21wb25lbnQpIHtcbiAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgbnVsbCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBleGlzdGluZy50eXBlID0gcmV0dXJuTm9kZS52YWx1ZTtcbiAgICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21SZXR1cm4ocmV0dXJuTm9kZSwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgY3JlYXRlZC50eXBlID0gcmV0dXJuTm9kZS52YWx1ZTtcbiAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgcG9ydGFsLCBleHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBrZXkgPSBwb3J0YWwua2V5O1xuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETzogSWYga2V5ID09PSBudWxsIGFuZCBjaGlsZC5rZXkgPT09IG51bGwsIHRoZW4gdGhpcyBvbmx5IGFwcGxpZXMgdG9cbiAgICAgIC8vIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIGlmIChjaGlsZC50YWcgPT09IEhvc3RQb3J0YWwgJiYgY2hpbGQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gPT09IHBvcnRhbC5jb250YWluZXJJbmZvICYmIGNoaWxkLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiA9PT0gcG9ydGFsLmltcGxlbWVudGF0aW9uKSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBwb3J0YWwuY2hpbGRyZW4gfHwgW10sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG5cbiAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgcmV0dXJuIGNyZWF0ZWQ7XG4gIH1cblxuICAvLyBUaGlzIEFQSSB3aWxsIHRhZyB0aGUgY2hpbGRyZW4gd2l0aCB0aGUgc2lkZS1lZmZlY3Qgb2YgdGhlIHJlY29uY2lsaWF0aW9uXG4gIC8vIGl0c2VsZi4gVGhleSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBzaWRlLWVmZmVjdCBsaXN0IGFzIHdlIHBhc3MgdGhyb3VnaCB0aGVcbiAgLy8gY2hpbGRyZW4gYW5kIHRoZSBwYXJlbnQuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkRmliZXJzKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBub3QgcmVjdXJzaXZlLlxuICAgIC8vIElmIHRoZSB0b3AgbGV2ZWwgaXRlbSBpcyBhbiBhcnJheSwgd2UgdHJlYXQgaXQgYXMgYSBzZXQgb2YgY2hpbGRyZW4sXG4gICAgLy8gbm90IGFzIGEgZnJhZ21lbnQuIE5lc3RlZCBhcnJheXMgb24gdGhlIG90aGVyIGhhbmQgd2lsbCBiZSB0cmVhdGVkIGFzXG4gICAgLy8gZnJhZ21lbnQgbm9kZXMuIFJlY3Vyc2lvbiBoYXBwZW5zIGF0IHRoZSBub3JtYWwgZmxvdy5cblxuICAgIC8vIEhhbmRsZSB0b3AgbGV2ZWwgdW5rZXllZCBmcmFnbWVudHMgYXMgaWYgdGhleSB3ZXJlIGFycmF5cy5cbiAgICAvLyBUaGlzIGxlYWRzIHRvIGFuIGFtYmlndWl0eSBiZXR3ZWVuIDw+e1suLi5dfTwvPiBhbmQgPD4uLi48Lz4uXG4gICAgLy8gV2UgdHJlYXQgdGhlIGFtYmlndW91cyBjYXNlcyBhYm92ZSB0aGUgc2FtZS5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCAmJiBuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFICYmIG5ld0NoaWxkLmtleSA9PT0gbnVsbCkge1xuICAgICAgbmV3Q2hpbGQgPSBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbjtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgb2JqZWN0IHR5cGVzXG4gICAgdmFyIGlzT2JqZWN0ID0gdHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbDtcblxuICAgIGlmIChpc09iamVjdCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVFbGVtZW50KHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSk7XG5cbiAgICAgICAgY2FzZSBSRUFDVF9DQUxMX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlQ2FsbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkpO1xuICAgICAgICBjYXNlIFJFQUNUX1JFVFVSTl9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZVJldHVybihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkpO1xuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgJycgKyBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheSQxKG5ld0NoaWxkKSkge1xuICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIGlmIChnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIGlmIChpc09iamVjdCkge1xuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIElmIHRoZSBuZXcgY2hpbGQgaXMgdW5kZWZpbmVkLCBhbmQgdGhlIHJldHVybiBmaWJlciBpcyBhIGNvbXBvc2l0ZVxuICAgICAgLy8gY29tcG9uZW50LCB0aHJvdyBhbiBlcnJvci4gSWYgRmliZXIgcmV0dXJuIHR5cGVzIGFyZSBkaXNhYmxlZCxcbiAgICAgIC8vIHdlIGFscmVhZHkgdGhyZXcgYWJvdmUuXG4gICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UucmVuZGVyLl9pc01vY2tGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIFdlIGFsbG93IGF1dG8tbW9ja3MgdG8gcHJvY2VlZCBhcyBpZiB0aGV5J3JlIHJldHVybmluZyBudWxsLlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAvLyBJbnRlbnRpb25hbGx5IGZhbGwgdGhyb3VnaCB0byB0aGUgbmV4dCBjYXNlLCB3aGljaCBoYW5kbGVzIGJvdGhcbiAgICAgICAgLy8gZnVuY3Rpb25zIGFuZCBjbGFzc2VzXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZWQgbm8tZmFsbHRocm91Z2hcbiAgICAgICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBDb21wb25lbnQgPSByZXR1cm5GaWJlci50eXBlO1xuICAgICAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnJXMoLi4uKTogTm90aGluZyB3YXMgcmV0dXJuZWQgZnJvbSByZW5kZXIuIFRoaXMgdXN1YWxseSBtZWFucyBhIHJldHVybiBzdGF0ZW1lbnQgaXMgbWlzc2luZy4gT3IsIHRvIHJlbmRlciBub3RoaW5nLCByZXR1cm4gbnVsbC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZW1haW5pbmcgY2FzZXMgYXJlIGFsbCB0cmVhdGVkIGFzIGVtcHR5LlxuICAgIHJldHVybiBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgcmV0dXJuIHJlY29uY2lsZUNoaWxkRmliZXJzO1xufVxuXG52YXIgcmVjb25jaWxlQ2hpbGRGaWJlcnMgPSBDaGlsZFJlY29uY2lsZXIodHJ1ZSk7XG52YXIgbW91bnRDaGlsZEZpYmVycyA9IENoaWxkUmVjb25jaWxlcihmYWxzZSk7XG5cbmZ1bmN0aW9uIGNsb25lQ2hpbGRGaWJlcnMoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgIShjdXJyZW50ID09PSBudWxsIHx8IHdvcmtJblByb2dyZXNzLmNoaWxkID09PSBjdXJyZW50LmNoaWxkKSA/IGludmFyaWFudChmYWxzZSwgJ1Jlc3VtaW5nIHdvcmsgbm90IHlldCBpbXBsZW1lbnRlZC4nKSA6IHZvaWQgMDtcblxuICBpZiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY3VycmVudENoaWxkID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIHZhciBuZXdDaGlsZCA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCwgY3VycmVudENoaWxkLnBlbmRpbmdQcm9wcywgY3VycmVudENoaWxkLmV4cGlyYXRpb25UaW1lKTtcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBuZXdDaGlsZDtcblxuICBuZXdDaGlsZFsncmV0dXJuJ10gPSB3b3JrSW5Qcm9ncmVzcztcbiAgd2hpbGUgKGN1cnJlbnRDaGlsZC5zaWJsaW5nICE9PSBudWxsKSB7XG4gICAgY3VycmVudENoaWxkID0gY3VycmVudENoaWxkLnNpYmxpbmc7XG4gICAgbmV3Q2hpbGQgPSBuZXdDaGlsZC5zaWJsaW5nID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudENoaWxkLCBjdXJyZW50Q2hpbGQucGVuZGluZ1Byb3BzLCBjdXJyZW50Q2hpbGQuZXhwaXJhdGlvblRpbWUpO1xuICAgIG5ld0NoaWxkWydyZXR1cm4nXSA9IHdvcmtJblByb2dyZXNzO1xuICB9XG4gIG5ld0NoaWxkLnNpYmxpbmcgPSBudWxsO1xufVxuXG57XG4gIHZhciB3YXJuZWRBYm91dFN0YXRlbGVzc1JlZnMgPSB7fTtcbn1cblxudmFyIFJlYWN0RmliZXJCZWdpbldvcmsgPSBmdW5jdGlvbiAoY29uZmlnLCBob3N0Q29udGV4dCwgaHlkcmF0aW9uQ29udGV4dCwgc2NoZWR1bGVXb3JrLCBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKSB7XG4gIHZhciBzaG91bGRTZXRUZXh0Q29udGVudCA9IGNvbmZpZy5zaG91bGRTZXRUZXh0Q29udGVudCxcbiAgICAgIHVzZVN5bmNTY2hlZHVsaW5nID0gY29uZmlnLnVzZVN5bmNTY2hlZHVsaW5nLFxuICAgICAgc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZSA9IGNvbmZpZy5zaG91bGREZXByaW9yaXRpemVTdWJ0cmVlO1xuICB2YXIgcHVzaEhvc3RDb250ZXh0ID0gaG9zdENvbnRleHQucHVzaEhvc3RDb250ZXh0LFxuICAgICAgcHVzaEhvc3RDb250YWluZXIgPSBob3N0Q29udGV4dC5wdXNoSG9zdENvbnRhaW5lcjtcbiAgdmFyIGVudGVySHlkcmF0aW9uU3RhdGUgPSBoeWRyYXRpb25Db250ZXh0LmVudGVySHlkcmF0aW9uU3RhdGUsXG4gICAgICByZXNldEh5ZHJhdGlvblN0YXRlID0gaHlkcmF0aW9uQ29udGV4dC5yZXNldEh5ZHJhdGlvblN0YXRlLFxuICAgICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBoeWRyYXRpb25Db250ZXh0LnRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlO1xuXG4gIHZhciBfUmVhY3RGaWJlckNsYXNzQ29tcG8gPSBSZWFjdEZpYmVyQ2xhc3NDb21wb25lbnQoc2NoZWR1bGVXb3JrLCBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyLCBtZW1vaXplUHJvcHMsIG1lbW9pemVTdGF0ZSksXG4gICAgICBhZG9wdENsYXNzSW5zdGFuY2UgPSBfUmVhY3RGaWJlckNsYXNzQ29tcG8uYWRvcHRDbGFzc0luc3RhbmNlLFxuICAgICAgY29uc3RydWN0Q2xhc3NJbnN0YW5jZSA9IF9SZWFjdEZpYmVyQ2xhc3NDb21wby5jb25zdHJ1Y3RDbGFzc0luc3RhbmNlLFxuICAgICAgbW91bnRDbGFzc0luc3RhbmNlID0gX1JlYWN0RmliZXJDbGFzc0NvbXBvLm1vdW50Q2xhc3NJbnN0YW5jZSxcbiAgICAgIHVwZGF0ZUNsYXNzSW5zdGFuY2UgPSBfUmVhY3RGaWJlckNsYXNzQ29tcG8udXBkYXRlQ2xhc3NJbnN0YW5jZTtcblxuICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBhbmQgdXNlIHJlY29uY2lsZUNoaWxkcmVuQXRFeHBpcmF0aW9uVGltZSBkaXJlY3RseS5cblxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pIHtcbiAgICByZWNvbmNpbGVDaGlsZHJlbkF0RXhwaXJhdGlvblRpbWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBmcmVzaCBuZXcgY29tcG9uZW50IHRoYXQgaGFzbid0IGJlZW4gcmVuZGVyZWQgeWV0LCB3ZVxuICAgICAgLy8gd29uJ3QgdXBkYXRlIGl0cyBjaGlsZCBzZXQgYnkgYXBwbHlpbmcgbWluaW1hbCBzaWRlLWVmZmVjdHMuIEluc3RlYWQsXG4gICAgICAvLyB3ZSB3aWxsIGFkZCB0aGVtIGFsbCB0byB0aGUgY2hpbGQgYmVmb3JlIGl0IGdldHMgcmVuZGVyZWQuIFRoYXQgbWVhbnNcbiAgICAgIC8vIHdlIGNhbiBvcHRpbWl6ZSB0aGlzIHJlY29uY2lsaWF0aW9uIHBhc3MgYnkgbm90IHRyYWNraW5nIHNpZGUtZWZmZWN0cy5cbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbW91bnRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZSBjdXJyZW50IGNoaWxkIGlzIHRoZSBzYW1lIGFzIHRoZSB3b3JrIGluIHByb2dyZXNzLCBpdCBtZWFucyB0aGF0XG4gICAgICAvLyB3ZSBoYXZlbid0IHlldCBzdGFydGVkIGFueSB3b3JrIG9uIHRoZXNlIGNoaWxkcmVuLiBUaGVyZWZvcmUsIHdlIHVzZVxuICAgICAgLy8gdGhlIGNsb25lIGFsZ29yaXRobSB0byBjcmVhdGUgYSBjb3B5IG9mIGFsbCB0aGUgY3VycmVudCBjaGlsZHJlbi5cblxuICAgICAgLy8gSWYgd2UgaGFkIGFueSBwcm9ncmVzc2VkIHdvcmsgYWxyZWFkeSwgdGhhdCBpcyBpbnZhbGlkIGF0IHRoaXMgcG9pbnQgc29cbiAgICAgIC8vIGxldCdzIHRocm93IGl0IG91dC5cbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQuY2hpbGQsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgICAgaWYgKG5leHRDaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgICAgICBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dENoaWxkcmVuID09PSBudWxsIHx8IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPT09IG5leHRDaGlsZHJlbikge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciByZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gICAgaWYgKHJlZiAhPT0gbnVsbCAmJiAoIWN1cnJlbnQgfHwgY3VycmVudC5yZWYgIT09IHJlZikpIHtcbiAgICAgIC8vIFNjaGVkdWxlIGEgUmVmIGVmZmVjdFxuICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFJlZjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGdW5jdGlvbmFsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgdmFyIGZuID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuXG4gICAgdmFyIG1lbW9pemVkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgIGlmIChoYXNDb250ZXh0Q2hhbmdlZCgpKSB7XG4gICAgICAvLyBOb3JtYWxseSB3ZSBjYW4gYmFpbCBvdXQgb24gcHJvcHMgZXF1YWxpdHkgYnV0IGlmIGNvbnRleHQgaGFzIGNoYW5nZWRcbiAgICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gICAgICBpZiAobmV4dFByb3BzID09PSBudWxsKSB7XG4gICAgICAgIG5leHRQcm9wcyA9IG1lbW9pemVkUHJvcHM7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuZXh0UHJvcHMgPT09IG51bGwgfHwgbWVtb2l6ZWRQcm9wcyA9PT0gbmV4dFByb3BzKSB7XG4gICAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cbiAgICAgIC8vIFRPRE86IGNvbnNpZGVyIGJyaW5naW5nIGZuLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpIGJhY2suXG4gICAgICAvLyBJdCB1c2VkIHRvIGJlIGhlcmUuXG4gICAgfVxuXG4gICAgdmFyIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIGNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuXG4gICAgdmFyIG5leHRDaGlsZHJlbjtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudFBoYXNlKCdyZW5kZXInKTtcbiAgICAgIG5leHRDaGlsZHJlbiA9IGZuKG5leHRQcm9wcywgY29udGV4dCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZShudWxsKTtcbiAgICB9XG4gICAgLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQZXJmb3JtZWRXb3JrO1xuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuICAgIC8vIER1cmluZyBtb3VudGluZyB3ZSBkb24ndCBrbm93IHRoZSBjaGlsZCBjb250ZXh0IHlldCBhcyB0aGUgaW5zdGFuY2UgZG9lc24ndCBleGlzdC5cbiAgICAvLyBXZSB3aWxsIGludmFsaWRhdGUgdGhlIGNoaWxkIGNvbnRleHQgaW4gZmluaXNoQ2xhc3NDb21wb25lbnQoKSByaWdodCBhZnRlciByZW5kZXJpbmcuXG4gICAgdmFyIGhhc0NvbnRleHQgPSBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcblxuICAgIHZhciBzaG91bGRVcGRhdGUgPSB2b2lkIDA7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIGlmICghd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlKSB7XG4gICAgICAgIC8vIEluIHRoZSBpbml0aWFsIHBhc3Mgd2UgbWlnaHQgbmVlZCB0byBjb25zdHJ1Y3QgdGhlIGluc3RhbmNlLlxuICAgICAgICBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMpO1xuICAgICAgICBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgc2hvdWxkVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ1Jlc3VtaW5nIHdvcmsgbm90IHlldCBpbXBsZW1lbnRlZC4nKTtcbiAgICAgICAgLy8gSW4gYSByZXN1bWUsIHdlJ2xsIGFscmVhZHkgaGF2ZSBhbiBpbnN0YW5jZSB3ZSBjYW4gcmV1c2UuXG4gICAgICAgIC8vIHNob3VsZFVwZGF0ZSA9IHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzaG91bGRVcGRhdGUgPSB1cGRhdGVDbGFzc0luc3RhbmNlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfVxuICAgIHJldHVybiBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgc2hvdWxkVXBkYXRlLCBoYXNDb250ZXh0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmlzaENsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBzaG91bGRVcGRhdGUsIGhhc0NvbnRleHQpIHtcbiAgICAvLyBSZWZzIHNob3VsZCB1cGRhdGUgZXZlbiBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZVxuICAgIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgaWYgKCFzaG91bGRVcGRhdGUpIHtcbiAgICAgIC8vIENvbnRleHQgcHJvdmlkZXJzIHNob3VsZCBkZWZlciB0byBzQ1UgZm9yIHJlbmRlcmluZ1xuICAgICAgaWYgKGhhc0NvbnRleHQpIHtcbiAgICAgICAgaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gICAgLy8gUmVyZW5kZXJcbiAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IHZvaWQgMDtcbiAgICB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZSgncmVuZGVyJyk7XG4gICAgICBuZXh0Q2hpbGRyZW4gPSBpbnN0YW5jZS5yZW5kZXIoKTtcbiAgICAgIGlmIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgaW5zdGFuY2UucmVuZGVyKCk7XG4gICAgICB9XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZShudWxsKTtcbiAgICB9XG4gICAgLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQZXJmb3JtZWRXb3JrO1xuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIC8vIE1lbW9pemUgcHJvcHMgYW5kIHN0YXRlIHVzaW5nIHRoZSB2YWx1ZXMgd2UganVzdCB1c2VkIHRvIHJlbmRlci5cbiAgICAvLyBUT0RPOiBSZXN0cnVjdHVyZSBzbyB3ZSBuZXZlciByZWFkIHZhbHVlcyBmcm9tIHRoZSBpbnN0YW5jZS5cbiAgICBtZW1vaXplU3RhdGUod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLnN0YXRlKTtcbiAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLnByb3BzKTtcblxuICAgIC8vIFRoZSBjb250ZXh0IG1pZ2h0IGhhdmUgY2hhbmdlZCBzbyB3ZSBuZWVkIHRvIHJlY2FsY3VsYXRlIGl0LlxuICAgIGlmIChoYXNDb250ZXh0KSB7XG4gICAgICBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCB0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKSB7XG4gICAgdmFyIHJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgaWYgKHJvb3QucGVuZGluZ0NvbnRleHQpIHtcbiAgICAgIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MsIHJvb3QucGVuZGluZ0NvbnRleHQsIHJvb3QucGVuZGluZ0NvbnRleHQgIT09IHJvb3QuY29udGV4dCk7XG4gICAgfSBlbHNlIGlmIChyb290LmNvbnRleHQpIHtcbiAgICAgIC8vIFNob3VsZCBhbHdheXMgYmUgc2V0XG4gICAgICBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzLCByb290LmNvbnRleHQsIGZhbHNlKTtcbiAgICB9XG4gICAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHJvb3QuY29udGFpbmVySW5mbyk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVIb3N0Um9vdChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmV2U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgdmFyIHN0YXRlID0gcHJvY2Vzc1VwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVRdWV1ZSwgbnVsbCwgbnVsbCwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKHByZXZTdGF0ZSA9PT0gc3RhdGUpIHtcbiAgICAgICAgLy8gSWYgdGhlIHN0YXRlIGlzIHRoZSBzYW1lIGFzIGJlZm9yZSwgdGhhdCdzIGEgYmFpbG91dCBiZWNhdXNlIHdlIGhhZFxuICAgICAgICAvLyBubyB3b3JrIHRoYXQgZXhwaXJlcyBhdCB0aGlzIHRpbWUuXG4gICAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuICAgICAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50O1xuICAgICAgdmFyIHJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICBpZiAoKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC5jaGlsZCA9PT0gbnVsbCkgJiYgcm9vdC5oeWRyYXRlICYmIGVudGVySHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IGN1cnJlbnQgY2hpbGRyZW4gdGhpcyBtaWdodCBiZSB0aGUgZmlyc3QgcGFzcy5cbiAgICAgICAgLy8gV2UgYWx3YXlzIHRyeSB0byBoeWRyYXRlLiBJZiB0aGlzIGlzbid0IGEgaHlkcmF0aW9uIHBhc3MgdGhlcmUgd29uJ3RcbiAgICAgICAgLy8gYmUgYW55IGNoaWxkcmVuIHRvIGh5ZHJhdGUgd2hpY2ggaXMgZWZmZWN0aXZlbHkgdGhlIHNhbWUgdGhpbmcgYXNcbiAgICAgICAgLy8gbm90IGh5ZHJhdGluZy5cblxuICAgICAgICAvLyBUaGlzIGlzIGEgYml0IG9mIGEgaGFjay4gV2UgdHJhY2sgdGhlIGhvc3Qgcm9vdCBhcyBhIHBsYWNlbWVudCB0b1xuICAgICAgICAvLyBrbm93IHRoYXQgd2UncmUgY3VycmVudGx5IGluIGEgbW91bnRpbmcgc3RhdGUuIFRoYXQgd2F5IGlzTW91bnRlZFxuICAgICAgICAvLyB3b3JrcyBhcyBleHBlY3RlZC4gV2UgbXVzdCByZXNldCB0aGlzIGJlZm9yZSBjb21taXR0aW5nLlxuICAgICAgICAvLyBUT0RPOiBEZWxldGUgdGhpcyB3aGVuIHdlIGRlbGV0ZSBpc01vdW50ZWQgYW5kIGZpbmRET01Ob2RlLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGxhY2VtZW50O1xuXG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IGNoaWxkcmVuIG1vdW50IGludG8gdGhpcyByb290IHdpdGhvdXQgdHJhY2tpbmdcbiAgICAgICAgLy8gc2lkZS1lZmZlY3RzLiBUaGlzIGVuc3VyZXMgdGhhdCB3ZSBkb24ndCBzdG9yZSBQbGFjZW1lbnQgZWZmZWN0cyBvblxuICAgICAgICAvLyBub2RlcyB0aGF0IHdpbGwgYmUgaHlkcmF0ZWQuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbW91bnRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgZWxlbWVudCwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlIHJlc2V0IGh5ZHJhdGlvbiBzdGF0ZSBpbiBjYXNlIHdlIGFib3J0ZWQgYW5kIHJlc3VtZWQgYW5vdGhlclxuICAgICAgICAvLyByb290LlxuICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBlbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIG1lbW9pemVTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgc3RhdGUpO1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIH1cbiAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gdXBkYXRlIHF1ZXVlLCB0aGF0J3MgYSBiYWlsb3V0IGJlY2F1c2UgdGhlIHJvb3QgaGFzIG5vIHByb3BzLlxuICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUhvc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgcHVzaEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcblxuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgIHZhciBtZW1vaXplZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmIChuZXh0UHJvcHMgPT09IG51bGwpIHtcbiAgICAgIG5leHRQcm9wcyA9IG1lbW9pemVkUHJvcHM7XG4gICAgICAhKG5leHRQcm9wcyAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdXZSBzaG91bGQgYWx3YXlzIGhhdmUgcGVuZGluZyBvciBjdXJyZW50IHByb3BzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIH1cbiAgICB2YXIgcHJldlByb3BzID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG51bGw7XG5cbiAgICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgIH0gZWxzZSBpZiAobmV4dFByb3BzID09PSBudWxsIHx8IG1lbW9pemVkUHJvcHMgPT09IG5leHRQcm9wcykge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gICAgdmFyIGlzRGlyZWN0VGV4dENoaWxkID0gc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgbmV4dFByb3BzKTtcblxuICAgIGlmIChpc0RpcmVjdFRleHRDaGlsZCkge1xuICAgICAgLy8gV2Ugc3BlY2lhbCBjYXNlIGEgZGlyZWN0IHRleHQgY2hpbGQgb2YgYSBob3N0IG5vZGUuIFRoaXMgaXMgYSBjb21tb25cbiAgICAgIC8vIGNhc2UuIFdlIHdvbid0IGhhbmRsZSBpdCBhcyBhIHJlaWZpZWQgY2hpbGQuIFdlIHdpbGwgaW5zdGVhZCBoYW5kbGVcbiAgICAgIC8vIHRoaXMgaW4gdGhlIGhvc3QgZW52aXJvbm1lbnQgdGhhdCBhbHNvIGhhdmUgYWNjZXNzIHRvIHRoaXMgcHJvcC4gVGhhdFxuICAgICAgLy8gYXZvaWRzIGFsbG9jYXRpbmcgYW5vdGhlciBIb3N0VGV4dCBmaWJlciBhbmQgdHJhdmVyc2luZyBpdC5cbiAgICAgIG5leHRDaGlsZHJlbiA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChwcmV2UHJvcHMgJiYgc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgcHJldlByb3BzKSkge1xuICAgICAgLy8gSWYgd2UncmUgc3dpdGNoaW5nIGZyb20gYSBkaXJlY3QgdGV4dCBjaGlsZCB0byBhIG5vcm1hbCBjaGlsZCwgb3IgdG9cbiAgICAgIC8vIGVtcHR5LCB3ZSBuZWVkIHRvIHNjaGVkdWxlIHRoZSB0ZXh0IGNvbnRlbnQgdG8gYmUgcmVzZXQuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gQ29udGVudFJlc2V0O1xuICAgIH1cblxuICAgIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgLy8gQ2hlY2sgdGhlIGhvc3QgY29uZmlnIHRvIHNlZSBpZiB0aGUgY2hpbGRyZW4gYXJlIG9mZnNjcmVlbi9oaWRkZW4uXG4gICAgaWYgKHJlbmRlckV4cGlyYXRpb25UaW1lICE9PSBOZXZlciAmJiAhdXNlU3luY1NjaGVkdWxpbmcgJiYgc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZSh0eXBlLCBuZXh0UHJvcHMpKSB7XG4gICAgICAvLyBEb3duLXByaW9yaXRpemUgdGhlIGNoaWxkcmVuLlxuICAgICAgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPSBOZXZlcjtcbiAgICAgIC8vIEJhaWxvdXQgYW5kIGNvbWUgYmFjayB0byB0aGlzIGZpYmVyIGxhdGVyLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMpO1xuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICBpZiAobmV4dFByb3BzID09PSBudWxsKSB7XG4gICAgICBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgIH1cbiAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcyk7XG4gICAgLy8gTm90aGluZyB0byBkbyBoZXJlLiBUaGlzIGlzIHRlcm1pbmFsLiBXZSdsbCBkbyB0aGUgY29tcGxldGlvbiBzdGVwXG4gICAgLy8gaW1tZWRpYXRlbHkgYWZ0ZXIuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBtb3VudEluZGV0ZXJtaW5hdGVDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgIShjdXJyZW50ID09PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0FuIGluZGV0ZXJtaW5hdGUgY29tcG9uZW50IHNob3VsZCBuZXZlciBoYXZlIG1vdW50ZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgdmFyIGZuID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgcHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgdmFyIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIGNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuXG4gICAgdmFyIHZhbHVlO1xuXG4gICAge1xuICAgICAgaWYgKGZuLnByb3RvdHlwZSAmJiB0eXBlb2YgZm4ucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCBcIlRoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gaGF2ZSBhIHJlbmRlciBtZXRob2QsIGJ1dCBkb2Vzbid0IGV4dGVuZCBSZWFjdC5Db21wb25lbnQuIFwiICsgJ1RoaXMgaXMgbGlrZWx5IHRvIGNhdXNlIGVycm9ycy4gQ2hhbmdlICVzIHRvIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIHZhbHVlID0gZm4ocHJvcHMsIGNvbnRleHQpO1xuICAgIH1cbiAgICAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFBlcmZvcm1lZFdvcms7XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBQcm9jZWVkIHVuZGVyIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhpcyBpcyBhIGNsYXNzIGluc3RhbmNlXG4gICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBDbGFzc0NvbXBvbmVudDtcblxuICAgICAgLy8gUHVzaCBjb250ZXh0IHByb3ZpZGVycyBlYXJseSB0byBwcmV2ZW50IGNvbnRleHQgc3RhY2sgbWlzbWF0Y2hlcy5cbiAgICAgIC8vIER1cmluZyBtb3VudGluZyB3ZSBkb24ndCBrbm93IHRoZSBjaGlsZCBjb250ZXh0IHlldCBhcyB0aGUgaW5zdGFuY2UgZG9lc24ndCBleGlzdC5cbiAgICAgIC8vIFdlIHdpbGwgaW52YWxpZGF0ZSB0aGUgY2hpbGQgY29udGV4dCBpbiBmaW5pc2hDbGFzc0NvbXBvbmVudCgpIHJpZ2h0IGFmdGVyIHJlbmRlcmluZy5cbiAgICAgIHZhciBoYXNDb250ZXh0ID0gcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBhZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHZhbHVlKTtcbiAgICAgIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgcmV0dXJuIGZpbmlzaENsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB0cnVlLCBoYXNDb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUHJvY2VlZCB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoaXMgaXMgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gRnVuY3Rpb25hbENvbXBvbmVudDtcbiAgICAgIHtcbiAgICAgICAgdmFyIENvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cbiAgICAgICAgaWYgKENvbXBvbmVudCkge1xuICAgICAgICAgIHdhcm5pbmcoIUNvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcywgJyVzKC4uLik6IGNoaWxkQ29udGV4dFR5cGVzIGNhbm5vdCBiZSBkZWZpbmVkIG9uIGEgZnVuY3Rpb25hbCBjb21wb25lbnQuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MucmVmICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGluZm8gPSAnJztcbiAgICAgICAgICB2YXIgb3duZXJOYW1lID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJPd25lck5hbWUoKTtcbiAgICAgICAgICBpZiAob3duZXJOYW1lKSB7XG4gICAgICAgICAgICBpbmZvICs9ICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHdhcm5pbmdLZXkgPSBvd25lck5hbWUgfHwgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSUQgfHwgJyc7XG4gICAgICAgICAgdmFyIGRlYnVnU291cmNlID0gd29ya0luUHJvZ3Jlc3MuX2RlYnVnU291cmNlO1xuICAgICAgICAgIGlmIChkZWJ1Z1NvdXJjZSkge1xuICAgICAgICAgICAgd2FybmluZ0tleSA9IGRlYnVnU291cmNlLmZpbGVOYW1lICsgJzonICsgZGVidWdTb3VyY2UubGluZU51bWJlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF3YXJuZWRBYm91dFN0YXRlbGVzc1JlZnNbd2FybmluZ0tleV0pIHtcbiAgICAgICAgICAgIHdhcm5lZEFib3V0U3RhdGVsZXNzUmVmc1t3YXJuaW5nS2V5XSA9IHRydWU7XG4gICAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnU3RhdGVsZXNzIGZ1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGJlIGdpdmVuIHJlZnMuICcgKyAnQXR0ZW1wdHMgdG8gYWNjZXNzIHRoaXMgcmVmIHdpbGwgZmFpbC4lcyVzJywgaW5mbywgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHZhbHVlKTtcbiAgICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgcHJvcHMpO1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNhbGxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIG5leHRDYWxsID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmIChoYXNDb250ZXh0Q2hhbmdlZCgpKSB7XG4gICAgICAvLyBOb3JtYWxseSB3ZSBjYW4gYmFpbCBvdXQgb24gcHJvcHMgZXF1YWxpdHkgYnV0IGlmIGNvbnRleHQgaGFzIGNoYW5nZWRcbiAgICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gICAgICBpZiAobmV4dENhbGwgPT09IG51bGwpIHtcbiAgICAgICAgbmV4dENhbGwgPSBjdXJyZW50ICYmIGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgIShuZXh0Q2FsbCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdXZSBzaG91bGQgYWx3YXlzIGhhdmUgcGVuZGluZyBvciBjdXJyZW50IHByb3BzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dENhbGwgPT09IG51bGwgfHwgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9PT0gbmV4dENhbGwpIHtcbiAgICAgIG5leHRDYWxsID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICAgIC8vIFRPRE86IFdoZW4gYmFpbGluZyBvdXQsIHdlIG1pZ2h0IG5lZWQgdG8gcmV0dXJuIHRoZSBzdGF0ZU5vZGUgaW5zdGVhZFxuICAgICAgLy8gb2YgdGhlIGNoaWxkLiBUbyBjaGVjayBpdCBmb3Igd29yay5cbiAgICAgIC8vIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dENhbGwuY2hpbGRyZW47XG5cbiAgICAvLyBUaGUgZm9sbG93aW5nIGlzIGEgZm9yayBvZiByZWNvbmNpbGVDaGlsZHJlbkF0RXhwaXJhdGlvblRpbWUgYnV0IHVzaW5nXG4gICAgLy8gc3RhdGVOb2RlIHRvIHN0b3JlIHRoZSBjaGlsZC5cbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gbW91bnRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfVxuXG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0Q2FsbCk7XG4gICAgLy8gVGhpcyBkb2Vzbid0IHRha2UgYXJiaXRyYXJ5IHRpbWUgc28gd2UgY291bGQgc3luY2hyb25vdXNseSBqdXN0IGJlZ2luXG4gICAgLy8gZWFnZXJseSBkbyB0aGUgd29yayBvZiB3b3JrSW5Qcm9ncmVzcy5jaGlsZCBhcyBhbiBvcHRpbWl6YXRpb24uXG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVBvcnRhbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICBwdXNoSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKGhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgICAgLy8gd2UgZG9uJ3QgZG8gdGhlIGJhaWxvdXQgYW5kIHdlIGhhdmUgdG8gcmV1c2UgZXhpc3RpbmcgcHJvcHMgaW5zdGVhZC5cbiAgICAgIGlmIChuZXh0Q2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICAgICAgbmV4dENoaWxkcmVuID0gY3VycmVudCAmJiBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICEobmV4dENoaWxkcmVuICE9IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnV2Ugc2hvdWxkIGFsd2F5cyBoYXZlIHBlbmRpbmcgb3IgY3VycmVudCBwcm9wcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRDaGlsZHJlbiA9PT0gbnVsbCB8fCB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID09PSBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgLy8gUG9ydGFscyBhcmUgc3BlY2lhbCBiZWNhdXNlIHdlIGRvbid0IGFwcGVuZCB0aGUgY2hpbGRyZW4gZHVyaW5nIG1vdW50XG4gICAgICAvLyBidXQgYXQgY29tbWl0LiBUaGVyZWZvcmUgd2UgbmVlZCB0byB0cmFjayBpbnNlcnRpb25zIHdoaWNoIHRoZSBub3JtYWxcbiAgICAgIC8vIGZsb3cgZG9lc24ndCBkbyBkdXJpbmcgbW91bnQuIFRoaXMgZG9lc24ndCBoYXBwZW4gYXQgdGhlIHJvb3QgYmVjYXVzZVxuICAgICAgLy8gdGhlIHJvb3QgYWx3YXlzIHN0YXJ0cyB3aXRoIGEgXCJjdXJyZW50XCIgd2l0aCBhIG51bGwgY2hpbGQuXG4gICAgICAvLyBUT0RPOiBDb25zaWRlciB1bmlmeWluZyB0aGlzIHdpdGggaG93IHRoZSByb290IHdvcmtzLlxuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIH1cbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICAvKlxuICBmdW5jdGlvbiByZXVzZUNoaWxkcmVuRWZmZWN0cyhyZXR1cm5GaWJlciA6IEZpYmVyLCBmaXJzdENoaWxkIDogRmliZXIpIHtcbiAgICBsZXQgY2hpbGQgPSBmaXJzdENoaWxkO1xuICAgIGRvIHtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBmaXJzdCBhbmQgbGFzdCBlZmZlY3Qgb2YgdGhlIHBhcmVudCBjb3JyZXNwb25kc1xuICAgICAgLy8gdG8gdGhlIGNoaWxkcmVuJ3MgZmlyc3QgYW5kIGxhc3QgZWZmZWN0LlxuICAgICAgaWYgKCFyZXR1cm5GaWJlci5maXJzdEVmZmVjdCkge1xuICAgICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IGNoaWxkLmZpcnN0RWZmZWN0O1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkLmxhc3RFZmZlY3QpIHtcbiAgICAgICAgaWYgKHJldHVybkZpYmVyLmxhc3RFZmZlY3QpIHtcbiAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBjaGlsZC5maXJzdEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY2hpbGQubGFzdEVmZmVjdDtcbiAgICAgIH1cbiAgICB9IHdoaWxlIChjaGlsZCA9IGNoaWxkLnNpYmxpbmcpO1xuICB9XG4gICovXG5cbiAgZnVuY3Rpb24gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIGNhbmNlbFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAvLyBUT0RPOiBXZSBzaG91bGQgaWRlYWxseSBiZSBhYmxlIHRvIGJhaWwgb3V0IGVhcmx5IGlmIHRoZSBjaGlsZHJlbiBoYXZlIG5vXG4gICAgLy8gbW9yZSB3b3JrIHRvIGRvLiBIb3dldmVyLCBzaW5jZSB3ZSBkb24ndCBoYXZlIGEgc2VwYXJhdGlvbiBvZiB0aGlzXG4gICAgLy8gRmliZXIncyBwcmlvcml0eSBhbmQgaXRzIGNoaWxkcmVuIHlldCAtIHdlIGRvbid0IGtub3cgd2l0aG91dCBkb2luZyBsb3RzXG4gICAgLy8gb2YgdGhlIHNhbWUgd29yayB3ZSBkbyBhbnl3YXkuIE9uY2Ugd2UgaGF2ZSB0aGF0IHNlcGFyYXRpb24gd2UgY2FuIGp1c3RcbiAgICAvLyBiYWlsIG91dCBoZXJlIGlmIHRoZSBjaGlsZHJlbiBoYXMgbm8gbW9yZSB3b3JrIGF0IHRoaXMgcHJpb3JpdHkgbGV2ZWwuXG4gICAgLy8gaWYgKHdvcmtJblByb2dyZXNzLnByaW9yaXR5T2ZDaGlsZHJlbiA8PSBwcmlvcml0eUxldmVsKSB7XG4gICAgLy8gICAvLyBJZiB0aGVyZSBhcmUgc2lkZS1lZmZlY3RzIGluIHRoZXNlIGNoaWxkcmVuIHRoYXQgaGF2ZSBub3QgeWV0IGJlZW5cbiAgICAvLyAgIC8vIGNvbW1pdHRlZCB3ZSBuZWVkIHRvIGVuc3VyZSB0aGF0IHRoZXkgZ2V0IHByb3Blcmx5IHRyYW5zZmVycmVkIHVwLlxuICAgIC8vICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudC5jaGlsZCAhPT0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpIHtcbiAgICAvLyAgICAgcmV1c2VDaGlsZHJlbkVmZmVjdHMod29ya0luUHJvZ3Jlc3MsIGNoaWxkKTtcbiAgICAvLyAgIH1cbiAgICAvLyAgIHJldHVybiBudWxsO1xuICAgIC8vIH1cblxuICAgIGNsb25lQ2hpbGRGaWJlcnMoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJhaWxvdXRPbkxvd1ByaW9yaXR5KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgY2FuY2VsV29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcblxuICAgIC8vIFRPRE86IEhhbmRsZSBIb3N0Q29tcG9uZW50IHRhZ3MgaGVyZSBhcyB3ZWxsIGFuZCBjYWxsIHB1c2hIb3N0Q29udGV4dCgpP1xuICAgIC8vIFNlZSBQUiA4NTkwIGRpc2N1c3Npb24gZm9yIGNvbnRleHRcbiAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICBwdXNoSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gVE9ETzogV2hhdCBpZiB0aGlzIGlzIGN1cnJlbnRseSBpbiBwcm9ncmVzcz9cbiAgICAvLyBIb3cgY2FuIHRoYXQgaGFwcGVuPyBIb3cgaXMgdGhpcyBub3QgYmVpbmcgY2xvbmVkP1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gVE9ETzogRGVsZXRlIG1lbW9pemVQcm9wcy9TdGF0ZSBhbmQgbW92ZSB0byByZWNvbmNpbGUvYmFpbG91dCBpbnN0ZWFkXG4gIGZ1bmN0aW9uIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5leHRQcm9wcztcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lbW9pemVTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFN0YXRlKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAvLyBEb24ndCByZXNldCB0aGUgdXBkYXRlUXVldWUsIGluIGNhc2UgdGhlcmUgYXJlIHBlbmRpbmcgdXBkYXRlcy4gUmVzZXR0aW5nXG4gICAgLy8gaXMgaGFuZGxlZCBieSBwcm9jZXNzVXBkYXRlUXVldWUuXG4gIH1cblxuICBmdW5jdGlvbiBiZWdpbldvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPiByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkxvd1ByaW9yaXR5KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gbW91bnRJbmRldGVybWluYXRlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBjYXNlIEZ1bmN0aW9uYWxDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiB1cGRhdGVGdW5jdGlvbmFsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiB1cGRhdGVDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RSb290KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICByZXR1cm4gdXBkYXRlSG9zdFRleHQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgY2FzZSBDYWxsSGFuZGxlclBoYXNlOlxuICAgICAgICAvLyBUaGlzIGlzIGEgcmVzdGFydC4gUmVzZXQgdGhlIHRhZyB0byB0aGUgaW5pdGlhbCBwaGFzZS5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2FsbENvbXBvbmVudDtcbiAgICAgIC8vIEludGVudGlvbmFsbHkgZmFsbCB0aHJvdWdoIHNpbmNlIHRoaXMgaXMgbm93IHRoZSBzYW1lLlxuICAgICAgY2FzZSBDYWxsQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlQ2FsbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBSZXR1cm5Db21wb25lbnQ6XG4gICAgICAgIC8vIEEgcmV0dXJuIGNvbXBvbmVudCBpcyBqdXN0IGEgcGxhY2Vob2xkZXIsIHdlIGNhbiBqdXN0IHJ1biB0aHJvdWdoIHRoZVxuICAgICAgICAvLyBuZXh0IG9uZSBpbW1lZGlhdGVseS5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgIHJldHVybiB1cGRhdGVQb3J0YWxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmtub3duIHVuaXQgb2Ygd29yayB0YWcuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYmVnaW5GYWlsZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFB1c2ggY29udGV4dCBwcm92aWRlcnMgaGVyZSB0byBhdm9pZCBhIHB1c2gvcG9wIGNvbnRleHQgbWlzbWF0Y2guXG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgdHlwZSBvZiB3b3JrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cblxuICAgIC8vIEFkZCBhbiBlcnJvciBlZmZlY3Qgc28gd2UgY2FuIGhhbmRsZSB0aGUgZXJyb3IgZHVyaW5nIHRoZSBjb21taXQgcGhhc2VcbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gRXJyO1xuXG4gICAgLy8gVGhpcyBpcyBhIHdlaXJkIGNhc2Ugd2hlcmUgd2UgZG8gXCJyZXN1bWVcIiB3b3JrIOKAlCB3b3JrIHRoYXQgZmFpbGVkIG9uXG4gICAgLy8gb3VyIGZpcnN0IGF0dGVtcHQuIEJlY2F1c2Ugd2Ugbm8gbG9uZ2VyIGhhdmUgYSBub3Rpb24gb2YgXCJwcm9ncmVzc2VkXG4gICAgLy8gZGVsZXRpb25zLFwiIHJlc2V0IHRoZSBjaGlsZCB0byB0aGUgY3VycmVudCBjaGlsZCB0byBtYWtlIHN1cmUgd2UgZGVsZXRlXG4gICAgLy8gaXQgYWdhaW4uIFRPRE86IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzLCBwZXJoYXBzIGR1cmluZyBhIG1vcmVcbiAgICAvLyBnZW5lcmFsIG92ZXJoYXVsIG9mIGVycm9yIGhhbmRsaW5nLlxuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGw7XG4gICAgfSBlbHNlIGlmICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCAhPT0gY3VycmVudC5jaGlsZCkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkO1xuICAgIH1cblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25Mb3dQcmlvcml0eShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZG9uJ3QgYmFpbCBvdXQsIHdlJ3JlIGdvaW5nIGJlIHJlY29tcHV0aW5nIG91ciBjaGlsZHJlbiBzbyB3ZSBuZWVkXG4gICAgLy8gdG8gZHJvcCBvdXIgZWZmZWN0IGxpc3QuXG4gICAgd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgPSBudWxsO1xuXG4gICAgLy8gVW5tb3VudCB0aGUgY3VycmVudCBjaGlsZHJlbiBhcyBpZiB0aGUgY29tcG9uZW50IHJlbmRlcmVkIG51bGxcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gbnVsbDtcbiAgICByZWNvbmNpbGVDaGlsZHJlbkF0RXhwaXJhdGlvblRpbWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBpbnN0YW5jZS5wcm9wcztcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJlZ2luV29yazogYmVnaW5Xb3JrLFxuICAgIGJlZ2luRmFpbGVkV29yazogYmVnaW5GYWlsZWRXb3JrXG4gIH07XG59O1xuXG52YXIgUmVhY3RGaWJlckNvbXBsZXRlV29yayA9IGZ1bmN0aW9uIChjb25maWcsIGhvc3RDb250ZXh0LCBoeWRyYXRpb25Db250ZXh0KSB7XG4gIHZhciBjcmVhdGVJbnN0YW5jZSA9IGNvbmZpZy5jcmVhdGVJbnN0YW5jZSxcbiAgICAgIGNyZWF0ZVRleHRJbnN0YW5jZSA9IGNvbmZpZy5jcmVhdGVUZXh0SW5zdGFuY2UsXG4gICAgICBhcHBlbmRJbml0aWFsQ2hpbGQgPSBjb25maWcuYXBwZW5kSW5pdGlhbENoaWxkLFxuICAgICAgZmluYWxpemVJbml0aWFsQ2hpbGRyZW4gPSBjb25maWcuZmluYWxpemVJbml0aWFsQ2hpbGRyZW4sXG4gICAgICBwcmVwYXJlVXBkYXRlID0gY29uZmlnLnByZXBhcmVVcGRhdGUsXG4gICAgICBtdXRhdGlvbiA9IGNvbmZpZy5tdXRhdGlvbixcbiAgICAgIHBlcnNpc3RlbmNlID0gY29uZmlnLnBlcnNpc3RlbmNlO1xuICB2YXIgZ2V0Um9vdEhvc3RDb250YWluZXIgPSBob3N0Q29udGV4dC5nZXRSb290SG9zdENvbnRhaW5lcixcbiAgICAgIHBvcEhvc3RDb250ZXh0ID0gaG9zdENvbnRleHQucG9wSG9zdENvbnRleHQsXG4gICAgICBnZXRIb3N0Q29udGV4dCA9IGhvc3RDb250ZXh0LmdldEhvc3RDb250ZXh0LFxuICAgICAgcG9wSG9zdENvbnRhaW5lciA9IGhvc3RDb250ZXh0LnBvcEhvc3RDb250YWluZXI7XG4gIHZhciBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlID0gaHlkcmF0aW9uQ29udGV4dC5wcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlLFxuICAgICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UgPSBoeWRyYXRpb25Db250ZXh0LnByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlLFxuICAgICAgcG9wSHlkcmF0aW9uU3RhdGUgPSBoeWRyYXRpb25Db250ZXh0LnBvcEh5ZHJhdGlvblN0YXRlO1xuXG5cbiAgZnVuY3Rpb24gbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcykge1xuICAgIC8vIFRhZyB0aGUgZmliZXIgd2l0aCBhbiB1cGRhdGUgZWZmZWN0LiBUaGlzIHR1cm5zIGEgUGxhY2VtZW50IGludG9cbiAgICAvLyBhbiBVcGRhdGVBbmRQbGFjZW1lbnQuXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtSZWYod29ya0luUHJvZ3Jlc3MpIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUmVmO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwZW5kQWxsUmV0dXJucyhyZXR1cm5zLCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIGlmIChub2RlKSB7XG4gICAgICBub2RlWydyZXR1cm4nXSA9IHdvcmtJblByb2dyZXNzO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCB8fCBub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdBIGNhbGwgY2Fubm90IGhhdmUgaG9zdCBjb21wb25lbnQgY2hpbGRyZW4uJyk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBSZXR1cm5Db21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJucy5wdXNoKG5vZGUudHlwZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlWydyZXR1cm4nXSA9PT0gbnVsbCB8fCBub2RlWydyZXR1cm4nXSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtb3ZlQ2FsbFRvSGFuZGxlclBoYXNlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBjYWxsID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICAhY2FsbCA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBiZSByZXNvbHZlZCBieSBub3cuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgICAvLyBGaXJzdCBzdGVwIG9mIHRoZSBjYWxsIGhhcyBjb21wbGV0ZWQuIE5vdyB3ZSBuZWVkIHRvIGRvIHRoZSBzZWNvbmQuXG4gICAgLy8gVE9ETzogSXQgd291bGQgYmUgbmljZSB0byBoYXZlIGEgbXVsdGkgc3RhZ2UgY2FsbCByZXByZXNlbnRlZCBieSBhXG4gICAgLy8gc2luZ2xlIGNvbXBvbmVudCwgb3IgYXQgbGVhc3QgdGFpbCBjYWxsIG9wdGltaXplIG5lc3RlZCBvbmVzLiBDdXJyZW50bHlcbiAgICAvLyB0aGF0IHJlcXVpcmVzIGFkZGl0aW9uYWwgZmllbGRzIHRoYXQgd2UgZG9uJ3Qgd2FudCB0byBhZGQgdG8gdGhlIGZpYmVyLlxuICAgIC8vIFNvIHRoaXMgcmVxdWlyZXMgbmVzdGVkIGhhbmRsZXJzLlxuICAgIC8vIE5vdGU6IFRoaXMgZG9lc24ndCBtdXRhdGUgdGhlIGFsdGVybmF0ZSBub2RlLiBJIGRvbid0IHRoaW5rIGl0IG5lZWRzIHRvXG4gICAgLy8gc2luY2UgdGhpcyBzdGFnZSBpcyByZXNldCBmb3IgZXZlcnkgcGFzcy5cbiAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBDYWxsSGFuZGxlclBoYXNlO1xuXG4gICAgLy8gQnVpbGQgdXAgdGhlIHJldHVybnMuXG4gICAgLy8gVE9ETzogQ29tcGFyZSB0aGlzIHRvIGEgZ2VuZXJhdG9yIG9yIG9wYXF1ZSBoZWxwZXJzIGxpa2UgQ2hpbGRyZW4uXG4gICAgdmFyIHJldHVybnMgPSBbXTtcbiAgICBhcHBlbmRBbGxSZXR1cm5zKHJldHVybnMsIHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgZm4gPSBjYWxsLmhhbmRsZXI7XG4gICAgdmFyIHByb3BzID0gY2FsbC5wcm9wcztcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gZm4ocHJvcHMsIHJldHVybnMpO1xuXG4gICAgdmFyIGN1cnJlbnRGaXJzdENoaWxkID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQuY2hpbGQgOiBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBlbmRBbGxDaGlsZHJlbihwYXJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgY3JlYXRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG4gICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgYXBwZW5kSW5pdGlhbENoaWxkKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcG9ydGFsIGNoaWxkLCB0aGVuIHdlIGRvbid0IHdhbnQgdG8gdHJhdmVyc2VcbiAgICAgICAgLy8gZG93biBpdHMgY2hpbGRyZW4uIEluc3RlYWQsIHdlJ2xsIGdldCBpbnNlcnRpb25zIGZyb20gZWFjaCBjaGlsZCBpblxuICAgICAgICAvLyB0aGUgcG9ydGFsIGRpcmVjdGx5LlxuICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1cGRhdGVIb3N0Q29udGFpbmVyID0gdm9pZCAwO1xuICB2YXIgdXBkYXRlSG9zdENvbXBvbmVudCA9IHZvaWQgMDtcbiAgdmFyIHVwZGF0ZUhvc3RUZXh0ID0gdm9pZCAwO1xuICBpZiAobXV0YXRpb24pIHtcbiAgICBpZiAoZW5hYmxlTXV0YXRpbmdSZWNvbmNpbGVyKSB7XG4gICAgICAvLyBNdXRhdGlvbiBtb2RlXG4gICAgICB1cGRhdGVIb3N0Q29udGFpbmVyID0gZnVuY3Rpb24gKHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIC8vIE5vb3BcbiAgICAgIH07XG4gICAgICB1cGRhdGVIb3N0Q29tcG9uZW50ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICAgICAgICAvLyBUT0RPOiBUeXBlIHRoaXMgc3BlY2lmaWMgdG8gdGhpcyB0eXBlIG9mIGNvbXBvbmVudC5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSB1cGRhdGVQYXlsb2FkO1xuICAgICAgICAvLyBJZiB0aGUgdXBkYXRlIHBheWxvYWQgaW5kaWNhdGVzIHRoYXQgdGhlcmUgaXMgYSBjaGFuZ2Ugb3IgaWYgdGhlcmVcbiAgICAgICAgLy8gaXMgYSBuZXcgcmVmIHdlIG1hcmsgdGhpcyBhcyBhbiB1cGRhdGUuIEFsbCB0aGUgd29yayBpcyBkb25lIGluIGNvbW1pdFdvcmsuXG4gICAgICAgIGlmICh1cGRhdGVQYXlsb2FkKSB7XG4gICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB1cGRhdGVIb3N0VGV4dCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgb2xkVGV4dCwgbmV3VGV4dCkge1xuICAgICAgICAvLyBJZiB0aGUgdGV4dCBkaWZmZXJzLCBtYXJrIGl0IGFzIGFuIHVwZGF0ZS4gQWxsIHRoZSB3b3JrIGluIGRvbmUgaW4gY29tbWl0V29yay5cbiAgICAgICAgaWYgKG9sZFRleHQgIT09IG5ld1RleHQpIHtcbiAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnTXV0YXRpbmcgcmVjb25jaWxlciBpcyBkaXNhYmxlZC4nKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocGVyc2lzdGVuY2UpIHtcbiAgICBpZiAoZW5hYmxlUGVyc2lzdGVudFJlY29uY2lsZXIpIHtcbiAgICAgIC8vIFBlcnNpc3RlbnQgaG9zdCB0cmVlIG1vZGVcbiAgICAgIHZhciBjbG9uZUluc3RhbmNlID0gcGVyc2lzdGVuY2UuY2xvbmVJbnN0YW5jZSxcbiAgICAgICAgICBjcmVhdGVDb250YWluZXJDaGlsZFNldCA9IHBlcnNpc3RlbmNlLmNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0LFxuICAgICAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldCA9IHBlcnNpc3RlbmNlLmFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldCxcbiAgICAgICAgICBmaW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuID0gcGVyc2lzdGVuY2UuZmluYWxpemVDb250YWluZXJDaGlsZHJlbjtcblxuICAgICAgLy8gQW4gdW5mb3J0dW5hdGUgZm9yayBvZiBhcHBlbmRBbGxDaGlsZHJlbiBiZWNhdXNlIHdlIGhhdmUgdHdvIGRpZmZlcmVudCBwYXJlbnQgdHlwZXMuXG5cbiAgICAgIHZhciBhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyID0gZnVuY3Rpb24gKGNvbnRhaW5lckNoaWxkU2V0LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBjcmVhdGVkIGJ1dCB3ZSBuZWVkIHJlY3Vyc2UgZG93biBpdHNcbiAgICAgICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgICAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldChjb250YWluZXJDaGlsZFNldCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBwb3J0YWwgY2hpbGQsIHRoZW4gd2UgZG9uJ3Qgd2FudCB0byB0cmF2ZXJzZVxuICAgICAgICAgICAgLy8gZG93biBpdHMgY2hpbGRyZW4uIEluc3RlYWQsIHdlJ2xsIGdldCBpbnNlcnRpb25zIGZyb20gZWFjaCBjaGlsZCBpblxuICAgICAgICAgICAgLy8gdGhlIHBvcnRhbCBkaXJlY3RseS5cbiAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgbm9kZVsncmV0dXJuJ10gPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB1cGRhdGVIb3N0Q29udGFpbmVyID0gZnVuY3Rpb24gKHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIHZhciBwb3J0YWxPclJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgIHZhciBjaGlsZHJlblVuY2hhbmdlZCA9IHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID09PSBudWxsO1xuICAgICAgICBpZiAoY2hpbGRyZW5VbmNoYW5nZWQpIHtcbiAgICAgICAgICAvLyBObyBjaGFuZ2VzLCBqdXN0IHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZS5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY29udGFpbmVyID0gcG9ydGFsT3JSb290LmNvbnRhaW5lckluZm87XG4gICAgICAgICAgdmFyIG5ld0NoaWxkU2V0ID0gY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQoY29udGFpbmVyKTtcbiAgICAgICAgICBpZiAoZmluYWxpemVDb250YWluZXJDaGlsZHJlbihjb250YWluZXIsIG5ld0NoaWxkU2V0KSkge1xuICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvcnRhbE9yUm9vdC5wZW5kaW5nQ2hpbGRyZW4gPSBuZXdDaGlsZFNldDtcbiAgICAgICAgICAvLyBJZiBjaGlsZHJlbiBtaWdodCBoYXZlIGNoYW5nZWQsIHdlIGhhdmUgdG8gYWRkIHRoZW0gYWxsIHRvIHRoZSBzZXQuXG4gICAgICAgICAgYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lcihuZXdDaGlsZFNldCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIC8vIFNjaGVkdWxlIGFuIHVwZGF0ZSBvbiB0aGUgY29udGFpbmVyIHRvIHN3YXAgb3V0IHRoZSBjb250YWluZXIuXG4gICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB1cGRhdGVIb3N0Q29tcG9uZW50ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gZWZmZWN0cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLCB0aGVuIG5vbmUgb2Ygb3VyIGNoaWxkcmVuIGhhZCBhbnkgdXBkYXRlcy5cbiAgICAgICAgLy8gVGhpcyBndWFyYW50ZWVzIHRoYXQgd2UgY2FuIHJldXNlIGFsbCBvZiB0aGVtLlxuICAgICAgICB2YXIgY2hpbGRyZW5VbmNoYW5nZWQgPSB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdCA9PT0gbnVsbDtcbiAgICAgICAgdmFyIGN1cnJlbnRJbnN0YW5jZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuICAgICAgICBpZiAoY2hpbGRyZW5VbmNoYW5nZWQgJiYgdXBkYXRlUGF5bG9hZCA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIE5vIGNoYW5nZXMsIGp1c3QgcmV1c2UgdGhlIGV4aXN0aW5nIGluc3RhbmNlLlxuICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIG1pZ2h0IHJlbGVhc2UgYSBwcmV2aW91cyBjbG9uZS5cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50SW5zdGFuY2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJlY3ljbGFibGVJbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICB2YXIgbmV3SW5zdGFuY2UgPSBjbG9uZUluc3RhbmNlKGN1cnJlbnRJbnN0YW5jZSwgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCB3b3JrSW5Qcm9ncmVzcywgY2hpbGRyZW5VbmNoYW5nZWQsIHJlY3ljbGFibGVJbnN0YW5jZSk7XG4gICAgICAgICAgaWYgKGZpbmFsaXplSW5pdGlhbENoaWxkcmVuKG5ld0luc3RhbmNlLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSkge1xuICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG5ld0luc3RhbmNlO1xuICAgICAgICAgIGlmIChjaGlsZHJlblVuY2hhbmdlZCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIG90aGVyIGVmZmVjdHMgaW4gdGhpcyB0cmVlLCB3ZSBuZWVkIHRvIGZsYWcgdGhpcyBub2RlIGFzIGhhdmluZyBvbmUuXG4gICAgICAgICAgICAvLyBFdmVuIHRob3VnaCB3ZSdyZSBub3QgZ29pbmcgdG8gdXNlIGl0IGZvciBhbnl0aGluZy5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBwYXJlbnRzIHdvbid0IGtub3cgdGhhdCB0aGVyZSBhcmUgbmV3IGNoaWxkcmVuIHRvIHByb3BhZ2F0ZSB1cHdhcmRzLlxuICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIGNoaWxkcmVuIG1pZ2h0IGhhdmUgY2hhbmdlZCwgd2UgaGF2ZSB0byBhZGQgdGhlbSBhbGwgdG8gdGhlIHNldC5cbiAgICAgICAgICAgIGFwcGVuZEFsbENoaWxkcmVuKG5ld0luc3RhbmNlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdFRleHQgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICAgICAgaWYgKG9sZFRleHQgIT09IG5ld1RleHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgdGV4dCBjb250ZW50IGRpZmZlcnMsIHdlJ2xsIGNyZWF0ZSBhIG5ldyB0ZXh0IGluc3RhbmNlIGZvciBpdC5cbiAgICAgICAgICB2YXIgcm9vdENvbnRhaW5lckluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcbiAgICAgICAgICB2YXIgY3VycmVudEhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjcmVhdGVUZXh0SW5zdGFuY2UobmV3VGV4dCwgcm9vdENvbnRhaW5lckluc3RhbmNlLCBjdXJyZW50SG9zdENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAvLyBXZSdsbCBoYXZlIHRvIG1hcmsgaXQgYXMgaGF2aW5nIGFuIGVmZmVjdCwgZXZlbiB0aG91Z2ggd2Ugd29uJ3QgdXNlIHRoZSBlZmZlY3QgZm9yIGFueXRoaW5nLlxuICAgICAgICAgIC8vIFRoaXMgbGV0cyB0aGUgcGFyZW50cyBrbm93IHRoYXQgYXQgbGVhc3Qgb25lIG9mIHRoZWlyIGNoaWxkcmVuIGhhcyBjaGFuZ2VkLlxuICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdQZXJzaXN0ZW50IHJlY29uY2lsZXIgaXMgZGlzYWJsZWQuJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChlbmFibGVOb29wUmVjb25jaWxlcikge1xuICAgICAgLy8gTm8gaG9zdCBvcGVyYXRpb25zXG4gICAgICB1cGRhdGVIb3N0Q29udGFpbmVyID0gZnVuY3Rpb24gKHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIC8vIE5vb3BcbiAgICAgIH07XG4gICAgICB1cGRhdGVIb3N0Q29tcG9uZW50ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdFRleHQgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICAgICAgLy8gTm9vcFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnTm9vcCByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBsZXRlV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBHZXQgdGhlIGxhdGVzdCBwcm9wcy5cbiAgICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKG5ld1Byb3BzID09PSBudWxsKSB7XG4gICAgICBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgfSBlbHNlIGlmICh3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSAhPT0gTmV2ZXIgfHwgcmVuZGVyRXhwaXJhdGlvblRpbWUgPT09IE5ldmVyKSB7XG4gICAgICAvLyBSZXNldCB0aGUgcGVuZGluZyBwcm9wcywgdW5sZXNzIHRoaXMgd2FzIGEgZG93bi1wcmlvcml0aXphdGlvbi5cbiAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyA9IG51bGw7XG4gICAgfVxuXG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgRnVuY3Rpb25hbENvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gV2UgYXJlIGxlYXZpbmcgdGhpcyBzdWJ0cmVlLCBzbyBwb3AgY29udGV4dCBpZiBhbnkuXG4gICAgICAgICAgcG9wQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAge1xuICAgICAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHBvcFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgdmFyIGZpYmVyUm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICBpZiAoZmliZXJSb290LnBlbmRpbmdDb250ZXh0KSB7XG4gICAgICAgICAgICBmaWJlclJvb3QuY29udGV4dCA9IGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dDtcbiAgICAgICAgICAgIGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC5jaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgaHlkcmF0ZWQsIHBvcCBzbyB0aGF0IHdlIGNhbiBkZWxldGUgYW55IHJlbWFpbmluZyBjaGlsZHJlblxuICAgICAgICAgICAgLy8gdGhhdCB3ZXJlbid0IGh5ZHJhdGVkLlxuICAgICAgICAgICAgcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgLy8gVGhpcyByZXNldHMgdGhlIGhhY2t5IHN0YXRlIHRvIGZpeCBpc01vdW50ZWQgYmVmb3JlIGNvbW1pdHRpbmcuXG4gICAgICAgICAgICAvLyBUT0RPOiBEZWxldGUgdGhpcyB3aGVuIHdlIGRlbGV0ZSBpc01vdW50ZWQgYW5kIGZpbmRET01Ob2RlLlxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnICY9IH5QbGFjZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBwb3BIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgdmFyIHJvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG4gICAgICAgICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGFuIGFsdGVybmF0ZSwgdGhhdCBtZWFucyB0aGlzIGlzIGFuIHVwZGF0ZSBhbmQgd2UgbmVlZCB0b1xuICAgICAgICAgICAgLy8gc2NoZWR1bGUgYSBzaWRlLWVmZmVjdCB0byBkbyB0aGUgdXBkYXRlcy5cbiAgICAgICAgICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIC8vIElmIHdlIGdldCB1cGRhdGVkIGJlY2F1c2Ugb25lIG9mIG91ciBjaGlsZHJlbiB1cGRhdGVkLCB3ZSBkb24ndFxuICAgICAgICAgICAgLy8gaGF2ZSBuZXdQcm9wcyBzbyB3ZSdsbCBoYXZlIHRvIHJldXNlIHRoZW0uXG4gICAgICAgICAgICAvLyBUT0RPOiBTcGxpdCB0aGUgdXBkYXRlIEFQSSBhcyBzZXBhcmF0ZSBmb3IgdGhlIHByb3BzIHZzLiBjaGlsZHJlbi5cbiAgICAgICAgICAgIC8vIEV2ZW4gYmV0dGVyIHdvdWxkIGJlIGlmIGNoaWxkcmVuIHdlcmVuJ3Qgc3BlY2lhbCBjYXNlZCBhdCBhbGwgdGhvLlxuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgICB2YXIgdXBkYXRlUGF5bG9hZCA9IHByZXBhcmVVcGRhdGUoaW5zdGFuY2UsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBjdXJyZW50SG9zdENvbnRleHQpO1xuXG4gICAgICAgICAgICB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50LnJlZiAhPT0gd29ya0luUHJvZ3Jlc3MucmVmKSB7XG4gICAgICAgICAgICAgIG1hcmtSZWYod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIW5ld1Byb3BzKSB7XG4gICAgICAgICAgICAgICEod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1dlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHdlIGFib3J0IHdvcmsuXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgX2N1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgICAvLyBUT0RPOiBNb3ZlIGNyZWF0ZUluc3RhbmNlIHRvIGJlZ2luV29yayBhbmQga2VlcCBpdCBvbiBhIGNvbnRleHRcbiAgICAgICAgICAgIC8vIFwic3RhY2tcIiBhcyB0aGUgcGFyZW50LiBUaGVuIGFwcGVuZCBjaGlsZHJlbiBhcyB3ZSBnbyBpbiBiZWdpbldvcmtcbiAgICAgICAgICAgIC8vIG9yIGNvbXBsZXRlV29yayBkZXBlbmRpbmcgb24gd2Ugd2FudCB0byBhZGQgdGhlbiB0b3AtPmRvd24gb3JcbiAgICAgICAgICAgIC8vIGJvdHRvbS0+dXAuIFRvcC0+ZG93biBpcyBmYXN0ZXIgaW4gSUUxMS5cbiAgICAgICAgICAgIHZhciB3YXNIeWRyYXRlZCA9IHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIGlmICh3YXNIeWRyYXRlZCkge1xuICAgICAgICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgYW5kIGNyZWF0ZUluc3RhbmNlIHN0ZXAgaW50byB0aGUgYmVnaW5QaGFzZVxuICAgICAgICAgICAgICAvLyB0byBjb25zb2xpZGF0ZS5cbiAgICAgICAgICAgICAgaWYgKHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgX2N1cnJlbnRIb3N0Q29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBjaGFuZ2VzIHRvIHRoZSBoeWRyYXRlZCBub2RlIG5lZWRzIHRvIGJlIGFwcGxpZWQgYXQgdGhlXG4gICAgICAgICAgICAgICAgLy8gY29tbWl0LXBoYXNlIHdlIG1hcmsgdGhpcyBhcyBzdWNoLlxuICAgICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgX2luc3RhbmNlID0gY3JlYXRlSW5zdGFuY2UodHlwZSwgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgX2N1cnJlbnRIb3N0Q29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgICAgIGFwcGVuZEFsbENoaWxkcmVuKF9pbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgICAgIC8vIENlcnRhaW4gcmVuZGVyZXJzIHJlcXVpcmUgY29tbWl0LXRpbWUgZWZmZWN0cyBmb3IgaW5pdGlhbCBtb3VudC5cbiAgICAgICAgICAgICAgLy8gKGVnIERPTSByZW5kZXJlciBzdXBwb3J0cyBhdXRvLWZvY3VzIGZvciBjZXJ0YWluIGVsZW1lbnRzKS5cbiAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHN1Y2ggcmVuZGVyZXJzIGdldCBzY2hlZHVsZWQgZm9yIGxhdGVyIHdvcmsuXG4gICAgICAgICAgICAgIGlmIChmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihfaW5zdGFuY2UsIHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpKSB7XG4gICAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gX2luc3RhbmNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MucmVmICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgcmVmIG9uIGEgaG9zdCBub2RlIHdlIG5lZWQgdG8gc2NoZWR1bGUgYSBjYWxsYmFja1xuICAgICAgICAgICAgICBtYXJrUmVmKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbmV3VGV4dCA9IG5ld1Byb3BzO1xuICAgICAgICAgIGlmIChjdXJyZW50ICYmIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgb2xkVGV4dCA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYW4gYWx0ZXJuYXRlLCB0aGF0IG1lYW5zIHRoaXMgaXMgYW4gdXBkYXRlIGFuZCB3ZSBuZWVkXG4gICAgICAgICAgICAvLyB0byBzY2hlZHVsZSBhIHNpZGUtZWZmZWN0IHRvIGRvIHRoZSB1cGRhdGVzLlxuICAgICAgICAgICAgdXBkYXRlSG9zdFRleHQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5ld1RleHQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICEod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1dlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHdlIGFib3J0IHdvcmsuXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9yb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuICAgICAgICAgICAgdmFyIF9jdXJyZW50SG9zdENvbnRleHQyID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgICAgICAgIHZhciBfd2FzSHlkcmF0ZWQgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICBpZiAoX3dhc0h5ZHJhdGVkKSB7XG4gICAgICAgICAgICAgIGlmIChwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKG5ld1RleHQsIF9yb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQyLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICBjYXNlIENhbGxDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiBtb3ZlQ2FsbFRvSGFuZGxlclBoYXNlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBjYXNlIENhbGxIYW5kbGVyUGhhc2U6XG4gICAgICAgIC8vIFJlc2V0IHRoZSB0YWcgdG8gbm93IGJlIGEgZmlyc3QgcGhhc2UgY2FsbC5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2FsbENvbXBvbmVudDtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIFJldHVybkNvbXBvbmVudDpcbiAgICAgICAgLy8gRG9lcyBub3RoaW5nLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgdXBkYXRlSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgLy8gRXJyb3IgY2FzZXNcbiAgICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnQW4gaW5kZXRlcm1pbmF0ZSBjb21wb25lbnQgc2hvdWxkIGhhdmUgYmVjb21lIGRldGVybWluYXRlIGJlZm9yZSBjb21wbGV0aW5nLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmtub3duIHVuaXQgb2Ygd29yayB0YWcuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb21wbGV0ZVdvcms6IGNvbXBsZXRlV29ya1xuICB9O1xufTtcblxudmFyIGludm9rZUd1YXJkZWRDYWxsYmFjayQyID0gUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjaztcbnZhciBoYXNDYXVnaHRFcnJvciQxID0gUmVhY3RFcnJvclV0aWxzLmhhc0NhdWdodEVycm9yO1xudmFyIGNsZWFyQ2F1Z2h0RXJyb3IkMSA9IFJlYWN0RXJyb3JVdGlscy5jbGVhckNhdWdodEVycm9yO1xuXG5cbnZhciBSZWFjdEZpYmVyQ29tbWl0V29yayA9IGZ1bmN0aW9uIChjb25maWcsIGNhcHR1cmVFcnJvcikge1xuICB2YXIgZ2V0UHVibGljSW5zdGFuY2UgPSBjb25maWcuZ2V0UHVibGljSW5zdGFuY2UsXG4gICAgICBtdXRhdGlvbiA9IGNvbmZpZy5tdXRhdGlvbixcbiAgICAgIHBlcnNpc3RlbmNlID0gY29uZmlnLnBlcnNpc3RlbmNlO1xuXG5cbiAgdmFyIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lciA9IGZ1bmN0aW9uIChjdXJyZW50LCBpbnN0YW5jZSkge1xuICAgIHN0YXJ0UGhhc2VUaW1lcihjdXJyZW50LCAnY29tcG9uZW50V2lsbFVubW91bnQnKTtcbiAgICBpbnN0YW5jZS5wcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICAgIHN0b3BQaGFzZVRpbWVyKCk7XG4gIH07XG5cbiAgLy8gQ2FwdHVyZSBlcnJvcnMgc28gdGhleSBkb24ndCBpbnRlcnJ1cHQgdW5tb3VudGluZy5cbiAgZnVuY3Rpb24gc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGN1cnJlbnQsIGluc3RhbmNlKSB7XG4gICAge1xuICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDIobnVsbCwgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyLCBudWxsLCBjdXJyZW50LCBpbnN0YW5jZSk7XG4gICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IkMSgpKSB7XG4gICAgICAgIHZhciB1bm1vdW50RXJyb3IgPSBjbGVhckNhdWdodEVycm9yJDEoKTtcbiAgICAgICAgY2FwdHVyZUVycm9yKGN1cnJlbnQsIHVubW91bnRFcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQpIHtcbiAgICB2YXIgcmVmID0gY3VycmVudC5yZWY7XG4gICAgaWYgKHJlZiAhPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMihudWxsLCByZWYsIG51bGwsIG51bGwpO1xuICAgICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IkMSgpKSB7XG4gICAgICAgICAgdmFyIHJlZkVycm9yID0gY2xlYXJDYXVnaHRFcnJvciQxKCk7XG4gICAgICAgICAgY2FwdHVyZUVycm9yKGN1cnJlbnQsIHJlZkVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdExpZmVDeWNsZXMoY3VycmVudCwgZmluaXNoZWRXb3JrKSB7XG4gICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLmVmZmVjdFRhZyAmIFVwZGF0ZSkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgc3RhcnRQaGFzZVRpbWVyKGZpbmlzaGVkV29yaywgJ2NvbXBvbmVudERpZE1vdW50Jyk7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnN0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50KCk7XG4gICAgICAgICAgICAgIHN0b3BQaGFzZVRpbWVyKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgcHJldlByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICBzdGFydFBoYXNlVGltZXIoZmluaXNoZWRXb3JrLCAnY29tcG9uZW50RGlkVXBkYXRlJyk7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnN0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSk7XG4gICAgICAgICAgICAgIHN0b3BQaGFzZVRpbWVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbW1pdENhbGxiYWNrcyh1cGRhdGVRdWV1ZSwgaW5zdGFuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX3VwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICAgICAgICAgIGlmIChfdXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBfaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuY2hpbGQgIT09IG51bGwgPyBmaW5pc2hlZFdvcmsuY2hpbGQuc3RhdGVOb2RlIDogbnVsbDtcbiAgICAgICAgICAgIGNvbW1pdENhbGxiYWNrcyhfdXBkYXRlUXVldWUsIF9pbnN0YW5jZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9pbnN0YW5jZTIgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgLy8gUmVuZGVyZXJzIG1heSBzY2hlZHVsZSB3b3JrIHRvIGJlIGRvbmUgYWZ0ZXIgaG9zdCBjb21wb25lbnRzIGFyZSBtb3VudGVkXG4gICAgICAgICAgLy8gKGVnIERPTSByZW5kZXJlciBtYXkgc2NoZWR1bGUgYXV0by1mb2N1cyBmb3IgaW5wdXRzIGFuZCBmb3JtIGNvbnRyb2xzKS5cbiAgICAgICAgICAvLyBUaGVzZSBlZmZlY3RzIHNob3VsZCBvbmx5IGJlIGNvbW1pdHRlZCB3aGVuIGNvbXBvbmVudHMgYXJlIGZpcnN0IG1vdW50ZWQsXG4gICAgICAgICAgLy8gYWthIHdoZW4gdGhlcmUgaXMgbm8gY3VycmVudC9hbHRlcm5hdGUuXG4gICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgJiYgZmluaXNoZWRXb3JrLmVmZmVjdFRhZyAmIFVwZGF0ZSkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBmaW5pc2hlZFdvcmsudHlwZTtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgY29tbWl0TW91bnQoX2luc3RhbmNlMiwgdHlwZSwgcHJvcHMsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gV2UgaGF2ZSBubyBsaWZlLWN5Y2xlcyBhc3NvY2lhdGVkIHdpdGggdGV4dC5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdlIGhhdmUgbm8gbGlmZS1jeWNsZXMgYXNzb2NpYXRlZCB3aXRoIHBvcnRhbHMuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVGhpcyB1bml0IG9mIHdvcmsgdGFnIHNob3VsZCBub3QgaGF2ZSBzaWRlLWVmZmVjdHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRBdHRhY2hSZWYoZmluaXNoZWRXb3JrKSB7XG4gICAgdmFyIHJlZiA9IGZpbmlzaGVkV29yay5yZWY7XG4gICAgaWYgKHJlZiAhPT0gbnVsbCkge1xuICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgcmVmKGdldFB1YmxpY0luc3RhbmNlKGluc3RhbmNlKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVmKGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXREZXRhY2hSZWYoY3VycmVudCkge1xuICAgIHZhciBjdXJyZW50UmVmID0gY3VycmVudC5yZWY7XG4gICAgaWYgKGN1cnJlbnRSZWYgIT09IG51bGwpIHtcbiAgICAgIGN1cnJlbnRSZWYobnVsbCk7XG4gICAgfVxuICB9XG5cbiAgLy8gVXNlci1vcmlnaW5hdGluZyBlcnJvcnMgKGxpZmVjeWNsZXMgYW5kIHJlZnMpIHNob3VsZCBub3QgaW50ZXJydXB0XG4gIC8vIGRlbGV0aW9uLCBzbyBkb24ndCBsZXQgdGhlbSB0aHJvdy4gSG9zdC1vcmlnaW5hdGluZyBlcnJvcnMgc2hvdWxkXG4gIC8vIGludGVycnVwdCBkZWxldGlvbiwgc28gaXQncyBva2F5XG4gIGZ1bmN0aW9uIGNvbW1pdFVubW91bnQoY3VycmVudCkge1xuICAgIGlmICh0eXBlb2Ygb25Db21taXRVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvbkNvbW1pdFVubW91bnQoY3VycmVudCk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChjdXJyZW50LnRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50KTtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBjdXJyZW50LnN0YXRlTm9kZTtcbiAgICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoY3VycmVudCwgaW5zdGFuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQ2FsbENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKGN1cnJlbnQuc3RhdGVOb2RlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFRPRE86IHRoaXMgaXMgcmVjdXJzaXZlLlxuICAgICAgICAgIC8vIFdlIGFyZSBhbHNvIG5vdCB1c2luZyB0aGlzIHBhcmVudCBiZWNhdXNlXG4gICAgICAgICAgLy8gdGhlIHBvcnRhbCB3aWxsIGdldCBwdXNoZWQgaW1tZWRpYXRlbHkuXG4gICAgICAgICAgaWYgKGVuYWJsZU11dGF0aW5nUmVjb25jaWxlciAmJiBtdXRhdGlvbikge1xuICAgICAgICAgICAgdW5tb3VudEhvc3RDb21wb25lbnRzKGN1cnJlbnQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZW5hYmxlUGVyc2lzdGVudFJlY29uY2lsZXIgJiYgcGVyc2lzdGVuY2UpIHtcbiAgICAgICAgICAgIGVtcHR5UG9ydGFsQ29udGFpbmVyKGN1cnJlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXROZXN0ZWRVbm1vdW50cyhyb290KSB7XG4gICAgLy8gV2hpbGUgd2UncmUgaW5zaWRlIGEgcmVtb3ZlZCBob3N0IG5vZGUgd2UgZG9uJ3Qgd2FudCB0byBjYWxsXG4gICAgLy8gcmVtb3ZlQ2hpbGQgb24gdGhlIGlubmVyIG5vZGVzIGJlY2F1c2UgdGhleSdyZSByZW1vdmVkIGJ5IHRoZSB0b3BcbiAgICAvLyBjYWxsIGFueXdheS4gV2UgYWxzbyB3YW50IHRvIGNhbGwgY29tcG9uZW50V2lsbFVubW91bnQgb24gYWxsXG4gICAgLy8gY29tcG9zaXRlcyBiZWZvcmUgdGhpcyBob3N0IG5vZGUgaXMgcmVtb3ZlZCBmcm9tIHRoZSB0cmVlLiBUaGVyZWZvcmVcbiAgICB2YXIgbm9kZSA9IHJvb3Q7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbW1pdFVubW91bnQobm9kZSk7XG4gICAgICAvLyBWaXNpdCBjaGlsZHJlbiBiZWNhdXNlIHRoZXkgbWF5IGNvbnRhaW4gbW9yZSBjb21wb3NpdGUgb3IgaG9zdCBub2Rlcy5cbiAgICAgIC8vIFNraXAgcG9ydGFscyBiZWNhdXNlIGNvbW1pdFVubW91bnQoKSBjdXJyZW50bHkgdmlzaXRzIHRoZW0gcmVjdXJzaXZlbHkuXG4gICAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCAmJiAoXG4gICAgICAvLyBJZiB3ZSB1c2UgbXV0YXRpb24gd2UgZHJpbGwgZG93biBpbnRvIHBvcnRhbHMgdXNpbmcgY29tbWl0VW5tb3VudCBhYm92ZS5cbiAgICAgIC8vIElmIHdlIGRvbid0IHVzZSBtdXRhdGlvbiB3ZSBkcmlsbCBkb3duIGludG8gcG9ydGFscyBoZXJlIGluc3RlYWQuXG4gICAgICAhbXV0YXRpb24gfHwgbm9kZS50YWcgIT09IEhvc3RQb3J0YWwpKSB7XG4gICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IHJvb3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgbm9kZVsncmV0dXJuJ10gPT09IHJvb3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZXRhY2hGaWJlcihjdXJyZW50KSB7XG4gICAgLy8gQ3V0IG9mZiB0aGUgcmV0dXJuIHBvaW50ZXJzIHRvIGRpc2Nvbm5lY3QgaXQgZnJvbSB0aGUgdHJlZS4gSWRlYWxseSwgd2VcbiAgICAvLyBzaG91bGQgY2xlYXIgdGhlIGNoaWxkIHBvaW50ZXIgb2YgdGhlIHBhcmVudCBhbHRlcm5hdGUgdG8gbGV0IHRoaXNcbiAgICAvLyBnZXQgR0M6ZWQgYnV0IHdlIGRvbid0IGtub3cgd2hpY2ggZm9yIHN1cmUgd2hpY2ggcGFyZW50IGlzIHRoZSBjdXJyZW50XG4gICAgLy8gb25lIHNvIHdlJ2xsIHNldHRsZSBmb3IgR0M6aW5nIHRoZSBzdWJ0cmVlIG9mIHRoaXMgY2hpbGQuIFRoaXMgY2hpbGRcbiAgICAvLyBpdHNlbGYgd2lsbCBiZSBHQzplZCB3aGVuIHRoZSBwYXJlbnQgdXBkYXRlcyB0aGUgbmV4dCB0aW1lLlxuICAgIGN1cnJlbnRbJ3JldHVybiddID0gbnVsbDtcbiAgICBjdXJyZW50LmNoaWxkID0gbnVsbDtcbiAgICBpZiAoY3VycmVudC5hbHRlcm5hdGUpIHtcbiAgICAgIGN1cnJlbnQuYWx0ZXJuYXRlLmNoaWxkID0gbnVsbDtcbiAgICAgIGN1cnJlbnQuYWx0ZXJuYXRlWydyZXR1cm4nXSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFtdXRhdGlvbikge1xuICAgIHZhciBjb21taXRDb250YWluZXIgPSB2b2lkIDA7XG4gICAgaWYgKHBlcnNpc3RlbmNlKSB7XG4gICAgICB2YXIgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuID0gcGVyc2lzdGVuY2UucmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuLFxuICAgICAgICAgIGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0ID0gcGVyc2lzdGVuY2UuY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQ7XG5cbiAgICAgIHZhciBlbXB0eVBvcnRhbENvbnRhaW5lciA9IGZ1bmN0aW9uIChjdXJyZW50KSB7XG4gICAgICAgIHZhciBwb3J0YWwgPSBjdXJyZW50LnN0YXRlTm9kZTtcbiAgICAgICAgdmFyIGNvbnRhaW5lckluZm8gPSBwb3J0YWwuY29udGFpbmVySW5mbztcblxuICAgICAgICB2YXIgZW1wdHlDaGlsZFNldCA9IGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0KGNvbnRhaW5lckluZm8pO1xuICAgICAgICByZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4oY29udGFpbmVySW5mbywgZW1wdHlDaGlsZFNldCk7XG4gICAgICB9O1xuICAgICAgY29tbWl0Q29udGFpbmVyID0gZnVuY3Rpb24gKGZpbmlzaGVkV29yaykge1xuICAgICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgcG9ydGFsT3JSb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lckluZm8gPSBwb3J0YWxPclJvb3QuY29udGFpbmVySW5mbyxcbiAgICAgICAgICAgICAgICAgIF9wZW5kaW5nQ2hpbGRyZW4gPSBwb3J0YWxPclJvb3QucGVuZGluZ0NoaWxkcmVuO1xuXG4gICAgICAgICAgICAgIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbihjb250YWluZXJJbmZvLCBfcGVuZGluZ0NoaWxkcmVuKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21taXRDb250YWluZXIgPSBmdW5jdGlvbiAoZmluaXNoZWRXb3JrKSB7XG4gICAgICAgIC8vIE5vb3BcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChlbmFibGVQZXJzaXN0ZW50UmVjb25jaWxlciB8fCBlbmFibGVOb29wUmVjb25jaWxlcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29tbWl0UmVzZXRUZXh0Q29udGVudDogZnVuY3Rpb24gKGZpbmlzaGVkV29yaykge30sXG4gICAgICAgIGNvbW1pdFBsYWNlbWVudDogZnVuY3Rpb24gKGZpbmlzaGVkV29yaykge30sXG4gICAgICAgIGNvbW1pdERlbGV0aW9uOiBmdW5jdGlvbiAoY3VycmVudCkge1xuICAgICAgICAgIC8vIERldGFjaCByZWZzIGFuZCBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50KCkgb24gdGhlIHdob2xlIHN1YnRyZWUuXG4gICAgICAgICAgY29tbWl0TmVzdGVkVW5tb3VudHMoY3VycmVudCk7XG4gICAgICAgICAgZGV0YWNoRmliZXIoY3VycmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbW1pdFdvcms6IGZ1bmN0aW9uIChjdXJyZW50LCBmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgICBjb21taXRDb250YWluZXIoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb21taXRMaWZlQ3ljbGVzOiBjb21taXRMaWZlQ3ljbGVzLFxuICAgICAgICBjb21taXRBdHRhY2hSZWY6IGNvbW1pdEF0dGFjaFJlZixcbiAgICAgICAgY29tbWl0RGV0YWNoUmVmOiBjb21taXREZXRhY2hSZWZcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChwZXJzaXN0ZW5jZSkge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnUGVyc2lzdGVudCByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdOb29wIHJlY29uY2lsZXIgaXMgZGlzYWJsZWQuJyk7XG4gICAgfVxuICB9XG4gIHZhciBjb21taXRNb3VudCA9IG11dGF0aW9uLmNvbW1pdE1vdW50LFxuICAgICAgY29tbWl0VXBkYXRlID0gbXV0YXRpb24uY29tbWl0VXBkYXRlLFxuICAgICAgcmVzZXRUZXh0Q29udGVudCA9IG11dGF0aW9uLnJlc2V0VGV4dENvbnRlbnQsXG4gICAgICBjb21taXRUZXh0VXBkYXRlID0gbXV0YXRpb24uY29tbWl0VGV4dFVwZGF0ZSxcbiAgICAgIGFwcGVuZENoaWxkID0gbXV0YXRpb24uYXBwZW5kQ2hpbGQsXG4gICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyID0gbXV0YXRpb24uYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcixcbiAgICAgIGluc2VydEJlZm9yZSA9IG11dGF0aW9uLmluc2VydEJlZm9yZSxcbiAgICAgIGluc2VydEluQ29udGFpbmVyQmVmb3JlID0gbXV0YXRpb24uaW5zZXJ0SW5Db250YWluZXJCZWZvcmUsXG4gICAgICByZW1vdmVDaGlsZCA9IG11dGF0aW9uLnJlbW92ZUNoaWxkLFxuICAgICAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyID0gbXV0YXRpb24ucmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyO1xuXG5cbiAgZnVuY3Rpb24gZ2V0SG9zdFBhcmVudEZpYmVyKGZpYmVyKSB7XG4gICAgdmFyIHBhcmVudCA9IGZpYmVyWydyZXR1cm4nXTtcbiAgICB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICBpZiAoaXNIb3N0UGFyZW50KHBhcmVudCkpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudFsncmV0dXJuJ107XG4gICAgfVxuICAgIGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHRvIGZpbmQgYSBob3N0IHBhcmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSG9zdFBhcmVudChmaWJlcikge1xuICAgIHJldHVybiBmaWJlci50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgZmliZXIudGFnID09PSBIb3N0Um9vdCB8fCBmaWJlci50YWcgPT09IEhvc3RQb3J0YWw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRIb3N0U2libGluZyhmaWJlcikge1xuICAgIC8vIFdlJ3JlIGdvaW5nIHRvIHNlYXJjaCBmb3J3YXJkIGludG8gdGhlIHRyZWUgdW50aWwgd2UgZmluZCBhIHNpYmxpbmcgaG9zdFxuICAgIC8vIG5vZGUuIFVuZm9ydHVuYXRlbHksIGlmIG11bHRpcGxlIGluc2VydGlvbnMgYXJlIGRvbmUgaW4gYSByb3cgd2UgaGF2ZSB0b1xuICAgIC8vIHNlYXJjaCBwYXN0IHRoZW0uIFRoaXMgbGVhZHMgdG8gZXhwb25lbnRpYWwgc2VhcmNoIGZvciB0aGUgbmV4dCBzaWJsaW5nLlxuICAgIHZhciBub2RlID0gZmliZXI7XG4gICAgc2libGluZ3M6IHdoaWxlICh0cnVlKSB7XG4gICAgICAvLyBJZiB3ZSBkaWRuJ3QgZmluZCBhbnl0aGluZywgbGV0J3MgdHJ5IHRoZSBuZXh0IHNpYmxpbmcuXG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlWydyZXR1cm4nXSA9PT0gbnVsbCB8fCBpc0hvc3RQYXJlbnQobm9kZVsncmV0dXJuJ10pKSB7XG4gICAgICAgICAgLy8gSWYgd2UgcG9wIG91dCBvZiB0aGUgcm9vdCBvciBoaXQgdGhlIHBhcmVudCB0aGUgZmliZXIgd2UgYXJlIHRoZVxuICAgICAgICAgIC8vIGxhc3Qgc2libGluZy5cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgd2hpbGUgKG5vZGUudGFnICE9PSBIb3N0Q29tcG9uZW50ICYmIG5vZGUudGFnICE9PSBIb3N0VGV4dCkge1xuICAgICAgICAvLyBJZiBpdCBpcyBub3QgaG9zdCBub2RlIGFuZCwgd2UgbWlnaHQgaGF2ZSBhIGhvc3Qgbm9kZSBpbnNpZGUgaXQuXG4gICAgICAgIC8vIFRyeSB0byBzZWFyY2ggZG93biB1bnRpbCB3ZSBmaW5kIG9uZS5cbiAgICAgICAgaWYgKG5vZGUuZWZmZWN0VGFnICYgUGxhY2VtZW50KSB7XG4gICAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGNoaWxkLCB0cnkgdGhlIHNpYmxpbmdzIGluc3RlYWQuXG4gICAgICAgICAgY29udGludWUgc2libGluZ3M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGNoaWxkLCB0cnkgdGhlIHNpYmxpbmdzIGluc3RlYWQuXG4gICAgICAgIC8vIFdlIGFsc28gc2tpcCBwb3J0YWxzIGJlY2F1c2UgdGhleSBhcmUgbm90IHBhcnQgb2YgdGhpcyBob3N0IHRyZWUuXG4gICAgICAgIGlmIChub2RlLmNoaWxkID09PSBudWxsIHx8IG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgICAgY29udGludWUgc2libGluZ3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGhvc3Qgbm9kZSBpcyBzdGFibGUgb3IgYWJvdXQgdG8gYmUgcGxhY2VkLlxuICAgICAgaWYgKCEobm9kZS5lZmZlY3RUYWcgJiBQbGFjZW1lbnQpKSB7XG4gICAgICAgIC8vIEZvdW5kIGl0IVxuICAgICAgICByZXR1cm4gbm9kZS5zdGF0ZU5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0UGxhY2VtZW50KGZpbmlzaGVkV29yaykge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGluc2VydCBhbGwgaG9zdCBub2RlcyBpbnRvIHRoZSBwYXJlbnQuXG4gICAgdmFyIHBhcmVudEZpYmVyID0gZ2V0SG9zdFBhcmVudEZpYmVyKGZpbmlzaGVkV29yayk7XG4gICAgdmFyIHBhcmVudCA9IHZvaWQgMDtcbiAgICB2YXIgaXNDb250YWluZXIgPSB2b2lkIDA7XG4gICAgc3dpdGNoIChwYXJlbnRGaWJlci50YWcpIHtcbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgcGFyZW50ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICBpc0NvbnRhaW5lciA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHBhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICBpc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICBwYXJlbnQgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgaXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgaG9zdCBwYXJlbnQgZmliZXIuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICAgIGlmIChwYXJlbnRGaWJlci5lZmZlY3RUYWcgJiBDb250ZW50UmVzZXQpIHtcbiAgICAgIC8vIFJlc2V0IHRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIHBhcmVudCBiZWZvcmUgZG9pbmcgYW55IGluc2VydGlvbnNcbiAgICAgIHJlc2V0VGV4dENvbnRlbnQocGFyZW50KTtcbiAgICAgIC8vIENsZWFyIENvbnRlbnRSZXNldCBmcm9tIHRoZSBlZmZlY3QgdGFnXG4gICAgICBwYXJlbnRGaWJlci5lZmZlY3RUYWcgJj0gfkNvbnRlbnRSZXNldDtcbiAgICB9XG5cbiAgICB2YXIgYmVmb3JlID0gZ2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTtcbiAgICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBpbnNlcnRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG4gICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgIHZhciBub2RlID0gZmluaXNoZWRXb3JrO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgICBpZiAoaXNDb250YWluZXIpIHtcbiAgICAgICAgICAgIGluc2VydEluQ29udGFpbmVyQmVmb3JlKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUsIGJlZm9yZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluc2VydEJlZm9yZShwYXJlbnQsIG5vZGUuc3RhdGVOb2RlLCBiZWZvcmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaXNDb250YWluZXIpIHtcbiAgICAgICAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXIocGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFwcGVuZENoaWxkKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAvLyBJZiB0aGUgaW5zZXJ0aW9uIGl0c2VsZiBpcyBhIHBvcnRhbCwgdGhlbiB3ZSBkb24ndCB3YW50IHRvIHRyYXZlcnNlXG4gICAgICAgIC8vIGRvd24gaXRzIGNoaWxkcmVuLiBJbnN0ZWFkLCB3ZSdsbCBnZXQgaW5zZXJ0aW9ucyBmcm9tIGVhY2ggY2hpbGQgaW5cbiAgICAgICAgLy8gdGhlIHBvcnRhbCBkaXJlY3RseS5cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSBmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgbm9kZVsncmV0dXJuJ10gPT09IGZpbmlzaGVkV29yaykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVubW91bnRIb3N0Q29tcG9uZW50cyhjdXJyZW50KSB7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgaW5zZXJ0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIHZhciBub2RlID0gY3VycmVudDtcblxuICAgIC8vIEVhY2ggaXRlcmF0aW9uLCBjdXJyZW50UGFyZW50IGlzIHBvcHVsYXRlZCB3aXRoIG5vZGUncyBob3N0IHBhcmVudCBpZiBub3RcbiAgICAvLyBjdXJyZW50UGFyZW50SXNWYWxpZC5cbiAgICB2YXIgY3VycmVudFBhcmVudElzVmFsaWQgPSBmYWxzZTtcbiAgICB2YXIgY3VycmVudFBhcmVudCA9IHZvaWQgMDtcbiAgICB2YXIgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdm9pZCAwO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmICghY3VycmVudFBhcmVudElzVmFsaWQpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgICBmaW5kUGFyZW50OiB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICEocGFyZW50ICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHRvIGZpbmQgYSBob3N0IHBhcmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgICBzd2l0Y2ggKHBhcmVudC50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhayBmaW5kUGFyZW50O1xuICAgICAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgICAgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgICAgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyZW50ID0gcGFyZW50WydyZXR1cm4nXTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50UGFyZW50SXNWYWxpZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgY29tbWl0TmVzdGVkVW5tb3VudHMobm9kZSk7XG4gICAgICAgIC8vIEFmdGVyIGFsbCB0aGUgY2hpbGRyZW4gaGF2ZSB1bm1vdW50ZWQsIGl0IGlzIG5vdyBzYWZlIHRvIHJlbW92ZSB0aGVcbiAgICAgICAgLy8gbm9kZSBmcm9tIHRoZSB0cmVlLlxuICAgICAgICBpZiAoY3VycmVudFBhcmVudElzQ29udGFpbmVyKSB7XG4gICAgICAgICAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyKGN1cnJlbnRQYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmVDaGlsZChjdXJyZW50UGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG9uJ3QgdmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB3ZSBhbHJlYWR5IHZpc2l0ZWQgdGhlbS5cbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgLy8gV2hlbiB3ZSBnbyBpbnRvIGEgcG9ydGFsLCBpdCBiZWNvbWVzIHRoZSBwYXJlbnQgdG8gcmVtb3ZlIGZyb20uXG4gICAgICAgIC8vIFdlIHdpbGwgcmVhc3NpZ24gaXQgYmFjayB3aGVuIHdlIHBvcCB0aGUgcG9ydGFsIG9uIHRoZSB3YXkgdXAuXG4gICAgICAgIGN1cnJlbnRQYXJlbnQgPSBub2RlLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAvLyBWaXNpdCBjaGlsZHJlbiBiZWNhdXNlIHBvcnRhbHMgbWlnaHQgY29udGFpbiBob3N0IGNvbXBvbmVudHMuXG4gICAgICAgIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21taXRVbm1vdW50KG5vZGUpO1xuICAgICAgICAvLyBWaXNpdCBjaGlsZHJlbiBiZWNhdXNlIHdlIG1heSBmaW5kIG1vcmUgaG9zdCBjb21wb25lbnRzIGJlbG93LlxuICAgICAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgbm9kZVsncmV0dXJuJ10gPT09IGN1cnJlbnQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgICAvLyBXaGVuIHdlIGdvIG91dCBvZiB0aGUgcG9ydGFsLCB3ZSBuZWVkIHRvIHJlc3RvcmUgdGhlIHBhcmVudC5cbiAgICAgICAgICAvLyBTaW5jZSB3ZSBkb24ndCBrZWVwIGEgc3RhY2sgb2YgdGhlbSwgd2Ugd2lsbCBzZWFyY2ggZm9yIGl0LlxuICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0RGVsZXRpb24oY3VycmVudCkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGRlbGV0ZSBhbGwgaG9zdCBub2RlcyBmcm9tIHRoZSBwYXJlbnQuXG4gICAgLy8gRGV0YWNoIHJlZnMgYW5kIGNhbGwgY29tcG9uZW50V2lsbFVubW91bnQoKSBvbiB0aGUgd2hvbGUgc3VidHJlZS5cbiAgICB1bm1vdW50SG9zdENvbXBvbmVudHMoY3VycmVudCk7XG4gICAgZGV0YWNoRmliZXIoY3VycmVudCk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRXb3JrKGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICBpZiAoaW5zdGFuY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQ29tbWl0IHRoZSB3b3JrIHByZXBhcmVkIGVhcmxpZXIuXG4gICAgICAgICAgICB2YXIgbmV3UHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIC8vIEZvciBoeWRyYXRpb24gd2UgcmV1c2UgdGhlIHVwZGF0ZSBwYXRoIGJ1dCB3ZSB0cmVhdCB0aGUgb2xkUHJvcHNcbiAgICAgICAgICAgIC8vIGFzIHRoZSBuZXdQcm9wcy4gVGhlIHVwZGF0ZVBheWxvYWQgd2lsbCBjb250YWluIHRoZSByZWFsIGNoYW5nZSBpblxuICAgICAgICAgICAgLy8gdGhpcyBjYXNlLlxuICAgICAgICAgICAgdmFyIG9sZFByb3BzID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG5ld1Byb3BzO1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBmaW5pc2hlZFdvcmsudHlwZTtcbiAgICAgICAgICAgIC8vIFRPRE86IFR5cGUgdGhlIHVwZGF0ZVF1ZXVlIHRvIGJlIHNwZWNpZmljIHRvIGhvc3QgY29tcG9uZW50cy5cbiAgICAgICAgICAgIHZhciB1cGRhdGVQYXlsb2FkID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICAgICAgICAgICAgZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh1cGRhdGVQYXlsb2FkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGNvbW1pdFVwZGF0ZShpbnN0YW5jZSwgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgIHtcbiAgICAgICAgICAhKGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnVGhpcyBzaG91bGQgaGF2ZSBhIHRleHQgbm9kZSBpbml0aWFsaXplZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgICB2YXIgdGV4dEluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICB2YXIgbmV3VGV4dCA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIC8vIEZvciBoeWRyYXRpb24gd2UgcmV1c2UgdGhlIHVwZGF0ZSBwYXRoIGJ1dCB3ZSB0cmVhdCB0aGUgb2xkUHJvcHNcbiAgICAgICAgICAvLyBhcyB0aGUgbmV3UHJvcHMuIFRoZSB1cGRhdGVQYXlsb2FkIHdpbGwgY29udGFpbiB0aGUgcmVhbCBjaGFuZ2UgaW5cbiAgICAgICAgICAvLyB0aGlzIGNhc2UuXG4gICAgICAgICAgdmFyIG9sZFRleHQgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogbmV3VGV4dDtcbiAgICAgICAgICBjb21taXRUZXh0VXBkYXRlKHRleHRJbnN0YW5jZSwgb2xkVGV4dCwgbmV3VGV4dCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVGhpcyB1bml0IG9mIHdvcmsgdGFnIHNob3VsZCBub3QgaGF2ZSBzaWRlLWVmZmVjdHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRSZXNldFRleHRDb250ZW50KGN1cnJlbnQpIHtcbiAgICByZXNldFRleHRDb250ZW50KGN1cnJlbnQuc3RhdGVOb2RlKTtcbiAgfVxuXG4gIGlmIChlbmFibGVNdXRhdGluZ1JlY29uY2lsZXIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tbWl0UmVzZXRUZXh0Q29udGVudDogY29tbWl0UmVzZXRUZXh0Q29udGVudCxcbiAgICAgIGNvbW1pdFBsYWNlbWVudDogY29tbWl0UGxhY2VtZW50LFxuICAgICAgY29tbWl0RGVsZXRpb246IGNvbW1pdERlbGV0aW9uLFxuICAgICAgY29tbWl0V29yazogY29tbWl0V29yayxcbiAgICAgIGNvbW1pdExpZmVDeWNsZXM6IGNvbW1pdExpZmVDeWNsZXMsXG4gICAgICBjb21taXRBdHRhY2hSZWY6IGNvbW1pdEF0dGFjaFJlZixcbiAgICAgIGNvbW1pdERldGFjaFJlZjogY29tbWl0RGV0YWNoUmVmXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBpbnZhcmlhbnQoZmFsc2UsICdNdXRhdGluZyByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICB9XG59O1xuXG52YXIgTk9fQ09OVEVYVCA9IHt9O1xuXG52YXIgUmVhY3RGaWJlckhvc3RDb250ZXh0ID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICB2YXIgZ2V0Q2hpbGRIb3N0Q29udGV4dCA9IGNvbmZpZy5nZXRDaGlsZEhvc3RDb250ZXh0LFxuICAgICAgZ2V0Um9vdEhvc3RDb250ZXh0ID0gY29uZmlnLmdldFJvb3RIb3N0Q29udGV4dDtcblxuXG4gIHZhciBjb250ZXh0U3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG4gIHZhciBjb250ZXh0RmliZXJTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihOT19DT05URVhUKTtcbiAgdmFyIHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xuXG4gIGZ1bmN0aW9uIHJlcXVpcmVkQ29udGV4dChjKSB7XG4gICAgIShjICE9PSBOT19DT05URVhUKSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIGhvc3QgY29udGV4dCB0byBleGlzdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gYztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFJvb3RIb3N0Q29udGFpbmVyKCkge1xuICAgIHZhciByb290SW5zdGFuY2UgPSByZXF1aXJlZENvbnRleHQocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCk7XG4gICAgcmV0dXJuIHJvb3RJbnN0YW5jZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hIb3N0Q29udGFpbmVyKGZpYmVyLCBuZXh0Um9vdEluc3RhbmNlKSB7XG4gICAgLy8gUHVzaCBjdXJyZW50IHJvb3QgaW5zdGFuY2Ugb250byB0aGUgc3RhY2s7XG4gICAgLy8gVGhpcyBhbGxvd3MgdXMgdG8gcmVzZXQgcm9vdCB3aGVuIHBvcnRhbHMgYXJlIHBvcHBlZC5cbiAgICBwdXNoKHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLCBuZXh0Um9vdEluc3RhbmNlLCBmaWJlcik7XG5cbiAgICB2YXIgbmV4dFJvb3RDb250ZXh0ID0gZ2V0Um9vdEhvc3RDb250ZXh0KG5leHRSb290SW5zdGFuY2UpO1xuXG4gICAgLy8gVHJhY2sgdGhlIGNvbnRleHQgYW5kIHRoZSBGaWJlciB0aGF0IHByb3ZpZGVkIGl0LlxuICAgIC8vIFRoaXMgZW5hYmxlcyB1cyB0byBwb3Agb25seSBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cbiAgICBwdXNoKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpO1xuICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBuZXh0Um9vdENvbnRleHQsIGZpYmVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvcEhvc3RDb250YWluZXIoZmliZXIpIHtcbiAgICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgcG9wKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgcG9wKHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRIb3N0Q29udGV4dCgpIHtcbiAgICB2YXIgY29udGV4dCA9IHJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCk7XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoSG9zdENvbnRleHQoZmliZXIpIHtcbiAgICB2YXIgcm9vdEluc3RhbmNlID0gcmVxdWlyZWRDb250ZXh0KHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICAgIHZhciBjb250ZXh0ID0gcmVxdWlyZWRDb250ZXh0KGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgICB2YXIgbmV4dENvbnRleHQgPSBnZXRDaGlsZEhvc3RDb250ZXh0KGNvbnRleHQsIGZpYmVyLnR5cGUsIHJvb3RJbnN0YW5jZSk7XG5cbiAgICAvLyBEb24ndCBwdXNoIHRoaXMgRmliZXIncyBjb250ZXh0IHVubGVzcyBpdCdzIHVuaXF1ZS5cbiAgICBpZiAoY29udGV4dCA9PT0gbmV4dENvbnRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUcmFjayB0aGUgY29udGV4dCBhbmQgdGhlIEZpYmVyIHRoYXQgcHJvdmlkZWQgaXQuXG4gICAgLy8gVGhpcyBlbmFibGVzIHVzIHRvIHBvcCBvbmx5IEZpYmVycyB0aGF0IHByb3ZpZGUgdW5pcXVlIGNvbnRleHRzLlxuICAgIHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlcik7XG4gICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG5leHRDb250ZXh0LCBmaWJlcik7XG4gIH1cblxuICBmdW5jdGlvbiBwb3BIb3N0Q29udGV4dChmaWJlcikge1xuICAgIC8vIERvIG5vdCBwb3AgdW5sZXNzIHRoaXMgRmliZXIgcHJvdmlkZWQgdGhlIGN1cnJlbnQgY29udGV4dC5cbiAgICAvLyBwdXNoSG9zdENvbnRleHQoKSBvbmx5IHB1c2hlcyBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cbiAgICBpZiAoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IuY3VycmVudCAhPT0gZmliZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgcG9wKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldEhvc3RDb250YWluZXIoKSB7XG4gICAgY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQgPSBOT19DT05URVhUO1xuICAgIHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQgPSBOT19DT05URVhUO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBnZXRIb3N0Q29udGV4dDogZ2V0SG9zdENvbnRleHQsXG4gICAgZ2V0Um9vdEhvc3RDb250YWluZXI6IGdldFJvb3RIb3N0Q29udGFpbmVyLFxuICAgIHBvcEhvc3RDb250YWluZXI6IHBvcEhvc3RDb250YWluZXIsXG4gICAgcG9wSG9zdENvbnRleHQ6IHBvcEhvc3RDb250ZXh0LFxuICAgIHB1c2hIb3N0Q29udGFpbmVyOiBwdXNoSG9zdENvbnRhaW5lcixcbiAgICBwdXNoSG9zdENvbnRleHQ6IHB1c2hIb3N0Q29udGV4dCxcbiAgICByZXNldEhvc3RDb250YWluZXI6IHJlc2V0SG9zdENvbnRhaW5lclxuICB9O1xufTtcblxudmFyIFJlYWN0RmliZXJIeWRyYXRpb25Db250ZXh0ID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICB2YXIgc2hvdWxkU2V0VGV4dENvbnRlbnQgPSBjb25maWcuc2hvdWxkU2V0VGV4dENvbnRlbnQsXG4gICAgICBoeWRyYXRpb24gPSBjb25maWcuaHlkcmF0aW9uO1xuXG4gIC8vIElmIHRoaXMgZG9lc24ndCBoYXZlIGh5ZHJhdGlvbiBtb2RlLlxuXG4gIGlmICghaHlkcmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVudGVySHlkcmF0aW9uU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGU6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2U6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfSxcbiAgICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfSxcbiAgICAgIHBvcEh5ZHJhdGlvblN0YXRlOiBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB2YXIgY2FuSHlkcmF0ZUluc3RhbmNlID0gaHlkcmF0aW9uLmNhbkh5ZHJhdGVJbnN0YW5jZSxcbiAgICAgIGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UgPSBoeWRyYXRpb24uY2FuSHlkcmF0ZVRleHRJbnN0YW5jZSxcbiAgICAgIGdldE5leHRIeWRyYXRhYmxlU2libGluZyA9IGh5ZHJhdGlvbi5nZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcsXG4gICAgICBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZCA9IGh5ZHJhdGlvbi5nZXRGaXJzdEh5ZHJhdGFibGVDaGlsZCxcbiAgICAgIGh5ZHJhdGVJbnN0YW5jZSA9IGh5ZHJhdGlvbi5oeWRyYXRlSW5zdGFuY2UsXG4gICAgICBoeWRyYXRlVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmh5ZHJhdGVUZXh0SW5zdGFuY2UsXG4gICAgICBkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2UsXG4gICAgICBkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UsXG4gICAgICBkaWROb3RIeWRyYXRlQ29udGFpbmVySW5zdGFuY2UgPSBoeWRyYXRpb24uZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlLFxuICAgICAgZGlkTm90SHlkcmF0ZUluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEh5ZHJhdGVJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2UgPSBoeWRyYXRpb24uZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVyVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVyVGV4dEluc3RhbmNlLFxuICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlLFxuICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UgPSBoeWRyYXRpb24uZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2U7XG5cbiAgLy8gVGhlIGRlZXBlc3QgRmliZXIgb24gdGhlIHN0YWNrIGludm9sdmVkIGluIGEgaHlkcmF0aW9uIGNvbnRleHQuXG4gIC8vIFRoaXMgbWF5IGhhdmUgYmVlbiBhbiBpbnNlcnRpb24gb3IgYSBoeWRyYXRpb24uXG5cbiAgdmFyIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gbnVsbDtcbiAgdmFyIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsO1xuICB2YXIgaXNIeWRyYXRpbmcgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBlbnRlckh5ZHJhdGlvblN0YXRlKGZpYmVyKSB7XG4gICAgdmFyIHBhcmVudEluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKHBhcmVudEluc3RhbmNlKTtcbiAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgIGlzSHlkcmF0aW5nID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZShyZXR1cm5GaWJlciwgaW5zdGFuY2UpIHtcbiAgICB7XG4gICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIGRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZShyZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbywgaW5zdGFuY2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgZGlkTm90SHlkcmF0ZUluc3RhbmNlKHJldHVybkZpYmVyLnR5cGUsIHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHMsIHJldHVybkZpYmVyLnN0YXRlTm9kZSwgaW5zdGFuY2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGlsZFRvRGVsZXRlID0gY3JlYXRlRmliZXJGcm9tSG9zdEluc3RhbmNlRm9yRGVsZXRpb24oKTtcbiAgICBjaGlsZFRvRGVsZXRlLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuICAgIGNoaWxkVG9EZWxldGVbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgY2hpbGRUb0RlbGV0ZS5lZmZlY3RUYWcgPSBEZWxldGlvbjtcblxuICAgIC8vIFRoaXMgbWlnaHQgc2VlbSBsaWtlIGl0IGJlbG9uZ3Mgb24gcHJvZ3Jlc3NlZEZpcnN0RGVsZXRpb24uIEhvd2V2ZXIsXG4gICAgLy8gdGhlc2UgY2hpbGRyZW4gYXJlIG5vdCBwYXJ0IG9mIHRoZSByZWNvbmNpbGlhdGlvbiBsaXN0IG9mIGNoaWxkcmVuLlxuICAgIC8vIEV2ZW4gaWYgd2UgYWJvcnQgYW5kIHJlcmVjb25jaWxlIHRoZSBjaGlsZHJlbiwgdGhhdCB3aWxsIHRyeSB0byBoeWRyYXRlXG4gICAgLy8gYWdhaW4gYW5kIHRoZSBub2RlcyBhcmUgc3RpbGwgaW4gdGhlIGhvc3QgdHJlZSBzbyB0aGVzZSB3aWxsIGJlXG4gICAgLy8gcmVjcmVhdGVkLlxuICAgIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShyZXR1cm5GaWJlciwgZmliZXIpIHtcbiAgICBmaWJlci5lZmZlY3RUYWcgfD0gUGxhY2VtZW50O1xuICAgIHtcbiAgICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBhcmVudENvbnRhaW5lciA9IHJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHR5cGUsIHByb3BzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHRleHQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBhcmVudFR5cGUgPSByZXR1cm5GaWJlci50eXBlO1xuICAgICAgICAgICAgdmFyIHBhcmVudFByb3BzID0gcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIHZhciBwYXJlbnRJbnN0YW5jZSA9IHJldHVybkZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgICB2YXIgX3R5cGUgPSBmaWJlci50eXBlO1xuICAgICAgICAgICAgICAgIHZhciBfcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIF90eXBlLCBfcHJvcHMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICAgICAgICAgIHZhciBfdGV4dCA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIF90ZXh0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSB7XG4gICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICB2YXIgcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gY2FuSHlkcmF0ZUluc3RhbmNlKG5leHRJbnN0YW5jZSwgdHlwZSwgcHJvcHMpO1xuICAgICAgICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZmliZXIuc3RhdGVOb2RlID0gaW5zdGFuY2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHRleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgdmFyIHRleHRJbnN0YW5jZSA9IGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UobmV4dEluc3RhbmNlLCB0ZXh0KTtcbiAgICAgICAgICBpZiAodGV4dEluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmaWJlci5zdGF0ZU5vZGUgPSB0ZXh0SW5zdGFuY2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2UoZmliZXIpIHtcbiAgICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBuZXh0SW5zdGFuY2UgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlO1xuICAgIGlmICghbmV4dEluc3RhbmNlKSB7XG4gICAgICAvLyBOb3RoaW5nIHRvIGh5ZHJhdGUuIE1ha2UgaXQgYW4gaW5zZXJ0aW9uLlxuICAgICAgaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgZmliZXIpO1xuICAgICAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSkge1xuICAgICAgLy8gSWYgd2UgY2FuJ3QgaHlkcmF0ZSB0aGlzIGluc3RhbmNlIGxldCdzIHRyeSB0aGUgbmV4dCBvbmUuXG4gICAgICAvLyBXZSB1c2UgdGhpcyBhcyBhIGhldXJpc3RpYy4gSXQncyBiYXNlZCBvbiBpbnR1aXRpb24gYW5kIG5vdCBkYXRhIHNvIGl0XG4gICAgICAvLyBtaWdodCBiZSBmbGF3ZWQgb3IgdW5uZWNlc3NhcnkuXG4gICAgICBuZXh0SW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobmV4dEluc3RhbmNlKTtcbiAgICAgIGlmICghbmV4dEluc3RhbmNlIHx8ICF0cnlIeWRyYXRlKGZpYmVyLCBuZXh0SW5zdGFuY2UpKSB7XG4gICAgICAgIC8vIE5vdGhpbmcgdG8gaHlkcmF0ZS4gTWFrZSBpdCBhbiBpbnNlcnRpb24uXG4gICAgICAgIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIGZpYmVyKTtcbiAgICAgICAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgbmV4dCBvbmUsIHdlJ2xsIG5vdyBhc3N1bWUgdGhhdCB0aGUgZmlyc3Qgb25lIHdhc1xuICAgICAgLy8gc3VwZXJmbHVvdXMgYW5kIHdlJ2xsIGRlbGV0ZSBpdC4gU2luY2Ugd2UgY2FuJ3QgZWFnZXJseSBkZWxldGUgaXRcbiAgICAgIC8vIHdlJ2xsIGhhdmUgdG8gc2NoZWR1bGUgYSBkZWxldGlvbi4gVG8gZG8gdGhhdCwgdGhpcyBub2RlIG5lZWRzIGEgZHVtbXlcbiAgICAgIC8vIGZpYmVyIGFzc29jaWF0ZWQgd2l0aCBpdC5cbiAgICAgIGRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSk7XG4gICAgfVxuICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKG5leHRJbnN0YW5jZSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKGZpYmVyLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0KSB7XG4gICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICAgIHZhciB1cGRhdGVQYXlsb2FkID0gaHlkcmF0ZUluc3RhbmNlKGluc3RhbmNlLCBmaWJlci50eXBlLCBmaWJlci5tZW1vaXplZFByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBmaWJlcik7XG4gICAgLy8gVE9ETzogVHlwZSB0aGlzIHNwZWNpZmljIHRvIHRoaXMgdHlwZSBvZiBjb21wb25lbnQuXG4gICAgZmliZXIudXBkYXRlUXVldWUgPSB1cGRhdGVQYXlsb2FkO1xuICAgIC8vIElmIHRoZSB1cGRhdGUgcGF5bG9hZCBpbmRpY2F0ZXMgdGhhdCB0aGVyZSBpcyBhIGNoYW5nZSBvciBpZiB0aGVyZVxuICAgIC8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLlxuICAgIGlmICh1cGRhdGVQYXlsb2FkICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UoZmliZXIpIHtcbiAgICB2YXIgdGV4dEluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICAgIHZhciB0ZXh0Q29udGVudCA9IGZpYmVyLm1lbW9pemVkUHJvcHM7XG4gICAgdmFyIHNob3VsZFVwZGF0ZSA9IGh5ZHJhdGVUZXh0SW5zdGFuY2UodGV4dEluc3RhbmNlLCB0ZXh0Q29udGVudCwgZmliZXIpO1xuICAgIHtcbiAgICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgICAgLy8gV2UgYXNzdW1lIHRoYXQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UgaXMgY2FsbGVkIGluIGEgY29udGV4dCB3aGVyZSB0aGVcbiAgICAgICAgLy8gaHlkcmF0aW9uIHBhcmVudCBpcyB0aGUgcGFyZW50IGhvc3QgY29tcG9uZW50IG9mIHRoaXMgaG9zdCB0ZXh0LlxuICAgICAgICB2YXIgcmV0dXJuRmliZXIgPSBoeWRyYXRpb25QYXJlbnRGaWJlcjtcbiAgICAgICAgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50Q29udGFpbmVyID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50VHlwZSA9IHJldHVybkZpYmVyLnR5cGU7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudFByb3BzID0gcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50SW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaG91bGRVcGRhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKSB7XG4gICAgdmFyIHBhcmVudCA9IGZpYmVyWydyZXR1cm4nXTtcbiAgICB3aGlsZSAocGFyZW50ICE9PSBudWxsICYmIHBhcmVudC50YWcgIT09IEhvc3RDb21wb25lbnQgJiYgcGFyZW50LnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudFsncmV0dXJuJ107XG4gICAgfVxuICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gcGFyZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wSHlkcmF0aW9uU3RhdGUoZmliZXIpIHtcbiAgICBpZiAoZmliZXIgIT09IGh5ZHJhdGlvblBhcmVudEZpYmVyKSB7XG4gICAgICAvLyBXZSdyZSBkZWVwZXIgdGhhbiB0aGUgY3VycmVudCBoeWRyYXRpb24gY29udGV4dCwgaW5zaWRlIGFuIGluc2VydGVkXG4gICAgICAvLyB0cmVlLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgICAvLyBJZiB3ZSdyZSBub3QgY3VycmVudGx5IGh5ZHJhdGluZyBidXQgd2UncmUgaW4gYSBoeWRyYXRpb24gY29udGV4dCwgdGhlblxuICAgICAgLy8gd2Ugd2VyZSBhbiBpbnNlcnRpb24gYW5kIG5vdyBuZWVkIHRvIHBvcCB1cCByZWVudGVyIGh5ZHJhdGlvbiBvZiBvdXJcbiAgICAgIC8vIHNpYmxpbmdzLlxuICAgICAgcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7XG4gICAgICBpc0h5ZHJhdGluZyA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHR5cGUgPSBmaWJlci50eXBlO1xuXG4gICAgLy8gSWYgd2UgaGF2ZSBhbnkgcmVtYWluaW5nIGh5ZHJhdGFibGUgbm9kZXMsIHdlIG5lZWQgdG8gZGVsZXRlIHRoZW0gbm93LlxuICAgIC8vIFdlIG9ubHkgZG8gdGhpcyBkZWVwZXIgdGhhbiBoZWFkIGFuZCBib2R5IHNpbmNlIHRoZXkgdGVuZCB0byBoYXZlIHJhbmRvbVxuICAgIC8vIG90aGVyIG5vZGVzIGluIHRoZW0uIFdlIGFsc28gaWdub3JlIGNvbXBvbmVudHMgd2l0aCBwdXJlIHRleHQgY29udGVudCBpblxuICAgIC8vIHNpZGUgb2YgdGhlbS5cbiAgICAvLyBUT0RPOiBCZXR0ZXIgaGV1cmlzdGljLlxuICAgIGlmIChmaWJlci50YWcgIT09IEhvc3RDb21wb25lbnQgfHwgdHlwZSAhPT0gJ2hlYWQnICYmIHR5cGUgIT09ICdib2R5JyAmJiAhc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgZmliZXIubWVtb2l6ZWRQcm9wcykpIHtcbiAgICAgIHZhciBuZXh0SW5zdGFuY2UgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlO1xuICAgICAgd2hpbGUgKG5leHRJbnN0YW5jZSkge1xuICAgICAgICBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UoZmliZXIsIG5leHRJbnN0YW5jZSk7XG4gICAgICAgIG5leHRJbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhuZXh0SW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBoeWRyYXRpb25QYXJlbnRGaWJlciA/IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhmaWJlci5zdGF0ZU5vZGUpIDogbnVsbDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0SHlkcmF0aW9uU3RhdGUoKSB7XG4gICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBudWxsO1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsO1xuICAgIGlzSHlkcmF0aW5nID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVudGVySHlkcmF0aW9uU3RhdGU6IGVudGVySHlkcmF0aW9uU3RhdGUsXG4gICAgcmVzZXRIeWRyYXRpb25TdGF0ZTogcmVzZXRIeWRyYXRpb25TdGF0ZSxcbiAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZTogdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2UsXG4gICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZTogcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSxcbiAgICBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZTogcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UsXG4gICAgcG9wSHlkcmF0aW9uU3RhdGU6IHBvcEh5ZHJhdGlvblN0YXRlXG4gIH07XG59O1xuXG4vLyBUaGlzIGxldHMgdXMgaG9vayBpbnRvIEZpYmVyIHRvIGRlYnVnIHdoYXQgaXQncyBkb2luZy5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC84MDMzLlxuLy8gVGhpcyBpcyBub3QgcGFydCBvZiB0aGUgcHVibGljIEFQSSwgbm90IGV2ZW4gZm9yIFJlYWN0IERldlRvb2xzLlxuLy8gWW91IG1heSBvbmx5IGluamVjdCBhIGRlYnVnVG9vbCBpZiB5b3Ugd29yayBvbiBSZWFjdCBGaWJlciBpdHNlbGYuXG52YXIgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbiA9IHtcbiAgZGVidWdUb29sOiBudWxsXG59O1xuXG52YXIgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xID0gUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbjtcblxudmFyIGRlZmF1bHRTaG93RGlhbG9nID0gZnVuY3Rpb24gKGNhcHR1cmVkRXJyb3IpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgc2hvd0RpYWxvZyA9IGRlZmF1bHRTaG93RGlhbG9nO1xuXG5mdW5jdGlvbiBsb2dDYXB0dXJlZEVycm9yKGNhcHR1cmVkRXJyb3IpIHtcbiAgdmFyIGxvZ0Vycm9yID0gc2hvd0RpYWxvZyhjYXB0dXJlZEVycm9yKTtcblxuICAvLyBBbGxvdyBpbmplY3RlZCBzaG93RGlhbG9nKCkgdG8gcHJldmVudCBkZWZhdWx0IGNvbnNvbGUuZXJyb3IgbG9nZ2luZy5cbiAgLy8gVGhpcyBlbmFibGVzIHJlbmRlcmVycyBsaWtlIFJlYWN0TmF0aXZlIHRvIGJldHRlciBtYW5hZ2UgcmVkYm94IGJlaGF2aW9yLlxuICBpZiAobG9nRXJyb3IgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGVycm9yID0gY2FwdHVyZWRFcnJvci5lcnJvcjtcbiAgdmFyIHN1cHByZXNzTG9nZ2luZyA9IGVycm9yICYmIGVycm9yLnN1cHByZXNzUmVhY3RFcnJvckxvZ2dpbmc7XG4gIGlmIChzdXBwcmVzc0xvZ2dpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBjYXB0dXJlZEVycm9yLmNvbXBvbmVudE5hbWUsXG4gICAgICAgIGNvbXBvbmVudFN0YWNrID0gY2FwdHVyZWRFcnJvci5jb21wb25lbnRTdGFjayxcbiAgICAgICAgZXJyb3JCb3VuZGFyeU5hbWUgPSBjYXB0dXJlZEVycm9yLmVycm9yQm91bmRhcnlOYW1lLFxuICAgICAgICBlcnJvckJvdW5kYXJ5Rm91bmQgPSBjYXB0dXJlZEVycm9yLmVycm9yQm91bmRhcnlGb3VuZCxcbiAgICAgICAgd2lsbFJldHJ5ID0gY2FwdHVyZWRFcnJvci53aWxsUmV0cnk7XG5cblxuICAgIHZhciBjb21wb25lbnROYW1lTWVzc2FnZSA9IGNvbXBvbmVudE5hbWUgPyAnVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIHRoZSA8JyArIGNvbXBvbmVudE5hbWUgKyAnPiBjb21wb25lbnQ6JyA6ICdUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gb25lIG9mIHlvdXIgUmVhY3QgY29tcG9uZW50czonO1xuXG4gICAgdmFyIGVycm9yQm91bmRhcnlNZXNzYWdlID0gdm9pZCAwO1xuICAgIC8vIGVycm9yQm91bmRhcnlGb3VuZCBjaGVjayBpcyBzdWZmaWNpZW50OyBlcnJvckJvdW5kYXJ5TmFtZSBjaGVjayBpcyB0byBzYXRpc2Z5IEZsb3cuXG4gICAgaWYgKGVycm9yQm91bmRhcnlGb3VuZCAmJiBlcnJvckJvdW5kYXJ5TmFtZSkge1xuICAgICAgaWYgKHdpbGxSZXRyeSkge1xuICAgICAgICBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9ICdSZWFjdCB3aWxsIHRyeSB0byByZWNyZWF0ZSB0aGlzIGNvbXBvbmVudCB0cmVlIGZyb20gc2NyYXRjaCAnICsgKCd1c2luZyB0aGUgZXJyb3IgYm91bmRhcnkgeW91IHByb3ZpZGVkLCAnICsgZXJyb3JCb3VuZGFyeU5hbWUgKyAnLicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3JCb3VuZGFyeU1lc3NhZ2UgPSAnVGhpcyBlcnJvciB3YXMgaW5pdGlhbGx5IGhhbmRsZWQgYnkgdGhlIGVycm9yIGJvdW5kYXJ5ICcgKyBlcnJvckJvdW5kYXJ5TmFtZSArICcuXFxuJyArICdSZWNyZWF0aW5nIHRoZSB0cmVlIGZyb20gc2NyYXRjaCBmYWlsZWQgc28gUmVhY3Qgd2lsbCB1bm1vdW50IHRoZSB0cmVlLic7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yQm91bmRhcnlNZXNzYWdlID0gJ0NvbnNpZGVyIGFkZGluZyBhbiBlcnJvciBib3VuZGFyeSB0byB5b3VyIHRyZWUgdG8gY3VzdG9taXplIGVycm9yIGhhbmRsaW5nIGJlaGF2aW9yLlxcbicgKyAnVmlzaXQgaHR0cHM6Ly9mYi5tZS9yZWFjdC1lcnJvci1ib3VuZGFyaWVzIHRvIGxlYXJuIG1vcmUgYWJvdXQgZXJyb3IgYm91bmRhcmllcy4nO1xuICAgIH1cbiAgICB2YXIgY29tYmluZWRNZXNzYWdlID0gJycgKyBjb21wb25lbnROYW1lTWVzc2FnZSArIGNvbXBvbmVudFN0YWNrICsgJ1xcblxcbicgKyAoJycgKyBlcnJvckJvdW5kYXJ5TWVzc2FnZSk7XG5cbiAgICAvLyBJbiBkZXZlbG9wbWVudCwgd2UgcHJvdmlkZSBvdXIgb3duIG1lc3NhZ2Ugd2l0aCBqdXN0IHRoZSBjb21wb25lbnQgc3RhY2suXG4gICAgLy8gV2UgZG9uJ3QgaW5jbHVkZSB0aGUgb3JpZ2luYWwgZXJyb3IgbWVzc2FnZSBhbmQgSlMgc3RhY2sgYmVjYXVzZSB0aGUgYnJvd3NlclxuICAgIC8vIGhhcyBhbHJlYWR5IHByaW50ZWQgaXQuIEV2ZW4gaWYgdGhlIGFwcGxpY2F0aW9uIHN3YWxsb3dzIHRoZSBlcnJvciwgaXQgaXMgc3RpbGxcbiAgICAvLyBkaXNwbGF5ZWQgYnkgdGhlIGJyb3dzZXIgdGhhbmtzIHRvIHRoZSBERVYtb25seSBmYWtlIGV2ZW50IHRyaWNrIGluIFJlYWN0RXJyb3JVdGlscy5cbiAgICBjb25zb2xlLmVycm9yKGNvbWJpbmVkTWVzc2FnZSk7XG4gIH1cbn1cblxudmFyIGludm9rZUd1YXJkZWRDYWxsYmFjayQxID0gUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjaztcbnZhciBoYXNDYXVnaHRFcnJvciA9IFJlYWN0RXJyb3JVdGlscy5oYXNDYXVnaHRFcnJvcjtcbnZhciBjbGVhckNhdWdodEVycm9yID0gUmVhY3RFcnJvclV0aWxzLmNsZWFyQ2F1Z2h0RXJyb3I7XG5cblxue1xuICB2YXIgZGlkV2FybkFib3V0U3RhdGVUcmFuc2l0aW9uID0gZmFsc2U7XG4gIHZhciBkaWRXYXJuU2V0U3RhdGVDaGlsZENvbnRleHQgPSBmYWxzZTtcbiAgdmFyIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudCA9IHt9O1xuXG4gIHZhciB3YXJuQWJvdXRVcGRhdGVPblVubW91bnRlZCA9IGZ1bmN0aW9uIChmaWJlcikge1xuICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1JlYWN0Q2xhc3MnO1xuICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2FybmluZyhmYWxzZSwgJ0NhbiBvbmx5IHVwZGF0ZSBhIG1vdW50ZWQgb3IgbW91bnRpbmcgJyArICdjb21wb25lbnQuIFRoaXMgdXN1YWxseSBtZWFucyB5b3UgY2FsbGVkIHNldFN0YXRlLCByZXBsYWNlU3RhdGUsICcgKyAnb3IgZm9yY2VVcGRhdGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4gVGhpcyBpcyBhIG5vLW9wLlxcblxcblBsZWFzZSAnICsgJ2NoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNvbXBvbmVudE5hbWUpO1xuICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFtjb21wb25lbnROYW1lXSA9IHRydWU7XG4gIH07XG5cbiAgdmFyIHdhcm5BYm91dEludmFsaWRVcGRhdGVzID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgc3dpdGNoIChSZWFjdERlYnVnQ3VycmVudEZpYmVyLnBoYXNlKSB7XG4gICAgICBjYXNlICdnZXRDaGlsZENvbnRleHQnOlxuICAgICAgICBpZiAoZGlkV2FyblNldFN0YXRlQ2hpbGRDb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdzZXRTdGF0ZSguLi4pOiBDYW5ub3QgY2FsbCBzZXRTdGF0ZSgpIGluc2lkZSBnZXRDaGlsZENvbnRleHQoKScpO1xuICAgICAgICBkaWRXYXJuU2V0U3RhdGVDaGlsZENvbnRleHQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JlbmRlcic6XG4gICAgICAgIGlmIChkaWRXYXJuQWJvdXRTdGF0ZVRyYW5zaXRpb24pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ0Nhbm5vdCB1cGRhdGUgZHVyaW5nIGFuIGV4aXN0aW5nIHN0YXRlIHRyYW5zaXRpb24gKHN1Y2ggYXMgd2l0aGluICcgKyBcImByZW5kZXJgIG9yIGFub3RoZXIgY29tcG9uZW50J3MgY29uc3RydWN0b3IpLiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgXCIgKyAnYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZTsgY29uc3RydWN0b3Igc2lkZS1lZmZlY3RzIGFyZSAnICsgJ2FuIGFudGktcGF0dGVybiwgYnV0IGNhbiBiZSBtb3ZlZCB0byBgY29tcG9uZW50V2lsbE1vdW50YC4nKTtcbiAgICAgICAgZGlkV2FybkFib3V0U3RhdGVUcmFuc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xufVxuXG52YXIgUmVhY3RGaWJlclNjaGVkdWxlciA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIGhvc3RDb250ZXh0ID0gUmVhY3RGaWJlckhvc3RDb250ZXh0KGNvbmZpZyk7XG4gIHZhciBoeWRyYXRpb25Db250ZXh0ID0gUmVhY3RGaWJlckh5ZHJhdGlvbkNvbnRleHQoY29uZmlnKTtcbiAgdmFyIHBvcEhvc3RDb250YWluZXIgPSBob3N0Q29udGV4dC5wb3BIb3N0Q29udGFpbmVyLFxuICAgICAgcG9wSG9zdENvbnRleHQgPSBob3N0Q29udGV4dC5wb3BIb3N0Q29udGV4dCxcbiAgICAgIHJlc2V0SG9zdENvbnRhaW5lciA9IGhvc3RDb250ZXh0LnJlc2V0SG9zdENvbnRhaW5lcjtcblxuICB2YXIgX1JlYWN0RmliZXJCZWdpbldvcmsgPSBSZWFjdEZpYmVyQmVnaW5Xb3JrKGNvbmZpZywgaG9zdENvbnRleHQsIGh5ZHJhdGlvbkNvbnRleHQsIHNjaGVkdWxlV29yaywgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlciksXG4gICAgICBiZWdpbldvcmsgPSBfUmVhY3RGaWJlckJlZ2luV29yay5iZWdpbldvcmssXG4gICAgICBiZWdpbkZhaWxlZFdvcmsgPSBfUmVhY3RGaWJlckJlZ2luV29yay5iZWdpbkZhaWxlZFdvcms7XG5cbiAgdmFyIF9SZWFjdEZpYmVyQ29tcGxldGVXbyA9IFJlYWN0RmliZXJDb21wbGV0ZVdvcmsoY29uZmlnLCBob3N0Q29udGV4dCwgaHlkcmF0aW9uQ29udGV4dCksXG4gICAgICBjb21wbGV0ZVdvcmsgPSBfUmVhY3RGaWJlckNvbXBsZXRlV28uY29tcGxldGVXb3JrO1xuXG4gIHZhciBfUmVhY3RGaWJlckNvbW1pdFdvcmsgPSBSZWFjdEZpYmVyQ29tbWl0V29yayhjb25maWcsIGNhcHR1cmVFcnJvciksXG4gICAgICBjb21taXRSZXNldFRleHRDb250ZW50ID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdFJlc2V0VGV4dENvbnRlbnQsXG4gICAgICBjb21taXRQbGFjZW1lbnQgPSBfUmVhY3RGaWJlckNvbW1pdFdvcmsuY29tbWl0UGxhY2VtZW50LFxuICAgICAgY29tbWl0RGVsZXRpb24gPSBfUmVhY3RGaWJlckNvbW1pdFdvcmsuY29tbWl0RGVsZXRpb24sXG4gICAgICBjb21taXRXb3JrID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdFdvcmssXG4gICAgICBjb21taXRMaWZlQ3ljbGVzID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdExpZmVDeWNsZXMsXG4gICAgICBjb21taXRBdHRhY2hSZWYgPSBfUmVhY3RGaWJlckNvbW1pdFdvcmsuY29tbWl0QXR0YWNoUmVmLFxuICAgICAgY29tbWl0RGV0YWNoUmVmID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdERldGFjaFJlZjtcblxuICB2YXIgbm93ID0gY29uZmlnLm5vdyxcbiAgICAgIHNjaGVkdWxlRGVmZXJyZWRDYWxsYmFjayA9IGNvbmZpZy5zY2hlZHVsZURlZmVycmVkQ2FsbGJhY2ssXG4gICAgICBjYW5jZWxEZWZlcnJlZENhbGxiYWNrID0gY29uZmlnLmNhbmNlbERlZmVycmVkQ2FsbGJhY2ssXG4gICAgICB1c2VTeW5jU2NoZWR1bGluZyA9IGNvbmZpZy51c2VTeW5jU2NoZWR1bGluZyxcbiAgICAgIHByZXBhcmVGb3JDb21taXQgPSBjb25maWcucHJlcGFyZUZvckNvbW1pdCxcbiAgICAgIHJlc2V0QWZ0ZXJDb21taXQgPSBjb25maWcucmVzZXRBZnRlckNvbW1pdDtcblxuICAvLyBSZXByZXNlbnRzIHRoZSBjdXJyZW50IHRpbWUgaW4gbXMuXG5cbiAgdmFyIHN0YXJ0VGltZSA9IG5vdygpO1xuICB2YXIgbW9zdFJlY2VudEN1cnJlbnRUaW1lID0gbXNUb0V4cGlyYXRpb25UaW1lKDApO1xuXG4gIC8vIFJlcHJlc2VudHMgdGhlIGV4cGlyYXRpb24gdGltZSB0aGF0IGluY29taW5nIHVwZGF0ZXMgc2hvdWxkIHVzZS4gKElmIHRoaXNcbiAgLy8gaXMgTm9Xb3JrLCB1c2UgdGhlIGRlZmF1bHQgc3RyYXRlZ3k6IGFzeW5jIHVwZGF0ZXMgaW4gYXN5bmMgbW9kZSwgc3luY1xuICAvLyB1cGRhdGVzIGluIHN5bmMgbW9kZS4pXG4gIHZhciBleHBpcmF0aW9uQ29udGV4dCA9IE5vV29yaztcblxuICB2YXIgaXNXb3JraW5nID0gZmFsc2U7XG5cbiAgLy8gVGhlIG5leHQgd29yayBpbiBwcm9ncmVzcyBmaWJlciB0aGF0IHdlJ3JlIGN1cnJlbnRseSB3b3JraW5nIG9uLlxuICB2YXIgbmV4dFVuaXRPZldvcmsgPSBudWxsO1xuICB2YXIgbmV4dFJvb3QgPSBudWxsO1xuICAvLyBUaGUgdGltZSBhdCB3aGljaCB3ZSdyZSBjdXJyZW50bHkgcmVuZGVyaW5nIHdvcmsuXG4gIHZhciBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG5cbiAgLy8gVGhlIG5leHQgZmliZXIgd2l0aCBhbiBlZmZlY3QgdGhhdCB3ZSdyZSBjdXJyZW50bHkgY29tbWl0dGluZy5cbiAgdmFyIG5leHRFZmZlY3QgPSBudWxsO1xuXG4gIC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZmliZXJzIGhhdmUgY2FwdHVyZWQgYW4gZXJyb3IgdGhhdCBuZWVkIHRvIGJlIGhhbmRsZWQuXG4gIC8vIFdvcmsgaXMgcmVtb3ZlZCBmcm9tIHRoaXMgY29sbGVjdGlvbiBhZnRlciBjb21wb25lbnREaWRDYXRjaCBpcyBjYWxsZWQuXG4gIHZhciBjYXB0dXJlZEVycm9ycyA9IG51bGw7XG4gIC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZmliZXJzIGhhdmUgZmFpbGVkIGR1cmluZyB0aGUgY3VycmVudCBiYXRjaCBvZiB3b3JrLlxuICAvLyBUaGlzIGlzIGEgZGlmZmVyZW50IHNldCB0aGFuIGNhcHR1cmVkRXJyb3JzLCBiZWNhdXNlIGl0IGlzIG5vdCByZXNldCB1bnRpbFxuICAvLyB0aGUgZW5kIG9mIHRoZSBiYXRjaC4gVGhpcyBpcyBuZWVkZWQgdG8gcHJvcGFnYXRlIGVycm9ycyBjb3JyZWN0bHkgaWYgYVxuICAvLyBzdWJ0cmVlIGZhaWxzIG1vcmUgdGhhbiBvbmNlLlxuICB2YXIgZmFpbGVkQm91bmRhcmllcyA9IG51bGw7XG4gIC8vIEVycm9yIGJvdW5kYXJpZXMgdGhhdCBjYXB0dXJlZCBhbiBlcnJvciBkdXJpbmcgdGhlIGN1cnJlbnQgY29tbWl0LlxuICB2YXIgY29tbWl0UGhhc2VCb3VuZGFyaWVzID0gbnVsbDtcbiAgdmFyIGZpcnN0VW5jYXVnaHRFcnJvciA9IG51bGw7XG4gIHZhciBkaWRGYXRhbCA9IGZhbHNlO1xuXG4gIHZhciBpc0NvbW1pdHRpbmcgPSBmYWxzZTtcbiAgdmFyIGlzVW5tb3VudGluZyA9IGZhbHNlO1xuXG4gIC8vIFVzZWQgZm9yIHBlcmZvcm1hbmNlIHRyYWNraW5nLlxuICB2YXIgaW50ZXJydXB0ZWRCeSA9IG51bGw7XG5cbiAgZnVuY3Rpb24gcmVzZXRDb250ZXh0U3RhY2soKSB7XG4gICAgLy8gUmVzZXQgdGhlIHN0YWNrXG4gICAgcmVzZXQkMSgpO1xuICAgIC8vIFJlc2V0IHRoZSBjdXJzb3JzXG4gICAgcmVzZXRDb250ZXh0KCk7XG4gICAgcmVzZXRIb3N0Q29udGFpbmVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRBbGxIb3N0RWZmZWN0cygpIHtcbiAgICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRGaWJlcihuZXh0RWZmZWN0KTtcbiAgICAgIH1cbiAgICAgIHJlY29yZEVmZmVjdCgpO1xuXG4gICAgICB2YXIgZWZmZWN0VGFnID0gbmV4dEVmZmVjdC5lZmZlY3RUYWc7XG4gICAgICBpZiAoZWZmZWN0VGFnICYgQ29udGVudFJlc2V0KSB7XG4gICAgICAgIGNvbW1pdFJlc2V0VGV4dENvbnRlbnQobmV4dEVmZmVjdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlZmZlY3RUYWcgJiBSZWYpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICBjb21taXREZXRhY2hSZWYoY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGZvbGxvd2luZyBzd2l0Y2ggc3RhdGVtZW50IGlzIG9ubHkgY29uY2VybmVkIGFib3V0IHBsYWNlbWVudCxcbiAgICAgIC8vIHVwZGF0ZXMsIGFuZCBkZWxldGlvbnMuIFRvIGF2b2lkIG5lZWRpbmcgdG8gYWRkIGEgY2FzZSBmb3IgZXZlcnlcbiAgICAgIC8vIHBvc3NpYmxlIGJpdG1hcCB2YWx1ZSwgd2UgcmVtb3ZlIHRoZSBzZWNvbmRhcnkgZWZmZWN0cyBmcm9tIHRoZVxuICAgICAgLy8gZWZmZWN0IHRhZyBhbmQgc3dpdGNoIG9uIHRoYXQgdmFsdWUuXG4gICAgICB2YXIgcHJpbWFyeUVmZmVjdFRhZyA9IGVmZmVjdFRhZyAmIH4oQ2FsbGJhY2sgfCBFcnIgfCBDb250ZW50UmVzZXQgfCBSZWYgfCBQZXJmb3JtZWRXb3JrKTtcbiAgICAgIHN3aXRjaCAocHJpbWFyeUVmZmVjdFRhZykge1xuICAgICAgICBjYXNlIFBsYWNlbWVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb21taXRQbGFjZW1lbnQobmV4dEVmZmVjdCk7XG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgXCJwbGFjZW1lbnRcIiBmcm9tIGVmZmVjdCB0YWcgc28gdGhhdCB3ZSBrbm93IHRoYXQgdGhpcyBpcyBpbnNlcnRlZCwgYmVmb3JlXG4gICAgICAgICAgICAvLyBhbnkgbGlmZS1jeWNsZXMgbGlrZSBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZC5cbiAgICAgICAgICAgIC8vIFRPRE86IGZpbmRET01Ob2RlIGRvZXNuJ3QgcmVseSBvbiB0aGlzIGFueSBtb3JlIGJ1dCBpc01vdW50ZWRcbiAgICAgICAgICAgIC8vIGRvZXMgYW5kIGlzTW91bnRlZCBpcyBkZXByZWNhdGVkIGFueXdheSBzbyB3ZSBzaG91bGQgYmUgYWJsZVxuICAgICAgICAgICAgLy8gdG8ga2lsbCB0aGlzLlxuICAgICAgICAgICAgbmV4dEVmZmVjdC5lZmZlY3RUYWcgJj0gflBsYWNlbWVudDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBQbGFjZW1lbnRBbmRVcGRhdGU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gUGxhY2VtZW50XG4gICAgICAgICAgICBjb21taXRQbGFjZW1lbnQobmV4dEVmZmVjdCk7XG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgXCJwbGFjZW1lbnRcIiBmcm9tIGVmZmVjdCB0YWcgc28gdGhhdCB3ZSBrbm93IHRoYXQgdGhpcyBpcyBpbnNlcnRlZCwgYmVmb3JlXG4gICAgICAgICAgICAvLyBhbnkgbGlmZS1jeWNsZXMgbGlrZSBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZC5cbiAgICAgICAgICAgIG5leHRFZmZlY3QuZWZmZWN0VGFnICY9IH5QbGFjZW1lbnQ7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZVxuICAgICAgICAgICAgdmFyIF9jdXJyZW50ID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgICAgICBjb21taXRXb3JrKF9jdXJyZW50LCBuZXh0RWZmZWN0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBVcGRhdGU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9jdXJyZW50MiA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgICAgICAgY29tbWl0V29yayhfY3VycmVudDIsIG5leHRFZmZlY3QpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIERlbGV0aW9uOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlzVW5tb3VudGluZyA9IHRydWU7XG4gICAgICAgICAgICBjb21taXREZWxldGlvbihuZXh0RWZmZWN0KTtcbiAgICAgICAgICAgIGlzVW5tb3VudGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICB9XG5cbiAgICB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0QWxsTGlmZUN5Y2xlcygpIHtcbiAgICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIGVmZmVjdFRhZyA9IG5leHRFZmZlY3QuZWZmZWN0VGFnO1xuXG4gICAgICBpZiAoZWZmZWN0VGFnICYgKFVwZGF0ZSB8IENhbGxiYWNrKSkge1xuICAgICAgICByZWNvcmRFZmZlY3QoKTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgICAgY29tbWl0TGlmZUN5Y2xlcyhjdXJyZW50LCBuZXh0RWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVmZmVjdFRhZyAmIFJlZikge1xuICAgICAgICByZWNvcmRFZmZlY3QoKTtcbiAgICAgICAgY29tbWl0QXR0YWNoUmVmKG5leHRFZmZlY3QpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWZmZWN0VGFnICYgRXJyKSB7XG4gICAgICAgIHJlY29yZEVmZmVjdCgpO1xuICAgICAgICBjb21taXRFcnJvckhhbmRsaW5nKG5leHRFZmZlY3QpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV4dCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IHdlIGNsZWFuIHRoZXNlIHVwIHNvIHRoYXQgd2UgZG9uJ3QgYWNjaWRlbnRhbGx5IGtlZXAgdGhlbS5cbiAgICAgIC8vIEknbSBub3QgYWN0dWFsbHkgc3VyZSB0aGlzIG1hdHRlcnMgYmVjYXVzZSB3ZSBjYW4ndCByZXNldCBmaXJzdEVmZmVjdFxuICAgICAgLy8gYW5kIGxhc3RFZmZlY3Qgc2luY2UgdGhleSdyZSBvbiBldmVyeSBub2RlLCBub3QganVzdCB0aGUgZWZmZWN0ZnVsXG4gICAgICAvLyBvbmVzLiBTbyB3ZSBoYXZlIHRvIGNsZWFuIGV2ZXJ5dGhpbmcgYXMgd2UgcmV1c2Ugbm9kZXMgYW55d2F5LlxuICAgICAgbmV4dEVmZmVjdC5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IHdlIHJlc2V0IHRoZSBlZmZlY3RUYWcgaGVyZSBzbyB0aGF0IHdlIGNhbiByZWx5IG9uIGVmZmVjdFxuICAgICAgLy8gdGFncyB0byByZWFzb24gYWJvdXQgdGhlIGN1cnJlbnQgbGlmZS1jeWNsZS5cbiAgICAgIG5leHRFZmZlY3QgPSBuZXh0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdFJvb3QoZmluaXNoZWRXb3JrKSB7XG4gICAgLy8gV2Uga2VlcCB0cmFjayBvZiB0aGlzIHNvIHRoYXQgY2FwdHVyZUVycm9yIGNhbiBjb2xsZWN0IGFueSBib3VuZGFyaWVzXG4gICAgLy8gdGhhdCBjYXB0dXJlIGFuIGVycm9yIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlLiBUaGUgcmVhc29uIHRoZXNlIGFyZW4ndFxuICAgIC8vIGxvY2FsIHRvIHRoaXMgZnVuY3Rpb24gaXMgYmVjYXVzZSBlcnJvcnMgdGhhdCBvY2N1ciBkdXJpbmcgY1dVIGFyZVxuICAgIC8vIGNhcHR1cmVkIGVsc2V3aGVyZSwgdG8gcHJldmVudCB0aGUgdW5tb3VudCBmcm9tIGJlaW5nIGludGVycnVwdGVkLlxuICAgIGlzV29ya2luZyA9IHRydWU7XG4gICAgaXNDb21taXR0aW5nID0gdHJ1ZTtcbiAgICBzdGFydENvbW1pdFRpbWVyKCk7XG5cbiAgICB2YXIgcm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgIShyb290LmN1cnJlbnQgIT09IGZpbmlzaGVkV29yaykgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgY29tbWl0IHRoZSBzYW1lIHRyZWUgYXMgYmVmb3JlLiBUaGlzIGlzIHByb2JhYmx5IGEgYnVnIHJlbGF0ZWQgdG8gdGhlIHJldHVybiBmaWVsZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICByb290LmlzUmVhZHlGb3JDb21taXQgPSBmYWxzZTtcblxuICAgIC8vIFJlc2V0IHRoaXMgdG8gbnVsbCBiZWZvcmUgY2FsbGluZyBsaWZlY3ljbGVzXG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG5cbiAgICB2YXIgZmlyc3RFZmZlY3QgPSB2b2lkIDA7XG4gICAgaWYgKGZpbmlzaGVkV29yay5lZmZlY3RUYWcgPiBQZXJmb3JtZWRXb3JrKSB7XG4gICAgICAvLyBBIGZpYmVyJ3MgZWZmZWN0IGxpc3QgY29uc2lzdHMgb25seSBvZiBpdHMgY2hpbGRyZW4sIG5vdCBpdHNlbGYuIFNvIGlmXG4gICAgICAvLyB0aGUgcm9vdCBoYXMgYW4gZWZmZWN0LCB3ZSBuZWVkIHRvIGFkZCBpdCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LiBUaGVcbiAgICAgIC8vIHJlc3VsdGluZyBsaXN0IGlzIHRoZSBzZXQgdGhhdCB3b3VsZCBiZWxvbmcgdG8gdGhlIHJvb3QncyBwYXJlbnQsIGlmXG4gICAgICAvLyBpdCBoYWQgb25lOyB0aGF0IGlzLCBhbGwgdGhlIGVmZmVjdHMgaW4gdGhlIHRyZWUgaW5jbHVkaW5nIHRoZSByb290LlxuICAgICAgaWYgKGZpbmlzaGVkV29yay5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgIGZpbmlzaGVkV29yay5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBmaW5pc2hlZFdvcms7XG4gICAgICAgIGZpcnN0RWZmZWN0ID0gZmluaXNoZWRXb3JrLmZpcnN0RWZmZWN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlyc3RFZmZlY3QgPSBmaW5pc2hlZFdvcms7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZXJlIGlzIG5vIGVmZmVjdCBvbiB0aGUgcm9vdC5cbiAgICAgIGZpcnN0RWZmZWN0ID0gZmluaXNoZWRXb3JrLmZpcnN0RWZmZWN0O1xuICAgIH1cblxuICAgIHByZXBhcmVGb3JDb21taXQoKTtcblxuICAgIC8vIENvbW1pdCBhbGwgdGhlIHNpZGUtZWZmZWN0cyB3aXRoaW4gYSB0cmVlLiBXZSdsbCBkbyB0aGlzIGluIHR3byBwYXNzZXMuXG4gICAgLy8gVGhlIGZpcnN0IHBhc3MgcGVyZm9ybXMgYWxsIHRoZSBob3N0IGluc2VydGlvbnMsIHVwZGF0ZXMsIGRlbGV0aW9ucyBhbmRcbiAgICAvLyByZWYgdW5tb3VudHMuXG4gICAgbmV4dEVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuICAgIHN0YXJ0Q29tbWl0SG9zdEVmZmVjdHNUaW1lcigpO1xuICAgIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICB2YXIgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBfZXJyb3IgPSB2b2lkIDA7XG4gICAgICB7XG4gICAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQxKG51bGwsIGNvbW1pdEFsbEhvc3RFZmZlY3RzLCBudWxsKTtcbiAgICAgICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgICAgICBkaWRFcnJvciA9IHRydWU7XG4gICAgICAgICAgX2Vycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGlkRXJyb3IpIHtcbiAgICAgICAgIShuZXh0RWZmZWN0ICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBoYXZlIG5leHQgZWZmZWN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICBjYXB0dXJlRXJyb3IobmV4dEVmZmVjdCwgX2Vycm9yKTtcbiAgICAgICAgLy8gQ2xlYW4tdXBcbiAgICAgICAgaWYgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICBuZXh0RWZmZWN0ID0gbmV4dEVmZmVjdC5uZXh0RWZmZWN0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHN0b3BDb21taXRIb3N0RWZmZWN0c1RpbWVyKCk7XG5cbiAgICByZXNldEFmdGVyQ29tbWl0KCk7XG5cbiAgICAvLyBUaGUgd29yay1pbi1wcm9ncmVzcyB0cmVlIGlzIG5vdyB0aGUgY3VycmVudCB0cmVlLiBUaGlzIG11c3QgY29tZSBhZnRlclxuICAgIC8vIHRoZSBmaXJzdCBwYXNzIG9mIHRoZSBjb21taXQgcGhhc2UsIHNvIHRoYXQgdGhlIHByZXZpb3VzIHRyZWUgaXMgc3RpbGxcbiAgICAvLyBjdXJyZW50IGR1cmluZyBjb21wb25lbnRXaWxsVW5tb3VudCwgYnV0IGJlZm9yZSB0aGUgc2Vjb25kIHBhc3MsIHNvIHRoYXRcbiAgICAvLyB0aGUgZmluaXNoZWQgd29yayBpcyBjdXJyZW50IGR1cmluZyBjb21wb25lbnREaWRNb3VudC9VcGRhdGUuXG4gICAgcm9vdC5jdXJyZW50ID0gZmluaXNoZWRXb3JrO1xuXG4gICAgLy8gSW4gdGhlIHNlY29uZCBwYXNzIHdlJ2xsIHBlcmZvcm0gYWxsIGxpZmUtY3ljbGVzIGFuZCByZWYgY2FsbGJhY2tzLlxuICAgIC8vIExpZmUtY3ljbGVzIGhhcHBlbiBhcyBhIHNlcGFyYXRlIHBhc3Mgc28gdGhhdCBhbGwgcGxhY2VtZW50cywgdXBkYXRlcyxcbiAgICAvLyBhbmQgZGVsZXRpb25zIGluIHRoZSBlbnRpcmUgdHJlZSBoYXZlIGFscmVhZHkgYmVlbiBpbnZva2VkLlxuICAgIC8vIFRoaXMgcGFzcyBhbHNvIHRyaWdnZXJzIGFueSByZW5kZXJlci1zcGVjaWZpYyBpbml0aWFsIGVmZmVjdHMuXG4gICAgbmV4dEVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuICAgIHN0YXJ0Q29tbWl0TGlmZUN5Y2xlc1RpbWVyKCk7XG4gICAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgIHZhciBfZGlkRXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBfZXJyb3IyID0gdm9pZCAwO1xuICAgICAge1xuICAgICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMShudWxsLCBjb21taXRBbGxMaWZlQ3ljbGVzLCBudWxsKTtcbiAgICAgICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgICAgICBfZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIF9lcnJvcjIgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChfZGlkRXJyb3IpIHtcbiAgICAgICAgIShuZXh0RWZmZWN0ICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBoYXZlIG5leHQgZWZmZWN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICBjYXB0dXJlRXJyb3IobmV4dEVmZmVjdCwgX2Vycm9yMik7XG4gICAgICAgIGlmIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlzQ29tbWl0dGluZyA9IGZhbHNlO1xuICAgIGlzV29ya2luZyA9IGZhbHNlO1xuICAgIHN0b3BDb21taXRMaWZlQ3ljbGVzVGltZXIoKTtcbiAgICBzdG9wQ29tbWl0VGltZXIoKTtcbiAgICBpZiAodHlwZW9mIG9uQ29tbWl0Um9vdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb25Db21taXRSb290KGZpbmlzaGVkV29yay5zdGF0ZU5vZGUpO1xuICAgIH1cbiAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQ29tbWl0V29yayhmaW5pc2hlZFdvcmspO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGNhdWdodCBhbnkgZXJyb3JzIGR1cmluZyB0aGlzIGNvbW1pdCwgc2NoZWR1bGUgdGhlaXIgYm91bmRhcmllc1xuICAgIC8vIHRvIHVwZGF0ZS5cbiAgICBpZiAoY29tbWl0UGhhc2VCb3VuZGFyaWVzKSB7XG4gICAgICBjb21taXRQaGFzZUJvdW5kYXJpZXMuZm9yRWFjaChzY2hlZHVsZUVycm9yUmVjb3ZlcnkpO1xuICAgICAgY29tbWl0UGhhc2VCb3VuZGFyaWVzID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoZmlyc3RVbmNhdWdodEVycm9yICE9PSBudWxsKSB7XG4gICAgICB2YXIgX2Vycm9yMyA9IGZpcnN0VW5jYXVnaHRFcnJvcjtcbiAgICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IG51bGw7XG4gICAgICBvblVuY2F1Z2h0RXJyb3IoX2Vycm9yMyk7XG4gICAgfVxuXG4gICAgdmFyIHJlbWFpbmluZ1RpbWUgPSByb290LmN1cnJlbnQuZXhwaXJhdGlvblRpbWU7XG5cbiAgICBpZiAocmVtYWluaW5nVGltZSA9PT0gTm9Xb3JrKSB7XG4gICAgICBjYXB0dXJlZEVycm9ycyA9IG51bGw7XG4gICAgICBmYWlsZWRCb3VuZGFyaWVzID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVtYWluaW5nVGltZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0RXhwaXJhdGlvblRpbWUod29ya0luUHJvZ3Jlc3MsIHJlbmRlclRpbWUpIHtcbiAgICBpZiAocmVuZGVyVGltZSAhPT0gTmV2ZXIgJiYgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPT09IE5ldmVyKSB7XG4gICAgICAvLyBUaGUgY2hpbGRyZW4gb2YgdGhpcyBjb21wb25lbnQgYXJlIGhpZGRlbi4gRG9uJ3QgYnViYmxlIHRoZWlyXG4gICAgICAvLyBleHBpcmF0aW9uIHRpbWVzLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBwZW5kaW5nIHVwZGF0ZXMuXG4gICAgdmFyIG5ld0V4cGlyYXRpb25UaW1lID0gZ2V0VXBkYXRlRXhwaXJhdGlvblRpbWUod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgLy8gVE9ETzogQ2FsbHMgbmVlZCB0byB2aXNpdCBzdGF0ZU5vZGVcblxuICAgIC8vIEJ1YmJsZSB1cCB0aGUgZWFybGllc3QgZXhwaXJhdGlvbiB0aW1lLlxuICAgIHZhciBjaGlsZCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGNoaWxkLmV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmsgJiYgKG5ld0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbmV3RXhwaXJhdGlvblRpbWUgPiBjaGlsZC5leHBpcmF0aW9uVGltZSkpIHtcbiAgICAgICAgbmV3RXhwaXJhdGlvblRpbWUgPSBjaGlsZC5leHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG4gICAgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPSBuZXdFeHBpcmF0aW9uVGltZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBsZXRlVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcykge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAvLyBUaGUgY3VycmVudCwgZmx1c2hlZCwgc3RhdGUgb2YgdGhpcyBmaWJlciBpcyB0aGUgYWx0ZXJuYXRlLlxuICAgICAgLy8gSWRlYWxseSBub3RoaW5nIHNob3VsZCByZWx5IG9uIHRoaXMsIGJ1dCByZWx5aW5nIG9uIGl0IGhlcmVcbiAgICAgIC8vIG1lYW5zIHRoYXQgd2UgZG9uJ3QgbmVlZCBhbiBhZGRpdGlvbmFsIGZpZWxkIG9uIHRoZSB3b3JrIGluXG4gICAgICAvLyBwcm9ncmVzcy5cbiAgICAgIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuICAgICAge1xuICAgICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRGaWJlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG4gICAgICB2YXIgbmV4dCA9IGNvbXBsZXRlV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIHtcbiAgICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5yZXNldEN1cnJlbnRGaWJlcigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzc1sncmV0dXJuJ107XG4gICAgICB2YXIgc2libGluZ0ZpYmVyID0gd29ya0luUHJvZ3Jlc3Muc2libGluZztcblxuICAgICAgcmVzZXRFeHBpcmF0aW9uVGltZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcblxuICAgICAgaWYgKG5leHQgIT09IG51bGwpIHtcbiAgICAgICAgc3RvcFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQ29tcGxldGVXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBjb21wbGV0aW5nIHRoaXMgd29yayBzcGF3bmVkIG5ldyB3b3JrLCBkbyB0aGF0IG5leHQuIFdlJ2xsIGNvbWVcbiAgICAgICAgLy8gYmFjayBoZXJlIGFnYWluLlxuICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgIH1cblxuICAgICAgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIEFwcGVuZCBhbGwgdGhlIGVmZmVjdHMgb2YgdGhlIHN1YnRyZWUgYW5kIHRoaXMgZmliZXIgb250byB0aGUgZWZmZWN0XG4gICAgICAgIC8vIGxpc3Qgb2YgdGhlIHBhcmVudC4gVGhlIGNvbXBsZXRpb24gb3JkZXIgb2YgdGhlIGNoaWxkcmVuIGFmZmVjdHMgdGhlXG4gICAgICAgIC8vIHNpZGUtZWZmZWN0IG9yZGVyLlxuICAgICAgICBpZiAocmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHJldHVybkZpYmVyLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoaXMgZmliZXIgaGFkIHNpZGUtZWZmZWN0cywgd2UgYXBwZW5kIGl0IEFGVEVSIHRoZSBjaGlsZHJlbidzXG4gICAgICAgIC8vIHNpZGUtZWZmZWN0cy4gV2UgY2FuIHBlcmZvcm0gY2VydGFpbiBzaWRlLWVmZmVjdHMgZWFybGllciBpZlxuICAgICAgICAvLyBuZWVkZWQsIGJ5IGRvaW5nIG11bHRpcGxlIHBhc3NlcyBvdmVyIHRoZSBlZmZlY3QgbGlzdC4gV2UgZG9uJ3Qgd2FudFxuICAgICAgICAvLyB0byBzY2hlZHVsZSBvdXIgb3duIHNpZGUtZWZmZWN0IG9uIG91ciBvd24gbGlzdCBiZWNhdXNlIGlmIGVuZCB1cFxuICAgICAgICAvLyByZXVzaW5nIGNoaWxkcmVuIHdlJ2xsIHNjaGVkdWxlIHRoaXMgZWZmZWN0IG9udG8gaXRzZWxmIHNpbmNlIHdlJ3JlXG4gICAgICAgIC8vIGF0IHRoZSBlbmQuXG4gICAgICAgIHZhciBlZmZlY3RUYWcgPSB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWc7XG4gICAgICAgIC8vIFNraXAgYm90aCBOb1dvcmsgYW5kIFBlcmZvcm1lZFdvcmsgdGFncyB3aGVuIGNyZWF0aW5nIHRoZSBlZmZlY3QgbGlzdC5cbiAgICAgICAgLy8gUGVyZm9ybWVkV29yayBlZmZlY3QgaXMgcmVhZCBieSBSZWFjdCBEZXZUb29scyBidXQgc2hvdWxkbid0IGJlIGNvbW1pdHRlZC5cbiAgICAgICAgaWYgKGVmZmVjdFRhZyA+IFBlcmZvcm1lZFdvcmspIHtcbiAgICAgICAgICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdG9wV29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkNvbXBsZXRlV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaWJsaW5nRmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbW9yZSB3b3JrIHRvIGRvIGluIHRoaXMgcmV0dXJuRmliZXIsIGRvIHRoYXQgbmV4dC5cbiAgICAgICAgcmV0dXJuIHNpYmxpbmdGaWJlcjtcbiAgICAgIH0gZWxzZSBpZiAocmV0dXJuRmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBtb3JlIHdvcmsgaW4gdGhpcyByZXR1cm5GaWJlci4gQ29tcGxldGUgdGhlIHJldHVybkZpYmVyLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIHJvb3QuXG4gICAgICAgIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICByb290LmlzUmVhZHlGb3JDb21taXQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXaXRob3V0IHRoaXMgZXhwbGljaXQgbnVsbCByZXR1cm4gRmxvdyBjb21wbGFpbnMgb2YgaW52YWxpZCByZXR1cm4gdHlwZVxuICAgIC8vIFRPRE8gUmVtb3ZlIHRoZSBhYm92ZSB3aGlsZSh0cnVlKSBsb29wXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVucmVhY2hhYmxlXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcykge1xuICAgIC8vIFRoZSBjdXJyZW50LCBmbHVzaGVkLCBzdGF0ZSBvZiB0aGlzIGZpYmVyIGlzIHRoZSBhbHRlcm5hdGUuXG4gICAgLy8gSWRlYWxseSBub3RoaW5nIHNob3VsZCByZWx5IG9uIHRoaXMsIGJ1dCByZWx5aW5nIG9uIGl0IGhlcmVcbiAgICAvLyBtZWFucyB0aGF0IHdlIGRvbid0IG5lZWQgYW4gYWRkaXRpb25hbCBmaWVsZCBvbiB0aGUgd29yayBpblxuICAgIC8vIHByb2dyZXNzLlxuICAgIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuXG4gICAgLy8gU2VlIGlmIGJlZ2lubmluZyB0aGlzIHdvcmsgc3Bhd25zIG1vcmUgd29yay5cbiAgICBzdGFydFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50RmliZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciBuZXh0ID0gYmVnaW5Xb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIucmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICB9XG4gICAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkJlZ2luV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHRoaXMgZG9lc24ndCBzcGF3biBuZXcgd29yaywgY29tcGxldGUgdGhlIGN1cnJlbnQgd29yay5cbiAgICAgIG5leHQgPSBjb21wbGV0ZVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuXG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtRmFpbGVkVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcykge1xuICAgIC8vIFRoZSBjdXJyZW50LCBmbHVzaGVkLCBzdGF0ZSBvZiB0aGlzIGZpYmVyIGlzIHRoZSBhbHRlcm5hdGUuXG4gICAgLy8gSWRlYWxseSBub3RoaW5nIHNob3VsZCByZWx5IG9uIHRoaXMsIGJ1dCByZWx5aW5nIG9uIGl0IGhlcmVcbiAgICAvLyBtZWFucyB0aGF0IHdlIGRvbid0IG5lZWQgYW4gYWRkaXRpb25hbCBmaWVsZCBvbiB0aGUgd29yayBpblxuICAgIC8vIHByb2dyZXNzLlxuICAgIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuXG4gICAgLy8gU2VlIGlmIGJlZ2lubmluZyB0aGlzIHdvcmsgc3Bhd25zIG1vcmUgd29yay5cbiAgICBzdGFydFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50RmliZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgICB2YXIgbmV4dCA9IGJlZ2luRmFpbGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgfVxuICAgIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25CZWdpbldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGlzIGRvZXNuJ3Qgc3Bhd24gbmV3IHdvcmssIGNvbXBsZXRlIHRoZSBjdXJyZW50IHdvcmsuXG4gICAgICBuZXh0ID0gY29tcGxldGVVbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcblxuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgZnVuY3Rpb24gd29ya0xvb3AoZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY2FwdHVyZWRFcnJvcnMgIT09IG51bGwpIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZSB1bmhhbmRsZWQgZXJyb3JzLCBzd2l0Y2ggdG8gdGhlIHNsb3cgd29yayBsb29wLlxuICAgICAgLy8gVE9ETzogSG93IHRvIGF2b2lkIHRoaXMgY2hlY2sgaW4gdGhlIGZhc3QgcGF0aD8gTWF5YmUgdGhlIHJlbmRlcmVyXG4gICAgICAvLyBjb3VsZCBrZWVwIHRyYWNrIG9mIHdoaWNoIHJvb3RzIGhhdmUgdW5oYW5kbGVkIGVycm9ycyBhbmQgY2FsbCBhXG4gICAgICAvLyBmb3JrZWQgdmVyc2lvbiBvZiByZW5kZXJSb290LlxuICAgICAgc2xvd1dvcmtMb29wVGhhdENoZWNrc0ZvckZhaWxlZFdvcmsoZXhwaXJhdGlvblRpbWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID4gZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobmV4dFJlbmRlckV4cGlyYXRpb25UaW1lIDw9IG1vc3RSZWNlbnRDdXJyZW50VGltZSkge1xuICAgICAgLy8gRmx1c2ggYWxsIGV4cGlyZWQgd29yay5cbiAgICAgIHdoaWxlIChuZXh0VW5pdE9mV29yayAhPT0gbnVsbCkge1xuICAgICAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1Vbml0T2ZXb3JrKG5leHRVbml0T2ZXb3JrKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmx1c2ggYXN5bmNocm9ub3VzIHdvcmsgdW50aWwgdGhlIGRlYWRsaW5lIHJ1bnMgb3V0IG9mIHRpbWUuXG4gICAgICB3aGlsZSAobmV4dFVuaXRPZldvcmsgIT09IG51bGwgJiYgIXNob3VsZFlpZWxkKCkpIHtcbiAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtVW5pdE9mV29yayhuZXh0VW5pdE9mV29yayk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2xvd1dvcmtMb29wVGhhdENoZWNrc0ZvckZhaWxlZFdvcmsoZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAobmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID4gZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobmV4dFJlbmRlckV4cGlyYXRpb25UaW1lIDw9IG1vc3RSZWNlbnRDdXJyZW50VGltZSkge1xuICAgICAgLy8gRmx1c2ggYWxsIGV4cGlyZWQgd29yay5cbiAgICAgIHdoaWxlIChuZXh0VW5pdE9mV29yayAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoaGFzQ2FwdHVyZWRFcnJvcihuZXh0VW5pdE9mV29yaykpIHtcbiAgICAgICAgICAvLyBVc2UgYSBmb3JrZWQgdmVyc2lvbiBvZiBwZXJmb3JtVW5pdE9mV29ya1xuICAgICAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybUZhaWxlZFVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybVVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZsdXNoIGFzeW5jaHJvbm91cyB3b3JrIHVudGlsIHRoZSBkZWFkbGluZSBydW5zIG91dCBvZiB0aW1lLlxuICAgICAgd2hpbGUgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsICYmICFzaG91bGRZaWVsZCgpKSB7XG4gICAgICAgIGlmIChoYXNDYXB0dXJlZEVycm9yKG5leHRVbml0T2ZXb3JrKSkge1xuICAgICAgICAgIC8vIFVzZSBhIGZvcmtlZCB2ZXJzaW9uIG9mIHBlcmZvcm1Vbml0T2ZXb3JrXG4gICAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtRmFpbGVkVW5pdE9mV29yayhuZXh0VW5pdE9mV29yayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtVW5pdE9mV29yayhuZXh0VW5pdE9mV29yayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJSb290Q2F0Y2hCbG9jayhyb290LCBmYWlsZWRXb3JrLCBib3VuZGFyeSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBXZSdyZSBnb2luZyB0byByZXN0YXJ0IHRoZSBlcnJvciBib3VuZGFyeSB0aGF0IGNhcHR1cmVkIHRoZSBlcnJvci5cbiAgICAvLyBDb25jZXB0dWFsbHksIHdlJ3JlIHVud2luZGluZyB0aGUgc3RhY2suIFdlIG5lZWQgdG8gdW53aW5kIHRoZVxuICAgIC8vIGNvbnRleHQgc3RhY2ssIHRvby5cbiAgICB1bndpbmRDb250ZXh0cyhmYWlsZWRXb3JrLCBib3VuZGFyeSk7XG5cbiAgICAvLyBSZXN0YXJ0IHRoZSBlcnJvciBib3VuZGFyeSB1c2luZyBhIGZvcmtlZCB2ZXJzaW9uIG9mXG4gICAgLy8gcGVyZm9ybVVuaXRPZldvcmsgdGhhdCBkZWxldGVzIHRoZSBib3VuZGFyeSdzIGNoaWxkcmVuLiBUaGUgZW50aXJlXG4gICAgLy8gZmFpbGVkIHN1YnJlZSB3aWxsIGJlIHVubW91bnRlZC4gRHVyaW5nIHRoZSBjb21taXQgcGhhc2UsIGEgc3BlY2lhbFxuICAgIC8vIGxpZmVjeWNsZSBtZXRob2QgaXMgY2FsbGVkIG9uIHRoZSBlcnJvciBib3VuZGFyeSwgd2hpY2ggdHJpZ2dlcnNcbiAgICAvLyBhIHJlLXJlbmRlci5cbiAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1GYWlsZWRVbml0T2ZXb3JrKGJvdW5kYXJ5KTtcblxuICAgIC8vIENvbnRpbnVlIHdvcmtpbmcuXG4gICAgd29ya0xvb3AoZXhwaXJhdGlvblRpbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyUm9vdChyb290LCBleHBpcmF0aW9uVGltZSkge1xuICAgICEhaXNXb3JraW5nID8gaW52YXJpYW50KGZhbHNlLCAncmVuZGVyUm9vdCB3YXMgY2FsbGVkIHJlY3Vyc2l2ZWx5LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIGlzV29ya2luZyA9IHRydWU7XG5cbiAgICAvLyBXZSdyZSBhYm91dCB0byBtdXRhdGUgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgdHJlZS4gSWYgdGhlIHJvb3Qgd2FzIHBlbmRpbmdcbiAgICAvLyBjb21taXQsIGl0IG5vIGxvbmdlciBpczogd2UnbGwgbmVlZCB0byBjb21wbGV0ZSBpdCBhZ2Fpbi5cbiAgICByb290LmlzUmVhZHlGb3JDb21taXQgPSBmYWxzZTtcblxuICAgIC8vIENoZWNrIGlmIHdlJ3JlIHN0YXJ0aW5nIGZyb20gYSBmcmVzaCBzdGFjaywgb3IgaWYgd2UncmUgcmVzdW1pbmcgZnJvbVxuICAgIC8vIHByZXZpb3VzbHkgeWllbGRlZCB3b3JrLlxuICAgIGlmIChyb290ICE9PSBuZXh0Um9vdCB8fCBleHBpcmF0aW9uVGltZSAhPT0gbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lIHx8IG5leHRVbml0T2ZXb3JrID09PSBudWxsKSB7XG4gICAgICAvLyBSZXNldCB0aGUgc3RhY2sgYW5kIHN0YXJ0IHdvcmtpbmcgZnJvbSB0aGUgcm9vdC5cbiAgICAgIHJlc2V0Q29udGV4dFN0YWNrKCk7XG4gICAgICBuZXh0Um9vdCA9IHJvb3Q7XG4gICAgICBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgIG5leHRVbml0T2ZXb3JrID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MobmV4dFJvb3QuY3VycmVudCwgbnVsbCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIHN0YXJ0V29ya0xvb3BUaW1lcihuZXh0VW5pdE9mV29yayk7XG5cbiAgICB2YXIgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICB2YXIgZXJyb3IgPSBudWxsO1xuICAgIHtcbiAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQxKG51bGwsIHdvcmtMb29wLCBudWxsLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICBkaWRFcnJvciA9IHRydWU7XG4gICAgICAgIGVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFuIGVycm9yIHdhcyB0aHJvd24gZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuXG4gICAgd2hpbGUgKGRpZEVycm9yKSB7XG4gICAgICBpZiAoZGlkRmF0YWwpIHtcbiAgICAgICAgLy8gVGhpcyB3YXMgYSBmYXRhbCBlcnJvci4gRG9uJ3QgYXR0ZW1wdCB0byByZWNvdmVyIGZyb20gaXQuXG4gICAgICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IGVycm9yO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIGZhaWxlZFdvcmsgPSBuZXh0VW5pdE9mV29yaztcbiAgICAgIGlmIChmYWlsZWRXb3JrID09PSBudWxsKSB7XG4gICAgICAgIC8vIEFuIGVycm9yIHdhcyB0aHJvd24gYnV0IHRoZXJlJ3Mgbm8gY3VycmVudCB1bml0IG9mIHdvcmsuIFRoaXMgY2FuXG4gICAgICAgIC8vIGhhcHBlbiBkdXJpbmcgdGhlIGNvbW1pdCBwaGFzZSBpZiB0aGVyZSdzIGEgYnVnIGluIHRoZSByZW5kZXJlci5cbiAgICAgICAgZGlkRmF0YWwgPSB0cnVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gXCJDYXB0dXJlXCIgdGhlIGVycm9yIGJ5IGZpbmRpbmcgdGhlIG5lYXJlc3QgYm91bmRhcnkuIElmIHRoZXJlIGlzIG5vXG4gICAgICAvLyBlcnJvciBib3VuZGFyeSwgd2UgdXNlIHRoZSByb290LlxuICAgICAgdmFyIGJvdW5kYXJ5ID0gY2FwdHVyZUVycm9yKGZhaWxlZFdvcmssIGVycm9yKTtcbiAgICAgICEoYm91bmRhcnkgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGhhdmUgZm91bmQgYW4gZXJyb3IgYm91bmRhcnkuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgICAgIGlmIChkaWRGYXRhbCkge1xuICAgICAgICAvLyBUaGUgZXJyb3Igd2UganVzdCBjYXB0dXJlZCB3YXMgYSBmYXRhbCBlcnJvci4gVGhpcyBoYXBwZW5zXG4gICAgICAgIC8vIHdoZW4gdGhlIGVycm9yIHByb3BhZ2F0ZXMgdG8gdGhlIHJvb3QgbW9yZSB0aGFuIG9uY2UuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBkaWRFcnJvciA9IGZhbHNlO1xuICAgICAgZXJyb3IgPSBudWxsO1xuICAgICAge1xuICAgICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMShudWxsLCByZW5kZXJSb290Q2F0Y2hCbG9jaywgbnVsbCwgcm9vdCwgZmFpbGVkV29yaywgYm91bmRhcnksIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgICAgICBkaWRFcnJvciA9IHRydWU7XG4gICAgICAgICAgZXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFdlJ3JlIGZpbmlzaGVkIHdvcmtpbmcuIEV4aXQgdGhlIGVycm9yIGxvb3AuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgdW5jYXVnaHRFcnJvciA9IGZpcnN0VW5jYXVnaHRFcnJvcjtcblxuICAgIC8vIFdlJ3JlIGRvbmUgcGVyZm9ybWluZyB3b3JrLiBUaW1lIHRvIGNsZWFuIHVwLlxuICAgIHN0b3BXb3JrTG9vcFRpbWVyKGludGVycnVwdGVkQnkpO1xuICAgIGludGVycnVwdGVkQnkgPSBudWxsO1xuICAgIGlzV29ya2luZyA9IGZhbHNlO1xuICAgIGRpZEZhdGFsID0gZmFsc2U7XG4gICAgZmlyc3RVbmNhdWdodEVycm9yID0gbnVsbDtcblxuICAgIGlmICh1bmNhdWdodEVycm9yICE9PSBudWxsKSB7XG4gICAgICBvblVuY2F1Z2h0RXJyb3IodW5jYXVnaHRFcnJvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJvb3QuaXNSZWFkeUZvckNvbW1pdCA/IHJvb3QuY3VycmVudC5hbHRlcm5hdGUgOiBudWxsO1xuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgYm91bmRhcnkgdGhhdCBjYXB0dXJlZCB0aGUgZXJyb3IsIG9yIG51bGwgaWYgdGhlIGVycm9yIGlzIGlnbm9yZWRcbiAgZnVuY3Rpb24gY2FwdHVyZUVycm9yKGZhaWxlZFdvcmssIGVycm9yKSB7XG4gICAgLy8gSXQgaXMgbm8gbG9uZ2VyIHZhbGlkIGJlY2F1c2Ugd2UgZXhpdGVkIHRoZSB1c2VyIGNvZGUuXG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5yZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cblxuICAgIC8vIFNlYXJjaCBmb3IgdGhlIG5lYXJlc3QgZXJyb3IgYm91bmRhcnkuXG4gICAgdmFyIGJvdW5kYXJ5ID0gbnVsbDtcblxuICAgIC8vIFBhc3NlZCB0byBsb2dDYXB0dXJlZEVycm9yKClcbiAgICB2YXIgZXJyb3JCb3VuZGFyeUZvdW5kID0gZmFsc2U7XG4gICAgdmFyIHdpbGxSZXRyeSA9IGZhbHNlO1xuICAgIHZhciBlcnJvckJvdW5kYXJ5TmFtZSA9IG51bGw7XG5cbiAgICAvLyBIb3N0IGNvbnRhaW5lcnMgYXJlIGEgc3BlY2lhbCBjYXNlLiBJZiB0aGUgZmFpbGVkIHdvcmsgaXRzZWxmIGlzIGEgaG9zdFxuICAgIC8vIGNvbnRhaW5lciwgdGhlbiBpdCBhY3RzIGFzIGl0cyBvd24gYm91bmRhcnkuIEluIGFsbCBvdGhlciBjYXNlcywgd2VcbiAgICAvLyBpZ25vcmUgdGhlIHdvcmsgaXRzZWxmIGFuZCBvbmx5IHNlYXJjaCB0aHJvdWdoIHRoZSBwYXJlbnRzLlxuICAgIGlmIChmYWlsZWRXb3JrLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgIGJvdW5kYXJ5ID0gZmFpbGVkV29yaztcblxuICAgICAgaWYgKGlzRmFpbGVkQm91bmRhcnkoZmFpbGVkV29yaykpIHtcbiAgICAgICAgLy8gSWYgdGhpcyByb290IGFscmVhZHkgZmFpbGVkLCB0aGVyZSBtdXN0IGhhdmUgYmVlbiBhbiBlcnJvciB3aGVuXG4gICAgICAgIC8vIGF0dGVtcHRpbmcgdG8gdW5tb3VudCBpdC4gVGhpcyBpcyBhIHdvcnN0LWNhc2Ugc2NlbmFyaW8gYW5kXG4gICAgICAgIC8vIHNob3VsZCBvbmx5IGJlIHBvc3NpYmxlIGlmIHRoZXJlJ3MgYSBidWcgaW4gdGhlIHJlbmRlcmVyLlxuICAgICAgICBkaWRGYXRhbCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBub2RlID0gZmFpbGVkV29ya1sncmV0dXJuJ107XG4gICAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCAmJiBib3VuZGFyeSA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gbm9kZS5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZXJyb3JCb3VuZGFyeUZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIGVycm9yQm91bmRhcnlOYW1lID0gZ2V0Q29tcG9uZW50TmFtZShub2RlKTtcblxuICAgICAgICAgICAgLy8gRm91bmQgYW4gZXJyb3IgYm91bmRhcnkhXG4gICAgICAgICAgICBib3VuZGFyeSA9IG5vZGU7XG4gICAgICAgICAgICB3aWxsUmV0cnkgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgICAgICAvLyBUcmVhdCB0aGUgcm9vdCBsaWtlIGEgbm8tb3AgZXJyb3IgYm91bmRhcnlcbiAgICAgICAgICBib3VuZGFyeSA9IG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNGYWlsZWRCb3VuZGFyeShub2RlKSkge1xuICAgICAgICAgIC8vIFRoaXMgYm91bmRhcnkgaXMgYWxyZWFkeSBpbiBhIGZhaWxlZCBzdGF0ZS5cblxuICAgICAgICAgIC8vIElmIHdlJ3JlIGN1cnJlbnRseSB1bm1vdW50aW5nLCB0aGF0IG1lYW5zIHRoaXMgZXJyb3Igd2FzXG4gICAgICAgICAgLy8gdGhyb3duIHdoaWxlIHVubW91bnRpbmcgYSBmYWlsZWQgc3VidHJlZS4gV2Ugc2hvdWxkIGlnbm9yZVxuICAgICAgICAgIC8vIHRoZSBlcnJvci5cbiAgICAgICAgICBpZiAoaXNVbm1vdW50aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBpbiB0aGUgY29tbWl0IHBoYXNlLCB3ZSBzaG91bGQgY2hlY2sgdG8gc2VlIGlmXG4gICAgICAgICAgLy8gdGhpcyBib3VuZGFyeSBhbHJlYWR5IGNhcHR1cmVkIGFuIGVycm9yIGR1cmluZyB0aGlzIGNvbW1pdC5cbiAgICAgICAgICAvLyBUaGlzIGNhc2UgZXhpc3RzIGJlY2F1c2UgbXVsdGlwbGUgZXJyb3JzIGNhbiBiZSB0aHJvd24gZHVyaW5nXG4gICAgICAgICAgLy8gYSBzaW5nbGUgY29tbWl0IHdpdGhvdXQgaW50ZXJydXB0aW9uLlxuICAgICAgICAgIGlmIChjb21taXRQaGFzZUJvdW5kYXJpZXMgIT09IG51bGwgJiYgKGNvbW1pdFBoYXNlQm91bmRhcmllcy5oYXMobm9kZSkgfHwgbm9kZS5hbHRlcm5hdGUgIT09IG51bGwgJiYgY29tbWl0UGhhc2VCb3VuZGFyaWVzLmhhcyhub2RlLmFsdGVybmF0ZSkpKSB7XG4gICAgICAgICAgICAvLyBJZiBzbywgd2Ugc2hvdWxkIGlnbm9yZSB0aGlzIGVycm9yLlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVGhlIGVycm9yIHNob3VsZCBwcm9wYWdhdGUgdG8gdGhlIG5leHQgYm91bmRhcnkgLeKAlCB3ZSBrZWVwIGxvb2tpbmcuXG4gICAgICAgICAgYm91bmRhcnkgPSBudWxsO1xuICAgICAgICAgIHdpbGxSZXRyeSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChib3VuZGFyeSAhPT0gbnVsbCkge1xuICAgICAgLy8gQWRkIHRvIHRoZSBjb2xsZWN0aW9uIG9mIGZhaWxlZCBib3VuZGFyaWVzLiBUaGlzIGxldHMgdXMga25vdyB0aGF0XG4gICAgICAvLyBzdWJzZXF1ZW50IGVycm9ycyBpbiB0aGlzIHN1YnRyZWUgc2hvdWxkIHByb3BhZ2F0ZSB0byB0aGUgbmV4dCBib3VuZGFyeS5cbiAgICAgIGlmIChmYWlsZWRCb3VuZGFyaWVzID09PSBudWxsKSB7XG4gICAgICAgIGZhaWxlZEJvdW5kYXJpZXMgPSBuZXcgU2V0KCk7XG4gICAgICB9XG4gICAgICBmYWlsZWRCb3VuZGFyaWVzLmFkZChib3VuZGFyeSk7XG5cbiAgICAgIC8vIFRoaXMgbWV0aG9kIGlzIHVuc2FmZSBvdXRzaWRlIG9mIHRoZSBiZWdpbiBhbmQgY29tcGxldGUgcGhhc2VzLlxuICAgICAgLy8gV2UgbWlnaHQgYmUgaW4gdGhlIGNvbW1pdCBwaGFzZSB3aGVuIGFuIGVycm9yIGlzIGNhcHR1cmVkLlxuICAgICAgLy8gVGhlIHJpc2sgaXMgdGhhdCB0aGUgcmV0dXJuIHBhdGggZnJvbSB0aGlzIEZpYmVyIG1heSBub3QgYmUgYWNjdXJhdGUuXG4gICAgICAvLyBUaGF0IHJpc2sgaXMgYWNjZXB0YWJsZSBnaXZlbiB0aGUgYmVuZWZpdCBvZiBwcm92aWRpbmcgdXNlcnMgbW9yZSBjb250ZXh0LlxuICAgICAgdmFyIF9jb21wb25lbnRTdGFjayA9IGdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIoZmFpbGVkV29yayk7XG4gICAgICB2YXIgX2NvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZhaWxlZFdvcmspO1xuXG4gICAgICAvLyBBZGQgdG8gdGhlIGNvbGxlY3Rpb24gb2YgY2FwdHVyZWQgZXJyb3JzLiBUaGlzIGlzIHN0b3JlZCBhcyBhIGdsb2JhbFxuICAgICAgLy8gbWFwIG9mIGVycm9ycyBhbmQgdGhlaXIgY29tcG9uZW50IHN0YWNrIGxvY2F0aW9uIGtleWVkIGJ5IHRoZSBib3VuZGFyaWVzXG4gICAgICAvLyB0aGF0IGNhcHR1cmUgdGhlbS4gV2UgbW9zdGx5IHVzZSB0aGlzIE1hcCBhcyBhIFNldDsgaXQncyBhIE1hcCBvbmx5IHRvXG4gICAgICAvLyBhdm9pZCBhZGRpbmcgYSBmaWVsZCB0byBGaWJlciB0byBzdG9yZSB0aGUgZXJyb3IuXG4gICAgICBpZiAoY2FwdHVyZWRFcnJvcnMgPT09IG51bGwpIHtcbiAgICAgICAgY2FwdHVyZWRFcnJvcnMgPSBuZXcgTWFwKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjYXB0dXJlZEVycm9yID0ge1xuICAgICAgICBjb21wb25lbnROYW1lOiBfY29tcG9uZW50TmFtZSxcbiAgICAgICAgY29tcG9uZW50U3RhY2s6IF9jb21wb25lbnRTdGFjayxcbiAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICBlcnJvckJvdW5kYXJ5OiBlcnJvckJvdW5kYXJ5Rm91bmQgPyBib3VuZGFyeS5zdGF0ZU5vZGUgOiBudWxsLFxuICAgICAgICBlcnJvckJvdW5kYXJ5Rm91bmQ6IGVycm9yQm91bmRhcnlGb3VuZCxcbiAgICAgICAgZXJyb3JCb3VuZGFyeU5hbWU6IGVycm9yQm91bmRhcnlOYW1lLFxuICAgICAgICB3aWxsUmV0cnk6IHdpbGxSZXRyeVxuICAgICAgfTtcblxuICAgICAgY2FwdHVyZWRFcnJvcnMuc2V0KGJvdW5kYXJ5LCBjYXB0dXJlZEVycm9yKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgbG9nQ2FwdHVyZWRFcnJvcihjYXB0dXJlZEVycm9yKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gUHJldmVudCBjeWNsZSBpZiBsb2dDYXB0dXJlZEVycm9yKCkgdGhyb3dzLlxuICAgICAgICAvLyBBIGN5Y2xlIG1heSBzdGlsbCBvY2N1ciBpZiBsb2dDYXB0dXJlZEVycm9yIHJlbmRlcnMgYSBjb21wb25lbnQgdGhhdCB0aHJvd3MuXG4gICAgICAgIHZhciBzdXBwcmVzc0xvZ2dpbmcgPSBlICYmIGUuc3VwcHJlc3NSZWFjdEVycm9yTG9nZ2luZztcbiAgICAgICAgaWYgKCFzdXBwcmVzc0xvZ2dpbmcpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlJ3JlIGluIHRoZSBjb21taXQgcGhhc2UsIGRlZmVyIHNjaGVkdWxpbmcgYW4gdXBkYXRlIG9uIHRoZVxuICAgICAgLy8gYm91bmRhcnkgdW50aWwgYWZ0ZXIgdGhlIGNvbW1pdCBpcyBjb21wbGV0ZVxuICAgICAgaWYgKGlzQ29tbWl0dGluZykge1xuICAgICAgICBpZiAoY29tbWl0UGhhc2VCb3VuZGFyaWVzID09PSBudWxsKSB7XG4gICAgICAgICAgY29tbWl0UGhhc2VCb3VuZGFyaWVzID0gbmV3IFNldCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbW1pdFBoYXNlQm91bmRhcmllcy5hZGQoYm91bmRhcnkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBzY2hlZHVsZSBhbiB1cGRhdGUgbm93LlxuICAgICAgICAvLyBUT0RPOiBJcyB0aGlzIGFjdHVhbGx5IG5lY2Vzc2FyeSBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZT8gSXMgaXRcbiAgICAgICAgLy8gcG9zc2libGUgdG8gdW53aW5kIGFuZCBjb250aW51ZSByZW5kZXJpbmcgYXQgdGhlIHNhbWUgcHJpb3JpdHksXG4gICAgICAgIC8vIHdpdGhvdXQgY29ycnVwdGluZyBpbnRlcm5hbCBzdGF0ZT9cbiAgICAgICAgc2NoZWR1bGVFcnJvclJlY292ZXJ5KGJvdW5kYXJ5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBib3VuZGFyeTtcbiAgICB9IGVsc2UgaWYgKGZpcnN0VW5jYXVnaHRFcnJvciA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgbm8gYm91bmRhcnkgaXMgZm91bmQsIHdlJ2xsIG5lZWQgdG8gdGhyb3cgdGhlIGVycm9yXG4gICAgICBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNDYXB0dXJlZEVycm9yKGZpYmVyKSB7XG4gICAgLy8gVE9ETzogY2FwdHVyZWRFcnJvcnMgc2hvdWxkIHN0b3JlIHRoZSBib3VuZGFyeSBpbnN0YW5jZSwgdG8gYXZvaWQgbmVlZGluZ1xuICAgIC8vIHRvIGNoZWNrIHRoZSBhbHRlcm5hdGUuXG4gICAgcmV0dXJuIGNhcHR1cmVkRXJyb3JzICE9PSBudWxsICYmIChjYXB0dXJlZEVycm9ycy5oYXMoZmliZXIpIHx8IGZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbCAmJiBjYXB0dXJlZEVycm9ycy5oYXMoZmliZXIuYWx0ZXJuYXRlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0ZhaWxlZEJvdW5kYXJ5KGZpYmVyKSB7XG4gICAgLy8gVE9ETzogZmFpbGVkQm91bmRhcmllcyBzaG91bGQgc3RvcmUgdGhlIGJvdW5kYXJ5IGluc3RhbmNlLCB0byBhdm9pZFxuICAgIC8vIG5lZWRpbmcgdG8gY2hlY2sgdGhlIGFsdGVybmF0ZS5cbiAgICByZXR1cm4gZmFpbGVkQm91bmRhcmllcyAhPT0gbnVsbCAmJiAoZmFpbGVkQm91bmRhcmllcy5oYXMoZmliZXIpIHx8IGZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbCAmJiBmYWlsZWRCb3VuZGFyaWVzLmhhcyhmaWJlci5hbHRlcm5hdGUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdEVycm9ySGFuZGxpbmcoZWZmZWN0ZnVsRmliZXIpIHtcbiAgICB2YXIgY2FwdHVyZWRFcnJvciA9IHZvaWQgMDtcbiAgICBpZiAoY2FwdHVyZWRFcnJvcnMgIT09IG51bGwpIHtcbiAgICAgIGNhcHR1cmVkRXJyb3IgPSBjYXB0dXJlZEVycm9ycy5nZXQoZWZmZWN0ZnVsRmliZXIpO1xuICAgICAgY2FwdHVyZWRFcnJvcnNbJ2RlbGV0ZSddKGVmZmVjdGZ1bEZpYmVyKTtcbiAgICAgIGlmIChjYXB0dXJlZEVycm9yID09IG51bGwpIHtcbiAgICAgICAgaWYgKGVmZmVjdGZ1bEZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGVmZmVjdGZ1bEZpYmVyID0gZWZmZWN0ZnVsRmliZXIuYWx0ZXJuYXRlO1xuICAgICAgICAgIGNhcHR1cmVkRXJyb3IgPSBjYXB0dXJlZEVycm9ycy5nZXQoZWZmZWN0ZnVsRmliZXIpO1xuICAgICAgICAgIGNhcHR1cmVkRXJyb3JzWydkZWxldGUnXShlZmZlY3RmdWxGaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAhKGNhcHR1cmVkRXJyb3IgIT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdObyBlcnJvciBmb3IgZ2l2ZW4gdW5pdCBvZiB3b3JrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAgc3dpdGNoIChlZmZlY3RmdWxGaWJlci50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGVmZmVjdGZ1bEZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgICB2YXIgaW5mbyA9IHtcbiAgICAgICAgICBjb21wb25lbnRTdGFjazogY2FwdHVyZWRFcnJvci5jb21wb25lbnRTdGFja1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEFsbG93IHRoZSBib3VuZGFyeSB0byBoYW5kbGUgdGhlIGVycm9yLCB1c3VhbGx5IGJ5IHNjaGVkdWxpbmdcbiAgICAgICAgLy8gYW4gdXBkYXRlIHRvIGl0c2VsZlxuICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaChjYXB0dXJlZEVycm9yLmVycm9yLCBpbmZvKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgaWYgKGZpcnN0VW5jYXVnaHRFcnJvciA9PT0gbnVsbCkge1xuICAgICAgICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IGNhcHR1cmVkRXJyb3IuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCB0eXBlIG9mIHdvcmsuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdW53aW5kQ29udGV4dHMoZnJvbSwgdG8pIHtcbiAgICB2YXIgbm9kZSA9IGZyb207XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobm9kZS50YWcpIHtcbiAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICBwb3BDb250ZXh0UHJvdmlkZXIobm9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICBwb3BIb3N0Q29udGV4dChub2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICBwb3BIb3N0Q29udGFpbmVyKG5vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgICAgcG9wSG9zdENvbnRhaW5lcihub2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSB0byB8fCBub2RlLmFsdGVybmF0ZSA9PT0gdG8pIHtcbiAgICAgICAgc3RvcEZhaWxlZFdvcmtUaW1lcihub2RlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdG9wV29ya1RpbWVyKG5vZGUpO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXB1dGVBc3luY0V4cGlyYXRpb24oKSB7XG4gICAgLy8gR2l2ZW4gdGhlIGN1cnJlbnQgY2xvY2sgdGltZSwgcmV0dXJucyBhbiBleHBpcmF0aW9uIHRpbWUuIFdlIHVzZSByb3VuZGluZ1xuICAgIC8vIHRvIGJhdGNoIGxpa2UgdXBkYXRlcyB0b2dldGhlci5cbiAgICAvLyBTaG91bGQgY29tcGxldGUgd2l0aGluIH4xMDAwbXMuIDEyMDBtcyBtYXguXG4gICAgdmFyIGN1cnJlbnRUaW1lID0gcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpO1xuICAgIHZhciBleHBpcmF0aW9uTXMgPSAxMDAwO1xuICAgIHZhciBidWNrZXRTaXplTXMgPSAyMDA7XG4gICAgcmV0dXJuIGNvbXB1dGVFeHBpcmF0aW9uQnVja2V0KGN1cnJlbnRUaW1lLCBleHBpcmF0aW9uTXMsIGJ1Y2tldFNpemVNcyk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKGZpYmVyKSB7XG4gICAgdmFyIGV4cGlyYXRpb25UaW1lID0gdm9pZCAwO1xuICAgIGlmIChleHBpcmF0aW9uQ29udGV4dCAhPT0gTm9Xb3JrKSB7XG4gICAgICAvLyBBbiBleHBsaWNpdCBleHBpcmF0aW9uIGNvbnRleHQgd2FzIHNldDtcbiAgICAgIGV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvbkNvbnRleHQ7XG4gICAgfSBlbHNlIGlmIChpc1dvcmtpbmcpIHtcbiAgICAgIGlmIChpc0NvbW1pdHRpbmcpIHtcbiAgICAgICAgLy8gVXBkYXRlcyB0aGF0IG9jY3VyIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlIHNob3VsZCBoYXZlIHN5bmMgcHJpb3JpdHlcbiAgICAgICAgLy8gYnkgZGVmYXVsdC5cbiAgICAgICAgZXhwaXJhdGlvblRpbWUgPSBTeW5jO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVXBkYXRlcyBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSBzaG91bGQgZXhwaXJlIGF0IHRoZSBzYW1lIHRpbWUgYXNcbiAgICAgICAgLy8gdGhlIHdvcmsgdGhhdCBpcyBiZWluZyByZW5kZXJlZC5cbiAgICAgICAgZXhwaXJhdGlvblRpbWUgPSBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vIGV4cGxpY2l0IGV4cGlyYXRpb24gY29udGV4dCB3YXMgc2V0LCBhbmQgd2UncmUgbm90IGN1cnJlbnRseVxuICAgICAgLy8gcGVyZm9ybWluZyB3b3JrLiBDYWxjdWxhdGUgYSBuZXcgZXhwaXJhdGlvbiB0aW1lLlxuICAgICAgaWYgKHVzZVN5bmNTY2hlZHVsaW5nICYmICEoZmliZXIuaW50ZXJuYWxDb250ZXh0VGFnICYgQXN5bmNVcGRhdGVzKSkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgc3luYyB1cGRhdGVcbiAgICAgICAgZXhwaXJhdGlvblRpbWUgPSBTeW5jO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhbiBhc3luYyB1cGRhdGVcbiAgICAgICAgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleHBpcmF0aW9uVGltZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlV29yayhmaWJlciwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICByZXR1cm4gc2NoZWR1bGVXb3JrSW1wbChmaWJlciwgZXhwaXJhdGlvblRpbWUsIGZhbHNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrUm9vdE5lZWRzQ2xlYXJpbmcocm9vdCwgZmliZXIsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKCFpc1dvcmtpbmcgJiYgcm9vdCA9PT0gbmV4dFJvb3QgJiYgZXhwaXJhdGlvblRpbWUgPCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIC8vIFJlc3RhcnQgdGhlIHJvb3QgZnJvbSB0aGUgdG9wLlxuICAgICAgaWYgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYW4gaW50ZXJydXB0aW9uLiAoVXNlZCBmb3IgcGVyZm9ybWFuY2UgdHJhY2tpbmcuKVxuICAgICAgICBpbnRlcnJ1cHRlZEJ5ID0gZmliZXI7XG4gICAgICB9XG4gICAgICBuZXh0Um9vdCA9IG51bGw7XG4gICAgICBuZXh0VW5pdE9mV29yayA9IG51bGw7XG4gICAgICBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGVXb3JrSW1wbChmaWJlciwgZXhwaXJhdGlvblRpbWUsIGlzRXJyb3JSZWNvdmVyeSkge1xuICAgIHJlY29yZFNjaGVkdWxlVXBkYXRlKCk7XG5cbiAgICB7XG4gICAgICBpZiAoIWlzRXJyb3JSZWNvdmVyeSAmJiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgd2FybkFib3V0SW52YWxpZFVwZGF0ZXMoaW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBub2RlID0gZmliZXI7XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIC8vIFdhbGsgdGhlIHBhcmVudCBwYXRoIHRvIHRoZSByb290IGFuZCB1cGRhdGUgZWFjaCBub2RlJ3NcbiAgICAgIC8vIGV4cGlyYXRpb24gdGltZS5cbiAgICAgIGlmIChub2RlLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbm9kZS5leHBpcmF0aW9uVGltZSA+IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIG5vZGUuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS5hbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBub2RlLmFsdGVybmF0ZS5leHBpcmF0aW9uVGltZSA+IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgICAgbm9kZS5hbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgICAgICB2YXIgcm9vdCA9IG5vZGUuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgY2hlY2tSb290TmVlZHNDbGVhcmluZyhyb290LCBmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIHJlcXVlc3RXb3JrKHJvb3QsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICBjaGVja1Jvb3ROZWVkc0NsZWFyaW5nKHJvb3QsIGZpYmVyLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFpc0Vycm9yUmVjb3ZlcnkgJiYgZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICB3YXJuQWJvdXRVcGRhdGVPblVubW91bnRlZChmaWJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlRXJyb3JSZWNvdmVyeShmaWJlcikge1xuICAgIHNjaGVkdWxlV29ya0ltcGwoZmliZXIsIFN5bmMsIHRydWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpIHtcbiAgICAvLyBTdWJ0cmFjdCBpbml0aWFsIHRpbWUgc28gaXQgZml0cyBpbnNpZGUgMzJiaXRzXG4gICAgdmFyIG1zID0gbm93KCkgLSBzdGFydFRpbWU7XG4gICAgbW9zdFJlY2VudEN1cnJlbnRUaW1lID0gbXNUb0V4cGlyYXRpb25UaW1lKG1zKTtcbiAgICByZXR1cm4gbW9zdFJlY2VudEN1cnJlbnRUaW1lO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVmZXJyZWRVcGRhdGVzKGZuKSB7XG4gICAgdmFyIHByZXZpb3VzRXhwaXJhdGlvbkNvbnRleHQgPSBleHBpcmF0aW9uQ29udGV4dDtcbiAgICBleHBpcmF0aW9uQ29udGV4dCA9IGNvbXB1dGVBc3luY0V4cGlyYXRpb24oKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGV4cGlyYXRpb25Db250ZXh0ID0gcHJldmlvdXNFeHBpcmF0aW9uQ29udGV4dDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzeW5jVXBkYXRlcyhmbikge1xuICAgIHZhciBwcmV2aW91c0V4cGlyYXRpb25Db250ZXh0ID0gZXhwaXJhdGlvbkNvbnRleHQ7XG4gICAgZXhwaXJhdGlvbkNvbnRleHQgPSBTeW5jO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZXhwaXJhdGlvbkNvbnRleHQgPSBwcmV2aW91c0V4cGlyYXRpb25Db250ZXh0O1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IEV2ZXJ5dGhpbmcgYmVsb3cgdGhpcyBpcyB3cml0dGVuIGFzIGlmIGl0IGhhcyBiZWVuIGxpZnRlZCB0byB0aGVcbiAgLy8gcmVuZGVyZXJzLiBJJ2xsIGRvIHRoaXMgaW4gYSBmb2xsb3ctdXAuXG5cbiAgLy8gTGlua2VkLWxpc3Qgb2Ygcm9vdHNcbiAgdmFyIGZpcnN0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gIHZhciBsYXN0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG5cbiAgdmFyIGNhbGxiYWNrRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gIHZhciBjYWxsYmFja0lEID0gLTE7XG4gIHZhciBpc1JlbmRlcmluZyA9IGZhbHNlO1xuICB2YXIgbmV4dEZsdXNoZWRSb290ID0gbnVsbDtcbiAgdmFyIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gIHZhciBkZWFkbGluZURpZEV4cGlyZSA9IGZhbHNlO1xuICB2YXIgaGFzVW5oYW5kbGVkRXJyb3IgPSBmYWxzZTtcbiAgdmFyIHVuaGFuZGxlZEVycm9yID0gbnVsbDtcbiAgdmFyIGRlYWRsaW5lID0gbnVsbDtcblxuICB2YXIgaXNCYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcbiAgdmFyIGlzVW5iYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcblxuICAvLyBVc2UgdGhlc2UgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wIG9mIG5lc3RlZCB1cGRhdGVzXG4gIHZhciBORVNURURfVVBEQVRFX0xJTUlUID0gMTAwMDtcbiAgdmFyIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcblxuICB2YXIgdGltZUhldXJpc3RpY0ZvclVuaXRPZldvcmsgPSAxO1xuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlQ2FsbGJhY2tXaXRoRXhwaXJhdGlvbihleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjYWxsYmFja0V4cGlyYXRpb25UaW1lICE9PSBOb1dvcmspIHtcbiAgICAgIC8vIEEgY2FsbGJhY2sgaXMgYWxyZWFkeSBzY2hlZHVsZWQuIENoZWNrIGl0cyBleHBpcmF0aW9uIHRpbWUgKHRpbWVvdXQpLlxuICAgICAgaWYgKGV4cGlyYXRpb25UaW1lID4gY2FsbGJhY2tFeHBpcmF0aW9uVGltZSkge1xuICAgICAgICAvLyBFeGlzdGluZyBjYWxsYmFjayBoYXMgc3VmZmljaWVudCB0aW1lb3V0LiBFeGl0LlxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFeGlzdGluZyBjYWxsYmFjayBoYXMgaW5zdWZmaWNpZW50IHRpbWVvdXQuIENhbmNlbCBhbmQgc2NoZWR1bGUgYVxuICAgICAgICAvLyBuZXcgb25lLlxuICAgICAgICBjYW5jZWxEZWZlcnJlZENhbGxiYWNrKGNhbGxiYWNrSUQpO1xuICAgICAgfVxuICAgICAgLy8gVGhlIHJlcXVlc3QgY2FsbGJhY2sgdGltZXIgaXMgYWxyZWFkeSBydW5uaW5nLiBEb24ndCBzdGFydCBhIG5ldyBvbmUuXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0UmVxdWVzdENhbGxiYWNrVGltZXIoKTtcbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIGEgdGltZW91dCBmb3IgdGhlIGdpdmVuIGV4cGlyYXRpb24gdGltZS5cbiAgICB2YXIgY3VycmVudE1zID0gbm93KCkgLSBzdGFydFRpbWU7XG4gICAgdmFyIGV4cGlyYXRpb25NcyA9IGV4cGlyYXRpb25UaW1lVG9NcyhleHBpcmF0aW9uVGltZSk7XG4gICAgdmFyIHRpbWVvdXQgPSBleHBpcmF0aW9uTXMgLSBjdXJyZW50TXM7XG5cbiAgICBjYWxsYmFja0V4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgY2FsbGJhY2tJRCA9IHNjaGVkdWxlRGVmZXJyZWRDYWxsYmFjayhwZXJmb3JtQXN5bmNXb3JrLCB7IHRpbWVvdXQ6IHRpbWVvdXQgfSk7XG4gIH1cblxuICAvLyByZXF1ZXN0V29yayBpcyBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlciB3aGVuZXZlciBhIHJvb3QgcmVjZWl2ZXMgYW4gdXBkYXRlLlxuICAvLyBJdCdzIHVwIHRvIHRoZSByZW5kZXJlciB0byBjYWxsIHJlbmRlclJvb3QgYXQgc29tZSBwb2ludCBpbiB0aGUgZnV0dXJlLlxuICBmdW5jdGlvbiByZXF1ZXN0V29yayhyb290LCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChuZXN0ZWRVcGRhdGVDb3VudCA+IE5FU1RFRF9VUERBVEVfTElNSVQpIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ01heGltdW0gdXBkYXRlIGRlcHRoIGV4Y2VlZGVkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBhIGNvbXBvbmVudCByZXBlYXRlZGx5IGNhbGxzIHNldFN0YXRlIGluc2lkZSBjb21wb25lbnRXaWxsVXBkYXRlIG9yIGNvbXBvbmVudERpZFVwZGF0ZS4gUmVhY3QgbGltaXRzIHRoZSBudW1iZXIgb2YgbmVzdGVkIHVwZGF0ZXMgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wcy4nKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIHJvb3QgdG8gdGhlIHNjaGVkdWxlLlxuICAgIC8vIENoZWNrIGlmIHRoaXMgcm9vdCBpcyBhbHJlYWR5IHBhcnQgb2YgdGhlIHNjaGVkdWxlLlxuICAgIGlmIChyb290Lm5leHRTY2hlZHVsZWRSb290ID09PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIHJvb3QgaXMgbm90IGFscmVhZHkgc2NoZWR1bGVkLiBBZGQgaXQuXG4gICAgICByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICBpZiAobGFzdFNjaGVkdWxlZFJvb3QgPT09IG51bGwpIHtcbiAgICAgICAgZmlyc3RTY2hlZHVsZWRSb290ID0gbGFzdFNjaGVkdWxlZFJvb3QgPSByb290O1xuICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhc3RTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QgPSByb290O1xuICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IGZpcnN0U2NoZWR1bGVkUm9vdDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyByb290IGlzIGFscmVhZHkgc2NoZWR1bGVkLCBidXQgaXRzIHByaW9yaXR5IG1heSBoYXZlIGluY3JlYXNlZC5cbiAgICAgIHZhciByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWU7XG4gICAgICBpZiAocmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBleHBpcmF0aW9uVGltZSA8IHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcHJpb3JpdHkuXG4gICAgICAgIHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNSZW5kZXJpbmcpIHtcbiAgICAgIC8vIFByZXZlbnQgcmVlbnRyYW5jeS4gUmVtYWluaW5nIHdvcmsgd2lsbCBiZSBzY2hlZHVsZWQgYXQgdGhlIGVuZCBvZlxuICAgICAgLy8gdGhlIGN1cnJlbnRseSByZW5kZXJpbmcgYmF0Y2guXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzQmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgICAvLyBGbHVzaCB3b3JrIGF0IHRoZSBlbmQgb2YgdGhlIGJhdGNoLlxuICAgICAgaWYgKGlzVW5iYXRjaGluZ1VwZGF0ZXMpIHtcbiAgICAgICAgLy8gLi4udW5sZXNzIHdlJ3JlIGluc2lkZSB1bmJhdGNoZWRVcGRhdGVzLCBpbiB3aGljaCBjYXNlIHdlIHNob3VsZFxuICAgICAgICAvLyBmbHVzaCBpdCBub3cuXG4gICAgICAgIG5leHRGbHVzaGVkUm9vdCA9IHJvb3Q7XG4gICAgICAgIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPSBTeW5jO1xuICAgICAgICBwZXJmb3JtV29ya09uUm9vdChuZXh0Rmx1c2hlZFJvb3QsIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRPRE86IEdldCByaWQgb2YgU3luYyBhbmQgdXNlIGN1cnJlbnQgdGltZT9cbiAgICBpZiAoZXhwaXJhdGlvblRpbWUgPT09IFN5bmMpIHtcbiAgICAgIHBlcmZvcm1Xb3JrKFN5bmMsIG51bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlZHVsZUNhbGxiYWNrV2l0aEV4cGlyYXRpb24oZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRIaWdoZXN0UHJpb3JpdHlSb290KCkge1xuICAgIHZhciBoaWdoZXN0UHJpb3JpdHlXb3JrID0gTm9Xb3JrO1xuICAgIHZhciBoaWdoZXN0UHJpb3JpdHlSb290ID0gbnVsbDtcblxuICAgIGlmIChsYXN0U2NoZWR1bGVkUm9vdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIHByZXZpb3VzU2NoZWR1bGVkUm9vdCA9IGxhc3RTY2hlZHVsZWRSb290O1xuICAgICAgdmFyIHJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7XG4gICAgICB3aGlsZSAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lO1xuICAgICAgICBpZiAocmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPT09IE5vV29yaykge1xuICAgICAgICAgIC8vIFRoaXMgcm9vdCBubyBsb25nZXIgaGFzIHdvcmsuIFJlbW92ZSBpdCBmcm9tIHRoZSBzY2hlZHVsZXIuXG5cbiAgICAgICAgICAvLyBUT0RPOiBUaGlzIGNoZWNrIGlzIHJlZHVkYW50LCBidXQgRmxvdyBpcyBjb25mdXNlZCBieSB0aGUgYnJhbmNoXG4gICAgICAgICAgLy8gYmVsb3cgd2hlcmUgd2Ugc2V0IGxhc3RTY2hlZHVsZWRSb290IHRvIG51bGwsIGV2ZW4gdGhvdWdoIHdlIGJyZWFrXG4gICAgICAgICAgLy8gZnJvbSB0aGUgbG9vcCByaWdodCBhZnRlci5cbiAgICAgICAgICAhKHByZXZpb3VzU2NoZWR1bGVkUm9vdCAhPT0gbnVsbCAmJiBsYXN0U2NoZWR1bGVkUm9vdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgaGF2ZSBhIHByZXZpb3VzIGFuZCBsYXN0IHJvb3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgaWYgKHJvb3QgPT09IHJvb3QubmV4dFNjaGVkdWxlZFJvb3QpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIG9ubHkgcm9vdCBpbiB0aGUgbGlzdC5cbiAgICAgICAgICAgIHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICAgICAgZmlyc3RTY2hlZHVsZWRSb290ID0gbGFzdFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIGlmIChyb290ID09PSBmaXJzdFNjaGVkdWxlZFJvb3QpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHJvb3QgaW4gdGhlIGxpc3QuXG4gICAgICAgICAgICB2YXIgbmV4dCA9IHJvb3QubmV4dFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgICAgICBmaXJzdFNjaGVkdWxlZFJvb3QgPSBuZXh0O1xuICAgICAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBuZXh0O1xuICAgICAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIGlmIChyb290ID09PSBsYXN0U2NoZWR1bGVkUm9vdCkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgbGFzdCByb290IGluIHRoZSBsaXN0LlxuICAgICAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QgPSBwcmV2aW91c1NjaGVkdWxlZFJvb3Q7XG4gICAgICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IGZpcnN0U2NoZWR1bGVkUm9vdDtcbiAgICAgICAgICAgIHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZXZpb3VzU2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IHJvb3QubmV4dFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcm9vdCA9IHByZXZpb3VzU2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaGlnaGVzdFByaW9yaXR5V29yayA9PT0gTm9Xb3JrIHx8IHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lIDwgaGlnaGVzdFByaW9yaXR5V29yaykge1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBwcmlvcml0eSwgaWYgaXQncyBoaWdoZXJcbiAgICAgICAgICAgIGhpZ2hlc3RQcmlvcml0eVdvcmsgPSByZW1haW5pbmdFeHBpcmF0aW9uVGltZTtcbiAgICAgICAgICAgIGhpZ2hlc3RQcmlvcml0eVJvb3QgPSByb290O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocm9vdCA9PT0gbGFzdFNjaGVkdWxlZFJvb3QpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcmV2aW91c1NjaGVkdWxlZFJvb3QgPSByb290O1xuICAgICAgICAgIHJvb3QgPSByb290Lm5leHRTY2hlZHVsZWRSb290O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIG5leHQgcm9vdCBpcyB0aGUgc2FtZSBhcyB0aGUgcHJldmlvdXMgcm9vdCwgdGhpcyBpcyBhIG5lc3RlZFxuICAgIC8vIHVwZGF0ZS4gVG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wLCBpbmNyZW1lbnQgdGhlIG5lc3RlZCB1cGRhdGUgY291bnQuXG4gICAgdmFyIHByZXZpb3VzRmx1c2hlZFJvb3QgPSBuZXh0Rmx1c2hlZFJvb3Q7XG4gICAgaWYgKHByZXZpb3VzRmx1c2hlZFJvb3QgIT09IG51bGwgJiYgcHJldmlvdXNGbHVzaGVkUm9vdCA9PT0gaGlnaGVzdFByaW9yaXR5Um9vdCkge1xuICAgICAgbmVzdGVkVXBkYXRlQ291bnQrKztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVzZXQgd2hlbmV2ZXIgd2Ugc3dpdGNoIHJvb3RzLlxuICAgICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuICAgIH1cbiAgICBuZXh0Rmx1c2hlZFJvb3QgPSBoaWdoZXN0UHJpb3JpdHlSb290O1xuICAgIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPSBoaWdoZXN0UHJpb3JpdHlXb3JrO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybUFzeW5jV29yayhkbCkge1xuICAgIHBlcmZvcm1Xb3JrKE5vV29yaywgZGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybVdvcmsobWluRXhwaXJhdGlvblRpbWUsIGRsKSB7XG4gICAgZGVhZGxpbmUgPSBkbDtcblxuICAgIC8vIEtlZXAgd29ya2luZyBvbiByb290cyB1bnRpbCB0aGVyZSdzIG5vIG1vcmUgd29yaywgb3IgdW50aWwgdGhlIHdlIHJlYWNoXG4gICAgLy8gdGhlIGRlYWRsaW5lLlxuICAgIGZpbmRIaWdoZXN0UHJpb3JpdHlSb290KCk7XG5cbiAgICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSAmJiBkZWFkbGluZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIGRpZEV4cGlyZSA9IG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPCByZWNhbGN1bGF0ZUN1cnJlbnRUaW1lKCk7XG4gICAgICBzdG9wUmVxdWVzdENhbGxiYWNrVGltZXIoZGlkRXhwaXJlKTtcbiAgICB9XG5cbiAgICB3aGlsZSAobmV4dEZsdXNoZWRSb290ICE9PSBudWxsICYmIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgIT09IE5vV29yayAmJiAobWluRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lIDw9IG1pbkV4cGlyYXRpb25UaW1lKSAmJiAhZGVhZGxpbmVEaWRFeHBpcmUpIHtcbiAgICAgIHBlcmZvcm1Xb3JrT25Sb290KG5leHRGbHVzaGVkUm9vdCwgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSk7XG4gICAgICAvLyBGaW5kIHRoZSBuZXh0IGhpZ2hlc3QgcHJpb3JpdHkgd29yay5cbiAgICAgIGZpbmRIaWdoZXN0UHJpb3JpdHlSb290KCk7XG4gICAgfVxuXG4gICAgLy8gV2UncmUgZG9uZSBmbHVzaGluZyB3b3JrLiBFaXRoZXIgd2UgcmFuIG91dCBvZiB0aW1lIGluIHRoaXMgY2FsbGJhY2ssXG4gICAgLy8gb3IgdGhlcmUncyBubyBtb3JlIHdvcmsgbGVmdCB3aXRoIHN1ZmZpY2llbnQgcHJpb3JpdHkuXG5cbiAgICAvLyBJZiB3ZSdyZSBpbnNpZGUgYSBjYWxsYmFjaywgc2V0IHRoaXMgdG8gZmFsc2Ugc2luY2Ugd2UganVzdCBjb21wbGV0ZWQgaXQuXG4gICAgaWYgKGRlYWRsaW5lICE9PSBudWxsKSB7XG4gICAgICBjYWxsYmFja0V4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICAgICAgY2FsbGJhY2tJRCA9IC0xO1xuICAgIH1cbiAgICAvLyBJZiB0aGVyZSdzIHdvcmsgbGVmdCBvdmVyLCBzY2hlZHVsZSBhIG5ldyBjYWxsYmFjay5cbiAgICBpZiAobmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrKSB7XG4gICAgICBzY2hlZHVsZUNhbGxiYWNrV2l0aEV4cGlyYXRpb24obmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSk7XG4gICAgfVxuXG4gICAgLy8gQ2xlYW4tdXAuXG4gICAgZGVhZGxpbmUgPSBudWxsO1xuICAgIGRlYWRsaW5lRGlkRXhwaXJlID0gZmFsc2U7XG4gICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuXG4gICAgaWYgKGhhc1VuaGFuZGxlZEVycm9yKSB7XG4gICAgICB2YXIgX2Vycm9yNCA9IHVuaGFuZGxlZEVycm9yO1xuICAgICAgdW5oYW5kbGVkRXJyb3IgPSBudWxsO1xuICAgICAgaGFzVW5oYW5kbGVkRXJyb3IgPSBmYWxzZTtcbiAgICAgIHRocm93IF9lcnJvcjQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybVdvcmtPblJvb3Qocm9vdCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAhIWlzUmVuZGVyaW5nID8gaW52YXJpYW50KGZhbHNlLCAncGVyZm9ybVdvcmtPblJvb3Qgd2FzIGNhbGxlZCByZWN1cnNpdmVseS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICAgIGlzUmVuZGVyaW5nID0gdHJ1ZTtcblxuICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYXN5bmMgd29yayBvciBzeW5jL2V4cGlyZWQgd29yay5cbiAgICAvLyBUT0RPOiBQYXNzIGN1cnJlbnQgdGltZSBhcyBhcmd1bWVudCB0byByZW5kZXJSb290LCBjb21taXRSb290XG4gICAgaWYgKGV4cGlyYXRpb25UaW1lIDw9IHJlY2FsY3VsYXRlQ3VycmVudFRpbWUoKSkge1xuICAgICAgLy8gRmx1c2ggc3luYyB3b3JrLlxuICAgICAgdmFyIGZpbmlzaGVkV29yayA9IHJvb3QuZmluaXNoZWRXb3JrO1xuICAgICAgaWYgKGZpbmlzaGVkV29yayAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGlzIHJvb3QgaXMgYWxyZWFkeSBjb21wbGV0ZS4gV2UgY2FuIGNvbW1pdCBpdC5cbiAgICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuICAgICAgICByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gY29tbWl0Um9vdChmaW5pc2hlZFdvcmspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuICAgICAgICBmaW5pc2hlZFdvcmsgPSByZW5kZXJSb290KHJvb3QsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgaWYgKGZpbmlzaGVkV29yayAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlJ3ZlIGNvbXBsZXRlZCB0aGUgcm9vdC4gQ29tbWl0IGl0LlxuICAgICAgICAgIHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBjb21taXRSb290KGZpbmlzaGVkV29yayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmx1c2ggYXN5bmMgd29yay5cbiAgICAgIHZhciBfZmluaXNoZWRXb3JrID0gcm9vdC5maW5pc2hlZFdvcms7XG4gICAgICBpZiAoX2ZpbmlzaGVkV29yayAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGlzIHJvb3QgaXMgYWxyZWFkeSBjb21wbGV0ZS4gV2UgY2FuIGNvbW1pdCBpdC5cbiAgICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuICAgICAgICByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gY29tbWl0Um9vdChfZmluaXNoZWRXb3JrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgICAgX2ZpbmlzaGVkV29yayA9IHJlbmRlclJvb3Qocm9vdCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBpZiAoX2ZpbmlzaGVkV29yayAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlJ3ZlIGNvbXBsZXRlZCB0aGUgcm9vdC4gQ2hlY2sgdGhlIGRlYWRsaW5lIG9uZSBtb3JlIHRpbWVcbiAgICAgICAgICAvLyBiZWZvcmUgY29tbWl0dGluZy5cbiAgICAgICAgICBpZiAoIXNob3VsZFlpZWxkKCkpIHtcbiAgICAgICAgICAgIC8vIFN0aWxsIHRpbWUgbGVmdC4gQ29tbWl0IHRoZSByb290LlxuICAgICAgICAgICAgcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IGNvbW1pdFJvb3QoX2ZpbmlzaGVkV29yayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZXJlJ3Mgbm8gdGltZSBsZWZ0LiBNYXJrIHRoaXMgcm9vdCBhcyBjb21wbGV0ZS4gV2UnbGwgY29tZVxuICAgICAgICAgICAgLy8gYmFjayBhbmQgY29tbWl0IGl0IGxhdGVyLlxuICAgICAgICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBfZmluaXNoZWRXb3JrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlzUmVuZGVyaW5nID0gZmFsc2U7XG4gIH1cblxuICAvLyBXaGVuIHdvcmtpbmcgb24gYXN5bmMgd29yaywgdGhlIHJlY29uY2lsZXIgYXNrcyB0aGUgcmVuZGVyZXIgaWYgaXQgc2hvdWxkXG4gIC8vIHlpZWxkIGV4ZWN1dGlvbi4gRm9yIERPTSwgd2UgaW1wbGVtZW50IHRoaXMgd2l0aCByZXF1ZXN0SWRsZUNhbGxiYWNrLlxuICBmdW5jdGlvbiBzaG91bGRZaWVsZCgpIHtcbiAgICBpZiAoZGVhZGxpbmUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRlYWRsaW5lLnRpbWVSZW1haW5pbmcoKSA+IHRpbWVIZXVyaXN0aWNGb3JVbml0T2ZXb3JrKSB7XG4gICAgICAvLyBEaXNyZWdhcmQgZGVhZGxpbmUuZGlkVGltZW91dC4gT25seSBleHBpcmVkIHdvcmsgc2hvdWxkIGJlIGZsdXNoZWRcbiAgICAgIC8vIGR1cmluZyBhIHRpbWVvdXQuIFRoaXMgcGF0aCBpcyBvbmx5IGhpdCBmb3Igbm9uLWV4cGlyZWQgd29yay5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZGVhZGxpbmVEaWRFeHBpcmUgPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gVE9ETzogTm90IGhhcHB5IGFib3V0IHRoaXMgaG9vay4gQ29uY2VwdHVhbGx5LCByZW5kZXJSb290IHNob3VsZCByZXR1cm4gYVxuICAvLyB0dXBsZSBvZiAoaXNSZWFkeUZvckNvbW1pdCwgZGlkRXJyb3IsIGVycm9yKVxuICBmdW5jdGlvbiBvblVuY2F1Z2h0RXJyb3IoZXJyb3IpIHtcbiAgICAhKG5leHRGbHVzaGVkUm9vdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgYmUgd29ya2luZyBvbiBhIHJvb3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgLy8gVW5zY2hlZHVsZSB0aGlzIHJvb3Qgc28gd2UgZG9uJ3Qgd29yayBvbiBpdCBhZ2FpbiB1bnRpbCB0aGVyZSdzXG4gICAgLy8gYW5vdGhlciB1cGRhdGUuXG4gICAgbmV4dEZsdXNoZWRSb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICAgIGlmICghaGFzVW5oYW5kbGVkRXJyb3IpIHtcbiAgICAgIGhhc1VuaGFuZGxlZEVycm9yID0gdHJ1ZTtcbiAgICAgIHVuaGFuZGxlZEVycm9yID0gZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogQmF0Y2hpbmcgc2hvdWxkIGJlIGltcGxlbWVudGVkIGF0IHRoZSByZW5kZXJlciBsZXZlbCwgbm90IGluc2lkZVxuICAvLyB0aGUgcmVjb25jaWxlci5cbiAgZnVuY3Rpb24gYmF0Y2hlZFVwZGF0ZXMoZm4sIGEpIHtcbiAgICB2YXIgcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcyA9IGlzQmF0Y2hpbmdVcGRhdGVzO1xuICAgIGlzQmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKGEpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpc0JhdGNoaW5nVXBkYXRlcyA9IHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXM7XG4gICAgICBpZiAoIWlzQmF0Y2hpbmdVcGRhdGVzICYmICFpc1JlbmRlcmluZykge1xuICAgICAgICBwZXJmb3JtV29yayhTeW5jLCBudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBCYXRjaGluZyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYXQgdGhlIHJlbmRlcmVyIGxldmVsLCBub3QgaW5zaWRlXG4gIC8vIHRoZSByZWNvbmNpbGVyLlxuICBmdW5jdGlvbiB1bmJhdGNoZWRVcGRhdGVzKGZuKSB7XG4gICAgaWYgKGlzQmF0Y2hpbmdVcGRhdGVzICYmICFpc1VuYmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgICBpc1VuYmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaXNVbmJhdGNoaW5nVXBkYXRlcyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm4oKTtcbiAgfVxuXG4gIC8vIFRPRE86IEJhdGNoaW5nIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBhdCB0aGUgcmVuZGVyZXIgbGV2ZWwsIG5vdCB3aXRoaW5cbiAgLy8gdGhlIHJlY29uY2lsZXIuXG4gIGZ1bmN0aW9uIGZsdXNoU3luYyhmbikge1xuICAgIHZhciBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzID0gaXNCYXRjaGluZ1VwZGF0ZXM7XG4gICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gc3luY1VwZGF0ZXMoZm4pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpc0JhdGNoaW5nVXBkYXRlcyA9IHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXM7XG4gICAgICAhIWlzUmVuZGVyaW5nID8gaW52YXJpYW50KGZhbHNlLCAnZmx1c2hTeW5jIHdhcyBjYWxsZWQgZnJvbSBpbnNpZGUgYSBsaWZlY3ljbGUgbWV0aG9kLiBJdCBjYW5ub3QgYmUgY2FsbGVkIHdoZW4gUmVhY3QgaXMgYWxyZWFkeSByZW5kZXJpbmcuJykgOiB2b2lkIDA7XG4gICAgICBwZXJmb3JtV29yayhTeW5jLCBudWxsKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNvbXB1dGVBc3luY0V4cGlyYXRpb246IGNvbXB1dGVBc3luY0V4cGlyYXRpb24sXG4gICAgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcjogY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcixcbiAgICBzY2hlZHVsZVdvcms6IHNjaGVkdWxlV29yayxcbiAgICBiYXRjaGVkVXBkYXRlczogYmF0Y2hlZFVwZGF0ZXMsXG4gICAgdW5iYXRjaGVkVXBkYXRlczogdW5iYXRjaGVkVXBkYXRlcyxcbiAgICBmbHVzaFN5bmM6IGZsdXNoU3luYyxcbiAgICBkZWZlcnJlZFVwZGF0ZXM6IGRlZmVycmVkVXBkYXRlc1xuICB9O1xufTtcblxue1xuICB2YXIgZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyA9IGZhbHNlO1xufVxuXG4vLyAwIGlzIFBST0QsIDEgaXMgREVWLlxuLy8gTWlnaHQgYWRkIFBST0ZJTEUgbGF0ZXIuXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dEZvclN1YnRyZWUocGFyZW50Q29tcG9uZW50KSB7XG4gIGlmICghcGFyZW50Q29tcG9uZW50KSB7XG4gICAgcmV0dXJuIGVtcHR5T2JqZWN0O1xuICB9XG5cbiAgdmFyIGZpYmVyID0gZ2V0KHBhcmVudENvbXBvbmVudCk7XG4gIHZhciBwYXJlbnRDb250ZXh0ID0gZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQoZmliZXIpO1xuICByZXR1cm4gaXNDb250ZXh0UHJvdmlkZXIoZmliZXIpID8gcHJvY2Vzc0NoaWxkQ29udGV4dChmaWJlciwgcGFyZW50Q29udGV4dCkgOiBwYXJlbnRDb250ZXh0O1xufVxuXG52YXIgUmVhY3RGaWJlclJlY29uY2lsZXIkMSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIGdldFB1YmxpY0luc3RhbmNlID0gY29uZmlnLmdldFB1YmxpY0luc3RhbmNlO1xuXG4gIHZhciBfUmVhY3RGaWJlclNjaGVkdWxlciA9IFJlYWN0RmliZXJTY2hlZHVsZXIoY29uZmlnKSxcbiAgICAgIGNvbXB1dGVBc3luY0V4cGlyYXRpb24gPSBfUmVhY3RGaWJlclNjaGVkdWxlci5jb21wdXRlQXN5bmNFeHBpcmF0aW9uLFxuICAgICAgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlciA9IF9SZWFjdEZpYmVyU2NoZWR1bGVyLmNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIsXG4gICAgICBzY2hlZHVsZVdvcmsgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5zY2hlZHVsZVdvcmssXG4gICAgICBiYXRjaGVkVXBkYXRlcyA9IF9SZWFjdEZpYmVyU2NoZWR1bGVyLmJhdGNoZWRVcGRhdGVzLFxuICAgICAgdW5iYXRjaGVkVXBkYXRlcyA9IF9SZWFjdEZpYmVyU2NoZWR1bGVyLnVuYmF0Y2hlZFVwZGF0ZXMsXG4gICAgICBmbHVzaFN5bmMgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5mbHVzaFN5bmMsXG4gICAgICBkZWZlcnJlZFVwZGF0ZXMgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5kZWZlcnJlZFVwZGF0ZXM7XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGVUb3BMZXZlbFVwZGF0ZShjdXJyZW50LCBlbGVtZW50LCBjYWxsYmFjaykge1xuICAgIHtcbiAgICAgIGlmIChSZWFjdERlYnVnQ3VycmVudEZpYmVyLnBoYXNlID09PSAncmVuZGVyJyAmJiBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQgIT09IG51bGwgJiYgIWRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMpIHtcbiAgICAgICAgZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyA9IHRydWU7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZTsgJyArICd0cmlnZ2VyaW5nIG5lc3RlZCBjb21wb25lbnQgdXBkYXRlcyBmcm9tIHJlbmRlciBpcyBub3QgYWxsb3dlZC4gJyArICdJZiBuZWNlc3NhcnksIHRyaWdnZXIgbmVzdGVkIHVwZGF0ZXMgaW4gY29tcG9uZW50RGlkVXBkYXRlLlxcblxcbicgKyAnQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJXMuJywgZ2V0Q29tcG9uZW50TmFtZShSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQpIHx8ICdVbmtub3duJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuICAgIHtcbiAgICAgIHdhcm5pbmcoY2FsbGJhY2sgPT09IG51bGwgfHwgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nLCAncmVuZGVyKC4uLik6IEV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSAnICsgJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgdmFyIGV4cGlyYXRpb25UaW1lID0gdm9pZCAwO1xuICAgIC8vIENoZWNrIGlmIHRoZSB0b3AtbGV2ZWwgZWxlbWVudCBpcyBhbiBhc3luYyB3cmFwcGVyIGNvbXBvbmVudC4gSWYgc28sXG4gICAgLy8gdHJlYXQgdXBkYXRlcyB0byB0aGUgcm9vdCBhcyBhc3luYy4gVGhpcyBpcyBhIGJpdCB3ZWlyZCBidXQgbGV0cyB1c1xuICAgIC8vIGF2b2lkIGEgc2VwYXJhdGUgYHJlbmRlckFzeW5jYCBBUEkuXG4gICAgaWYgKGVuYWJsZUFzeW5jU3VidHJlZUFQSSAmJiBlbGVtZW50ICE9IG51bGwgJiYgZWxlbWVudC50eXBlICE9IG51bGwgJiYgZWxlbWVudC50eXBlLnByb3RvdHlwZSAhPSBudWxsICYmIGVsZW1lbnQudHlwZS5wcm90b3R5cGUudW5zdGFibGVfaXNBc3luY1JlYWN0Q29tcG9uZW50ID09PSB0cnVlKSB7XG4gICAgICBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVBc3luY0V4cGlyYXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKGN1cnJlbnQpO1xuICAgIH1cblxuICAgIHZhciB1cGRhdGUgPSB7XG4gICAgICBleHBpcmF0aW9uVGltZTogZXhwaXJhdGlvblRpbWUsXG4gICAgICBwYXJ0aWFsU3RhdGU6IHsgZWxlbWVudDogZWxlbWVudCB9LFxuICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgaXNSZXBsYWNlOiBmYWxzZSxcbiAgICAgIGlzRm9yY2VkOiBmYWxzZSxcbiAgICAgIG5leHRDYWxsYmFjazogbnVsbCxcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuICAgIGluc2VydFVwZGF0ZUludG9GaWJlcihjdXJyZW50LCB1cGRhdGUpO1xuICAgIHNjaGVkdWxlV29yayhjdXJyZW50LCBleHBpcmF0aW9uVGltZSk7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlKGZpYmVyKSB7XG4gICAgdmFyIGhvc3RGaWJlciA9IGZpbmRDdXJyZW50SG9zdEZpYmVyKGZpYmVyKTtcbiAgICBpZiAoaG9zdEZpYmVyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGhvc3RGaWJlci5zdGF0ZU5vZGU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNyZWF0ZUNvbnRhaW5lcjogZnVuY3Rpb24gKGNvbnRhaW5lckluZm8sIGh5ZHJhdGUpIHtcbiAgICAgIHJldHVybiBjcmVhdGVGaWJlclJvb3QoY29udGFpbmVySW5mbywgaHlkcmF0ZSk7XG4gICAgfSxcbiAgICB1cGRhdGVDb250YWluZXI6IGZ1bmN0aW9uIChlbGVtZW50LCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgY2FsbGJhY2spIHtcbiAgICAgIC8vIFRPRE86IElmIHRoaXMgaXMgYSBuZXN0ZWQgY29udGFpbmVyLCB0aGlzIHdvbid0IGJlIHRoZSByb290LlxuICAgICAgdmFyIGN1cnJlbnQgPSBjb250YWluZXIuY3VycmVudDtcblxuICAgICAge1xuICAgICAgICBpZiAoUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgICAgIGlmIChjdXJyZW50LmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbk1vdW50Q29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uVW5tb3VudENvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uVXBkYXRlQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gZ2V0Q29udGV4dEZvclN1YnRyZWUocGFyZW50Q29tcG9uZW50KTtcbiAgICAgIGlmIChjb250YWluZXIuY29udGV4dCA9PT0gbnVsbCkge1xuICAgICAgICBjb250YWluZXIuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXIucGVuZGluZ0NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgfVxuXG4gICAgICBzY2hlZHVsZVRvcExldmVsVXBkYXRlKGN1cnJlbnQsIGVsZW1lbnQsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG5cbiAgICBiYXRjaGVkVXBkYXRlczogYmF0Y2hlZFVwZGF0ZXMsXG5cbiAgICB1bmJhdGNoZWRVcGRhdGVzOiB1bmJhdGNoZWRVcGRhdGVzLFxuXG4gICAgZGVmZXJyZWRVcGRhdGVzOiBkZWZlcnJlZFVwZGF0ZXMsXG5cbiAgICBmbHVzaFN5bmM6IGZsdXNoU3luYyxcblxuICAgIGdldFB1YmxpY1Jvb3RJbnN0YW5jZTogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICAgdmFyIGNvbnRhaW5lckZpYmVyID0gY29udGFpbmVyLmN1cnJlbnQ7XG4gICAgICBpZiAoIWNvbnRhaW5lckZpYmVyLmNoaWxkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChjb250YWluZXJGaWJlci5jaGlsZC50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIHJldHVybiBnZXRQdWJsaWNJbnN0YW5jZShjb250YWluZXJGaWJlci5jaGlsZC5zdGF0ZU5vZGUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBjb250YWluZXJGaWJlci5jaGlsZC5zdGF0ZU5vZGU7XG4gICAgICB9XG4gICAgfSxcblxuXG4gICAgZmluZEhvc3RJbnN0YW5jZTogZmluZEhvc3RJbnN0YW5jZSxcblxuICAgIGZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzOiBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgIHZhciBob3N0RmliZXIgPSBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHMoZmliZXIpO1xuICAgICAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xuICAgIH0sXG4gICAgaW5qZWN0SW50b0RldlRvb2xzOiBmdW5jdGlvbiAoZGV2VG9vbHNDb25maWcpIHtcbiAgICAgIHZhciBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSA9IGRldlRvb2xzQ29uZmlnLmZpbmRGaWJlckJ5SG9zdEluc3RhbmNlO1xuXG4gICAgICByZXR1cm4gaW5qZWN0SW50ZXJuYWxzKF9hc3NpZ24oe30sIGRldlRvb2xzQ29uZmlnLCB7XG4gICAgICAgIGZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyOiBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgICByZXR1cm4gZmluZEhvc3RJbnN0YW5jZShmaWJlcik7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOiBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICBpZiAoIWZpbmRGaWJlckJ5SG9zdEluc3RhbmNlKSB7XG4gICAgICAgICAgICAvLyBNaWdodCBub3QgYmUgaW1wbGVtZW50ZWQgYnkgdGhlIHJlbmRlcmVyLlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG59O1xuXG52YXIgUmVhY3RGaWJlclJlY29uY2lsZXIkMiA9IE9iamVjdC5mcmVlemUoe1xuXHRkZWZhdWx0OiBSZWFjdEZpYmVyUmVjb25jaWxlciQxXG59KTtcblxudmFyIFJlYWN0RmliZXJSZWNvbmNpbGVyJDMgPSAoIFJlYWN0RmliZXJSZWNvbmNpbGVyJDIgJiYgUmVhY3RGaWJlclJlY29uY2lsZXIkMSApIHx8IFJlYWN0RmliZXJSZWNvbmNpbGVyJDI7XG5cbi8vIFRPRE86IGJ1bmRsZSBGbG93IHR5cGVzIHdpdGggdGhlIHBhY2thZ2UuXG5cblxuXG4vLyBUT0RPOiBkZWNpZGUgb24gdGhlIHRvcC1sZXZlbCBleHBvcnQgZm9ybS5cbi8vIFRoaXMgaXMgaGFja3kgYnV0IG1ha2VzIGl0IHdvcmsgd2l0aCBib3RoIFJvbGx1cCBhbmQgSmVzdC5cbnZhciByZWFjdFJlY29uY2lsZXIgPSBSZWFjdEZpYmVyUmVjb25jaWxlciQzWydkZWZhdWx0J10gPyBSZWFjdEZpYmVyUmVjb25jaWxlciQzWydkZWZhdWx0J10gOiBSZWFjdEZpYmVyUmVjb25jaWxlciQzO1xuXG5mdW5jdGlvbiBjcmVhdGVQb3J0YWwkMShjaGlsZHJlbiwgY29udGFpbmVySW5mbyxcbi8vIFRPRE86IGZpZ3VyZSBvdXQgdGhlIEFQSSBmb3IgY3Jvc3MtcmVuZGVyZXIgaW1wbGVtZW50YXRpb24uXG5pbXBsZW1lbnRhdGlvbikge1xuICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuXG4gIHJldHVybiB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3cgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IFBvcnRhbFxuICAgICQkdHlwZW9mOiBSRUFDVF9QT1JUQUxfVFlQRSxcbiAgICBrZXk6IGtleSA9PSBudWxsID8gbnVsbCA6ICcnICsga2V5LFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBjb250YWluZXJJbmZvOiBjb250YWluZXJJbmZvLFxuICAgIGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvblxuICB9O1xufVxuXG4vLyBUT0RPOiB0aGlzIGlzIHNwZWNpYWwgYmVjYXVzZSBpdCBnZXRzIGltcG9ydGVkIGR1cmluZyBidWlsZC5cblxudmFyIFJlYWN0VmVyc2lvbiA9ICcxNi4yLjAnO1xuXG4vLyBhIHJlcXVlc3RBbmltYXRpb25GcmFtZSwgc3RvcmluZyB0aGUgdGltZSBmb3IgdGhlIHN0YXJ0IG9mIHRoZSBmcmFtZSwgdGhlblxuLy8gc2NoZWR1bGluZyBhIHBvc3RNZXNzYWdlIHdoaWNoIGdldHMgc2NoZWR1bGVkIGFmdGVyIHBhaW50LiBXaXRoaW4gdGhlXG4vLyBwb3N0TWVzc2FnZSBoYW5kbGVyIGRvIGFzIG11Y2ggd29yayBhcyBwb3NzaWJsZSB1bnRpbCB0aW1lICsgZnJhbWUgcmF0ZS5cbi8vIEJ5IHNlcGFyYXRpbmcgdGhlIGlkbGUgY2FsbCBpbnRvIGEgc2VwYXJhdGUgZXZlbnQgdGljayB3ZSBlbnN1cmUgdGhhdFxuLy8gbGF5b3V0LCBwYWludCBhbmQgb3RoZXIgYnJvd3NlciB3b3JrIGlzIGNvdW50ZWQgYWdhaW5zdCB0aGUgYXZhaWxhYmxlIHRpbWUuXG4vLyBUaGUgZnJhbWUgcmF0ZSBpcyBkeW5hbWljYWxseSBhZGp1c3RlZC5cblxue1xuICBpZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmIHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QgZGVwZW5kcyBvbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuIE1ha2Ugc3VyZSB0aGF0IHlvdSBsb2FkIGEgJyArICdwb2x5ZmlsbCBpbiBvbGRlciBicm93c2Vycy4gaHR0cDovL2ZiLm1lL3JlYWN0LXBvbHlmaWxscycpO1xuICB9XG59XG5cbnZhciBoYXNOYXRpdmVQZXJmb3JtYW5jZU5vdyA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJztcblxudmFyIG5vdyA9IHZvaWQgMDtcbmlmIChoYXNOYXRpdmVQZXJmb3JtYW5jZU5vdykge1xuICBub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO1xuICB9O1xufSBlbHNlIHtcbiAgbm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBEYXRlLm5vdygpO1xuICB9O1xufVxuXG4vLyBUT0RPOiBUaGVyZSdzIG5vIHdheSB0byBjYW5jZWwsIGJlY2F1c2UgRmliZXIgZG9lc24ndCBhdG0uXG52YXIgcklDID0gdm9pZCAwO1xudmFyIGNJQyA9IHZvaWQgMDtcblxuaWYgKCFFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgcklDID0gZnVuY3Rpb24gKGZyYW1lQ2FsbGJhY2spIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBmcmFtZUNhbGxiYWNrKHtcbiAgICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIGNJQyA9IGZ1bmN0aW9uICh0aW1lb3V0SUQpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dElEKTtcbiAgfTtcbn0gZWxzZSBpZiAodHlwZW9mIHJlcXVlc3RJZGxlQ2FsbGJhY2sgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGNhbmNlbElkbGVDYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAvLyBQb2x5ZmlsbCByZXF1ZXN0SWRsZUNhbGxiYWNrIGFuZCBjYW5jZWxJZGxlQ2FsbGJhY2tcblxuICB2YXIgc2NoZWR1bGVkUklDQ2FsbGJhY2sgPSBudWxsO1xuICB2YXIgaXNJZGxlU2NoZWR1bGVkID0gZmFsc2U7XG4gIHZhciB0aW1lb3V0VGltZSA9IC0xO1xuXG4gIHZhciBpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgdmFyIGZyYW1lRGVhZGxpbmUgPSAwO1xuICAvLyBXZSBzdGFydCBvdXQgYXNzdW1pbmcgdGhhdCB3ZSBydW4gYXQgMzBmcHMgYnV0IHRoZW4gdGhlIGhldXJpc3RpYyB0cmFja2luZ1xuICAvLyB3aWxsIGFkanVzdCB0aGlzIHZhbHVlIHRvIGEgZmFzdGVyIGZwcyBpZiB3ZSBnZXQgbW9yZSBmcmVxdWVudCBhbmltYXRpb25cbiAgLy8gZnJhbWVzLlxuICB2YXIgcHJldmlvdXNGcmFtZVRpbWUgPSAzMztcbiAgdmFyIGFjdGl2ZUZyYW1lVGltZSA9IDMzO1xuXG4gIHZhciBmcmFtZURlYWRsaW5lT2JqZWN0O1xuICBpZiAoaGFzTmF0aXZlUGVyZm9ybWFuY2VOb3cpIHtcbiAgICBmcmFtZURlYWRsaW5lT2JqZWN0ID0ge1xuICAgICAgZGlkVGltZW91dDogZmFsc2UsXG4gICAgICB0aW1lUmVtYWluaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IGlmIHdlIGhhdmUgYSBwZXJmb3JtYW5jZSB0aW1lciB0aGF0IHRoZSByQUYgY2FsbGJhY2tcbiAgICAgICAgLy8gZ2V0cyBhIHBlcmZvcm1hbmNlIHRpbWVyIHZhbHVlLiBOb3Qgc3VyZSBpZiB0aGlzIGlzIGFsd2F5cyB0cnVlLlxuICAgICAgICB2YXIgcmVtYWluaW5nID0gZnJhbWVEZWFkbGluZSAtIHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICByZXR1cm4gcmVtYWluaW5nID4gMCA/IHJlbWFpbmluZyA6IDA7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBmcmFtZURlYWRsaW5lT2JqZWN0ID0ge1xuICAgICAgZGlkVGltZW91dDogZmFsc2UsXG4gICAgICB0aW1lUmVtYWluaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIERhdGUubm93KClcbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IGZyYW1lRGVhZGxpbmUgLSBEYXRlLm5vdygpO1xuICAgICAgICByZXR1cm4gcmVtYWluaW5nID4gMCA/IHJlbWFpbmluZyA6IDA7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIFdlIHVzZSB0aGUgcG9zdE1lc3NhZ2UgdHJpY2sgdG8gZGVmZXIgaWRsZSB3b3JrIHVudGlsIGFmdGVyIHRoZSByZXBhaW50LlxuICB2YXIgbWVzc2FnZUtleSA9ICdfX3JlYWN0SWRsZUNhbGxiYWNrJCcgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcbiAgdmFyIGlkbGVUaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnNvdXJjZSAhPT0gd2luZG93IHx8IGV2ZW50LmRhdGEgIT09IG1lc3NhZ2VLZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpc0lkbGVTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAgIHZhciBjdXJyZW50VGltZSA9IG5vdygpO1xuICAgIGlmIChmcmFtZURlYWRsaW5lIC0gY3VycmVudFRpbWUgPD0gMCkge1xuICAgICAgLy8gVGhlcmUncyBubyB0aW1lIGxlZnQgaW4gdGhpcyBpZGxlIHBlcmlvZC4gQ2hlY2sgaWYgdGhlIGNhbGxiYWNrIGhhc1xuICAgICAgLy8gYSB0aW1lb3V0IGFuZCB3aGV0aGVyIGl0J3MgYmVlbiBleGNlZWRlZC5cbiAgICAgIGlmICh0aW1lb3V0VGltZSAhPT0gLTEgJiYgdGltZW91dFRpbWUgPD0gY3VycmVudFRpbWUpIHtcbiAgICAgICAgLy8gRXhjZWVkZWQgdGhlIHRpbWVvdXQuIEludm9rZSB0aGUgY2FsbGJhY2sgZXZlbiB0aG91Z2ggdGhlcmUncyBub1xuICAgICAgICAvLyB0aW1lIGxlZnQuXG4gICAgICAgIGZyYW1lRGVhZGxpbmVPYmplY3QuZGlkVGltZW91dCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBObyB0aW1lb3V0LlxuICAgICAgICBpZiAoIWlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQpIHtcbiAgICAgICAgICAvLyBTY2hlZHVsZSBhbm90aGVyIGFuaW1hdGlvbiBjYWxsYmFjayBzbyB3ZSByZXRyeSBsYXRlci5cbiAgICAgICAgICBpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uVGljayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXhpdCB3aXRob3V0IGludm9raW5nIHRoZSBjYWxsYmFjay5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGVyZSdzIHN0aWxsIHRpbWUgbGVmdCBpbiB0aGlzIGlkbGUgcGVyaW9kLlxuICAgICAgZnJhbWVEZWFkbGluZU9iamVjdC5kaWRUaW1lb3V0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGltZW91dFRpbWUgPSAtMTtcbiAgICB2YXIgY2FsbGJhY2sgPSBzY2hlZHVsZWRSSUNDYWxsYmFjaztcbiAgICBzY2hlZHVsZWRSSUNDYWxsYmFjayA9IG51bGw7XG4gICAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICBjYWxsYmFjayhmcmFtZURlYWRsaW5lT2JqZWN0KTtcbiAgICB9XG4gIH07XG4gIC8vIEFzc3VtZXMgdGhhdCB3ZSBoYXZlIGFkZEV2ZW50TGlzdGVuZXIgaW4gdGhpcyBlbnZpcm9ubWVudC4gTWlnaHQgbmVlZFxuICAvLyBzb21ldGhpbmcgYmV0dGVyIGZvciBvbGQgSUUuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaWRsZVRpY2ssIGZhbHNlKTtcblxuICB2YXIgYW5pbWF0aW9uVGljayA9IGZ1bmN0aW9uIChyYWZUaW1lKSB7XG4gICAgaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHZhciBuZXh0RnJhbWVUaW1lID0gcmFmVGltZSAtIGZyYW1lRGVhZGxpbmUgKyBhY3RpdmVGcmFtZVRpbWU7XG4gICAgaWYgKG5leHRGcmFtZVRpbWUgPCBhY3RpdmVGcmFtZVRpbWUgJiYgcHJldmlvdXNGcmFtZVRpbWUgPCBhY3RpdmVGcmFtZVRpbWUpIHtcbiAgICAgIGlmIChuZXh0RnJhbWVUaW1lIDwgOCkge1xuICAgICAgICAvLyBEZWZlbnNpdmUgY29kaW5nLiBXZSBkb24ndCBzdXBwb3J0IGhpZ2hlciBmcmFtZSByYXRlcyB0aGFuIDEyMGh6LlxuICAgICAgICAvLyBJZiB3ZSBnZXQgbG93ZXIgdGhhbiB0aGF0LCBpdCBpcyBwcm9iYWJseSBhIGJ1Zy5cbiAgICAgICAgbmV4dEZyYW1lVGltZSA9IDg7XG4gICAgICB9XG4gICAgICAvLyBJZiBvbmUgZnJhbWUgZ29lcyBsb25nLCB0aGVuIHRoZSBuZXh0IG9uZSBjYW4gYmUgc2hvcnQgdG8gY2F0Y2ggdXAuXG4gICAgICAvLyBJZiB0d28gZnJhbWVzIGFyZSBzaG9ydCBpbiBhIHJvdywgdGhlbiB0aGF0J3MgYW4gaW5kaWNhdGlvbiB0aGF0IHdlXG4gICAgICAvLyBhY3R1YWxseSBoYXZlIGEgaGlnaGVyIGZyYW1lIHJhdGUgdGhhbiB3aGF0IHdlJ3JlIGN1cnJlbnRseSBvcHRpbWl6aW5nLlxuICAgICAgLy8gV2UgYWRqdXN0IG91ciBoZXVyaXN0aWMgZHluYW1pY2FsbHkgYWNjb3JkaW5nbHkuIEZvciBleGFtcGxlLCBpZiB3ZSdyZVxuICAgICAgLy8gcnVubmluZyBvbiAxMjBoeiBkaXNwbGF5IG9yIDkwaHogVlIgZGlzcGxheS5cbiAgICAgIC8vIFRha2UgdGhlIG1heCBvZiB0aGUgdHdvIGluIGNhc2Ugb25lIG9mIHRoZW0gd2FzIGFuIGFub21hbHkgZHVlIHRvXG4gICAgICAvLyBtaXNzZWQgZnJhbWUgZGVhZGxpbmVzLlxuICAgICAgYWN0aXZlRnJhbWVUaW1lID0gbmV4dEZyYW1lVGltZSA8IHByZXZpb3VzRnJhbWVUaW1lID8gcHJldmlvdXNGcmFtZVRpbWUgOiBuZXh0RnJhbWVUaW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmV2aW91c0ZyYW1lVGltZSA9IG5leHRGcmFtZVRpbWU7XG4gICAgfVxuICAgIGZyYW1lRGVhZGxpbmUgPSByYWZUaW1lICsgYWN0aXZlRnJhbWVUaW1lO1xuICAgIGlmICghaXNJZGxlU2NoZWR1bGVkKSB7XG4gICAgICBpc0lkbGVTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgd2luZG93LnBvc3RNZXNzYWdlKG1lc3NhZ2VLZXksICcqJyk7XG4gICAgfVxuICB9O1xuXG4gIHJJQyA9IGZ1bmN0aW9uIChjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIC8vIFRoaXMgYXNzdW1lcyB0aGF0IHdlIG9ubHkgc2NoZWR1bGUgb25lIGNhbGxiYWNrIGF0IGEgdGltZSBiZWNhdXNlIHRoYXQnc1xuICAgIC8vIGhvdyBGaWJlciB1c2VzIGl0LlxuICAgIHNjaGVkdWxlZFJJQ0NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiB0eXBlb2Ygb3B0aW9ucy50aW1lb3V0ID09PSAnbnVtYmVyJykge1xuICAgICAgdGltZW91dFRpbWUgPSBub3coKSArIG9wdGlvbnMudGltZW91dDtcbiAgICB9XG4gICAgaWYgKCFpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkKSB7XG4gICAgICAvLyBJZiByQUYgZGlkbid0IGFscmVhZHkgc2NoZWR1bGUgb25lLCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGEgZnJhbWUuXG4gICAgICAvLyBUT0RPOiBJZiB0aGlzIHJBRiBkb2Vzbid0IG1hdGVyaWFsaXplIGJlY2F1c2UgdGhlIGJyb3dzZXIgdGhyb3R0bGVzLCB3ZVxuICAgICAgLy8gbWlnaHQgd2FudCB0byBzdGlsbCBoYXZlIHNldFRpbWVvdXQgdHJpZ2dlciBySUMgYXMgYSBiYWNrdXAgdG8gZW5zdXJlXG4gICAgICAvLyB0aGF0IHdlIGtlZXAgcGVyZm9ybWluZyB3b3JrLlxuICAgICAgaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uVGljayk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9O1xuXG4gIGNJQyA9IGZ1bmN0aW9uICgpIHtcbiAgICBzY2hlZHVsZWRSSUNDYWxsYmFjayA9IG51bGw7XG4gICAgaXNJZGxlU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgdGltZW91dFRpbWUgPSAtMTtcbiAgfTtcbn0gZWxzZSB7XG4gIHJJQyA9IHdpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrO1xuICBjSUMgPSB3aW5kb3cuY2FuY2VsSWRsZUNhbGxiYWNrO1xufVxuXG4vKipcbiAqIEZvcmtlZCBmcm9tIGZianMvd2FybmluZzpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mYmpzL2Jsb2IvZTY2YmEyMGFkNWJlNDMzZWI1NDQyM2YyYjA5N2Q4MjkzMjRkOWRlNi9wYWNrYWdlcy9mYmpzL3NyYy9fX2ZvcmtzX18vd2FybmluZy5qc1xuICpcbiAqIE9ubHkgY2hhbmdlIGlzIHdlIHVzZSBjb25zb2xlLndhcm4gaW5zdGVhZCBvZiBjb25zb2xlLmVycm9yLFxuICogYW5kIGRvIG5vdGhpbmcgd2hlbiAnY29uc29sZScgaXMgbm90IHN1cHBvcnRlZC5cbiAqIFRoaXMgcmVhbGx5IHNpbXBsaWZpZXMgdGhlIGNvZGUuXG4gKiAtLS1cbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG5cbiAgbG93UHJpb3JpdHlXYXJuaW5nID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIGxvd1ByaW9yaXR5V2FybmluZyQxID0gbG93UHJpb3JpdHlXYXJuaW5nO1xuXG4vLyBpc0F0dHJpYnV0ZU5hbWVTYWZlKCkgaXMgY3VycmVudGx5IGR1cGxpY2F0ZWQgaW4gRE9NTWFya3VwT3BlcmF0aW9ucy5cbi8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgcGxhY2UgZm9yIHRoaXMuXG52YXIgVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVggPSBuZXcgUmVnRXhwKCdeWycgKyBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgJ11bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG52YXIgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xudmFyIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xuZnVuY3Rpb24gaXNBdHRyaWJ1dGVOYW1lU2FmZShhdHRyaWJ1dGVOYW1lKSB7XG4gIGlmICh2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUuaGFzT3duUHJvcGVydHkoYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZS5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgudGVzdChhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG4gIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhdHRyaWJ1dGUgbmFtZTogYCVzYCcsIGF0dHJpYnV0ZU5hbWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gc2hvdWxkSWdub3JlVmFsdWUoKSBpcyBjdXJyZW50bHkgZHVwbGljYXRlZCBpbiBET01NYXJrdXBPcGVyYXRpb25zLlxuLy8gVE9ETzogRmluZCBhIGJldHRlciBwbGFjZSBmb3IgdGhpcy5cbmZ1bmN0aW9uIHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgdmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgfHwgcHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSAmJiAhdmFsdWUgfHwgcHJvcGVydHlJbmZvLmhhc051bWVyaWNWYWx1ZSAmJiBpc05hTih2YWx1ZSkgfHwgcHJvcGVydHlJbmZvLmhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlICYmIHZhbHVlIDwgMSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSAmJiB2YWx1ZSA9PT0gZmFsc2U7XG59XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIERPTSBwcm9wZXJ0aWVzLlxuICovXG5cblxuXG5cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS4gT25seSB1c2VkIGluIERFViBmb3IgU1NSIHZhbGlkYXRpb24uXG4gKiBUaGUgXCJleHBlY3RlZFwiIGFyZ3VtZW50IGlzIHVzZWQgYXMgYSBoaW50IG9mIHdoYXQgdGhlIGV4cGVjdGVkIHZhbHVlIGlzLlxuICogU29tZSBwcm9wZXJ0aWVzIGhhdmUgbXVsdGlwbGUgZXF1aXZhbGVudCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSwgZXhwZWN0ZWQpIHtcbiAge1xuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG4gICAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgICAgdmFyIG11dGF0aW9uTWV0aG9kID0gcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kO1xuICAgICAgaWYgKG11dGF0aW9uTWV0aG9kIHx8IHByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVbcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lO1xuXG4gICAgICAgIHZhciBzdHJpbmdWYWx1ZSA9IG51bGw7XG5cbiAgICAgICAgaWYgKHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlKSB7XG4gICAgICAgICAgaWYgKG5vZGUuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCBleHBlY3RlZCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAnJyArIGV4cGVjdGVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5oYXNBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgICBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCBleHBlY3RlZCkpIHtcbiAgICAgICAgICAgIC8vIFdlIGhhZCBhbiBhdHRyaWJ1dGUgYnV0IHNob3VsZG4ndCBoYXZlIGhhZCBvbmUsIHNvIHJlYWQgaXRcbiAgICAgICAgICAgIC8vIGZvciB0aGUgZXJyb3IgbWVzc2FnZS5cbiAgICAgICAgICAgIHJldHVybiBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgd2FzIGEgYm9vbGVhbiwgaXQgZG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgdmFsdWUgaXNcbiAgICAgICAgICAgIC8vIHRoZSBmYWN0IHRoYXQgd2UgaGF2ZSBpdCBpcyB0aGUgc2FtZSBhcyB0aGUgZXhwZWN0ZWQuXG4gICAgICAgICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEV2ZW4gaWYgdGhpcyBwcm9wZXJ0eSB1c2VzIGEgbmFtZXNwYWNlIHdlIHVzZSBnZXRBdHRyaWJ1dGVcbiAgICAgICAgICAvLyBiZWNhdXNlIHdlIGFzc3VtZSBpdHMgbmFtZXNwYWNlZCBuYW1lIGlzIHRoZSBzYW1lIGFzIG91ciBjb25maWcuXG4gICAgICAgICAgLy8gVG8gdXNlIGdldEF0dHJpYnV0ZU5TIHdlIG5lZWQgdGhlIGxvY2FsIG5hbWUgd2hpY2ggd2UgZG9uJ3QgaGF2ZVxuICAgICAgICAgIC8vIGluIG91ciBjb25maWcgYXRtLlxuICAgICAgICAgIHN0cmluZ1ZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCBleHBlY3RlZCkpIHtcbiAgICAgICAgICByZXR1cm4gc3RyaW5nVmFsdWUgPT09IG51bGwgPyBleHBlY3RlZCA6IHN0cmluZ1ZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmluZ1ZhbHVlID09PSAnJyArIGV4cGVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzdHJpbmdWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgZm9yIGEgYXR0cmlidXRlIG9uIGEgbm9kZS4gT25seSB1c2VkIGluIERFViBmb3IgU1NSIHZhbGlkYXRpb24uXG4gKiBUaGUgdGhpcmQgYXJndW1lbnQgaXMgdXNlZCBhcyBhIGhpbnQgb2Ygd2hhdCB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMuIFNvbWVcbiAqIGF0dHJpYnV0ZXMgaGF2ZSBtdWx0aXBsZSBlcXVpdmFsZW50IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUobm9kZSwgbmFtZSwgZXhwZWN0ZWQpIHtcbiAge1xuICAgIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIW5vZGUuaGFzQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICByZXR1cm4gZXhwZWN0ZWQgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG51bGw7XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgIGlmICh2YWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICovXG5mdW5jdGlvbiBzZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG5cbiAgaWYgKHByb3BlcnR5SW5mbyAmJiBzaG91bGRTZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpKSB7XG4gICAgdmFyIG11dGF0aW9uTWV0aG9kID0gcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kO1xuICAgIGlmIChtdXRhdGlvbk1ldGhvZCkge1xuICAgICAgbXV0YXRpb25NZXRob2Qobm9kZSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCB2YWx1ZSkpIHtcbiAgICAgIGRlbGV0ZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICAvLyBDb250cmFyeSB0byBgc2V0QXR0cmlidXRlYCwgb2JqZWN0IHByb3BlcnRpZXMgYXJlIHByb3Blcmx5XG4gICAgICAvLyBgdG9TdHJpbmdgZWQgYnkgSUU4LzkuXG4gICAgICBub2RlW3Byb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWVdID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XG4gICAgICB2YXIgbmFtZXNwYWNlID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWVzcGFjZTtcbiAgICAgIC8vIGBzZXRBdHRyaWJ1dGVgIHdpdGggb2JqZWN0cyBiZWNvbWVzIG9ubHkgYFtvYmplY3RdYCBpbiBJRTgvOSxcbiAgICAgIC8vICgnJyArIHZhbHVlKSBtYWtlcyBpdCBvdXRwdXQgdGhlIGNvcnJlY3QgdG9TdHJpbmcoKS12YWx1ZS5cbiAgICAgIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIGF0dHJpYnV0ZU5hbWUsICcnICsgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsICcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsICcnICsgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzZXRWYWx1ZUZvckF0dHJpYnV0ZShub2RlLCBuYW1lLCBzaG91bGRTZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpID8gdmFsdWUgOiBudWxsKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAgXG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0VmFsdWVGb3JBdHRyaWJ1dGUobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgJycgKyB2YWx1ZSk7XG4gIH1cblxuICB7XG4gICAgXG4gIH1cbn1cblxuLyoqXG4gKiBEZWxldGVzIGFuIGF0dHJpYnV0ZXMgZnJvbSBhIG5vZGUuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5mdW5jdGlvbiBkZWxldGVWYWx1ZUZvckF0dHJpYnV0ZShub2RlLCBuYW1lKSB7XG4gIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xufVxuXG4vKipcbiAqIERlbGV0ZXMgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbmZ1bmN0aW9uIGRlbGV0ZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSkge1xuICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuICBpZiAocHJvcGVydHlJbmZvKSB7XG4gICAgdmFyIG11dGF0aW9uTWV0aG9kID0gcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kO1xuICAgIGlmIChtdXRhdGlvbk1ldGhvZCkge1xuICAgICAgbXV0YXRpb25NZXRob2Qobm9kZSwgdW5kZWZpbmVkKTtcbiAgICB9IGVsc2UgaWYgKHByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHkpIHtcbiAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWU7XG4gICAgICBpZiAocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSkge1xuICAgICAgICBub2RlW3Byb3BOYW1lXSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSAnJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUocHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgfVxufVxuXG52YXIgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMgPSB7XG4gIGNoZWNrUHJvcFR5cGVzOiBudWxsXG59O1xuXG57XG4gIHZhciBoYXNSZWFkT25seVZhbHVlID0ge1xuICAgIGJ1dHRvbjogdHJ1ZSxcbiAgICBjaGVja2JveDogdHJ1ZSxcbiAgICBpbWFnZTogdHJ1ZSxcbiAgICBoaWRkZW46IHRydWUsXG4gICAgcmFkaW86IHRydWUsXG4gICAgcmVzZXQ6IHRydWUsXG4gICAgc3VibWl0OiB0cnVlXG4gIH07XG5cbiAgdmFyIHByb3BUeXBlcyA9IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgICAgaWYgKCFwcm9wc1twcm9wTmFtZV0gfHwgaGFzUmVhZE9ubHlWYWx1ZVtwcm9wcy50eXBlXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ1lvdSBwcm92aWRlZCBhIGB2YWx1ZWAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0VmFsdWVgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gICAgfSxcbiAgICBjaGVja2VkOiBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICBpZiAoIXByb3BzW3Byb3BOYW1lXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ1lvdSBwcm92aWRlZCBhIGBjaGVja2VkYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRDaGVja2VkYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUHJvdmlkZSBhIGxpbmtlZCBgdmFsdWVgIGF0dHJpYnV0ZSBmb3IgY29udHJvbGxlZCBmb3Jtcy4gWW91IHNob3VsZCBub3QgdXNlXG4gICAqIHRoaXMgb3V0c2lkZSBvZiB0aGUgUmVhY3RET00gY29udHJvbGxlZCBmb3JtIGNvbXBvbmVudHMuXG4gICAqL1xuICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGZ1bmN0aW9uICh0YWdOYW1lLCBwcm9wcywgZ2V0U3RhY2spIHtcbiAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIHByb3BzLCAncHJvcCcsIHRhZ05hbWUsIGdldFN0YWNrKTtcbiAgfTtcbn1cblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQyID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJPd25lck5hbWU7XG52YXIgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQzID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuXG52YXIgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gZmFsc2U7XG52YXIgZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCA9IGZhbHNlO1xudmFyIGRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGlzQ29udHJvbGxlZChwcm9wcykge1xuICB2YXIgdXNlc0NoZWNrZWQgPSBwcm9wcy50eXBlID09PSAnY2hlY2tib3gnIHx8IHByb3BzLnR5cGUgPT09ICdyYWRpbyc7XG4gIHJldHVybiB1c2VzQ2hlY2tlZCA/IHByb3BzLmNoZWNrZWQgIT0gbnVsbCA6IHByb3BzLnZhbHVlICE9IG51bGw7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhbiA8aW5wdXQ+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIHNldHRpbmcgdGhlc2Ugb3B0aW9uYWxcbiAqIHByb3BzOiBgY2hlY2tlZGAsIGB2YWx1ZWAsIGBkZWZhdWx0Q2hlY2tlZGAsIGFuZCBgZGVmYXVsdFZhbHVlYC5cbiAqXG4gKiBJZiBgY2hlY2tlZGAgb3IgYHZhbHVlYCBhcmUgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9uc1xuICogdGhhdCBhZmZlY3QgdGhlIGNoZWNrZWQgc3RhdGUgb3IgdmFsdWUgd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogSWYgdGhleSBhcmUgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIG5vdFxuICogdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LiBJbnN0ZWFkLCB0aGUgcHJvcHMgbXVzdCBjaGFuZ2UgaW4gb3JkZXIgZm9yXG4gKiB0aGUgcmVuZGVyZWQgZWxlbWVudCB0byBiZSB1cGRhdGVkLlxuICpcbiAqIFRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgYmUgaW5pdGlhbGl6ZWQgYXMgdW5jaGVja2VkIChvciBgZGVmYXVsdENoZWNrZWRgKVxuICogd2l0aCBhbiBlbXB0eSB2YWx1ZSAob3IgYGRlZmF1bHRWYWx1ZWApLlxuICpcbiAqIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEyL1dELWh0bWw1LTIwMTIxMDI1L3RoZS1pbnB1dC1lbGVtZW50Lmh0bWxcbiAqL1xuXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgdmFyIGNoZWNrZWQgPSBwcm9wcy5jaGVja2VkO1xuXG4gIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHtcbiAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IC50eXBlIGJlZm9yZSBhbnkgb3RoZXIgcHJvcGVydGllcyAoc2V0dGluZyAudmFsdWVcbiAgICAvLyBiZWZvcmUgLnR5cGUgbWVhbnMgLnZhbHVlIGlzIGxvc3QgaW4gSUUxMSBhbmQgYmVsb3cpXG4gICAgdHlwZTogdW5kZWZpbmVkLFxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgLnN0ZXAgYmVmb3JlIC52YWx1ZSAoc2V0dGluZyAudmFsdWUgYmVmb3JlIC5zdGVwXG4gICAgLy8gbWVhbnMgLnZhbHVlIGlzIHJvdW5kZWQgb24gbW91bnQsIGJhc2VkIHVwb24gc3RlcCBwcmVjaXNpb24pXG4gICAgc3RlcDogdW5kZWZpbmVkLFxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgLm1pbiAmIC5tYXggYmVmb3JlIC52YWx1ZSAodG8gZW5zdXJlIHByb3BlciBvcmRlclxuICAgIC8vIGluIGNvcm5lciBjYXNlcyBzdWNoIGFzIG1pbiBvciBtYXggZGVyaXZpbmcgZnJvbSB2YWx1ZSwgZS5nLiBJc3N1ZSAjNzE3MClcbiAgICBtaW46IHVuZGVmaW5lZCxcbiAgICBtYXg6IHVuZGVmaW5lZFxuICB9LCBwcm9wcywge1xuICAgIGRlZmF1bHRDaGVja2VkOiB1bmRlZmluZWQsXG4gICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgdmFsdWU6IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUsXG4gICAgY2hlY2tlZDogY2hlY2tlZCAhPSBudWxsID8gY2hlY2tlZCA6IG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsQ2hlY2tlZFxuICB9KTtcblxuICByZXR1cm4gaG9zdFByb3BzO1xufVxuXG5mdW5jdGlvbiBpbml0V3JhcHBlclN0YXRlKGVsZW1lbnQsIHByb3BzKSB7XG4gIHtcbiAgICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygnaW5wdXQnLCBwcm9wcywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQzKTtcblxuICAgIGlmIChwcm9wcy5jaGVja2VkICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdENoZWNrZWQgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIGNoZWNrZWQgYW5kIGRlZmF1bHRDaGVja2VkIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSBjaGVja2VkIHByb3AsIG9yIHRoZSBkZWZhdWx0Q2hlY2tlZCBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMigpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpO1xuICAgICAgZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQyKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSk7XG4gICAgICBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgbm9kZS5fd3JhcHBlclN0YXRlID0ge1xuICAgIGluaXRpYWxDaGVja2VkOiBwcm9wcy5jaGVja2VkICE9IG51bGwgPyBwcm9wcy5jaGVja2VkIDogcHJvcHMuZGVmYXVsdENoZWNrZWQsXG4gICAgaW5pdGlhbFZhbHVlOiBwcm9wcy52YWx1ZSAhPSBudWxsID8gcHJvcHMudmFsdWUgOiBkZWZhdWx0VmFsdWUsXG4gICAgY29udHJvbGxlZDogaXNDb250cm9sbGVkKHByb3BzKVxuICB9O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDaGVja2VkKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIGNoZWNrZWQgPSBwcm9wcy5jaGVja2VkO1xuICBpZiAoY2hlY2tlZCAhPSBudWxsKSB7XG4gICAgc2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCAnY2hlY2tlZCcsIGNoZWNrZWQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVdyYXBwZXIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB7XG4gICAgdmFyIGNvbnRyb2xsZWQgPSBpc0NvbnRyb2xsZWQocHJvcHMpO1xuXG4gICAgaWYgKCFub2RlLl93cmFwcGVyU3RhdGUuY29udHJvbGxlZCAmJiBjb250cm9sbGVkICYmICFkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnQSBjb21wb25lbnQgaXMgY2hhbmdpbmcgYW4gdW5jb250cm9sbGVkIGlucHV0IG9mIHR5cGUgJXMgdG8gYmUgY29udHJvbGxlZC4gJyArICdJbnB1dCBlbGVtZW50cyBzaG91bGQgbm90IHN3aXRjaCBmcm9tIHVuY29udHJvbGxlZCB0byBjb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gJyArICdEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBjb21wb25lbnQuIE1vcmUgaW5mbzogaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMlcycsIHByb3BzLnR5cGUsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMygpKTtcbiAgICAgIGRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAobm9kZS5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgIWNvbnRyb2xsZWQgJiYgIWRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdBIGNvbXBvbmVudCBpcyBjaGFuZ2luZyBhIGNvbnRyb2xsZWQgaW5wdXQgb2YgdHlwZSAlcyB0byBiZSB1bmNvbnRyb2xsZWQuICcgKyAnSW5wdXQgZWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSBjb250cm9sbGVkIHRvIHVuY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJXMnLCBwcm9wcy50eXBlLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDMoKSk7XG4gICAgICBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVDaGVja2VkKGVsZW1lbnQsIHByb3BzKTtcblxuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICBpZiAodmFsdWUgPT09IDAgJiYgbm9kZS52YWx1ZSA9PT0gJycpIHtcbiAgICAgIG5vZGUudmFsdWUgPSAnMCc7XG4gICAgICAvLyBOb3RlOiBJRTkgcmVwb3J0cyBhIG51bWJlciBpbnB1dHMgYXMgJ3RleHQnLCBzbyBjaGVjayBwcm9wcyBpbnN0ZWFkLlxuICAgIH0gZWxzZSBpZiAocHJvcHMudHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIFNpbXVsYXRlIGBpbnB1dC52YWx1ZUFzTnVtYmVyYC4gSUU5IGRvZXMgbm90IHN1cHBvcnQgaXRcbiAgICAgIHZhciB2YWx1ZUFzTnVtYmVyID0gcGFyc2VGbG9hdChub2RlLnZhbHVlKSB8fCAwO1xuXG4gICAgICBpZiAoXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIHZhbHVlICE9IHZhbHVlQXNOdW1iZXIgfHxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgdmFsdWUgPT0gdmFsdWVBc051bWJlciAmJiBub2RlLnZhbHVlICE9IHZhbHVlKSB7XG4gICAgICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4gICAgICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBkbyB0aGlzIGFzIG5lY2Vzc2FyeSwganNkb20gZG9lc24ndC5cbiAgICAgICAgbm9kZS52YWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLnZhbHVlICE9PSAnJyArIHZhbHVlKSB7XG4gICAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgICAgLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGRvIHRoaXMgYXMgbmVjZXNzYXJ5LCBqc2RvbSBkb2Vzbid0LlxuICAgICAgbm9kZS52YWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChwcm9wcy52YWx1ZSA9PSBudWxsICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAvLyBJbiBDaHJvbWUsIGFzc2lnbmluZyBkZWZhdWx0VmFsdWUgdG8gY2VydGFpbiBpbnB1dCB0eXBlcyB0cmlnZ2VycyBpbnB1dCB2YWxpZGF0aW9uLlxuICAgICAgLy8gRm9yIG51bWJlciBpbnB1dHMsIHRoZSBkaXNwbGF5IHZhbHVlIGxvc2VzIHRyYWlsaW5nIGRlY2ltYWwgcG9pbnRzLiBGb3IgZW1haWwgaW5wdXRzLFxuICAgICAgLy8gQ2hyb21lIHJhaXNlcyBcIlRoZSBzcGVjaWZpZWQgdmFsdWUgPHg+IGlzIG5vdCBhIHZhbGlkIGVtYWlsIGFkZHJlc3NcIi5cbiAgICAgIC8vXG4gICAgICAvLyBIZXJlIHdlIGNoZWNrIHRvIHNlZSBpZiB0aGUgZGVmYXVsdFZhbHVlIGhhcyBhY3R1YWxseSBjaGFuZ2VkLCBhdm9pZGluZyB0aGVzZSBwcm9ibGVtc1xuICAgICAgLy8gd2hlbiB0aGUgdXNlciBpcyBpbnB1dHRpbmcgdGV4dFxuICAgICAgLy9cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI1M1xuICAgICAgaWYgKG5vZGUuZGVmYXVsdFZhbHVlICE9PSAnJyArIHByb3BzLmRlZmF1bHRWYWx1ZSkge1xuICAgICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9ICcnICsgcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHMuY2hlY2tlZCA9PSBudWxsICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9IG51bGwpIHtcbiAgICAgIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhIXByb3BzLmRlZmF1bHRDaGVja2VkO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0TW91bnRXcmFwcGVyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcblxuICAvLyBEZXRhY2ggdmFsdWUgZnJvbSBkZWZhdWx0VmFsdWUuIFdlIHdvbid0IGRvIGFueXRoaW5nIGlmIHdlJ3JlIHdvcmtpbmcgb25cbiAgLy8gc3VibWl0IG9yIHJlc2V0IGlucHV0cyBhcyB0aG9zZSB2YWx1ZXMgJiBkZWZhdWx0VmFsdWVzIGFyZSBsaW5rZWQuIFRoZXlcbiAgLy8gYXJlIG5vdCByZXNldGFibGUgbm9kZXMgc28gdGhpcyBvcGVyYXRpb24gZG9lc24ndCBtYXR0ZXIgYW5kIGFjdHVhbGx5XG4gIC8vIHJlbW92ZXMgYnJvd3Nlci1kZWZhdWx0IHZhbHVlcyAoZWcgXCJTdWJtaXQgUXVlcnlcIikgd2hlbiBubyB2YWx1ZSBpc1xuICAvLyBwcm92aWRlZC5cblxuICBzd2l0Y2ggKHByb3BzLnR5cGUpIHtcbiAgICBjYXNlICdzdWJtaXQnOlxuICAgIGNhc2UgJ3Jlc2V0JzpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2NvbG9yJzpcbiAgICBjYXNlICdkYXRlJzpcbiAgICBjYXNlICdkYXRldGltZSc6XG4gICAgY2FzZSAnZGF0ZXRpbWUtbG9jYWwnOlxuICAgIGNhc2UgJ21vbnRoJzpcbiAgICBjYXNlICd0aW1lJzpcbiAgICBjYXNlICd3ZWVrJzpcbiAgICAgIC8vIFRoaXMgZml4ZXMgdGhlIG5vLXNob3cgaXNzdWUgb24gaU9TIFNhZmFyaSBhbmQgQW5kcm9pZCBDaHJvbWU6XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyMzNcbiAgICAgIG5vZGUudmFsdWUgPSAnJztcbiAgICAgIG5vZGUudmFsdWUgPSBub2RlLmRlZmF1bHRWYWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBub2RlLnZhbHVlID0gbm9kZS52YWx1ZTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gTm9ybWFsbHksIHdlJ2QganVzdCBkbyBgbm9kZS5jaGVja2VkID0gbm9kZS5jaGVja2VkYCB1cG9uIGluaXRpYWwgbW91bnQsIGxlc3MgdGhpcyBidWdcbiAgLy8gdGhpcyBpcyBuZWVkZWQgdG8gd29yayBhcm91bmQgYSBjaHJvbWUgYnVnIHdoZXJlIHNldHRpbmcgZGVmYXVsdENoZWNrZWRcbiAgLy8gd2lsbCBzb21ldGltZXMgaW5mbHVlbmNlIHRoZSB2YWx1ZSBvZiBjaGVja2VkIChldmVuIGFmdGVyIGRldGFjaG1lbnQpLlxuICAvLyBSZWZlcmVuY2U6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTYwODQxNlxuICAvLyBXZSBuZWVkIHRvIHRlbXBvcmFyaWx5IHVuc2V0IG5hbWUgdG8gYXZvaWQgZGlzcnVwdGluZyByYWRpbyBidXR0b24gZ3JvdXBzLlxuICB2YXIgbmFtZSA9IG5vZGUubmFtZTtcbiAgaWYgKG5hbWUgIT09ICcnKSB7XG4gICAgbm9kZS5uYW1lID0gJyc7XG4gIH1cbiAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICFub2RlLmRlZmF1bHRDaGVja2VkO1xuICBub2RlLmRlZmF1bHRDaGVja2VkID0gIW5vZGUuZGVmYXVsdENoZWNrZWQ7XG4gIGlmIChuYW1lICE9PSAnJykge1xuICAgIG5vZGUubmFtZSA9IG5hbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdXBkYXRlV3JhcHBlcihub2RlLCBwcm9wcyk7XG4gIHVwZGF0ZU5hbWVkQ291c2lucyhub2RlLCBwcm9wcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU5hbWVkQ291c2lucyhyb290Tm9kZSwgcHJvcHMpIHtcbiAgdmFyIG5hbWUgPSBwcm9wcy5uYW1lO1xuICBpZiAocHJvcHMudHlwZSA9PT0gJ3JhZGlvJyAmJiBuYW1lICE9IG51bGwpIHtcbiAgICB2YXIgcXVlcnlSb290ID0gcm9vdE5vZGU7XG5cbiAgICB3aGlsZSAocXVlcnlSb290LnBhcmVudE5vZGUpIHtcbiAgICAgIHF1ZXJ5Um9vdCA9IHF1ZXJ5Um9vdC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIC8vIElmIGByb290Tm9kZS5mb3JtYCB3YXMgbm9uLW51bGwsIHRoZW4gd2UgY291bGQgdHJ5IGBmb3JtLmVsZW1lbnRzYCxcbiAgICAvLyBidXQgdGhhdCBzb21ldGltZXMgYmVoYXZlcyBzdHJhbmdlbHkgaW4gSUU4LiBXZSBjb3VsZCBhbHNvIHRyeSB1c2luZ1xuICAgIC8vIGBmb3JtLmdldEVsZW1lbnRzQnlOYW1lYCwgYnV0IHRoYXQgd2lsbCBvbmx5IHJldHVybiBkaXJlY3QgY2hpbGRyZW5cbiAgICAvLyBhbmQgd29uJ3QgaW5jbHVkZSBpbnB1dHMgdGhhdCB1c2UgdGhlIEhUTUw1IGBmb3JtPWAgYXR0cmlidXRlLiBTaW5jZVxuICAgIC8vIHRoZSBpbnB1dCBtaWdodCBub3QgZXZlbiBiZSBpbiBhIGZvcm0uIEl0IG1pZ2h0IG5vdCBldmVuIGJlIGluIHRoZVxuICAgIC8vIGRvY3VtZW50LiBMZXQncyBqdXN0IHVzZSB0aGUgbG9jYWwgYHF1ZXJ5U2VsZWN0b3JBbGxgIHRvIGVuc3VyZSB3ZSBkb24ndFxuICAgIC8vIG1pc3MgYW55dGhpbmcuXG4gICAgdmFyIGdyb3VwID0gcXVlcnlSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W25hbWU9JyArIEpTT04uc3RyaW5naWZ5KCcnICsgbmFtZSkgKyAnXVt0eXBlPVwicmFkaW9cIl0nKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvdGhlck5vZGUgPSBncm91cFtpXTtcbiAgICAgIGlmIChvdGhlck5vZGUgPT09IHJvb3ROb2RlIHx8IG90aGVyTm9kZS5mb3JtICE9PSByb290Tm9kZS5mb3JtKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGlmIHJhZGlvIGJ1dHRvbnMgcmVuZGVyZWQgYnkgZGlmZmVyZW50IGNvcGllcyBvZiBSZWFjdFxuICAgICAgLy8gYW5kIHRoZSBzYW1lIG5hbWUgYXJlIHJlbmRlcmVkIGludG8gdGhlIHNhbWUgZm9ybSAoc2FtZSBhcyAjMTkzOSkuXG4gICAgICAvLyBUaGF0J3MgcHJvYmFibHkgb2theTsgd2UgZG9uJ3Qgc3VwcG9ydCBpdCBqdXN0IGFzIHdlIGRvbid0IHN1cHBvcnRcbiAgICAgIC8vIG1peGluZyBSZWFjdCByYWRpbyBidXR0b25zIHdpdGggbm9uLVJlYWN0IG9uZXMuXG4gICAgICB2YXIgb3RoZXJQcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUkMShvdGhlck5vZGUpO1xuICAgICAgIW90aGVyUHJvcHMgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTUlucHV0OiBNaXhpbmcgUmVhY3QgYW5kIG5vbi1SZWFjdCByYWRpbyBpbnB1dHMgd2l0aCB0aGUgc2FtZSBgbmFtZWAgaXMgbm90IHN1cHBvcnRlZC4nKSA6IHZvaWQgMDtcblxuICAgICAgLy8gV2UgbmVlZCB1cGRhdGUgdGhlIHRyYWNrZWQgdmFsdWUgb24gdGhlIG5hbWVkIGNvdXNpbiBzaW5jZSB0aGUgdmFsdWVcbiAgICAgIC8vIHdhcyBjaGFuZ2VkIGJ1dCB0aGUgaW5wdXQgc2F3IG5vIGV2ZW50IG9yIHZhbHVlIHNldFxuICAgICAgdXBkYXRlVmFsdWVJZkNoYW5nZWQob3RoZXJOb2RlKTtcblxuICAgICAgLy8gSWYgdGhpcyBpcyBhIGNvbnRyb2xsZWQgcmFkaW8gYnV0dG9uIGdyb3VwLCBmb3JjaW5nIHRoZSBpbnB1dCB0aGF0XG4gICAgICAvLyB3YXMgcHJldmlvdXNseSBjaGVja2VkIHRvIHVwZGF0ZSB3aWxsIGNhdXNlIGl0IHRvIGJlIGNvbWUgcmUtY2hlY2tlZFxuICAgICAgLy8gYXMgYXBwcm9wcmlhdGUuXG4gICAgICB1cGRhdGVXcmFwcGVyKG90aGVyTm9kZSwgb3RoZXJQcm9wcyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5DaGlsZHJlbihjaGlsZHJlbikge1xuICB2YXIgY29udGVudCA9ICcnO1xuXG4gIC8vIEZsYXR0ZW4gY2hpbGRyZW4gYW5kIHdhcm4gaWYgdGhleSBhcmVuJ3Qgc3RyaW5ncyBvciBudW1iZXJzO1xuICAvLyBpbnZhbGlkIHR5cGVzIGFyZSBpZ25vcmVkLlxuICAvLyBXZSBjYW4gc2lsZW50bHkgc2tpcCB0aGVtIGJlY2F1c2UgaW52YWxpZCBET00gbmVzdGluZyB3YXJuaW5nXG4gIC8vIGNhdGNoZXMgdGhlc2UgY2FzZXMgaW4gRmliZXIuXG4gIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbnRlbnQgKz0gY2hpbGQ7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY29udGVudDtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxvcHRpb24+IGhvc3QgY29tcG9uZW50IHRoYXQgd2FybnMgd2hlbiBgc2VsZWN0ZWRgIGlzIHNldC5cbiAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BzKGVsZW1lbnQsIHByb3BzKSB7XG4gIC8vIFRPRE8gKHl1bmdzdGVycyk6IFJlbW92ZSBzdXBwb3J0IGZvciBgc2VsZWN0ZWRgIGluIDxvcHRpb24+LlxuICB7XG4gICAgd2FybmluZyhwcm9wcy5zZWxlY3RlZCA9PSBudWxsLCAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIG9uIDxzZWxlY3Q+IGluc3RlYWQgb2YgJyArICdzZXR0aW5nIGBzZWxlY3RlZGAgb24gPG9wdGlvbj4uJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIC8vIHZhbHVlPVwiXCIgc2hvdWxkIG1ha2UgYSB2YWx1ZSBhdHRyaWJ1dGUgKCM2MjE5KVxuICBpZiAocHJvcHMudmFsdWUgIT0gbnVsbCkge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHByb3BzLnZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMkMShlbGVtZW50LCBwcm9wcykge1xuICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7IGNoaWxkcmVuOiB1bmRlZmluZWQgfSwgcHJvcHMpO1xuICB2YXIgY29udGVudCA9IGZsYXR0ZW5DaGlsZHJlbihwcm9wcy5jaGlsZHJlbik7XG5cbiAgaWYgKGNvbnRlbnQpIHtcbiAgICBob3N0UHJvcHMuY2hpbGRyZW4gPSBjb250ZW50O1xuICB9XG5cbiAgcmV0dXJuIGhvc3RQcm9wcztcbn1cblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQzID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJPd25lck5hbWU7XG52YXIgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ0ID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuXG5cbntcbiAgdmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgdmFyIG93bmVyTmFtZSA9IGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQzKCk7XG4gIGlmIChvd25lck5hbWUpIHtcbiAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgb3duZXJOYW1lICsgJ2AuJztcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbnZhciB2YWx1ZVByb3BOYW1lcyA9IFsndmFsdWUnLCAnZGVmYXVsdFZhbHVlJ107XG5cbi8qKlxuICogVmFsaWRhdGlvbiBmdW5jdGlvbiBmb3IgYHZhbHVlYCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrU2VsZWN0UHJvcFR5cGVzKHByb3BzKSB7XG4gIFJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCdzZWxlY3QnLCBwcm9wcywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ0KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlUHJvcE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3BOYW1lID0gdmFsdWVQcm9wTmFtZXNbaV07XG4gICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHByb3BzW3Byb3BOYW1lXSk7XG4gICAgaWYgKHByb3BzLm11bHRpcGxlICYmICFpc0FycmF5KSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGFuIGFycmF5IGlmICcgKyAnYG11bHRpcGxlYCBpcyB0cnVlLiVzJywgcHJvcE5hbWUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpKTtcbiAgICB9IGVsc2UgaWYgKCFwcm9wcy5tdWx0aXBsZSAmJiBpc0FycmF5KSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGEgc2NhbGFyICcgKyAndmFsdWUgaWYgYG11bHRpcGxlYCBpcyBmYWxzZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMobm9kZSwgbXVsdGlwbGUsIHByb3BWYWx1ZSwgc2V0RGVmYXVsdFNlbGVjdGVkKSB7XG4gIHZhciBvcHRpb25zID0gbm9kZS5vcHRpb25zO1xuXG4gIGlmIChtdWx0aXBsZSkge1xuICAgIHZhciBzZWxlY3RlZFZhbHVlcyA9IHByb3BWYWx1ZTtcbiAgICB2YXIgc2VsZWN0ZWRWYWx1ZSA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIFByZWZpeCB0byBhdm9pZCBjaGFvcyB3aXRoIHNwZWNpYWwga2V5cy5cbiAgICAgIHNlbGVjdGVkVmFsdWVbJyQnICsgc2VsZWN0ZWRWYWx1ZXNbaV1dID0gdHJ1ZTtcbiAgICB9XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG9wdGlvbnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBzZWxlY3RlZFZhbHVlLmhhc093blByb3BlcnR5KCckJyArIG9wdGlvbnNbX2ldLnZhbHVlKTtcbiAgICAgIGlmIChvcHRpb25zW19pXS5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uc1tfaV0uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxlY3RlZCAmJiBzZXREZWZhdWx0U2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uc1tfaV0uZGVmYXVsdFNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gbm90IHNldCBgc2VsZWN0LnZhbHVlYCBhcyBleGFjdCBiZWhhdmlvciBpc24ndCBjb25zaXN0ZW50IGFjcm9zcyBhbGxcbiAgICAvLyBicm93c2VycyBmb3IgYWxsIGNhc2VzLlxuICAgIHZhciBfc2VsZWN0ZWRWYWx1ZSA9ICcnICsgcHJvcFZhbHVlO1xuICAgIHZhciBkZWZhdWx0U2VsZWN0ZWQgPSBudWxsO1xuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG9wdGlvbnMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgaWYgKG9wdGlvbnNbX2kyXS52YWx1ZSA9PT0gX3NlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgb3B0aW9uc1tfaTJdLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHNldERlZmF1bHRTZWxlY3RlZCkge1xuICAgICAgICAgIG9wdGlvbnNbX2kyXS5kZWZhdWx0U2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChkZWZhdWx0U2VsZWN0ZWQgPT09IG51bGwgJiYgIW9wdGlvbnNbX2kyXS5kaXNhYmxlZCkge1xuICAgICAgICBkZWZhdWx0U2VsZWN0ZWQgPSBvcHRpb25zW19pMl07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkZWZhdWx0U2VsZWN0ZWQgIT09IG51bGwpIHtcbiAgICAgIGRlZmF1bHRTZWxlY3RlZC5zZWxlY3RlZCA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDxzZWxlY3Q+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIG9wdGlvbmFsbHkgc2V0dGluZyB0aGVcbiAqIHByb3BzIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLiBJZiBgbXVsdGlwbGVgIGlzIGZhbHNlLCB0aGUgcHJvcCBtdXN0IGJlIGFcbiAqIHN0cmluZ2FibGUuIElmIGBtdWx0aXBsZWAgaXMgdHJ1ZSwgdGhlIHByb3AgbXVzdCBiZSBhbiBhcnJheSBvZiBzdHJpbmdhYmxlcy5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBjaGFuZ2UgdGhlXG4gKiBzZWxlY3RlZCBvcHRpb24gd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gKlxuICogSWYgaXQgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgb3B0aW9ucyB3aWxsIG5vdFxuICogdXBkYXRlIGluIHJlc3BvbnNlIHRvIHVzZXIgYWN0aW9ucy4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBvcHRpb25zIHRvIHVwZGF0ZS5cbiAqXG4gKiBJZiBgZGVmYXVsdFZhbHVlYCBpcyBwcm92aWRlZCwgYW55IG9wdGlvbnMgd2l0aCB0aGUgc3VwcGxpZWQgdmFsdWVzIHdpbGwgYmVcbiAqIHNlbGVjdGVkLlxuICovXG5cbmZ1bmN0aW9uIGdldEhvc3RQcm9wcyQyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHJldHVybiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGluaXRXcmFwcGVyU3RhdGUkMShlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHtcbiAgICBjaGVja1NlbGVjdFByb3BUeXBlcyhwcm9wcyk7XG4gIH1cblxuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgbm9kZS5fd3JhcHBlclN0YXRlID0ge1xuICAgIGluaXRpYWxWYWx1ZTogdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogcHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgIHdhc011bHRpcGxlOiAhIXByb3BzLm11bHRpcGxlXG4gIH07XG5cbiAge1xuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1NlbGVjdCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgc2VsZWN0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJyk7XG4gICAgICBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIkMihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIG5vZGUubXVsdGlwbGUgPSAhIXByb3BzLm11bHRpcGxlO1xuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHZhbHVlLCBmYWxzZSk7XG4gIH0gZWxzZSBpZiAocHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHByb3BzLmRlZmF1bHRWYWx1ZSwgdHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdFVwZGF0ZVdyYXBwZXIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICAvLyBBZnRlciB0aGUgaW5pdGlhbCBtb3VudCwgd2UgY29udHJvbCBzZWxlY3RlZC1uZXNzIG1hbnVhbGx5IHNvIGRvbid0IHBhc3NcbiAgLy8gdGhpcyB2YWx1ZSBkb3duXG4gIG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUgPSB1bmRlZmluZWQ7XG5cbiAgdmFyIHdhc011bHRpcGxlID0gbm9kZS5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlO1xuICBub2RlLl93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGUgPSAhIXByb3BzLm11bHRpcGxlO1xuXG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgdmFsdWUsIGZhbHNlKTtcbiAgfSBlbHNlIGlmICh3YXNNdWx0aXBsZSAhPT0gISFwcm9wcy5tdWx0aXBsZSkge1xuICAgIC8vIEZvciBzaW1wbGljaXR5LCByZWFwcGx5IGBkZWZhdWx0VmFsdWVgIGlmIGBtdWx0aXBsZWAgaXMgdG9nZ2xlZC5cbiAgICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgcHJvcHMuZGVmYXVsdFZhbHVlLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmV2ZXJ0IHRoZSBzZWxlY3QgYmFjayB0byBpdHMgZGVmYXVsdCB1bnNlbGVjdGVkIHN0YXRlLlxuICAgICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCBwcm9wcy5tdWx0aXBsZSA/IFtdIDogJycsIGZhbHNlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG5cbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHZhbHVlLCBmYWxzZSk7XG4gIH1cbn1cblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNSA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxudmFyIGRpZFdhcm5WYWxEZWZhdWx0VmFsID0gZmFsc2U7XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDx0ZXh0YXJlYT4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyBgdmFsdWVgLCBhbmRcbiAqIGBkZWZhdWx0VmFsdWVgLiBUaGlzIGRpZmZlcnMgZnJvbSB0aGUgdHJhZGl0aW9uYWwgRE9NIEFQSSBiZWNhdXNlIHZhbHVlIGlzXG4gKiB1c3VhbGx5IHNldCBhcyBQQ0RBVEEgY2hpbGRyZW4uXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgYWZmZWN0IHRoZVxuICogdmFsdWUgd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGxcbiAqIG5vdCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgZWxlbWVudCB0byBiZSB1cGRhdGVkLlxuICpcbiAqIFRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhbiBlbXB0eSB2YWx1ZSwgdGhlIHByb3BcbiAqIGBkZWZhdWx0VmFsdWVgIGlmIHNwZWNpZmllZCwgb3IgdGhlIGNoaWxkcmVuIGNvbnRlbnQgKGRlcHJlY2F0ZWQpLlxuICovXG5cbmZ1bmN0aW9uIGdldEhvc3RQcm9wcyQzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgIShwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ2BkYW5nZXJvdXNseVNldElubmVySFRNTGAgZG9lcyBub3QgbWFrZSBzZW5zZSBvbiA8dGV4dGFyZWE+LicpIDogdm9pZCAwO1xuXG4gIC8vIEFsd2F5cyBzZXQgY2hpbGRyZW4gdG8gdGhlIHNhbWUgdGhpbmcuIEluIElFOSwgdGhlIHNlbGVjdGlvbiByYW5nZSB3aWxsXG4gIC8vIGdldCByZXNldCBpZiBgdGV4dENvbnRlbnRgIGlzIG11dGF0ZWQuICBXZSBjb3VsZCBhZGQgYSBjaGVjayBpbiBzZXRUZXh0Q29udGVudFxuICAvLyB0byBvbmx5IHNldCB0aGUgdmFsdWUgaWYvd2hlbiB0aGUgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBub2RlIHZhbHVlICh3aGljaCB3b3VsZFxuICAvLyBjb21wbGV0ZWx5IHNvbHZlIHRoaXMgSUU5IGJ1ZyksIGJ1dCBTZWJhc3RpYW4rU29waGllIHNlZW1lZCB0byBsaWtlIHRoaXNcbiAgLy8gc29sdXRpb24uIFRoZSB2YWx1ZSBjYW4gYmUgYSBib29sZWFuIG9yIG9iamVjdCBzbyB0aGF0J3Mgd2h5IGl0J3MgZm9yY2VkXG4gIC8vIHRvIGJlIGEgc3RyaW5nLlxuICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgIGNoaWxkcmVuOiAnJyArIG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWVcbiAgfSk7XG5cbiAgcmV0dXJuIGhvc3RQcm9wcztcbn1cblxuZnVuY3Rpb24gaW5pdFdyYXBwZXJTdGF0ZSQyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAge1xuICAgIFJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCd0ZXh0YXJlYScsIHByb3BzLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDUpO1xuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsRGVmYXVsdFZhbCkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RleHRhcmVhIGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCB0ZXh0YXJlYSAnICsgJ2FuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnKTtcbiAgICAgIGRpZFdhcm5WYWxEZWZhdWx0VmFsID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgaW5pdGlhbFZhbHVlID0gcHJvcHMudmFsdWU7XG5cbiAgLy8gT25seSBib3RoZXIgZmV0Y2hpbmcgZGVmYXVsdCB2YWx1ZSBpZiB3ZSdyZSBnb2luZyB0byB1c2UgaXRcbiAgaWYgKGluaXRpYWxWYWx1ZSA9PSBudWxsKSB7XG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAvLyBUT0RPICh5dW5nc3RlcnMpOiBSZW1vdmUgc3VwcG9ydCBmb3IgY2hpbGRyZW4gY29udGVudCBpbiA8dGV4dGFyZWE+LlxuICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICAgIGlmIChjaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgaW5zdGVhZCBvZiBzZXR0aW5nICcgKyAnY2hpbGRyZW4gb24gPHRleHRhcmVhPi4nKTtcbiAgICAgIH1cbiAgICAgICEoZGVmYXVsdFZhbHVlID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnSWYgeW91IHN1cHBseSBgZGVmYXVsdFZhbHVlYCBvbiBhIDx0ZXh0YXJlYT4sIGRvIG5vdCBwYXNzIGNoaWxkcmVuLicpIDogdm9pZCAwO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICEoY2hpbGRyZW4ubGVuZ3RoIDw9IDEpID8gaW52YXJpYW50KGZhbHNlLCAnPHRleHRhcmVhPiBjYW4gb25seSBoYXZlIGF0IG1vc3Qgb25lIGNoaWxkLicpIDogdm9pZCAwO1xuICAgICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuWzBdO1xuICAgICAgfVxuXG4gICAgICBkZWZhdWx0VmFsdWUgPSAnJyArIGNoaWxkcmVuO1xuICAgIH1cbiAgICBpZiAoZGVmYXVsdFZhbHVlID09IG51bGwpIHtcbiAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnO1xuICAgIH1cbiAgICBpbml0aWFsVmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gIH1cblxuICBub2RlLl93cmFwcGVyU3RhdGUgPSB7XG4gICAgaW5pdGlhbFZhbHVlOiAnJyArIGluaXRpYWxWYWx1ZVxuICB9O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVXcmFwcGVyJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBkbyB0aGlzIGFzIG5lY2Vzc2FyeSwganNkb20gZG9lc24ndC5cbiAgICB2YXIgbmV3VmFsdWUgPSAnJyArIHZhbHVlO1xuXG4gICAgLy8gVG8gYXZvaWQgc2lkZSBlZmZlY3RzIChzdWNoIGFzIGxvc2luZyB0ZXh0IHNlbGVjdGlvbiksIG9ubHkgc2V0IHZhbHVlIGlmIGNoYW5nZWRcbiAgICBpZiAobmV3VmFsdWUgIT09IG5vZGUudmFsdWUpIHtcbiAgICAgIG5vZGUudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgIH1cbiAgfVxuICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0TW91bnRXcmFwcGVyJDMoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICAvLyBUaGlzIGlzIGluIHBvc3RNb3VudCBiZWNhdXNlIHdlIG5lZWQgYWNjZXNzIHRvIHRoZSBET00gbm9kZSwgd2hpY2ggaXMgbm90XG4gIC8vIGF2YWlsYWJsZSB1bnRpbCBhZnRlciB0aGUgY29tcG9uZW50IGhhcyBtb3VudGVkLlxuICB2YXIgdGV4dENvbnRlbnQgPSBub2RlLnRleHRDb250ZW50O1xuXG4gIC8vIE9ubHkgc2V0IG5vZGUudmFsdWUgaWYgdGV4dENvbnRlbnQgaXMgZXF1YWwgdG8gdGhlIGV4cGVjdGVkXG4gIC8vIGluaXRpYWwgdmFsdWUuIEluIElFMTAvSUUxMSB0aGVyZSBpcyBhIGJ1ZyB3aGVyZSB0aGUgcGxhY2Vob2xkZXIgYXR0cmlidXRlXG4gIC8vIHdpbGwgcG9wdWxhdGUgdGV4dENvbnRlbnQgYXMgd2VsbC5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMTAxNTI1L1xuICBpZiAodGV4dENvbnRlbnQgPT09IG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUpIHtcbiAgICBub2RlLnZhbHVlID0gdGV4dENvbnRlbnQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQzKGVsZW1lbnQsIHByb3BzKSB7XG4gIC8vIERPTSBjb21wb25lbnQgaXMgc3RpbGwgbW91bnRlZDsgdXBkYXRlXG4gIHVwZGF0ZVdyYXBwZXIkMShlbGVtZW50LCBwcm9wcyk7XG59XG5cbnZhciBIVE1MX05BTUVTUEFDRSQxID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO1xudmFyIE1BVEhfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnO1xudmFyIFNWR19OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuXG52YXIgTmFtZXNwYWNlcyA9IHtcbiAgaHRtbDogSFRNTF9OQU1FU1BBQ0UkMSxcbiAgbWF0aG1sOiBNQVRIX05BTUVTUEFDRSxcbiAgc3ZnOiBTVkdfTkFNRVNQQUNFXG59O1xuXG4vLyBBc3N1bWVzIHRoZXJlIGlzIG5vIHBhcmVudCBuYW1lc3BhY2UuXG5mdW5jdGlvbiBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodHlwZSkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdzdmcnOlxuICAgICAgcmV0dXJuIFNWR19OQU1FU1BBQ0U7XG4gICAgY2FzZSAnbWF0aCc6XG4gICAgICByZXR1cm4gTUFUSF9OQU1FU1BBQ0U7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBIVE1MX05BTUVTUEFDRSQxO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldENoaWxkTmFtZXNwYWNlKHBhcmVudE5hbWVzcGFjZSwgdHlwZSkge1xuICBpZiAocGFyZW50TmFtZXNwYWNlID09IG51bGwgfHwgcGFyZW50TmFtZXNwYWNlID09PSBIVE1MX05BTUVTUEFDRSQxKSB7XG4gICAgLy8gTm8gKG9yIGRlZmF1bHQpIHBhcmVudCBuYW1lc3BhY2U6IHBvdGVudGlhbCBlbnRyeSBwb2ludC5cbiAgICByZXR1cm4gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpO1xuICB9XG4gIGlmIChwYXJlbnROYW1lc3BhY2UgPT09IFNWR19OQU1FU1BBQ0UgJiYgdHlwZSA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gV2UncmUgbGVhdmluZyBTVkcuXG4gICAgcmV0dXJuIEhUTUxfTkFNRVNQQUNFJDE7XG4gIH1cbiAgLy8gQnkgZGVmYXVsdCwgcGFzcyBuYW1lc3BhY2UgYmVsb3cuXG4gIHJldHVybiBwYXJlbnROYW1lc3BhY2U7XG59XG5cbi8qIGdsb2JhbHMgTVNBcHAgKi9cblxuLyoqXG4gKiBDcmVhdGUgYSBmdW5jdGlvbiB3aGljaCBoYXMgJ3Vuc2FmZScgcHJpdmlsZWdlcyAocmVxdWlyZWQgYnkgd2luZG93czggYXBwcylcbiAqL1xudmFyIGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24gPSBmdW5jdGlvbiAoZnVuYykge1xuICBpZiAodHlwZW9mIE1TQXBwICE9PSAndW5kZWZpbmVkJyAmJiBNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuYyhhcmcwLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH1cbn07XG5cbi8vIFNWRyB0ZW1wIGNvbnRhaW5lciBmb3IgSUUgbGFja2luZyBpbm5lckhUTUxcbnZhciByZXVzYWJsZVNWR0NvbnRhaW5lciA9IHZvaWQgMDtcblxuLyoqXG4gKiBTZXQgdGhlIGlubmVySFRNTCBwcm9wZXJ0eSBvZiBhIG5vZGVcbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIHNldElubmVySFRNTCA9IGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKG5vZGUsIGh0bWwpIHtcbiAgLy8gSUUgZG9lcyBub3QgaGF2ZSBpbm5lckhUTUwgZm9yIFNWRyBub2Rlcywgc28gaW5zdGVhZCB3ZSBpbmplY3QgdGhlXG4gIC8vIG5ldyBtYXJrdXAgaW4gYSB0ZW1wIG5vZGUgYW5kIHRoZW4gbW92ZSB0aGUgY2hpbGQgbm9kZXMgYWNyb3NzIGludG9cbiAgLy8gdGhlIHRhcmdldCBub2RlXG5cbiAgaWYgKG5vZGUubmFtZXNwYWNlVVJJID09PSBOYW1lc3BhY2VzLnN2ZyAmJiAhKCdpbm5lckhUTUwnIGluIG5vZGUpKSB7XG4gICAgcmV1c2FibGVTVkdDb250YWluZXIgPSByZXVzYWJsZVNWR0NvbnRhaW5lciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICByZXVzYWJsZVNWR0NvbnRhaW5lci5pbm5lckhUTUwgPSAnPHN2Zz4nICsgaHRtbCArICc8L3N2Zz4nO1xuICAgIHZhciBzdmdOb2RlID0gcmV1c2FibGVTVkdDb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAobm9kZS5maXJzdENoaWxkKSB7XG4gICAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIHdoaWxlIChzdmdOb2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoc3ZnTm9kZS5maXJzdENoaWxkKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5pbm5lckhUTUwgPSBodG1sO1xuICB9XG59KTtcblxuLyoqXG4gKiBTZXQgdGhlIHRleHRDb250ZW50IHByb3BlcnR5IG9mIGEgbm9kZSwgZW5zdXJpbmcgdGhhdCB3aGl0ZXNwYWNlIGlzIHByZXNlcnZlZFxuICogZXZlbiBpbiBJRTguIGlubmVyVGV4dCBpcyBhIHBvb3Igc3Vic3RpdHV0ZSBmb3IgdGV4dENvbnRlbnQgYW5kLCBhbW9uZyBtYW55XG4gKiBpc3N1ZXMsIGluc2VydHMgPGJyPiBpbnN0ZWFkIG9mIHRoZSBsaXRlcmFsIG5ld2xpbmUgY2hhcnMuIGlubmVySFRNTCBiZWhhdmVzXG4gKiBhcyBpdCBzaG91bGQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQGludGVybmFsXG4gKi9cbnZhciBzZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uIChub2RlLCB0ZXh0KSB7XG4gIGlmICh0ZXh0KSB7XG4gICAgdmFyIGZpcnN0Q2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG5cbiAgICBpZiAoZmlyc3RDaGlsZCAmJiBmaXJzdENoaWxkID09PSBub2RlLmxhc3RDaGlsZCAmJiBmaXJzdENoaWxkLm5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgIGZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdGV4dDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59O1xuXG4vKipcbiAqIENTUyBwcm9wZXJ0aWVzIHdoaWNoIGFjY2VwdCBudW1iZXJzIGJ1dCBhcmUgbm90IGluIHVuaXRzIG9mIFwicHhcIi5cbiAqL1xudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSB7XG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0cnVlLFxuICBib3JkZXJJbWFnZU91dHNldDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VTbGljZTogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VXaWR0aDogdHJ1ZSxcbiAgYm94RmxleDogdHJ1ZSxcbiAgYm94RmxleEdyb3VwOiB0cnVlLFxuICBib3hPcmRpbmFsR3JvdXA6IHRydWUsXG4gIGNvbHVtbkNvdW50OiB0cnVlLFxuICBjb2x1bW5zOiB0cnVlLFxuICBmbGV4OiB0cnVlLFxuICBmbGV4R3JvdzogdHJ1ZSxcbiAgZmxleFBvc2l0aXZlOiB0cnVlLFxuICBmbGV4U2hyaW5rOiB0cnVlLFxuICBmbGV4TmVnYXRpdmU6IHRydWUsXG4gIGZsZXhPcmRlcjogdHJ1ZSxcbiAgZ3JpZFJvdzogdHJ1ZSxcbiAgZ3JpZFJvd0VuZDogdHJ1ZSxcbiAgZ3JpZFJvd1NwYW46IHRydWUsXG4gIGdyaWRSb3dTdGFydDogdHJ1ZSxcbiAgZ3JpZENvbHVtbjogdHJ1ZSxcbiAgZ3JpZENvbHVtbkVuZDogdHJ1ZSxcbiAgZ3JpZENvbHVtblNwYW46IHRydWUsXG4gIGdyaWRDb2x1bW5TdGFydDogdHJ1ZSxcbiAgZm9udFdlaWdodDogdHJ1ZSxcbiAgbGluZUNsYW1wOiB0cnVlLFxuICBsaW5lSGVpZ2h0OiB0cnVlLFxuICBvcGFjaXR5OiB0cnVlLFxuICBvcmRlcjogdHJ1ZSxcbiAgb3JwaGFuczogdHJ1ZSxcbiAgdGFiU2l6ZTogdHJ1ZSxcbiAgd2lkb3dzOiB0cnVlLFxuICB6SW5kZXg6IHRydWUsXG4gIHpvb206IHRydWUsXG5cbiAgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuICBmaWxsT3BhY2l0eTogdHJ1ZSxcbiAgZmxvb2RPcGFjaXR5OiB0cnVlLFxuICBzdG9wT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaGFycmF5OiB0cnVlLFxuICBzdHJva2VEYXNob2Zmc2V0OiB0cnVlLFxuICBzdHJva2VNaXRlcmxpbWl0OiB0cnVlLFxuICBzdHJva2VPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VXaWR0aDogdHJ1ZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IHZlbmRvci1zcGVjaWZpYyBwcmVmaXgsIGVnOiBXZWJraXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgc3R5bGUgbmFtZSwgZWc6IHRyYW5zaXRpb25EdXJhdGlvblxuICogQHJldHVybiB7c3RyaW5nfSBzdHlsZSBuYW1lIHByZWZpeGVkIHdpdGggYHByZWZpeGAsIHByb3Blcmx5IGNhbWVsQ2FzZWQsIGVnOlxuICogV2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uXG4gKi9cbmZ1bmN0aW9uIHByZWZpeEtleShwcmVmaXgsIGtleSkge1xuICByZXR1cm4gcHJlZml4ICsga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnN1YnN0cmluZygxKTtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHN0eWxlIG5hbWVzIHRoYXQgbWF5IGNvbWUgcGFzc2VkIGluIHByZWZpeGVkIGJ5IGFkZGluZyBwZXJtdXRhdGlvbnNcbiAqIG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xudmFyIHByZWZpeGVzID0gWydXZWJraXQnLCAnbXMnLCAnTW96JywgJ08nXTtcblxuLy8gVXNpbmcgT2JqZWN0LmtleXMgaGVyZSwgb3IgZWxzZSB0aGUgdmFuaWxsYSBmb3ItaW4gbG9vcCBtYWtlcyBJRTggZ28gaW50byBhblxuLy8gaW5maW5pdGUgbG9vcCwgYmVjYXVzZSBpdCBpdGVyYXRlcyBvdmVyIHRoZSBuZXdseSBhZGRlZCBwcm9wcyB0b28uXG5PYmplY3Qua2V5cyhpc1VuaXRsZXNzTnVtYmVyKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gIHByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xuICAgIGlzVW5pdGxlc3NOdW1iZXJbcHJlZml4S2V5KHByZWZpeCwgcHJvcCldID0gaXNVbml0bGVzc051bWJlcltwcm9wXTtcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgaW50byB0aGUgcHJvcGVyIGNzcyB3cml0YWJsZSB2YWx1ZS4gVGhlIHN0eWxlIG5hbWUgYG5hbWVgXG4gKiBzaG91bGQgYmUgbG9naWNhbCAobm8gaHlwaGVucyksIGFzIHNwZWNpZmllZFxuICogaW4gYENTU1Byb3BlcnR5LmlzVW5pdGxlc3NOdW1iZXJgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIENTUyBwcm9wZXJ0eSBuYW1lIHN1Y2ggYXMgYHRvcE1hcmdpbmAuXG4gKiBAcGFyYW0geyp9IHZhbHVlIENTUyBwcm9wZXJ0eSB2YWx1ZSBzdWNoIGFzIGAxMHB4YC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBzdHlsZSB2YWx1ZSB3aXRoIGRpbWVuc2lvbnMgYXBwbGllZC5cbiAqL1xuZnVuY3Rpb24gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShuYW1lLCB2YWx1ZSwgaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAvLyBOb3RlIHRoYXQgd2UndmUgcmVtb3ZlZCBlc2NhcGVUZXh0Rm9yQnJvd3NlcigpIGNhbGxzIGhlcmUgc2luY2UgdGhlXG4gIC8vIHdob2xlIHN0cmluZyB3aWxsIGJlIGVzY2FwZWQgd2hlbiB0aGUgYXR0cmlidXRlIGlzIGluamVjdGVkIGludG9cbiAgLy8gdGhlIG1hcmt1cC4gSWYgeW91IHByb3ZpZGUgdW5zYWZlIHVzZXIgZGF0YSBoZXJlIHRoZXkgY2FuIGluamVjdFxuICAvLyBhcmJpdHJhcnkgQ1NTIHdoaWNoIG1heSBiZSBwcm9ibGVtYXRpYyAoSSBjb3VsZG4ndCByZXBybyB0aGlzKTpcbiAgLy8gaHR0cHM6Ly93d3cub3dhc3Aub3JnL2luZGV4LnBocC9YU1NfRmlsdGVyX0V2YXNpb25fQ2hlYXRfU2hlZXRcbiAgLy8gaHR0cDovL3d3dy50aGVzcGFubmVyLmNvLnVrLzIwMDcvMTEvMjYvdWx0aW1hdGUteHNzLWNzcy1pbmplY3Rpb24vXG4gIC8vIFRoaXMgaXMgbm90IGFuIFhTUyBob2xlIGJ1dCBpbnN0ZWFkIGEgcG90ZW50aWFsIENTUyBpbmplY3Rpb24gaXNzdWVcbiAgLy8gd2hpY2ggaGFzIGxlYWQgdG8gYSBncmVhdGVyIGRpc2N1c3Npb24gYWJvdXQgaG93IHdlJ3JlIGdvaW5nIHRvXG4gIC8vIHRydXN0IFVSTHMgbW92aW5nIGZvcndhcmQuIFNlZSAjMjExNTkwMVxuXG4gIHZhciBpc0VtcHR5ID0gdmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB8fCB2YWx1ZSA9PT0gJyc7XG4gIGlmIChpc0VtcHR5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKCFpc0N1c3RvbVByb3BlcnR5ICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdmFsdWUgIT09IDAgJiYgIShpc1VuaXRsZXNzTnVtYmVyLmhhc093blByb3BlcnR5KG5hbWUpICYmIGlzVW5pdGxlc3NOdW1iZXJbbmFtZV0pKSB7XG4gICAgcmV0dXJuIHZhbHVlICsgJ3B4JzsgLy8gUHJlc3VtZXMgaW1wbGljaXQgJ3B4JyBzdWZmaXggZm9yIHVuaXRsZXNzIG51bWJlcnNcbiAgfVxuXG4gIHJldHVybiAoJycgKyB2YWx1ZSkudHJpbSgpO1xufVxuXG52YXIgd2FyblZhbGlkU3R5bGUgPSBlbXB0eUZ1bmN0aW9uO1xuXG57XG4gIC8vICdtc1RyYW5zZm9ybScgaXMgY29ycmVjdCwgYnV0IHRoZSBvdGhlciBwcmVmaXhlcyBzaG91bGQgYmUgY2FwaXRhbGl6ZWRcbiAgdmFyIGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybiA9IC9eKD86d2Via2l0fG1venxvKVtBLVpdLztcblxuICAvLyBzdHlsZSB2YWx1ZXMgc2hvdWxkbid0IGNvbnRhaW4gYSBzZW1pY29sb25cbiAgdmFyIGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiA9IC87XFxzKiQvO1xuXG4gIHZhciB3YXJuZWRTdHlsZU5hbWVzID0ge307XG4gIHZhciB3YXJuZWRTdHlsZVZhbHVlcyA9IHt9O1xuICB2YXIgd2FybmVkRm9yTmFOVmFsdWUgPSBmYWxzZTtcbiAgdmFyIHdhcm5lZEZvckluZmluaXR5VmFsdWUgPSBmYWxzZTtcblxuICB2YXIgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSwgZ2V0U3RhY2spIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ1Vuc3VwcG9ydGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JXMnLCBuYW1lLCBjYW1lbGl6ZVN0eWxlTmFtZShuYW1lKSwgZ2V0U3RhY2soKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBnZXRTdGFjaykge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnVW5zdXBwb3J0ZWQgdmVuZG9yLXByZWZpeGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JXMnLCBuYW1lLCBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSwgZ2V0U3RhY2soKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgZ2V0U3RhY2spIHtcbiAgICBpZiAod2FybmVkU3R5bGVWYWx1ZXMuaGFzT3duUHJvcGVydHkodmFsdWUpICYmIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgXCJTdHlsZSBwcm9wZXJ0eSB2YWx1ZXMgc2hvdWxkbid0IGNvbnRhaW4gYSBzZW1pY29sb24uIFwiICsgJ1RyeSBcIiVzOiAlc1wiIGluc3RlYWQuJXMnLCBuYW1lLCB2YWx1ZS5yZXBsYWNlKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiwgJycpLCBnZXRTdGFjaygpKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc05hTiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgZ2V0U3RhY2spIHtcbiAgICBpZiAod2FybmVkRm9yTmFOVmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRGb3JOYU5WYWx1ZSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ2BOYU5gIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS4lcycsIG5hbWUsIGdldFN0YWNrKCkpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHkgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKHdhcm5lZEZvckluZmluaXR5VmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnYEluZmluaXR5YCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJXMnLCBuYW1lLCBnZXRTdGFjaygpKTtcbiAgfTtcblxuICB3YXJuVmFsaWRTdHlsZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgZ2V0U3RhY2spIHtcbiAgICBpZiAobmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUobmFtZSwgZ2V0U3RhY2spO1xuICAgIH0gZWxzZSBpZiAoYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuLnRlc3QobmFtZSkpIHtcbiAgICAgIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZShuYW1lLCBnZXRTdGFjayk7XG4gICAgfSBlbHNlIGlmIChiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbihuYW1lLCB2YWx1ZSwgZ2V0U3RhY2spO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIHdhcm5TdHlsZVZhbHVlSXNOYU4obmFtZSwgdmFsdWUsIGdldFN0YWNrKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICB3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHkobmFtZSwgdmFsdWUsIGdldFN0YWNrKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbnZhciB3YXJuVmFsaWRTdHlsZSQxID0gd2FyblZhbGlkU3R5bGU7XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIENTUyBwcm9wZXJ0aWVzLlxuICovXG5cbi8qKlxuICogVGhpcyBjcmVhdGVzIGEgc3RyaW5nIHRoYXQgaXMgZXhwZWN0ZWQgdG8gYmUgZXF1aXZhbGVudCB0byB0aGUgc3R5bGVcbiAqIGF0dHJpYnV0ZSBnZW5lcmF0ZWQgYnkgc2VydmVyLXNpZGUgcmVuZGVyaW5nLiBJdCBieS1wYXNzZXMgd2FybmluZ3MgYW5kXG4gKiBzZWN1cml0eSBjaGVja3Mgc28gaXQncyBub3Qgc2FmZSB0byB1c2UgdGhpcyB2YWx1ZSBmb3IgYW55dGhpbmcgb3RoZXIgdGhhblxuICogY29tcGFyaXNvbi4gSXQgaXMgb25seSB1c2VkIGluIERFViBmb3IgU1NSIHZhbGlkYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURhbmdlcm91c1N0cmluZ0ZvclN0eWxlcyhzdHlsZXMpIHtcbiAge1xuICAgIHZhciBzZXJpYWxpemVkID0gJyc7XG4gICAgdmFyIGRlbGltaXRlciA9ICcnO1xuICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGVWYWx1ZSA9IHN0eWxlc1tzdHlsZU5hbWVdO1xuICAgICAgaWYgKHN0eWxlVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICB2YXIgaXNDdXN0b21Qcm9wZXJ0eSA9IHN0eWxlTmFtZS5pbmRleE9mKCctLScpID09PSAwO1xuICAgICAgICBzZXJpYWxpemVkICs9IGRlbGltaXRlciArIGh5cGhlbmF0ZVN0eWxlTmFtZShzdHlsZU5hbWUpICsgJzonO1xuICAgICAgICBzZXJpYWxpemVkICs9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlLCBpc0N1c3RvbVByb3BlcnR5KTtcblxuICAgICAgICBkZWxpbWl0ZXIgPSAnOyc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkIHx8IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBmb3IgbXVsdGlwbGUgc3R5bGVzIG9uIGEgbm9kZS4gIElmIGEgdmFsdWUgaXMgc3BlY2lmaWVkIGFzXG4gKiAnJyAoZW1wdHkgc3RyaW5nKSwgdGhlIGNvcnJlc3BvbmRpbmcgc3R5bGUgcHJvcGVydHkgd2lsbCBiZSB1bnNldC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcbiAqL1xuZnVuY3Rpb24gc2V0VmFsdWVGb3JTdHlsZXMobm9kZSwgc3R5bGVzLCBnZXRTdGFjaykge1xuICB2YXIgc3R5bGUgPSBub2RlLnN0eWxlO1xuICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBpc0N1c3RvbVByb3BlcnR5ID0gc3R5bGVOYW1lLmluZGV4T2YoJy0tJykgPT09IDA7XG4gICAge1xuICAgICAgaWYgKCFpc0N1c3RvbVByb3BlcnR5KSB7XG4gICAgICAgIHdhcm5WYWxpZFN0eWxlJDEoc3R5bGVOYW1lLCBzdHlsZXNbc3R5bGVOYW1lXSwgZ2V0U3RhY2spO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgc3R5bGVWYWx1ZSA9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZXNbc3R5bGVOYW1lXSwgaXNDdXN0b21Qcm9wZXJ0eSk7XG4gICAgaWYgKHN0eWxlTmFtZSA9PT0gJ2Zsb2F0Jykge1xuICAgICAgc3R5bGVOYW1lID0gJ2Nzc0Zsb2F0JztcbiAgICB9XG4gICAgaWYgKGlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgICAgIHN0eWxlLnNldFByb3BlcnR5KHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlW3N0eWxlTmFtZV0gPSBzdHlsZVZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIHNob3VsZCBvbWl0IHRoZWlyIGNsb3NlIHRhZy4gV2Uga2VlcCBhIHdoaXRlbGlzdCBmb3Jcbi8vIHRob3NlIHNwZWNpYWwtY2FzZSB0YWdzLlxuXG52YXIgb21pdHRlZENsb3NlVGFncyA9IHtcbiAgYXJlYTogdHJ1ZSxcbiAgYmFzZTogdHJ1ZSxcbiAgYnI6IHRydWUsXG4gIGNvbDogdHJ1ZSxcbiAgZW1iZWQ6IHRydWUsXG4gIGhyOiB0cnVlLFxuICBpbWc6IHRydWUsXG4gIGlucHV0OiB0cnVlLFxuICBrZXlnZW46IHRydWUsXG4gIGxpbms6IHRydWUsXG4gIG1ldGE6IHRydWUsXG4gIHBhcmFtOiB0cnVlLFxuICBzb3VyY2U6IHRydWUsXG4gIHRyYWNrOiB0cnVlLFxuICB3YnI6IHRydWVcbn07XG5cbi8vIEZvciBIVE1MLCBjZXJ0YWluIHRhZ3MgY2Fubm90IGhhdmUgY2hpbGRyZW4uIFRoaXMgaGFzIHRoZSBzYW1lIHB1cnBvc2UgYXNcbi8vIGBvbWl0dGVkQ2xvc2VUYWdzYCBleGNlcHQgdGhhdCBgbWVudWl0ZW1gIHNob3VsZCBzdGlsbCBoYXZlIGl0cyBjbG9zaW5nIHRhZy5cblxudmFyIHZvaWRFbGVtZW50VGFncyA9IF9hc3NpZ24oe1xuICBtZW51aXRlbTogdHJ1ZVxufSwgb21pdHRlZENsb3NlVGFncyk7XG5cbnZhciBIVE1MJDEgPSAnX19odG1sJztcblxuZnVuY3Rpb24gYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHByb3BzLCBnZXRTdGFjaykge1xuICBpZiAoIXByb3BzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIE5vdGUgdGhlIHVzZSBvZiBgPT1gIHdoaWNoIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWQuXG4gIGlmICh2b2lkRWxlbWVudFRhZ3NbdGFnXSkge1xuICAgICEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJyVzIGlzIGEgdm9pZCBlbGVtZW50IHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgdXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJXMnLCB0YWcsIGdldFN0YWNrKCkpIDogdm9pZCAwO1xuICB9XG4gIGlmIChwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPSBudWxsKSB7XG4gICAgIShwcm9wcy5jaGlsZHJlbiA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0NhbiBvbmx5IHNldCBvbmUgb2YgYGNoaWxkcmVuYCBvciBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpIDogdm9pZCAwO1xuICAgICEodHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09PSAnb2JqZWN0JyAmJiBIVE1MJDEgaW4gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpID8gaW52YXJpYW50KGZhbHNlLCAnYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vZmIubWUvcmVhY3QtaW52YXJpYW50LWRhbmdlcm91c2x5LXNldC1pbm5lci1odG1sIGZvciBtb3JlIGluZm9ybWF0aW9uLicpIDogdm9pZCAwO1xuICB9XG4gIHtcbiAgICB3YXJuaW5nKHByb3BzLnN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyB8fCAhcHJvcHMuY29udGVudEVkaXRhYmxlIHx8IHByb3BzLmNoaWxkcmVuID09IG51bGwsICdBIGNvbXBvbmVudCBpcyBgY29udGVudEVkaXRhYmxlYCBhbmQgY29udGFpbnMgYGNoaWxkcmVuYCBtYW5hZ2VkIGJ5ICcgKyAnUmVhY3QuIEl0IGlzIG5vdyB5b3VyIHJlc3BvbnNpYmlsaXR5IHRvIGd1YXJhbnRlZSB0aGF0IG5vbmUgb2YgJyArICd0aG9zZSBub2RlcyBhcmUgdW5leHBlY3RlZGx5IG1vZGlmaWVkIG9yIGR1cGxpY2F0ZWQuIFRoaXMgaXMgJyArICdwcm9iYWJseSBub3QgaW50ZW50aW9uYWwuJXMnLCBnZXRTdGFjaygpKTtcbiAgfVxuICAhKHByb3BzLnN0eWxlID09IG51bGwgfHwgdHlwZW9mIHByb3BzLnN0eWxlID09PSAnb2JqZWN0JykgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGUgYHN0eWxlYCBwcm9wIGV4cGVjdHMgYSBtYXBwaW5nIGZyb20gc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMsIG5vdCBhIHN0cmluZy4gRm9yIGV4YW1wbGUsIHN0eWxlPXt7bWFyZ2luUmlnaHQ6IHNwYWNpbmcgKyBcXCdlbVxcJ319IHdoZW4gdXNpbmcgSlNYLiVzJywgZ2V0U3RhY2soKSkgOiB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIGlzQ3VzdG9tQ29tcG9uZW50KHRhZ05hbWUsIHByb3BzKSB7XG4gIGlmICh0YWdOYW1lLmluZGV4T2YoJy0nKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gdHlwZW9mIHByb3BzLmlzID09PSAnc3RyaW5nJztcbiAgfVxuICBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICAvLyBUaGVzZSBhcmUgcmVzZXJ2ZWQgU1ZHIGFuZCBNYXRoTUwgZWxlbWVudHMuXG4gICAgLy8gV2UgZG9uJ3QgbWluZCB0aGlzIHdoaXRlbGlzdCB0b28gbXVjaCBiZWNhdXNlIHdlIGV4cGVjdCBpdCB0byBuZXZlciBncm93LlxuICAgIC8vIFRoZSBhbHRlcm5hdGl2ZSBpcyB0byB0cmFjayB0aGUgbmFtZXNwYWNlIGluIGEgZmV3IHBsYWNlcyB3aGljaCBpcyBjb252b2x1dGVkLlxuICAgIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJjb21wb25lbnRzL3NwZWMvY3VzdG9tLyNjdXN0b20tZWxlbWVudHMtY29yZS1jb25jZXB0c1xuICAgIGNhc2UgJ2Fubm90YXRpb24teG1sJzpcbiAgICBjYXNlICdjb2xvci1wcm9maWxlJzpcbiAgICBjYXNlICdmb250LWZhY2UnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1zcmMnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS11cmknOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1mb3JtYXQnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1uYW1lJzpcbiAgICBjYXNlICdtaXNzaW5nLWdseXBoJzpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxudmFyIGFyaWFQcm9wZXJ0aWVzID0ge1xuICAnYXJpYS1jdXJyZW50JzogMCwgLy8gc3RhdGVcbiAgJ2FyaWEtZGV0YWlscyc6IDAsXG4gICdhcmlhLWRpc2FibGVkJzogMCwgLy8gc3RhdGVcbiAgJ2FyaWEtaGlkZGVuJzogMCwgLy8gc3RhdGVcbiAgJ2FyaWEtaW52YWxpZCc6IDAsIC8vIHN0YXRlXG4gICdhcmlhLWtleXNob3J0Y3V0cyc6IDAsXG4gICdhcmlhLWxhYmVsJzogMCxcbiAgJ2FyaWEtcm9sZWRlc2NyaXB0aW9uJzogMCxcbiAgLy8gV2lkZ2V0IEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYXV0b2NvbXBsZXRlJzogMCxcbiAgJ2FyaWEtY2hlY2tlZCc6IDAsXG4gICdhcmlhLWV4cGFuZGVkJzogMCxcbiAgJ2FyaWEtaGFzcG9wdXAnOiAwLFxuICAnYXJpYS1sZXZlbCc6IDAsXG4gICdhcmlhLW1vZGFsJzogMCxcbiAgJ2FyaWEtbXVsdGlsaW5lJzogMCxcbiAgJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJzogMCxcbiAgJ2FyaWEtb3JpZW50YXRpb24nOiAwLFxuICAnYXJpYS1wbGFjZWhvbGRlcic6IDAsXG4gICdhcmlhLXByZXNzZWQnOiAwLFxuICAnYXJpYS1yZWFkb25seSc6IDAsXG4gICdhcmlhLXJlcXVpcmVkJzogMCxcbiAgJ2FyaWEtc2VsZWN0ZWQnOiAwLFxuICAnYXJpYS1zb3J0JzogMCxcbiAgJ2FyaWEtdmFsdWVtYXgnOiAwLFxuICAnYXJpYS12YWx1ZW1pbic6IDAsXG4gICdhcmlhLXZhbHVlbm93JzogMCxcbiAgJ2FyaWEtdmFsdWV0ZXh0JzogMCxcbiAgLy8gTGl2ZSBSZWdpb24gQXR0cmlidXRlc1xuICAnYXJpYS1hdG9taWMnOiAwLFxuICAnYXJpYS1idXN5JzogMCxcbiAgJ2FyaWEtbGl2ZSc6IDAsXG4gICdhcmlhLXJlbGV2YW50JzogMCxcbiAgLy8gRHJhZy1hbmQtRHJvcCBBdHRyaWJ1dGVzXG4gICdhcmlhLWRyb3BlZmZlY3QnOiAwLFxuICAnYXJpYS1ncmFiYmVkJzogMCxcbiAgLy8gUmVsYXRpb25zaGlwIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCc6IDAsXG4gICdhcmlhLWNvbGNvdW50JzogMCxcbiAgJ2FyaWEtY29saW5kZXgnOiAwLFxuICAnYXJpYS1jb2xzcGFuJzogMCxcbiAgJ2FyaWEtY29udHJvbHMnOiAwLFxuICAnYXJpYS1kZXNjcmliZWRieSc6IDAsXG4gICdhcmlhLWVycm9ybWVzc2FnZSc6IDAsXG4gICdhcmlhLWZsb3d0byc6IDAsXG4gICdhcmlhLWxhYmVsbGVkYnknOiAwLFxuICAnYXJpYS1vd25zJzogMCxcbiAgJ2FyaWEtcG9zaW5zZXQnOiAwLFxuICAnYXJpYS1yb3djb3VudCc6IDAsXG4gICdhcmlhLXJvd2luZGV4JzogMCxcbiAgJ2FyaWEtcm93c3Bhbic6IDAsXG4gICdhcmlhLXNldHNpemUnOiAwXG59O1xuXG52YXIgd2FybmVkUHJvcGVydGllcyA9IHt9O1xudmFyIHJBUklBID0gbmV3IFJlZ0V4cCgnXihhcmlhKS1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG52YXIgckFSSUFDYW1lbCA9IG5ldyBSZWdFeHAoJ14oYXJpYSlbQS1aXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gZ2V0U3RhY2tBZGRlbmR1bSgpIHtcbiAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gIHJldHVybiBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eSh0YWdOYW1lLCBuYW1lKSB7XG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFByb3BlcnRpZXMsIG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChyQVJJQUNhbWVsLnRlc3QobmFtZSkpIHtcbiAgICB2YXIgYXJpYU5hbWUgPSAnYXJpYS0nICsgbmFtZS5zbGljZSg0KS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBjb3JyZWN0TmFtZSA9IGFyaWFQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGFyaWFOYW1lKSA/IGFyaWFOYW1lIDogbnVsbDtcblxuICAgIC8vIElmIHRoaXMgaXMgYW4gYXJpYS0qIGF0dHJpYnV0ZSwgYnV0IGlzIG5vdCBsaXN0ZWQgaW4gdGhlIGtub3duIERPTVxuICAgIC8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cbiAgICBpZiAoY29ycmVjdE5hbWUgPT0gbnVsbCkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gQVJJQSBhdHRyaWJ1dGVzIGZvbGxvdyB0aGUgcGF0dGVybiBhcmlhLSogYW5kIG11c3QgYmUgbG93ZXJjYXNlLiVzJywgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuICAgIGlmIChuYW1lICE9PSBjb3JyZWN0TmFtZSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JXMnLCBuYW1lLCBjb3JyZWN0TmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJBUklBLnRlc3QobmFtZSkpIHtcbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHN0YW5kYXJkTmFtZSA9IGFyaWFQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IGxvd2VyQ2FzZWROYW1lIDogbnVsbDtcblxuICAgIC8vIElmIHRoaXMgaXMgYW4gYXJpYS0qIGF0dHJpYnV0ZSwgYnV0IGlzIG5vdCBsaXN0ZWQgaW4gdGhlIGtub3duIERPTVxuICAgIC8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cbiAgICBpZiAoc3RhbmRhcmROYW1lID09IG51bGwpIHtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBhcmlhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvbi5cbiAgICBpZiAobmFtZSAhPT0gc3RhbmRhcmROYW1lKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVW5rbm93biBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8lcycsIG5hbWUsIHN0YW5kYXJkTmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHdhcm5JbnZhbGlkQVJJQVByb3BzKHR5cGUsIHByb3BzKSB7XG4gIHZhciBpbnZhbGlkUHJvcHMgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICB2YXIgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkodHlwZSwga2V5KTtcbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIGludmFsaWRQcm9wcy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVua25vd25Qcm9wU3RyaW5nID0gaW52YWxpZFByb3BzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICB9KS5qb2luKCcsICcpO1xuXG4gIGlmIChpbnZhbGlkUHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJpYSBwcm9wICVzIG9uIDwlcz4gdGFnLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9pbnZhbGlkLWFyaWEtcHJvcCVzJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gIH0gZWxzZSBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA+IDEpIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmlhIHByb3BzICVzIG9uIDwlcz4gdGFnLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9pbnZhbGlkLWFyaWEtcHJvcCVzJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzKHR5cGUsIHByb3BzKSB7XG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2FybkludmFsaWRBUklBUHJvcHModHlwZSwgcHJvcHMpO1xufVxuXG52YXIgZGlkV2FyblZhbHVlTnVsbCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBnZXRTdGFja0FkZGVuZHVtJDEoKSB7XG4gIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuICByZXR1cm4gc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJyc7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyQxKHR5cGUsIHByb3BzKSB7XG4gIGlmICh0eXBlICE9PSAnaW5wdXQnICYmIHR5cGUgIT09ICd0ZXh0YXJlYScgJiYgdHlwZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAocHJvcHMgIT0gbnVsbCAmJiBwcm9wcy52YWx1ZSA9PT0gbnVsbCAmJiAhZGlkV2FyblZhbHVlTnVsbCkge1xuICAgIGRpZFdhcm5WYWx1ZU51bGwgPSB0cnVlO1xuICAgIGlmICh0eXBlID09PSAnc2VsZWN0JyAmJiBwcm9wcy5tdWx0aXBsZSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJyArICdDb25zaWRlciB1c2luZyBhbiBlbXB0eSBhcnJheSB3aGVuIGBtdWx0aXBsZWAgaXMgc2V0IHRvIGB0cnVlYCAnICsgJ3RvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLiVzJywgdHlwZSwgZ2V0U3RhY2tBZGRlbmR1bSQxKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IHN0cmluZyB0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgICcgKyAnZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLiVzJywgdHlwZSwgZ2V0U3RhY2tBZGRlbmR1bSQxKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoZSBIVE1MIG9yIFNWRyB3aGl0ZWxpc3QsIGJlIHN1cmUgdG9cbi8vIGFsc28gYWRkIHRoZW0gdG8gdGhpcyBtb2R1bGUgdG8gZW5zdXJlIGNhc2luZyBhbmQgaW5jb3JyZWN0IG5hbWVcbi8vIHdhcm5pbmdzLlxudmFyIHBvc3NpYmxlU3RhbmRhcmROYW1lcyA9IHtcbiAgLy8gSFRNTFxuICBhY2NlcHQ6ICdhY2NlcHQnLFxuICBhY2NlcHRjaGFyc2V0OiAnYWNjZXB0Q2hhcnNldCcsXG4gICdhY2NlcHQtY2hhcnNldCc6ICdhY2NlcHRDaGFyc2V0JyxcbiAgYWNjZXNza2V5OiAnYWNjZXNzS2V5JyxcbiAgYWN0aW9uOiAnYWN0aW9uJyxcbiAgYWxsb3dmdWxsc2NyZWVuOiAnYWxsb3dGdWxsU2NyZWVuJyxcbiAgYWx0OiAnYWx0JyxcbiAgYXM6ICdhcycsXG4gIGFzeW5jOiAnYXN5bmMnLFxuICBhdXRvY2FwaXRhbGl6ZTogJ2F1dG9DYXBpdGFsaXplJyxcbiAgYXV0b2NvbXBsZXRlOiAnYXV0b0NvbXBsZXRlJyxcbiAgYXV0b2NvcnJlY3Q6ICdhdXRvQ29ycmVjdCcsXG4gIGF1dG9mb2N1czogJ2F1dG9Gb2N1cycsXG4gIGF1dG9wbGF5OiAnYXV0b1BsYXknLFxuICBhdXRvc2F2ZTogJ2F1dG9TYXZlJyxcbiAgY2FwdHVyZTogJ2NhcHR1cmUnLFxuICBjZWxscGFkZGluZzogJ2NlbGxQYWRkaW5nJyxcbiAgY2VsbHNwYWNpbmc6ICdjZWxsU3BhY2luZycsXG4gIGNoYWxsZW5nZTogJ2NoYWxsZW5nZScsXG4gIGNoYXJzZXQ6ICdjaGFyU2V0JyxcbiAgY2hlY2tlZDogJ2NoZWNrZWQnLFxuICBjaGlsZHJlbjogJ2NoaWxkcmVuJyxcbiAgY2l0ZTogJ2NpdGUnLFxuICAnY2xhc3MnOiAnY2xhc3NOYW1lJyxcbiAgY2xhc3NpZDogJ2NsYXNzSUQnLFxuICBjbGFzc25hbWU6ICdjbGFzc05hbWUnLFxuICBjb2xzOiAnY29scycsXG4gIGNvbHNwYW46ICdjb2xTcGFuJyxcbiAgY29udGVudDogJ2NvbnRlbnQnLFxuICBjb250ZW50ZWRpdGFibGU6ICdjb250ZW50RWRpdGFibGUnLFxuICBjb250ZXh0bWVudTogJ2NvbnRleHRNZW51JyxcbiAgY29udHJvbHM6ICdjb250cm9scycsXG4gIGNvbnRyb2xzbGlzdDogJ2NvbnRyb2xzTGlzdCcsXG4gIGNvb3JkczogJ2Nvb3JkcycsXG4gIGNyb3Nzb3JpZ2luOiAnY3Jvc3NPcmlnaW4nLFxuICBkYW5nZXJvdXNseXNldGlubmVyaHRtbDogJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJyxcbiAgZGF0YTogJ2RhdGEnLFxuICBkYXRldGltZTogJ2RhdGVUaW1lJyxcbiAgJ2RlZmF1bHQnOiAnZGVmYXVsdCcsXG4gIGRlZmF1bHRjaGVja2VkOiAnZGVmYXVsdENoZWNrZWQnLFxuICBkZWZhdWx0dmFsdWU6ICdkZWZhdWx0VmFsdWUnLFxuICBkZWZlcjogJ2RlZmVyJyxcbiAgZGlyOiAnZGlyJyxcbiAgZGlzYWJsZWQ6ICdkaXNhYmxlZCcsXG4gIGRvd25sb2FkOiAnZG93bmxvYWQnLFxuICBkcmFnZ2FibGU6ICdkcmFnZ2FibGUnLFxuICBlbmN0eXBlOiAnZW5jVHlwZScsXG4gICdmb3InOiAnaHRtbEZvcicsXG4gIGZvcm06ICdmb3JtJyxcbiAgZm9ybW1ldGhvZDogJ2Zvcm1NZXRob2QnLFxuICBmb3JtYWN0aW9uOiAnZm9ybUFjdGlvbicsXG4gIGZvcm1lbmN0eXBlOiAnZm9ybUVuY1R5cGUnLFxuICBmb3Jtbm92YWxpZGF0ZTogJ2Zvcm1Ob1ZhbGlkYXRlJyxcbiAgZm9ybXRhcmdldDogJ2Zvcm1UYXJnZXQnLFxuICBmcmFtZWJvcmRlcjogJ2ZyYW1lQm9yZGVyJyxcbiAgaGVhZGVyczogJ2hlYWRlcnMnLFxuICBoZWlnaHQ6ICdoZWlnaHQnLFxuICBoaWRkZW46ICdoaWRkZW4nLFxuICBoaWdoOiAnaGlnaCcsXG4gIGhyZWY6ICdocmVmJyxcbiAgaHJlZmxhbmc6ICdocmVmTGFuZycsXG4gIGh0bWxmb3I6ICdodG1sRm9yJyxcbiAgaHR0cGVxdWl2OiAnaHR0cEVxdWl2JyxcbiAgJ2h0dHAtZXF1aXYnOiAnaHR0cEVxdWl2JyxcbiAgaWNvbjogJ2ljb24nLFxuICBpZDogJ2lkJyxcbiAgaW5uZXJodG1sOiAnaW5uZXJIVE1MJyxcbiAgaW5wdXRtb2RlOiAnaW5wdXRNb2RlJyxcbiAgaW50ZWdyaXR5OiAnaW50ZWdyaXR5JyxcbiAgaXM6ICdpcycsXG4gIGl0ZW1pZDogJ2l0ZW1JRCcsXG4gIGl0ZW1wcm9wOiAnaXRlbVByb3AnLFxuICBpdGVtcmVmOiAnaXRlbVJlZicsXG4gIGl0ZW1zY29wZTogJ2l0ZW1TY29wZScsXG4gIGl0ZW10eXBlOiAnaXRlbVR5cGUnLFxuICBrZXlwYXJhbXM6ICdrZXlQYXJhbXMnLFxuICBrZXl0eXBlOiAna2V5VHlwZScsXG4gIGtpbmQ6ICdraW5kJyxcbiAgbGFiZWw6ICdsYWJlbCcsXG4gIGxhbmc6ICdsYW5nJyxcbiAgbGlzdDogJ2xpc3QnLFxuICBsb29wOiAnbG9vcCcsXG4gIGxvdzogJ2xvdycsXG4gIG1hbmlmZXN0OiAnbWFuaWZlc3QnLFxuICBtYXJnaW53aWR0aDogJ21hcmdpbldpZHRoJyxcbiAgbWFyZ2luaGVpZ2h0OiAnbWFyZ2luSGVpZ2h0JyxcbiAgbWF4OiAnbWF4JyxcbiAgbWF4bGVuZ3RoOiAnbWF4TGVuZ3RoJyxcbiAgbWVkaWE6ICdtZWRpYScsXG4gIG1lZGlhZ3JvdXA6ICdtZWRpYUdyb3VwJyxcbiAgbWV0aG9kOiAnbWV0aG9kJyxcbiAgbWluOiAnbWluJyxcbiAgbWlubGVuZ3RoOiAnbWluTGVuZ3RoJyxcbiAgbXVsdGlwbGU6ICdtdWx0aXBsZScsXG4gIG11dGVkOiAnbXV0ZWQnLFxuICBuYW1lOiAnbmFtZScsXG4gIG5vbmNlOiAnbm9uY2UnLFxuICBub3ZhbGlkYXRlOiAnbm9WYWxpZGF0ZScsXG4gIG9wZW46ICdvcGVuJyxcbiAgb3B0aW11bTogJ29wdGltdW0nLFxuICBwYXR0ZXJuOiAncGF0dGVybicsXG4gIHBsYWNlaG9sZGVyOiAncGxhY2Vob2xkZXInLFxuICBwbGF5c2lubGluZTogJ3BsYXlzSW5saW5lJyxcbiAgcG9zdGVyOiAncG9zdGVyJyxcbiAgcHJlbG9hZDogJ3ByZWxvYWQnLFxuICBwcm9maWxlOiAncHJvZmlsZScsXG4gIHJhZGlvZ3JvdXA6ICdyYWRpb0dyb3VwJyxcbiAgcmVhZG9ubHk6ICdyZWFkT25seScsXG4gIHJlZmVycmVycG9saWN5OiAncmVmZXJyZXJQb2xpY3knLFxuICByZWw6ICdyZWwnLFxuICByZXF1aXJlZDogJ3JlcXVpcmVkJyxcbiAgcmV2ZXJzZWQ6ICdyZXZlcnNlZCcsXG4gIHJvbGU6ICdyb2xlJyxcbiAgcm93czogJ3Jvd3MnLFxuICByb3dzcGFuOiAncm93U3BhbicsXG4gIHNhbmRib3g6ICdzYW5kYm94JyxcbiAgc2NvcGU6ICdzY29wZScsXG4gIHNjb3BlZDogJ3Njb3BlZCcsXG4gIHNjcm9sbGluZzogJ3Njcm9sbGluZycsXG4gIHNlYW1sZXNzOiAnc2VhbWxlc3MnLFxuICBzZWxlY3RlZDogJ3NlbGVjdGVkJyxcbiAgc2hhcGU6ICdzaGFwZScsXG4gIHNpemU6ICdzaXplJyxcbiAgc2l6ZXM6ICdzaXplcycsXG4gIHNwYW46ICdzcGFuJyxcbiAgc3BlbGxjaGVjazogJ3NwZWxsQ2hlY2snLFxuICBzcmM6ICdzcmMnLFxuICBzcmNkb2M6ICdzcmNEb2MnLFxuICBzcmNsYW5nOiAnc3JjTGFuZycsXG4gIHNyY3NldDogJ3NyY1NldCcsXG4gIHN0YXJ0OiAnc3RhcnQnLFxuICBzdGVwOiAnc3RlcCcsXG4gIHN0eWxlOiAnc3R5bGUnLFxuICBzdW1tYXJ5OiAnc3VtbWFyeScsXG4gIHRhYmluZGV4OiAndGFiSW5kZXgnLFxuICB0YXJnZXQ6ICd0YXJnZXQnLFxuICB0aXRsZTogJ3RpdGxlJyxcbiAgdHlwZTogJ3R5cGUnLFxuICB1c2VtYXA6ICd1c2VNYXAnLFxuICB2YWx1ZTogJ3ZhbHVlJyxcbiAgd2lkdGg6ICd3aWR0aCcsXG4gIHdtb2RlOiAnd21vZGUnLFxuICB3cmFwOiAnd3JhcCcsXG5cbiAgLy8gU1ZHXG4gIGFib3V0OiAnYWJvdXQnLFxuICBhY2NlbnRoZWlnaHQ6ICdhY2NlbnRIZWlnaHQnLFxuICAnYWNjZW50LWhlaWdodCc6ICdhY2NlbnRIZWlnaHQnLFxuICBhY2N1bXVsYXRlOiAnYWNjdW11bGF0ZScsXG4gIGFkZGl0aXZlOiAnYWRkaXRpdmUnLFxuICBhbGlnbm1lbnRiYXNlbGluZTogJ2FsaWdubWVudEJhc2VsaW5lJyxcbiAgJ2FsaWdubWVudC1iYXNlbGluZSc6ICdhbGlnbm1lbnRCYXNlbGluZScsXG4gIGFsbG93cmVvcmRlcjogJ2FsbG93UmVvcmRlcicsXG4gIGFscGhhYmV0aWM6ICdhbHBoYWJldGljJyxcbiAgYW1wbGl0dWRlOiAnYW1wbGl0dWRlJyxcbiAgYXJhYmljZm9ybTogJ2FyYWJpY0Zvcm0nLFxuICAnYXJhYmljLWZvcm0nOiAnYXJhYmljRm9ybScsXG4gIGFzY2VudDogJ2FzY2VudCcsXG4gIGF0dHJpYnV0ZW5hbWU6ICdhdHRyaWJ1dGVOYW1lJyxcbiAgYXR0cmlidXRldHlwZTogJ2F0dHJpYnV0ZVR5cGUnLFxuICBhdXRvcmV2ZXJzZTogJ2F1dG9SZXZlcnNlJyxcbiAgYXppbXV0aDogJ2F6aW11dGgnLFxuICBiYXNlZnJlcXVlbmN5OiAnYmFzZUZyZXF1ZW5jeScsXG4gIGJhc2VsaW5lc2hpZnQ6ICdiYXNlbGluZVNoaWZ0JyxcbiAgJ2Jhc2VsaW5lLXNoaWZ0JzogJ2Jhc2VsaW5lU2hpZnQnLFxuICBiYXNlcHJvZmlsZTogJ2Jhc2VQcm9maWxlJyxcbiAgYmJveDogJ2Jib3gnLFxuICBiZWdpbjogJ2JlZ2luJyxcbiAgYmlhczogJ2JpYXMnLFxuICBieTogJ2J5JyxcbiAgY2FsY21vZGU6ICdjYWxjTW9kZScsXG4gIGNhcGhlaWdodDogJ2NhcEhlaWdodCcsXG4gICdjYXAtaGVpZ2h0JzogJ2NhcEhlaWdodCcsXG4gIGNsaXA6ICdjbGlwJyxcbiAgY2xpcHBhdGg6ICdjbGlwUGF0aCcsXG4gICdjbGlwLXBhdGgnOiAnY2xpcFBhdGgnLFxuICBjbGlwcGF0aHVuaXRzOiAnY2xpcFBhdGhVbml0cycsXG4gIGNsaXBydWxlOiAnY2xpcFJ1bGUnLFxuICAnY2xpcC1ydWxlJzogJ2NsaXBSdWxlJyxcbiAgY29sb3I6ICdjb2xvcicsXG4gIGNvbG9yaW50ZXJwb2xhdGlvbjogJ2NvbG9ySW50ZXJwb2xhdGlvbicsXG4gICdjb2xvci1pbnRlcnBvbGF0aW9uJzogJ2NvbG9ySW50ZXJwb2xhdGlvbicsXG4gIGNvbG9yaW50ZXJwb2xhdGlvbmZpbHRlcnM6ICdjb2xvckludGVycG9sYXRpb25GaWx0ZXJzJyxcbiAgJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyc6ICdjb2xvckludGVycG9sYXRpb25GaWx0ZXJzJyxcbiAgY29sb3Jwcm9maWxlOiAnY29sb3JQcm9maWxlJyxcbiAgJ2NvbG9yLXByb2ZpbGUnOiAnY29sb3JQcm9maWxlJyxcbiAgY29sb3JyZW5kZXJpbmc6ICdjb2xvclJlbmRlcmluZycsXG4gICdjb2xvci1yZW5kZXJpbmcnOiAnY29sb3JSZW5kZXJpbmcnLFxuICBjb250ZW50c2NyaXB0dHlwZTogJ2NvbnRlbnRTY3JpcHRUeXBlJyxcbiAgY29udGVudHN0eWxldHlwZTogJ2NvbnRlbnRTdHlsZVR5cGUnLFxuICBjdXJzb3I6ICdjdXJzb3InLFxuICBjeDogJ2N4JyxcbiAgY3k6ICdjeScsXG4gIGQ6ICdkJyxcbiAgZGF0YXR5cGU6ICdkYXRhdHlwZScsXG4gIGRlY2VsZXJhdGU6ICdkZWNlbGVyYXRlJyxcbiAgZGVzY2VudDogJ2Rlc2NlbnQnLFxuICBkaWZmdXNlY29uc3RhbnQ6ICdkaWZmdXNlQ29uc3RhbnQnLFxuICBkaXJlY3Rpb246ICdkaXJlY3Rpb24nLFxuICBkaXNwbGF5OiAnZGlzcGxheScsXG4gIGRpdmlzb3I6ICdkaXZpc29yJyxcbiAgZG9taW5hbnRiYXNlbGluZTogJ2RvbWluYW50QmFzZWxpbmUnLFxuICAnZG9taW5hbnQtYmFzZWxpbmUnOiAnZG9taW5hbnRCYXNlbGluZScsXG4gIGR1cjogJ2R1cicsXG4gIGR4OiAnZHgnLFxuICBkeTogJ2R5JyxcbiAgZWRnZW1vZGU6ICdlZGdlTW9kZScsXG4gIGVsZXZhdGlvbjogJ2VsZXZhdGlvbicsXG4gIGVuYWJsZWJhY2tncm91bmQ6ICdlbmFibGVCYWNrZ3JvdW5kJyxcbiAgJ2VuYWJsZS1iYWNrZ3JvdW5kJzogJ2VuYWJsZUJhY2tncm91bmQnLFxuICBlbmQ6ICdlbmQnLFxuICBleHBvbmVudDogJ2V4cG9uZW50JyxcbiAgZXh0ZXJuYWxyZXNvdXJjZXNyZXF1aXJlZDogJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLFxuICBmaWxsOiAnZmlsbCcsXG4gIGZpbGxvcGFjaXR5OiAnZmlsbE9wYWNpdHknLFxuICAnZmlsbC1vcGFjaXR5JzogJ2ZpbGxPcGFjaXR5JyxcbiAgZmlsbHJ1bGU6ICdmaWxsUnVsZScsXG4gICdmaWxsLXJ1bGUnOiAnZmlsbFJ1bGUnLFxuICBmaWx0ZXI6ICdmaWx0ZXInLFxuICBmaWx0ZXJyZXM6ICdmaWx0ZXJSZXMnLFxuICBmaWx0ZXJ1bml0czogJ2ZpbHRlclVuaXRzJyxcbiAgZmxvb2RvcGFjaXR5OiAnZmxvb2RPcGFjaXR5JyxcbiAgJ2Zsb29kLW9wYWNpdHknOiAnZmxvb2RPcGFjaXR5JyxcbiAgZmxvb2Rjb2xvcjogJ2Zsb29kQ29sb3InLFxuICAnZmxvb2QtY29sb3InOiAnZmxvb2RDb2xvcicsXG4gIGZvY3VzYWJsZTogJ2ZvY3VzYWJsZScsXG4gIGZvbnRmYW1pbHk6ICdmb250RmFtaWx5JyxcbiAgJ2ZvbnQtZmFtaWx5JzogJ2ZvbnRGYW1pbHknLFxuICBmb250c2l6ZTogJ2ZvbnRTaXplJyxcbiAgJ2ZvbnQtc2l6ZSc6ICdmb250U2l6ZScsXG4gIGZvbnRzaXplYWRqdXN0OiAnZm9udFNpemVBZGp1c3QnLFxuICAnZm9udC1zaXplLWFkanVzdCc6ICdmb250U2l6ZUFkanVzdCcsXG4gIGZvbnRzdHJldGNoOiAnZm9udFN0cmV0Y2gnLFxuICAnZm9udC1zdHJldGNoJzogJ2ZvbnRTdHJldGNoJyxcbiAgZm9udHN0eWxlOiAnZm9udFN0eWxlJyxcbiAgJ2ZvbnQtc3R5bGUnOiAnZm9udFN0eWxlJyxcbiAgZm9udHZhcmlhbnQ6ICdmb250VmFyaWFudCcsXG4gICdmb250LXZhcmlhbnQnOiAnZm9udFZhcmlhbnQnLFxuICBmb250d2VpZ2h0OiAnZm9udFdlaWdodCcsXG4gICdmb250LXdlaWdodCc6ICdmb250V2VpZ2h0JyxcbiAgZm9ybWF0OiAnZm9ybWF0JyxcbiAgZnJvbTogJ2Zyb20nLFxuICBmeDogJ2Z4JyxcbiAgZnk6ICdmeScsXG4gIGcxOiAnZzEnLFxuICBnMjogJ2cyJyxcbiAgZ2x5cGhuYW1lOiAnZ2x5cGhOYW1lJyxcbiAgJ2dseXBoLW5hbWUnOiAnZ2x5cGhOYW1lJyxcbiAgZ2x5cGhvcmllbnRhdGlvbmhvcml6b250YWw6ICdnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsXG4gICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJzogJ2dseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsJyxcbiAgZ2x5cGhvcmllbnRhdGlvbnZlcnRpY2FsOiAnZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsJyxcbiAgJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJzogJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsXG4gIGdseXBocmVmOiAnZ2x5cGhSZWYnLFxuICBncmFkaWVudHRyYW5zZm9ybTogJ2dyYWRpZW50VHJhbnNmb3JtJyxcbiAgZ3JhZGllbnR1bml0czogJ2dyYWRpZW50VW5pdHMnLFxuICBoYW5naW5nOiAnaGFuZ2luZycsXG4gIGhvcml6YWR2eDogJ2hvcml6QWR2WCcsXG4gICdob3Jpei1hZHYteCc6ICdob3JpekFkdlgnLFxuICBob3Jpem9yaWdpbng6ICdob3Jpek9yaWdpblgnLFxuICAnaG9yaXotb3JpZ2luLXgnOiAnaG9yaXpPcmlnaW5YJyxcbiAgaWRlb2dyYXBoaWM6ICdpZGVvZ3JhcGhpYycsXG4gIGltYWdlcmVuZGVyaW5nOiAnaW1hZ2VSZW5kZXJpbmcnLFxuICAnaW1hZ2UtcmVuZGVyaW5nJzogJ2ltYWdlUmVuZGVyaW5nJyxcbiAgaW4yOiAnaW4yJyxcbiAgJ2luJzogJ2luJyxcbiAgaW5saXN0OiAnaW5saXN0JyxcbiAgaW50ZXJjZXB0OiAnaW50ZXJjZXB0JyxcbiAgazE6ICdrMScsXG4gIGsyOiAnazInLFxuICBrMzogJ2szJyxcbiAgazQ6ICdrNCcsXG4gIGs6ICdrJyxcbiAga2VybmVsbWF0cml4OiAna2VybmVsTWF0cml4JyxcbiAga2VybmVsdW5pdGxlbmd0aDogJ2tlcm5lbFVuaXRMZW5ndGgnLFxuICBrZXJuaW5nOiAna2VybmluZycsXG4gIGtleXBvaW50czogJ2tleVBvaW50cycsXG4gIGtleXNwbGluZXM6ICdrZXlTcGxpbmVzJyxcbiAga2V5dGltZXM6ICdrZXlUaW1lcycsXG4gIGxlbmd0aGFkanVzdDogJ2xlbmd0aEFkanVzdCcsXG4gIGxldHRlcnNwYWNpbmc6ICdsZXR0ZXJTcGFjaW5nJyxcbiAgJ2xldHRlci1zcGFjaW5nJzogJ2xldHRlclNwYWNpbmcnLFxuICBsaWdodGluZ2NvbG9yOiAnbGlnaHRpbmdDb2xvcicsXG4gICdsaWdodGluZy1jb2xvcic6ICdsaWdodGluZ0NvbG9yJyxcbiAgbGltaXRpbmdjb25lYW5nbGU6ICdsaW1pdGluZ0NvbmVBbmdsZScsXG4gIGxvY2FsOiAnbG9jYWwnLFxuICBtYXJrZXJlbmQ6ICdtYXJrZXJFbmQnLFxuICAnbWFya2VyLWVuZCc6ICdtYXJrZXJFbmQnLFxuICBtYXJrZXJoZWlnaHQ6ICdtYXJrZXJIZWlnaHQnLFxuICBtYXJrZXJtaWQ6ICdtYXJrZXJNaWQnLFxuICAnbWFya2VyLW1pZCc6ICdtYXJrZXJNaWQnLFxuICBtYXJrZXJzdGFydDogJ21hcmtlclN0YXJ0JyxcbiAgJ21hcmtlci1zdGFydCc6ICdtYXJrZXJTdGFydCcsXG4gIG1hcmtlcnVuaXRzOiAnbWFya2VyVW5pdHMnLFxuICBtYXJrZXJ3aWR0aDogJ21hcmtlcldpZHRoJyxcbiAgbWFzazogJ21hc2snLFxuICBtYXNrY29udGVudHVuaXRzOiAnbWFza0NvbnRlbnRVbml0cycsXG4gIG1hc2t1bml0czogJ21hc2tVbml0cycsXG4gIG1hdGhlbWF0aWNhbDogJ21hdGhlbWF0aWNhbCcsXG4gIG1vZGU6ICdtb2RlJyxcbiAgbnVtb2N0YXZlczogJ251bU9jdGF2ZXMnLFxuICBvZmZzZXQ6ICdvZmZzZXQnLFxuICBvcGFjaXR5OiAnb3BhY2l0eScsXG4gIG9wZXJhdG9yOiAnb3BlcmF0b3InLFxuICBvcmRlcjogJ29yZGVyJyxcbiAgb3JpZW50OiAnb3JpZW50JyxcbiAgb3JpZW50YXRpb246ICdvcmllbnRhdGlvbicsXG4gIG9yaWdpbjogJ29yaWdpbicsXG4gIG92ZXJmbG93OiAnb3ZlcmZsb3cnLFxuICBvdmVybGluZXBvc2l0aW9uOiAnb3ZlcmxpbmVQb3NpdGlvbicsXG4gICdvdmVybGluZS1wb3NpdGlvbic6ICdvdmVybGluZVBvc2l0aW9uJyxcbiAgb3ZlcmxpbmV0aGlja25lc3M6ICdvdmVybGluZVRoaWNrbmVzcycsXG4gICdvdmVybGluZS10aGlja25lc3MnOiAnb3ZlcmxpbmVUaGlja25lc3MnLFxuICBwYWludG9yZGVyOiAncGFpbnRPcmRlcicsXG4gICdwYWludC1vcmRlcic6ICdwYWludE9yZGVyJyxcbiAgcGFub3NlMTogJ3Bhbm9zZTEnLFxuICAncGFub3NlLTEnOiAncGFub3NlMScsXG4gIHBhdGhsZW5ndGg6ICdwYXRoTGVuZ3RoJyxcbiAgcGF0dGVybmNvbnRlbnR1bml0czogJ3BhdHRlcm5Db250ZW50VW5pdHMnLFxuICBwYXR0ZXJudHJhbnNmb3JtOiAncGF0dGVyblRyYW5zZm9ybScsXG4gIHBhdHRlcm51bml0czogJ3BhdHRlcm5Vbml0cycsXG4gIHBvaW50ZXJldmVudHM6ICdwb2ludGVyRXZlbnRzJyxcbiAgJ3BvaW50ZXItZXZlbnRzJzogJ3BvaW50ZXJFdmVudHMnLFxuICBwb2ludHM6ICdwb2ludHMnLFxuICBwb2ludHNhdHg6ICdwb2ludHNBdFgnLFxuICBwb2ludHNhdHk6ICdwb2ludHNBdFknLFxuICBwb2ludHNhdHo6ICdwb2ludHNBdFonLFxuICBwcmVmaXg6ICdwcmVmaXgnLFxuICBwcmVzZXJ2ZWFscGhhOiAncHJlc2VydmVBbHBoYScsXG4gIHByZXNlcnZlYXNwZWN0cmF0aW86ICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJyxcbiAgcHJpbWl0aXZldW5pdHM6ICdwcmltaXRpdmVVbml0cycsXG4gIHByb3BlcnR5OiAncHJvcGVydHknLFxuICByOiAncicsXG4gIHJhZGl1czogJ3JhZGl1cycsXG4gIHJlZng6ICdyZWZYJyxcbiAgcmVmeTogJ3JlZlknLFxuICByZW5kZXJpbmdpbnRlbnQ6ICdyZW5kZXJpbmdJbnRlbnQnLFxuICAncmVuZGVyaW5nLWludGVudCc6ICdyZW5kZXJpbmdJbnRlbnQnLFxuICByZXBlYXRjb3VudDogJ3JlcGVhdENvdW50JyxcbiAgcmVwZWF0ZHVyOiAncmVwZWF0RHVyJyxcbiAgcmVxdWlyZWRleHRlbnNpb25zOiAncmVxdWlyZWRFeHRlbnNpb25zJyxcbiAgcmVxdWlyZWRmZWF0dXJlczogJ3JlcXVpcmVkRmVhdHVyZXMnLFxuICByZXNvdXJjZTogJ3Jlc291cmNlJyxcbiAgcmVzdGFydDogJ3Jlc3RhcnQnLFxuICByZXN1bHQ6ICdyZXN1bHQnLFxuICByZXN1bHRzOiAncmVzdWx0cycsXG4gIHJvdGF0ZTogJ3JvdGF0ZScsXG4gIHJ4OiAncngnLFxuICByeTogJ3J5JyxcbiAgc2NhbGU6ICdzY2FsZScsXG4gIHNlY3VyaXR5OiAnc2VjdXJpdHknLFxuICBzZWVkOiAnc2VlZCcsXG4gIHNoYXBlcmVuZGVyaW5nOiAnc2hhcGVSZW5kZXJpbmcnLFxuICAnc2hhcGUtcmVuZGVyaW5nJzogJ3NoYXBlUmVuZGVyaW5nJyxcbiAgc2xvcGU6ICdzbG9wZScsXG4gIHNwYWNpbmc6ICdzcGFjaW5nJyxcbiAgc3BlY3VsYXJjb25zdGFudDogJ3NwZWN1bGFyQ29uc3RhbnQnLFxuICBzcGVjdWxhcmV4cG9uZW50OiAnc3BlY3VsYXJFeHBvbmVudCcsXG4gIHNwZWVkOiAnc3BlZWQnLFxuICBzcHJlYWRtZXRob2Q6ICdzcHJlYWRNZXRob2QnLFxuICBzdGFydG9mZnNldDogJ3N0YXJ0T2Zmc2V0JyxcbiAgc3RkZGV2aWF0aW9uOiAnc3RkRGV2aWF0aW9uJyxcbiAgc3RlbWg6ICdzdGVtaCcsXG4gIHN0ZW12OiAnc3RlbXYnLFxuICBzdGl0Y2h0aWxlczogJ3N0aXRjaFRpbGVzJyxcbiAgc3RvcGNvbG9yOiAnc3RvcENvbG9yJyxcbiAgJ3N0b3AtY29sb3InOiAnc3RvcENvbG9yJyxcbiAgc3RvcG9wYWNpdHk6ICdzdG9wT3BhY2l0eScsXG4gICdzdG9wLW9wYWNpdHknOiAnc3RvcE9wYWNpdHknLFxuICBzdHJpa2V0aHJvdWdocG9zaXRpb246ICdzdHJpa2V0aHJvdWdoUG9zaXRpb24nLFxuICAnc3RyaWtldGhyb3VnaC1wb3NpdGlvbic6ICdzdHJpa2V0aHJvdWdoUG9zaXRpb24nLFxuICBzdHJpa2V0aHJvdWdodGhpY2tuZXNzOiAnc3RyaWtldGhyb3VnaFRoaWNrbmVzcycsXG4gICdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyc6ICdzdHJpa2V0aHJvdWdoVGhpY2tuZXNzJyxcbiAgc3RyaW5nOiAnc3RyaW5nJyxcbiAgc3Ryb2tlOiAnc3Ryb2tlJyxcbiAgc3Ryb2tlZGFzaGFycmF5OiAnc3Ryb2tlRGFzaGFycmF5JyxcbiAgJ3N0cm9rZS1kYXNoYXJyYXknOiAnc3Ryb2tlRGFzaGFycmF5JyxcbiAgc3Ryb2tlZGFzaG9mZnNldDogJ3N0cm9rZURhc2hvZmZzZXQnLFxuICAnc3Ryb2tlLWRhc2hvZmZzZXQnOiAnc3Ryb2tlRGFzaG9mZnNldCcsXG4gIHN0cm9rZWxpbmVjYXA6ICdzdHJva2VMaW5lY2FwJyxcbiAgJ3N0cm9rZS1saW5lY2FwJzogJ3N0cm9rZUxpbmVjYXAnLFxuICBzdHJva2VsaW5lam9pbjogJ3N0cm9rZUxpbmVqb2luJyxcbiAgJ3N0cm9rZS1saW5lam9pbic6ICdzdHJva2VMaW5lam9pbicsXG4gIHN0cm9rZW1pdGVybGltaXQ6ICdzdHJva2VNaXRlcmxpbWl0JyxcbiAgJ3N0cm9rZS1taXRlcmxpbWl0JzogJ3N0cm9rZU1pdGVybGltaXQnLFxuICBzdHJva2V3aWR0aDogJ3N0cm9rZVdpZHRoJyxcbiAgJ3N0cm9rZS13aWR0aCc6ICdzdHJva2VXaWR0aCcsXG4gIHN0cm9rZW9wYWNpdHk6ICdzdHJva2VPcGFjaXR5JyxcbiAgJ3N0cm9rZS1vcGFjaXR5JzogJ3N0cm9rZU9wYWNpdHknLFxuICBzdXBwcmVzc2NvbnRlbnRlZGl0YWJsZXdhcm5pbmc6ICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnLFxuICBzdXBwcmVzc2h5ZHJhdGlvbndhcm5pbmc6ICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnLFxuICBzdXJmYWNlc2NhbGU6ICdzdXJmYWNlU2NhbGUnLFxuICBzeXN0ZW1sYW5ndWFnZTogJ3N5c3RlbUxhbmd1YWdlJyxcbiAgdGFibGV2YWx1ZXM6ICd0YWJsZVZhbHVlcycsXG4gIHRhcmdldHg6ICd0YXJnZXRYJyxcbiAgdGFyZ2V0eTogJ3RhcmdldFknLFxuICB0ZXh0YW5jaG9yOiAndGV4dEFuY2hvcicsXG4gICd0ZXh0LWFuY2hvcic6ICd0ZXh0QW5jaG9yJyxcbiAgdGV4dGRlY29yYXRpb246ICd0ZXh0RGVjb3JhdGlvbicsXG4gICd0ZXh0LWRlY29yYXRpb24nOiAndGV4dERlY29yYXRpb24nLFxuICB0ZXh0bGVuZ3RoOiAndGV4dExlbmd0aCcsXG4gIHRleHRyZW5kZXJpbmc6ICd0ZXh0UmVuZGVyaW5nJyxcbiAgJ3RleHQtcmVuZGVyaW5nJzogJ3RleHRSZW5kZXJpbmcnLFxuICB0bzogJ3RvJyxcbiAgdHJhbnNmb3JtOiAndHJhbnNmb3JtJyxcbiAgJ3R5cGVvZic6ICd0eXBlb2YnLFxuICB1MTogJ3UxJyxcbiAgdTI6ICd1MicsXG4gIHVuZGVybGluZXBvc2l0aW9uOiAndW5kZXJsaW5lUG9zaXRpb24nLFxuICAndW5kZXJsaW5lLXBvc2l0aW9uJzogJ3VuZGVybGluZVBvc2l0aW9uJyxcbiAgdW5kZXJsaW5ldGhpY2tuZXNzOiAndW5kZXJsaW5lVGhpY2tuZXNzJyxcbiAgJ3VuZGVybGluZS10aGlja25lc3MnOiAndW5kZXJsaW5lVGhpY2tuZXNzJyxcbiAgdW5pY29kZTogJ3VuaWNvZGUnLFxuICB1bmljb2RlYmlkaTogJ3VuaWNvZGVCaWRpJyxcbiAgJ3VuaWNvZGUtYmlkaSc6ICd1bmljb2RlQmlkaScsXG4gIHVuaWNvZGVyYW5nZTogJ3VuaWNvZGVSYW5nZScsXG4gICd1bmljb2RlLXJhbmdlJzogJ3VuaWNvZGVSYW5nZScsXG4gIHVuaXRzcGVyZW06ICd1bml0c1BlckVtJyxcbiAgJ3VuaXRzLXBlci1lbSc6ICd1bml0c1BlckVtJyxcbiAgdW5zZWxlY3RhYmxlOiAndW5zZWxlY3RhYmxlJyxcbiAgdmFscGhhYmV0aWM6ICd2QWxwaGFiZXRpYycsXG4gICd2LWFscGhhYmV0aWMnOiAndkFscGhhYmV0aWMnLFxuICB2YWx1ZXM6ICd2YWx1ZXMnLFxuICB2ZWN0b3JlZmZlY3Q6ICd2ZWN0b3JFZmZlY3QnLFxuICAndmVjdG9yLWVmZmVjdCc6ICd2ZWN0b3JFZmZlY3QnLFxuICB2ZXJzaW9uOiAndmVyc2lvbicsXG4gIHZlcnRhZHZ5OiAndmVydEFkdlknLFxuICAndmVydC1hZHYteSc6ICd2ZXJ0QWR2WScsXG4gIHZlcnRvcmlnaW54OiAndmVydE9yaWdpblgnLFxuICAndmVydC1vcmlnaW4teCc6ICd2ZXJ0T3JpZ2luWCcsXG4gIHZlcnRvcmlnaW55OiAndmVydE9yaWdpblknLFxuICAndmVydC1vcmlnaW4teSc6ICd2ZXJ0T3JpZ2luWScsXG4gIHZoYW5naW5nOiAndkhhbmdpbmcnLFxuICAndi1oYW5naW5nJzogJ3ZIYW5naW5nJyxcbiAgdmlkZW9ncmFwaGljOiAndklkZW9ncmFwaGljJyxcbiAgJ3YtaWRlb2dyYXBoaWMnOiAndklkZW9ncmFwaGljJyxcbiAgdmlld2JveDogJ3ZpZXdCb3gnLFxuICB2aWV3dGFyZ2V0OiAndmlld1RhcmdldCcsXG4gIHZpc2liaWxpdHk6ICd2aXNpYmlsaXR5JyxcbiAgdm1hdGhlbWF0aWNhbDogJ3ZNYXRoZW1hdGljYWwnLFxuICAndi1tYXRoZW1hdGljYWwnOiAndk1hdGhlbWF0aWNhbCcsXG4gIHZvY2FiOiAndm9jYWInLFxuICB3aWR0aHM6ICd3aWR0aHMnLFxuICB3b3Jkc3BhY2luZzogJ3dvcmRTcGFjaW5nJyxcbiAgJ3dvcmQtc3BhY2luZyc6ICd3b3JkU3BhY2luZycsXG4gIHdyaXRpbmdtb2RlOiAnd3JpdGluZ01vZGUnLFxuICAnd3JpdGluZy1tb2RlJzogJ3dyaXRpbmdNb2RlJyxcbiAgeDE6ICd4MScsXG4gIHgyOiAneDInLFxuICB4OiAneCcsXG4gIHhjaGFubmVsc2VsZWN0b3I6ICd4Q2hhbm5lbFNlbGVjdG9yJyxcbiAgeGhlaWdodDogJ3hIZWlnaHQnLFxuICAneC1oZWlnaHQnOiAneEhlaWdodCcsXG4gIHhsaW5rYWN0dWF0ZTogJ3hsaW5rQWN0dWF0ZScsXG4gICd4bGluazphY3R1YXRlJzogJ3hsaW5rQWN0dWF0ZScsXG4gIHhsaW5rYXJjcm9sZTogJ3hsaW5rQXJjcm9sZScsXG4gICd4bGluazphcmNyb2xlJzogJ3hsaW5rQXJjcm9sZScsXG4gIHhsaW5raHJlZjogJ3hsaW5rSHJlZicsXG4gICd4bGluazpocmVmJzogJ3hsaW5rSHJlZicsXG4gIHhsaW5rcm9sZTogJ3hsaW5rUm9sZScsXG4gICd4bGluazpyb2xlJzogJ3hsaW5rUm9sZScsXG4gIHhsaW5rc2hvdzogJ3hsaW5rU2hvdycsXG4gICd4bGluazpzaG93JzogJ3hsaW5rU2hvdycsXG4gIHhsaW5rdGl0bGU6ICd4bGlua1RpdGxlJyxcbiAgJ3hsaW5rOnRpdGxlJzogJ3hsaW5rVGl0bGUnLFxuICB4bGlua3R5cGU6ICd4bGlua1R5cGUnLFxuICAneGxpbms6dHlwZSc6ICd4bGlua1R5cGUnLFxuICB4bWxiYXNlOiAneG1sQmFzZScsXG4gICd4bWw6YmFzZSc6ICd4bWxCYXNlJyxcbiAgeG1sbGFuZzogJ3htbExhbmcnLFxuICAneG1sOmxhbmcnOiAneG1sTGFuZycsXG4gIHhtbG5zOiAneG1sbnMnLFxuICAneG1sOnNwYWNlJzogJ3htbFNwYWNlJyxcbiAgeG1sbnN4bGluazogJ3htbG5zWGxpbmsnLFxuICAneG1sbnM6eGxpbmsnOiAneG1sbnNYbGluaycsXG4gIHhtbHNwYWNlOiAneG1sU3BhY2UnLFxuICB5MTogJ3kxJyxcbiAgeTI6ICd5MicsXG4gIHk6ICd5JyxcbiAgeWNoYW5uZWxzZWxlY3RvcjogJ3lDaGFubmVsU2VsZWN0b3InLFxuICB6OiAneicsXG4gIHpvb21hbmRwYW46ICd6b29tQW5kUGFuJ1xufTtcblxuZnVuY3Rpb24gZ2V0U3RhY2tBZGRlbmR1bSQyKCkge1xuICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgcmV0dXJuIHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnO1xufVxuXG57XG4gIHZhciB3YXJuZWRQcm9wZXJ0aWVzJDEgPSB7fTtcbiAgdmFyIGhhc093blByb3BlcnR5JDEgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgRVZFTlRfTkFNRV9SRUdFWCA9IC9eb24uLztcbiAgdmFyIElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWCA9IC9eb25bXkEtWl0vO1xuICB2YXIgckFSSUEkMSA9IG5ldyBSZWdFeHAoJ14oYXJpYSktWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuICB2YXIgckFSSUFDYW1lbCQxID0gbmV3IFJlZ0V4cCgnXihhcmlhKVtBLVpdWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuXG4gIHZhciB2YWxpZGF0ZVByb3BlcnR5JDEgPSBmdW5jdGlvbiAodGFnTmFtZSwgbmFtZSwgdmFsdWUsIGNhblVzZUV2ZW50U3lzdGVtKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5JDEuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzJDEsIG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ29uZm9jdXNpbicgfHwgbG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3Vzb3V0Jykge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0IHVzZXMgb25Gb2N1cyBhbmQgb25CbHVyIGluc3RlYWQgb2Ygb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0LiAnICsgJ0FsbCBSZWFjdCBldmVudHMgYXJlIG5vcm1hbGl6ZWQgdG8gYnViYmxlLCBzbyBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQgJyArICdhcmUgbm90IG5lZWRlZC9zdXBwb3J0ZWQgYnkgUmVhY3QuJyk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gV2UgY2FuJ3QgcmVseSBvbiB0aGUgZXZlbnQgc3lzdGVtIGJlaW5nIGluamVjdGVkIG9uIHRoZSBzZXJ2ZXIuXG4gICAgaWYgKGNhblVzZUV2ZW50U3lzdGVtKSB7XG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gcG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1tsb3dlckNhc2VkTmFtZV0gOiBudWxsO1xuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgIT0gbnVsbCkge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPyVzJywgbmFtZSwgcmVnaXN0cmF0aW9uTmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChFVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ1Vua25vd24gZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBJdCB3aWxsIGJlIGlnbm9yZWQuJXMnLCBuYW1lLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBJZiBubyBldmVudCBwbHVnaW5zIGhhdmUgYmVlbiBpbmplY3RlZCwgd2UgYXJlIGluIGEgc2VydmVyIGVudmlyb25tZW50LlxuICAgICAgLy8gU28gd2UgY2FuJ3QgdGVsbCBpZiB0aGUgZXZlbnQgbmFtZSBpcyBjb3JyZWN0IGZvciBzdXJlLCBidXQgd2UgY2FuIGZpbHRlclxuICAgICAgLy8gb3V0IGtub3duIGJhZCBvbmVzIGxpa2UgYG9uY2xpY2tgLiBXZSBjYW4ndCBzdWdnZXN0IGEgc3BlY2lmaWMgcmVwbGFjZW1lbnQgdGhvdWdoLlxuICAgICAgaWYgKElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gJyArICdSZWFjdCBldmVudHMgdXNlIHRoZSBjYW1lbENhc2UgbmFtaW5nIGNvbnZlbnRpb24sIGZvciBleGFtcGxlIGBvbkNsaWNrYC4lcycsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBMZXQgdGhlIEFSSUEgYXR0cmlidXRlIGhvb2sgdmFsaWRhdGUgQVJJQSBhdHRyaWJ1dGVzXG4gICAgaWYgKHJBUklBJDEudGVzdChuYW1lKSB8fCByQVJJQUNhbWVsJDEudGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnaW5uZXJodG1sJykge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0RpcmVjdGx5IHNldHRpbmcgcHJvcGVydHkgYGlubmVySFRNTGAgaXMgbm90IHBlcm1pdHRlZC4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgbG9va3VwIGRvY3VtZW50YXRpb24gb24gYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdhcmlhJykge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RoZSBgYXJpYWAgYXR0cmlidXRlIGlzIHJlc2VydmVkIGZvciBmdXR1cmUgdXNlIGluIFJlYWN0LiAnICsgJ1Bhc3MgaW5kaXZpZHVhbCBgYXJpYS1gIGF0dHJpYnV0ZXMgaW5zdGVhZC4nKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdpcycgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnUmVjZWl2ZWQgYSBgJXNgIGZvciBhIHN0cmluZyBhdHRyaWJ1dGUgYGlzYC4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4lcycsIHR5cGVvZiB2YWx1ZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbHVlKSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1JlY2VpdmVkIE5hTiBmb3IgdGhlIGAlc2AgYXR0cmlidXRlLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0ICcgKyAndGhlIHZhbHVlIHRvIGEgc3RyaW5nLiVzJywgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBpc1Jlc2VydmVkID0gaXNSZXNlcnZlZFByb3AobmFtZSk7XG5cbiAgICAvLyBLbm93biBhdHRyaWJ1dGVzIHNob3VsZCBtYXRjaCB0aGUgY2FzaW5nIHNwZWNpZmllZCBpbiB0aGUgcHJvcGVydHkgY29uZmlnLlxuICAgIGlmIChwb3NzaWJsZVN0YW5kYXJkTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpKSB7XG4gICAgICB2YXIgc3RhbmRhcmROYW1lID0gcG9zc2libGVTdGFuZGFyZE5hbWVzW2xvd2VyQ2FzZWROYW1lXTtcbiAgICAgIGlmIChzdGFuZGFyZE5hbWUgIT09IG5hbWUpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgRE9NIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPyVzJywgbmFtZSwgc3RhbmRhcmROYW1lLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQgJiYgbmFtZSAhPT0gbG93ZXJDYXNlZE5hbWUpIHtcbiAgICAgIC8vIFVua25vd24gYXR0cmlidXRlcyBzaG91bGQgaGF2ZSBsb3dlcmNhc2UgY2FzaW5nIHNpbmNlIHRoYXQncyBob3cgdGhleVxuICAgICAgLy8gd2lsbCBiZSBjYXNlZCBhbnl3YXkgd2l0aCBzZXJ2ZXIgcmVuZGVyaW5nLlxuICAgICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0IGRvZXMgbm90IHJlY29nbml6ZSB0aGUgYCVzYCBwcm9wIG9uIGEgRE9NIGVsZW1lbnQuIElmIHlvdSAnICsgJ2ludGVudGlvbmFsbHkgd2FudCBpdCB0byBhcHBlYXIgaW4gdGhlIERPTSBhcyBhIGN1c3RvbSAnICsgJ2F0dHJpYnV0ZSwgc3BlbGwgaXQgYXMgbG93ZXJjYXNlIGAlc2AgaW5zdGVhZC4gJyArICdJZiB5b3UgYWNjaWRlbnRhbGx5IHBhc3NlZCBpdCBmcm9tIGEgcGFyZW50IGNvbXBvbmVudCwgcmVtb3ZlICcgKyAnaXQgZnJvbSB0aGUgRE9NIGVsZW1lbnQuJXMnLCBuYW1lLCBsb3dlckNhc2VkTmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyAmJiAhc2hvdWxkQXR0cmlidXRlQWNjZXB0Qm9vbGVhblZhbHVlKG5hbWUpKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ1JlY2VpdmVkIGAlc2AgZm9yIGEgbm9uLWJvb2xlYW4gYXR0cmlidXRlIGAlc2AuXFxuXFxuJyArICdJZiB5b3Ugd2FudCB0byB3cml0ZSBpdCB0byB0aGUgRE9NLCBwYXNzIGEgc3RyaW5nIGluc3RlYWQ6ICcgKyAnJXM9XCIlc1wiIG9yICVzPXt2YWx1ZS50b1N0cmluZygpfS4lcycsIHZhbHVlLCBuYW1lLCBuYW1lLCB2YWx1ZSwgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ1JlY2VpdmVkIGAlc2AgZm9yIGEgbm9uLWJvb2xlYW4gYXR0cmlidXRlIGAlc2AuXFxuXFxuJyArICdJZiB5b3Ugd2FudCB0byB3cml0ZSBpdCB0byB0aGUgRE9NLCBwYXNzIGEgc3RyaW5nIGluc3RlYWQ6ICcgKyAnJXM9XCIlc1wiIG9yICVzPXt2YWx1ZS50b1N0cmluZygpfS5cXG5cXG4nICsgJ0lmIHlvdSB1c2VkIHRvIGNvbmRpdGlvbmFsbHkgb21pdCBpdCB3aXRoICVzPXtjb25kaXRpb24gJiYgdmFsdWV9LCAnICsgJ3Bhc3MgJXM9e2NvbmRpdGlvbiA/IHZhbHVlIDogdW5kZWZpbmVkfSBpbnN0ZWFkLiVzJywgdmFsdWUsIG5hbWUsIG5hbWUsIHZhbHVlLCBuYW1lLCBuYW1lLCBuYW1lLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICB9XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gTm93IHRoYXQgd2UndmUgdmFsaWRhdGVkIGNhc2luZywgZG8gbm90IHZhbGlkYXRlXG4gICAgLy8gZGF0YSB0eXBlcyBmb3IgcmVzZXJ2ZWQgcHJvcHNcbiAgICBpZiAoaXNSZXNlcnZlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gV2FybiB3aGVuIGEga25vd24gYXR0cmlidXRlIGlzIGEgYmFkIHR5cGVcbiAgICBpZiAoIXNob3VsZFNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkpIHtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59XG5cbnZhciB3YXJuVW5rbm93blByb3BlcnRpZXMgPSBmdW5jdGlvbiAodHlwZSwgcHJvcHMsIGNhblVzZUV2ZW50U3lzdGVtKSB7XG4gIHZhciB1bmtub3duUHJvcHMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5JDEodHlwZSwga2V5LCBwcm9wc1trZXldLCBjYW5Vc2VFdmVudFN5c3RlbSk7XG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICB1bmtub3duUHJvcHMucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1bmtub3duUHJvcFN0cmluZyA9IHVua25vd25Qcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgfSkuam9pbignLCAnKTtcbiAgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCB2YWx1ZSBmb3IgcHJvcCAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSBpdCBmcm9tIHRoZSBlbGVtZW50LCAnICsgJ29yIHBhc3MgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIHRvIGtlZXAgaXQgaW4gdGhlIERPTS4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtYXR0cmlidXRlLWJlaGF2aW9yJXMnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICB9IGVsc2UgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgdmFsdWVzIGZvciBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSB0aGVtIGZyb20gdGhlIGVsZW1lbnQsICcgKyAnb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCB0aGVtIGluIHRoZSBET00uICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL3JlYWN0LWF0dHJpYnV0ZS1iZWhhdmlvciVzJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMsIGNhblVzZUV2ZW50U3lzdGVtKSB7XG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2FyblVua25vd25Qcm9wZXJ0aWVzKHR5cGUsIHByb3BzLCBjYW5Vc2VFdmVudFN5c3RlbSk7XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMSA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lO1xudmFyIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMiA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxudmFyIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gZmFsc2U7XG52YXIgZGlkV2FyblNoYWR5RE9NID0gZmFsc2U7XG5cbnZhciBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCA9ICdkYW5nZXJvdXNseVNldElubmVySFRNTCc7XG52YXIgU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HID0gJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyc7XG52YXIgU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSA9ICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnO1xudmFyIEFVVE9GT0NVUyA9ICdhdXRvRm9jdXMnO1xudmFyIENISUxEUkVOID0gJ2NoaWxkcmVuJztcbnZhciBTVFlMRSA9ICdzdHlsZSc7XG52YXIgSFRNTCA9ICdfX2h0bWwnO1xuXG52YXIgSFRNTF9OQU1FU1BBQ0UgPSBOYW1lc3BhY2VzLmh0bWw7XG5cblxudmFyIGdldFN0YWNrID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucygnJyk7XG5cbntcbiAgZ2V0U3RhY2sgPSBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDI7XG5cbiAgdmFyIHdhcm5lZFVua25vd25UYWdzID0ge1xuICAgIC8vIENocm9tZSBpcyB0aGUgb25seSBtYWpvciBicm93c2VyIG5vdCBzaGlwcGluZyA8dGltZT4uIEJ1dCBhcyBvZiBKdWx5XG4gICAgLy8gMjAxNyBpdCBpbnRlbmRzIHRvIHNoaXAgaXQgZHVlIHRvIHdpZGVzcHJlYWQgdXNhZ2UuIFdlIGludGVudGlvbmFsbHlcbiAgICAvLyAqZG9uJ3QqIHdhcm4gZm9yIDx0aW1lPiBldmVuIGlmIGl0J3MgdW5yZWNvZ25pemVkIGJ5IENocm9tZSBiZWNhdXNlXG4gICAgLy8gaXQgc29vbiB3aWxsIGJlLCBhbmQgbWFueSBhcHBzIGhhdmUgYmVlbiB1c2luZyBpdCBhbnl3YXkuXG4gICAgdGltZTogdHJ1ZSxcbiAgICAvLyBUaGVyZSBhcmUgd29ya2luZyBwb2x5ZmlsbHMgZm9yIDxkaWFsb2c+LiBMZXQgcGVvcGxlIHVzZSBpdC5cbiAgICBkaWFsb2c6IHRydWVcbiAgfTtcblxuICB2YXIgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBwcm9wcykge1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyh0eXBlLCBwcm9wcyk7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzJDEodHlwZSwgcHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUsIHByb3BzLCAvKiBjYW5Vc2VFdmVudFN5c3RlbSAqL3RydWUpO1xuICB9O1xuXG4gIC8vIEhUTUwgcGFyc2luZyBub3JtYWxpemVzIENSIGFuZCBDUkxGIHRvIExGLlxuICAvLyBJdCBhbHNvIGNhbiB0dXJuIFxcdTAwMDAgaW50byBcXHVGRkZEIGluc2lkZSBhdHRyaWJ1dGVzLlxuICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvc2luZ2xlLXBhZ2UuaHRtbCNwcmVwcm9jZXNzaW5nLXRoZS1pbnB1dC1zdHJlYW1cbiAgLy8gSWYgd2UgaGF2ZSBhIG1pc21hdGNoLCBpdCBtaWdodCBiZSBjYXVzZWQgYnkgdGhhdC5cbiAgLy8gV2Ugd2lsbCBzdGlsbCBwYXRjaCB1cCBpbiB0aGlzIGNhc2UgYnV0IG5vdCBmaXJlIHRoZSB3YXJuaW5nLlxuICB2YXIgTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYID0gL1xcclxcbj8vZztcbiAgdmFyIE5PUk1BTElaRV9OVUxMX0FORF9SRVBMQUNFTUVOVF9SRUdFWCA9IC9cXHUwMDAwfFxcdUZGRkQvZztcblxuICB2YXIgbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlID0gZnVuY3Rpb24gKG1hcmt1cCkge1xuICAgIHZhciBtYXJrdXBTdHJpbmcgPSB0eXBlb2YgbWFya3VwID09PSAnc3RyaW5nJyA/IG1hcmt1cCA6ICcnICsgbWFya3VwO1xuICAgIHJldHVybiBtYXJrdXBTdHJpbmcucmVwbGFjZShOT1JNQUxJWkVfTkVXTElORVNfUkVHRVgsICdcXG4nKS5yZXBsYWNlKE5PUk1BTElaRV9OVUxMX0FORF9SRVBMQUNFTUVOVF9SRUdFWCwgJycpO1xuICB9O1xuXG4gIHZhciB3YXJuRm9yVGV4dERpZmZlcmVuY2UgPSBmdW5jdGlvbiAoc2VydmVyVGV4dCwgY2xpZW50VGV4dCkge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbm9ybWFsaXplZENsaWVudFRleHQgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoY2xpZW50VGV4dCk7XG4gICAgdmFyIG5vcm1hbGl6ZWRTZXJ2ZXJUZXh0ID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKHNlcnZlclRleHQpO1xuICAgIGlmIChub3JtYWxpemVkU2VydmVyVGV4dCA9PT0gbm9ybWFsaXplZENsaWVudFRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdUZXh0IGNvbnRlbnQgZGlkIG5vdCBtYXRjaC4gU2VydmVyOiBcIiVzXCIgQ2xpZW50OiBcIiVzXCInLCBub3JtYWxpemVkU2VydmVyVGV4dCwgbm9ybWFsaXplZENsaWVudFRleHQpO1xuICB9O1xuXG4gIHZhciB3YXJuRm9yUHJvcERpZmZlcmVuY2UgPSBmdW5jdGlvbiAocHJvcE5hbWUsIHNlcnZlclZhbHVlLCBjbGllbnRWYWx1ZSkge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbm9ybWFsaXplZENsaWVudFZhbHVlID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKGNsaWVudFZhbHVlKTtcbiAgICB2YXIgbm9ybWFsaXplZFNlcnZlclZhbHVlID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKHNlcnZlclZhbHVlKTtcbiAgICBpZiAobm9ybWFsaXplZFNlcnZlclZhbHVlID09PSBub3JtYWxpemVkQ2xpZW50VmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdQcm9wIGAlc2AgZGlkIG5vdCBtYXRjaC4gU2VydmVyOiAlcyBDbGllbnQ6ICVzJywgcHJvcE5hbWUsIEpTT04uc3RyaW5naWZ5KG5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSksIEpTT04uc3RyaW5naWZ5KG5vcm1hbGl6ZWRDbGllbnRWYWx1ZSkpO1xuICB9O1xuXG4gIHZhciB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWVzKSB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBhdHRyaWJ1dGVOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBuYW1lcy5wdXNoKG5hbWUpO1xuICAgIH0pO1xuICAgIHdhcm5pbmcoZmFsc2UsICdFeHRyYSBhdHRyaWJ1dGVzIGZyb20gdGhlIHNlcnZlcjogJXMnLCBuYW1lcyk7XG4gIH07XG5cbiAgdmFyIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChyZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lciA9PT0gZmFsc2UpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdFeHBlY3RlZCBgJXNgIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IGBmYWxzZWAuXFxuXFxuJyArICdJZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgJyArICdwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4lcycsIHJlZ2lzdHJhdGlvbk5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0V4cGVjdGVkIGAlc2AgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgYSB2YWx1ZSBvZiBgJXNgIHR5cGUuJXMnLCByZWdpc3RyYXRpb25OYW1lLCB0eXBlb2YgbGlzdGVuZXIsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUGFyc2UgdGhlIEhUTUwgYW5kIHJlYWQgaXQgYmFjayB0byBub3JtYWxpemUgdGhlIEhUTUwgc3RyaW5nIHNvIHRoYXQgaXRcbiAgLy8gY2FuIGJlIHVzZWQgZm9yIGNvbXBhcmlzb24uXG4gIHZhciBub3JtYWxpemVIVE1MID0gZnVuY3Rpb24gKHBhcmVudCwgaHRtbCkge1xuICAgIC8vIFdlIGNvdWxkIGhhdmUgY3JlYXRlZCBhIHNlcGFyYXRlIGRvY3VtZW50IGhlcmUgdG8gYXZvaWRcbiAgICAvLyByZS1pbml0aWFsaXppbmcgY3VzdG9tIGVsZW1lbnRzIGlmIHRoZXkgZXhpc3QuIEJ1dCB0aGlzIGJyZWFrc1xuICAgIC8vIGhvdyA8bm9zY3JpcHQ+IGlzIGJlaW5nIGhhbmRsZWQuIFNvIHdlIHVzZSB0aGUgc2FtZSBkb2N1bWVudC5cbiAgICAvLyBTZWUgdGhlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTExNTcuXG4gICAgdmFyIHRlc3RFbGVtZW50ID0gcGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UgPyBwYXJlbnQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHBhcmVudC50YWdOYW1lKSA6IHBhcmVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhwYXJlbnQubmFtZXNwYWNlVVJJLCBwYXJlbnQudGFnTmFtZSk7XG4gICAgdGVzdEVsZW1lbnQuaW5uZXJIVE1MID0gaHRtbDtcbiAgICByZXR1cm4gdGVzdEVsZW1lbnQuaW5uZXJIVE1MO1xuICB9O1xufVxuXG5mdW5jdGlvbiBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICB2YXIgaXNEb2N1bWVudE9yRnJhZ21lbnQgPSByb290Q29udGFpbmVyRWxlbWVudC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSB8fCByb290Q29udGFpbmVyRWxlbWVudC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERTtcbiAgdmFyIGRvYyA9IGlzRG9jdW1lbnRPckZyYWdtZW50ID8gcm9vdENvbnRhaW5lckVsZW1lbnQgOiByb290Q29udGFpbmVyRWxlbWVudC5vd25lckRvY3VtZW50O1xuICBsaXN0ZW5UbyhyZWdpc3RyYXRpb25OYW1lLCBkb2MpO1xufVxuXG5mdW5jdGlvbiBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIocm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgcmV0dXJuIHJvb3RDb250YWluZXJFbGVtZW50Lm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFID8gcm9vdENvbnRhaW5lckVsZW1lbnQgOiByb290Q29udGFpbmVyRWxlbWVudC5vd25lckRvY3VtZW50O1xufVxuXG4vLyBUaGVyZSBhcmUgc28gbWFueSBtZWRpYSBldmVudHMsIGl0IG1ha2VzIHNlbnNlIHRvIGp1c3Rcbi8vIG1haW50YWluIGEgbGlzdCByYXRoZXIgdGhhbiBjcmVhdGUgYSBgdHJhcEJ1YmJsZWRFdmVudGAgZm9yIGVhY2hcbnZhciBtZWRpYUV2ZW50cyA9IHtcbiAgdG9wQWJvcnQ6ICdhYm9ydCcsXG4gIHRvcENhblBsYXk6ICdjYW5wbGF5JyxcbiAgdG9wQ2FuUGxheVRocm91Z2g6ICdjYW5wbGF5dGhyb3VnaCcsXG4gIHRvcER1cmF0aW9uQ2hhbmdlOiAnZHVyYXRpb25jaGFuZ2UnLFxuICB0b3BFbXB0aWVkOiAnZW1wdGllZCcsXG4gIHRvcEVuY3J5cHRlZDogJ2VuY3J5cHRlZCcsXG4gIHRvcEVuZGVkOiAnZW5kZWQnLFxuICB0b3BFcnJvcjogJ2Vycm9yJyxcbiAgdG9wTG9hZGVkRGF0YTogJ2xvYWRlZGRhdGEnLFxuICB0b3BMb2FkZWRNZXRhZGF0YTogJ2xvYWRlZG1ldGFkYXRhJyxcbiAgdG9wTG9hZFN0YXJ0OiAnbG9hZHN0YXJ0JyxcbiAgdG9wUGF1c2U6ICdwYXVzZScsXG4gIHRvcFBsYXk6ICdwbGF5JyxcbiAgdG9wUGxheWluZzogJ3BsYXlpbmcnLFxuICB0b3BQcm9ncmVzczogJ3Byb2dyZXNzJyxcbiAgdG9wUmF0ZUNoYW5nZTogJ3JhdGVjaGFuZ2UnLFxuICB0b3BTZWVrZWQ6ICdzZWVrZWQnLFxuICB0b3BTZWVraW5nOiAnc2Vla2luZycsXG4gIHRvcFN0YWxsZWQ6ICdzdGFsbGVkJyxcbiAgdG9wU3VzcGVuZDogJ3N1c3BlbmQnLFxuICB0b3BUaW1lVXBkYXRlOiAndGltZXVwZGF0ZScsXG4gIHRvcFZvbHVtZUNoYW5nZTogJ3ZvbHVtZWNoYW5nZScsXG4gIHRvcFdhaXRpbmc6ICd3YWl0aW5nJ1xufTtcblxuZnVuY3Rpb24gdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQobm9kZSkge1xuICAvLyBNb2JpbGUgU2FmYXJpIGRvZXMgbm90IGZpcmUgcHJvcGVybHkgYnViYmxlIGNsaWNrIGV2ZW50cyBvblxuICAvLyBub24taW50ZXJhY3RpdmUgZWxlbWVudHMsIHdoaWNoIG1lYW5zIGRlbGVnYXRlZCBjbGljayBsaXN0ZW5lcnMgZG8gbm90XG4gIC8vIGZpcmUuIFRoZSB3b3JrYXJvdW5kIGZvciB0aGlzIGJ1ZyBpbnZvbHZlcyBhdHRhY2hpbmcgYW4gZW1wdHkgY2xpY2tcbiAgLy8gbGlzdGVuZXIgb24gdGhlIHRhcmdldCBub2RlLlxuICAvLyBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxuICAvLyBKdXN0IHNldCBpdCB1c2luZyB0aGUgb25jbGljayBwcm9wZXJ0eSBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gbWFuYWdlIGFueVxuICAvLyBib29ra2VlcGluZyBmb3IgaXQuIE5vdCBzdXJlIGlmIHdlIG5lZWQgdG8gY2xlYXIgaXQgd2hlbiB0aGUgbGlzdGVuZXIgaXNcbiAgLy8gcmVtb3ZlZC5cbiAgLy8gVE9ETzogT25seSBkbyB0aGlzIGZvciB0aGUgcmVsZXZhbnQgU2FmYXJpcyBtYXliZT9cbiAgbm9kZS5vbmNsaWNrID0gZW1wdHlGdW5jdGlvbjtcbn1cblxuZnVuY3Rpb24gc2V0SW5pdGlhbERPTVByb3BlcnRpZXModGFnLCBkb21FbGVtZW50LCByb290Q29udGFpbmVyRWxlbWVudCwgbmV4dFByb3BzLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBmb3IgKHZhciBwcm9wS2V5IGluIG5leHRQcm9wcykge1xuICAgIGlmICghbmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIG5leHRQcm9wID0gbmV4dFByb3BzW3Byb3BLZXldO1xuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAge1xuICAgICAgICBpZiAobmV4dFByb3ApIHtcbiAgICAgICAgICAvLyBGcmVlemUgdGhlIG5leHQgc3R5bGUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGFzc3VtZSBpdCB3b24ndCBiZVxuICAgICAgICAgIC8vIG11dGF0ZWQuIFdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgZm9yIHRoaXMgaW4gdGhlIHBhc3QuXG4gICAgICAgICAgT2JqZWN0LmZyZWV6ZShuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFJlbGllcyBvbiBgdXBkYXRlU3R5bGVzQnlJRGAgbm90IG11dGF0aW5nIGBzdHlsZVVwZGF0ZXNgLlxuICAgICAgc2V0VmFsdWVGb3JTdHlsZXMoZG9tRWxlbWVudCwgbmV4dFByb3AsIGdldFN0YWNrKTtcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICB2YXIgbmV4dEh0bWwgPSBuZXh0UHJvcCA/IG5leHRQcm9wW0hUTUxdIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKG5leHRIdG1sICE9IG51bGwpIHtcbiAgICAgICAgc2V0SW5uZXJIVE1MKGRvbUVsZW1lbnQsIG5leHRIdG1sKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBBdm9pZCBzZXR0aW5nIGluaXRpYWwgdGV4dENvbnRlbnQgd2hlbiB0aGUgdGV4dCBpcyBlbXB0eS4gSW4gSUUxMSBzZXR0aW5nXG4gICAgICAgIC8vIHRleHRDb250ZW50IG9uIGEgPHRleHRhcmVhPiB3aWxsIGNhdXNlIHRoZSBwbGFjZWhvbGRlciB0byBub3RcbiAgICAgICAgLy8gc2hvdyB3aXRoaW4gdGhlIDx0ZXh0YXJlYT4gdW50aWwgaXQgaGFzIGJlZW4gZm9jdXNlZCBhbmQgYmx1cnJlZCBhZ2Fpbi5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy82NzMxI2lzc3VlY29tbWVudC0yNTQ4NzQ1NTNcbiAgICAgICAgdmFyIGNhblNldFRleHRDb250ZW50ID0gdGFnICE9PSAndGV4dGFyZWEnIHx8IG5leHRQcm9wICE9PSAnJztcbiAgICAgICAgaWYgKGNhblNldFRleHRDb250ZW50KSB7XG4gICAgICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgJycgKyBuZXh0UHJvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSkge1xuICAgICAgLy8gTm9vcFxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gQVVUT0ZPQ1VTKSB7XG4gICAgICAvLyBXZSBwb2x5ZmlsbCBpdCBzZXBhcmF0ZWx5IG9uIHRoZSBjbGllbnQgZHVyaW5nIGNvbW1pdC5cbiAgICAgIC8vIFdlIGJsYWNrbGlzdCBpdCBoZXJlIHJhdGhlciB0aGFuIGluIHRoZSBwcm9wZXJ0eSBsaXN0IGJlY2F1c2Ugd2UgZW1pdCBpdCBpbiBTU1IuXG4gICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHRydWUgJiYgdHlwZW9mIG5leHRQcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgICAgc2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgIH0gZWxzZSBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UncmUgdXBkYXRpbmcgdG8gbnVsbCBvciB1bmRlZmluZWQsIHdlIHNob3VsZCByZW1vdmUgdGhlIHByb3BlcnR5XG4gICAgICAvLyBmcm9tIHRoZSBET00gbm9kZSBpbnN0ZWFkIG9mIGluYWR2ZXJ0ZW50bHkgc2V0dGluZyB0byBhIHN0cmluZy4gVGhpc1xuICAgICAgLy8gYnJpbmdzIHVzIGluIGxpbmUgd2l0aCB0aGUgc2FtZSBiZWhhdmlvciB3ZSBoYXZlIG9uIGluaXRpYWwgcmVuZGVyLlxuICAgICAgc2V0VmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgd2FzQ3VzdG9tQ29tcG9uZW50VGFnLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAvLyBUT0RPOiBIYW5kbGUgd2FzQ3VzdG9tQ29tcG9uZW50VGFnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdXBkYXRlUGF5bG9hZC5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBwcm9wS2V5ID0gdXBkYXRlUGF5bG9hZFtpXTtcbiAgICB2YXIgcHJvcFZhbHVlID0gdXBkYXRlUGF5bG9hZFtpICsgMV07XG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICBzZXRWYWx1ZUZvclN0eWxlcyhkb21FbGVtZW50LCBwcm9wVmFsdWUsIGdldFN0YWNrKTtcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICBzZXRJbm5lckhUTUwoZG9tRWxlbWVudCwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICBzZXRUZXh0Q29udGVudChkb21FbGVtZW50LCBwcm9wVmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUZvckF0dHJpYnV0ZShkb21FbGVtZW50LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlVmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgIT0gbnVsbCkge1xuICAgICAgc2V0VmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSdyZSB1cGRhdGluZyB0byBudWxsIG9yIHVuZGVmaW5lZCwgd2Ugc2hvdWxkIHJlbW92ZSB0aGUgcHJvcGVydHlcbiAgICAgIC8vIGZyb20gdGhlIERPTSBub2RlIGluc3RlYWQgb2YgaW5hZHZlcnRlbnRseSBzZXR0aW5nIHRvIGEgc3RyaW5nLiBUaGlzXG4gICAgICAvLyBicmluZ3MgdXMgaW4gbGluZSB3aXRoIHRoZSBzYW1lIGJlaGF2aW9yIHdlIGhhdmUgb24gaW5pdGlhbCByZW5kZXIuXG4gICAgICBkZWxldGVWYWx1ZUZvclByb3BlcnR5KGRvbUVsZW1lbnQsIHByb3BLZXkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50JDEodHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJFbGVtZW50LCBwYXJlbnROYW1lc3BhY2UpIHtcbiAgLy8gV2UgY3JlYXRlIHRhZ3MgaW4gdGhlIG5hbWVzcGFjZSBvZiB0aGVpciBwYXJlbnQgY29udGFpbmVyLCBleGNlcHQgSFRNTFxuICB2YXIgb3duZXJEb2N1bWVudCA9IGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihyb290Q29udGFpbmVyRWxlbWVudCk7XG4gIHZhciBkb21FbGVtZW50O1xuICB2YXIgbmFtZXNwYWNlVVJJID0gcGFyZW50TmFtZXNwYWNlO1xuICBpZiAobmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgIG5hbWVzcGFjZVVSSSA9IGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKTtcbiAgfVxuICBpZiAobmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgIHtcbiAgICAgIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHR5cGUsIHByb3BzKTtcbiAgICAgIC8vIFNob3VsZCB0aGlzIGNoZWNrIGJlIGdhdGVkIGJ5IHBhcmVudCBuYW1lc3BhY2U/IE5vdCBzdXJlIHdlIHdhbnQgdG9cbiAgICAgIC8vIGFsbG93IDxTVkc+IG9yIDxtQVRIPi5cbiAgICAgIHdhcm5pbmcoaXNDdXN0b21Db21wb25lbnRUYWcgfHwgdHlwZSA9PT0gdHlwZS50b0xvd2VyQ2FzZSgpLCAnPCVzIC8+IGlzIHVzaW5nIHVwcGVyY2FzZSBIVE1MLiBBbHdheXMgdXNlIGxvd2VyY2FzZSBIVE1MIHRhZ3MgJyArICdpbiBSZWFjdC4nLCB0eXBlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ3NjcmlwdCcpIHtcbiAgICAgIC8vIENyZWF0ZSB0aGUgc2NyaXB0IHZpYSAuaW5uZXJIVE1MIHNvIGl0cyBcInBhcnNlci1pbnNlcnRlZFwiIGZsYWcgaXNcbiAgICAgIC8vIHNldCB0byB0cnVlIGFuZCBpdCBkb2VzIG5vdCBleGVjdXRlXG4gICAgICB2YXIgZGl2ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRpdi5pbm5lckhUTUwgPSAnPHNjcmlwdD48JyArICcvc2NyaXB0Pic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIC8vIFRoaXMgaXMgZ3VhcmFudGVlZCB0byB5aWVsZCBhIHNjcmlwdCBlbGVtZW50LlxuICAgICAgdmFyIGZpcnN0Q2hpbGQgPSBkaXYuZmlyc3RDaGlsZDtcbiAgICAgIGRvbUVsZW1lbnQgPSBkaXYucmVtb3ZlQ2hpbGQoZmlyc3RDaGlsZCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvcHMuaXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyAkRmxvd0lzc3VlIGBjcmVhdGVFbGVtZW50YCBzaG91bGQgYmUgdXBkYXRlZCBmb3IgV2ViIENvbXBvbmVudHNcbiAgICAgIGRvbUVsZW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSwgeyBpczogcHJvcHMuaXMgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNlcGFyYXRlIGVsc2UgYnJhbmNoIGluc3RlYWQgb2YgdXNpbmcgYHByb3BzLmlzIHx8IHVuZGVmaW5lZGAgYWJvdmUgYmVjYXVzZSBvZiBhIEZpcmVmb3ggYnVnLlxuICAgICAgLy8gU2VlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNjg5NlxuICAgICAgLy8gYW5kIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTI3NjI0MFxuICAgICAgZG9tRWxlbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZG9tRWxlbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgdHlwZSk7XG4gIH1cblxuICB7XG4gICAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgIGlmICghaXNDdXN0b21Db21wb25lbnRUYWcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRvbUVsZW1lbnQpID09PSAnW29iamVjdCBIVE1MVW5rbm93bkVsZW1lbnRdJyAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFVua25vd25UYWdzLCB0eXBlKSkge1xuICAgICAgICB3YXJuZWRVbmtub3duVGFnc1t0eXBlXSA9IHRydWU7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdUaGUgdGFnIDwlcz4gaXMgdW5yZWNvZ25pemVkIGluIHRoaXMgYnJvd3Nlci4gJyArICdJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgUmVhY3QgY29tcG9uZW50LCBzdGFydCBpdHMgbmFtZSB3aXRoICcgKyAnYW4gdXBwZXJjYXNlIGxldHRlci4nLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZG9tRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUkMSh0ZXh0LCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICByZXR1cm4gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJFbGVtZW50KS5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbn1cblxuZnVuY3Rpb24gc2V0SW5pdGlhbFByb3BlcnRpZXMkMShkb21FbGVtZW50LCB0YWcsIHJhd1Byb3BzLCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIHJhd1Byb3BzKTtcbiAge1xuICAgIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQodGFnLCByYXdQcm9wcyk7XG4gICAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnICYmICFkaWRXYXJuU2hhZHlET00gJiYgZG9tRWxlbWVudC5zaGFkeVJvb3QpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclcyBpcyB1c2luZyBzaGFkeSBET00uIFVzaW5nIHNoYWR5IERPTSB3aXRoIFJlYWN0IGNhbiAnICsgJ2NhdXNlIHRoaW5ncyB0byBicmVhayBzdWJ0bHkuJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDEoKSB8fCAnQSBjb21wb25lbnQnKTtcbiAgICAgIGRpZFdhcm5TaGFkeURPTSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogTWFrZSBzdXJlIHRoYXQgd2UgY2hlY2sgaXNNb3VudGVkIGJlZm9yZSBmaXJpbmcgYW55IG9mIHRoZXNlIGV2ZW50cy5cbiAgdmFyIHByb3BzO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcExvYWQnLCAnbG9hZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICBjYXNlICdhdWRpbyc6XG4gICAgICAvLyBDcmVhdGUgbGlzdGVuZXIgZm9yIGVhY2ggbWVkaWEgZXZlbnRcbiAgICAgIGZvciAodmFyIGV2ZW50IGluIG1lZGlhRXZlbnRzKSB7XG4gICAgICAgIGlmIChtZWRpYUV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcbiAgICAgICAgICB0cmFwQnViYmxlZEV2ZW50KGV2ZW50LCBtZWRpYUV2ZW50c1tldmVudF0sIGRvbUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc291cmNlJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEVycm9yJywgJ2Vycm9yJywgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW1nJzpcbiAgICBjYXNlICdpbWFnZSc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BFcnJvcicsICdlcnJvcicsIGRvbUVsZW1lbnQpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wTG9hZCcsICdsb2FkJywgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZm9ybSc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BSZXNldCcsICdyZXNldCcsIGRvbUVsZW1lbnQpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wU3VibWl0JywgJ3N1Ym1pdCcsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wVG9nZ2xlJywgJ3RvZ2dsZScsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgcHJvcHMgPSBnZXRIb3N0UHJvcHMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wSW52YWxpZCcsICdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG4gICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgIC8vIHRvIG9uQ2hhbmdlLiBFdmVuIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLlxuICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIHZhbGlkYXRlUHJvcHMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgcHJvcHMgPSBnZXRIb3N0UHJvcHMkMShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQxKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzJDIoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wSW52YWxpZCcsICdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG4gICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgIC8vIHRvIG9uQ2hhbmdlLiBFdmVuIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLlxuICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzJDMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wSW52YWxpZCcsICdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG4gICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgIC8vIHRvIG9uQ2hhbmdlLiBFdmVuIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLlxuICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gIH1cblxuICBhc3NlcnRWYWxpZFByb3BzKHRhZywgcHJvcHMsIGdldFN0YWNrKTtcblxuICBzZXRJbml0aWFsRE9NUHJvcGVydGllcyh0YWcsIGRvbUVsZW1lbnQsIHJvb3RDb250YWluZXJFbGVtZW50LCBwcm9wcywgaXNDdXN0b21Db21wb25lbnRUYWcpO1xuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcG9zdE1vdW50V3JhcHBlcihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyJDMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgcG9zdE1vdW50V3JhcHBlciQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodHlwZW9mIHByb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbiAgICAgICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoZG9tRWxlbWVudCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxufVxuXG4vLyBDYWxjdWxhdGUgdGhlIGRpZmYgYmV0d2VlbiB0aGUgdHdvIG9iamVjdHMuXG5mdW5jdGlvbiBkaWZmUHJvcGVydGllcyQxKGRvbUVsZW1lbnQsIHRhZywgbGFzdFJhd1Byb3BzLCBuZXh0UmF3UHJvcHMsIHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgbmV4dFJhd1Byb3BzKTtcbiAgfVxuXG4gIHZhciB1cGRhdGVQYXlsb2FkID0gbnVsbDtcblxuICB2YXIgbGFzdFByb3BzO1xuICB2YXIgbmV4dFByb3BzO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyhkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgbGFzdFByb3BzID0gZ2V0SG9zdFByb3BzJDEoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IGdldEhvc3RQcm9wcyQxKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgbGFzdFByb3BzID0gZ2V0SG9zdFByb3BzJDIoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IGdldEhvc3RQcm9wcyQyKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICBsYXN0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMyhkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzJDMoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBsYXN0UHJvcHMgPSBsYXN0UmF3UHJvcHM7XG4gICAgICBuZXh0UHJvcHMgPSBuZXh0UmF3UHJvcHM7XG4gICAgICBpZiAodHlwZW9mIGxhc3RQcm9wcy5vbkNsaWNrICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBuZXh0UHJvcHMub25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGNhc3QgbWF5IG5vdCBiZSBzb3VuZCBmb3IgU1ZHLCBNYXRoTUwgb3IgY3VzdG9tIGVsZW1lbnRzLlxuICAgICAgICB0cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudChkb21FbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIG5leHRQcm9wcywgZ2V0U3RhY2spO1xuXG4gIHZhciBwcm9wS2V5O1xuICB2YXIgc3R5bGVOYW1lO1xuICB2YXIgc3R5bGVVcGRhdGVzID0gbnVsbDtcbiAgZm9yIChwcm9wS2V5IGluIGxhc3RQcm9wcykge1xuICAgIGlmIChuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgIWxhc3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBsYXN0UHJvcHNbcHJvcEtleV0gPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgdmFyIGxhc3RTdHlsZSA9IGxhc3RQcm9wc1twcm9wS2V5XTtcbiAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RTdHlsZSkge1xuICAgICAgICBpZiAobGFzdFN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MIHx8IHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICAvLyBOb29wLiBUaGlzIGlzIGhhbmRsZWQgYnkgdGhlIGNsZWFyIHRleHQgbWVjaGFuaXNtLlxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEpIHtcbiAgICAgIC8vIE5vb3BcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IEFVVE9GT0NVUykge1xuICAgICAgLy8gTm9vcC4gSXQgZG9lc24ndCB3b3JrIG9uIHVwZGF0ZXMgYW55d2F5LlxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UuIElmIGFueSBsaXN0ZW5lciB1cGRhdGVzIHdlIG5lZWQgdG8gZW5zdXJlXG4gICAgICAvLyB0aGF0IHRoZSBcImN1cnJlbnRcIiBmaWJlciBwb2ludGVyIGdldHMgdXBkYXRlZCBzbyB3ZSBuZWVkIGEgY29tbWl0XG4gICAgICAvLyB0byB1cGRhdGUgdGhpcyBlbGVtZW50LlxuICAgICAgaWYgKCF1cGRhdGVQYXlsb2FkKSB7XG4gICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIGFsbCBvdGhlciBkZWxldGVkIHByb3BlcnRpZXMgd2UgYWRkIGl0IHRvIHRoZSBxdWV1ZS4gV2UgdXNlXG4gICAgICAvLyB0aGUgd2hpdGVsaXN0IGluIHRoZSBjb21taXQgcGhhc2UgaW5zdGVhZC5cbiAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCBudWxsKTtcbiAgICB9XG4gIH1cbiAgZm9yIChwcm9wS2V5IGluIG5leHRQcm9wcykge1xuICAgIHZhciBuZXh0UHJvcCA9IG5leHRQcm9wc1twcm9wS2V5XTtcbiAgICB2YXIgbGFzdFByb3AgPSBsYXN0UHJvcHMgIT0gbnVsbCA/IGxhc3RQcm9wc1twcm9wS2V5XSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBuZXh0UHJvcCA9PT0gbGFzdFByb3AgfHwgbmV4dFByb3AgPT0gbnVsbCAmJiBsYXN0UHJvcCA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIC8vIEZyZWV6ZSB0aGUgbmV4dCBzdHlsZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gYXNzdW1lIGl0IHdvbid0IGJlXG4gICAgICAgICAgLy8gbXV0YXRlZC4gV2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBmb3IgdGhpcyBpbiB0aGUgcGFzdC5cbiAgICAgICAgICBPYmplY3QuZnJlZXplKG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgIC8vIFVuc2V0IHN0eWxlcyBvbiBgbGFzdFByb3BgIGJ1dCBub3Qgb24gYG5leHRQcm9wYC5cbiAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbGFzdFByb3ApIHtcbiAgICAgICAgICBpZiAobGFzdFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiAoIW5leHRQcm9wIHx8ICFuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSkge1xuICAgICAgICAgICAgaWYgKCFzdHlsZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgc3R5bGVzIHRoYXQgY2hhbmdlZCBzaW5jZSBgbGFzdFByb3BgLlxuICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBuZXh0UHJvcCkge1xuICAgICAgICAgIGlmIChuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmIGxhc3RQcm9wW3N0eWxlTmFtZV0gIT09IG5leHRQcm9wW3N0eWxlTmFtZV0pIHtcbiAgICAgICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSBuZXh0UHJvcFtzdHlsZU5hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVsaWVzIG9uIGB1cGRhdGVTdHlsZXNCeUlEYCBub3QgbXV0YXRpbmcgYHN0eWxlVXBkYXRlc2AuXG4gICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgaWYgKCF1cGRhdGVQYXlsb2FkKSB7XG4gICAgICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZVBheWxvYWQucHVzaChwcm9wS2V5LCBzdHlsZVVwZGF0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlVXBkYXRlcyA9IG5leHRQcm9wO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwpIHtcbiAgICAgIHZhciBuZXh0SHRtbCA9IG5leHRQcm9wID8gbmV4dFByb3BbSFRNTF0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgbGFzdEh0bWwgPSBsYXN0UHJvcCA/IGxhc3RQcm9wW0hUTUxdIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKG5leHRIdG1sICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGxhc3RIdG1sICE9PSBuZXh0SHRtbCkge1xuICAgICAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCAnJyArIG5leHRIdG1sKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogSXQgbWlnaHQgYmUgdG9vIGxhdGUgdG8gY2xlYXIgdGhpcyBpZiB3ZSBoYXZlIGNoaWxkcmVuXG4gICAgICAgIC8vIGluc2VydGVkIGFscmVhZHkuXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgaWYgKGxhc3RQcm9wICE9PSBuZXh0UHJvcCAmJiAodHlwZW9mIG5leHRQcm9wID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSkge1xuICAgICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgJycgKyBuZXh0UHJvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSkge1xuICAgICAgLy8gTm9vcFxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgIC8vIFdlIGVhZ2VybHkgbGlzdGVuIHRvIHRoaXMgZXZlbiB0aG91Z2ggd2UgaGF2ZW4ndCBjb21taXR0ZWQgeWV0LlxuICAgICAgICBpZiAodHJ1ZSAmJiB0eXBlb2YgbmV4dFByb3AgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIocHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCBwcm9wS2V5KTtcbiAgICAgIH1cbiAgICAgIGlmICghdXBkYXRlUGF5bG9hZCAmJiBsYXN0UHJvcCAhPT0gbmV4dFByb3ApIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZS4gSWYgYW55IGxpc3RlbmVyIHVwZGF0ZXMgd2UgbmVlZCB0byBlbnN1cmVcbiAgICAgICAgLy8gdGhhdCB0aGUgXCJjdXJyZW50XCIgcHJvcHMgcG9pbnRlciBnZXRzIHVwZGF0ZWQgc28gd2UgbmVlZCBhIGNvbW1pdFxuICAgICAgICAvLyB0byB1cGRhdGUgdGhpcyBlbGVtZW50LlxuICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBhbnkgb3RoZXIgcHJvcGVydHkgd2UgYWx3YXlzIGFkZCBpdCB0byB0aGUgcXVldWUgYW5kIHRoZW4gd2VcbiAgICAgIC8vIGZpbHRlciBpdCBvdXQgdXNpbmcgdGhlIHdoaXRlbGlzdCBkdXJpbmcgdGhlIGNvbW1pdC5cbiAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgfVxuICB9XG4gIGlmIChzdHlsZVVwZGF0ZXMpIHtcbiAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2goU1RZTEUsIHN0eWxlVXBkYXRlcyk7XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZVBheWxvYWQ7XG59XG5cbi8vIEFwcGx5IHRoZSBkaWZmLlxuZnVuY3Rpb24gdXBkYXRlUHJvcGVydGllcyQxKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHRhZywgbGFzdFJhd1Byb3BzLCBuZXh0UmF3UHJvcHMpIHtcbiAgLy8gVXBkYXRlIGNoZWNrZWQgKmJlZm9yZSogbmFtZS5cbiAgLy8gSW4gdGhlIG1pZGRsZSBvZiBhbiB1cGRhdGUsIGl0IGlzIHBvc3NpYmxlIHRvIGhhdmUgbXVsdGlwbGUgY2hlY2tlZC5cbiAgLy8gV2hlbiBhIGNoZWNrZWQgcmFkaW8gdHJpZXMgdG8gY2hhbmdlIG5hbWUsIGJyb3dzZXIgbWFrZXMgYW5vdGhlciByYWRpbydzIGNoZWNrZWQgZmFsc2UuXG4gIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgbmV4dFJhd1Byb3BzLnR5cGUgPT09ICdyYWRpbycgJiYgbmV4dFJhd1Byb3BzLm5hbWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZUNoZWNrZWQoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgfVxuXG4gIHZhciB3YXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIGxhc3RSYXdQcm9wcyk7XG4gIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZywgbmV4dFJhd1Byb3BzKTtcbiAgLy8gQXBwbHkgdGhlIGRpZmYuXG4gIHVwZGF0ZURPTVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgd2FzQ3VzdG9tQ29tcG9uZW50VGFnLCBpc0N1c3RvbUNvbXBvbmVudFRhZyk7XG5cbiAgLy8gVE9ETzogRW5zdXJlIHRoYXQgYW4gdXBkYXRlIGdldHMgc2NoZWR1bGVkIGlmIGFueSBvZiB0aGUgc3BlY2lhbCBwcm9wc1xuICAvLyBjaGFuZ2VkLlxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIC8vIFVwZGF0ZSB0aGUgd3JhcHBlciBhcm91bmQgaW5wdXRzICphZnRlciogdXBkYXRpbmcgcHJvcHMuIFRoaXMgaGFzIHRvXG4gICAgICAvLyBoYXBwZW4gYWZ0ZXIgYHVwZGF0ZURPTVByb3BlcnRpZXNgLiBPdGhlcndpc2UgSFRNTDUgaW5wdXQgdmFsaWRhdGlvbnNcbiAgICAgIC8vIHJhaXNlIHdhcm5pbmdzIGFuZCBwcmV2ZW50IHRoZSBuZXcgdmFsdWUgZnJvbSBiZWluZyBhc3NpZ25lZC5cbiAgICAgIHVwZGF0ZVdyYXBwZXIoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIHVwZGF0ZVdyYXBwZXIkMShkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIC8vIDxzZWxlY3Q+IHZhbHVlIHVwZGF0ZSBuZWVkcyB0byBvY2N1ciBhZnRlciA8b3B0aW9uPiBjaGlsZHJlblxuICAgICAgLy8gcmVjb25jaWxpYXRpb25cbiAgICAgIHBvc3RVcGRhdGVXcmFwcGVyKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzJDEoZG9tRWxlbWVudCwgdGFnLCByYXdQcm9wcywgcGFyZW50TmFtZXNwYWNlLCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICB7XG4gICAgdmFyIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZyA9IHJhd1Byb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDFdID09PSB0cnVlO1xuICAgIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZywgcmF3UHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQodGFnLCByYXdQcm9wcyk7XG4gICAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnICYmICFkaWRXYXJuU2hhZHlET00gJiYgZG9tRWxlbWVudC5zaGFkeVJvb3QpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclcyBpcyB1c2luZyBzaGFkeSBET00uIFVzaW5nIHNoYWR5IERPTSB3aXRoIFJlYWN0IGNhbiAnICsgJ2NhdXNlIHRoaW5ncyB0byBicmVhayBzdWJ0bHkuJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDEoKSB8fCAnQSBjb21wb25lbnQnKTtcbiAgICAgIGRpZFdhcm5TaGFkeURPTSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogTWFrZSBzdXJlIHRoYXQgd2UgY2hlY2sgaXNNb3VudGVkIGJlZm9yZSBmaXJpbmcgYW55IG9mIHRoZXNlIGV2ZW50cy5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpZnJhbWUnOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BMb2FkJywgJ2xvYWQnLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICBjYXNlICdhdWRpbyc6XG4gICAgICAvLyBDcmVhdGUgbGlzdGVuZXIgZm9yIGVhY2ggbWVkaWEgZXZlbnRcbiAgICAgIGZvciAodmFyIGV2ZW50IGluIG1lZGlhRXZlbnRzKSB7XG4gICAgICAgIGlmIChtZWRpYUV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcbiAgICAgICAgICB0cmFwQnViYmxlZEV2ZW50KGV2ZW50LCBtZWRpYUV2ZW50c1tldmVudF0sIGRvbUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wRXJyb3InLCAnZXJyb3InLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ltZyc6XG4gICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wRXJyb3InLCAnZXJyb3InLCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcExvYWQnLCAnbG9hZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZm9ybSc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BSZXNldCcsICdyZXNldCcsIGRvbUVsZW1lbnQpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wU3VibWl0JywgJ3N1Ym1pdCcsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGV0YWlscyc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BUb2dnbGUnLCAndG9nZ2xlJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICB2YWxpZGF0ZVByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wSW52YWxpZCcsICdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG4gICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgIC8vIHRvIG9uQ2hhbmdlLiBFdmVuIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLlxuICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHJhd1Byb3BzLCBnZXRTdGFjayk7XG5cbiAge1xuICAgIHZhciBleHRyYUF0dHJpYnV0ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgIHZhciBhdHRyaWJ1dGVzID0gZG9tRWxlbWVudC5hdHRyaWJ1dGVzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVzW2ldLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAvLyBCdWlsdC1pbiBTU1IgYXR0cmlidXRlIGlzIHdoaXRlbGlzdGVkXG4gICAgICAgIGNhc2UgJ2RhdGEtcmVhY3Ryb290JzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gQ29udHJvbGxlZCBhdHRyaWJ1dGVzIGFyZSBub3QgdmFsaWRhdGVkXG4gICAgICAgIC8vIFRPRE86IE9ubHkgaWdub3JlIHRoZW0gb24gY29udHJvbGxlZCB0YWdzLlxuICAgICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NoZWNrZWQnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzZWxlY3RlZCc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gSW50ZW50aW9uYWxseSB1c2UgdGhlIG9yaWdpbmFsIG5hbWUuXG4gICAgICAgICAgLy8gU2VlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTA2NzYuXG4gICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lcy5hZGQoYXR0cmlidXRlc1tpXS5uYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgdXBkYXRlUGF5bG9hZCA9IG51bGw7XG4gIGZvciAodmFyIHByb3BLZXkgaW4gcmF3UHJvcHMpIHtcbiAgICBpZiAoIXJhd1Byb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIG5leHRQcm9wID0gcmF3UHJvcHNbcHJvcEtleV07XG4gICAgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICAvLyBGb3IgdGV4dCBjb250ZW50IGNoaWxkcmVuIHdlIGNvbXBhcmUgYWdhaW5zdCB0ZXh0Q29udGVudC4gVGhpc1xuICAgICAgLy8gbWlnaHQgbWF0Y2ggYWRkaXRpb25hbCBIVE1MIHRoYXQgaXMgaGlkZGVuIHdoZW4gd2UgcmVhZCBpdCB1c2luZ1xuICAgICAgLy8gdGV4dENvbnRlbnQuIEUuZy4gXCJmb29cIiB3aWxsIG1hdGNoIFwiZjxzcGFuPm9vPC9zcGFuPlwiIGJ1dCB0aGF0IHN0aWxsXG4gICAgICAvLyBzYXRpc2ZpZXMgb3VyIHJlcXVpcmVtZW50LiBPdXIgcmVxdWlyZW1lbnQgaXMgbm90IHRvIHByb2R1Y2UgcGVyZmVjdFxuICAgICAgLy8gSFRNTCBhbmQgYXR0cmlidXRlcy4gSWRlYWxseSB3ZSBzaG91bGQgcHJlc2VydmUgc3RydWN0dXJlIGJ1dCBpdCdzXG4gICAgICAvLyBvayBub3QgdG8gaWYgdGhlIHZpc2libGUgY29udGVudCBpcyBzdGlsbCBlbm91Z2ggdG8gaW5kaWNhdGUgd2hhdFxuICAgICAgLy8gZXZlbiBsaXN0ZW5lcnMgdGhlc2Ugbm9kZXMgbWlnaHQgYmUgd2lyZWQgdXAgdG8uXG4gICAgICAvLyBUT0RPOiBXYXJuIGlmIHRoZXJlIGlzIG1vcmUgdGhhbiBhIHNpbmdsZSB0ZXh0Tm9kZSBhcyBhIGNoaWxkLlxuICAgICAgLy8gVE9ETzogU2hvdWxkIHdlIHVzZSBkb21FbGVtZW50LmZpcnN0Q2hpbGQubm9kZVZhbHVlIHRvIGNvbXBhcmU/XG4gICAgICBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoZG9tRWxlbWVudC50ZXh0Q29udGVudCAhPT0gbmV4dFByb3ApIHtcbiAgICAgICAgICBpZiAodHJ1ZSAmJiAhc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgICAgICAgICB3YXJuRm9yVGV4dERpZmZlcmVuY2UoZG9tRWxlbWVudC50ZXh0Q29udGVudCwgbmV4dFByb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkID0gW0NISUxEUkVOLCBuZXh0UHJvcF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoZG9tRWxlbWVudC50ZXh0Q29udGVudCAhPT0gJycgKyBuZXh0UHJvcCkge1xuICAgICAgICAgIGlmICh0cnVlICYmICFzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgICAgICAgIHdhcm5Gb3JUZXh0RGlmZmVyZW5jZShkb21FbGVtZW50LnRleHRDb250ZW50LCBuZXh0UHJvcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbQ0hJTERSRU4sICcnICsgbmV4dFByb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHRydWUgJiYgdHlwZW9mIG5leHRQcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFZhbGlkYXRlIHRoYXQgdGhlIHByb3BlcnRpZXMgY29ycmVzcG9uZCB0byB0aGVpciBleHBlY3RlZCB2YWx1ZXMuXG4gICAgICB2YXIgc2VydmVyVmFsdWU7XG4gICAgICB2YXIgcHJvcGVydHlJbmZvO1xuICAgICAgaWYgKHN1cHByZXNzSHlkcmF0aW9uV2FybmluZykge1xuICAgICAgICAvLyBEb24ndCBib3RoZXIgY29tcGFyaW5nLiBXZSdyZSBpZ25vcmluZyBhbGwgdGhlc2Ugd2FybmluZ3MuXG4gICAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyB8fCBwcm9wS2V5ID09PSBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxIHx8XG4gICAgICAvLyBDb250cm9sbGVkIGF0dHJpYnV0ZXMgYXJlIG5vdCB2YWxpZGF0ZWRcbiAgICAgIC8vIFRPRE86IE9ubHkgaWdub3JlIHRoZW0gb24gY29udHJvbGxlZCB0YWdzLlxuICAgICAgcHJvcEtleSA9PT0gJ3ZhbHVlJyB8fCBwcm9wS2V5ID09PSAnY2hlY2tlZCcgfHwgcHJvcEtleSA9PT0gJ3NlbGVjdGVkJykge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICAgIHZhciByYXdIdG1sID0gbmV4dFByb3AgPyBuZXh0UHJvcFtIVE1MXSB8fCAnJyA6ICcnO1xuICAgICAgICB2YXIgc2VydmVySFRNTCA9IGRvbUVsZW1lbnQuaW5uZXJIVE1MO1xuICAgICAgICB2YXIgZXhwZWN0ZWRIVE1MID0gbm9ybWFsaXplSFRNTChkb21FbGVtZW50LCByYXdIdG1sKTtcbiAgICAgICAgaWYgKGV4cGVjdGVkSFRNTCAhPT0gc2VydmVySFRNTCkge1xuICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LCBzZXJ2ZXJIVE1MLCBleHBlY3RlZEhUTUwpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lc1snZGVsZXRlJ10ocHJvcEtleSk7XG4gICAgICAgIHZhciBleHBlY3RlZFN0eWxlID0gY3JlYXRlRGFuZ2Vyb3VzU3RyaW5nRm9yU3R5bGVzKG5leHRQcm9wKTtcbiAgICAgICAgc2VydmVyVmFsdWUgPSBkb21FbGVtZW50LmdldEF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgICAgaWYgKGV4cGVjdGVkU3R5bGUgIT09IHNlcnZlclZhbHVlKSB7XG4gICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlclZhbHVlLCBleHBlY3RlZFN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXNbJ2RlbGV0ZSddKHByb3BLZXkudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuXG4gICAgICAgIGlmIChuZXh0UHJvcCAhPT0gc2VydmVyVmFsdWUpIHtcbiAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVyVmFsdWUsIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzaG91bGRTZXRBdHRyaWJ1dGUocHJvcEtleSwgbmV4dFByb3ApKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8ocHJvcEtleSkpIHtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lc1snZGVsZXRlJ10ocHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG93bk5hbWVzcGFjZSA9IHBhcmVudE5hbWVzcGFjZTtcbiAgICAgICAgICBpZiAob3duTmFtZXNwYWNlID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgICAgICAgb3duTmFtZXNwYWNlID0gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHRhZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvd25OYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzWydkZWxldGUnXShwcm9wS2V5LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzWydkZWxldGUnXShwcm9wS2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VydmVyVmFsdWUgPSBnZXRWYWx1ZUZvckF0dHJpYnV0ZShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV4dFByb3AgIT09IHNlcnZlclZhbHVlKSB7XG4gICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlclZhbHVlLCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgIGlmIChleHRyYUF0dHJpYnV0ZU5hbWVzLnNpemUgPiAwICYmICFzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgIHdhcm5Gb3JFeHRyYUF0dHJpYnV0ZXMoZXh0cmFBdHRyaWJ1dGVOYW1lcyk7XG4gICAgfVxuICB9XG5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB3ZSBjaGVjayBpZiB0aGlzIGlzIHN0aWxsIHVubW91bnRlZCBvciBkbyBhbnkgY2xlYW5cbiAgICAgIC8vIHVwIG5lY2Vzc2FyeSBzaW5jZSB3ZSBuZXZlciBzdG9wIHRyYWNraW5nIGFueW1vcmUuXG4gICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAvLyBGb3IgaW5wdXQgYW5kIHRleHRhcmVhIHdlIGN1cnJlbnQgYWx3YXlzIHNldCB0aGUgdmFsdWUgcHJvcGVydHkgYXRcbiAgICAgIC8vIHBvc3QgbW91bnQgdG8gZm9yY2UgaXQgdG8gZGl2ZXJnZSBmcm9tIGF0dHJpYnV0ZXMuIEhvd2V2ZXIsIGZvclxuICAgICAgLy8gb3B0aW9uIGFuZCBzZWxlY3Qgd2UgZG9uJ3QgcXVpdGUgZG8gdGhlIHNhbWUgdGhpbmcgYW5kIHNlbGVjdFxuICAgICAgLy8gaXMgbm90IHJlc2lsaWVudCB0byB0aGUgRE9NIHN0YXRlIGNoYW5naW5nIHNvIHdlIGRvbid0IGRvIHRoYXQgaGVyZS5cbiAgICAgIC8vIFRPRE86IENvbnNpZGVyIG5vdCBkb2luZyB0aGlzIGZvciBpbnB1dCBhbmQgdGV4dGFyZWEuXG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHR5cGVvZiByYXdQcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KGRvbUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gdXBkYXRlUGF5bG9hZDtcbn1cblxuZnVuY3Rpb24gZGlmZkh5ZHJhdGVkVGV4dCQxKHRleHROb2RlLCB0ZXh0KSB7XG4gIHZhciBpc0RpZmZlcmVudCA9IHRleHROb2RlLm5vZGVWYWx1ZSAhPT0gdGV4dDtcbiAgcmV0dXJuIGlzRGlmZmVyZW50O1xufVxuXG5mdW5jdGlvbiB3YXJuRm9yVW5tYXRjaGVkVGV4dCQxKHRleHROb2RlLCB0ZXh0KSB7XG4gIHtcbiAgICB3YXJuRm9yVGV4dERpZmZlcmVuY2UodGV4dE5vZGUubm9kZVZhbHVlLCB0ZXh0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50JDEocGFyZW50Tm9kZSwgY2hpbGQpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0RpZCBub3QgZXhwZWN0IHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSA8JXM+IGluIDwlcz4uJywgY2hpbGQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSwgcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0JDEocGFyZW50Tm9kZSwgY2hpbGQpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0RpZCBub3QgZXhwZWN0IHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gdGhlIHRleHQgbm9kZSBcIiVzXCIgaW4gPCVzPi4nLCBjaGlsZC5ub2RlVmFsdWUsIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50JDEocGFyZW50Tm9kZSwgdGFnLCBwcm9wcykge1xuICB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRXhwZWN0ZWQgc2VydmVyIEhUTUwgdG8gY29udGFpbiBhIG1hdGNoaW5nIDwlcz4gaW4gPCVzPi4nLCB0YWcsIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0JDEocGFyZW50Tm9kZSwgdGV4dCkge1xuICB7XG4gICAgaWYgKHRleHQgPT09ICcnKSB7XG4gICAgICAvLyBXZSBleHBlY3QgdG8gaW5zZXJ0IGVtcHR5IHRleHQgbm9kZXMgc2luY2UgdGhleSdyZSBub3QgcmVwcmVzZW50ZWQgaW5cbiAgICAgIC8vIHRoZSBIVE1MLlxuICAgICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgc3BlY2lhbCBjYXNlIGlmIHdlIGNhbiBqdXN0IGF2b2lkIGluc2VydGluZyBlbXB0eVxuICAgICAgLy8gdGV4dCBub2Rlcy5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRXhwZWN0ZWQgc2VydmVyIEhUTUwgdG8gY29udGFpbiBhIG1hdGNoaW5nIHRleHQgbm9kZSBmb3IgXCIlc1wiIGluIDwlcz4uJywgdGV4dCwgcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlKGRvbUVsZW1lbnQsIHRhZywgcHJvcHMpIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDEoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMyhkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMihkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICByZXR1cm47XG4gIH1cbn1cblxudmFyIFJlYWN0RE9NRmliZXJDb21wb25lbnQgPSBPYmplY3QuZnJlZXplKHtcblx0Y3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxuXHRjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUkMSxcblx0c2V0SW5pdGlhbFByb3BlcnRpZXM6IHNldEluaXRpYWxQcm9wZXJ0aWVzJDEsXG5cdGRpZmZQcm9wZXJ0aWVzOiBkaWZmUHJvcGVydGllcyQxLFxuXHR1cGRhdGVQcm9wZXJ0aWVzOiB1cGRhdGVQcm9wZXJ0aWVzJDEsXG5cdGRpZmZIeWRyYXRlZFByb3BlcnRpZXM6IGRpZmZIeWRyYXRlZFByb3BlcnRpZXMkMSxcblx0ZGlmZkh5ZHJhdGVkVGV4dDogZGlmZkh5ZHJhdGVkVGV4dCQxLFxuXHR3YXJuRm9yVW5tYXRjaGVkVGV4dDogd2FybkZvclVubWF0Y2hlZFRleHQkMSxcblx0d2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudDogd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudCQxLFxuXHR3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0OiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0JDEsXG5cdHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudDogd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50JDEsXG5cdHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dDogd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0JDEsXG5cdHJlc3RvcmVDb250cm9sbGVkU3RhdGU6IHJlc3RvcmVDb250cm9sbGVkU3RhdGVcbn0pO1xuXG4vLyBUT0RPOiBkaXJlY3QgaW1wb3J0cyBsaWtlIHNvbWUtcGFja2FnZS9zcmMvKiBhcmUgYmFkLiBGaXggbWUuXG52YXIgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ2ID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuXG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gZW1wdHlGdW5jdGlvbjtcblxue1xuICAvLyBUaGlzIHZhbGlkYXRpb24gY29kZSB3YXMgd3JpdHRlbiBiYXNlZCBvbiB0aGUgSFRNTDUgcGFyc2luZyBzcGVjOlxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuICAvL1xuICAvLyBOb3RlOiB0aGlzIGRvZXMgbm90IGNhdGNoIGFsbCBpbnZhbGlkIG5lc3RpbmcsIG5vciBkb2VzIGl0IHRyeSB0byAoYXMgaXQnc1xuICAvLyBub3QgY2xlYXIgd2hhdCBwcmFjdGljYWwgYmVuZWZpdCBkb2luZyBzbyBwcm92aWRlcyk7IGluc3RlYWQsIHdlIHdhcm4gb25seVxuICAvLyBmb3IgY2FzZXMgd2hlcmUgdGhlIHBhcnNlciB3aWxsIGdpdmUgYSBwYXJzZSB0cmVlIGRpZmZlcmluZyBmcm9tIHdoYXQgUmVhY3RcbiAgLy8gaW50ZW5kZWQuIEZvciBleGFtcGxlLCA8Yj48ZGl2PjwvZGl2PjwvYj4gaXMgaW52YWxpZCBidXQgd2UgZG9uJ3Qgd2FyblxuICAvLyBiZWNhdXNlIGl0IHN0aWxsIHBhcnNlcyBjb3JyZWN0bHk7IHdlIGRvIHdhcm4gZm9yIG90aGVyIGNhc2VzIGxpa2UgbmVzdGVkXG4gIC8vIDxwPiB0YWdzIHdoZXJlIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHNlY29uZCBlbGVtZW50IGltcGxpY2l0bHkgY2xvc2VzIHRoZVxuICAvLyBmaXJzdCwgY2F1c2luZyBhIGNvbmZ1c2luZyBtZXNzLlxuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3NwZWNpYWxcbiAgdmFyIHNwZWNpYWxUYWdzID0gWydhZGRyZXNzJywgJ2FwcGxldCcsICdhcmVhJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnYmFzZScsICdiYXNlZm9udCcsICdiZ3NvdW5kJywgJ2Jsb2NrcXVvdGUnLCAnYm9keScsICdicicsICdidXR0b24nLCAnY2FwdGlvbicsICdjZW50ZXInLCAnY29sJywgJ2NvbGdyb3VwJywgJ2RkJywgJ2RldGFpbHMnLCAnZGlyJywgJ2RpdicsICdkbCcsICdkdCcsICdlbWJlZCcsICdmaWVsZHNldCcsICdmaWdjYXB0aW9uJywgJ2ZpZ3VyZScsICdmb290ZXInLCAnZm9ybScsICdmcmFtZScsICdmcmFtZXNldCcsICdoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNicsICdoZWFkJywgJ2hlYWRlcicsICdoZ3JvdXAnLCAnaHInLCAnaHRtbCcsICdpZnJhbWUnLCAnaW1nJywgJ2lucHV0JywgJ2lzaW5kZXgnLCAnbGknLCAnbGluaycsICdsaXN0aW5nJywgJ21haW4nLCAnbWFycXVlZScsICdtZW51JywgJ21lbnVpdGVtJywgJ21ldGEnLCAnbmF2JywgJ25vZW1iZWQnLCAnbm9mcmFtZXMnLCAnbm9zY3JpcHQnLCAnb2JqZWN0JywgJ29sJywgJ3AnLCAncGFyYW0nLCAncGxhaW50ZXh0JywgJ3ByZScsICdzY3JpcHQnLCAnc2VjdGlvbicsICdzZWxlY3QnLCAnc291cmNlJywgJ3N0eWxlJywgJ3N1bW1hcnknLCAndGFibGUnLCAndGJvZHknLCAndGQnLCAndGVtcGxhdGUnLCAndGV4dGFyZWEnLCAndGZvb3QnLCAndGgnLCAndGhlYWQnLCAndGl0bGUnLCAndHInLCAndHJhY2snLCAndWwnLCAnd2JyJywgJ3htcCddO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXG4gIHZhciBpblNjb3BlVGFncyA9IFsnYXBwbGV0JywgJ2NhcHRpb24nLCAnaHRtbCcsICd0YWJsZScsICd0ZCcsICd0aCcsICdtYXJxdWVlJywgJ29iamVjdCcsICd0ZW1wbGF0ZScsXG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaHRtbC1pbnRlZ3JhdGlvbi1wb2ludFxuICAvLyBUT0RPOiBEaXN0aW5ndWlzaCBieSBuYW1lc3BhY2UgaGVyZSAtLSBmb3IgPHRpdGxlPiwgaW5jbHVkaW5nIGl0IGhlcmVcbiAgLy8gZXJycyBvbiB0aGUgc2lkZSBvZiBmZXdlciB3YXJuaW5nc1xuICAnZm9yZWlnbk9iamVjdCcsICdkZXNjJywgJ3RpdGxlJ107XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tYnV0dG9uLXNjb3BlXG4gIHZhciBidXR0b25TY29wZVRhZ3MgPSBpblNjb3BlVGFncy5jb25jYXQoWydidXR0b24nXSk7XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjZ2VuZXJhdGUtaW1wbGllZC1lbmQtdGFnc1xuICB2YXIgaW1wbGllZEVuZFRhZ3MgPSBbJ2RkJywgJ2R0JywgJ2xpJywgJ29wdGlvbicsICdvcHRncm91cCcsICdwJywgJ3JwJywgJ3J0J107XG5cbiAgdmFyIGVtcHR5QW5jZXN0b3JJbmZvID0ge1xuICAgIGN1cnJlbnQ6IG51bGwsXG5cbiAgICBmb3JtVGFnOiBudWxsLFxuICAgIGFUYWdJblNjb3BlOiBudWxsLFxuICAgIGJ1dHRvblRhZ0luU2NvcGU6IG51bGwsXG4gICAgbm9iclRhZ0luU2NvcGU6IG51bGwsXG4gICAgcFRhZ0luQnV0dG9uU2NvcGU6IG51bGwsXG5cbiAgICBsaXN0SXRlbVRhZ0F1dG9jbG9zaW5nOiBudWxsLFxuICAgIGRsSXRlbVRhZ0F1dG9jbG9zaW5nOiBudWxsXG4gIH07XG5cbiAgdmFyIHVwZGF0ZWRBbmNlc3RvckluZm8kMSA9IGZ1bmN0aW9uIChvbGRJbmZvLCB0YWcsIGluc3RhbmNlKSB7XG4gICAgdmFyIGFuY2VzdG9ySW5mbyA9IF9hc3NpZ24oe30sIG9sZEluZm8gfHwgZW1wdHlBbmNlc3RvckluZm8pO1xuICAgIHZhciBpbmZvID0geyB0YWc6IHRhZywgaW5zdGFuY2U6IGluc3RhbmNlIH07XG5cbiAgICBpZiAoaW5TY29wZVRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSkge1xuICAgICAgYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChidXR0b25TY29wZVRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSkge1xuICAgICAgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTZWUgcnVsZXMgZm9yICdsaScsICdkZCcsICdkdCcgc3RhcnQgdGFncyBpblxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHlcbiAgICBpZiAoc3BlY2lhbFRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSAmJiB0YWcgIT09ICdhZGRyZXNzJyAmJiB0YWcgIT09ICdkaXYnICYmIHRhZyAhPT0gJ3AnKSB7XG4gICAgICBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3NpbmcgPSBudWxsO1xuICAgIH1cblxuICAgIGFuY2VzdG9ySW5mby5jdXJyZW50ID0gaW5mbztcblxuICAgIGlmICh0YWcgPT09ICdmb3JtJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmZvcm1UYWcgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnYScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdidXR0b24nKSB7XG4gICAgICBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdub2JyJykge1xuICAgICAgYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ3AnKSB7XG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnbGknKSB7XG4gICAgICBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdkZCcgfHwgdGFnID09PSAnZHQnKSB7XG4gICAgICBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3NpbmcgPSBpbmZvO1xuICAgIH1cblxuICAgIHJldHVybiBhbmNlc3RvckluZm87XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlclxuICAgKi9cbiAgdmFyIGlzVGFnVmFsaWRXaXRoUGFyZW50ID0gZnVuY3Rpb24gKHRhZywgcGFyZW50VGFnKSB7XG4gICAgLy8gRmlyc3QsIGxldCdzIGNoZWNrIGlmIHdlJ3JlIGluIGFuIHVudXN1YWwgcGFyc2luZyBtb2RlLi4uXG4gICAgc3dpdGNoIChwYXJlbnRUYWcpIHtcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnNlbGVjdFxuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ29wdGlvbicgfHwgdGFnID09PSAnb3B0Z3JvdXAnIHx8IHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIGNhc2UgJ29wdGdyb3VwJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ29wdGlvbicgfHwgdGFnID09PSAnI3RleHQnO1xuICAgICAgLy8gU3RyaWN0bHkgc3BlYWtpbmcsIHNlZWluZyBhbiA8b3B0aW9uPiBkb2Vzbid0IG1lYW4gd2UncmUgaW4gYSA8c2VsZWN0PlxuICAgICAgLy8gYnV0XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnI3RleHQnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGRcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmNhcHRpb25cbiAgICAgIC8vIE5vIHNwZWNpYWwgYmVoYXZpb3Igc2luY2UgdGhlc2UgcnVsZXMgZmFsbCBiYWNrIHRvIFwiaW4gYm9keVwiIG1vZGUgZm9yXG4gICAgICAvLyBhbGwgZXhjZXB0IHNwZWNpYWwgdGFibGUgbm9kZXMgd2hpY2ggY2F1c2UgYmFkIHBhcnNpbmcgYmVoYXZpb3IgYW55d2F5LlxuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50clxuICAgICAgY2FzZSAndHInOlxuICAgICAgICByZXR1cm4gdGFnID09PSAndGgnIHx8IHRhZyA9PT0gJ3RkJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50Ym9keVxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAndHInIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmNvbGdyb3VwXG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdjb2wnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRhYmxlXG4gICAgICBjYXNlICd0YWJsZSc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdjYXB0aW9uJyB8fCB0YWcgPT09ICdjb2xncm91cCcgfHwgdGFnID09PSAndGJvZHknIHx8IHRhZyA9PT0gJ3Rmb290JyB8fCB0YWcgPT09ICd0aGVhZCcgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluaGVhZFxuICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdiYXNlJyB8fCB0YWcgPT09ICdiYXNlZm9udCcgfHwgdGFnID09PSAnYmdzb3VuZCcgfHwgdGFnID09PSAnbGluaycgfHwgdGFnID09PSAnbWV0YScgfHwgdGFnID09PSAndGl0bGUnIHx8IHRhZyA9PT0gJ25vc2NyaXB0JyB8fCB0YWcgPT09ICdub2ZyYW1lcycgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VtYW50aWNzLmh0bWwjdGhlLWh0bWwtZWxlbWVudFxuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdoZWFkJyB8fCB0YWcgPT09ICdib2R5JztcbiAgICAgIGNhc2UgJyNkb2N1bWVudCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdodG1sJztcbiAgICB9XG5cbiAgICAvLyBQcm9iYWJseSBpbiB0aGUgXCJpbiBib2R5XCIgcGFyc2luZyBtb2RlLCBzbyB3ZSBvdXRsYXcgb25seSB0YWcgY29tYm9zXG4gICAgLy8gd2hlcmUgdGhlIHBhcnNpbmcgcnVsZXMgY2F1c2UgaW1wbGljaXQgb3BlbnMgb3IgY2xvc2VzIHRvIGJlIGFkZGVkLlxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHlcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSAnaDEnOlxuICAgICAgY2FzZSAnaDInOlxuICAgICAgY2FzZSAnaDMnOlxuICAgICAgY2FzZSAnaDQnOlxuICAgICAgY2FzZSAnaDUnOlxuICAgICAgY2FzZSAnaDYnOlxuICAgICAgICByZXR1cm4gcGFyZW50VGFnICE9PSAnaDEnICYmIHBhcmVudFRhZyAhPT0gJ2gyJyAmJiBwYXJlbnRUYWcgIT09ICdoMycgJiYgcGFyZW50VGFnICE9PSAnaDQnICYmIHBhcmVudFRhZyAhPT0gJ2g1JyAmJiBwYXJlbnRUYWcgIT09ICdoNic7XG5cbiAgICAgIGNhc2UgJ3JwJzpcbiAgICAgIGNhc2UgJ3J0JzpcbiAgICAgICAgcmV0dXJuIGltcGxpZWRFbmRUYWdzLmluZGV4T2YocGFyZW50VGFnKSA9PT0gLTE7XG5cbiAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgY2FzZSAnY2FwdGlvbic6XG4gICAgICBjYXNlICdjb2wnOlxuICAgICAgY2FzZSAnY29sZ3JvdXAnOlxuICAgICAgY2FzZSAnZnJhbWUnOlxuICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICBjYXNlICdodG1sJzpcbiAgICAgIGNhc2UgJ3Rib2R5JzpcbiAgICAgIGNhc2UgJ3RkJzpcbiAgICAgIGNhc2UgJ3Rmb290JzpcbiAgICAgIGNhc2UgJ3RoJzpcbiAgICAgIGNhc2UgJ3RoZWFkJzpcbiAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgLy8gVGhlc2UgdGFncyBhcmUgb25seSB2YWxpZCB3aXRoIGEgZmV3IHBhcmVudHMgdGhhdCBoYXZlIHNwZWNpYWwgY2hpbGRcbiAgICAgICAgLy8gcGFyc2luZyBydWxlcyAtLSBpZiB3ZSdyZSBkb3duIGhlcmUsIHRoZW4gbm9uZSBvZiB0aG9zZSBtYXRjaGVkIGFuZFxuICAgICAgICAvLyBzbyB3ZSBhbGxvdyBpdCBvbmx5IGlmIHdlIGRvbid0IGtub3cgd2hhdCB0aGUgcGFyZW50IGlzLCBhcyBhbGwgb3RoZXJcbiAgICAgICAgLy8gY2FzZXMgYXJlIGludmFsaWQuXG4gICAgICAgIHJldHVybiBwYXJlbnRUYWcgPT0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL1xuICB2YXIgZmluZEludmFsaWRBbmNlc3RvckZvclRhZyA9IGZ1bmN0aW9uICh0YWcsIGFuY2VzdG9ySW5mbykge1xuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlICdhZGRyZXNzJzpcbiAgICAgIGNhc2UgJ2FydGljbGUnOlxuICAgICAgY2FzZSAnYXNpZGUnOlxuICAgICAgY2FzZSAnYmxvY2txdW90ZSc6XG4gICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgY2FzZSAnZGV0YWlscyc6XG4gICAgICBjYXNlICdkaWFsb2cnOlxuICAgICAgY2FzZSAnZGlyJzpcbiAgICAgIGNhc2UgJ2Rpdic6XG4gICAgICBjYXNlICdkbCc6XG4gICAgICBjYXNlICdmaWVsZHNldCc6XG4gICAgICBjYXNlICdmaWdjYXB0aW9uJzpcbiAgICAgIGNhc2UgJ2ZpZ3VyZSc6XG4gICAgICBjYXNlICdmb290ZXInOlxuICAgICAgY2FzZSAnaGVhZGVyJzpcbiAgICAgIGNhc2UgJ2hncm91cCc6XG4gICAgICBjYXNlICdtYWluJzpcbiAgICAgIGNhc2UgJ21lbnUnOlxuICAgICAgY2FzZSAnbmF2JzpcbiAgICAgIGNhc2UgJ29sJzpcbiAgICAgIGNhc2UgJ3AnOlxuICAgICAgY2FzZSAnc2VjdGlvbic6XG4gICAgICBjYXNlICdzdW1tYXJ5JzpcbiAgICAgIGNhc2UgJ3VsJzpcbiAgICAgIGNhc2UgJ3ByZSc6XG4gICAgICBjYXNlICdsaXN0aW5nJzpcbiAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgIGNhc2UgJ2hyJzpcbiAgICAgIGNhc2UgJ3htcCc6XG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmZvcm1UYWcgfHwgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdsaSc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnZGQnOlxuICAgICAgY2FzZSAnZHQnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nO1xuXG4gICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAvLyBTcGVjIHNheXMgc29tZXRoaW5nIGFib3V0IHN0b3JpbmcgYSBsaXN0IG9mIG1hcmtlcnMsIGJ1dCBpdCBzb3VuZHNcbiAgICAgICAgLy8gZXF1aXZhbGVudCB0byB0aGlzIGNoZWNrLlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdub2JyJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICB2YXIgZGlkV2FybiA9IHt9O1xuXG4gIHZhbGlkYXRlRE9NTmVzdGluZyA9IGZ1bmN0aW9uIChjaGlsZFRhZywgY2hpbGRUZXh0LCBhbmNlc3RvckluZm8pIHtcbiAgICBhbmNlc3RvckluZm8gPSBhbmNlc3RvckluZm8gfHwgZW1wdHlBbmNlc3RvckluZm87XG4gICAgdmFyIHBhcmVudEluZm8gPSBhbmNlc3RvckluZm8uY3VycmVudDtcbiAgICB2YXIgcGFyZW50VGFnID0gcGFyZW50SW5mbyAmJiBwYXJlbnRJbmZvLnRhZztcblxuICAgIGlmIChjaGlsZFRleHQgIT0gbnVsbCkge1xuICAgICAgd2FybmluZyhjaGlsZFRhZyA9PSBudWxsLCAndmFsaWRhdGVET01OZXN0aW5nOiB3aGVuIGNoaWxkVGV4dCBpcyBwYXNzZWQsIGNoaWxkVGFnIHNob3VsZCBiZSBudWxsJyk7XG4gICAgICBjaGlsZFRhZyA9ICcjdGV4dCc7XG4gICAgfVxuXG4gICAgdmFyIGludmFsaWRQYXJlbnQgPSBpc1RhZ1ZhbGlkV2l0aFBhcmVudChjaGlsZFRhZywgcGFyZW50VGFnKSA/IG51bGwgOiBwYXJlbnRJbmZvO1xuICAgIHZhciBpbnZhbGlkQW5jZXN0b3IgPSBpbnZhbGlkUGFyZW50ID8gbnVsbCA6IGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcoY2hpbGRUYWcsIGFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIGludmFsaWRQYXJlbnRPckFuY2VzdG9yID0gaW52YWxpZFBhcmVudCB8fCBpbnZhbGlkQW5jZXN0b3I7XG4gICAgaWYgKCFpbnZhbGlkUGFyZW50T3JBbmNlc3Rvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhbmNlc3RvclRhZyA9IGludmFsaWRQYXJlbnRPckFuY2VzdG9yLnRhZztcbiAgICB2YXIgYWRkZW5kdW0gPSBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDYoKTtcblxuICAgIHZhciB3YXJuS2V5ID0gISFpbnZhbGlkUGFyZW50ICsgJ3wnICsgY2hpbGRUYWcgKyAnfCcgKyBhbmNlc3RvclRhZyArICd8JyArIGFkZGVuZHVtO1xuICAgIGlmIChkaWRXYXJuW3dhcm5LZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5bd2FybktleV0gPSB0cnVlO1xuXG4gICAgdmFyIHRhZ0Rpc3BsYXlOYW1lID0gY2hpbGRUYWc7XG4gICAgdmFyIHdoaXRlc3BhY2VJbmZvID0gJyc7XG4gICAgaWYgKGNoaWxkVGFnID09PSAnI3RleHQnKSB7XG4gICAgICBpZiAoL1xcUy8udGVzdChjaGlsZFRleHQpKSB7XG4gICAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJ1RleHQgbm9kZXMnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFnRGlzcGxheU5hbWUgPSAnV2hpdGVzcGFjZSB0ZXh0IG5vZGVzJztcbiAgICAgICAgd2hpdGVzcGFjZUluZm8gPSBcIiBNYWtlIHN1cmUgeW91IGRvbid0IGhhdmUgYW55IGV4dHJhIHdoaXRlc3BhY2UgYmV0d2VlbiB0YWdzIG9uIFwiICsgJ2VhY2ggbGluZSBvZiB5b3VyIHNvdXJjZSBjb2RlLic7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJzwnICsgY2hpbGRUYWcgKyAnPic7XG4gICAgfVxuXG4gICAgaWYgKGludmFsaWRQYXJlbnQpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG4gICAgICBpZiAoYW5jZXN0b3JUYWcgPT09ICd0YWJsZScgJiYgY2hpbGRUYWcgPT09ICd0cicpIHtcbiAgICAgICAgaW5mbyArPSAnIEFkZCBhIDx0Ym9keT4gdG8geW91ciBjb2RlIHRvIG1hdGNoIHRoZSBET00gdHJlZSBnZW5lcmF0ZWQgYnkgJyArICd0aGUgYnJvd3Nlci4nO1xuICAgICAgfVxuICAgICAgd2FybmluZyhmYWxzZSwgJ3ZhbGlkYXRlRE9NTmVzdGluZyguLi4pOiAlcyBjYW5ub3QgYXBwZWFyIGFzIGEgY2hpbGQgb2YgPCVzPi4lcyVzJXMnLCB0YWdEaXNwbGF5TmFtZSwgYW5jZXN0b3JUYWcsIHdoaXRlc3BhY2VJbmZvLCBpbmZvLCBhZGRlbmR1bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGRlc2NlbmRhbnQgb2YgJyArICc8JXM+LiVzJywgdGFnRGlzcGxheU5hbWUsIGFuY2VzdG9yVGFnLCBhZGRlbmR1bSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRPRE86IHR1cm4gdGhpcyBpbnRvIGEgbmFtZWQgZXhwb3J0XG4gIHZhbGlkYXRlRE9NTmVzdGluZy51cGRhdGVkQW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyQxO1xuXG4gIC8vIEZvciB0ZXN0aW5nXG4gIHZhbGlkYXRlRE9NTmVzdGluZy5pc1RhZ1ZhbGlkSW5Db250ZXh0ID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XG4gICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvO1xuICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLmN1cnJlbnQ7XG4gICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudEluZm8gJiYgcGFyZW50SW5mby50YWc7XG4gICAgcmV0dXJuIGlzVGFnVmFsaWRXaXRoUGFyZW50KHRhZywgcGFyZW50VGFnKSAmJiAhZmluZEludmFsaWRBbmNlc3RvckZvclRhZyh0YWcsIGFuY2VzdG9ySW5mbyk7XG4gIH07XG59XG5cbnZhciB2YWxpZGF0ZURPTU5lc3RpbmckMSA9IHZhbGlkYXRlRE9NTmVzdGluZztcblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGNyZWF0ZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50JDE7XG52YXIgY3JlYXRlVGV4dE5vZGUgPSBjcmVhdGVUZXh0Tm9kZSQxO1xudmFyIHNldEluaXRpYWxQcm9wZXJ0aWVzID0gc2V0SW5pdGlhbFByb3BlcnRpZXMkMTtcbnZhciBkaWZmUHJvcGVydGllcyA9IGRpZmZQcm9wZXJ0aWVzJDE7XG52YXIgdXBkYXRlUHJvcGVydGllcyA9IHVwZGF0ZVByb3BlcnRpZXMkMTtcbnZhciBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzID0gZGlmZkh5ZHJhdGVkUHJvcGVydGllcyQxO1xudmFyIGRpZmZIeWRyYXRlZFRleHQgPSBkaWZmSHlkcmF0ZWRUZXh0JDE7XG52YXIgd2FybkZvclVubWF0Y2hlZFRleHQgPSB3YXJuRm9yVW5tYXRjaGVkVGV4dCQxO1xudmFyIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQgPSB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50JDE7XG52YXIgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dCA9IHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQkMTtcbnZhciB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQgPSB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQkMTtcbnZhciB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQgPSB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQkMTtcbnZhciB1cGRhdGVkQW5jZXN0b3JJbmZvID0gdmFsaWRhdGVET01OZXN0aW5nJDEudXBkYXRlZEFuY2VzdG9ySW5mbztcbnZhciBwcmVjYWNoZUZpYmVyTm9kZSA9IHByZWNhY2hlRmliZXJOb2RlJDE7XG52YXIgdXBkYXRlRmliZXJQcm9wcyA9IHVwZGF0ZUZpYmVyUHJvcHMkMTtcblxuXG57XG4gIHZhciBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyA9ICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnO1xuICBpZiAodHlwZW9mIE1hcCAhPT0gJ2Z1bmN0aW9uJyB8fCBNYXAucHJvdG90eXBlID09IG51bGwgfHwgdHlwZW9mIE1hcC5wcm90b3R5cGUuZm9yRWFjaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgU2V0ICE9PSAnZnVuY3Rpb24nIHx8IFNldC5wcm90b3R5cGUgPT0gbnVsbCB8fCB0eXBlb2YgU2V0LnByb3RvdHlwZS5jbGVhciAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgU2V0LnByb3RvdHlwZS5mb3JFYWNoICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0IGRlcGVuZHMgb24gTWFwIGFuZCBTZXQgYnVpbHQtaW4gdHlwZXMuIE1ha2Ugc3VyZSB0aGF0IHlvdSBsb2FkIGEgJyArICdwb2x5ZmlsbCBpbiBvbGRlciBicm93c2Vycy4gaHR0cDovL2ZiLm1lL3JlYWN0LXBvbHlmaWxscycpO1xuICB9XG59XG5cbmluamVjdGlvbiQzLmluamVjdEZpYmVyQ29udHJvbGxlZEhvc3RDb21wb25lbnQoUmVhY3RET01GaWJlckNvbXBvbmVudCk7XG5cbnZhciBldmVudHNFbmFibGVkID0gbnVsbDtcbnZhciBzZWxlY3Rpb25JbmZvcm1hdGlvbiA9IG51bGw7XG5cbi8qKlxuICogVHJ1ZSBpZiB0aGUgc3VwcGxpZWQgRE9NIG5vZGUgaXMgYSB2YWxpZCBub2RlIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZSBUaGUgY2FuZGlkYXRlIERPTSBub2RlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgRE9NIGlzIGEgdmFsaWQgRE9NIG5vZGUuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZENvbnRhaW5lcihub2RlKSB7XG4gIHJldHVybiAhIShub2RlICYmIChub2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSAmJiBub2RlLm5vZGVWYWx1ZSA9PT0gJyByZWFjdC1tb3VudC1wb2ludC11bnN0YWJsZSAnKSk7XG59XG5cbmZ1bmN0aW9uIGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgaWYgKCFjb250YWluZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUpIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmRvY3VtZW50RWxlbWVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkSHlkcmF0ZUR1ZVRvTGVnYWN5SGV1cmlzdGljKGNvbnRhaW5lcikge1xuICB2YXIgcm9vdEVsZW1lbnQgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgcmV0dXJuICEhKHJvb3RFbGVtZW50ICYmIHJvb3RFbGVtZW50Lm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgJiYgcm9vdEVsZW1lbnQuaGFzQXR0cmlidXRlKFJPT1RfQVRUUklCVVRFX05BTUUpKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkQXV0b0ZvY3VzSG9zdENvbXBvbmVudCh0eXBlLCBwcm9wcykge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdidXR0b24nOlxuICAgIGNhc2UgJ2lucHV0JzpcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIHJldHVybiAhIXByb3BzLmF1dG9Gb2N1cztcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBET01SZW5kZXJlciA9IHJlYWN0UmVjb25jaWxlcih7XG4gIGdldFJvb3RIb3N0Q29udGV4dDogZnVuY3Rpb24gKHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICAgIHZhciB0eXBlID0gdm9pZCAwO1xuICAgIHZhciBuYW1lc3BhY2UgPSB2b2lkIDA7XG4gICAgdmFyIG5vZGVUeXBlID0gcm9vdENvbnRhaW5lckluc3RhbmNlLm5vZGVUeXBlO1xuICAgIHN3aXRjaCAobm9kZVR5cGUpIHtcbiAgICAgIGNhc2UgRE9DVU1FTlRfTk9ERTpcbiAgICAgIGNhc2UgRE9DVU1FTlRfRlJBR01FTlRfTk9ERTpcbiAgICAgICAge1xuICAgICAgICAgIHR5cGUgPSBub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSA/ICcjZG9jdW1lbnQnIDogJyNmcmFnbWVudCc7XG4gICAgICAgICAgdmFyIHJvb3QgPSByb290Q29udGFpbmVySW5zdGFuY2UuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgIG5hbWVzcGFjZSA9IHJvb3QgPyByb290Lm5hbWVzcGFjZVVSSSA6IGdldENoaWxkTmFtZXNwYWNlKG51bGwsICcnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBjb250YWluZXIgPSBub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFID8gcm9vdENvbnRhaW5lckluc3RhbmNlLnBhcmVudE5vZGUgOiByb290Q29udGFpbmVySW5zdGFuY2U7XG4gICAgICAgICAgdmFyIG93bk5hbWVzcGFjZSA9IGNvbnRhaW5lci5uYW1lc3BhY2VVUkkgfHwgbnVsbDtcbiAgICAgICAgICB0eXBlID0gY29udGFpbmVyLnRhZ05hbWU7XG4gICAgICAgICAgbmFtZXNwYWNlID0gZ2V0Q2hpbGROYW1lc3BhY2Uob3duTmFtZXNwYWNlLCB0eXBlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICB7XG4gICAgICB2YXIgdmFsaWRhdGVkVGFnID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIF9hbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKG51bGwsIHZhbGlkYXRlZFRhZywgbnVsbCk7XG4gICAgICByZXR1cm4geyBuYW1lc3BhY2U6IG5hbWVzcGFjZSwgYW5jZXN0b3JJbmZvOiBfYW5jZXN0b3JJbmZvIH07XG4gICAgfVxuICAgIHJldHVybiBuYW1lc3BhY2U7XG4gIH0sXG4gIGdldENoaWxkSG9zdENvbnRleHQ6IGZ1bmN0aW9uIChwYXJlbnRIb3N0Q29udGV4dCwgdHlwZSkge1xuICAgIHtcbiAgICAgIHZhciBwYXJlbnRIb3N0Q29udGV4dERldiA9IHBhcmVudEhvc3RDb250ZXh0O1xuICAgICAgdmFyIF9uYW1lc3BhY2UgPSBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnRIb3N0Q29udGV4dERldi5uYW1lc3BhY2UsIHR5cGUpO1xuICAgICAgdmFyIF9hbmNlc3RvckluZm8yID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhwYXJlbnRIb3N0Q29udGV4dERldi5hbmNlc3RvckluZm8sIHR5cGUsIG51bGwpO1xuICAgICAgcmV0dXJuIHsgbmFtZXNwYWNlOiBfbmFtZXNwYWNlLCBhbmNlc3RvckluZm86IF9hbmNlc3RvckluZm8yIH07XG4gICAgfVxuICAgIHZhciBwYXJlbnROYW1lc3BhY2UgPSBwYXJlbnRIb3N0Q29udGV4dDtcbiAgICByZXR1cm4gZ2V0Q2hpbGROYW1lc3BhY2UocGFyZW50TmFtZXNwYWNlLCB0eXBlKTtcbiAgfSxcbiAgZ2V0UHVibGljSW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSxcbiAgcHJlcGFyZUZvckNvbW1pdDogZnVuY3Rpb24gKCkge1xuICAgIGV2ZW50c0VuYWJsZWQgPSBpc0VuYWJsZWQoKTtcbiAgICBzZWxlY3Rpb25JbmZvcm1hdGlvbiA9IGdldFNlbGVjdGlvbkluZm9ybWF0aW9uKCk7XG4gICAgc2V0RW5hYmxlZChmYWxzZSk7XG4gIH0sXG4gIHJlc2V0QWZ0ZXJDb21taXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXN0b3JlU2VsZWN0aW9uKHNlbGVjdGlvbkluZm9ybWF0aW9uKTtcbiAgICBzZWxlY3Rpb25JbmZvcm1hdGlvbiA9IG51bGw7XG4gICAgc2V0RW5hYmxlZChldmVudHNFbmFibGVkKTtcbiAgICBldmVudHNFbmFibGVkID0gbnVsbDtcbiAgfSxcbiAgY3JlYXRlSW5zdGFuY2U6IGZ1bmN0aW9uICh0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCwgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAgIHZhciBwYXJlbnROYW1lc3BhY2UgPSB2b2lkIDA7XG4gICAge1xuICAgICAgLy8gVE9ETzogdGFrZSBuYW1lc3BhY2UgaW50byBhY2NvdW50IHdoZW4gdmFsaWRhdGluZy5cbiAgICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuICAgICAgdmFsaWRhdGVET01OZXN0aW5nJDEodHlwZSwgbnVsbCwgaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvKTtcbiAgICAgIGlmICh0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIHN0cmluZyA9ICcnICsgcHJvcHMuY2hpbGRyZW47XG4gICAgICAgIHZhciBvd25BbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbywgdHlwZSwgbnVsbCk7XG4gICAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyQxKG51bGwsIHN0cmluZywgb3duQW5jZXN0b3JJbmZvKTtcbiAgICAgIH1cbiAgICAgIHBhcmVudE5hbWVzcGFjZSA9IGhvc3RDb250ZXh0RGV2Lm5hbWVzcGFjZTtcbiAgICB9XG4gICAgdmFyIGRvbUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIHBhcmVudE5hbWVzcGFjZSk7XG4gICAgcHJlY2FjaGVGaWJlck5vZGUoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgZG9tRWxlbWVudCk7XG4gICAgdXBkYXRlRmliZXJQcm9wcyhkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgcmV0dXJuIGRvbUVsZW1lbnQ7XG4gIH0sXG4gIGFwcGVuZEluaXRpYWxDaGlsZDogZnVuY3Rpb24gKHBhcmVudEluc3RhbmNlLCBjaGlsZCkge1xuICAgIHBhcmVudEluc3RhbmNlLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgfSxcbiAgZmluYWxpemVJbml0aWFsQ2hpbGRyZW46IGZ1bmN0aW9uIChkb21FbGVtZW50LCB0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSB7XG4gICAgc2V0SW5pdGlhbFByb3BlcnRpZXMoZG9tRWxlbWVudCwgdHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG4gICAgcmV0dXJuIHNob3VsZEF1dG9Gb2N1c0hvc3RDb21wb25lbnQodHlwZSwgcHJvcHMpO1xuICB9LFxuICBwcmVwYXJlVXBkYXRlOiBmdW5jdGlvbiAoZG9tRWxlbWVudCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0KSB7XG4gICAge1xuICAgICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgICBpZiAodHlwZW9mIG5ld1Byb3BzLmNoaWxkcmVuICE9PSB0eXBlb2Ygb2xkUHJvcHMuY2hpbGRyZW4gJiYgKHR5cGVvZiBuZXdQcm9wcy5jaGlsZHJlbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld1Byb3BzLmNoaWxkcmVuID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgdmFyIHN0cmluZyA9ICcnICsgbmV3UHJvcHMuY2hpbGRyZW47XG4gICAgICAgIHZhciBvd25BbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbywgdHlwZSwgbnVsbCk7XG4gICAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyQxKG51bGwsIHN0cmluZywgb3duQW5jZXN0b3JJbmZvKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpZmZQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKTtcbiAgfSxcbiAgc2hvdWxkU2V0VGV4dENvbnRlbnQ6IGZ1bmN0aW9uICh0eXBlLCBwcm9wcykge1xuICAgIHJldHVybiB0eXBlID09PSAndGV4dGFyZWEnIHx8IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT09ICdvYmplY3QnICYmIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICE9PSBudWxsICYmIHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWwgPT09ICdzdHJpbmcnO1xuICB9LFxuICBzaG91bGREZXByaW9yaXRpemVTdWJ0cmVlOiBmdW5jdGlvbiAodHlwZSwgcHJvcHMpIHtcbiAgICByZXR1cm4gISFwcm9wcy5oaWRkZW47XG4gIH0sXG4gIGNyZWF0ZVRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHRleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICB7XG4gICAgICB2YXIgaG9zdENvbnRleHREZXYgPSBob3N0Q29udGV4dDtcbiAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyQxKG51bGwsIHRleHQsIGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbyk7XG4gICAgfVxuICAgIHZhciB0ZXh0Tm9kZSA9IGNyZWF0ZVRleHROb2RlKHRleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG4gICAgcHJlY2FjaGVGaWJlck5vZGUoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgdGV4dE5vZGUpO1xuICAgIHJldHVybiB0ZXh0Tm9kZTtcbiAgfSxcblxuXG4gIG5vdzogbm93LFxuXG4gIG11dGF0aW9uOiB7XG4gICAgY29tbWl0TW91bnQ6IGZ1bmN0aW9uIChkb21FbGVtZW50LCB0eXBlLCBuZXdQcm9wcywgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAgICAgZG9tRWxlbWVudC5mb2N1cygpO1xuICAgIH0sXG4gICAgY29tbWl0VXBkYXRlOiBmdW5jdGlvbiAoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gICAgICAvLyBVcGRhdGUgdGhlIHByb3BzIGhhbmRsZSBzbyB0aGF0IHdlIGtub3cgd2hpY2ggcHJvcHMgYXJlIHRoZSBvbmVzIHdpdGhcbiAgICAgIC8vIHdpdGggY3VycmVudCBldmVudCBoYW5kbGVycy5cbiAgICAgIHVwZGF0ZUZpYmVyUHJvcHMoZG9tRWxlbWVudCwgbmV3UHJvcHMpO1xuICAgICAgLy8gQXBwbHkgdGhlIGRpZmYgdG8gdGhlIERPTSBub2RlLlxuICAgICAgdXBkYXRlUHJvcGVydGllcyhkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMpO1xuICAgIH0sXG4gICAgcmVzZXRUZXh0Q29udGVudDogZnVuY3Rpb24gKGRvbUVsZW1lbnQpIHtcbiAgICAgIGRvbUVsZW1lbnQudGV4dENvbnRlbnQgPSAnJztcbiAgICB9LFxuICAgIGNvbW1pdFRleHRVcGRhdGU6IGZ1bmN0aW9uICh0ZXh0SW5zdGFuY2UsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICAgIHRleHRJbnN0YW5jZS5ub2RlVmFsdWUgPSBuZXdUZXh0O1xuICAgIH0sXG4gICAgYXBwZW5kQ2hpbGQ6IGZ1bmN0aW9uIChwYXJlbnRJbnN0YW5jZSwgY2hpbGQpIHtcbiAgICAgIHBhcmVudEluc3RhbmNlLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICB9LFxuICAgIGFwcGVuZENoaWxkVG9Db250YWluZXI6IGZ1bmN0aW9uIChjb250YWluZXIsIGNoaWxkKSB7XG4gICAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICAgICAgY29udGFpbmVyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkLCBjb250YWluZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGluc2VydEJlZm9yZTogZnVuY3Rpb24gKHBhcmVudEluc3RhbmNlLCBjaGlsZCwgYmVmb3JlQ2hpbGQpIHtcbiAgICAgIHBhcmVudEluc3RhbmNlLmluc2VydEJlZm9yZShjaGlsZCwgYmVmb3JlQ2hpbGQpO1xuICAgIH0sXG4gICAgaW5zZXJ0SW5Db250YWluZXJCZWZvcmU6IGZ1bmN0aW9uIChjb250YWluZXIsIGNoaWxkLCBiZWZvcmVDaGlsZCkge1xuICAgICAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICAgIGNvbnRhaW5lci5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZCwgYmVmb3JlQ2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLmluc2VydEJlZm9yZShjaGlsZCwgYmVmb3JlQ2hpbGQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVtb3ZlQ2hpbGQ6IGZ1bmN0aW9uIChwYXJlbnRJbnN0YW5jZSwgY2hpbGQpIHtcbiAgICAgIHBhcmVudEluc3RhbmNlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICB9LFxuICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcjogZnVuY3Rpb24gKGNvbnRhaW5lciwgY2hpbGQpIHtcbiAgICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgICBjb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBoeWRyYXRpb246IHtcbiAgICBjYW5IeWRyYXRlSW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0YW5jZSwgdHlwZSwgcHJvcHMpIHtcbiAgICAgIGlmIChpbnN0YW5jZS5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFIHx8IHR5cGUudG9Mb3dlckNhc2UoKSAhPT0gaW5zdGFuY2Uubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgaGFzIG5vdyBiZWVuIHJlZmluZWQgdG8gYW4gZWxlbWVudCBub2RlLlxuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH0sXG4gICAgY2FuSHlkcmF0ZVRleHRJbnN0YW5jZTogZnVuY3Rpb24gKGluc3RhbmNlLCB0ZXh0KSB7XG4gICAgICBpZiAodGV4dCA9PT0gJycgfHwgaW5zdGFuY2Uubm9kZVR5cGUgIT09IFRFWFRfTk9ERSkge1xuICAgICAgICAvLyBFbXB0eSBzdHJpbmdzIGFyZSBub3QgcGFyc2VkIGJ5IEhUTUwgc28gdGhlcmUgd29uJ3QgYmUgYSBjb3JyZWN0IG1hdGNoIGhlcmUuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgLy8gVGhpcyBoYXMgbm93IGJlZW4gcmVmaW5lZCB0byBhIHRleHQgbm9kZS5cbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9LFxuICAgIGdldE5leHRIeWRyYXRhYmxlU2libGluZzogZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICB2YXIgbm9kZSA9IGluc3RhbmNlLm5leHRTaWJsaW5nO1xuICAgICAgLy8gU2tpcCBub24taHlkcmF0YWJsZSBub2Rlcy5cbiAgICAgIHdoaWxlIChub2RlICYmIG5vZGUubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSAmJiBub2RlLm5vZGVUeXBlICE9PSBURVhUX05PREUpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuICAgIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkOiBmdW5jdGlvbiAocGFyZW50SW5zdGFuY2UpIHtcbiAgICAgIHZhciBuZXh0ID0gcGFyZW50SW5zdGFuY2UuZmlyc3RDaGlsZDtcbiAgICAgIC8vIFNraXAgbm9uLWh5ZHJhdGFibGUgbm9kZXMuXG4gICAgICB3aGlsZSAobmV4dCAmJiBuZXh0Lm5vZGVUeXBlICE9PSBFTEVNRU5UX05PREUgJiYgbmV4dC5ub2RlVHlwZSAhPT0gVEVYVF9OT0RFKSB7XG4gICAgICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfSxcbiAgICBoeWRyYXRlSW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0YW5jZSwgdHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICAgIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIGluc3RhbmNlKTtcbiAgICAgIC8vIFRPRE86IFBvc3NpYmx5IGRlZmVyIHRoaXMgdW50aWwgdGhlIGNvbW1pdCBwaGFzZSB3aGVyZSBhbGwgdGhlIGV2ZW50c1xuICAgICAgLy8gZ2V0IGF0dGFjaGVkLlxuICAgICAgdXBkYXRlRmliZXJQcm9wcyhpbnN0YW5jZSwgcHJvcHMpO1xuICAgICAgdmFyIHBhcmVudE5hbWVzcGFjZSA9IHZvaWQgMDtcbiAgICAgIHtcbiAgICAgICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgICAgIHBhcmVudE5hbWVzcGFjZSA9IGhvc3RDb250ZXh0RGV2Lm5hbWVzcGFjZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzKGluc3RhbmNlLCB0eXBlLCBwcm9wcywgcGFyZW50TmFtZXNwYWNlLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuICAgIH0sXG4gICAgaHlkcmF0ZVRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHRleHRJbnN0YW5jZSwgdGV4dCwgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAgICAgcHJlY2FjaGVGaWJlck5vZGUoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgdGV4dEluc3RhbmNlKTtcbiAgICAgIHJldHVybiBkaWZmSHlkcmF0ZWRUZXh0KHRleHRJbnN0YW5jZSwgdGV4dCk7XG4gICAgfSxcbiAgICBkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50Q29udGFpbmVyLCB0ZXh0SW5zdGFuY2UsIHRleHQpIHtcbiAgICAgIHtcbiAgICAgICAgd2FybkZvclVubWF0Y2hlZFRleHQodGV4dEluc3RhbmNlLCB0ZXh0KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uIChwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHRleHRJbnN0YW5jZSwgdGV4dCkge1xuICAgICAgaWYgKHRydWUgJiYgcGFyZW50UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddICE9PSB0cnVlKSB7XG4gICAgICAgIHdhcm5Gb3JVbm1hdGNoZWRUZXh0KHRleHRJbnN0YW5jZSwgdGV4dCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RIeWRyYXRlQ29udGFpbmVySW5zdGFuY2U6IGZ1bmN0aW9uIChwYXJlbnRDb250YWluZXIsIGluc3RhbmNlKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChpbnN0YW5jZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQocGFyZW50Q29udGFpbmVyLCBpbnN0YW5jZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dChwYXJlbnRDb250YWluZXIsIGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZGlkTm90SHlkcmF0ZUluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCBpbnN0YW5jZSkge1xuICAgICAgaWYgKHRydWUgJiYgcGFyZW50UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddICE9PSB0cnVlKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQocGFyZW50SW5zdGFuY2UsIGluc3RhbmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0KHBhcmVudEluc3RhbmNlLCBpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2U6IGZ1bmN0aW9uIChwYXJlbnRDb250YWluZXIsIHR5cGUsIHByb3BzKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudChwYXJlbnRDb250YWluZXIsIHR5cGUsIHByb3BzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVyVGV4dEluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50Q29udGFpbmVyLCB0ZXh0KSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dChwYXJlbnRDb250YWluZXIsIHRleHQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgdHlwZSwgcHJvcHMpIHtcbiAgICAgIGlmICh0cnVlICYmIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSAhPT0gdHJ1ZSkge1xuICAgICAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQocGFyZW50SW5zdGFuY2UsIHR5cGUsIHByb3BzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0KSB7XG4gICAgICBpZiAodHJ1ZSAmJiBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklOR10gIT09IHRydWUpIHtcbiAgICAgICAgd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0KHBhcmVudEluc3RhbmNlLCB0ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgc2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrOiBySUMsXG4gIGNhbmNlbERlZmVycmVkQ2FsbGJhY2s6IGNJQyxcblxuICB1c2VTeW5jU2NoZWR1bGluZzogIWVuYWJsZUFzeW5jU2NoZWR1bGluZ0J5RGVmYXVsdEluUmVhY3RET01cbn0pO1xuXG5pbmplY3Rpb24kNC5pbmplY3RGaWJlckJhdGNoZWRVcGRhdGVzKERPTVJlbmRlcmVyLmJhdGNoZWRVcGRhdGVzKTtcblxudmFyIHdhcm5lZEFib3V0SHlkcmF0ZUFQSSA9IGZhbHNlO1xuXG5mdW5jdGlvbiByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIGNoaWxkcmVuLCBjb250YWluZXIsIGZvcmNlSHlkcmF0ZSwgY2FsbGJhY2spIHtcbiAgIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSA/IGludmFyaWFudChmYWxzZSwgJ1RhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiB2b2lkIDA7XG5cbiAge1xuICAgIGlmIChjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lciAmJiBjb250YWluZXIubm9kZVR5cGUgIT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgdmFyIGhvc3RJbnN0YW5jZSA9IERPTVJlbmRlcmVyLmZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzKGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyLmN1cnJlbnQpO1xuICAgICAgaWYgKGhvc3RJbnN0YW5jZSkge1xuICAgICAgICB3YXJuaW5nKGhvc3RJbnN0YW5jZS5wYXJlbnROb2RlID09PSBjb250YWluZXIsICdyZW5kZXIoLi4uKTogSXQgbG9va3MgbGlrZSB0aGUgUmVhY3QtcmVuZGVyZWQgY29udGVudCBvZiB0aGlzICcgKyAnY29udGFpbmVyIHdhcyByZW1vdmVkIHdpdGhvdXQgdXNpbmcgUmVhY3QuIFRoaXMgaXMgbm90ICcgKyAnc3VwcG9ydGVkIGFuZCB3aWxsIGNhdXNlIGVycm9ycy4gSW5zdGVhZCwgY2FsbCAnICsgJ1JlYWN0RE9NLnVubW91bnRDb21wb25lbnRBdE5vZGUgdG8gZW1wdHkgYSBjb250YWluZXIuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGlzUm9vdFJlbmRlcmVkQnlTb21lUmVhY3QgPSAhIWNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyO1xuICAgIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICB2YXIgaGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSAhIShyb290RWwgJiYgZ2V0SW5zdGFuY2VGcm9tTm9kZSQxKHJvb3RFbCkpO1xuXG4gICAgd2FybmluZyghaGFzTm9uUm9vdFJlYWN0Q2hpbGQgfHwgaXNSb290UmVuZGVyZWRCeVNvbWVSZWFjdCwgJ3JlbmRlciguLi4pOiBSZXBsYWNpbmcgUmVhY3QtcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBhIG5ldyByb290ICcgKyAnY29tcG9uZW50LiBJZiB5b3UgaW50ZW5kZWQgdG8gdXBkYXRlIHRoZSBjaGlsZHJlbiBvZiB0aGlzIG5vZGUsICcgKyAneW91IHNob3VsZCBpbnN0ZWFkIGhhdmUgdGhlIGV4aXN0aW5nIGNoaWxkcmVuIHVwZGF0ZSB0aGVpciBzdGF0ZSAnICsgJ2FuZCByZW5kZXIgdGhlIG5ldyBjb21wb25lbnRzIGluc3RlYWQgb2YgY2FsbGluZyBSZWFjdERPTS5yZW5kZXIuJyk7XG5cbiAgICB3YXJuaW5nKGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFIHx8ICFjb250YWluZXIudGFnTmFtZSB8fCBjb250YWluZXIudGFnTmFtZS50b1VwcGVyQ2FzZSgpICE9PSAnQk9EWScsICdyZW5kZXIoKTogUmVuZGVyaW5nIGNvbXBvbmVudHMgZGlyZWN0bHkgaW50byBkb2N1bWVudC5ib2R5IGlzICcgKyAnZGlzY291cmFnZWQsIHNpbmNlIGl0cyBjaGlsZHJlbiBhcmUgb2Z0ZW4gbWFuaXB1bGF0ZWQgYnkgdGhpcmQtcGFydHkgJyArICdzY3JpcHRzIGFuZCBicm93c2VyIGV4dGVuc2lvbnMuIFRoaXMgbWF5IGxlYWQgdG8gc3VidGxlICcgKyAncmVjb25jaWxpYXRpb24gaXNzdWVzLiBUcnkgcmVuZGVyaW5nIGludG8gYSBjb250YWluZXIgZWxlbWVudCBjcmVhdGVkICcgKyAnZm9yIHlvdXIgYXBwLicpO1xuICB9XG5cbiAgdmFyIHJvb3QgPSBjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcjtcbiAgaWYgKCFyb290KSB7XG4gICAgdmFyIHNob3VsZEh5ZHJhdGUgPSBmb3JjZUh5ZHJhdGUgfHwgc2hvdWxkSHlkcmF0ZUR1ZVRvTGVnYWN5SGV1cmlzdGljKGNvbnRhaW5lcik7XG4gICAgLy8gRmlyc3QgY2xlYXIgYW55IGV4aXN0aW5nIGNvbnRlbnQuXG4gICAgaWYgKCFzaG91bGRIeWRyYXRlKSB7XG4gICAgICB2YXIgd2FybmVkID0gZmFsc2U7XG4gICAgICB2YXIgcm9vdFNpYmxpbmcgPSB2b2lkIDA7XG4gICAgICB3aGlsZSAocm9vdFNpYmxpbmcgPSBjb250YWluZXIubGFzdENoaWxkKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoIXdhcm5lZCAmJiByb290U2libGluZy5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICYmIHJvb3RTaWJsaW5nLmhhc0F0dHJpYnV0ZShST09UX0FUVFJJQlVURV9OQU1FKSkge1xuICAgICAgICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdyZW5kZXIoKTogVGFyZ2V0IG5vZGUgaGFzIG1hcmt1cCByZW5kZXJlZCBieSBSZWFjdCwgYnV0IHRoZXJlICcgKyAnYXJlIHVucmVsYXRlZCBub2RlcyBhcyB3ZWxsLiBUaGlzIGlzIG1vc3QgY29tbW9ubHkgY2F1c2VkIGJ5ICcgKyAnd2hpdGUtc3BhY2UgaW5zZXJ0ZWQgYXJvdW5kIHNlcnZlci1yZW5kZXJlZCBtYXJrdXAuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChyb290U2libGluZyk7XG4gICAgICB9XG4gICAgfVxuICAgIHtcbiAgICAgIGlmIChzaG91bGRIeWRyYXRlICYmICFmb3JjZUh5ZHJhdGUgJiYgIXdhcm5lZEFib3V0SHlkcmF0ZUFQSSkge1xuICAgICAgICB3YXJuZWRBYm91dEh5ZHJhdGVBUEkgPSB0cnVlO1xuICAgICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJ3JlbmRlcigpOiBDYWxsaW5nIFJlYWN0RE9NLnJlbmRlcigpIHRvIGh5ZHJhdGUgc2VydmVyLXJlbmRlcmVkIG1hcmt1cCAnICsgJ3dpbGwgc3RvcCB3b3JraW5nIGluIFJlYWN0IHYxNy4gUmVwbGFjZSB0aGUgUmVhY3RET00ucmVuZGVyKCkgY2FsbCAnICsgJ3dpdGggUmVhY3RET00uaHlkcmF0ZSgpIGlmIHlvdSB3YW50IFJlYWN0IHRvIGF0dGFjaCB0byB0aGUgc2VydmVyIEhUTUwuJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBuZXdSb290ID0gRE9NUmVuZGVyZXIuY3JlYXRlQ29udGFpbmVyKGNvbnRhaW5lciwgc2hvdWxkSHlkcmF0ZSk7XG4gICAgcm9vdCA9IGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyID0gbmV3Um9vdDtcbiAgICAvLyBJbml0aWFsIG1vdW50IHNob3VsZCBub3QgYmUgYmF0Y2hlZC5cbiAgICBET01SZW5kZXJlci51bmJhdGNoZWRVcGRhdGVzKGZ1bmN0aW9uICgpIHtcbiAgICAgIERPTVJlbmRlcmVyLnVwZGF0ZUNvbnRhaW5lcihjaGlsZHJlbiwgbmV3Um9vdCwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjayk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgRE9NUmVuZGVyZXIudXBkYXRlQ29udGFpbmVyKGNoaWxkcmVuLCByb290LCBwYXJlbnRDb21wb25lbnQsIGNhbGxiYWNrKTtcbiAgfVxuICByZXR1cm4gRE9NUmVuZGVyZXIuZ2V0UHVibGljUm9vdEluc3RhbmNlKHJvb3QpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGNvbnRhaW5lcikge1xuICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuXG4gICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBpbnZhcmlhbnQoZmFsc2UsICdUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogdm9pZCAwO1xuICAvLyBUT0RPOiBwYXNzIFJlYWN0RE9NIHBvcnRhbCBpbXBsZW1lbnRhdGlvbiBhcyB0aGlyZCBhcmd1bWVudFxuICByZXR1cm4gY3JlYXRlUG9ydGFsJDEoY2hpbGRyZW4sIGNvbnRhaW5lciwgbnVsbCwga2V5KTtcbn1cblxuZnVuY3Rpb24gUmVhY3RSb290KGNvbnRhaW5lciwgaHlkcmF0ZSkge1xuICB2YXIgcm9vdCA9IERPTVJlbmRlcmVyLmNyZWF0ZUNvbnRhaW5lcihjb250YWluZXIsIGh5ZHJhdGUpO1xuICB0aGlzLl9yZWFjdFJvb3RDb250YWluZXIgPSByb290O1xufVxuUmVhY3RSb290LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoY2hpbGRyZW4sIGNhbGxiYWNrKSB7XG4gIHZhciByb290ID0gdGhpcy5fcmVhY3RSb290Q29udGFpbmVyO1xuICBET01SZW5kZXJlci51cGRhdGVDb250YWluZXIoY2hpbGRyZW4sIHJvb3QsIG51bGwsIGNhbGxiYWNrKTtcbn07XG5SZWFjdFJvb3QucHJvdG90eXBlLnVubW91bnQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdmFyIHJvb3QgPSB0aGlzLl9yZWFjdFJvb3RDb250YWluZXI7XG4gIERPTVJlbmRlcmVyLnVwZGF0ZUNvbnRhaW5lcihudWxsLCByb290LCBudWxsLCBjYWxsYmFjayk7XG59O1xuXG52YXIgUmVhY3RET00gPSB7XG4gIGNyZWF0ZVBvcnRhbDogY3JlYXRlUG9ydGFsLFxuXG4gIGZpbmRET01Ob2RlOiBmdW5jdGlvbiAoY29tcG9uZW50T3JFbGVtZW50KSB7XG4gICAge1xuICAgICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICAgIGlmIChvd25lciAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSBvd25lci5zdGF0ZU5vZGUuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyO1xuICAgICAgICB3YXJuaW5nKHdhcm5lZEFib3V0UmVmc0luUmVuZGVyLCAnJXMgaXMgYWNjZXNzaW5nIGZpbmRET01Ob2RlIGluc2lkZSBpdHMgcmVuZGVyKCkuICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lKG93bmVyKSB8fCAnQSBjb21wb25lbnQnKTtcbiAgICAgICAgb3duZXIuc3RhdGVOb2RlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRPckVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRPckVsZW1lbnQubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgcmV0dXJuIGNvbXBvbmVudE9yRWxlbWVudDtcbiAgICB9XG5cbiAgICB2YXIgaW5zdCA9IGdldChjb21wb25lbnRPckVsZW1lbnQpO1xuICAgIGlmIChpbnN0KSB7XG4gICAgICByZXR1cm4gRE9NUmVuZGVyZXIuZmluZEhvc3RJbnN0YW5jZShpbnN0KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbXBvbmVudE9yRWxlbWVudC5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCBhcHBlYXJzIHRvIGJlIG5laXRoZXIgUmVhY3RDb21wb25lbnQgbm9yIERPTU5vZGUuIEtleXM6ICVzJywgT2JqZWN0LmtleXMoY29tcG9uZW50T3JFbGVtZW50KSk7XG4gICAgfVxuICB9LFxuICBoeWRyYXRlOiBmdW5jdGlvbiAoZWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgIC8vIFRPRE86IHRocm93IG9yIHdhcm4gaWYgd2UgY291bGRuJ3QgaHlkcmF0ZT9cbiAgICByZXR1cm4gcmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgZWxlbWVudCwgY29udGFpbmVyLCB0cnVlLCBjYWxsYmFjayk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gcmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgZWxlbWVudCwgY29udGFpbmVyLCBmYWxzZSwgY2FsbGJhY2spO1xuICB9LFxuICB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjogZnVuY3Rpb24gKHBhcmVudENvbXBvbmVudCwgZWxlbWVudCwgY29udGFpbmVyTm9kZSwgY2FsbGJhY2spIHtcbiAgICAhKHBhcmVudENvbXBvbmVudCAhPSBudWxsICYmIGhhcyhwYXJlbnRDb21wb25lbnQpKSA/IGludmFyaWFudChmYWxzZSwgJ3BhcmVudENvbXBvbmVudCBtdXN0IGJlIGEgdmFsaWQgUmVhY3QgQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgZWxlbWVudCwgY29udGFpbmVyTm9kZSwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgfSxcbiAgdW5tb3VudENvbXBvbmVudEF0Tm9kZTogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBpbnZhcmlhbnQoZmFsc2UsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiB2b2lkIDA7XG5cbiAgICBpZiAoY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHJvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICB2YXIgcmVuZGVyZWRCeURpZmZlcmVudFJlYWN0ID0gcm9vdEVsICYmICFnZXRJbnN0YW5jZUZyb21Ob2RlJDEocm9vdEVsKTtcbiAgICAgICAgd2FybmluZyghcmVuZGVyZWRCeURpZmZlcmVudFJlYWN0LCBcInVubW91bnRDb21wb25lbnRBdE5vZGUoKTogVGhlIG5vZGUgeW91J3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCBcIiArICd3YXMgcmVuZGVyZWQgYnkgYW5vdGhlciBjb3B5IG9mIFJlYWN0LicpO1xuICAgICAgfVxuXG4gICAgICAvLyBVbm1vdW50IHNob3VsZCBub3QgYmUgYmF0Y2hlZC5cbiAgICAgIERPTVJlbmRlcmVyLnVuYmF0Y2hlZFVwZGF0ZXMoZnVuY3Rpb24gKCkge1xuICAgICAgICByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihudWxsLCBudWxsLCBjb250YWluZXIsIGZhbHNlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgLy8gSWYgeW91IGNhbGwgdW5tb3VudENvbXBvbmVudEF0Tm9kZSB0d2ljZSBpbiBxdWljayBzdWNjZXNzaW9uLCB5b3UnbGxcbiAgICAgIC8vIGdldCBgdHJ1ZWAgdHdpY2UuIFRoYXQncyBwcm9iYWJseSBmaW5lP1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIF9yb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgdmFyIGhhc05vblJvb3RSZWFjdENoaWxkID0gISEoX3Jvb3RFbCAmJiBnZXRJbnN0YW5jZUZyb21Ob2RlJDEoX3Jvb3RFbCkpO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBjb250YWluZXIgaXRzZWxmIGlzIGEgUmVhY3Qgcm9vdCBub2RlLlxuICAgICAgICB2YXIgaXNDb250YWluZXJSZWFjdFJvb3QgPSBjb250YWluZXIubm9kZVR5cGUgPT09IDEgJiYgaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIucGFyZW50Tm9kZSkgJiYgISFjb250YWluZXIucGFyZW50Tm9kZS5fcmVhY3RSb290Q29udGFpbmVyO1xuXG4gICAgICAgIHdhcm5pbmcoIWhhc05vblJvb3RSZWFjdENoaWxkLCBcInVubW91bnRDb21wb25lbnRBdE5vZGUoKTogVGhlIG5vZGUgeW91J3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCBcIiArICd3YXMgcmVuZGVyZWQgYnkgUmVhY3QgYW5kIGlzIG5vdCBhIHRvcC1sZXZlbCBjb250YWluZXIuICVzJywgaXNDb250YWluZXJSZWFjdFJvb3QgPyAnWW91IG1heSBoYXZlIGFjY2lkZW50YWxseSBwYXNzZWQgaW4gYSBSZWFjdCByb290IG5vZGUgaW5zdGVhZCAnICsgJ29mIGl0cyBjb250YWluZXIuJyA6ICdJbnN0ZWFkLCBoYXZlIHRoZSBwYXJlbnQgY29tcG9uZW50IHVwZGF0ZSBpdHMgc3RhdGUgYW5kICcgKyAncmVyZW5kZXIgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoaXMgY29tcG9uZW50LicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG5cbiAgLy8gVGVtcG9yYXJ5IGFsaWFzIHNpbmNlIHdlIGFscmVhZHkgc2hpcHBlZCBSZWFjdCAxNiBSQyB3aXRoIGl0LlxuICAvLyBUT0RPOiByZW1vdmUgaW4gUmVhY3QgMTcuXG4gIHVuc3RhYmxlX2NyZWF0ZVBvcnRhbDogY3JlYXRlUG9ydGFsLFxuXG4gIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOiBiYXRjaGVkVXBkYXRlcyxcblxuICB1bnN0YWJsZV9kZWZlcnJlZFVwZGF0ZXM6IERPTVJlbmRlcmVyLmRlZmVycmVkVXBkYXRlcyxcblxuICBmbHVzaFN5bmM6IERPTVJlbmRlcmVyLmZsdXNoU3luYyxcblxuICBfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDoge1xuICAgIC8vIEZvciBUYXBFdmVudFBsdWdpbiB3aGljaCBpcyBwb3B1bGFyIGluIG9wZW4gc291cmNlXG4gICAgRXZlbnRQbHVnaW5IdWI6IEV2ZW50UGx1Z2luSHViLFxuICAgIC8vIFVzZWQgYnkgdGVzdC11dGlsc1xuICAgIEV2ZW50UGx1Z2luUmVnaXN0cnk6IEV2ZW50UGx1Z2luUmVnaXN0cnksXG4gICAgRXZlbnRQcm9wYWdhdG9yczogRXZlbnRQcm9wYWdhdG9ycyxcbiAgICBSZWFjdENvbnRyb2xsZWRDb21wb25lbnQ6IFJlYWN0Q29udHJvbGxlZENvbXBvbmVudCxcbiAgICBSZWFjdERPTUNvbXBvbmVudFRyZWU6IFJlYWN0RE9NQ29tcG9uZW50VHJlZSxcbiAgICBSZWFjdERPTUV2ZW50TGlzdGVuZXI6IFJlYWN0RE9NRXZlbnRMaXN0ZW5lclxuICB9XG59O1xuXG5pZiAoZW5hYmxlQ3JlYXRlUm9vdCkge1xuICBSZWFjdERPTS5jcmVhdGVSb290ID0gZnVuY3Rpb24gY3JlYXRlUm9vdChjb250YWluZXIsIG9wdGlvbnMpIHtcbiAgICB2YXIgaHlkcmF0ZSA9IG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLmh5ZHJhdGUgPT09IHRydWU7XG4gICAgcmV0dXJuIG5ldyBSZWFjdFJvb3QoY29udGFpbmVyLCBoeWRyYXRlKTtcbiAgfTtcbn1cblxudmFyIGZvdW5kRGV2VG9vbHMgPSBET01SZW5kZXJlci5pbmplY3RJbnRvRGV2VG9vbHMoe1xuICBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTogZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUsXG4gIGJ1bmRsZVR5cGU6IDEsXG4gIHZlcnNpb246IFJlYWN0VmVyc2lvbixcbiAgcmVuZGVyZXJQYWNrYWdlTmFtZTogJ3JlYWN0LWRvbSdcbn0pO1xuXG57XG4gIGlmICghZm91bmREZXZUb29scyAmJiBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgd2luZG93LnRvcCA9PT0gd2luZG93LnNlbGYpIHtcbiAgICAvLyBJZiB3ZSdyZSBpbiBDaHJvbWUgb3IgRmlyZWZveCwgcHJvdmlkZSBhIGRvd25sb2FkIGxpbmsgaWYgbm90IGluc3RhbGxlZC5cbiAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUnKSA+IC0xICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRWRnZScpID09PSAtMSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA+IC0xKSB7XG4gICAgICB2YXIgcHJvdG9jb2wgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2w7XG4gICAgICAvLyBEb24ndCB3YXJuIGluIGV4b3RpYyBjYXNlcyBsaWtlIGNocm9tZS1leHRlbnNpb246Ly8uXG4gICAgICBpZiAoL14oaHR0cHM/fGZpbGUpOiQvLnRlc3QocHJvdG9jb2wpKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbygnJWNEb3dubG9hZCB0aGUgUmVhY3QgRGV2VG9vbHMgJyArICdmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWRldnRvb2xzJyArIChwcm90b2NvbCA9PT0gJ2ZpbGU6JyA/ICdcXG5Zb3UgbWlnaHQgbmVlZCB0byB1c2UgYSBsb2NhbCBIVFRQIHNlcnZlciAoaW5zdGVhZCBvZiBmaWxlOi8vKTogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWRldnRvb2xzLWZhcScgOiAnJyksICdmb250LXdlaWdodDpib2xkJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblxuXG52YXIgUmVhY3RET00kMiA9IE9iamVjdC5mcmVlemUoe1xuXHRkZWZhdWx0OiBSZWFjdERPTVxufSk7XG5cbnZhciBSZWFjdERPTSQzID0gKCBSZWFjdERPTSQyICYmIFJlYWN0RE9NICkgfHwgUmVhY3RET00kMjtcblxuLy8gVE9ETzogZGVjaWRlIG9uIHRoZSB0b3AtbGV2ZWwgZXhwb3J0IGZvcm0uXG4vLyBUaGlzIGlzIGhhY2t5IGJ1dCBtYWtlcyBpdCB3b3JrIHdpdGggYm90aCBSb2xsdXAgYW5kIEplc3QuXG52YXIgcmVhY3REb20gPSBSZWFjdERPTSQzWydkZWZhdWx0J10gPyBSZWFjdERPTSQzWydkZWZhdWx0J10gOiBSZWFjdERPTSQzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWN0RG9tO1xuICB9KSgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjaGVja0RDRSgpIHtcbiAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuICBpZiAoXG4gICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFICE9PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIFRoaXMgYnJhbmNoIGlzIHVucmVhY2hhYmxlIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZFxuICAgIC8vIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgY29uZGl0aW9uIGlzIHRydWUgb25seSBpbiBkZXZlbG9wbWVudC5cbiAgICAvLyBUaGVyZWZvcmUgaWYgdGhlIGJyYW5jaCBpcyBzdGlsbCBoZXJlLCBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2Fzbid0XG4gICAgLy8gcHJvcGVybHkgYXBwbGllZC5cbiAgICAvLyBEb24ndCBjaGFuZ2UgdGhlIG1lc3NhZ2UuIFJlYWN0IERldlRvb2xzIHJlbGllcyBvbiBpdC4gQWxzbyBtYWtlIHN1cmVcbiAgICAvLyB0aGlzIG1lc3NhZ2UgZG9lc24ndCBvY2N1ciBlbHNld2hlcmUgaW4gdGhpcyBmdW5jdGlvbiwgb3IgaXQgd2lsbCBjYXVzZVxuICAgIC8vIGEgZmFsc2UgcG9zaXRpdmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdeX14nKTtcbiAgfVxuICB0cnkge1xuICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBjb2RlIGFib3ZlIGhhcyBiZWVuIGRlYWQgY29kZSBlbGltaW5hdGVkIChEQ0UnZCkuXG4gICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFKGNoZWNrRENFKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gRGV2VG9vbHMgc2hvdWxkbid0IGNyYXNoIFJlYWN0LCBubyBtYXR0ZXIgd2hhdC5cbiAgICAvLyBXZSBzaG91bGQgc3RpbGwgcmVwb3J0IGluIGNhc2Ugd2UgYnJlYWsgdGhpcyBjb2RlLlxuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfVxufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAvLyBEQ0UgY2hlY2sgc2hvdWxkIGhhcHBlbiBiZWZvcmUgUmVhY3RET00gYnVuZGxlIGV4ZWN1dGVzIHNvIHRoYXRcbiAgLy8gRGV2VG9vbHMgY2FuIHJlcG9ydCBiYWQgbWluaWZpY2F0aW9uIGR1cmluZyBpbmplY3Rpb24uXG4gIGNoZWNrRENFKCk7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiaW1wb3J0IFJlYWN0LCB7IENoaWxkcmVuLCBDb21wb25lbnQsIGNsb25lRWxlbWVudCwgY3JlYXRlRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSwgeyBmaW5kRE9NTm9kZSB9IGZyb20gJ3JlYWN0LWRvbSc7XG5cbmZ1bmN0aW9uIHdhcm5PbmNlKG1zZykge1xuICB2YXIgaGFzV2FybmVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFoYXNXYXJuZWQpIHtcbiAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgaGFzV2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG59XG5cblxudmFyIHN0YXRlbGVzc0Z1bmN0aW9uYWxDb21wb25lbnRTdXBwbGllZCA9IHdhcm5PbmNlKCdcXG4+PiBFcnJvciwgdmlhIHJlYWN0LWZsaXAtbW92ZSA8PFxcblxcbllvdSBwcm92aWRlZCBhIHN0YXRlbGVzcyBmdW5jdGlvbmFsIGNvbXBvbmVudCBhcyBhIGNoaWxkIHRvIDxGbGlwTW92ZT4uIFVuZm9ydHVuYXRlbHksIFNGQ3MgYXJlblxcJ3Qgc3VwcG9ydGVkLCBiZWNhdXNlIEZsaXAgTW92ZSBuZWVkcyBhY2Nlc3MgdG8gdGhlIGJhY2tpbmcgaW5zdGFuY2VzIHZpYSByZWZzLCBhbmQgU0ZDcyBkb25cXCd0IGhhdmUgYSBwdWJsaWMgaW5zdGFuY2UgdGhhdCBob2xkcyB0aGF0IGluZm8uXFxuXFxuUGxlYXNlIHdyYXAgeW91ciBjb21wb25lbnRzIGluIGEgbmF0aXZlIGVsZW1lbnQgKGVnLiA8ZGl2PiksIG9yIGEgbm9uLWZ1bmN0aW9uYWwgY29tcG9uZW50LlxcbicpO1xuXG52YXIgcHJpbWl0aXZlTm9kZVN1cHBsaWVkID0gd2Fybk9uY2UoJ1xcbj4+IEVycm9yLCB2aWEgcmVhY3QtZmxpcC1tb3ZlIDw8XFxuXFxuWW91IHByb3ZpZGVkIGEgcHJpbWl0aXZlICh0ZXh0IG9yIG51bWJlcikgbm9kZSBhcyBhIGNoaWxkIHRvIDxGbGlwTW92ZT4uIEZsaXAgTW92ZSBuZWVkcyBjb250YWluZXJzIHdpdGggdW5pcXVlIGtleXMgdG8gbW92ZSBjaGlsZHJlbiBhcm91bmQuXFxuXFxuUGxlYXNlIHdyYXAgeW91ciB2YWx1ZSBpbiBhIG5hdGl2ZSBlbGVtZW50IChlZy4gPHNwYW4+KSwgb3IgYSBjb21wb25lbnQuXFxuJyk7XG5cbnZhciBpbnZhbGlkVHlwZUZvclRpbWluZ1Byb3AgPSBmdW5jdGlvbiBpbnZhbGlkVHlwZUZvclRpbWluZ1Byb3AoYXJnc1xuLy8gcHJldHRpZXItaWdub3JlXG4pIHtcbiAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoJ1xcbj4+IEVycm9yLCB2aWEgcmVhY3QtZmxpcC1tb3ZlIDw8XFxuXFxuVGhlIHByb3AgeW91IHByb3ZpZGVkIGZvciBcXCcnICsgYXJncy5wcm9wICsgJ1xcJyBpcyBpbnZhbGlkLiBJdCBuZWVkcyB0byBiZSBhIHBvc2l0aXZlIGludGVnZXIsIG9yIGEgc3RyaW5nIHRoYXQgY2FuIGJlIHJlc29sdmVkIHRvIGEgbnVtYmVyLiBUaGUgdmFsdWUgeW91IHByb3ZpZGVkIGlzIFxcJycgKyBhcmdzLnZhbHVlICsgJ1xcJy5cXG5cXG5BcyBhIHJlc3VsdCwgIHRoZSBkZWZhdWx0IHZhbHVlIGZvciB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHVzZWQsIHdoaWNoIGlzIFxcJycgKyBhcmdzLmRlZmF1bHRWYWx1ZSArICdcXCcuXFxuJyk7XG59O1xuXG52YXIgaW52YWxpZEVudGVyTGVhdmVQcmVzZXQgPSBmdW5jdGlvbiBpbnZhbGlkRW50ZXJMZWF2ZVByZXNldChhcmdzXG4vLyBwcmV0dGllci1pZ25vcmVcbikge1xuICByZXR1cm4gY29uc29sZS5lcnJvcignXFxuPj4gRXJyb3IsIHZpYSByZWFjdC1mbGlwLW1vdmUgPDxcXG5cXG5UaGUgZW50ZXIvbGVhdmUgcHJlc2V0IHlvdSBwcm92aWRlZCBpcyBpbnZhbGlkLiBXZSBkb25cXCd0IGN1cnJlbnRseSBoYXZlIGEgXFwnJyArIGFyZ3MudmFsdWUgKyAnIHByZXNldC5cXCdcXG5cXG5BY2NlcHRhYmxlIHZhbHVlcyBhcmUgJyArIGFyZ3MuYWNjZXB0YWJsZVZhbHVlcyArICcuIFRoZSBkZWZhdWx0IHZhbHVlIG9mIFxcJycgKyBhcmdzLmRlZmF1bHRWYWx1ZSArICdcXCcgd2lsbCBiZSB1c2VkLlxcbicpO1xufTtcblxudmFyIHBhcmVudE5vZGVQb3NpdGlvblN0YXRpYyA9IHdhcm5PbmNlKCdcXG4+PiBXYXJuaW5nLCB2aWEgcmVhY3QtZmxpcC1tb3ZlIDw8XFxuXFxuV2hlbiB1c2luZyBcIndyYXBwZXJsZXNzXCIgbW9kZSAoYnkgc3VwcGx5aW5nIFxcJ3R5cGVOYW1lXFwnIG9mIFxcJ251bGxcXCcpLCBzdHJhbmdlIHRoaW5ncyBoYXBwZW4gd2hlbiB0aGUgZGlyZWN0IHBhcmVudCBoYXMgdGhlIGRlZmF1bHQgXCJzdGF0aWNcIiBwb3NpdGlvbi5cXG5cXG5GbGlwTW92ZSBoYXMgYWRkZWQgXFwncG9zaXRpb246IHJlbGF0aXZlXFwnIHRvIHRoaXMgbm9kZSwgdG8gZW5zdXJlIEZsaXAgTW92ZSBhbmltYXRlcyBjb3JyZWN0bHkuXFxuXFxuVG8gYXZvaWQgc2VlaW5nIHRoaXMgd2FybmluZywgc2ltcGx5IGFwcGx5IGEgbm9uLXN0YXRpYyBwb3NpdGlvbiB0byB0aGF0IHBhcmVudCBub2RlLlxcbicpO1xuXG52YXIgY2hpbGRJc0Rpc2FibGVkID0gd2Fybk9uY2UoJ1xcbj4+IFdhcm5pbmcsIHZpYSByZWFjdC1mbGlwLW1vdmUgPDxcXG5cXG5PbmUgb3IgbW9yZSBvZiBGbGlwIE1vdmVcXCdzIGNoaWxkIGVsZW1lbnRzIGhhdmUgdGhlIGh0bWwgYXR0cmlidXRlIFxcJ2Rpc2FibGVkXFwnIHNldCB0byB0cnVlLlxcblxcblBsZWFzZSBub3RlIHRoYXQgdGhpcyB3aWxsIGNhdXNlIGFuaW1hdGlvbnMgdG8gYnJlYWsgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTEgYW5kIGJlbG93LiBFaXRoZXIgcmVtb3ZlIHRoZSBkaXNhYmxlZCBhdHRyaWJ1dGUgb3Igc2V0IFxcJ2FuaW1hdGlvblxcJyB0byBmYWxzZS5cXG4nKTtcblxudmFyIGVudGVyUHJlc2V0cyA9IHtcbiAgZWxldmF0b3I6IHtcbiAgICBmcm9tOiB7IHRyYW5zZm9ybTogJ3NjYWxlKDApJywgb3BhY2l0eTogJzAnIH0sXG4gICAgdG86IHsgdHJhbnNmb3JtOiAnJywgb3BhY2l0eTogJycgfVxuICB9LFxuICBmYWRlOiB7XG4gICAgZnJvbTogeyBvcGFjaXR5OiAnMCcgfSxcbiAgICB0bzogeyBvcGFjaXR5OiAnJyB9XG4gIH0sXG4gIGFjY29yZGlvblZlcnRpY2FsOiB7XG4gICAgZnJvbTogeyB0cmFuc2Zvcm06ICdzY2FsZVkoMCknLCB0cmFuc2Zvcm1PcmlnaW46ICdjZW50ZXIgdG9wJyB9LFxuICAgIHRvOiB7IHRyYW5zZm9ybTogJycsIHRyYW5zZm9ybU9yaWdpbjogJ2NlbnRlciB0b3AnIH1cbiAgfSxcbiAgYWNjb3JkaW9uSG9yaXpvbnRhbDoge1xuICAgIGZyb206IHsgdHJhbnNmb3JtOiAnc2NhbGVYKDApJywgdHJhbnNmb3JtT3JpZ2luOiAnbGVmdCBjZW50ZXInIH0sXG4gICAgdG86IHsgdHJhbnNmb3JtOiAnJywgdHJhbnNmb3JtT3JpZ2luOiAnbGVmdCBjZW50ZXInIH1cbiAgfSxcbiAgbm9uZTogbnVsbFxufTtcbi8qKlxuICogUmVhY3QgRmxpcCBNb3ZlIHwgZW50ZXJMZWF2ZVByZXNldHNcbiAqIChjKSAyMDE2LXByZXNlbnQgSm9zaHVhIENvbWVhdVxuICpcbiAqIFRoaXMgY29udGFpbnMgdGhlIG1hc3RlciBsaXN0IG9mIHByZXNldHMgYXZhaWxhYmxlIGZvciBlbnRlci9sZWF2ZSBhbmltYXRpb25zLFxuICogYWxvbmcgd2l0aCB0aGUgbWFwcGluZyBiZXR3ZWVuIHByZXNldCBhbmQgc3R5bGVzLlxuICovXG5cblxudmFyIGxlYXZlUHJlc2V0cyA9IHtcbiAgZWxldmF0b3I6IHtcbiAgICBmcm9tOiB7IHRyYW5zZm9ybTogJ3NjYWxlKDEpJywgb3BhY2l0eTogJzEnIH0sXG4gICAgdG86IHsgdHJhbnNmb3JtOiAnc2NhbGUoMCknLCBvcGFjaXR5OiAnMCcgfVxuICB9LFxuICBmYWRlOiB7XG4gICAgZnJvbTogeyBvcGFjaXR5OiAnMScgfSxcbiAgICB0bzogeyBvcGFjaXR5OiAnMCcgfVxuICB9LFxuICBhY2NvcmRpb25WZXJ0aWNhbDoge1xuICAgIGZyb206IHsgdHJhbnNmb3JtOiAnc2NhbGVZKDEpJywgdHJhbnNmb3JtT3JpZ2luOiAnY2VudGVyIHRvcCcgfSxcbiAgICB0bzogeyB0cmFuc2Zvcm06ICdzY2FsZVkoMCknLCB0cmFuc2Zvcm1PcmlnaW46ICdjZW50ZXIgdG9wJyB9XG4gIH0sXG4gIGFjY29yZGlvbkhvcml6b250YWw6IHtcbiAgICBmcm9tOiB7IHRyYW5zZm9ybTogJ3NjYWxlWCgxKScsIHRyYW5zZm9ybU9yaWdpbjogJ2xlZnQgY2VudGVyJyB9LFxuICAgIHRvOiB7IHRyYW5zZm9ybTogJ3NjYWxlWCgwKScsIHRyYW5zZm9ybU9yaWdpbjogJ2xlZnQgY2VudGVyJyB9XG4gIH0sXG4gIG5vbmU6IG51bGxcbn07XG5cbi8vIEZvciBub3csIGFwcGVhclByZXNldHMgd2lsbCBiZSBpZGVudGljYWwgdG8gZW50ZXJQcmVzZXRzLlxuLy8gQXNzaWduaW5nIGEgY3VzdG9tIGV4cG9ydCBpbiBjYXNlIHdlIGV2ZXIgd2FudCB0byBhZGQgYXBwZWFyLXNwZWNpZmljIG9uZXMuXG52YXIgYXBwZWFyUHJlc2V0cyA9IGVudGVyUHJlc2V0cztcblxudmFyIGRlZmF1bHRQcmVzZXQgPSAnZWxldmF0b3InO1xudmFyIGRpc2FibGVQcmVzZXQgPSAnbm9uZSc7XG5cbnZhciBmaW5kID0gZnVuY3Rpb24gZmluZChwcmVkaWNhdGUsIGFycikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyW2ldLCBpLCBhcnIpKSB7XG4gICAgICByZXR1cm4gYXJyW2ldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG5cbnZhciBldmVyeSA9IGZ1bmN0aW9uIGV2ZXJ5KHByZWRpY2F0ZSwgYXJyKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFwcmVkaWNhdGUoYXJyW2ldLCBpLCBhcnIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1tdXRhYmxlLWV4cG9ydHNcbnZhciBfaXNBcnJheSA9IGZ1bmN0aW9uIGlzQXJyYXkoYXJyKSB7XG4gIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJnKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xuICByZXR1cm4gX2lzQXJyYXkoYXJyKTtcbn07XG5cbnZhciBpc0VsZW1lbnRBblNGQyA9IGZ1bmN0aW9uIGlzRWxlbWVudEFuU0ZDKGVsZW1lbnQpIHtcbiAgdmFyIGlzTmF0aXZlRE9NRWxlbWVudCA9IHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnO1xuXG4gIGlmIChpc05hdGl2ZURPTUVsZW1lbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gIWVsZW1lbnQudHlwZS5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudDtcbn07XG5cbmZ1bmN0aW9uIG9taXQob2JqKSB7XG4gIHZhciBhdHRycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG5cbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChhdHRycy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG9ialtrZXldO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGFycmF5c0VxdWFsKGEsIGIpIHtcbiAgdmFyIHNhbWVPYmplY3QgPSBhID09PSBiO1xuICBpZiAoc2FtZU9iamVjdCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIG5vdEJvdGhBcnJheXMgPSAhX2lzQXJyYXkoYSkgfHwgIV9pc0FycmF5KGIpO1xuICB2YXIgZGlmZmVyZW50TGVuZ3RocyA9IGEubGVuZ3RoICE9PSBiLmxlbmd0aDtcblxuICBpZiAobm90Qm90aEFycmF5cyB8fCBkaWZmZXJlbnRMZW5ndGhzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGV2ZXJ5KGZ1bmN0aW9uIChlbGVtZW50LCBpbmRleCkge1xuICAgIHJldHVybiBlbGVtZW50ID09PSBiW2luZGV4XTtcbiAgfSwgYSk7XG59XG5cbmZ1bmN0aW9uIG1lbW9pemVTdHJpbmcoZm4pIHtcbiAgdmFyIGNhY2hlID0ge307XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChzdHIpIHtcbiAgICBpZiAoIWNhY2hlW3N0cl0pIHtcbiAgICAgIGNhY2hlW3N0cl0gPSBmbihzdHIpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVbc3RyXTtcbiAgfTtcbn1cblxudmFyIGh5cGhlbmF0ZSA9IG1lbW9pemVTdHJpbmcoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbQS1aXSkvZywgJy0kMScpLnRvTG93ZXJDYXNlKCk7XG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmo7XG59IDogZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIGNsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cblxuXG5cblxuXG5cblxuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuXG5cbnZhciBpbmhlcml0cyA9IGZ1bmN0aW9uIChzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn07XG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4gPSBmdW5jdGlvbiAoc2VsZiwgY2FsbCkge1xuICBpZiAoIXNlbGYpIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjtcbn07XG5cbi8qKlxuICogUmVhY3QgRmxpcCBNb3ZlIHwgcHJvcENvbnZlcnRlclxuICogKGMpIDIwMTYtcHJlc2VudCBKb3NodWEgQ29tZWF1XG4gKlxuICogQWJzdHJhY3RlZCBhd2F5IGEgYnVuY2ggb2YgdGhlIG1lc3N5IGJ1c2luZXNzIHdpdGggcHJvcHMuXG4gKiAgIC0gcHJvcHMgZmxvdyB0eXBlcyBhbmQgZGVmYXVsdFByb3BzXG4gKiAgIC0gVHlwZSBjb252ZXJzaW9uIChXZSBhY2NlcHQgJ3N0cmluZycgYW5kICdudW1iZXInIHZhbHVlcyBmb3IgZHVyYXRpb24sXG4gKiAgICAgZGVsYXksIGFuZCBvdGhlciBmaWVsZHMsIGJ1dCB3ZSBhY3R1YWxseSBuZWVkIHRoZW0gdG8gYmUgaW50cy4pXG4gKiAgIC0gQ2hpbGRyZW4gY29udmVyc2lvbiAod2UgbmVlZCB0aGUgY2hpbGRyZW4gdG8gYmUgYW4gYXJyYXkuIE1heSBub3QgYWx3YXlzXG4gKiAgICAgYmUsIGlmIGEgc2luZ2xlIGNoaWxkIGlzIHBhc3NlZCBpbi4pXG4gKiAgIC0gUmVzb2x2aW5nIGFuaW1hdGlvbiBwcmVzZXRzIGludG8gdGhlaXIgYmFzZSBDU1Mgc3R5bGVzXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIGJsb2NrLXNjb3BlZC12YXIgKi9cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGxpY2F0ZS1pbXBvcnRzXG5cblxuZnVuY3Rpb24gcHJvcENvbnZlcnRlcihDb21wb3NlZENvbXBvbmVudCkge1xuICB2YXIgX2NsYXNzLCBfdGVtcDtcblxuICByZXR1cm4gX3RlbXAgPSBfY2xhc3MgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICAgIGluaGVyaXRzKEZsaXBNb3ZlUHJvcENvbnZlcnRlciwgX0NvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBGbGlwTW92ZVByb3BDb252ZXJ0ZXIoKSB7XG4gICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBGbGlwTW92ZVByb3BDb252ZXJ0ZXIpO1xuICAgICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICAgIEZsaXBNb3ZlUHJvcENvbnZlcnRlci5wcm90b3R5cGUuY2hlY2tDaGlsZHJlbiA9IGZ1bmN0aW9uIGNoZWNrQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgICAgIC8vIFNraXAgYWxsIGNvbnNvbGUgd2FybmluZ3MgaW4gcHJvZHVjdGlvbi5cbiAgICAgIC8vIEJhaWwgZWFybHksIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdvcmsuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHNhbWUgYXMgUmVhY3QuTm9kZSwgYnV0IHdpdGhvdXQgZnJhZ21lbnRzLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzQ3ODFcblxuXG4gICAgICAvLyBGbGlwTW92ZSBkb2VzIG5vdCBzdXBwb3J0IHN0YXRlbGVzcyBmdW5jdGlvbmFsIGNvbXBvbmVudHMuXG4gICAgICAvLyBDaGVjayB0byBzZWUgaWYgYW55IHN1cHBsaWVkIGNvbXBvbmVudHMgd29uJ3Qgd29yay5cbiAgICAgIC8vIElmIHRoZSBjaGlsZCBkb2Vzbid0IGhhdmUgYSBrZXksIGl0IG1lYW5zIHdlIGFyZW4ndCBhbmltYXRpbmcgaXQuXG4gICAgICAvLyBJdCdzIGFsbG93ZWQgdG8gYmUgYW4gU0ZDLCBzaW5jZSB3ZSBpZ25vcmUgaXQuXG4gICAgICBDaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgLy8gbnVsbCwgdW5kZWZpbmVkLCBhbmQgYm9vbGVhbnMgd2lsbCBiZSBmaWx0ZXJlZCBvdXQgYnkgQ2hpbGRyZW4udG9BcnJheVxuICAgICAgICBpZiAoY2hpbGQgPT0gbnVsbCB8fCB0eXBlb2YgY2hpbGQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgodHlwZW9mIGNoaWxkID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihjaGlsZCkpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHByaW1pdGl2ZU5vZGVTdXBwbGllZCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0VsZW1lbnRBblNGQyhjaGlsZCkgJiYgY2hpbGQua2V5ICE9IG51bGwpIHtcbiAgICAgICAgICBzdGF0ZWxlc3NGdW5jdGlvbmFsQ29tcG9uZW50U3VwcGxpZWQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIEZsaXBNb3ZlUHJvcENvbnZlcnRlci5wcm90b3R5cGUuY29udmVydFByb3BzID0gZnVuY3Rpb24gY29udmVydFByb3BzKHByb3BzKSB7XG4gICAgICB2YXIgd29ya2luZ1Byb3BzID0ge1xuICAgICAgICAvLyBleHBsaWNpdGx5IGJ5cGFzcyB0aGUgcHJvcHMgdGhhdCBkb24ndCBuZWVkIGNvbnZlcnNpb25cbiAgICAgICAgY2hpbGRyZW46IHByb3BzLmNoaWxkcmVuLFxuICAgICAgICBlYXNpbmc6IHByb3BzLmVhc2luZyxcbiAgICAgICAgb25TdGFydDogcHJvcHMub25TdGFydCxcbiAgICAgICAgb25GaW5pc2g6IHByb3BzLm9uRmluaXNoLFxuICAgICAgICBvblN0YXJ0QWxsOiBwcm9wcy5vblN0YXJ0QWxsLFxuICAgICAgICBvbkZpbmlzaEFsbDogcHJvcHMub25GaW5pc2hBbGwsXG4gICAgICAgIHR5cGVOYW1lOiBwcm9wcy50eXBlTmFtZSxcbiAgICAgICAgZGlzYWJsZUFsbEFuaW1hdGlvbnM6IHByb3BzLmRpc2FibGVBbGxBbmltYXRpb25zLFxuICAgICAgICBnZXRQb3NpdGlvbjogcHJvcHMuZ2V0UG9zaXRpb24sXG4gICAgICAgIG1haW50YWluQ29udGFpbmVySGVpZ2h0OiBwcm9wcy5tYWludGFpbkNvbnRhaW5lckhlaWdodCxcbiAgICAgICAgdmVydGljYWxBbGlnbm1lbnQ6IHByb3BzLnZlcnRpY2FsQWxpZ25tZW50LFxuXG4gICAgICAgIC8vIERvIHN0cmluZy10by1pbnQgY29udmVyc2lvbiBmb3IgYWxsIHRpbWluZy1yZWxhdGVkIHByb3BzXG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLmNvbnZlcnRUaW1pbmdQcm9wKCdkdXJhdGlvbicpLFxuICAgICAgICBkZWxheTogdGhpcy5jb252ZXJ0VGltaW5nUHJvcCgnZGVsYXknKSxcbiAgICAgICAgc3RhZ2dlckR1cmF0aW9uQnk6IHRoaXMuY29udmVydFRpbWluZ1Byb3AoJ3N0YWdnZXJEdXJhdGlvbkJ5JyksXG4gICAgICAgIHN0YWdnZXJEZWxheUJ5OiB0aGlzLmNvbnZlcnRUaW1pbmdQcm9wKCdzdGFnZ2VyRGVsYXlCeScpLFxuXG4gICAgICAgIC8vIE91ciBlbnRlci9sZWF2ZSBhbmltYXRpb25zIGNhbiBiZSBzcGVjaWZpZWQgYXMgYm9vbGVhbiAoZGVmYXVsdCBvclxuICAgICAgICAvLyBkaXNhYmxlZCksIHN0cmluZyAocHJlc2V0IG5hbWUpLCBvciBvYmplY3QgKGFjdHVhbCBhbmltYXRpb24gdmFsdWVzKS5cbiAgICAgICAgLy8gTGV0J3Mgc3RhbmRhcmRpemUgdGhpcyBzbyB0aGF0IHRoZXkncmUgYWx3YXlzIG9iamVjdHNcbiAgICAgICAgYXBwZWFyQW5pbWF0aW9uOiB0aGlzLmNvbnZlcnRBbmltYXRpb25Qcm9wKHByb3BzLmFwcGVhckFuaW1hdGlvbiwgYXBwZWFyUHJlc2V0cyksXG4gICAgICAgIGVudGVyQW5pbWF0aW9uOiB0aGlzLmNvbnZlcnRBbmltYXRpb25Qcm9wKHByb3BzLmVudGVyQW5pbWF0aW9uLCBlbnRlclByZXNldHMpLFxuICAgICAgICBsZWF2ZUFuaW1hdGlvbjogdGhpcy5jb252ZXJ0QW5pbWF0aW9uUHJvcChwcm9wcy5sZWF2ZUFuaW1hdGlvbiwgbGVhdmVQcmVzZXRzKSxcblxuICAgICAgICBkZWxlZ2F0ZWQ6IHt9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmNoZWNrQ2hpbGRyZW4od29ya2luZ1Byb3BzLmNoaWxkcmVuKTtcblxuICAgICAgLy8gR2F0aGVyIGFueSBhZGRpdGlvbmFsIHByb3BzO1xuICAgICAgLy8gdGhleSB3aWxsIGJlIGRlbGVnYXRlZCB0byB0aGUgUmVhY3RFbGVtZW50IGNyZWF0ZWQuXG4gICAgICB2YXIgcHJpbWFyeVByb3BLZXlzID0gT2JqZWN0LmtleXMod29ya2luZ1Byb3BzKTtcbiAgICAgIHZhciBkZWxlZ2F0ZWRQcm9wcyA9IG9taXQodGhpcy5wcm9wcywgcHJpbWFyeVByb3BLZXlzKTtcblxuICAgICAgLy8gVGhlIEZsaXBNb3ZlIGNvbnRhaW5lciBlbGVtZW50IG5lZWRzIHRvIGhhdmUgYSBub24tc3RhdGljIHBvc2l0aW9uLlxuICAgICAgLy8gV2UgdXNlIGByZWxhdGl2ZWAgYnkgZGVmYXVsdCwgYnV0IGl0IGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSB1c2VyLlxuICAgICAgLy8gTm93IHRoYXQgd2UncmUgZGVsZWdhdGluZyBwcm9wcywgd2UgbmVlZCB0byBtZXJnZSB0aGlzIGluLlxuICAgICAgZGVsZWdhdGVkUHJvcHMuc3R5bGUgPSBfZXh0ZW5kcyh7XG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnXG4gICAgICB9LCBkZWxlZ2F0ZWRQcm9wcy5zdHlsZSk7XG5cbiAgICAgIHdvcmtpbmdQcm9wcy5kZWxlZ2F0ZWQgPSBkZWxlZ2F0ZWRQcm9wcztcblxuICAgICAgcmV0dXJuIHdvcmtpbmdQcm9wcztcbiAgICB9O1xuXG4gICAgRmxpcE1vdmVQcm9wQ29udmVydGVyLnByb3RvdHlwZS5jb252ZXJ0VGltaW5nUHJvcCA9IGZ1bmN0aW9uIGNvbnZlcnRUaW1pbmdQcm9wKHByb3ApIHtcbiAgICAgIHZhciByYXdWYWx1ZSA9IHRoaXMucHJvcHNbcHJvcF07XG5cbiAgICAgIHZhciB2YWx1ZSA9IHR5cGVvZiByYXdWYWx1ZSA9PT0gJ251bWJlcicgPyByYXdWYWx1ZSA6IHBhcnNlSW50KHJhd1ZhbHVlLCAxMCk7XG5cbiAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IEZsaXBNb3ZlUHJvcENvbnZlcnRlci5kZWZhdWx0UHJvcHNbcHJvcF07XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpbnZhbGlkVHlwZUZvclRpbWluZ1Byb3Aoe1xuICAgICAgICAgICAgcHJvcDogcHJvcCxcbiAgICAgICAgICAgIHZhbHVlOiByYXdWYWx1ZSxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZGVmYXVsdFZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG5cblxuICAgIEZsaXBNb3ZlUHJvcENvbnZlcnRlci5wcm90b3R5cGUuY29udmVydEFuaW1hdGlvblByb3AgPSBmdW5jdGlvbiBjb252ZXJ0QW5pbWF0aW9uUHJvcChhbmltYXRpb24sIHByZXNldHMpIHtcbiAgICAgIHN3aXRjaCAodHlwZW9mIGFuaW1hdGlvbiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYW5pbWF0aW9uKSkge1xuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBJZiBpdCdzIHRydWUsIHdlIHdhbnQgdG8gdXNlIHRoZSBkZWZhdWx0IHByZXNldC5cbiAgICAgICAgICAgIC8vIElmIGl0J3MgZmFsc2UsIHdlIHdhbnQgdG8gdXNlIHRoZSAnbm9uZScgcHJlc2V0LlxuICAgICAgICAgICAgcmV0dXJuIHByZXNldHNbYW5pbWF0aW9uID8gZGVmYXVsdFByZXNldCA6IGRpc2FibGVQcmVzZXRdO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwcmVzZXRLZXlzID0gT2JqZWN0LmtleXMocHJlc2V0cyk7XG5cbiAgICAgICAgICAgIGlmIChwcmVzZXRLZXlzLmluZGV4T2YoYW5pbWF0aW9uKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpbnZhbGlkRW50ZXJMZWF2ZVByZXNldCh7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogYW5pbWF0aW9uLFxuICAgICAgICAgICAgICAgICAgYWNjZXB0YWJsZVZhbHVlczogcHJlc2V0S2V5cy5qb2luKCcsICcpLFxuICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBkZWZhdWx0UHJlc2V0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gcHJlc2V0c1tkZWZhdWx0UHJlc2V0XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHByZXNldHNbYW5pbWF0aW9uXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gYW5pbWF0aW9uO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgRmxpcE1vdmVQcm9wQ29udmVydGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb3NlZENvbXBvbmVudCwgdGhpcy5jb252ZXJ0UHJvcHModGhpcy5wcm9wcykpO1xuICAgIH07XG5cbiAgICByZXR1cm4gRmxpcE1vdmVQcm9wQ29udmVydGVyO1xuICB9KENvbXBvbmVudCksIF9jbGFzcy5kZWZhdWx0UHJvcHMgPSB7XG4gICAgZWFzaW5nOiAnZWFzZS1pbi1vdXQnLFxuICAgIGR1cmF0aW9uOiAzNTAsXG4gICAgZGVsYXk6IDAsXG4gICAgc3RhZ2dlckR1cmF0aW9uQnk6IDAsXG4gICAgc3RhZ2dlckRlbGF5Qnk6IDAsXG4gICAgdHlwZU5hbWU6ICdkaXYnLFxuICAgIGVudGVyQW5pbWF0aW9uOiBkZWZhdWx0UHJlc2V0LFxuICAgIGxlYXZlQW5pbWF0aW9uOiBkZWZhdWx0UHJlc2V0LFxuICAgIGRpc2FibGVBbGxBbmltYXRpb25zOiBmYWxzZSxcbiAgICBnZXRQb3NpdGlvbjogZnVuY3Rpb24gZ2V0UG9zaXRpb24obm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfSxcbiAgICBtYWludGFpbkNvbnRhaW5lckhlaWdodDogZmFsc2UsXG4gICAgdmVydGljYWxBbGlnbm1lbnQ6ICd0b3AnXG4gIH0sIF90ZW1wO1xufVxuXG4vKipcbiAqIFJlYWN0IEZsaXAgTW92ZVxuICogKGMpIDIwMTYtcHJlc2VudCBKb3NodWEgQ29tZWF1XG4gKlxuICogVGhlc2UgbWV0aG9kcyByZWFkIGZyb20gYW5kIHdyaXRlIHRvIHRoZSBET00uXG4gKiBUaGV5IGFsbW9zdCBhbHdheXMgaGF2ZSBzaWRlIGVmZmVjdHMsIGFuZCB3aWxsIGhvcGVmdWxseSBiZWNvbWUgdGhlXG4gKiBvbmx5IHNwb3QgaW4gdGhlIGNvZGViYXNlIHdpdGggaW1wdXJlIGZ1bmN0aW9ucy5cbiAqL1xuZnVuY3Rpb24gYXBwbHlTdHlsZXNUb0RPTU5vZGUoX3JlZikge1xuICB2YXIgZG9tTm9kZSA9IF9yZWYuZG9tTm9kZSxcbiAgICAgIHN0eWxlcyA9IF9yZWYuc3R5bGVzO1xuXG4gIC8vIENhbid0IGp1c3QgZG8gYW4gb2JqZWN0IG1lcmdlIGJlY2F1c2UgZG9tTm9kZS5zdHlsZXMgaXMgbm8gcmVndWxhciBvYmplY3QuXG4gIC8vIE5lZWQgdG8gZG8gaXQgdGhpcyB3YXkgZm9yIHRoZSBlbmdpbmUgdG8gZmlyZSBpdHMgYHNldGAgbGlzdGVuZXJzLlxuICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGRvbU5vZGUuc3R5bGUuc2V0UHJvcGVydHkoaHlwaGVuYXRlKGtleSksIHN0eWxlc1trZXldKTtcbiAgfSk7XG59XG5cbi8vIE1vZGlmaWVkIGZyb20gTW9kZXJuaXpyXG5mdW5jdGlvbiB3aGljaFRyYW5zaXRpb25FdmVudCgpIHtcbiAgdmFyIHRyYW5zaXRpb25zID0ge1xuICAgIHRyYW5zaXRpb246ICd0cmFuc2l0aW9uZW5kJyxcbiAgICAnLW8tdHJhbnNpdGlvbic6ICdvVHJhbnNpdGlvbkVuZCcsXG4gICAgJy1tb3otdHJhbnNpdGlvbic6ICd0cmFuc2l0aW9uZW5kJyxcbiAgICAnLXdlYmtpdC10cmFuc2l0aW9uJzogJ3dlYmtpdFRyYW5zaXRpb25FbmQnXG4gIH07XG5cbiAgLy8gSWYgd2UncmUgcnVubmluZyBpbiBhIGJyb3dzZXJsZXNzIGVudmlyb25tZW50IChlZy4gU1NSKSwgaXQgZG9lc24ndCBhcHBseS5cbiAgLy8gUmV0dXJuIGEgcGxhY2Vob2xkZXIgc3RyaW5nLCBmb3IgY29uc2lzdGVudCB0eXBlIHJldHVybi5cbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiAnJztcblxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmYWtlZWxlbWVudCcpO1xuXG4gIHZhciBtYXRjaCA9IGZpbmQoZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gZWwuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSh0KSAhPT0gdW5kZWZpbmVkO1xuICB9LCBPYmplY3Qua2V5cyh0cmFuc2l0aW9ucykpO1xuXG4gIC8vIElmIG5vIGB0cmFuc2l0aW9uYCBpcyBmb3VuZCwgd2UgbXVzdCBiZSBydW5uaW5nIGluIGEgYnJvd3NlciBzbyBhbmNpZW50LFxuICAvLyBSZWFjdCBpdHNlbGYgd29uJ3QgcnVuLiBSZXR1cm4gYW4gZW1wdHkgc3RyaW5nLCBmb3IgY29uc2lzdGVudCB0eXBlIHJldHVyblxuICByZXR1cm4gbWF0Y2ggPyB0cmFuc2l0aW9uc1ttYXRjaF0gOiAnJztcbn1cblxudmFyIGdldFJlbGF0aXZlQm91bmRpbmdCb3ggPSBmdW5jdGlvbiBnZXRSZWxhdGl2ZUJvdW5kaW5nQm94KF9yZWYyKSB7XG4gIHZhciBjaGlsZERvbU5vZGUgPSBfcmVmMi5jaGlsZERvbU5vZGUsXG4gICAgICBwYXJlbnREb21Ob2RlID0gX3JlZjIucGFyZW50RG9tTm9kZSxcbiAgICAgIGdldFBvc2l0aW9uID0gX3JlZjIuZ2V0UG9zaXRpb247XG5cbiAgdmFyIHBhcmVudEJveCA9IGdldFBvc2l0aW9uKHBhcmVudERvbU5vZGUpO1xuXG4gIHZhciBfZ2V0UG9zaXRpb24gPSBnZXRQb3NpdGlvbihjaGlsZERvbU5vZGUpLFxuICAgICAgdG9wID0gX2dldFBvc2l0aW9uLnRvcCxcbiAgICAgIGxlZnQgPSBfZ2V0UG9zaXRpb24ubGVmdCxcbiAgICAgIHJpZ2h0ID0gX2dldFBvc2l0aW9uLnJpZ2h0LFxuICAgICAgYm90dG9tID0gX2dldFBvc2l0aW9uLmJvdHRvbSxcbiAgICAgIHdpZHRoID0gX2dldFBvc2l0aW9uLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX2dldFBvc2l0aW9uLmhlaWdodDtcblxuICByZXR1cm4ge1xuICAgIHRvcDogdG9wIC0gcGFyZW50Qm94LnRvcCxcbiAgICBsZWZ0OiBsZWZ0IC0gcGFyZW50Qm94LmxlZnQsXG4gICAgcmlnaHQ6IHBhcmVudEJveC5yaWdodCAtIHJpZ2h0LFxuICAgIGJvdHRvbTogcGFyZW50Qm94LmJvdHRvbSAtIGJvdHRvbSxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcbn07XG5cbi8qKiBnZXRQb3NpdGlvbkRlbHRhXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBkZWx0YSBiZXR3ZWVuIHR3byBib3VuZGluZyBib3hlcywgdG8gZmlndXJlIG91dFxuICogaG93IG1hbnkgcGl4ZWxzIG9uIGVhY2ggYXhpcyB0aGUgZWxlbWVudCBoYXMgbW92ZWQuXG4gKlxuICovXG52YXIgZ2V0UG9zaXRpb25EZWx0YSA9IGZ1bmN0aW9uIGdldFBvc2l0aW9uRGVsdGEoX3JlZjMpIHtcbiAgdmFyIGNoaWxkRG9tTm9kZSA9IF9yZWYzLmNoaWxkRG9tTm9kZSxcbiAgICAgIGNoaWxkQm91bmRpbmdCb3ggPSBfcmVmMy5jaGlsZEJvdW5kaW5nQm94LFxuICAgICAgcGFyZW50Qm91bmRpbmdCb3ggPSBfcmVmMy5wYXJlbnRCb3VuZGluZ0JveCxcbiAgICAgIGdldFBvc2l0aW9uID0gX3JlZjMuZ2V0UG9zaXRpb247XG5cbiAgLy8gVEVNUDogQSBteXN0ZXJ5IGJ1ZyBpcyBzb21ldGltZXMgY2F1c2luZyB1bm5lY2Vzc2FyeSBib3VuZGluZ0JveGVzIHRvXG4gIHZhciBkZWZhdWx0Qm94ID0ge1xuICAgIHRvcDogMCxcbiAgICBsZWZ0OiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBoZWlnaHQ6IDAsXG4gICAgd2lkdGg6IDBcbiAgfTtcblxuICAvLyBPdXIgb2xkIGJveCBpcyBpdHMgbGFzdCBjYWxjdWxhdGVkIHBvc2l0aW9uLCBkZXJpdmVkIG9uIG1vdW50IG9yIGF0IHRoZVxuICAvLyBzdGFydCBvZiB0aGUgcHJldmlvdXMgYW5pbWF0aW9uLlxuICB2YXIgb2xkUmVsYXRpdmVCb3ggPSBjaGlsZEJvdW5kaW5nQm94IHx8IGRlZmF1bHRCb3g7XG4gIHZhciBwYXJlbnRCb3ggPSBwYXJlbnRCb3VuZGluZ0JveCB8fCBkZWZhdWx0Qm94O1xuXG4gIC8vIE91ciBuZXcgYm94IGlzIHRoZSBuZXcgZmluYWwgcmVzdGluZyBwbGFjZTogV2hlcmUgd2UgZXhwZWN0IGl0IHRvIHdpbmQgdXBcbiAgLy8gYWZ0ZXIgdGhlIGFuaW1hdGlvbi4gRmlyc3Qgd2UgZ2V0IHRoZSBib3ggaW4gYWJzb2x1dGUgdGVybXMgKEFLQSByZWxhdGl2ZVxuICAvLyB0byB0aGUgdmlld3BvcnQpLCBhbmQgdGhlbiB3ZSBjYWxjdWxhdGUgaXRzIHJlbGF0aXZlIGJveCAocmVsYXRpdmUgdG8gdGhlXG4gIC8vIHBhcmVudCBjb250YWluZXIpXG4gIHZhciBuZXdBYnNvbHV0ZUJveCA9IGdldFBvc2l0aW9uKGNoaWxkRG9tTm9kZSk7XG4gIHZhciBuZXdSZWxhdGl2ZUJveCA9IHtcbiAgICB0b3A6IG5ld0Fic29sdXRlQm94LnRvcCAtIHBhcmVudEJveC50b3AsXG4gICAgbGVmdDogbmV3QWJzb2x1dGVCb3gubGVmdCAtIHBhcmVudEJveC5sZWZ0XG4gIH07XG5cbiAgcmV0dXJuIFtvbGRSZWxhdGl2ZUJveC5sZWZ0IC0gbmV3UmVsYXRpdmVCb3gubGVmdCwgb2xkUmVsYXRpdmVCb3gudG9wIC0gbmV3UmVsYXRpdmVCb3gudG9wXTtcbn07XG5cbi8qKiByZW1vdmVOb2RlRnJvbURPTUZsb3dcbiAqIFRoaXMgbWV0aG9kIGRvZXMgc29tZXRoaW5nIHZlcnkgc25lYWt5OiBpdCByZW1vdmVzIGEgRE9NIG5vZGUgZnJvbSB0aGVcbiAqIGRvY3VtZW50IGZsb3csIGJ1dCB3aXRob3V0IGFjdHVhbGx5IGNoYW5naW5nIGl0cyBvbi1zY3JlZW4gcG9zaXRpb24uXG4gKlxuICogSXQgd29ya3MgYnkgY2FsY3VsYXRpbmcgd2hlcmUgdGhlIG5vZGUgaXMsIGFuZCB0aGVuIGFwcGx5aW5nIHN0eWxlc1xuICogc28gdGhhdCBpdCB3aW5kcyB1cCBiZWluZyBwb3NpdGlvbmVkIGFic29sdXRlbHksIGJ1dCBpbiBleGFjdGx5IHRoZVxuICogc2FtZSBwbGFjZS5cbiAqXG4gKiBUaGlzIGlzIGEgdml0YWwgcGFydCBvZiB0aGUgRkxJUCB0ZWNobmlxdWUuXG4gKi9cbnZhciByZW1vdmVOb2RlRnJvbURPTUZsb3cgPSBmdW5jdGlvbiByZW1vdmVOb2RlRnJvbURPTUZsb3coY2hpbGREYXRhLCB2ZXJ0aWNhbEFsaWdubWVudCkge1xuICB2YXIgZG9tTm9kZSA9IGNoaWxkRGF0YS5kb21Ob2RlLFxuICAgICAgYm91bmRpbmdCb3ggPSBjaGlsZERhdGEuYm91bmRpbmdCb3g7XG5cblxuICBpZiAoIWRvbU5vZGUgfHwgIWJvdW5kaW5nQm94KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRm9yIHRoaXMgdG8gd29yaywgd2UgaGF2ZSB0byBvZmZzZXQgYW55IGdpdmVuIGBtYXJnaW5gLlxuICB2YXIgY29tcHV0ZWQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb21Ob2RlKTtcblxuICAvLyBXZSBuZWVkIHRvIGNsZWFuIHVwIG1hcmdpbnMsIGJ5IGNvbnZlcnRpbmcgYW5kIHJlbW92aW5nIHN1ZmZpeDpcbiAgLy8gZWcuICcyMXB4JyAtPiAyMVxuICB2YXIgbWFyZ2luQXR0cnMgPSBbJ21hcmdpbi10b3AnLCAnbWFyZ2luLWxlZnQnLCAnbWFyZ2luLXJpZ2h0J107XG4gIHZhciBtYXJnaW5zID0gbWFyZ2luQXR0cnMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIG1hcmdpbikge1xuICAgIHZhciBfYmFiZWxIZWxwZXJzJGV4dGVuZHM7XG5cbiAgICB2YXIgcHJvcGVydHlWYWwgPSBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKG1hcmdpbik7XG5cbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGFjYywgKF9iYWJlbEhlbHBlcnMkZXh0ZW5kcyA9IHt9LCBfYmFiZWxIZWxwZXJzJGV4dGVuZHNbbWFyZ2luXSA9IE51bWJlcihwcm9wZXJ0eVZhbC5yZXBsYWNlKCdweCcsICcnKSksIF9iYWJlbEhlbHBlcnMkZXh0ZW5kcykpO1xuICB9LCB7fSk7XG5cbiAgLy8gSWYgd2UncmUgYm90dG9tLWFsaWduZWQsIHdlIG5lZWQgdG8gYWRkIHRoZSBoZWlnaHQgb2YgdGhlIGNoaWxkIHRvIGl0c1xuICAvLyB0b3Agb2Zmc2V0LiBUaGlzIGlzIGJlY2F1c2UsIHdoZW4gdGhlIGNvbnRhaW5lciBpcyBib3R0b20tYWxpZ25lZCwgaXRzXG4gIC8vIGhlaWdodCBzaHJpbmtzIGZyb20gdGhlIHRvcCwgbm90IHRoZSBib3R0b20uIFdlJ3JlIHJlbW92aW5nIHRoaXMgbm9kZVxuICAvLyBmcm9tIHRoZSBmbG93LCBzbyB0aGUgdG9wIGlzIGdvaW5nIHRvIGRyb3AgYnkgaXRzIGhlaWdodC5cbiAgdmFyIHRvcE9mZnNldCA9IHZlcnRpY2FsQWxpZ25tZW50ID09PSAnYm90dG9tJyA/IGJvdW5kaW5nQm94LnRvcCAtIGJvdW5kaW5nQm94LmhlaWdodCA6IGJvdW5kaW5nQm94LnRvcDtcblxuICB2YXIgc3R5bGVzID0ge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHRvcDogdG9wT2Zmc2V0IC0gbWFyZ2luc1snbWFyZ2luLXRvcCddICsgJ3B4JyxcbiAgICBsZWZ0OiBib3VuZGluZ0JveC5sZWZ0IC0gbWFyZ2luc1snbWFyZ2luLWxlZnQnXSArICdweCcsXG4gICAgcmlnaHQ6IGJvdW5kaW5nQm94LnJpZ2h0IC0gbWFyZ2luc1snbWFyZ2luLXJpZ2h0J10gKyAncHgnXG4gIH07XG5cbiAgYXBwbHlTdHlsZXNUb0RPTU5vZGUoeyBkb21Ob2RlOiBkb21Ob2RlLCBzdHlsZXM6IHN0eWxlcyB9KTtcbn07XG5cbi8qKiB1cGRhdGVIZWlnaHRQbGFjZWhvbGRlclxuICogQW4gb3B0aW9uYWwgcHJvcGVydHkgdG8gRmxpcE1vdmUgaXMgYSBgbWFpbnRhaW5Db250YWluZXJIZWlnaHRgIGJvb2xlYW4uXG4gKiBUaGlzIHByb3BlcnR5IGNyZWF0ZXMgYSBub2RlIHRoYXQgZmlsbHMgc3BhY2UsIHNvIHRoYXQgdGhlIHBhcmVudFxuICogY29udGFpbmVyIGRvZXNuJ3QgY29sbGFwc2Ugd2hlbiBpdHMgY2hpbGRyZW4gYXJlIHJlbW92ZWQgZnJvbSB0aGVcbiAqIGRvY3VtZW50IGZsb3cuXG4gKi9cbnZhciB1cGRhdGVIZWlnaHRQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIHVwZGF0ZUhlaWdodFBsYWNlaG9sZGVyKF9yZWY0KSB7XG4gIHZhciBkb21Ob2RlID0gX3JlZjQuZG9tTm9kZSxcbiAgICAgIHBhcmVudERhdGEgPSBfcmVmNC5wYXJlbnREYXRhLFxuICAgICAgZ2V0UG9zaXRpb24gPSBfcmVmNC5nZXRQb3NpdGlvbjtcblxuICB2YXIgcGFyZW50RG9tTm9kZSA9IHBhcmVudERhdGEuZG9tTm9kZTtcbiAgdmFyIHBhcmVudEJvdW5kaW5nQm94ID0gcGFyZW50RGF0YS5ib3VuZGluZ0JveDtcblxuICBpZiAoIXBhcmVudERvbU5vZGUgfHwgIXBhcmVudEJvdW5kaW5nQm94KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gV2UgbmVlZCB0byBmaW5kIHRoZSBoZWlnaHQgb2YgdGhlIGNvbnRhaW5lciAqd2l0aG91dCogdGhlIHBsYWNlaG9sZGVyLlxuICAvLyBTaW5jZSBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHBsYWNlaG9sZGVyIG1pZ2h0IGFscmVhZHkgYmUgcHJlc2VudCxcbiAgLy8gd2UgZmlyc3Qgc2V0IGl0cyBoZWlnaHQgdG8gMC5cbiAgLy8gVGhpcyBhbGxvd3MgdGhlIGNvbnRhaW5lciB0byBjb2xsYXBzZSBkb3duIHRvIHRoZSBzaXplIG9mIGp1c3QgaXRzXG4gIC8vIGNvbnRlbnQgKHBsdXMgY29udGFpbmVyIHBhZGRpbmcgb3IgYm9yZGVycyBpZiBhbnkpLlxuICBhcHBseVN0eWxlc1RvRE9NTm9kZSh7IGRvbU5vZGU6IGRvbU5vZGUsIHN0eWxlczogeyBoZWlnaHQ6ICcwJyB9IH0pO1xuXG4gIC8vIEZpbmQgdGhlIGRpc3RhbmNlIGJ5IHdoaWNoIHRoZSBjb250YWluZXIgd291bGQgYmUgY29sbGFwc2VkIGJ5IGVsZW1lbnRzXG4gIC8vIGxlYXZpbmcuIFdlIGNvbXBhcmUgdGhlIGZyZXNobHktYXZhaWxhYmxlIHBhcmVudCBoZWlnaHQgd2l0aCB0aGUgb3JpZ2luYWwsXG4gIC8vIGNhY2hlZCBjb250YWluZXIgaGVpZ2h0LlxuICB2YXIgb3JpZ2luYWxQYXJlbnRIZWlnaHQgPSBwYXJlbnRCb3VuZGluZ0JveC5oZWlnaHQ7XG4gIHZhciBjb2xsYXBzZWRQYXJlbnRIZWlnaHQgPSBnZXRQb3NpdGlvbihwYXJlbnREb21Ob2RlKS5oZWlnaHQ7XG4gIHZhciByZWR1Y3Rpb25JbkhlaWdodCA9IG9yaWdpbmFsUGFyZW50SGVpZ2h0IC0gY29sbGFwc2VkUGFyZW50SGVpZ2h0O1xuXG4gIC8vIElmIHRoZSBjb250YWluZXIgaGFzIGJlY29tZSBzaG9ydGVyLCB1cGRhdGUgdGhlIHBhZGRpbmcgZWxlbWVudCdzXG4gIC8vIGhlaWdodCB0byB0YWtlIHVwIHRoZSBkaWZmZXJlbmNlLiBPdGhlcndpc2Ugc2V0IGl0cyBoZWlnaHQgdG8gemVybyxcbiAgLy8gc28gdGhhdCBpdCBoYXMgbm8gZWZmZWN0LlxuICB2YXIgc3R5bGVzID0ge1xuICAgIGhlaWdodDogcmVkdWN0aW9uSW5IZWlnaHQgPiAwID8gcmVkdWN0aW9uSW5IZWlnaHQgKyAncHgnIDogJzAnXG4gIH07XG5cbiAgYXBwbHlTdHlsZXNUb0RPTU5vZGUoeyBkb21Ob2RlOiBkb21Ob2RlLCBzdHlsZXM6IHN0eWxlcyB9KTtcbn07XG5cbnZhciBnZXROYXRpdmVOb2RlID0gZnVuY3Rpb24gZ2V0TmF0aXZlTm9kZShlbGVtZW50KSB7XG4gIC8vIFdoZW4gcnVubmluZyBpbiBhIHdpbmRvd2xlc3MgZW52aXJvbm1lbnQsIGFib3J0IVxuICBpZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gYGVsZW1lbnRgIG1heSBhbHJlYWR5IGJlIGEgbmF0aXZlIG5vZGUuXG4gIGlmIChlbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIC8vIFdoaWxlIFJlYWN0RE9NJ3MgYGZpbmRET01Ob2RlYCBpcyBkaXNjb3VyYWdlZCwgaXQncyB0aGUgb25seVxuICAvLyBwdWJsaWNseS1leHBvc2VkIHdheSB0byBmaW5kIHRoZSB1bmRlcmx5aW5nIERPTSBub2RlIGZvclxuICAvLyBjb21wb3NpdGUgY29tcG9uZW50cy5cbiAgdmFyIGZvdW5kTm9kZSA9IGZpbmRET01Ob2RlKGVsZW1lbnQpO1xuXG4gIGlmIChmb3VuZE5vZGUgJiYgZm91bmROb2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgIC8vIFRleHQgbm9kZXMgYXJlIG5vdCBzdXBwb3J0ZWRcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZmxvd3R5cGUvbm8td2Vhay10eXBlc1xuICByZXR1cm4gZm91bmROb2RlO1xufTtcblxudmFyIGNyZWF0ZVRyYW5zaXRpb25TdHJpbmcgPSBmdW5jdGlvbiBjcmVhdGVUcmFuc2l0aW9uU3RyaW5nKGluZGV4LCBwcm9wcykge1xuICB2YXIgZGVsYXkgPSBwcm9wcy5kZWxheSxcbiAgICAgIGR1cmF0aW9uID0gcHJvcHMuZHVyYXRpb247XG4gIHZhciBzdGFnZ2VyRHVyYXRpb25CeSA9IHByb3BzLnN0YWdnZXJEdXJhdGlvbkJ5LFxuICAgICAgc3RhZ2dlckRlbGF5QnkgPSBwcm9wcy5zdGFnZ2VyRGVsYXlCeSxcbiAgICAgIGVhc2luZyA9IHByb3BzLmVhc2luZztcblxuXG4gIGRlbGF5ICs9IGluZGV4ICogc3RhZ2dlckRlbGF5Qnk7XG4gIGR1cmF0aW9uICs9IGluZGV4ICogc3RhZ2dlckR1cmF0aW9uQnk7XG5cbiAgdmFyIGNzc1Byb3BlcnRpZXMgPSBbJ3RyYW5zZm9ybScsICdvcGFjaXR5J107XG5cbiAgcmV0dXJuIGNzc1Byb3BlcnRpZXMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuIHByb3AgKyAnICcgKyBkdXJhdGlvbiArICdtcyAnICsgZWFzaW5nICsgJyAnICsgZGVsYXkgKyAnbXMnO1xuICB9KS5qb2luKCcsICcpO1xufTtcblxuLyoqXG4gKiBSZWFjdCBGbGlwIE1vdmVcbiAqIChjKSAyMDE2LXByZXNlbnQgSm9zaHVhIENvbWVhdVxuICpcbiAqIEZvciBpbmZvcm1hdGlvbiBvbiBob3cgdGhpcyBjb2RlIGlzIGxhaWQgb3V0LCBjaGVjayBvdXQgQ09ERV9UT1VSLm1kXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgcmVhY3QvcHJvcC10eXBlcyAqL1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwbGljYXRlLWltcG9ydHNcblxuXG52YXIgdHJhbnNpdGlvbkVuZCA9IHdoaWNoVHJhbnNpdGlvbkV2ZW50KCk7XG52YXIgbm9Ccm93c2VyU3VwcG9ydCA9ICF0cmFuc2l0aW9uRW5kO1xuXG5mdW5jdGlvbiBnZXRLZXkoY2hpbGREYXRhKSB7XG4gIHJldHVybiBjaGlsZERhdGEua2V5IHx8ICcnO1xufVxuXG5mdW5jdGlvbiBnZXRFbGVtZW50Q2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgLy8gRml4IGluY29tcGxldGUgdHlwaW5nIG9mIENoaWxkcmVuLnRvQXJyYXlcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZsb3d0eXBlL25vLXdlYWstdHlwZXNcbiAgcmV0dXJuIENoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pO1xufVxuXG52YXIgRmxpcE1vdmUkMSA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKEZsaXBNb3ZlLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBGbGlwTW92ZSgpIHtcbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgRmxpcE1vdmUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbC5hcHBseShfQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuc3RhdGUgPSB7XG4gICAgICBjaGlsZHJlbjogZ2V0RWxlbWVudENoaWxkcmVuKFxuICAgICAgLy8gYHRoaXMucHJvcHNgIG91Z2h0IHRvIGFsd2F5cyBiZSBkZWZpbmVkIGF0IHRoaXMgcG9pbnQsIGJ1dCBhIHJlcG9ydFxuICAgICAgLy8gd2FzIG1hZGUgYWJvdXQgaXQgbm90IGJlaW5nIGRlZmluZWQgaW4gSUUxMC5cbiAgICAgIC8vIFRPRE86IFRlc3QgaW4gSUUxMCwgdG8gc2VlIGlmIHRoZXJlJ3MgYW4gdW5kZXJseWluZyBjYXVzZSB0aGF0IGNhblxuICAgICAgLy8gYmUgYWRkcmVzc2VkLlxuICAgICAgX3RoaXMucHJvcHMgPyBfdGhpcy5wcm9wcy5jaGlsZHJlbiA6IFtdKS5tYXAoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBlbGVtZW50LCB7XG4gICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICBhcHBlYXJpbmc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9KVxuICAgIH0sIF90aGlzLmNoaWxkcmVuRGF0YSA9IHt9LCBfdGhpcy5wYXJlbnREYXRhID0ge1xuICAgICAgZG9tTm9kZTogbnVsbCxcbiAgICAgIGJvdW5kaW5nQm94OiBudWxsXG4gICAgfSwgX3RoaXMuaGVpZ2h0UGxhY2Vob2xkZXJEYXRhID0ge1xuICAgICAgZG9tTm9kZTogbnVsbFxuICAgIH0sIF90aGlzLnJlbWFpbmluZ0FuaW1hdGlvbnMgPSAwLCBfdGhpcy5jaGlsZHJlblRvQW5pbWF0ZSA9IFtdLCBfdGhpcy5maW5kRE9NQ29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLWZpbmQtZG9tLW5vZGVcbiAgICAgIHZhciBkb21Ob2RlID0gUmVhY3RET00uZmluZERPTU5vZGUoX3RoaXMpO1xuICAgICAgdmFyIHBhcmVudE5vZGUgPSBkb21Ob2RlICYmIGRvbU5vZGUucGFyZW50Tm9kZTtcblxuICAgICAgLy8gVGhpcyBvdWdodCB0byBiZSBpbXBvc3NpYmxlLCBidXQgaGFuZGxpbmcgaXQgZm9yIEZsb3cncyBzYWtlLlxuICAgICAgaWYgKCFwYXJlbnROb2RlIHx8ICEocGFyZW50Tm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBwYXJlbnQgbm9kZSBoYXMgc3RhdGljIHBvc2l0aW9uaW5nLCBsZWF2ZSBhbmltYXRpb25zIG1pZ2h0IGxvb2tcbiAgICAgIC8vIHJlYWxseSBmdW5reS4gTGV0J3MgYXV0b21hdGljYWxseSBhcHBseSBgcG9zaXRpb246IHJlbGF0aXZlYCBpbiB0aGlzXG4gICAgICAvLyBjYXNlLCB0byBwcmV2ZW50IGFueSBxdWlya2luZXNzLlxuICAgICAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHBhcmVudE5vZGUpLnBvc2l0aW9uID09PSAnc3RhdGljJykge1xuICAgICAgICBwYXJlbnROb2RlLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgICAgcGFyZW50Tm9kZVBvc2l0aW9uU3RhdGljKCk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnBhcmVudERhdGEuZG9tTm9kZSA9IHBhcmVudE5vZGU7XG4gICAgfSwgX3RoaXMucnVuQW5pbWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGR5bmFtaWNDaGlsZHJlbiA9IF90aGlzLnN0YXRlLmNoaWxkcmVuLmZpbHRlcihfdGhpcy5kb2VzQ2hpbGROZWVkVG9CZUFuaW1hdGVkKTtcblxuICAgICAgLy8gU3BsaXR0aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzIHRvIGJlIHBlZm9ybWVkIGluIGJhdGNoZXNcbiAgICAgIHZhciBjaGlsZHJlbkluaXRpYWxTdHlsZXMgPSBkeW5hbWljQ2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuY29tcHV0ZUluaXRpYWxTdHlsZXMoY2hpbGQpO1xuICAgICAgfSk7XG4gICAgICBkeW5hbWljQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQsIGluZGV4KSB7XG4gICAgICAgIF90aGlzLnJlbWFpbmluZ0FuaW1hdGlvbnMgKz0gMTtcbiAgICAgICAgX3RoaXMuY2hpbGRyZW5Ub0FuaW1hdGUucHVzaChnZXRLZXkoY2hpbGQpKTtcbiAgICAgICAgX3RoaXMuYW5pbWF0ZUNoaWxkKGNoaWxkLCBpbmRleCwgY2hpbGRyZW5Jbml0aWFsU3R5bGVzW2luZGV4XSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBfdGhpcy5wcm9wcy5vblN0YXJ0QWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIF90aGlzLmNhbGxDaGlsZHJlbkhvb2soX3RoaXMucHJvcHMub25TdGFydEFsbCk7XG4gICAgICB9XG4gICAgfSwgX3RoaXMuZG9lc0NoaWxkTmVlZFRvQmVBbmltYXRlZCA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgLy8gSWYgdGhlIGNoaWxkIGRvZXNuJ3QgaGF2ZSBhIGtleSwgaXQncyBhbiBpbW1vdmFibGUgY2hpbGQgKG9uZSB0aGF0IHdlXG4gICAgICAvLyBkbyBub3Qgd2FudCB0byBkbyBGTElQIHN0dWZmIHRvLilcbiAgICAgIGlmICghZ2V0S2V5KGNoaWxkKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGlsZERhdGEgPSBfdGhpcy5nZXRDaGlsZERhdGEoZ2V0S2V5KGNoaWxkKSk7XG4gICAgICB2YXIgY2hpbGREb21Ob2RlID0gY2hpbGREYXRhLmRvbU5vZGU7XG4gICAgICB2YXIgY2hpbGRCb3VuZGluZ0JveCA9IGNoaWxkRGF0YS5ib3VuZGluZ0JveDtcbiAgICAgIHZhciBwYXJlbnRCb3VuZGluZ0JveCA9IF90aGlzLnBhcmVudERhdGEuYm91bmRpbmdCb3g7XG5cbiAgICAgIGlmICghY2hpbGREb21Ob2RlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIF90aGlzJHByb3BzID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgYXBwZWFyQW5pbWF0aW9uID0gX3RoaXMkcHJvcHMuYXBwZWFyQW5pbWF0aW9uLFxuICAgICAgICAgIGVudGVyQW5pbWF0aW9uID0gX3RoaXMkcHJvcHMuZW50ZXJBbmltYXRpb24sXG4gICAgICAgICAgbGVhdmVBbmltYXRpb24gPSBfdGhpcyRwcm9wcy5sZWF2ZUFuaW1hdGlvbixcbiAgICAgICAgICBnZXRQb3NpdGlvbiA9IF90aGlzJHByb3BzLmdldFBvc2l0aW9uO1xuXG5cbiAgICAgIHZhciBpc0FwcGVhcmluZ1dpdGhBbmltYXRpb24gPSBjaGlsZC5hcHBlYXJpbmcgJiYgYXBwZWFyQW5pbWF0aW9uO1xuICAgICAgdmFyIGlzRW50ZXJpbmdXaXRoQW5pbWF0aW9uID0gY2hpbGQuZW50ZXJpbmcgJiYgZW50ZXJBbmltYXRpb247XG4gICAgICB2YXIgaXNMZWF2aW5nV2l0aEFuaW1hdGlvbiA9IGNoaWxkLmxlYXZpbmcgJiYgbGVhdmVBbmltYXRpb247XG5cbiAgICAgIGlmIChpc0FwcGVhcmluZ1dpdGhBbmltYXRpb24gfHwgaXNFbnRlcmluZ1dpdGhBbmltYXRpb24gfHwgaXNMZWF2aW5nV2l0aEFuaW1hdGlvbikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgaXQgaXNuJ3QgZW50ZXJpbmcvbGVhdmluZywgd2Ugd2FudCB0byBhbmltYXRlIGl0IGlmIGl0J3NcbiAgICAgIC8vIG9uLXNjcmVlbiBwb3NpdGlvbiBoYXMgY2hhbmdlZC5cblxuICAgICAgdmFyIF9nZXRQb3NpdGlvbkRlbHRhID0gZ2V0UG9zaXRpb25EZWx0YSh7XG4gICAgICAgIGNoaWxkRG9tTm9kZTogY2hpbGREb21Ob2RlLFxuICAgICAgICBjaGlsZEJvdW5kaW5nQm94OiBjaGlsZEJvdW5kaW5nQm94LFxuICAgICAgICBwYXJlbnRCb3VuZGluZ0JveDogcGFyZW50Qm91bmRpbmdCb3gsXG4gICAgICAgIGdldFBvc2l0aW9uOiBnZXRQb3NpdGlvblxuICAgICAgfSksXG4gICAgICAgICAgZFggPSBfZ2V0UG9zaXRpb25EZWx0YVswXSxcbiAgICAgICAgICBkWSA9IF9nZXRQb3NpdGlvbkRlbHRhWzFdO1xuXG4gICAgICByZXR1cm4gZFggIT09IDAgfHwgZFkgIT09IDA7XG4gICAgfSwgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuICAvLyBDb3B5IHByb3BzLmNoaWxkcmVuIGludG8gc3RhdGUuXG4gIC8vIFRvIHVuZGVyc3RhbmQgd2h5IHRoaXMgaXMgaW1wb3J0YW50IChhbmQgbm90IGFuIGFudGktcGF0dGVybiksIGNvbnNpZGVyXG4gIC8vIGhvdyBcImxlYXZlXCIgYW5pbWF0aW9ucyB3b3JrLiBBbiBpdGVtIGhhcyBcImxlZnRcIiB3aGVuIHRoZSBjb21wb25lbnRcbiAgLy8gcmVjZWl2ZXMgYSBuZXcgc2V0IG9mIHByb3BzIHRoYXQgZG8gTk9UIGNvbnRhaW4gdGhlIGl0ZW0uXG4gIC8vIElmIHdlIGp1c3QgcmVuZGVyIHRoZSBwcm9wcyBhcy1pcywgdGhlIGl0ZW0gd291bGQgaW5zdGFudGx5IGRpc2FwcGVhci5cbiAgLy8gV2Ugd2FudCB0byBrZWVwIHRoZSBpdGVtIHJlbmRlcmVkIGZvciBhIGxpdHRsZSB3aGlsZSwgdW50aWwgaXRzIGFuaW1hdGlvblxuICAvLyBjYW4gY29tcGxldGUuIEJlY2F1c2Ugd2UgY2Fubm90IG11dGF0ZSBwcm9wcywgd2UgbWFrZSBgc3RhdGVgIHRoZSBzb3VyY2VcbiAgLy8gb2YgdHJ1dGguXG5cblxuICAvLyBGbGlwTW92ZSBuZWVkcyB0byBrbm93IHF1aXRlIGEgYml0IGFib3V0IGl0cyBjaGlsZHJlbiBpbiBvcmRlciB0byBkb1xuICAvLyBpdHMgam9iLiBXZSBzdG9yZSB0aGVzZSBhcyBhIHByb3BlcnR5IG9uIHRoZSBpbnN0YW5jZS4gV2UncmUgbm90IHVzaW5nXG4gIC8vIHN0YXRlLCBiZWNhdXNlIHdlIGRvbid0IHdhbnQgY2hhbmdlcyB0byB0cmlnZ2VyIHJlLXJlbmRlcnMsIHdlIGp1c3RcbiAgLy8gbmVlZCBhIHBsYWNlIHRvIGtlZXAgdGhlIGRhdGEgZm9yIHJlZmVyZW5jZSwgd2hlbiBjaGFuZ2VzIGhhcHBlbi5cbiAgLy8gVGhpcyBmaWVsZCBzaG91bGQgbm90IGJlIGFjY2Vzc2VkIGRpcmVjdGx5LiBJbnN0ZWFkLCB1c2UgZ2V0Q2hpbGREYXRhLFxuICAvLyBwdXRDaGlsZERhdGEsIGV0Yy4uLlxuXG5cbiAgLy8gU2ltaWxhcmx5LCB0cmFjayB0aGUgZG9tIG5vZGUgYW5kIGJveCBvZiBvdXIgcGFyZW50IGVsZW1lbnQuXG5cblxuICAvLyBJZiBgbWFpbnRhaW5Db250YWluZXJIZWlnaHRgIHByb3AgaXMgc2V0IHRvIHRydWUsIHdlJ2xsIGNyZWF0ZSBhXG4gIC8vIHBsYWNlaG9sZGVyIGVsZW1lbnQgd2hpY2ggb2NjdXBpZXMgc3BhY2Ugc28gdGhhdCB0aGUgcGFyZW50IGhlaWdodFxuICAvLyBkb2Vzbid0IGNoYW5nZSB3aGVuIGl0ZW1zIGFyZSByZW1vdmVkIGZyb20gdGhlIGRvY3VtZW50IGZsb3cgKHdoaWNoXG4gIC8vIGhhcHBlbnMgZHVyaW5nIGxlYXZlIGFuaW1hdGlvbnMpXG5cblxuICAvLyBLZWVwIHRyYWNrIG9mIHJlbWFpbmluZyBhbmltYXRpb25zIHNvIHdlIGtub3cgd2hlbiB0byBmaXJlIHRoZVxuICAvLyBhbGwtZmluaXNoZWQgY2FsbGJhY2ssIGFuZCBjbGVhbiB1cCBhZnRlciBvdXJzZWx2ZXMuXG4gIC8vIE5PVEU6IHdlIGNhbid0IHNpbXBseSB1c2UgY2hpbGRyZW5Ub0FuaW1hdGUubGVuZ3RoIHRvIHRyYWNrIHJlbWFpbmluZ1xuICAvLyBhbmltYXRpb25zLCBiZWNhdXNlIHdlIG5lZWQgdG8gbWFpbnRhaW4gdGhlIGxpc3Qgb2YgYW5pbWF0aW5nIGNoaWxkcmVuLFxuICAvLyB0byBwYXNzIHRvIHRoZSBgb25GaW5pc2hBbGxgIGhhbmRsZXIuXG5cblxuICBGbGlwTW92ZS5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAvLyBCZWNhdXNlIFJlYWN0IDE2IG5vIGxvbmdlciByZXF1aXJlcyB3cmFwcGluZyBlbGVtZW50cywgRmxpcCBNb3ZlIGNhbiBvcHRcbiAgICAvLyB0byBub3Qgd3JhcCB0aGUgY2hpbGRyZW4gaW4gYW4gZWxlbWVudC4gSW4gdGhhdCBjYXNlLCBmaW5kIHRoZSBwYXJlbnRcbiAgICAvLyBlbGVtZW50IHVzaW5nIGBmaW5kRE9NTm9kZWAuXG4gICAgaWYgKHRoaXMucHJvcHMudHlwZU5hbWUgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuZmluZERPTUNvbnRhaW5lcigpO1xuICAgIH1cblxuICAgIC8vIFJ1biBvdXIgYGFwcGVhckFuaW1hdGlvbmAgaWYgaXQgd2FzIHJlcXVlc3RlZCwgcmlnaHQgYWZ0ZXIgdGhlXG4gICAgLy8gY29tcG9uZW50IG1vdW50cy5cbiAgICB2YXIgc2hvdWxkVHJpZ2dlckZMSVAgPSB0aGlzLnByb3BzLmFwcGVhckFuaW1hdGlvbiAmJiAhdGhpcy5pc0FuaW1hdGlvbkRpc2FibGVkKHRoaXMucHJvcHMpO1xuXG4gICAgaWYgKHNob3VsZFRyaWdnZXJGTElQKSB7XG4gICAgICB0aGlzLnByZXBGb3JBbmltYXRpb24oKTtcbiAgICAgIHRoaXMucnVuQW5pbWF0aW9uKCk7XG4gICAgfVxuICB9O1xuXG4gIEZsaXBNb3ZlLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAvLyBXaGVuIHRoZSBjb21wb25lbnQgaXMgaGFuZGVkIG5ldyBwcm9wcywgd2UgbmVlZCB0byBmaWd1cmUgb3V0IHRoZVxuICAgIC8vIFwicmVzdGluZ1wiIHBvc2l0aW9uIG9mIGFsbCBjdXJyZW50bHktcmVuZGVyZWQgRE9NIG5vZGVzLlxuICAgIC8vIFdlIHN0b3JlIHRoYXQgZGF0YSBpbiB0aGlzLnBhcmVudCBhbmQgdGhpcy5jaGlsZHJlbixcbiAgICAvLyBzbyBpdCBjYW4gYmUgdXNlZCBsYXRlciB0byB3b3JrIG91dCB0aGUgYW5pbWF0aW9uLlxuICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3hDYWNoZXMoKTtcblxuICAgIC8vIENvbnZlcnQgb3BhcXVlIGNoaWxkcmVuIG9iamVjdCB0byBhcnJheS5cbiAgICB2YXIgbmV4dENoaWxkcmVuID0gZ2V0RWxlbWVudENoaWxkcmVuKG5leHRQcm9wcy5jaGlsZHJlbik7XG5cbiAgICAvLyBOZXh0LCB3ZSBuZWVkIHRvIHVwZGF0ZSBvdXIgc3RhdGUsIHNvIHRoYXQgaXQgY29udGFpbnMgb3VyIG5ldyBzZXQgb2ZcbiAgICAvLyBjaGlsZHJlbi4gSWYgYW5pbWF0aW9uIGlzIGRpc2FibGVkIG9yIHVuc3VwcG9ydGVkLCB0aGlzIGlzIGVhc3k7XG4gICAgLy8gd2UganVzdCBjb3B5IG91ciBwcm9wcyBpbnRvIHN0YXRlLlxuICAgIC8vIEFzc3VtaW5nIHRoYXQgd2UgY2FuIGFuaW1hdGUsIHRob3VnaCwgd2UgaGF2ZSB0byBkbyBzb21lIHdvcmsuXG4gICAgLy8gRXNzZW50aWFsbHksIHdlIHdhbnQgdG8ga2VlcCBqdXN0LWRlbGV0ZWQgbm9kZXMgaW4gdGhlIERPTSBmb3IgYSBiaXRcbiAgICAvLyBsb25nZXIsIHNvIHRoYXQgd2UgY2FuIGFuaW1hdGUgdGhlbSBhd2F5LlxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgY2hpbGRyZW46IHRoaXMuaXNBbmltYXRpb25EaXNhYmxlZChuZXh0UHJvcHMpID8gbmV4dENoaWxkcmVuLm1hcChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGVsZW1lbnQsIHsgZWxlbWVudDogZWxlbWVudCB9KTtcbiAgICAgIH0pIDogdGhpcy5jYWxjdWxhdGVOZXh0U2V0T2ZDaGlsZHJlbihuZXh0Q2hpbGRyZW4pXG4gICAgfSk7XG4gIH07XG5cbiAgRmxpcE1vdmUucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2aW91c1Byb3BzKSB7XG4gICAgaWYgKHRoaXMucHJvcHMudHlwZU5hbWUgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuZmluZERPTUNvbnRhaW5lcigpO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgY2hpbGRyZW4gaGF2ZSBiZWVuIHJlLWFycmFuZ2VkLCBtb3ZlZCwgb3IgYWRkZWQvcmVtb3ZlZCxcbiAgICAvLyB0cmlnZ2VyIHRoZSBtYWluIEZMSVAgYW5pbWF0aW9uLlxuICAgIC8vXG4gICAgLy8gSU1QT1JUQU5UOiBXZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBjaGlsZHJlbiBoYXZlIGFjdHVhbGx5IGNoYW5nZWQuXG4gICAgLy8gQXQgdGhlIGVuZCBvZiB0aGUgdHJhbnNpdGlvbiwgd2UgY2xlYW4gdXAgbm9kZXMgdGhhdCBuZWVkIHRvIGJlIHJlbW92ZWQuXG4gICAgLy8gV2UgRE9OJ1Qgd2FudCB0aGlzIGNsZWFudXAgdG8gdHJpZ2dlciBhbm90aGVyIHVwZGF0ZS5cblxuICAgIHZhciBvbGRDaGlsZHJlbktleXMgPSBnZXRFbGVtZW50Q2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbikubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZC5rZXk7XG4gICAgfSk7XG4gICAgdmFyIG5leHRDaGlsZHJlbktleXMgPSBnZXRFbGVtZW50Q2hpbGRyZW4ocHJldmlvdXNQcm9wcy5jaGlsZHJlbikubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZC5rZXk7XG4gICAgfSk7XG5cbiAgICB2YXIgc2hvdWxkVHJpZ2dlckZMSVAgPSAhYXJyYXlzRXF1YWwob2xkQ2hpbGRyZW5LZXlzLCBuZXh0Q2hpbGRyZW5LZXlzKSAmJiAhdGhpcy5pc0FuaW1hdGlvbkRpc2FibGVkKHRoaXMucHJvcHMpO1xuXG4gICAgaWYgKHNob3VsZFRyaWdnZXJGTElQKSB7XG4gICAgICB0aGlzLnByZXBGb3JBbmltYXRpb24oKTtcbiAgICAgIHRoaXMucnVuQW5pbWF0aW9uKCk7XG4gICAgfVxuICB9O1xuXG4gIEZsaXBNb3ZlLnByb3RvdHlwZS5jYWxjdWxhdGVOZXh0U2V0T2ZDaGlsZHJlbiA9IGZ1bmN0aW9uIGNhbGN1bGF0ZU5leHRTZXRPZkNoaWxkcmVuKG5leHRDaGlsZHJlbikge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgLy8gV2Ugd2FudCB0bzpcbiAgICAvLyAgIC0gTWFyayBhbGwgbmV3IGNoaWxkcmVuIGFzIGBlbnRlcmluZ2BcbiAgICAvLyAgIC0gUHVsbCBpbiBwcmV2aW91cyBjaGlsZHJlbiB0aGF0IGFyZW4ndCBpbiBuZXh0Q2hpbGRyZW4sIGFuZCBtYXJrIHRoZW1cbiAgICAvLyAgICAgYXMgYGxlYXZpbmdgXG4gICAgLy8gICAtIFByZXNlcnZlIHRoZSBuZXh0Q2hpbGRyZW4gbGlzdCBvcmRlciwgd2l0aCBsZWF2aW5nIGNoaWxkcmVuIGluIHRoZWlyXG4gICAgLy8gICAgIGFwcHJvcHJpYXRlIHBsYWNlcy5cbiAgICAvL1xuXG4gICAgdmFyIHVwZGF0ZWRDaGlsZHJlbiA9IG5leHRDaGlsZHJlbi5tYXAoZnVuY3Rpb24gKG5leHRDaGlsZCkge1xuICAgICAgdmFyIGNoaWxkID0gX3RoaXMyLmZpbmRDaGlsZEJ5S2V5KG5leHRDaGlsZC5rZXkpO1xuXG4gICAgICAvLyBJZiB0aGUgY3VycmVudCBjaGlsZCBkaWQgZXhpc3QsIGJ1dCBpdCB3YXMgaW4gdGhlIG1pZHN0IG9mIGxlYXZpbmcsXG4gICAgICAvLyB3ZSB3YW50IHRvIHRyZWF0IGl0IGFzIHRob3VnaCBpdCdzIGVudGVyaW5nXG4gICAgICB2YXIgaXNFbnRlcmluZyA9ICFjaGlsZCB8fCBjaGlsZC5sZWF2aW5nO1xuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIG5leHRDaGlsZCwgeyBlbGVtZW50OiBuZXh0Q2hpbGQsIGVudGVyaW5nOiBpc0VudGVyaW5nIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gVGhpcyBpcyB0cmlja3kuIFdlIHdhbnQgdG8ga2VlcCB0aGUgbmV4dENoaWxkcmVuJ3Mgb3JkZXJpbmcsIGJ1dCB3aXRoXG4gICAgLy8gYW55IGp1c3QtcmVtb3ZlZCBpdGVtcyBtYWludGFpbmluZyB0aGVpciBvcmlnaW5hbCBwb3NpdGlvbi5cbiAgICAvLyBlZy5cbiAgICAvLyAgIHRoaXMuc3RhdGUuY2hpbGRyZW4gID0gWyAxLCAyLCAzLCA0IF1cbiAgICAvLyAgIG5leHRDaGlsZHJlbiAgICAgICAgID0gWyAzLCAxIF1cbiAgICAvL1xuICAgIC8vIEluIHRoaXMgZXhhbXBsZSwgd2UndmUgcmVtb3ZlZCB0aGUgJzInICYgJzQnXG4gICAgLy8gV2Ugd2FudCB0byBlbmQgdXAgd2l0aDogIFsgMiwgMywgMSwgNCBdXG4gICAgLy9cbiAgICAvLyBUbyBhY2NvbXBsaXNoIHRoYXQsIHdlJ2xsIGl0ZXJhdGUgdGhyb3VnaCB0aGlzLnN0YXRlLmNoaWxkcmVuLiB3aGVuZXZlclxuICAgIC8vIHdlIGZpbmQgYSBtYXRjaCwgd2UnbGwgYXBwZW5kIG91ciBgbGVhdmluZ2AgZmxhZyB0byBpdCwgYW5kIGluc2VydCBpdFxuICAgIC8vIGludG8gdGhlIG5leHRDaGlsZHJlbiBpbiBpdHMgT1JJR0lOQUwgcG9zaXRpb24uIE5vdGUgdGhhdCwgYXMgd2Uga2VlcFxuICAgIC8vIGluc2VydGluZyBvbGQgaXRlbXMgaW50byB0aGUgbmV3IGxpc3QsIHRoZSBcIm9yaWdpbmFsXCIgcG9zaXRpb24gd2lsbFxuICAgIC8vIGtlZXAgaW5jcmVtZW50aW5nLlxuICAgIHZhciBudW1PZkNoaWxkcmVuTGVhdmluZyA9IDA7XG4gICAgdGhpcy5zdGF0ZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCwgaW5kZXgpIHtcbiAgICAgIHZhciBpc0xlYXZpbmcgPSAhZmluZChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIga2V5ID0gX3JlZi5rZXk7XG4gICAgICAgIHJldHVybiBrZXkgPT09IGdldEtleShjaGlsZCk7XG4gICAgICB9LCBuZXh0Q2hpbGRyZW4pO1xuXG4gICAgICAvLyBJZiB0aGUgY2hpbGQgaXNuJ3QgbGVhdmluZyAob3IsIGlmIHRoZXJlIGlzIG5vIGxlYXZlIGFuaW1hdGlvbiksXG4gICAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIGFkZCBpdCBpbnRvIHRoZSBzdGF0ZSBjaGlsZHJlbi5cbiAgICAgIGlmICghaXNMZWF2aW5nIHx8ICFfdGhpczIucHJvcHMubGVhdmVBbmltYXRpb24pIHJldHVybjtcblxuICAgICAgdmFyIG5leHRDaGlsZCA9IF9leHRlbmRzKHt9LCBjaGlsZCwgeyBsZWF2aW5nOiB0cnVlIH0pO1xuICAgICAgdmFyIG5leHRDaGlsZEluZGV4ID0gaW5kZXggKyBudW1PZkNoaWxkcmVuTGVhdmluZztcblxuICAgICAgdXBkYXRlZENoaWxkcmVuLnNwbGljZShuZXh0Q2hpbGRJbmRleCwgMCwgbmV4dENoaWxkKTtcbiAgICAgIG51bU9mQ2hpbGRyZW5MZWF2aW5nICs9IDE7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdXBkYXRlZENoaWxkcmVuO1xuICB9O1xuXG4gIEZsaXBNb3ZlLnByb3RvdHlwZS5wcmVwRm9yQW5pbWF0aW9uID0gZnVuY3Rpb24gcHJlcEZvckFuaW1hdGlvbigpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIC8vIE91ciBhbmltYXRpb24gcHJlcCBjb25zaXN0cyBvZjpcbiAgICAvLyAtIHJlbW92ZSBjaGlsZHJlbiB0aGF0IGFyZSBsZWF2aW5nIGZyb20gdGhlIERPTSBmbG93LCBzbyB0aGF0IHRoZSBuZXdcbiAgICAvLyAgIGxheW91dCBjYW4gYmUgYWNjdXJhdGVseSBjYWxjdWxhdGVkLFxuICAgIC8vIC0gdXBkYXRlIHRoZSBwbGFjZWhvbGRlciBjb250YWluZXIgaGVpZ2h0LCBpZiBuZWVkZWQsIHRvIGVuc3VyZSB0aGF0XG4gICAgLy8gICB0aGUgcGFyZW50J3MgaGVpZ2h0IGRvZXNuJ3QgY29sbGFwc2UuXG5cbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgbGVhdmVBbmltYXRpb24gPSBfcHJvcHMubGVhdmVBbmltYXRpb24sXG4gICAgICAgIG1haW50YWluQ29udGFpbmVySGVpZ2h0ID0gX3Byb3BzLm1haW50YWluQ29udGFpbmVySGVpZ2h0LFxuICAgICAgICBnZXRQb3NpdGlvbiA9IF9wcm9wcy5nZXRQb3NpdGlvbjtcblxuICAgIC8vIHdlIG5lZWQgdG8gbWFrZSBhbGwgbGVhdmluZyBub2RlcyBcImludmlzaWJsZVwiIHRvIHRoZSBsYXlvdXQgY2FsY3VsYXRpb25zXG4gICAgLy8gdGhhdCB3aWxsIHRha2UgcGxhY2UgaW4gdGhlIG5leHQgc3RlcCAodGhpcy5ydW5BbmltYXRpb24pLlxuXG4gICAgaWYgKGxlYXZlQW5pbWF0aW9uKSB7XG4gICAgICB2YXIgbGVhdmluZ0NoaWxkcmVuID0gdGhpcy5zdGF0ZS5jaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBjaGlsZC5sZWF2aW5nO1xuICAgICAgfSk7XG5cbiAgICAgIGxlYXZpbmdDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChsZWF2aW5nQ2hpbGQpIHtcbiAgICAgICAgdmFyIGNoaWxkRGF0YSA9IF90aGlzMy5nZXRDaGlsZERhdGEoZ2V0S2V5KGxlYXZpbmdDaGlsZCkpO1xuXG4gICAgICAgIC8vIFdhcm4gaWYgY2hpbGQgaXMgZGlzYWJsZWRcbiAgICAgICAgaWYgKCFfdGhpczMuaXNBbmltYXRpb25EaXNhYmxlZChfdGhpczMucHJvcHMpICYmIGNoaWxkRGF0YS5kb21Ob2RlICYmIGNoaWxkRGF0YS5kb21Ob2RlLmRpc2FibGVkKSB7XG4gICAgICAgICAgY2hpbGRJc0Rpc2FibGVkKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBuZWVkIHRvIHRha2UgdGhlIGl0ZW1zIG91dCBvZiB0aGUgXCJmbG93XCIgb2YgdGhlIGRvY3VtZW50LCBzbyB0aGF0XG4gICAgICAgIC8vIGl0cyBzaWJsaW5ncyBjYW4gbW92ZSB0byB0YWtlIGl0cyBwbGFjZS5cbiAgICAgICAgaWYgKGNoaWxkRGF0YS5ib3VuZGluZ0JveCkge1xuICAgICAgICAgIHJlbW92ZU5vZGVGcm9tRE9NRmxvdyhjaGlsZERhdGEsIF90aGlzMy5wcm9wcy52ZXJ0aWNhbEFsaWdubWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAobWFpbnRhaW5Db250YWluZXJIZWlnaHQgJiYgdGhpcy5oZWlnaHRQbGFjZWhvbGRlckRhdGEuZG9tTm9kZSkge1xuICAgICAgICB1cGRhdGVIZWlnaHRQbGFjZWhvbGRlcih7XG4gICAgICAgICAgZG9tTm9kZTogdGhpcy5oZWlnaHRQbGFjZWhvbGRlckRhdGEuZG9tTm9kZSxcbiAgICAgICAgICBwYXJlbnREYXRhOiB0aGlzLnBhcmVudERhdGEsXG4gICAgICAgICAgZ2V0UG9zaXRpb246IGdldFBvc2l0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZvciBhbGwgY2hpbGRyZW4gbm90IGluIHRoZSBtaWRkbGUgb2YgZW50ZXJpbmcgb3IgbGVhdmluZyxcbiAgICAvLyB3ZSBuZWVkIHRvIHJlc2V0IHRoZSB0cmFuc2l0aW9uLCBzbyB0aGF0IHRoZSBORVcgc2h1ZmZsZSBzdGFydHMgZnJvbVxuICAgIC8vIHRoZSByaWdodCBwbGFjZS5cbiAgICB0aGlzLnN0YXRlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICB2YXIgX2dldENoaWxkRGF0YSA9IF90aGlzMy5nZXRDaGlsZERhdGEoZ2V0S2V5KGNoaWxkKSksXG4gICAgICAgICAgZG9tTm9kZSA9IF9nZXRDaGlsZERhdGEuZG9tTm9kZTtcblxuICAgICAgLy8gSWdub3JlIGNoaWxkcmVuIHRoYXQgZG9uJ3QgcmVuZGVyIERPTSBub2RlcyAoZWcuIGJ5IHJldHVybmluZyBudWxsKVxuXG5cbiAgICAgIGlmICghZG9tTm9kZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghY2hpbGQuZW50ZXJpbmcgJiYgIWNoaWxkLmxlYXZpbmcpIHtcbiAgICAgICAgYXBwbHlTdHlsZXNUb0RPTU5vZGUoe1xuICAgICAgICAgIGRvbU5vZGU6IGRvbU5vZGUsXG4gICAgICAgICAgc3R5bGVzOiB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAnJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgRmxpcE1vdmUucHJvdG90eXBlLmFuaW1hdGVDaGlsZCA9IGZ1bmN0aW9uIGFuaW1hdGVDaGlsZChjaGlsZCwgaW5kZXgsIGNoaWxkSW5pdGlhbFN0eWxlcykge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgdmFyIF9nZXRDaGlsZERhdGEyID0gdGhpcy5nZXRDaGlsZERhdGEoZ2V0S2V5KGNoaWxkKSksXG4gICAgICAgIGRvbU5vZGUgPSBfZ2V0Q2hpbGREYXRhMi5kb21Ob2RlO1xuXG4gICAgaWYgKCFkb21Ob2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQXBwbHkgdGhlIHJlbGV2YW50IHN0eWxlIGZvciB0aGlzIERPTSBub2RlXG4gICAgLy8gVGhpcyBpcyB0aGUgb2Zmc2V0IGZyb20gaXRzIGFjdHVhbCBET00gcG9zaXRpb24uXG4gICAgLy8gZWcuIGlmIGFuIGl0ZW0gaGFzIGJlZW4gcmUtcmVuZGVyZWQgMjBweCBsb3dlciwgd2Ugd2FudCB0byBhcHBseSBhXG4gICAgLy8gc3R5bGUgb2YgJ3RyYW5zZm9ybTogdHJhbnNsYXRlKC0yMHB4KScsIHNvIHRoYXQgaXQgYXBwZWFycyB0byBiZSB3aGVyZVxuICAgIC8vIGl0IHN0YXJ0ZWQuXG4gICAgLy8gSW4gRkxJUCB0ZXJtaW5vbG9neSwgdGhpcyBpcyB0aGUgJ0ludmVydCcgc3RhZ2UuXG4gICAgYXBwbHlTdHlsZXNUb0RPTU5vZGUoe1xuICAgICAgZG9tTm9kZTogZG9tTm9kZSxcbiAgICAgIHN0eWxlczogY2hpbGRJbml0aWFsU3R5bGVzXG4gICAgfSk7XG5cbiAgICAvLyBTdGFydCBieSBpbnZva2luZyB0aGUgb25TdGFydCBjYWxsYmFjayBmb3IgdGhpcyBjaGlsZC5cbiAgICBpZiAodGhpcy5wcm9wcy5vblN0YXJ0KSB0aGlzLnByb3BzLm9uU3RhcnQoY2hpbGQsIGRvbU5vZGUpO1xuXG4gICAgLy8gTmV4dCwgYW5pbWF0ZSB0aGUgaXRlbSBmcm9tIGl0J3MgYXJ0aWZpY2lhbGx5LW9mZnNldCBwb3NpdGlvbiB0byBpdHNcbiAgICAvLyBuZXcsIG5hdHVyYWwgcG9zaXRpb24uXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIE5PVEUsIFJFOiB0aGUgZG91YmxlLXJlcXVlc3RBbmltYXRpb25GcmFtZTpcbiAgICAgICAgLy8gU2FkbHksIHRoaXMgaXMgdGhlIG1vc3QgYnJvd3Nlci1jb21wYXRpYmxlIHdheSB0byBkbyB0aGlzIEkndmUgZm91bmQuXG4gICAgICAgIC8vIEVzc2VudGlhbGx5IHdlIG5lZWQgdG8gc2V0IHRoZSBpbml0aWFsIHN0eWxlcyBvdXRzaWRlIG9mIGFueSByZXF1ZXN0XG4gICAgICAgIC8vIGNhbGxiYWNrcyB0byBhdm9pZCBiYXRjaGluZyB0aGVtLiBUaGVuLCBhIGZyYW1lIG5lZWRzIHRvIHBhc3Mgd2l0aFxuICAgICAgICAvLyB0aGUgc3R5bGVzIGFib3ZlIHJlbmRlcmVkLiBUaGVuLCBvbiB0aGUgc2Vjb25kIGZyYW1lLCB3ZSBjYW4gYXBwbHlcbiAgICAgICAgLy8gb3VyIGZpbmFsIHN0eWxlcyB0byBwZXJmb3JtIHRoZSBhbmltYXRpb24uXG5cbiAgICAgICAgLy8gT3VyIGZpcnN0IG9yZGVyIG9mIGJ1c2luZXNzIGlzIHRvIFwidW5kb1wiIHRoZSBzdHlsZXMgYXBwbGllZCBpbiB0aGVcbiAgICAgICAgLy8gcHJldmlvdXMgZnJhbWVzLCB3aGlsZSBhbHNvIGFkZGluZyBhIGB0cmFuc2l0aW9uYCBwcm9wZXJ0eS5cbiAgICAgICAgLy8gVGhpcyB3YXksIHRoZSBpdGVtIHdpbGwgc21vb3RobHkgdHJhbnNpdGlvbiBmcm9tIGl0cyBvbGQgcG9zaXRpb25cbiAgICAgICAgLy8gdG8gaXRzIG5ldyBwb3NpdGlvbi5cblxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZmxvd3R5cGUvcmVxdWlyZS12YXJpYWJsZS10eXBlXG4gICAgICAgIHZhciBzdHlsZXMgPSB7XG4gICAgICAgICAgdHJhbnNpdGlvbjogY3JlYXRlVHJhbnNpdGlvblN0cmluZyhpbmRleCwgX3RoaXM0LnByb3BzKSxcbiAgICAgICAgICB0cmFuc2Zvcm06ICcnLFxuICAgICAgICAgIG9wYWNpdHk6ICcnXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGNoaWxkLmFwcGVhcmluZyAmJiBfdGhpczQucHJvcHMuYXBwZWFyQW5pbWF0aW9uKSB7XG4gICAgICAgICAgc3R5bGVzID0gX2V4dGVuZHMoe30sIHN0eWxlcywgX3RoaXM0LnByb3BzLmFwcGVhckFuaW1hdGlvbi50byk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hpbGQuZW50ZXJpbmcgJiYgX3RoaXM0LnByb3BzLmVudGVyQW5pbWF0aW9uKSB7XG4gICAgICAgICAgc3R5bGVzID0gX2V4dGVuZHMoe30sIHN0eWxlcywgX3RoaXM0LnByb3BzLmVudGVyQW5pbWF0aW9uLnRvKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGlsZC5sZWF2aW5nICYmIF90aGlzNC5wcm9wcy5sZWF2ZUFuaW1hdGlvbikge1xuICAgICAgICAgIHN0eWxlcyA9IF9leHRlbmRzKHt9LCBzdHlsZXMsIF90aGlzNC5wcm9wcy5sZWF2ZUFuaW1hdGlvbi50byk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbiBGTElQIHRlcm1pbm9sb2d5LCB0aGlzIGlzIHRoZSAnUGxheScgc3RhZ2UuXG4gICAgICAgIGFwcGx5U3R5bGVzVG9ET01Ob2RlKHsgZG9tTm9kZTogZG9tTm9kZSwgc3R5bGVzOiBzdHlsZXMgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMuYmluZFRyYW5zaXRpb25FbmRIYW5kbGVyKGNoaWxkKTtcbiAgfTtcblxuICBGbGlwTW92ZS5wcm90b3R5cGUuYmluZFRyYW5zaXRpb25FbmRIYW5kbGVyID0gZnVuY3Rpb24gYmluZFRyYW5zaXRpb25FbmRIYW5kbGVyKGNoaWxkKSB7XG4gICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICB2YXIgX2dldENoaWxkRGF0YTMgPSB0aGlzLmdldENoaWxkRGF0YShnZXRLZXkoY2hpbGQpKSxcbiAgICAgICAgZG9tTm9kZSA9IF9nZXRDaGlsZERhdGEzLmRvbU5vZGU7XG5cbiAgICBpZiAoIWRvbU5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUaGUgb25GaW5pc2ggY2FsbGJhY2sgbmVlZHMgdG8gYmUgYm91bmQgdG8gdGhlIHRyYW5zaXRpb25FbmQgZXZlbnQuXG4gICAgLy8gV2UgYWxzbyBuZWVkIHRvIHVuYmluZCBpdCB3aGVuIHRoZSB0cmFuc2l0aW9uIGNvbXBsZXRlcywgc28gdGhpcyB1Z2x5XG4gICAgLy8gaW5saW5lIGZ1bmN0aW9uIGlzIHJlcXVpcmVkICh3ZSBuZWVkIGl0IGhlcmUgc28gaXQgY2xvc2VzIG92ZXJcbiAgICAvLyBkZXBlbmRlbnQgdmFyaWFibGVzIGBjaGlsZGAgYW5kIGBkb21Ob2RlYClcbiAgICB2YXIgdHJhbnNpdGlvbkVuZEhhbmRsZXIgPSBmdW5jdGlvbiB0cmFuc2l0aW9uRW5kSGFuZGxlcihldikge1xuICAgICAgLy8gSXQncyBwb3NzaWJsZSB0aGF0IHRoaXMgaGFuZGxlciBpcyBmaXJlZCBub3Qgb24gb3VyIHByaW1hcnkgdHJhbnNpdGlvbixcbiAgICAgIC8vIGJ1dCBvbiBhIG5lc3RlZCB0cmFuc2l0aW9uIChlZy4gYSBob3ZlciBlZmZlY3QpLiBJZ25vcmUgdGhlc2UgY2FzZXMuXG4gICAgICBpZiAoZXYudGFyZ2V0ICE9PSBkb21Ob2RlKSByZXR1cm47XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgJ3RyYW5zaXRpb24nIGlubGluZSBzdHlsZSB3ZSBhZGRlZC4gVGhpcyBpcyBjbGVhbnVwLlxuICAgICAgZG9tTm9kZS5zdHlsZS50cmFuc2l0aW9uID0gJyc7XG5cbiAgICAgIC8vIFRyaWdnZXIgYW55IGFwcGxpY2FibGUgb25GaW5pc2gvb25GaW5pc2hBbGwgaG9va3NcbiAgICAgIF90aGlzNS50cmlnZ2VyRmluaXNoSG9va3MoY2hpbGQsIGRvbU5vZGUpO1xuXG4gICAgICBkb21Ob2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZCwgdHJhbnNpdGlvbkVuZEhhbmRsZXIpO1xuXG4gICAgICBpZiAoY2hpbGQubGVhdmluZykge1xuICAgICAgICBfdGhpczUucmVtb3ZlQ2hpbGREYXRhKGdldEtleShjaGlsZCkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBkb21Ob2RlLmFkZEV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZCwgdHJhbnNpdGlvbkVuZEhhbmRsZXIpO1xuICB9O1xuXG4gIEZsaXBNb3ZlLnByb3RvdHlwZS50cmlnZ2VyRmluaXNoSG9va3MgPSBmdW5jdGlvbiB0cmlnZ2VyRmluaXNoSG9va3MoY2hpbGQsIGRvbU5vZGUpIHtcbiAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgIGlmICh0aGlzLnByb3BzLm9uRmluaXNoKSB0aGlzLnByb3BzLm9uRmluaXNoKGNoaWxkLCBkb21Ob2RlKTtcblxuICAgIC8vIFJlZHVjZSB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIHdlIG5lZWQgdG8gYW5pbWF0ZSBieSAxLFxuICAgIC8vIHNvIHRoYXQgd2UgY2FuIHRlbGwgd2hlbiBhbGwgY2hpbGRyZW4gaGF2ZSBmaW5pc2hlZC5cbiAgICB0aGlzLnJlbWFpbmluZ0FuaW1hdGlvbnMgLT0gMTtcblxuICAgIGlmICh0aGlzLnJlbWFpbmluZ0FuaW1hdGlvbnMgPT09IDApIHtcbiAgICAgIC8vIFJlbW92ZSBhbnkgaXRlbXMgZnJvbSB0aGUgRE9NIHRoYXQgaGF2ZSBsZWZ0LCBhbmQgcmVzZXQgYGVudGVyaW5nYC5cbiAgICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB0aGlzLnN0YXRlLmNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgICAgdmFyIGxlYXZpbmcgPSBfcmVmMi5sZWF2aW5nO1xuICAgICAgICByZXR1cm4gIWxlYXZpbmc7XG4gICAgICB9KS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBpdGVtLCB7XG4gICAgICAgICAgLy8gZml4IGZvciBGbG93XG4gICAgICAgICAgZWxlbWVudDogaXRlbS5lbGVtZW50LFxuICAgICAgICAgIGFwcGVhcmluZzogZmFsc2UsXG4gICAgICAgICAgZW50ZXJpbmc6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBjaGlsZHJlbjogbmV4dENoaWxkcmVuIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBfdGhpczYucHJvcHMub25GaW5pc2hBbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBfdGhpczYuY2FsbENoaWxkcmVuSG9vayhfdGhpczYucHJvcHMub25GaW5pc2hBbGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVzZXQgb3VyIHZhcmlhYmxlcyBmb3IgdGhlIG5leHQgaXRlcmF0aW9uXG4gICAgICAgIF90aGlzNi5jaGlsZHJlblRvQW5pbWF0ZSA9IFtdO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIElmIHRoZSBwbGFjZWhvbGRlciB3YXMgaG9sZGluZyB0aGUgY29udGFpbmVyIG9wZW4gd2hpbGUgZWxlbWVudHMgd2VyZVxuICAgICAgLy8gbGVhdmluZywgd2Ugd2UgY2FuIG5vdyBzZXQgaXRzIGhlaWdodCB0byB6ZXJvLlxuICAgICAgaWYgKHRoaXMuaGVpZ2h0UGxhY2Vob2xkZXJEYXRhLmRvbU5vZGUpIHtcbiAgICAgICAgdGhpcy5oZWlnaHRQbGFjZWhvbGRlckRhdGEuZG9tTm9kZS5zdHlsZS5oZWlnaHQgPSAnMCc7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEZsaXBNb3ZlLnByb3RvdHlwZS5jYWxsQ2hpbGRyZW5Ib29rID0gZnVuY3Rpb24gY2FsbENoaWxkcmVuSG9vayhob29rKSB7XG4gICAgdmFyIF90aGlzNyA9IHRoaXM7XG5cbiAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICB2YXIgZG9tTm9kZXMgPSBbXTtcblxuICAgIHRoaXMuY2hpbGRyZW5Ub0FuaW1hdGUuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGRLZXkpIHtcbiAgICAgIC8vIElmIHRoaXMgd2FzIGFuIGV4aXQgYW5pbWF0aW9uLCB0aGUgY2hpbGQgbWF5IG5vIGxvbmdlciBleGlzdC5cbiAgICAgIC8vIElmIHNvLCBza2lwIGl0LlxuICAgICAgdmFyIGNoaWxkID0gX3RoaXM3LmZpbmRDaGlsZEJ5S2V5KGNoaWxkS2V5KTtcblxuICAgICAgaWYgKCFjaGlsZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnRzLnB1c2goY2hpbGQpO1xuXG4gICAgICBpZiAoX3RoaXM3Lmhhc0NoaWxkRGF0YShjaGlsZEtleSkpIHtcbiAgICAgICAgZG9tTm9kZXMucHVzaChfdGhpczcuZ2V0Q2hpbGREYXRhKGNoaWxkS2V5KS5kb21Ob2RlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGhvb2soZWxlbWVudHMsIGRvbU5vZGVzKTtcbiAgfTtcblxuICBGbGlwTW92ZS5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdCb3hDYWNoZXMgPSBmdW5jdGlvbiB1cGRhdGVCb3VuZGluZ0JveENhY2hlcygpIHtcbiAgICB2YXIgX3RoaXM4ID0gdGhpcztcblxuICAgIC8vIFRoaXMgaXMgdGhlIE9OTFkgcGxhY2UgdGhhdCBwYXJlbnREYXRhIGFuZCBjaGlsZHJlbkRhdGEnc1xuICAgIC8vIGJvdW5kaW5nIGJveGVzIGFyZSB1cGRhdGVkLiBUaGV5IHdpbGwgYmUgY2FsY3VsYXRlZCBhdCBvdGhlciB0aW1lc1xuICAgIC8vIHRvIGJlIGNvbXBhcmVkIHRvIHRoaXMgdmFsdWUsIGJ1dCBpdCdzIGltcG9ydGFudCB0aGF0IHRoZSBjYWNoZSBpc1xuICAgIC8vIHVwZGF0ZWQgb25jZSBwZXIgdXBkYXRlLlxuICAgIHZhciBwYXJlbnREb21Ob2RlID0gdGhpcy5wYXJlbnREYXRhLmRvbU5vZGU7XG5cbiAgICBpZiAoIXBhcmVudERvbU5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnBhcmVudERhdGEuYm91bmRpbmdCb3ggPSB0aGlzLnByb3BzLmdldFBvc2l0aW9uKHBhcmVudERvbU5vZGUpO1xuXG4gICAgLy8gU3BsaXR0aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzIHRvIGJlIHBlZm9ybWVkIGluIGJhdGNoZXNcbiAgICB2YXIgY2hpbGRyZW5Cb3VuZGluZ0JveGVzID0gW107XG5cbiAgICB0aGlzLnN0YXRlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICB2YXIgY2hpbGRLZXkgPSBnZXRLZXkoY2hpbGQpO1xuXG4gICAgICAvLyBJdCBpcyBwb3NzaWJsZSB0aGF0IGEgY2hpbGQgZG9lcyBub3QgaGF2ZSBhIGBrZXlgIHByb3BlcnR5O1xuICAgICAgLy8gSWdub3JlIHRoZXNlIGNoaWxkcmVuLCB0aGV5IGRvbid0IG5lZWQgdG8gYmUgbW92ZWQuXG4gICAgICBpZiAoIWNoaWxkS2V5KSB7XG4gICAgICAgIGNoaWxkcmVuQm91bmRpbmdCb3hlcy5wdXNoKG51bGwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEluIHZlcnkgcmFyZSBjaXJjdW1zdGFuY2VzLCBmb3IgcmVhc29ucyB1bmtub3duLCB0aGUgcmVmIGlzIG5ldmVyXG4gICAgICAvLyBwb3B1bGF0ZWQgZm9yIGNlcnRhaW4gY2hpbGRyZW4uIEluIHRoaXMgY2FzZSwgYXZvaWQgZG9pbmcgdGhpcyB1cGRhdGUuXG4gICAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3Nod2NvbWVhdS9yZWFjdC1mbGlwLW1vdmUvcHVsbC85MVxuICAgICAgaWYgKCFfdGhpczguaGFzQ2hpbGREYXRhKGNoaWxkS2V5KSkge1xuICAgICAgICBjaGlsZHJlbkJvdW5kaW5nQm94ZXMucHVzaChudWxsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hpbGREYXRhID0gX3RoaXM4LmdldENoaWxkRGF0YShjaGlsZEtleSk7XG5cbiAgICAgIC8vIElmIHRoZSBjaGlsZCBlbGVtZW50IHJldHVybnMgbnVsbCwgd2UgbmVlZCB0byBhdm9pZCB0cnlpbmcgdG9cbiAgICAgIC8vIGFjY291bnQgZm9yIGl0XG4gICAgICBpZiAoIWNoaWxkRGF0YS5kb21Ob2RlIHx8ICFjaGlsZCkge1xuICAgICAgICBjaGlsZHJlbkJvdW5kaW5nQm94ZXMucHVzaChudWxsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjaGlsZHJlbkJvdW5kaW5nQm94ZXMucHVzaChnZXRSZWxhdGl2ZUJvdW5kaW5nQm94KHtcbiAgICAgICAgY2hpbGREb21Ob2RlOiBjaGlsZERhdGEuZG9tTm9kZSxcbiAgICAgICAgcGFyZW50RG9tTm9kZTogcGFyZW50RG9tTm9kZSxcbiAgICAgICAgZ2V0UG9zaXRpb246IF90aGlzOC5wcm9wcy5nZXRQb3NpdGlvblxuICAgICAgfSkpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5zdGF0ZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCwgaW5kZXgpIHtcbiAgICAgIHZhciBjaGlsZEtleSA9IGdldEtleShjaGlsZCk7XG5cbiAgICAgIHZhciBjaGlsZEJvdW5kaW5nQm94ID0gY2hpbGRyZW5Cb3VuZGluZ0JveGVzW2luZGV4XTtcblxuICAgICAgaWYgKCFjaGlsZEtleSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIF90aGlzOC5zZXRDaGlsZERhdGEoY2hpbGRLZXksIHtcbiAgICAgICAgYm91bmRpbmdCb3g6IGNoaWxkQm91bmRpbmdCb3hcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIEZsaXBNb3ZlLnByb3RvdHlwZS5jb21wdXRlSW5pdGlhbFN0eWxlcyA9IGZ1bmN0aW9uIGNvbXB1dGVJbml0aWFsU3R5bGVzKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkLmFwcGVhcmluZykge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcHMuYXBwZWFyQW5pbWF0aW9uID8gdGhpcy5wcm9wcy5hcHBlYXJBbmltYXRpb24uZnJvbSA6IHt9O1xuICAgIH0gZWxzZSBpZiAoY2hpbGQuZW50ZXJpbmcpIHtcbiAgICAgIGlmICghdGhpcy5wcm9wcy5lbnRlckFuaW1hdGlvbikge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICAvLyBJZiB0aGlzIGNoaWxkIHdhcyBpbiB0aGUgbWlkZGxlIG9mIGxlYXZpbmcsIGl0IHN0aWxsIGhhcyBpdHNcbiAgICAgIC8vIGFic29sdXRlIHBvc2l0aW9uaW5nIHN0eWxlcyBhcHBsaWVkLiBXZSBuZWVkIHRvIHVuZG8gdGhvc2UuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICBwb3NpdGlvbjogJycsXG4gICAgICAgIHRvcDogJycsXG4gICAgICAgIGxlZnQ6ICcnLFxuICAgICAgICByaWdodDogJycsXG4gICAgICAgIGJvdHRvbTogJydcbiAgICAgIH0sIHRoaXMucHJvcHMuZW50ZXJBbmltYXRpb24uZnJvbSk7XG4gICAgfSBlbHNlIGlmIChjaGlsZC5sZWF2aW5nKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5sZWF2ZUFuaW1hdGlvbiA/IHRoaXMucHJvcHMubGVhdmVBbmltYXRpb24uZnJvbSA6IHt9O1xuICAgIH1cblxuICAgIHZhciBjaGlsZERhdGEgPSB0aGlzLmdldENoaWxkRGF0YShnZXRLZXkoY2hpbGQpKTtcbiAgICB2YXIgY2hpbGREb21Ob2RlID0gY2hpbGREYXRhLmRvbU5vZGU7XG4gICAgdmFyIGNoaWxkQm91bmRpbmdCb3ggPSBjaGlsZERhdGEuYm91bmRpbmdCb3g7XG4gICAgdmFyIHBhcmVudEJvdW5kaW5nQm94ID0gdGhpcy5wYXJlbnREYXRhLmJvdW5kaW5nQm94O1xuXG4gICAgaWYgKCFjaGlsZERvbU5vZGUpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICB2YXIgX2dldFBvc2l0aW9uRGVsdGEyID0gZ2V0UG9zaXRpb25EZWx0YSh7XG4gICAgICBjaGlsZERvbU5vZGU6IGNoaWxkRG9tTm9kZSxcbiAgICAgIGNoaWxkQm91bmRpbmdCb3g6IGNoaWxkQm91bmRpbmdCb3gsXG4gICAgICBwYXJlbnRCb3VuZGluZ0JveDogcGFyZW50Qm91bmRpbmdCb3gsXG4gICAgICBnZXRQb3NpdGlvbjogdGhpcy5wcm9wcy5nZXRQb3NpdGlvblxuICAgIH0pLFxuICAgICAgICBkWCA9IF9nZXRQb3NpdGlvbkRlbHRhMlswXSxcbiAgICAgICAgZFkgPSBfZ2V0UG9zaXRpb25EZWx0YTJbMV07XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKCcgKyBkWCArICdweCwgJyArIGRZICsgJ3B4KSdcbiAgICB9O1xuICB9O1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG5cblxuICBGbGlwTW92ZS5wcm90b3R5cGUuaXNBbmltYXRpb25EaXNhYmxlZCA9IGZ1bmN0aW9uIGlzQW5pbWF0aW9uRGlzYWJsZWQocHJvcHMpIHtcbiAgICAvLyBJZiB0aGUgY29tcG9uZW50IGlzIGV4cGxpY2l0bHkgcGFzc2VkIGEgYGRpc2FibGVBbGxBbmltYXRpb25zYCBmbGFnLFxuICAgIC8vIHdlIGNhbiBza2lwIHRoaXMgd2hvbGUgcHJvY2Vzcy4gU2ltaWxhcmx5LCBpZiBhbGwgb2YgdGhlIG51bWJlcnMgaGF2ZVxuICAgIC8vIGJlZW4gc2V0IHRvIDAsIHRoZXJlIGlzIG5vIHBvaW50IGluIHRyeWluZyB0byBhbmltYXRlOyBkb2luZyBzbyB3b3VsZFxuICAgIC8vIG9ubHkgY2F1c2UgYSBmbGlja2VyIChhbmQgdGhlIGludGVudCBpcyBwcm9iYWJseSB0byBkaXNhYmxlIGFuaW1hdGlvbnMpXG4gICAgLy8gV2UgY2FuIGFsc28gc2tpcCB0aGlzIHJpZ2FtYXJvbGUgaWYgdGhlcmUncyBubyBicm93c2VyIHN1cHBvcnQgZm9yIGl0LlxuICAgIHJldHVybiBub0Jyb3dzZXJTdXBwb3J0IHx8IHByb3BzLmRpc2FibGVBbGxBbmltYXRpb25zIHx8IHByb3BzLmR1cmF0aW9uID09PSAwICYmIHByb3BzLmRlbGF5ID09PSAwICYmIHByb3BzLnN0YWdnZXJEdXJhdGlvbkJ5ID09PSAwICYmIHByb3BzLnN0YWdnZXJEZWxheUJ5ID09PSAwO1xuICB9O1xuXG4gIEZsaXBNb3ZlLnByb3RvdHlwZS5maW5kQ2hpbGRCeUtleSA9IGZ1bmN0aW9uIGZpbmRDaGlsZEJ5S2V5KGtleSkge1xuICAgIHJldHVybiBmaW5kKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgcmV0dXJuIGdldEtleShjaGlsZCkgPT09IGtleTtcbiAgICB9LCB0aGlzLnN0YXRlLmNoaWxkcmVuKTtcbiAgfTtcblxuICBGbGlwTW92ZS5wcm90b3R5cGUuaGFzQ2hpbGREYXRhID0gZnVuY3Rpb24gaGFzQ2hpbGREYXRhKGtleSkge1xuICAgIC8vIE9iamVjdCBoYXMgc29tZSBidWlsdC1pbiBwcm9wZXJ0aWVzIG9uIGl0cyBwcm90b3R5cGUsIHN1Y2ggYXMgdG9TdHJpbmcuICBoYXNPd25Qcm9wZXJ0eSBtYWtlc1xuICAgIC8vIHN1cmUgdGhhdCBrZXkgaXMgcHJlc2VudCBvbiBjaGlsZHJlbkRhdGEgaXRzZWxmLCBub3Qgb24gaXRzIHByb3RvdHlwZS5cbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuY2hpbGRyZW5EYXRhLCBrZXkpO1xuICB9O1xuXG4gIEZsaXBNb3ZlLnByb3RvdHlwZS5nZXRDaGlsZERhdGEgPSBmdW5jdGlvbiBnZXRDaGlsZERhdGEoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQ2hpbGREYXRhKGtleSkgPyB0aGlzLmNoaWxkcmVuRGF0YVtrZXldIDoge307XG4gIH07XG5cbiAgRmxpcE1vdmUucHJvdG90eXBlLnNldENoaWxkRGF0YSA9IGZ1bmN0aW9uIHNldENoaWxkRGF0YShrZXksIGRhdGEpIHtcbiAgICB0aGlzLmNoaWxkcmVuRGF0YVtrZXldID0gX2V4dGVuZHMoe30sIHRoaXMuZ2V0Q2hpbGREYXRhKGtleSksIGRhdGEpO1xuICB9O1xuXG4gIEZsaXBNb3ZlLnByb3RvdHlwZS5yZW1vdmVDaGlsZERhdGEgPSBmdW5jdGlvbiByZW1vdmVDaGlsZERhdGEoa2V5KSB7XG4gICAgZGVsZXRlIHRoaXMuY2hpbGRyZW5EYXRhW2tleV07XG4gICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAocHJldlN0YXRlKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHByZXZTdGF0ZSwge1xuICAgICAgICBjaGlsZHJlbjogcHJldlN0YXRlLmNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICByZXR1cm4gY2hpbGQuZWxlbWVudC5rZXkgIT09IGtleTtcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIEZsaXBNb3ZlLnByb3RvdHlwZS5jcmVhdGVIZWlnaHRQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIGNyZWF0ZUhlaWdodFBsYWNlaG9sZGVyKCkge1xuICAgIHZhciBfdGhpczkgPSB0aGlzO1xuXG4gICAgdmFyIHR5cGVOYW1lID0gdGhpcy5wcm9wcy50eXBlTmFtZTtcblxuICAgIC8vIElmIHJlcXVlc3RlZCwgY3JlYXRlIGFuIGludmlzaWJsZSBlbGVtZW50IGF0IHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4gICAgLy8gSXRzIGhlaWdodCB3aWxsIGJlIG1vZGlmaWVkIHRvIHByZXZlbnQgdGhlIGNvbnRhaW5lciBmcm9tIGNvbGxhcHNpbmdcbiAgICAvLyBwcmVtYXR1cmVseS5cblxuICAgIHZhciBpc0NvbnRhaW5lckFMaXN0ID0gdHlwZU5hbWUgPT09ICd1bCcgfHwgdHlwZU5hbWUgPT09ICdvbCc7XG4gICAgdmFyIHBsYWNlaG9sZGVyVHlwZSA9IGlzQ29udGFpbmVyQUxpc3QgPyAnbGknIDogJ2Rpdic7XG5cbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChwbGFjZWhvbGRlclR5cGUsIHtcbiAgICAgIGtleTogJ2hlaWdodC1wbGFjZWhvbGRlcicsXG4gICAgICByZWY6IGZ1bmN0aW9uIHJlZihkb21Ob2RlKSB7XG4gICAgICAgIF90aGlzOS5oZWlnaHRQbGFjZWhvbGRlckRhdGEuZG9tTm9kZSA9IGRvbU5vZGU7XG4gICAgICB9LFxuICAgICAgc3R5bGU6IHsgdmlzaWJpbGl0eTogJ2hpZGRlbicsIGhlaWdodDogMCB9XG4gICAgfSk7XG4gIH07XG5cbiAgRmxpcE1vdmUucHJvdG90eXBlLmNoaWxkcmVuV2l0aFJlZnMgPSBmdW5jdGlvbiBjaGlsZHJlbldpdGhSZWZzKCkge1xuICAgIHZhciBfdGhpczEwID0gdGhpcztcblxuICAgIC8vIFdlIG5lZWQgdG8gY2xvbmUgdGhlIHByb3ZpZGVkIGNoaWxkcmVuLCBjYXB0dXJpbmcgYSByZWZlcmVuY2UgdG8gdGhlXG4gICAgLy8gdW5kZXJseWluZyBET00gbm9kZS4gRmxpcCBNb3ZlIG5lZWRzIHRvIHVzZSB0aGUgUmVhY3QgZXNjYXBlIGhhdGNoZXMgdG9cbiAgICAvLyBiZSBhYmxlIHRvIGRvIGl0cyBjYWxjdWxhdGlvbnMuXG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgcmV0dXJuIGNsb25lRWxlbWVudChjaGlsZC5lbGVtZW50LCB7XG4gICAgICAgIHJlZjogZnVuY3Rpb24gcmVmKGVsZW1lbnQpIHtcbiAgICAgICAgICAvLyBTdGF0ZWxlc3MgRnVuY3Rpb25hbCBDb21wb25lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IEZsaXBNb3ZlLFxuICAgICAgICAgIC8vIGJlY2F1c2UgdGhleSBkb24ndCBoYXZlIGluc3RhbmNlcy5cbiAgICAgICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZG9tTm9kZSA9IGdldE5hdGl2ZU5vZGUoZWxlbWVudCk7XG4gICAgICAgICAgX3RoaXMxMC5zZXRDaGlsZERhdGEoZ2V0S2V5KGNoaWxkKSwgeyBkb21Ob2RlOiBkb21Ob2RlIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBGbGlwTW92ZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpczExID0gdGhpcztcblxuICAgIHZhciBfcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgdHlwZU5hbWUgPSBfcHJvcHMyLnR5cGVOYW1lLFxuICAgICAgICBkZWxlZ2F0ZWQgPSBfcHJvcHMyLmRlbGVnYXRlZCxcbiAgICAgICAgbGVhdmVBbmltYXRpb24gPSBfcHJvcHMyLmxlYXZlQW5pbWF0aW9uLFxuICAgICAgICBtYWludGFpbkNvbnRhaW5lckhlaWdodCA9IF9wcm9wczIubWFpbnRhaW5Db250YWluZXJIZWlnaHQ7XG5cblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW5XaXRoUmVmcygpO1xuICAgIGlmIChsZWF2ZUFuaW1hdGlvbiAmJiBtYWludGFpbkNvbnRhaW5lckhlaWdodCkge1xuICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLmNyZWF0ZUhlaWdodFBsYWNlaG9sZGVyKCkpO1xuICAgIH1cblxuICAgIGlmICghdHlwZU5hbWUpIHJldHVybiBjaGlsZHJlbjtcblxuICAgIHZhciBwcm9wcyA9IF9leHRlbmRzKHt9LCBkZWxlZ2F0ZWQsIHtcbiAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgIHJlZjogZnVuY3Rpb24gcmVmKG5vZGUpIHtcbiAgICAgICAgX3RoaXMxMS5wYXJlbnREYXRhLmRvbU5vZGUgPSBub2RlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodHlwZU5hbWUsIHByb3BzKTtcbiAgfTtcblxuICByZXR1cm4gRmxpcE1vdmU7XG59KENvbXBvbmVudCk7XG5cbnZhciBlbmhhbmNlZEZsaXBNb3ZlID0gLyogI19fUFVSRV9fICovcHJvcENvbnZlcnRlcihGbGlwTW92ZSQxKTtcblxuLyoqXG4gKiBSZWFjdCBGbGlwIE1vdmVcbiAqIChjKSAyMDE2LXByZXNlbnQgSm9zaHVhIENvbWVhdVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGVuaGFuY2VkRmxpcE1vdmU7XG4iLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjIuMFxuICogcmVhY3QuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMnKTtcblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTYuMi4wJztcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbFsnZm9yJ107XG5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG52YXIgUkVBQ1RfQ0FMTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QuY2FsbCcpIDogMHhlYWM4O1xudmFyIFJFQUNUX1JFVFVSTl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QucmV0dXJuJykgOiAweGVhYzk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QuZnJhZ21lbnQnKSA6IDB4ZWFjYjtcblxudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuXG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBXQVJOSU5HOiBETyBOT1QgbWFudWFsbHkgcmVxdWlyZSB0aGlzIG1vZHVsZS5cbiAqIFRoaXMgaXMgYSByZXBsYWNlbWVudCBmb3IgYGludmFyaWFudCguLi4pYCB1c2VkIGJ5IHRoZSBlcnJvciBjb2RlIHN5c3RlbVxuICogYW5kIHdpbGwgX29ubHlfIGJlIHJlcXVpcmVkIGJ5IHRoZSBjb3JyZXNwb25kaW5nIGJhYmVsIHBhc3MuXG4gKiBJdCBhbHdheXMgdGhyb3dzLlxuICovXG5cbi8qKlxuICogRm9ya2VkIGZyb20gZmJqcy93YXJuaW5nOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZianMvYmxvYi9lNjZiYTIwYWQ1YmU0MzNlYjU0NDIzZjJiMDk3ZDgyOTMyNGQ5ZGU2L3BhY2thZ2VzL2ZianMvc3JjL19fZm9ya3NfXy93YXJuaW5nLmpzXG4gKlxuICogT25seSBjaGFuZ2UgaXMgd2UgdXNlIGNvbnNvbGUud2FybiBpbnN0ZWFkIG9mIGNvbnNvbGUuZXJyb3IsXG4gKiBhbmQgZG8gbm90aGluZyB3aGVuICdjb25zb2xlJyBpcyBub3Qgc3VwcG9ydGVkLlxuICogVGhpcyByZWFsbHkgc2ltcGxpZmllcyB0aGUgY29kZS5cbiAqIC0tLVxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nJDEgPSBsb3dQcmlvcml0eVdhcm5pbmc7XG5cbnZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAge1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gY29uc3RydWN0b3IgJiYgKGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IGNvbnN0cnVjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJztcbiAgICB2YXIgd2FybmluZ0tleSA9IGNvbXBvbmVudE5hbWUgKyAnLicgKyBjYWxsZXJOYW1lO1xuICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IENhbiBvbmx5IHVwZGF0ZSBhIG1vdW50ZWQgb3IgbW91bnRpbmcgY29tcG9uZW50LiAnICsgJ1RoaXMgdXN1YWxseSBtZWFucyB5b3UgY2FsbGVkICVzKCkgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4gJyArICdUaGlzIGlzIGEgbm8tb3AuXFxuXFxuUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNhbGxlck5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAqL1xudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IE5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG4gIH1cbn07XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxuQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG5cbi8qKlxuICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyB0byBtdXRhdGVcbiAqIHN0YXRlLiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCB3aWxsIHJ1biBzeW5jaHJvbm91c2x5LFxuICogYXMgdGhleSBtYXkgZXZlbnR1YWxseSBiZSBiYXRjaGVkIHRvZ2V0aGVyLiAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsXG4gKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2FsbCB0byBzZXRTdGF0ZSBpcyBhY3R1YWxseVxuICogY29tcGxldGVkLlxuICpcbiAqIFdoZW4gYSBmdW5jdGlvbiBpcyBwcm92aWRlZCB0byBzZXRTdGF0ZSwgaXQgd2lsbCBiZSBjYWxsZWQgYXQgc29tZSBwb2ludCBpblxuICogdGhlIGZ1dHVyZSAobm90IHN5bmNocm9ub3VzbHkpLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cCB0byBkYXRlXG4gKiBjb21wb25lbnQgYXJndW1lbnRzIChzdGF0ZSwgcHJvcHMsIGNvbnRleHQpLiBUaGVzZSB2YWx1ZXMgY2FuIGJlIGRpZmZlcmVudFxuICogZnJvbSB0aGlzLiogYmVjYXVzZSB5b3VyIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgYWZ0ZXIgcmVjZWl2ZVByb3BzIGJ1dCBiZWZvcmVcbiAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSwgYW5kIHRoaXMgbmV3IHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgd2lsbCBub3QgeWV0IGJlXG4gKiBhc3NpZ25lZCB0byB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIG9yIGZ1bmN0aW9uIHRvXG4gKiAgICAgICAgcHJvZHVjZSBuZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgISh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nIHx8IHBhcnRpYWxTdGF0ZSA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ3NldFN0YXRlKC4uLik6IHRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLicpIDogdm9pZCAwO1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xufTtcblxuLyoqXG4gKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAqXG4gKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICpcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLCBjYWxsYmFjaywgJ2ZvcmNlVXBkYXRlJyk7XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQgQVBJcy4gVGhlc2UgQVBJcyB1c2VkIHRvIGV4aXN0IG9uIGNsYXNzaWMgUmVhY3QgY2xhc3NlcyBidXQgc2luY2VcbiAqIHdlIHdvdWxkIGxpa2UgdG8gZGVwcmVjYXRlIHRoZW0sIHdlJ3JlIG5vdCBnb2luZyB0byBtb3ZlIHRoZW0gb3ZlciB0byB0aGlzXG4gKiBtb2Rlcm4gYmFzZSBjbGFzcy4gSW5zdGVhZCwgd2UgZGVmaW5lIGEgZ2V0dGVyIHRoYXQgd2FybnMgaWYgaXQncyBhY2Nlc3NlZC5cbiAqL1xue1xuICB2YXIgZGVwcmVjYXRlZEFQSXMgPSB7XG4gICAgaXNNb3VudGVkOiBbJ2lzTW91bnRlZCcsICdJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgc3Vic2NyaXB0aW9ucyBhbmQgcGVuZGluZyByZXF1ZXN0cyBpbiAnICsgJ2NvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLiddLFxuICAgIHJlcGxhY2VTdGF0ZTogWydyZXBsYWNlU3RhdGUnLCAnUmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBzZXRTdGF0ZSBpbnN0ZWFkIChzZWUgJyArICdodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLiddXG4gIH07XG4gIHZhciBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgaW5mbykge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG93UHJpb3JpdHlXYXJuaW5nJDEoZmFsc2UsICclcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlcycsIGluZm9bMF0sIGluZm9bMV0pO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBmb3IgKHZhciBmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpIHtcbiAgICBpZiAoZGVwcmVjYXRlZEFQSXMuaGFzT3duUHJvcGVydHkoZm5OYW1lKSkge1xuICAgICAgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKGZuTmFtZSwgZGVwcmVjYXRlZEFQSXNbZm5OYW1lXSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIFB1cmVDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgLy8gRHVwbGljYXRlZCBmcm9tIENvbXBvbmVudC5cbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbmZ1bmN0aW9uIENvbXBvbmVudER1bW15KCkge31cbkNvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG52YXIgcHVyZUNvbXBvbmVudFByb3RvdHlwZSA9IFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHVyZUNvbXBvbmVudDtcbi8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxuX2Fzc2lnbihwdXJlQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXG5mdW5jdGlvbiBBc3luY0NvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAvLyBEdXBsaWNhdGVkIGZyb20gQ29tcG9uZW50LlxuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxudmFyIGFzeW5jQ29tcG9uZW50UHJvdG90eXBlID0gQXN5bmNDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5hc3luY0NvbXBvbmVudFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFzeW5jQ29tcG9uZW50O1xuLy8gQXZvaWQgYW4gZXh0cmEgcHJvdG90eXBlIGp1bXAgZm9yIHRoZXNlIG1ldGhvZHMuXG5fYXNzaWduKGFzeW5jQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcbmFzeW5jQ29tcG9uZW50UHJvdG90eXBlLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudCA9IHRydWU7XG5hc3luY0NvbXBvbmVudFByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xufTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xuXG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL2ZiLm1lL3JlYWN0LXNwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgIH1cbiAgfTtcbiAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBubyBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93IHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcblxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcblxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTtcblxuICAgIC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pO1xuICAgIC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTtcbiAgICAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY3JlYXRlZWxlbWVudFxuICovXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KHR5cGUsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lO1xuXG4gIC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcbiAgdmFyIHByb3BzID0ge307XG5cbiAgdmFyIGtleSA9IG51bGw7XG4gIHZhciByZWYgPSBudWxsO1xuICB2YXIgc2VsZiA9IG51bGw7XG4gIHZhciBzb3VyY2UgPSBudWxsO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgIH1cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIHNlbGYgPSBjb25maWcuX19zZWxmID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc2VsZjtcbiAgICBzb3VyY2UgPSBjb25maWcuX19zb3VyY2UgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zb3VyY2U7XG4gICAgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAge1xuICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZEFycmF5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAge1xuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3BzLiQkdHlwZW9mID09PSAndW5kZWZpbmVkJyB8fCBwcm9wcy4kJHR5cGVvZiAhPT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZikge1xuICAgICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBSZWFjdEVsZW1lbnRzIG9mIGEgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY3JlYXRlZmFjdG9yeVxuICovXG5cblxuZnVuY3Rpb24gY2xvbmVBbmRSZXBsYWNlS2V5KG9sZEVsZW1lbnQsIG5ld0tleSkge1xuICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudChvbGRFbGVtZW50LnR5cGUsIG5ld0tleSwgb2xkRWxlbWVudC5yZWYsIG9sZEVsZW1lbnQuX3NlbGYsIG9sZEVsZW1lbnQuX3NvdXJjZSwgb2xkRWxlbWVudC5fb3duZXIsIG9sZEVsZW1lbnQucHJvcHMpO1xuXG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuXG4vKipcbiAqIENsb25lIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IHVzaW5nIGVsZW1lbnQgYXMgdGhlIHN0YXJ0aW5nIHBvaW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjbG9uZWVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gY2xvbmVFbGVtZW50KGVsZW1lbnQsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lO1xuXG4gIC8vIE9yaWdpbmFsIHByb3BzIGFyZSBjb3BpZWRcbiAgdmFyIHByb3BzID0gX2Fzc2lnbih7fSwgZWxlbWVudC5wcm9wcyk7XG5cbiAgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjtcbiAgLy8gU2VsZiBpcyBwcmVzZXJ2ZWQgc2luY2UgdGhlIG93bmVyIGlzIHByZXNlcnZlZC5cbiAgdmFyIHNlbGYgPSBlbGVtZW50Ll9zZWxmO1xuICAvLyBTb3VyY2UgaXMgcHJlc2VydmVkIHNpbmNlIGNsb25lRWxlbWVudCBpcyB1bmxpa2VseSB0byBiZSB0YXJnZXRlZCBieSBhXG4gIC8vIHRyYW5zcGlsZXIsIGFuZCB0aGUgb3JpZ2luYWwgc291cmNlIGlzIHByb2JhYmx5IGEgYmV0dGVyIGluZGljYXRvciBvZiB0aGVcbiAgLy8gdHJ1ZSBvd25lci5cbiAgdmFyIHNvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcblxuICAvLyBPd25lciB3aWxsIGJlIHByZXNlcnZlZCwgdW5sZXNzIHJlZiBpcyBvdmVycmlkZGVuXG4gIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICAvLyBTaWxlbnRseSBzdGVhbCB0aGUgcmVmIGZyb20gdGhlIHBhcmVudC5cbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgfVxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgb3ZlcnJpZGUgZXhpc3RpbmcgcHJvcHNcbiAgICB2YXIgZGVmYXVsdFByb3BzO1xuICAgIGlmIChlbGVtZW50LnR5cGUgJiYgZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgZGVmYXVsdFByb3BzID0gZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcztcbiAgICB9XG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgaWYgKGNvbmZpZ1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0UHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQoZWxlbWVudC50eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpO1xufVxuXG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIHZhbGlkIGNvbXBvbmVudC5cbiAqIEBmaW5hbFxuICovXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cblxudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSB7fTtcblxue1xuICAvLyBDb21wb25lbnQgdGhhdCBpcyBiZWluZyB3b3JrZWQgb25cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW1wbCA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrO1xuICAgIGlmIChpbXBsKSB7XG4gICAgICByZXR1cm4gaW1wbCgpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbn1cblxudmFyIFNFUEFSQVRPUiA9ICcuJztcbnZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG5cbi8qKlxuICogRXNjYXBlIGFuZCB3cmFwIGtleSBzbyBpdCBpcyBzYWZlIHRvIHVzZSBhcyBhIHJlYWN0aWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRvIGJlIGVzY2FwZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBlc2NhcGVkIGtleS5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlKGtleSkge1xuICB2YXIgZXNjYXBlUmVnZXggPSAvWz06XS9nO1xuICB2YXIgZXNjYXBlckxvb2t1cCA9IHtcbiAgICAnPSc6ICc9MCcsXG4gICAgJzonOiAnPTInXG4gIH07XG4gIHZhciBlc2NhcGVkU3RyaW5nID0gKCcnICsga2V5KS5yZXBsYWNlKGVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xuXG4gIHJldHVybiAnJCcgKyBlc2NhcGVkU3RyaW5nO1xufVxuXG4vKipcbiAqIFRPRE86IFRlc3QgdGhhdCBhIHNpbmdsZSBjaGlsZCBhbmQgYW4gYXJyYXkgd2l0aCBvbmUgaXRlbSBoYXZlIHRoZSBzYW1lIGtleVxuICogcGF0dGVybi5cbiAqL1xuXG52YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xuXG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvXFwvKy9nO1xuZnVuY3Rpb24gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHRleHQpIHtcbiAgcmV0dXJuICgnJyArIHRleHQpLnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsICckJi8nKTtcbn1cblxudmFyIFBPT0xfU0laRSA9IDEwO1xudmFyIHRyYXZlcnNlQ29udGV4dFBvb2wgPSBbXTtcbmZ1bmN0aW9uIGdldFBvb2xlZFRyYXZlcnNlQ29udGV4dChtYXBSZXN1bHQsIGtleVByZWZpeCwgbWFwRnVuY3Rpb24sIG1hcENvbnRleHQpIHtcbiAgaWYgKHRyYXZlcnNlQ29udGV4dFBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IHRyYXZlcnNlQ29udGV4dFBvb2wucG9wKCk7XG4gICAgdHJhdmVyc2VDb250ZXh0LnJlc3VsdCA9IG1hcFJlc3VsdDtcbiAgICB0cmF2ZXJzZUNvbnRleHQua2V5UHJlZml4ID0ga2V5UHJlZml4O1xuICAgIHRyYXZlcnNlQ29udGV4dC5mdW5jID0gbWFwRnVuY3Rpb247XG4gICAgdHJhdmVyc2VDb250ZXh0LmNvbnRleHQgPSBtYXBDb250ZXh0O1xuICAgIHRyYXZlcnNlQ29udGV4dC5jb3VudCA9IDA7XG4gICAgcmV0dXJuIHRyYXZlcnNlQ29udGV4dDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0OiBtYXBSZXN1bHQsXG4gICAgICBrZXlQcmVmaXg6IGtleVByZWZpeCxcbiAgICAgIGZ1bmM6IG1hcEZ1bmN0aW9uLFxuICAgICAgY29udGV4dDogbWFwQ29udGV4dCxcbiAgICAgIGNvdW50OiAwXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWxlYXNlVHJhdmVyc2VDb250ZXh0KHRyYXZlcnNlQ29udGV4dCkge1xuICB0cmF2ZXJzZUNvbnRleHQucmVzdWx0ID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmtleVByZWZpeCA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5mdW5jID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmNvbnRleHQgPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQuY291bnQgPSAwO1xuICBpZiAodHJhdmVyc2VDb250ZXh0UG9vbC5sZW5ndGggPCBQT09MX1NJWkUpIHtcbiAgICB0cmF2ZXJzZUNvbnRleHRQb29sLnB1c2godHJhdmVyc2VDb250ZXh0KTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lU29GYXIgTmFtZSBvZiB0aGUga2V5IHBhdGggc28gZmFyLlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aXRoIGVhY2ggY2hpbGQgZm91bmQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgVXNlZCB0byBwYXNzIGluZm9ybWF0aW9uIHRocm91Z2hvdXQgdGhlIHRyYXZlcnNhbFxuICogcHJvY2Vzcy5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgbmFtZVNvRmFyLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkcmVuO1xuXG4gIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAvLyBBbGwgb2YgdGhlIGFib3ZlIGFyZSBwZXJjZWl2ZWQgYXMgbnVsbC5cbiAgICBjaGlsZHJlbiA9IG51bGw7XG4gIH1cblxuICB2YXIgaW52b2tlQ2FsbGJhY2sgPSBmYWxzZTtcblxuICBpZiAoY2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHN3aXRjaCAoY2hpbGRyZW4uJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0NBTExfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1JFVFVSTl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoaW52b2tlQ2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkcmVuLFxuICAgIC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93cy5cbiAgICBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkcmVuLCAwKSA6IG5hbWVTb0Zhcik7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBuZXh0TmFtZTtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB7XG4gICAgICAgIC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuICAgICAgICBpZiAoaXRlcmF0b3JGbiA9PT0gY2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICAgIHdhcm5pbmcoZGlkV2FybkFib3V0TWFwcywgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkICcgKyAndW5leHBlY3RlZCByZXN1bHRzLiBDb252ZXJ0IGl0IHRvIGEgc2VxdWVuY2UvaXRlcmFibGUgb2Yga2V5ZWQgJyArICdSZWFjdEVsZW1lbnRzIGluc3RlYWQuJXMnLCBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGNoaWxkcmVuKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgdmFyIGlpID0gMDtcbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG4gICAgICB7XG4gICAgICAgIGFkZGVuZHVtID0gJyBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZC4nICsgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gICAgICB9XG4gICAgICB2YXIgY2hpbGRyZW5TdHJpbmcgPSAnJyArIGNoaWxkcmVuO1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiAlcykuJXMnLCBjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcsIGFkZGVuZHVtKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VidHJlZUNvdW50O1xufVxuXG4vKipcbiAqIFRyYXZlcnNlcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAsIGJ1dFxuICogbWlnaHQgYWxzbyBiZSBzcGVjaWZpZWQgdGhyb3VnaCBhdHRyaWJ1dGVzOlxuICpcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbiwgLi4uKWBcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5sZWZ0UGFuZWxDaGlsZHJlbiwgLi4uKWBcbiAqXG4gKiBUaGUgYHRyYXZlcnNlQ29udGV4dGAgaXMgYW4gb3B0aW9uYWwgYXJndW1lbnQgdGhhdCBpcyBwYXNzZWQgdGhyb3VnaCB0aGVcbiAqIGVudGlyZSB0cmF2ZXJzYWwuIEl0IGNhbiBiZSB1c2VkIHRvIHN0b3JlIGFjY3VtdWxhdGlvbnMgb3IgYW55dGhpbmcgZWxzZSB0aGF0XG4gKiB0aGUgY2FsbGJhY2sgbWlnaHQgZmluZCByZWxldmFudC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIG9iamVjdC5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBUbyBpbnZva2UgdXBvbiB0cmF2ZXJzaW5nIGVhY2ggY2hpbGQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgQ29udGV4dCBmb3IgdHJhdmVyc2FsLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgJycsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBjb21wb25lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gY29tcG9uZW50IEEgY29tcG9uZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvbmVudEtleShjb21wb25lbnQsIGluZGV4KSB7XG4gIC8vIERvIHNvbWUgdHlwZWNoZWNraW5nIGhlcmUgc2luY2Ugd2UgY2FsbCB0aGlzIGJsaW5kbHkuIFdlIHdhbnQgdG8gZW5zdXJlXG4gIC8vIHRoYXQgd2UgZG9uJ3QgYmxvY2sgcG90ZW50aWFsIGZ1dHVyZSBFUyBBUElzLlxuICBpZiAodHlwZW9mIGNvbXBvbmVudCA9PT0gJ29iamVjdCcgJiYgY29tcG9uZW50ICE9PSBudWxsICYmIGNvbXBvbmVudC5rZXkgIT0gbnVsbCkge1xuICAgIC8vIEV4cGxpY2l0IGtleVxuICAgIHJldHVybiBlc2NhcGUoY29tcG9uZW50LmtleSk7XG4gIH1cbiAgLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaFNpbmdsZUNoaWxkKGJvb2tLZWVwaW5nLCBjaGlsZCwgbmFtZSkge1xuICB2YXIgZnVuYyA9IGJvb2tLZWVwaW5nLmZ1bmMsXG4gICAgICBjb250ZXh0ID0gYm9va0tlZXBpbmcuY29udGV4dDtcblxuICBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xufVxuXG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4uZm9yZWFjaFxuICpcbiAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuY1xuICogQHBhcmFtIHsqfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IGZvciBmb3JFYWNoQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IGdldFBvb2xlZFRyYXZlcnNlQ29udGV4dChudWxsLCBudWxsLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIHJlbGVhc2VUcmF2ZXJzZUNvbnRleHQodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dChib29rS2VlcGluZywgY2hpbGQsIGNoaWxkS2V5KSB7XG4gIHZhciByZXN1bHQgPSBib29rS2VlcGluZy5yZXN1bHQsXG4gICAgICBrZXlQcmVmaXggPSBib29rS2VlcGluZy5rZXlQcmVmaXgsXG4gICAgICBmdW5jID0gYm9va0tlZXBpbmcuZnVuYyxcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG5cbiAgdmFyIG1hcHBlZENoaWxkID0gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChtYXBwZWRDaGlsZCwgcmVzdWx0LCBjaGlsZEtleSwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XG4gICAgaWYgKGlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xuICAgICAgbWFwcGVkQ2hpbGQgPSBjbG9uZUFuZFJlcGxhY2VLZXkobWFwcGVkQ2hpbGQsXG4gICAgICAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xuICAgICAgLy8gdHJhdmVyc2VBbGxDaGlsZHJlbiB1c2VkIHRvIGRvIGZvciBvYmplY3RzIGFzIGNoaWxkcmVuXG4gICAgICBrZXlQcmVmaXggKyAobWFwcGVkQ2hpbGQua2V5ICYmICghY2hpbGQgfHwgY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpID8gZXNjYXBlVXNlclByb3ZpZGVkS2V5KG1hcHBlZENoaWxkLmtleSkgKyAnLycgOiAnJykgKyBjaGlsZEtleSk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKG1hcHBlZENoaWxkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCBhcnJheSwgcHJlZml4LCBmdW5jLCBjb250ZXh0KSB7XG4gIHZhciBlc2NhcGVkUHJlZml4ID0gJyc7XG4gIGlmIChwcmVmaXggIT0gbnVsbCkge1xuICAgIGVzY2FwZWRQcmVmaXggPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkocHJlZml4KSArICcvJztcbiAgfVxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gZ2V0UG9vbGVkVHJhdmVyc2VDb250ZXh0KGFycmF5LCBlc2NhcGVkUHJlZml4LCBmdW5jLCBjb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgcmVsZWFzZVRyYXZlcnNlQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4ubWFwXG4gKlxuICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBrZXksIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZnVuYyBUaGUgbWFwIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgZm9yIG1hcEZ1bmN0aW9uLlxuICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGZ1bmMsIGNvbnRleHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhc1xuICogYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLmNvdW50XG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4uXG4gKi9cbmZ1bmN0aW9uIGNvdW50Q2hpbGRyZW4oY2hpbGRyZW4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsLCBudWxsKTtcbn1cblxuLyoqXG4gKiBGbGF0dGVuIGEgY2hpbGRyZW4gb2JqZWN0ICh0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmApIGFuZFxuICogcmV0dXJuIGFuIGFycmF5IHdpdGggYXBwcm9wcmlhdGVseSByZS1rZXllZCBjaGlsZHJlbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLnRvYXJyYXlcbiAqL1xuZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcbiAqIGlzIG9ubHkgb25lIGNoaWxkIGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4ub25seVxuICpcbiAqIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGEgc2luZ2xlIGNoaWxkIGdldHNcbiAqIHBhc3NlZCB3aXRob3V0IGEgd3JhcHBlciwgYnV0IHRoZSBwdXJwb3NlIG9mIHRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHRvXG4gKiBhYnN0cmFjdCBhd2F5IHRoZSBwYXJ0aWN1bGFyIHN0cnVjdHVyZSBvZiBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGNoaWxkcmVuIENoaWxkIGNvbGxlY3Rpb24gc3RydWN0dXJlLlxuICogQHJldHVybiB7UmVhY3RFbGVtZW50fSBUaGUgZmlyc3QgYW5kIG9ubHkgYFJlYWN0RWxlbWVudGAgY29udGFpbmVkIGluIHRoZVxuICogc3RydWN0dXJlLlxuICovXG5mdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcbiAgIWlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0LkNoaWxkcmVuLm9ubHkgZXhwZWN0ZWQgdG8gcmVjZWl2ZSBhIHNpbmdsZSBSZWFjdCBlbGVtZW50IGNoaWxkLicpIDogdm9pZCAwO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbnZhciBkZXNjcmliZUNvbXBvbmVudEZyYW1lID0gZnVuY3Rpb24gKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKSB7XG4gIHJldHVybiAnXFxuICAgIGluICcgKyAobmFtZSB8fCAnVW5rbm93bicpICsgKHNvdXJjZSA/ICcgKGF0ICcgKyBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpICsgJzonICsgc291cmNlLmxpbmVOdW1iZXIgKyAnKScgOiBvd25lck5hbWUgPyAnIChjcmVhdGVkIGJ5ICcgKyBvd25lck5hbWUgKyAnKScgOiAnJyk7XG59O1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB7XG4gIHZhciB0eXBlID0gZmliZXIudHlwZTtcblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJlYWN0RWxlbWVudFZhbGlkYXRvciBwcm92aWRlcyBhIHdyYXBwZXIgYXJvdW5kIGEgZWxlbWVudCBmYWN0b3J5XG4gKiB3aGljaCB2YWxpZGF0ZXMgdGhlIHByb3BzIHBhc3NlZCB0byB0aGUgZWxlbWVudC4gVGhpcyBpcyBpbnRlbmRlZCB0byBiZVxuICogdXNlZCBvbmx5IGluIERFViBhbmQgY291bGQgYmUgcmVwbGFjZWQgYnkgYSBzdGF0aWMgdHlwZSBjaGVja2VyIGZvciBsYW5ndWFnZXNcbiAqIHRoYXQgc3VwcG9ydCBpdC5cbiAqL1xuXG57XG4gIHZhciBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IG51bGw7XG5cbiAgdmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG5cbiAgdmFyIGdldERpc3BsYXlOYW1lID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyNlbXB0eSc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGVsZW1lbnQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gJyN0ZXh0JztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZWxlbWVudC50eXBlO1xuICAgIH0gZWxzZSBpZiAoZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICByZXR1cm4gJ1JlYWN0LkZyYWdtZW50JztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVsZW1lbnQudHlwZS5kaXNwbGF5TmFtZSB8fCBlbGVtZW50LnR5cGUubmFtZSB8fCAnVW5rbm93bic7XG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRTdGFja0FkZGVuZHVtID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGFjayA9ICcnO1xuICAgIGlmIChjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXREaXNwbGF5TmFtZShjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCk7XG4gICAgICB2YXIgb3duZXIgPSBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudC5fb3duZXI7XG4gICAgICBzdGFjayArPSBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50Ll9zb3VyY2UsIG93bmVyICYmIGdldENvbXBvbmVudE5hbWUob3duZXIpKTtcbiAgICB9XG4gICAgc3RhY2sgKz0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCkgfHwgJyc7XG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xuXG4gIHZhciBWQUxJRF9GUkFHTUVOVF9QUk9QUyA9IG5ldyBNYXAoW1snY2hpbGRyZW4nLCB0cnVlXSwgWydrZXknLCB0cnVlXV0pO1xufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oZWxlbWVudFByb3BzKSB7XG4gIGlmIChlbGVtZW50UHJvcHMgIT09IG51bGwgJiYgZWxlbWVudFByb3BzICE9PSB1bmRlZmluZWQgJiYgZWxlbWVudFByb3BzLl9fc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgc291cmNlID0gZWxlbWVudFByb3BzLl9fc291cmNlO1xuICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgaWYgKCFpbmZvKSB7XG4gICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG4gICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgIGluZm8gPSAnXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8JyArIHBhcmVudE5hbWUgKyAnPi4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW5mbztcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcblxuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG4gIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTtcblxuICAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cbiAgdmFyIGNoaWxkT3duZXIgPSAnJztcbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICBjaGlsZE93bmVyID0gJyBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSAnICsgZ2V0Q29tcG9uZW50TmFtZShlbGVtZW50Ll9vd25lcikgKyAnLic7XG4gIH1cblxuICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IGVsZW1lbnQ7XG4gIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBvciBpdGVyYXRvciBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4lcycsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gIH1cbiAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBudWxsO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgIHZhciBzdGVwO1xuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHZhciBjb21wb25lbnRDbGFzcyA9IGVsZW1lbnQudHlwZTtcbiAgaWYgKHR5cGVvZiBjb21wb25lbnRDbGFzcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmFtZSA9IGNvbXBvbmVudENsYXNzLmRpc3BsYXlOYW1lIHx8IGNvbXBvbmVudENsYXNzLm5hbWU7XG4gIHZhciBwcm9wVHlwZXMgPSBjb21wb25lbnRDbGFzcy5wcm9wVHlwZXM7XG4gIGlmIChwcm9wVHlwZXMpIHtcbiAgICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0pO1xuICAgIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gbnVsbDtcbiAgfSBlbHNlIGlmIChjb21wb25lbnRDbGFzcy5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIG5hbWUgfHwgJ1Vua25vd24nKTtcbiAgfVxuICBpZiAodHlwZW9mIGNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHdhcm5pbmcoY29tcG9uZW50Q2xhc3MuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gZnJhZ21lbnQ7XG5cbiAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgdmFyIGtleSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICBpZiAoIVZBTElEX0ZSQUdNRU5UX1BST1BTLmhhcyhrZXkpKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJXMnLCBrZXksIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yWydyZXR1cm4nXSkge1xuICAgICAgICBfaXRlcmF0b3JbJ3JldHVybiddKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJXMnLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICB9XG5cbiAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciB2YWxpZFR5cGUgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHR5cGUgPT09ICdzeW1ib2wnIHx8IHR5cGVvZiB0eXBlID09PSAnbnVtYmVyJztcbiAgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cbiAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0ocHJvcHMpO1xuICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgfVxuXG4gICAgaW5mbyArPSBnZXRTdGFja0FkZGVuZHVtKCkgfHwgJyc7XG5cbiAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QuY3JlYXRlRWxlbWVudDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlID09IG51bGwgPyB0eXBlIDogdHlwZW9mIHR5cGUsIGluZm8pO1xuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuICBpZiAodmFsaWRUeXBlKSB7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3ltYm9sJyAmJiB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbih0eXBlKSB7XG4gIHZhciB2YWxpZGF0ZWRGYWN0b3J5ID0gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uLmJpbmQobnVsbCwgdHlwZSk7XG4gIC8vIExlZ2FjeSBob29rIFRPRE86IFdhcm4gaWYgdGhpcyBpcyBhY2Nlc3NlZFxuICB2YWxpZGF0ZWRGYWN0b3J5LnR5cGUgPSB0eXBlO1xuXG4gIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRhdGVkRmFjdG9yeSwgJ3R5cGUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJ0ZhY3RvcnkudHlwZSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdGhlIGNsYXNzIGRpcmVjdGx5ICcgKyAnYmVmb3JlIHBhc3NpbmcgaXQgdG8gY3JlYXRlRmFjdG9yeS4nKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgIHZhbHVlOiB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xufVxuXG5mdW5jdGlvbiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbihlbGVtZW50LCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBjbG9uZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gIH1cbiAgdmFsaWRhdGVQcm9wVHlwZXMobmV3RWxlbWVudCk7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuXG52YXIgUmVhY3QgPSB7XG4gIENoaWxkcmVuOiB7XG4gICAgbWFwOiBtYXBDaGlsZHJlbixcbiAgICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gICAgY291bnQ6IGNvdW50Q2hpbGRyZW4sXG4gICAgdG9BcnJheTogdG9BcnJheSxcbiAgICBvbmx5OiBvbmx5Q2hpbGRcbiAgfSxcblxuICBDb21wb25lbnQ6IENvbXBvbmVudCxcbiAgUHVyZUNvbXBvbmVudDogUHVyZUNvbXBvbmVudCxcbiAgdW5zdGFibGVfQXN5bmNDb21wb25lbnQ6IEFzeW5jQ29tcG9uZW50LFxuXG4gIEZyYWdtZW50OiBSRUFDVF9GUkFHTUVOVF9UWVBFLFxuXG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbixcbiAgY2xvbmVFbGVtZW50OiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbixcbiAgY3JlYXRlRmFjdG9yeTogY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uLFxuICBpc1ZhbGlkRWxlbWVudDogaXNWYWxpZEVsZW1lbnQsXG5cbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuXG4gIF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEOiB7XG4gICAgUmVhY3RDdXJyZW50T3duZXI6IFJlYWN0Q3VycmVudE93bmVyLFxuICAgIC8vIFVzZWQgYnkgcmVuZGVyZXJzIHRvIGF2b2lkIGJ1bmRsaW5nIG9iamVjdC1hc3NpZ24gdHdpY2UgaW4gVU1EIGJ1bmRsZXM6XG4gICAgYXNzaWduOiBfYXNzaWduXG4gIH1cbn07XG5cbntcbiAgX2Fzc2lnbihSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCwge1xuICAgIC8vIFRoZXNlIHNob3VsZCBub3QgYmUgaW5jbHVkZWQgaW4gcHJvZHVjdGlvbi5cbiAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lOiBSZWFjdERlYnVnQ3VycmVudEZyYW1lLFxuICAgIC8vIFNoaW0gZm9yIFJlYWN0IERPTSAxNi4wLjAgd2hpY2ggc3RpbGwgZGVzdHJ1Y3R1cmVkIChidXQgbm90IHVzZWQpIHRoaXMuXG4gICAgLy8gVE9ETzogcmVtb3ZlIGluIFJlYWN0IDE3LjAuXG4gICAgUmVhY3RDb21wb25lbnRUcmVlSG9vazoge31cbiAgfSk7XG59XG5cblxuXG52YXIgUmVhY3QkMiA9IE9iamVjdC5mcmVlemUoe1xuXHRkZWZhdWx0OiBSZWFjdFxufSk7XG5cbnZhciBSZWFjdCQzID0gKCBSZWFjdCQyICYmIFJlYWN0ICkgfHwgUmVhY3QkMjtcblxuLy8gVE9ETzogZGVjaWRlIG9uIHRoZSB0b3AtbGV2ZWwgZXhwb3J0IGZvcm0uXG4vLyBUaGlzIGlzIGhhY2t5IGJ1dCBtYWtlcyBpdCB3b3JrIHdpdGggYm90aCBSb2xsdXAgYW5kIEplc3QuXG52YXIgcmVhY3QgPSBSZWFjdCQzWydkZWZhdWx0J10gPyBSZWFjdCQzWydkZWZhdWx0J10gOiBSZWFjdCQzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWN0O1xuICB9KSgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCJpbXBvcnQgeyBUeXBlU3R5bGUgfSBmcm9tICcuL2ludGVybmFsL3R5cGVzdHlsZSc7XG5leHBvcnQgeyBUeXBlU3R5bGUgfTtcbi8qKlxuICogQWxsIHRoZSBDU1MgdHlwZXMgaW4gdGhlICd0eXBlcycgbmFtZXNwYWNlXG4gKi9cbmltcG9ydCAqIGFzIHR5cGVzIGZyb20gJy4vdHlwZXMnO1xuZXhwb3J0IHsgdHlwZXMgfTtcbi8qKlxuICogRXhwb3J0IGNlcnRhaW4gdXRpbGl0aWVzXG4gKi9cbmV4cG9ydCB7IGV4dGVuZCwgY2xhc3NlcywgbWVkaWEgfSBmcm9tICcuL2ludGVybmFsL3V0aWxpdGllcyc7XG4vKiogWmVybyBjb25maWd1cmF0aW9uLCBkZWZhdWx0IGluc3RhbmNlIG9mIFR5cGVTdHlsZSAqL1xudmFyIHRzID0gbmV3IFR5cGVTdHlsZSh7IGF1dG9HZW5lcmF0ZVRhZzogdHJ1ZSB9KTtcbi8qKiBTZXRzIHRoZSB0YXJnZXQgdGFnIHdoZXJlIHdlIHdyaXRlIHRoZSBjc3Mgb24gc3R5bGUgdXBkYXRlcyAqL1xuZXhwb3J0IHZhciBzZXRTdHlsZXNUYXJnZXQgPSB0cy5zZXRTdHlsZXNUYXJnZXQ7XG4vKipcbiAqIEluc2VydCBgcmF3YCBDU1MgYXMgYSBzdHJpbmcuIFRoaXMgaXMgdXNlZnVsIGZvciBlLmcuXG4gKiAtIHRoaXJkIHBhcnR5IENTUyB0aGF0IHlvdSBhcmUgY3VzdG9taXppbmcgd2l0aCB0ZW1wbGF0ZSBzdHJpbmdzXG4gKiAtIGdlbmVyYXRpbmcgcmF3IENTUyBpbiBKYXZhU2NyaXB0XG4gKiAtIHJlc2V0IGxpYnJhcmllcyBsaWtlIG5vcm1hbGl6ZS5jc3MgdGhhdCB5b3UgY2FuIHVzZSB3aXRob3V0IGxvYWRlcnNcbiAqL1xuZXhwb3J0IHZhciBjc3NSYXcgPSB0cy5jc3NSYXc7XG4vKipcbiAqIFRha2VzIENTU1Byb3BlcnRpZXMgYW5kIHJlZ2lzdGVycyBpdCB0byBhIGdsb2JhbCBzZWxlY3RvciAoYm9keSwgaHRtbCwgZXRjLilcbiAqL1xuZXhwb3J0IHZhciBjc3NSdWxlID0gdHMuY3NzUnVsZTtcbi8qKlxuICogUmVuZGVycyBzdHlsZXMgdG8gdGhlIHNpbmdsZXRvbiB0YWcgaW1lZGlhdGVseVxuICogTk9URTogWW91IHNob3VsZCBvbmx5IGNhbGwgaXQgb24gaW5pdGlhbCByZW5kZXIgdG8gcHJldmVudCBhbnkgbm9uIENTUyBmbGFzaC5cbiAqIEFmdGVyIHRoYXQgaXQgaXMga2VwdCBzeW5jIHVzaW5nIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIGFuZCB3ZSBoYXZlbid0IG5vdGljZWQgYW55IGJhZCBmbGFzaGVzLlxuICoqL1xuZXhwb3J0IHZhciBmb3JjZVJlbmRlclN0eWxlcyA9IHRzLmZvcmNlUmVuZGVyU3R5bGVzO1xuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIHJlZ2lzdGVyIGFuIEBmb250LWZhY2VcbiAqL1xuZXhwb3J0IHZhciBmb250RmFjZSA9IHRzLmZvbnRGYWNlO1xuLyoqXG4gKiBBbGxvd3MgdXNlIHRvIHVzZSB0aGUgc3R5bGVzaGVldCBpbiBhIG5vZGUuanMgZW52aXJvbm1lbnRcbiAqL1xuZXhwb3J0IHZhciBnZXRTdHlsZXMgPSB0cy5nZXRTdHlsZXM7XG4vKipcbiAqIFRha2VzIGtleWZyYW1lcyBhbmQgcmV0dXJucyBhIGdlbmVyYXRlZCBhbmltYXRpb25OYW1lXG4gKi9cbmV4cG9ydCB2YXIga2V5ZnJhbWVzID0gdHMua2V5ZnJhbWVzO1xuLyoqXG4gKiBIZWxwcyB3aXRoIHRlc3RpbmcuIFJlaW5pdGlhbGl6ZXMgRnJlZVN0eWxlICsgcmF3XG4gKi9cbmV4cG9ydCB2YXIgcmVpbml0ID0gdHMucmVpbml0O1xuLyoqXG4gKiBUYWtlcyBDU1NQcm9wZXJ0aWVzIGFuZCByZXR1cm4gYSBnZW5lcmF0ZWQgY2xhc3NOYW1lIHlvdSBjYW4gdXNlIG9uIHlvdXIgY29tcG9uZW50XG4gKi9cbmV4cG9ydCB2YXIgc3R5bGUgPSB0cy5zdHlsZTtcbi8qKlxuICogVGFrZXMgYW4gb2JqZWN0IHdoZXJlIHByb3BlcnR5IG5hbWVzIGFyZSBpZGVhbCBjbGFzcyBuYW1lcyBhbmQgcHJvcGVydHkgdmFsdWVzIGFyZSBDU1NQcm9wZXJ0aWVzLCBhbmRcbiAqIHJldHVybnMgYW4gb2JqZWN0IHdoZXJlIHByb3BlcnR5IG5hbWVzIGFyZSB0aGUgc2FtZSBpZGVhbCBjbGFzcyBuYW1lcyBhbmQgdGhlIHByb3BlcnR5IHZhbHVlcyBhcmVcbiAqIHRoZSBhY3R1YWwgZ2VuZXJhdGVkIGNsYXNzIG5hbWVzIHVzaW5nIHRoZSBpZGVhbCBjbGFzcyBuYW1lIGFzIHRoZSAkZGVidWdOYW1lXG4gKi9cbmV4cG9ydCB2YXIgc3R5bGVzaGVldCA9IHRzLnN0eWxlc2hlZXQ7XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgVHlwZVN0eWxlIHNlcGFyYXRlIGZyb20gdGhlIGRlZmF1bHQgaW5zdGFuY2UuXG4gKlxuICogLSBVc2UgdGhpcyBmb3IgY3JlYXRpbmcgYSBkaWZmZXJlbnQgdHlwZXN0eWxlIGluc3RhbmNlIGZvciBhIHNoYWRvdyBkb20gY29tcG9uZW50LlxuICogLSBVc2UgdGhpcyBpZiB5b3UgZG9uJ3Qgd2FudCBhbiBhdXRvIHRhZyBnZW5lcmF0ZWQgYW5kIHlvdSBqdXN0IHdhbnQgdG8gY29sbGVjdCB0aGUgQ1NTLlxuICpcbiAqIE5PVEU6IHN0eWxlcyBhcmVuJ3Qgc2hhcmVkIGJldHdlZW4gZGlmZmVyZW50IGluc3RhbmNlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVR5cGVTdHlsZSh0YXJnZXQpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBuZXcgVHlwZVN0eWxlKHsgYXV0b0dlbmVyYXRlVGFnOiBmYWxzZSB9KTtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIGluc3RhbmNlLnNldFN0eWxlc1RhcmdldCh0YXJnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gaW5zdGFuY2U7XG59XG4iLCJpbXBvcnQgKiBhcyBGcmVlU3R5bGUgZnJvbSAnZnJlZS1zdHlsZSc7XG4vKipcbiAqIFdlIG5lZWQgdG8gZG8gdGhlIGZvbGxvd2luZyB0byAqb3VyKiBvYmplY3RzIGJlZm9yZSBwYXNzaW5nIHRvIGZyZWVzdHlsZTpcbiAqIC0gRm9yIGFueSBgJG5lc3RgIGRpcmVjdGl2ZSBtb3ZlIHVwIHRvIEZyZWVTdHlsZSBzdHlsZSBuZXN0aW5nXG4gKiAtIEZvciBhbnkgYCR1bmlxdWVgIGRpcmVjdGl2ZSBtYXAgdG8gRnJlZVN0eWxlIFVuaXF1ZVxuICogLSBGb3IgYW55IGAkZGVidWdOYW1lYCBkaXJlY3RpdmUgcmV0dXJuIHRoZSBkZWJ1ZyBuYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVTdHJpbmdPYmoob2JqZWN0KSB7XG4gICAgLyoqIFRoZSBmaW5hbCByZXN1bHQgd2Ugd2lsbCByZXR1cm4gKi9cbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGRlYnVnTmFtZSA9ICcnO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgLyoqIEdyYWIgdGhlIHZhbHVlIHVwZnJvbnQgKi9cbiAgICAgICAgdmFyIHZhbCA9IG9iamVjdFtrZXldO1xuICAgICAgICAvKiogVHlwZVN0eWxlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyAqL1xuICAgICAgICBpZiAoa2V5ID09PSAnJHVuaXF1ZScpIHtcbiAgICAgICAgICAgIHJlc3VsdFtGcmVlU3R5bGUuSVNfVU5JUVVFXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09ICckbmVzdCcpIHtcbiAgICAgICAgICAgIHZhciBuZXN0ZWQgPSB2YWw7XG4gICAgICAgICAgICBmb3IgKHZhciBzZWxlY3RvciBpbiBuZXN0ZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3VicHJvcGVydGllcyA9IG5lc3RlZFtzZWxlY3Rvcl07XG4gICAgICAgICAgICAgICAgcmVzdWx0W3NlbGVjdG9yXSA9IGVuc3VyZVN0cmluZ09iaihzdWJwcm9wZXJ0aWVzKS5yZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnJGRlYnVnTmFtZScpIHtcbiAgICAgICAgICAgIGRlYnVnTmFtZSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHJlc3VsdDogcmVzdWx0LCBkZWJ1Z05hbWU6IGRlYnVnTmFtZSB9O1xufVxuLy8gdG9kbzogYmV0dGVyIG5hbWUgaGVyZVxuZXhwb3J0IGZ1bmN0aW9uIGV4cGxvZGVLZXlmcmFtZXMoZnJhbWVzKSB7XG4gICAgdmFyIHJlc3VsdCA9IHsgJGRlYnVnTmFtZTogdW5kZWZpbmVkLCBrZXlmcmFtZXM6IHt9IH07XG4gICAgZm9yICh2YXIgb2Zmc2V0IGluIGZyYW1lcykge1xuICAgICAgICB2YXIgdmFsID0gZnJhbWVzW29mZnNldF07XG4gICAgICAgIGlmIChvZmZzZXQgPT09ICckZGVidWdOYW1lJykge1xuICAgICAgICAgICAgcmVzdWx0LiRkZWJ1Z05hbWUgPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQua2V5ZnJhbWVzW29mZnNldF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsImltcG9ydCB7IGVuc3VyZVN0cmluZ09iaiwgZXhwbG9kZUtleWZyYW1lcyB9IGZyb20gJy4vZm9ybWF0dGluZyc7XG5pbXBvcnQgeyBleHRlbmQsIHJhZiB9IGZyb20gJy4vdXRpbGl0aWVzJztcbmltcG9ydCAqIGFzIEZyZWVTdHlsZSBmcm9tIFwiZnJlZS1zdHlsZVwiO1xuLyoqXG4gKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGZyZWUgc3R5bGUgd2l0aCBvdXIgb3B0aW9uc1xuICovXG52YXIgY3JlYXRlRnJlZVN0eWxlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gRnJlZVN0eWxlLmNyZWF0ZShcbi8qKiBVc2UgdGhlIGRlZmF1bHQgaGFzaCBmdW5jdGlvbiAqL1xudW5kZWZpbmVkLCBcbi8qKiBQcmVzZXJ2ZSAkZGVidWdOYW1lIHZhbHVlcyAqL1xudHJ1ZSk7IH07XG4vKipcbiAqIE1haW50YWlucyBhIHNpbmdsZSBzdHlsZXNoZWV0IGFuZCBrZWVwcyBpdCBpbiBzeW5jIHdpdGggcmVxdWVzdGVkIHN0eWxlc1xuICovXG52YXIgVHlwZVN0eWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFR5cGVTdHlsZShfYSkge1xuICAgICAgICB2YXIgYXV0b0dlbmVyYXRlVGFnID0gX2EuYXV0b0dlbmVyYXRlVGFnO1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5zZXJ0IGByYXdgIENTUyBhcyBhIHN0cmluZy4gVGhpcyBpcyB1c2VmdWwgZm9yIGUuZy5cbiAgICAgICAgICogLSB0aGlyZCBwYXJ0eSBDU1MgdGhhdCB5b3UgYXJlIGN1c3RvbWl6aW5nIHdpdGggdGVtcGxhdGUgc3RyaW5nc1xuICAgICAgICAgKiAtIGdlbmVyYXRpbmcgcmF3IENTUyBpbiBKYXZhU2NyaXB0XG4gICAgICAgICAqIC0gcmVzZXQgbGlicmFyaWVzIGxpa2Ugbm9ybWFsaXplLmNzcyB0aGF0IHlvdSBjYW4gdXNlIHdpdGhvdXQgbG9hZGVyc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jc3NSYXcgPSBmdW5jdGlvbiAobXVzdEJlVmFsaWRDU1MpIHtcbiAgICAgICAgICAgIGlmICghbXVzdEJlVmFsaWRDU1MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fcmF3ICs9IG11c3RCZVZhbGlkQ1NTIHx8ICcnO1xuICAgICAgICAgICAgX3RoaXMuX3BlbmRpbmdSYXdDaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgX3RoaXMuX3N0eWxlVXBkYXRlZCgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZXMgQ1NTUHJvcGVydGllcyBhbmQgcmVnaXN0ZXJzIGl0IHRvIGEgZ2xvYmFsIHNlbGVjdG9yIChib2R5LCBodG1sLCBldGMuKVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jc3NSdWxlID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBvYmplY3RzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG9iamVjdCA9IGVuc3VyZVN0cmluZ09iaihleHRlbmQuYXBwbHkodm9pZCAwLCBvYmplY3RzKSkucmVzdWx0O1xuICAgICAgICAgICAgX3RoaXMuX2ZyZWVTdHlsZS5yZWdpc3RlclJ1bGUoc2VsZWN0b3IsIG9iamVjdCk7XG4gICAgICAgICAgICBfdGhpcy5fc3R5bGVVcGRhdGVkKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXJzIHN0eWxlcyB0byB0aGUgc2luZ2xldG9uIHRhZyBpbWVkaWF0ZWx5XG4gICAgICAgICAqIE5PVEU6IFlvdSBzaG91bGQgb25seSBjYWxsIGl0IG9uIGluaXRpYWwgcmVuZGVyIHRvIHByZXZlbnQgYW55IG5vbiBDU1MgZmxhc2guXG4gICAgICAgICAqIEFmdGVyIHRoYXQgaXQgaXMga2VwdCBzeW5jIHVzaW5nIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIGFuZCB3ZSBoYXZlbid0IG5vdGljZWQgYW55IGJhZCBmbGFzaGVzLlxuICAgICAgICAgKiovXG4gICAgICAgIHRoaXMuZm9yY2VSZW5kZXJTdHlsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gX3RoaXMuX2dldFRhZygpO1xuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXQudGV4dENvbnRlbnQgPSBfdGhpcy5nZXRTdHlsZXMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gcmVnaXN0ZXIgYW4gQGZvbnQtZmFjZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb250RmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBmb250RmFjZSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBmb250RmFjZVtfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZyZWVTdHlsZSA9IF90aGlzLl9mcmVlU3R5bGU7XG4gICAgICAgICAgICBmb3IgKHZhciBfYSA9IDAsIF9iID0gZm9udEZhY2U7IF9hIDwgX2IubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZhY2UgPSBfYltfYV07XG4gICAgICAgICAgICAgICAgZnJlZVN0eWxlLnJlZ2lzdGVyUnVsZSgnQGZvbnQtZmFjZScsIGZhY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuX3N0eWxlVXBkYXRlZCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWxsb3dzIHVzZSB0byB1c2UgdGhlIHN0eWxlc2hlZXQgaW4gYSBub2RlLmpzIGVudmlyb25tZW50XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldFN0eWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAoX3RoaXMuX3JhdyB8fCAnJykgKyBfdGhpcy5fZnJlZVN0eWxlLmdldFN0eWxlcygpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZXMga2V5ZnJhbWVzIGFuZCByZXR1cm5zIGEgZ2VuZXJhdGVkIGFuaW1hdGlvbk5hbWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMua2V5ZnJhbWVzID0gZnVuY3Rpb24gKGZyYW1lcykge1xuICAgICAgICAgICAgdmFyIF9hID0gZXhwbG9kZUtleWZyYW1lcyhmcmFtZXMpLCBrZXlmcmFtZXMgPSBfYS5rZXlmcmFtZXMsICRkZWJ1Z05hbWUgPSBfYS4kZGVidWdOYW1lO1xuICAgICAgICAgICAgLy8gVE9ETzogcmVwbGFjZSAkZGVidWdOYW1lIHdpdGggZGlzcGxheSBuYW1lXG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uTmFtZSA9IF90aGlzLl9mcmVlU3R5bGUucmVnaXN0ZXJLZXlmcmFtZXMoa2V5ZnJhbWVzLCAkZGVidWdOYW1lKTtcbiAgICAgICAgICAgIF90aGlzLl9zdHlsZVVwZGF0ZWQoKTtcbiAgICAgICAgICAgIHJldHVybiBhbmltYXRpb25OYW1lO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSGVscHMgd2l0aCB0ZXN0aW5nLiBSZWluaXRpYWxpemVzIEZyZWVTdHlsZSArIHJhd1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvKiogcmVpbml0IGZyZWVzdHlsZSAqL1xuICAgICAgICAgICAgdmFyIGZyZWVTdHlsZSA9IGNyZWF0ZUZyZWVTdHlsZSgpO1xuICAgICAgICAgICAgX3RoaXMuX2ZyZWVTdHlsZSA9IGZyZWVTdHlsZTtcbiAgICAgICAgICAgIF90aGlzLl9sYXN0RnJlZVN0eWxlQ2hhbmdlSWQgPSBmcmVlU3R5bGUuY2hhbmdlSWQ7XG4gICAgICAgICAgICAvKiogcmVpbml0IHJhdyAqL1xuICAgICAgICAgICAgX3RoaXMuX3JhdyA9ICcnO1xuICAgICAgICAgICAgX3RoaXMuX3BlbmRpbmdSYXdDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKiBDbGVhciBhbnkgc3R5bGVzIHRoYXQgd2VyZSBmbHVzaGVkICovXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gX3RoaXMuX2dldFRhZygpO1xuICAgICAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC50ZXh0Q29udGVudCA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiogU2V0cyB0aGUgdGFyZ2V0IHRhZyB3aGVyZSB3ZSB3cml0ZSB0aGUgY3NzIG9uIHN0eWxlIHVwZGF0ZXMgKi9cbiAgICAgICAgdGhpcy5zZXRTdHlsZXNUYXJnZXQgPSBmdW5jdGlvbiAodGFnKSB7XG4gICAgICAgICAgICAvKiogQ2xlYXIgYW55IGRhdGEgaW4gYW55IHByZXZpb3VzIHRhZyAqL1xuICAgICAgICAgICAgaWYgKF90aGlzLl90YWcpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdGFnLnRleHRDb250ZW50ID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fdGFnID0gdGFnO1xuICAgICAgICAgICAgLyoqIFRoaXMgc3BlY2lhbCB0aW1lIGJ1ZmZlciBpbW1lZGlhdGVseSAqL1xuICAgICAgICAgICAgX3RoaXMuZm9yY2VSZW5kZXJTdHlsZXMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRha2VzIENTU1Byb3BlcnRpZXMgYW5kIHJldHVybiBhIGdlbmVyYXRlZCBjbGFzc05hbWUgeW91IGNhbiB1c2Ugb24geW91ciBjb21wb25lbnRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3R5bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBvYmplY3RzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZnJlZVN0eWxlID0gX3RoaXMuX2ZyZWVTdHlsZTtcbiAgICAgICAgICAgIHZhciBfYSA9IGVuc3VyZVN0cmluZ09iaihleHRlbmQuYXBwbHkodm9pZCAwLCBvYmplY3RzKSksIHJlc3VsdCA9IF9hLnJlc3VsdCwgZGVidWdOYW1lID0gX2EuZGVidWdOYW1lO1xuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGRlYnVnTmFtZSA/IGZyZWVTdHlsZS5yZWdpc3RlclN0eWxlKHJlc3VsdCwgZGVidWdOYW1lKSA6IGZyZWVTdHlsZS5yZWdpc3RlclN0eWxlKHJlc3VsdCk7XG4gICAgICAgICAgICBfdGhpcy5fc3R5bGVVcGRhdGVkKCk7XG4gICAgICAgICAgICByZXR1cm4gY2xhc3NOYW1lO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZXMgYW4gb2JqZWN0IHdoZXJlIHByb3BlcnR5IG5hbWVzIGFyZSBpZGVhbCBjbGFzcyBuYW1lcyBhbmQgcHJvcGVydHkgdmFsdWVzIGFyZSBDU1NQcm9wZXJ0aWVzLCBhbmRcbiAgICAgICAgICogcmV0dXJucyBhbiBvYmplY3Qgd2hlcmUgcHJvcGVydHkgbmFtZXMgYXJlIHRoZSBzYW1lIGlkZWFsIGNsYXNzIG5hbWVzIGFuZCB0aGUgcHJvcGVydHkgdmFsdWVzIGFyZVxuICAgICAgICAgKiB0aGUgYWN0dWFsIGdlbmVyYXRlZCBjbGFzcyBuYW1lcyB1c2luZyB0aGUgaWRlYWwgY2xhc3MgbmFtZSBhcyB0aGUgJGRlYnVnTmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdHlsZXNoZWV0ID0gZnVuY3Rpb24gKGNsYXNzZXMpIHtcbiAgICAgICAgICAgIHZhciBjbGFzc05hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY2xhc3Nlcyk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGNsYXNzTmFtZXNfMSA9IGNsYXNzTmFtZXM7IF9pIDwgY2xhc3NOYW1lc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSBjbGFzc05hbWVzXzFbX2ldO1xuICAgICAgICAgICAgICAgIHZhciBjbGFzc0RlZiA9IGNsYXNzZXNbY2xhc3NOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoY2xhc3NEZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NEZWYuJGRlYnVnTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2NsYXNzTmFtZV0gPSBfdGhpcy5zdHlsZShjbGFzc0RlZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGZyZWVTdHlsZSA9IGNyZWF0ZUZyZWVTdHlsZSgpO1xuICAgICAgICB0aGlzLl9hdXRvR2VuZXJhdGVUYWcgPSBhdXRvR2VuZXJhdGVUYWc7XG4gICAgICAgIHRoaXMuX2ZyZWVTdHlsZSA9IGZyZWVTdHlsZTtcbiAgICAgICAgdGhpcy5fbGFzdEZyZWVTdHlsZUNoYW5nZUlkID0gZnJlZVN0eWxlLmNoYW5nZUlkO1xuICAgICAgICB0aGlzLl9wZW5kaW5nID0gMDtcbiAgICAgICAgdGhpcy5fcGVuZGluZ1Jhd0NoYW5nZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yYXcgPSAnJztcbiAgICAgICAgdGhpcy5fdGFnID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbmx5IGNhbGxzIGNiIGFsbCBzeW5jIG9wZXJhdGlvbnMgc2V0dGxlXG4gICAgICovXG4gICAgVHlwZVN0eWxlLnByb3RvdHlwZS5fYWZ0ZXJBbGxTeW5jID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3BlbmRpbmcrKztcbiAgICAgICAgdmFyIHBlbmRpbmcgPSB0aGlzLl9wZW5kaW5nO1xuICAgICAgICByYWYoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHBlbmRpbmcgIT09IF90aGlzLl9wZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBUeXBlU3R5bGUucHJvdG90eXBlLl9nZXRUYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl90YWcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90YWc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2F1dG9HZW5lcmF0ZVRhZykge1xuICAgICAgICAgICAgdmFyIHRhZyA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgPyB7IHRleHRDb250ZW50OiAnJyB9XG4gICAgICAgICAgICAgICAgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHRhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl90YWcgPSB0YWc7XG4gICAgICAgICAgICByZXR1cm4gdGFnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICAvKiogQ2hlY2tzIGlmIHRoZSBzdHlsZSB0YWcgbmVlZHMgdXBkYXRpbmcgYW5kIGlmIHNvIHF1ZXVlcyB1cCB0aGUgY2hhbmdlICovXG4gICAgVHlwZVN0eWxlLnByb3RvdHlwZS5fc3R5bGVVcGRhdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY2hhbmdlSWQgPSB0aGlzLl9mcmVlU3R5bGUuY2hhbmdlSWQ7XG4gICAgICAgIHZhciBsYXN0Q2hhbmdlSWQgPSB0aGlzLl9sYXN0RnJlZVN0eWxlQ2hhbmdlSWQ7XG4gICAgICAgIGlmICghdGhpcy5fcGVuZGluZ1Jhd0NoYW5nZSAmJiBjaGFuZ2VJZCA9PT0gbGFzdENoYW5nZUlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGFzdEZyZWVTdHlsZUNoYW5nZUlkID0gY2hhbmdlSWQ7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdSYXdDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYWZ0ZXJBbGxTeW5jKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmZvcmNlUmVuZGVyU3R5bGVzKCk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFR5cGVTdHlsZTtcbn0oKSk7XG5leHBvcnQgeyBUeXBlU3R5bGUgfTtcbiIsIi8qKiBSYWYgZm9yIG5vZGUgKyBicm93c2VyICovXG5leHBvcnQgdmFyIHJhZiA9IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09ICd1bmRlZmluZWQnXG4gICAgLyoqXG4gICAgICogbWFrZSBzdXJlIHNldFRpbWVvdXQgaXMgYWx3YXlzIGludm9rZWQgd2l0aFxuICAgICAqIGB0aGlzYCBzZXQgdG8gYHdpbmRvd2Agb3IgYGdsb2JhbGAgYXV0b21hdGljYWxseVxuICAgICAqKi9cbiAgICA/IGZ1bmN0aW9uIChjYikgeyByZXR1cm4gc2V0VGltZW91dChjYik7IH1cbiAgICAvKiogbWFrZSBzdXJlIHJhZiBpcyBhbHdheXMgaW52b2tlZCB3aXRoIGB0aGlzYCB3aW5kb3cgKi9cbiAgICA6IHJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdyk7XG4vKipcbiAqIFV0aWxpdHkgdG8gam9pbiBjbGFzc2VzIGNvbmRpdGlvbmFsbHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYXNzZXMoKSB7XG4gICAgdmFyIGNsYXNzZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBjbGFzc2VzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBjbGFzc2VzLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gISFjOyB9KS5qb2luKCcgJyk7XG59XG4vKipcbiAqIE1lcmdlcyB2YXJpb3VzIHN0eWxlcyBpbnRvIGEgc2luZ2xlIHN0eWxlIG9iamVjdC5cbiAqIE5vdGU6IGlmIHR3byBvYmplY3RzIGhhdmUgdGhlIHNhbWUgcHJvcGVydHkgdGhlIGxhc3Qgb25lIHdpbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZCgpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG9iamVjdHNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgLyoqIFRoZSBmaW5hbCByZXN1bHQgd2Ugd2lsbCByZXR1cm4gKi9cbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgX2EgPSAwLCBvYmplY3RzXzEgPSBvYmplY3RzOyBfYSA8IG9iamVjdHNfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IG9iamVjdHNfMVtfYV07XG4gICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCB8fCBvYmplY3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAvKiogRmFsc3kgdmFsdWVzIGV4Y2VwdCBhIGV4cGxpY2l0IDAgaXMgaWdub3JlZCAqL1xuICAgICAgICAgICAgdmFyIHZhbCA9IG9iamVjdFtrZXldO1xuICAgICAgICAgICAgaWYgKCF2YWwgJiYgdmFsICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiogaWYgbmVzdGVkIG1lZGlhIG9yIHBzZXVkbyBzZWxlY3RvciAqL1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJyRuZXN0JyAmJiB2YWwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHJlc3VsdFsnJG5lc3QnXSA/IGV4dGVuZChyZXN1bHRbJyRuZXN0J10sIHZhbCkgOiB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoa2V5LmluZGV4T2YoJyYnKSAhPT0gLTEgfHwga2V5LmluZGV4T2YoJ0BtZWRpYScpID09PSAwKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gcmVzdWx0W2tleV0gPyBleHRlbmQocmVzdWx0W2tleV0sIHZhbCkgOiB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBVdGlsaXR5IHRvIGhlbHAgY3VzdG9taXplIHN0eWxlcyB3aXRoIG1lZGlhIHF1ZXJpZXMuIGUuZy5cbiAqIGBgYFxuICogc3R5bGUoXG4gKiAgbWVkaWEoe21heFdpZHRoOjUwMH0sIHtjb2xvcjoncmVkJ30pXG4gKiApXG4gKiBgYGBcbiAqL1xuZXhwb3J0IHZhciBtZWRpYSA9IGZ1bmN0aW9uIChtZWRpYVF1ZXJ5KSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvYmplY3RzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgbWVkaWFRdWVyeVNlY3Rpb25zID0gW107XG4gICAgaWYgKG1lZGlhUXVlcnkudHlwZSlcbiAgICAgICAgbWVkaWFRdWVyeVNlY3Rpb25zLnB1c2gobWVkaWFRdWVyeS50eXBlKTtcbiAgICBpZiAobWVkaWFRdWVyeS5vcmllbnRhdGlvbilcbiAgICAgICAgbWVkaWFRdWVyeVNlY3Rpb25zLnB1c2goXCIob3JpZW50YXRpb246IFwiICsgbWVkaWFRdWVyeS5vcmllbnRhdGlvbiArIFwiKVwiKTtcbiAgICBpZiAobWVkaWFRdWVyeS5taW5XaWR0aClcbiAgICAgICAgbWVkaWFRdWVyeVNlY3Rpb25zLnB1c2goXCIobWluLXdpZHRoOiBcIiArIG1lZGlhTGVuZ3RoKG1lZGlhUXVlcnkubWluV2lkdGgpICsgXCIpXCIpO1xuICAgIGlmIChtZWRpYVF1ZXJ5Lm1heFdpZHRoKVxuICAgICAgICBtZWRpYVF1ZXJ5U2VjdGlvbnMucHVzaChcIihtYXgtd2lkdGg6IFwiICsgbWVkaWFMZW5ndGgobWVkaWFRdWVyeS5tYXhXaWR0aCkgKyBcIilcIik7XG4gICAgaWYgKG1lZGlhUXVlcnkubWluSGVpZ2h0KVxuICAgICAgICBtZWRpYVF1ZXJ5U2VjdGlvbnMucHVzaChcIihtaW4taGVpZ2h0OiBcIiArIG1lZGlhTGVuZ3RoKG1lZGlhUXVlcnkubWluSGVpZ2h0KSArIFwiKVwiKTtcbiAgICBpZiAobWVkaWFRdWVyeS5tYXhIZWlnaHQpXG4gICAgICAgIG1lZGlhUXVlcnlTZWN0aW9ucy5wdXNoKFwiKG1heC1oZWlnaHQ6IFwiICsgbWVkaWFMZW5ndGgobWVkaWFRdWVyeS5tYXhIZWlnaHQpICsgXCIpXCIpO1xuICAgIHZhciBzdHJpbmdNZWRpYVF1ZXJ5ID0gXCJAbWVkaWEgXCIgKyBtZWRpYVF1ZXJ5U2VjdGlvbnMuam9pbignIGFuZCAnKTtcbiAgICB2YXIgb2JqZWN0ID0ge1xuICAgICAgICAkbmVzdDogKF9hID0ge30sXG4gICAgICAgICAgICBfYVtzdHJpbmdNZWRpYVF1ZXJ5XSA9IGV4dGVuZC5hcHBseSh2b2lkIDAsIG9iamVjdHMpLFxuICAgICAgICAgICAgX2EpXG4gICAgfTtcbiAgICByZXR1cm4gb2JqZWN0O1xuICAgIHZhciBfYTtcbn07XG52YXIgbWVkaWFMZW5ndGggPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlIDogdmFsdWUgKyBcInB4XCI7XG59O1xuIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsIGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaCAoZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG4iLCJleHBvcnQgZnVuY3Rpb24gc2h1ZmZsZShhcnJheTogYW55W10pIHtcbiAgdmFyIGN1cnJlbnRJbmRleCA9IGFycmF5Lmxlbmd0aCxcbiAgICB0ZW1wb3JhcnlWYWx1ZSxcbiAgICByYW5kb21JbmRleDtcblxuICAvLyBXaGlsZSB0aGVyZSByZW1haW4gZWxlbWVudHMgdG8gc2h1ZmZsZS4uLlxuICB3aGlsZSAoMCAhPT0gY3VycmVudEluZGV4KSB7XG4gICAgLy8gUGljayBhIHJlbWFpbmluZyBlbGVtZW50Li4uXG4gICAgcmFuZG9tSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjdXJyZW50SW5kZXgpO1xuICAgIGN1cnJlbnRJbmRleCAtPSAxO1xuXG4gICAgLy8gQW5kIHN3YXAgaXQgd2l0aCB0aGUgY3VycmVudCBlbGVtZW50LlxuICAgIHRlbXBvcmFyeVZhbHVlID0gYXJyYXlbY3VycmVudEluZGV4XTtcbiAgICBhcnJheVtjdXJyZW50SW5kZXhdID0gYXJyYXlbcmFuZG9tSW5kZXhdO1xuICAgIGFycmF5W3JhbmRvbUluZGV4XSA9IHRlbXBvcmFyeVZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIGFycmF5O1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBU3dBQUFFc0NBWUFBQUI1Zlk1MUFBQUFBWE5TUjBJQXJzNGM2UUFBUUFCSlJFRlVlQUZzdlZtVEprbDJudWU1ZnJuWDF0VmRTMjh6MCtpWndZQWdKUnBvQkFZRXlBdEpsTWtrU3FZTG1XU21HLzJTL2tNMGswbDN1cUZwb1JrRUl6RVFnZG5BV1hwNnI3MHlLL2RWei9PZU9KbmZqTUdySWlQQy9malovSnpqUzNqRXQzQjNaL05xSkYyTnkwdVB5N0cwdERRV0ZoWXFtNytucDZlNU50OXl5eFlYRjhmNStYbk81aTB2THlmLzR1SmlYRjVkallXbHhiRUkzRUpqTjQvN0M4NkxsSjFmWG95cks4cjVaN0xzaXJKT1hqY2ZYa3ZEUTdyenZBbGY5SmU0S2h3Tks1ekgrZG41V0ZsZEhsY0w4RDdSczU2NEduZmRJOStGdkhoWGVJVVpBOTRYNWFINHBDVGx6ZS9pNGxMd3lLOGltQzhPYWN2TGZHcWFoYmRLaEZOdjZuTmxaU1hYNXFuVHpoZDMxeEduK2NLc3JxNm1uaXlyZDJITWJ6ckZ5K0s0dUR5dk5nTE92RDZrNGJXMDFZMHRZSDN6R3BlMHVPVys5TG1BbmFBUTZwd0JPMmlud3FGcWw5Q0Y5ZFZaODFoNkViT3dTMFVMbUlVcjJ2UUNYVTM1bHBtVUR3NUZBZEhTb1hvSmo5YmprTDlRNFhwOWMzTmN3TXZ4d2Q1WXVEaXp5cmg3YTJkczc5d2VaMmZndWxvY3o1NThQV1lyeStQZDl4NlB2ZGU3NUorTnJlMnRjWEI4TkY3dTdzWW1VVkJhVnJ1OTBCQWtuL1lmeUtLTnJ5VHY0dUk4NTI0VGVUSHBQL0tVRnVkaUdUeVgxRnZDM2sxcEUvVWkvRkpCV281cGNic2NHUDhzSUFEYTU2cDBTRTUwZnduZFJmUWVmTml5K2EwTGJWQTdYNkM4OVM0WjlkYjh5U1ZleXIwK1hHMTFkWVVkZ1VwOUw4S1RaK3N0MEJiZDdsZmdoQkwrUXdGMWw2bXJEeXV2dU1yV1FFNWRlVHM3UlhlQWVuMUJXeFlQRjhFblZOb1o4UzdCYzRIZExhSDNFS1ZNZTdTZDVXR1ordkltSHVsRWJWc2JhNTlvekRJS1R4RzRHT0NlMUEzbWVmNDZCb1BVWlp3M2NPWUx0eVE4Z2w1aTdLcGVPUE91TkVicjJTaVF1SXJRVlNjRUo5aHVDUE84YnRyeitkS3F4aERYaEUrYzA2RWplU3d1NE93SURmbklwL0JxTkk0aE1Cd3VMNjBDYStPcW1NSnI0eTlpVFRwcTBhbEFWRHhGcWptK3pKVzJEWWlzMEN2OFpiQTJyZzFsbnNucndwbmJkQXJLMkFITE1xOU41dC93UkNPUnJLOHVUSll0VGRmbTVGREg1SHVkUUlPOGFaTkpOeHFnamhsZXB5QUQrRGludlV6aWJzUDNYcmljcWFlTXl1R3h1QXpQcStoTi9QQWtRZHVXMnltVmpWZzc1UURJYXB5Yk5sc09iUXJKbk5kSGJFZGJHZGdQK0R5a1o5MEZIQ2Q2VnA4NDNEbU9iQkNScEVIN0VrODRQRDRaZTNzSDQvandhTnpidVRYdTNkNGNSd1MwMTY5MkEvdm84YnRqZld0clBILzFjaHpSSVM4VCtGRlFnczBDOWlKK2hZa05hQWZjbVM2MEQ1alF5WlJKSGFaTlZaNTF5RnhaeHQ0NEs0OXRGMzNBblFGQi9xOEloc0ZuZ09NdzJNaThLSUxBQUFFUHlUQlFnaXp0QzRBNkxOellsWHpCc3dGUVdtQ252QU5mOFI1OE1qVUowRzN1MmNDZ1htL3NqRGF3QTZGc0FiNWpxZUdGZlA2Sm4yeDBMRHBvaFc5eUFiUzlMRCtIMzB2MElJL3l4aWswY3BGclpkUDJ3SDlPc0NSdlpSbmYwMGZGQVU1dFE0VXN4M2YxUVcxZGZ5SXZsUnVidFZOUVRxdXkweGhrcXlpVjRuMFpIcGxURXM0MGIzRGlOVVY0cnptc0d4d0toZEZkbktlRmdrK2NsdXNrcHZuN0hyMmxVUlIyanEvS0s5cVJCVTBadkd3SXlXckk0dFF4VktLR0tKejFQRG9WYitXazVvWHZhTDBnT3JCNkoyK1dXMmNxRFUvbVZlOVFlckxjUEpPMHZPKzhtN3BGU3hrYmIrdFRYTUo1MzNqRTVYM2pDeDkyQ2pIa29oWFlTVDVsRjI5d0lxNE9UZVhvWkcxdFRYUWxCOW5CTmRFemYxNC8zbXZFMWdVUVkzVUV1SVRqMXFpeXl0RUpiYXZJZ3BiM2Eram95WHFjcENHWE9vQk9yMTR2T0hSaWszSUlLeTF4YThBM3Nxcjdzc25LcXpxbnB5ZVRjNENaa2NvU28ybUpYZUVRanFTZVAzc3libTJ1ak8zMUZleHVoZEhENnZqeTYyL0dLZVVYVkRGWW5hR25sWlhWalBwMDVuQnRjSUlYT0VkSDVCZ292WmFNZXBKUG5Zdzg5YXlEUmlieXZWZFcyOVhrNEtSVDZ5REJEam0xMVN1UmtpeVR5QUpSUUUwNTBxbHlBd0VGMEYxSVFFUXZ3TWVldWw2YXAzZ0dRM2dYbVRpVlF3cVJ4M2F3anYra041ZFBSbVpIQmxuLzJTelNuNEFxV0hrdjNOVGhCT2NrbjRISEpyUVRVd2VPeXV4VVpOM1V0aTNPWlRxNytBRjZUa2NERURuVTF3K2xpYjdKRTQ5SjJLV3QyZW9uOXJ3cHBsQVhiQ0VFc0lLcEszYVo5MTdQTzQ5NWZlKzFoMG00TGpNZ0dqbUNoK3VWYVpnZHhvRzlkcTdVckQvV0ZYNmVuaVhldDVOelNTcWFhV0NWQVAvbTFhRXNIc0paRitPS01lQVUvcE12a3JRYVozb2psT2U1VThzbjdYbjUrcjU1bGJiRzZsbUZkMEN5WEJ3ZXBvYTN2ckFlamJmUERTdTh2SFZLWFc3a1R2emlNSG4rM2V1bTQ3bmtyaUFZb3lJdjVSTmZMV1BURWxkNG52QmZFWlFrYW40Q2VaeDU2bkYxRUhoWVJOY1o0UW1YUEM2aWYybnBqT1RiY3dxTG8yc1g0Vm40NlJxMjZHVkwzdFpMeTlHOEdTQ3ZzQ2RoYlVldzhSK3p0eTV6RjNtNE9qc1pzNnZUY1dkN0l6U2V2M3c5OXQ0Y2psUEtMaGhSTERHU1haMkNwemdXQ1JaT1plU25kU1VCN3cwZzhtM3I1ZDQ4K05YbTVuMUhmVmx1dThnYnhXbmJic3ZXY2RGdzVpRytscjFnbFZXUmdndDhTSUt1b0FNd1VzT0h0SlY1dmhOVnY5V1pXRG1kQ3ZvVmg1MU01RWtOOWFOdWkwWlVCNjdNU05RZkpkSlE3NUpJTzVQbk5GNDh5bE8yVkhJYWxIcGtGWjRNN3ZCdi9mQVBFcy9xd3lSTzRYSWtvL0tzVXpxRGpuWVE2UHBqSFdKY1Zib2tsRjdSbzErUUcwVUJZOFUyak02VGdTYXFzWGYwdXlZK01TRzhoMHg2ZG1xWVBQQ21NNEY0Q3hJQnlmY3NqTW1lMFhJUGFmWjlsNXR2a240ckpSbjhFWS9sd25ydEZDRkJqQ2JnOXBwbkc2ZW1GOVhJWGQ5emVMM211NHozZC9HcW04SmYvRm1uNlZvbWI5NFh6RTB2NGIxbHdyZU9sY0ZrbWZuZWUrM3g5NldHY1RndlJPTnNtdElWUi9Pby9vUnAvc1JwWHNONFRvQ2U2aldlcG0rNU5EMmM4cGp2ZGNwaElOZmdkRmp2YUNsVGYvbUtmZG5XY2tsN1VrL2NHZnBQOWNWeGVYRWFYTUxudjNtWjdsVVBteWtFUEZoWG1WbytzWmJiS1J2ckh3UXc1UUlaUEp5UERmemo4ZjEzeHJzN0syTnpiV1c4UHJ3WXIvWlB4aUZsaXpOR21OajRCZXRlb0RSbTRvejhNUUJkbHYwb1YvZitwUXY0WVdTbWxTcUx3VmRlWnJQVmNTcGQ4eWNkcWpQWGYwRXhacXZGczJXT25NWGx0YWs2VDNYSWxKeTF1TXdRQ0V5TytNZ05yQ004NGVYUjRKRzYwUkhYbkdGU2tTdjRoenY1S0x0UGdJTVgxMkV6cE9Sa0grRm85Znk4N0U1OHl1cUlLRk5zcmgzbFNxK24rSlFTc0txdHJVVUxFZGlWUUZpRFNYVXV5aWF1QkhIbzJsNm10aUd2TGJkZXA2eFg2VFBxSnZ4Ti9GQy85U1Jzd3I4S0tJRWQ4ZGh5bWtFaEZiRkdZb3JDS0d0bmJNWThlOGlReWV0V3dOOWJSbm02S1A2MEVEcnVmRkRxZXZOblladDU4K1hOYzJqU09NNnBOYUNicEVKcWppN1kyYmtQRHlwSUtKUFRSWTBGTERGNk5lVzFlRDBpTDcyVldMejJVSFlOcmxQekx4K1dXNi9UL0gzV0tTZ3dyM251YTNscDNWbFhITkpwR1MzejJxT0RqUHB5d1QxdEFUL05jNS9GSTM2VGVWM2ZjOVB5dXVnQU56bGVwaDFUM2E0WEpGT2UxMDdiN0lEa1d4cmk4UDZhejhDcVI5b0N2VnRtTHhWYWRoS3VrN2cyZUZYTEFPSTAzZkJUUE5vMnByUUt6bVhQSHA2VVN6a21YUzlxdnhDNkpBaVpIRGxjWGFFVEFzakRSdy9INzMzNHdWamNmNEt4Ryt5dXhzYkc2ampFOWs1Z3I1eHFqTU9URStwcC84V0hja25MSkY4R1lEczRIeGJwd0ZoRCtORzV4Q0dNc25yOFZyM1lvd1dWdWl6QlJMeGtaKzBHdWxuWXg0WXpyYVJFR0tmTDZ0bDZpeENUcjBXbXZlckV3TEpNa0pZSEJ4enExN1d1SzNTYlFBTXpoRnYwejlJQ1Y2NlhaVFFJak91NnZYd2hUbWtrU1U5N0lTL3RwVThEN3pNQjQxMk5OamhISkhURU9lMG0zOUJQTUpkWDZvcy9PS2pmTW5pT1BxVUI0MzB0d2l5d3g0ZXB6NzJCMW5KeGVkYU9scmJYWnAvNFJFUmppMUpXcWllSVlvTzBsRXFOVkd6QlBFZDVrMkFLNjMwM2lQZHhqSW41SmhvOENLYWdYdHViYUpMTmVETm8vYzVySVZ2NHBtTjV3OVZsR1k2OVVhWWRaQXJqb1l3R0tJMU9QRjB2T0drSTJNd2YrVys4NmRXWVZ0VFFPVlh5Ujdua1FiNjhGa2ZMMTZQUDFzTjgrVy9SaEtlV1E1aDV1azJwNlhROStiTE9QUCtXbmVPWVRhOTVuejgzYm9PbTF6cUdlRXptZWQzRzVWUm92bTNGTTQrN2FGZEFEd0wrWkRFZnVJeE8wSDE2ZkFNZ1JxZlQyWkZ3aXE1MExsb2tOSzRYaTVYTExuK0NzYTNDczVBRUVSb2t3VWtuMGx4YzJ4TFdKdk9jdU1hTmF4OU9abGhKWlBHWWhYVDFpbTR1VHc3RzVkRWV6b3lUZytzTndlbnc1SlJyY2FBUEF0M1NDdTFNTzVLVjFQcXBOaWk5TFJQTk1sV0VEK0dFajh5cFlRQ3BvS0hPUE5TVjVjTDJ3eFIxbTRDS25od2tPTzFCMkFqVHRGMXNkdHFka1JId05hSVNuN0Q4cDU0NDlFeXpWclEvTHF3bmdNRUw4aWhtYWlldURmYitXNFlmb01PYk92YVF0K2liU3JFSHorQlhkdmxOc0tadWVRMytJV3BnckNNOThacjhLNnpFV3dmcXNXSDdXa2l5MDBIb0w5ZDJMai9JVnB5R0NsTncyNldXTzhDc3pwZlNhOHRZaG9CWVJCRXRwbHdEYUlPVXNIRllSaVhTcVJndmVKbXlVYTFqdm9mMVRJRlRVUCtSTCtNbEdOeDN1Ym5BaUtmcld5YWZuU2Z0cWoveENQcExldFFvRHdQQUJFV2RSalJ3MlJPWkVRTUNUNC9DdkJlUFV3K0lncDhHOThuRnhLOTBFOVYxZEc5SXYwdmJ2QTZPWHB1c0w5NlNiVkw4aExQNTlxdzhEZC9YM2pmTWRVTUc2Z2J2dk81YlZ3WUo4NzF2dWF4bXU1bzBETXY2WG5yenNraXpBMFhqc1o3NTFwdS9UajB5cm8zTndyUVg1MGt1MTB3ZGlhaTNUT2ZTM0dTaWM5T1YydzM0cHhYNWFEMXRLN1N4Q0J1MHpTejNXcDR0YjltYWQ4K2Q3SzJYNktMWDFwYkdHbE85ODdNamg5VGpjTzk0ZkhWMFBHWnZNeHE5dFRFdUNGUUhlMjlZL3JnYU01NU9uVElGRTh2aXBVK1RaVSs3ZzZmSnhwU3hlSE1VcWQxaXN3SmdUNkZ2NEpGUDdDNEJEeVN1cTVua056NEZyRUZFT2NSbnAzbVo3UmZWVnVxemsvcDJwS2hPcENIdUpZSzJ0SUtQckF0czNXQm1lV1pIYU5GeTY0bExPUXhXWGhnUVkwOWNLMVBDWjVSZVBtV1puVlZ3VXkwQnk3QVBmZi9aZ2daRWt5aVYwYVROMnpXa2pVTnF3cSt0d0VzNklPQ1UyYU40QndaNnhtZ2JYdDZoWG5xWFAvRDQ1TkNwcFl2M3A4Z3BIdHNrdWpNb2k2Q1ZVV2VRcVdoeFVnWU9FQlloWVhXRzVJdWRKQ09kb2l5WU5WaDU3V0ZwbUJTbnNNRlpkVEpWVU9pcHJNL0NkMzNwWloxbVVyektsYytHU1JuM01CVTgxdXNVK3VCdXZwRUV2T0t1bnJCeGlBOUorS2RCMWxFNHZMYVg4YTc0N0RwTnArcVdIc3pyK3NWelBUVkU2R3Q1dXA1d3JidXVJNVg1Zk85TjgzcXBuTXFUOWpWTkNocTNqV3RLVzlrR3FOczh4V3pkTloydUwyejRnUzloR3JkNVhwdWEzK0tuYklQQ0dLajZkKzJxeXB5MjNOaE05ci9wMERpclFkSDlRa2d2UXFvWFhQTnVmWjFSL293azNrdGYvandyaDJYTnQ2MldGamZvNGJDUEh6OFk3ejkraDMxWFg2VTlEOW5hY0hwME9yWTIxc2ZhNnRwNHMwK3dPcm9ZangvZUdUdjMzaHFmZmZsazdCMGU0b3dRWTlwNktYMWtpVmZCWXROTXNDSWcxdFlFcUFLaXc1VU5sODFNR29tTlo2bmh1bzNsdDBaWnlpUC9PcUVqSFZQTHJuNHNUK0tjVHQ5cEZaSVlhTTdQa0pFUlIwTEcxTEZHVHhOT3IxZkFvV2VlVWM4TGVVSmptUTVXSUkzbVZUMmp1TGFMYVpDaHhoWXJVQ29iclVpd3JGRVpnb29PM3FlUkg3UmNHbkFhelNYNnFEWnhlcjZ3V0h2bTJxYVVUejE2ZUIwWmdWZEhOVWlxb0NZaXBYZWs2clRXbTNyNHdhQkRlVWdKV0xuaVQzU2w4Q0J0dzJpRGlXSW13TTR6MnBZUS9vMSt3b3lNQ2U4aEE4SjdlRyt3cTFFYmFvOWhwbXIrZEwzTzhiNXBwUzU4R1d6TTc3S2FreVBZUkM4MG14YndiZWhrVFhYa3RZei9XZ2s2a3IwaVJhM2s1c1Y1dFkya1k1bkUzN1NiVmdyK25qOXRpTUtmWTJDZGxNblVQVnZuTjc3VzEzeSsxNWJiaWwzL1dqZVRFY2k3TUkzSE9pMlAxNUV4TGViZGI1Y0paMk81ZmdKZ3lsMGp1MTRuc2kzQVhRWlh1alJJbVhUYVNJUmNHWkhnakdBS3JBRktPOG1lR25EbytLNmZWR2Q0bzlONW1WdS84dFQ4ZDE3YnBYVERNNVJ0ZXdmVk90Vnc4Zjc4ZU54aW5jb24wRnNzWEorZW5JOTF4QUxiV0dkeC9OdnYzUjdiOSs2TjFZMU4xbVhlSHQ4OGZ6MTI5MzFxYU9nclBXZ00wa3dDZmZqanZyWnhzQlNBdlNpYkVsUndNcGhoOTk0TDU3UU9mRGExaHdHcTRjUVpXTmZ5R0xGSnB6cVVtNDdZTnFRR1R5OXJ1bWJ3UW0ySm8xbnlBSWRUYmNlcDRnQTRlSzd6eURMYkVaQmVhcDA4SlFUSjFSVDA1V2VWN1FkQXBXMGRYV1gwT1BHNzRzd2liVzZid1NmSE9WRXVVL3dJNmgvbDA4KzFTMjRtUHdsT2JvWFFKdG9tMjJhckhSM1FxS3VpQTVNSmd0cVRzZ3Q3T1hWbzBUKzRHQ1d2ZjJMbGFoQ0VjNzRJVUk5a3lpaUFKQWtqWWFPZTV4aFRGVVFZeXhXcVUwZFdKYkdPUnRwNVlNcTk2MG9KWEFqdE1OU0dGRVdtSjRvYm5VeTlIa0xVa0wyTXlZYXVoY25hYXlWZGxTTmY1VmpsUU1VM3FEQWc2NXRzclBBTER0aWE4b3IzN1AvaHNvYmRWWGdEV3dGQitkdUp2UGFRcHNsOHJ6c2dwdkVRcXVzRWlEK3RXK0V0TTNXZTlFcUdaRWNuNnFVUFpiSGRFb1RJajh6aUFKZEpwd2xlS2xSN29idkpBT2Y1YVQyRnZ1TER0eWV4MkhISmg4NWl1eVpmWG0wVWJ1eUZDMVplSGNySHpJQkZmdjZwWTVQd2FrWSs1RGQ2MEVnbjQ1WkdwOWF6OS9LbW5OMUoxZWk0NmhlSDZwUjdIRDhiSzhHM3U3L1BjVEFXQ1ZSSFJ5ZGozK2tmVCtxMmxxOXdma1llYkc5WW1hMk1JOWF4OVA1elJsYXYzdXlQZ3hPZW9xSWZrenkwakxMbXRmKzBOZS9WaERBNnQyc3NKbldkQURhSklsK1ZxQ21QeUNJbTRjandNbjVtVU9HeWdvQUJELzFFMStDdkxUOU9pYXZERkxWVnBhK09yU2srYmJycmhGT0ExRjNhcmJoRm1mQUlUdjBqU0tqdGs3bkFBNXNPMmQ1WmZxTHo4aFdiS1BlSkVXcWRER1duUU5yeXBGOHpjYzVVTGs4S3ViZTg2SlRjd3RGSTBKTlc4YnNDZldWUk56Mk5sbWVUb3plNmhXc2ZsRC9MNEw2U0JwLzVvZ3VhRkNod1JjRkplQTBNUmpxNFdUa05LM01URHM4eGZQTFNnM0tlVCtKc1ptTzBWRkNKeVpPbTZyTnhxZWU1bEZoeWE2eUFST0U5TWhGZjlzVFFlSEhHMUMrYVVhYUs1UWd0Qks3cmNnVHJtcis2T290RCtQU3Q0SlRkTnJHZXpuS1pwM0dlbFYyOHduV3Y0VFdnTWFxV3RmSU1yaldTTTk4OFUvTWpQbkY1N256aExUZXY0VDBYUHV0V0VHcjR4a0VKa2xjamQwY2picFB0WkZ0b0docDJQWGlveFdEWGlhUm52aVBBakpTNGR6b0wwZFN6UEs0eDhTRWhBM25qejVxR2dZdnBsTTZiUFZyb0duQkEwNkxodzR6ZzBrbW1VVVdjaGRLV1E1MnE0dzcwczluTVVyWUduTEhPV3Vzekd2YXkvS0cyTTlhQlROWmJCZmJrOUhnY3djZFhyNC9IL3ZHTHNleDBpbnByZEliYnM3dGpIZjIrM2owZUw5OGNqZVBUcTNIdi90STRQTHNhcjNiM3g5WFVWdW5kYyswbzBIYVliRGI4aDV5a3lkZDJWbFB1MWdWMTVoTzdGYVpJYmhVd2VOa3UzVEZtTmtLZFBBbkhYbVlyczB6VkFMZ0pVb0hYSjlCNG5Nay90S0ZCaHBSMVBXd2pJeHg1Sk51MUh2UDFJMjFBM3J4MmF0aWRXT3lKZktleENRaXg0ZWFSZk1qWWJndStjOE4vL2E1Q0NmblFrd3QxN0NFUmQvdjdEK25TZG5sd0VPb2lzbFhsd25pQi9ncGxuY1VOTWUwdG8xQmdKYTU5cWEyMmVXMUxXOG0wbEllQTh1elRSenM4MnJRTUlVN0IzcE5UalppZVJpRTFubmE2SUpBWkRoRzJ3YzduZTIyeXJveFkxMlFkY2JYRFI0RXlDK01aelNDNFpSR1RQRk1hUUhrNCtFL1NlSnpIMTJKcytKVWNTams5cTNjZGhSS1BpbTFlVHVoSnZaWVg2M1F5VHhuc3ZkV0JaZFpydVMwVGw2bHhDV08rOThKcXFGM1crRHlMUXpqaFcxYXZOZDdPTTErNnJaUEdZN2w1clhjYjNXVEFkdmV6NVI3TmgvVzREUjNobW1jZDZQajR1UEFFUm1jNUpTajV2aUtCRWFOY3dlSU5ZQmtac0dhZzhkdWJ0MXppRG43T25ZVFhDRzBmRGR2eTYxZTdBRExQY3J3ZHhaWHVsS1gxSUx3cG96NWF0a1pkTmNKdnVSdStaRkdIanViRnJlNHhHMnpFbmVuMXhKY0FnUzZQR0NHZHNjYlRiYmkzVHhCeCtrSVRudU5uaHpDMXNiUXhYcC9zamlkNzdJRG5FZUdiczVkd0FHL0FMQk5zZGZtc3FVREhORzh6dm82VFVSTHQ0V3BPcGsvd291N3oxSkt6MWFvdHF2MlVOYmJBV1ZtNjNhZ09mWjVlcWgrVlJFTHQ2VENFZDRwRnhkcWVnT0RsQzFXL3B0YTJPZjdFNU9ROGk5WVFEcy93RHk3YjlwS2dtVTdZZXdtUWVoZStldlFCaytVOTZzWUxBaGgrVTE0alJqUU9iT2xEK0xRZjhuajJhRHUwdmRVUG5NTXYrRzF6Ymd4dXFROFQ1RmFRMXFSUjFCa0NGQy9sVTAxSG4xUlgxbkJ0MGZieFZTVnRnRkU4ZTA4d2JobUZFcjJraEFTdXFOcU1pYUNVMmVLWGsxaS9ZYndPakhuVXQvRzdrWVRSbUJwR3VNeWxRNmtjelJlbTFScWdaWGc2SzZ3VVJaVU14OXo3MUtRY0dNUHhDY3JGRFErUkF5ek5yNGFpZk5MMzJyT0dhR3BlV2diejVIRStDVzlxL3J2M2w0NzQ3R1ZOaUJxWXhtVzVoL1hNODVqVUd2aitJeS9OajdDL1pkZ0FnU0twNFpSTEhwb2ZDMHNYWlVDTmF6N29XRWRqMHZCOU5ML2lacVBVazIrTVd6TktnTG5SWStNUnp2cE5QOEVkaDlMNGxLOHNSYnZ4SUpjTVdYYTBEcFBoMC9vbHYwRzM5QWxIc2JYRnFYM0VGZHpBZXQxNmFOb2RpQ2lhYktyYTBjNUtiaVM4ektqRmFab3l5VVJOZWM3R3lzYmEyTHA3YnpBTUcvY2ZmekQyTHI4WnoxN3M0Z2c4ME1GeFp6UDJWN0ViM2dYazJUb2pIM2c2dzB2azFhTjFrVGdDZmoxb2RmS1o4T2U2RVBwekZHaG5rQUFMTHVtaldlclh5Rkc4MGNNa256dnNvdzl0V3Izd3Z3UGh3aFdkcnNwSHRPZ1p1Z2FyOEVLd2N2UzNCTy9ObjJkNXlidWduTFY1VS9JWW5jQlc4THNGcGpvYThSb1lhRVBvU3o3K05iV29mQ1lobC9TOXR3M0VCM2h3aFhjdXpaTlgyN3ltcWhhSGV5N0twb1FCRVh3b2x6NUJaMFZuSVY3eGk4dHJ6MzN0bmxEbDBTNHNrM0xXc01LRVJBSFcySHpDb0hKVlRnaE5USGx0eFVic2ZlcEFzSEZJbkp0SjdGSTIxWk1heGpxbU1JYVFFWTZzbWEvcEtBQkt6RUlpTUpuU3lCU3A2OVUyQkdud0Q0WEtxMlVlYlZ6Tm03eWExM1hGWTE0YlFTdkwvSG4rR3I3eVZLajBxeEhOYTkwMFBXcUxJa0dCNHBMQlNsd0hGOWZXaTI0OGs5UkNkTW1WbzV3TWZhZkc2eUNyNzBtOGVXdmEzUWJpTVJYcWFvL1dSK05vR2NWdnNIZUVvbzRkR1ZWN09aTFU2TXBnNUV3Y2xrbkhOSytQTnNyMHFCRDJYcHhPZSt5azdQQXlhYUMrT0pxK09LN2xzTjBvNi92R1g2UFFxdFB0NWxxTzVVNExESkZPMjZKWWVWWkJxaG1hYm94Y2hZY1p2R0M1MkJQODROdzdPK3Zqdi9yUC8yeHNiSzZPSjd5V001Ylh4dDcrTVRoV01qcTZBTWFtZGU5UlJ2RUdxK0F0bTFKKzA4MW9mK3BnSlUxRk93TCtKNmt1Y2hKY2ZMaFF2SlZQS0VOR29PSktuZEpIcnFlOEJLeENGWmt5blc4YXRwRDQ1UTE1bzIvYkNuNHpTdWJhTms3Z0FhU0RWOU4xZEsxY0JoNzU5YWhOdHJiemphemRYckxoQ0N4bjlIcGpjL2lkYld6YmNvN3VBUUpkTlF1SXk4SkxUdlZUci9NVWYxUUNFSjJrd3RSMjFna3UxODdLWDVXcEIwOFp0Y203TkV3SzVmcUFFeTVUTzJJejMvY2FjaHR4RVpEaGl0TG1YOE1oaktsSExOYUxZTkFwQlpZalVKdElhKy9QUFdWb0lVR28xZzhvSmRzZXE2Sy9oc0s2QkU1bkVrL1JidldVOE0yejVkTE51c0hFVy9NZ2pQeDZQdzl2blU2V0c5MUxzK1R6M3daY25neHhtUjViYUh0NTVSYldJdkZsTFlUNndjZTlVeTJ2blQ1Y3NDYmpkZlFZMXBIWjhyejdWdFRQbWVKb1JEcW8vNXFYcmljTlU5OGpSbUE2UDdncGx5Zno4cTRjbWw1Z3k3STZBV1hxMXA2ZmFUcHNSK0VVYVE1M2lQQkhQWlV1b0tOQmtWZWRDWG9rUUdTRUVWM1JSdFMzVlp1SEN2UklBVTN4MkdieWJmSnNYZjlWWHNHbHJqclNybE1ST3NLRFEzdjNuTFViZENTc2JnVWJETFRPeGt6bkkyTzJ1c0RUd0x2a1g0dzNyNzhlKzI5ZWo0UGRiNmkvTWJZM1pyeFBlTXcrTEFNZ20welJQWU5FYktXWEZ4ajVZbWR0SDlMd015c3dTMXRyZDE1cVE3U1JBUU83WEZsWlM3NCtidWNiUGJoVmdyWTFHRHAxRlRaeUlwdm5raG0rd2EzZTRRWko3RHdxZVk3ODBJbW5nTThBWURlZjlVTE8xempnc1pMTVVXKzZpN0s0czkyNlRUeEx6N2F4azVGeDhYYUFNRmpJVTNiMmd5ZThLVFRKdndZK2JiNXcvRFl2dG05WUFhMjJCb2NKNE1KbU1BS0d0RGtNdG43dDhMeVduOGFwcmhLd1VXam9NYTNQdGdZRlZvQ2NxU2lRbFV6bWR4QXkrRlRncURKVlVwRzVHQzhjcVpaOHkrZVY2WFVackVaWndpdDlqRklqbzJxWU5RKzZFWUJ6SWpUS29UVEtsUWNOUEVFdU5JcDM2emIrRHBSeTQvVTF2WW1HK2ZLamJGMVdjSVhEWm9sankyQmdkV2I0dHc1RDhWWnFpVkdtMGJqa3ZYUlI4cmNPREZvR3ZBc2N5THdiZlZWQXN0SE9XVnNwdnBRZkxsaTNjclFwai9ONDVhbGxWYy9kWHViSlIvRmVNTjR2b29QTDZlc1l5cVpVNmFFWC9HTEQ5SDRvZEM1WngweW5ZQjNrTURWdGNScjhaV3llRjhzMUxtV0xEcXlUbWlXTHNNSlVVdTdDblpHUzJSaTRGYklwRTFYYTNocW81WDd5aHhwNVQwOUhjRHFiZHRJKytiOU11Wldod05JQWdaaUFzekZiSDZ0cmkyTmpmWlZ2WHEyTlRhYUV6NTkreGVkbVhvMzd0N2ZITTlhd1ZqQzZEUjdwKys3aGlSc3hpWUFHUW5HcmY2ZHl6WFBMS28rL2xZQnJHS2Q5OGsxRzZqdExzVXovSUpSR041WVpraHBmcWFTYzFPRHZLMHRSQkRBR1pITEFoWHhjVndjd2RSUkU0OW92TmZFSUNlblRmQW1Td3B1eXUxMGVRZWJvdElLcndhVGExYlpTMW5vSEVGclNMS1lLQVgrVlNYamhycE9YYy9uSzZmcVkvSHBrWFlCejIyVFg4MzQxZkJvL21MYnkyTmE4Yyt4U0dqWDRxTTVkVzNMUG1VSzVwcmNJbkVzT1MydExpNStJMElyS0tmRnNPcHV1WmRTOFJNcUpTWHRhODdyTStsN2JXOWNqV0lqYitsUCs3OEttZ0Q5aEVxcVdxeGlEZ1hUaVlFUmFDb1FxK2taYkRtSG5GUkcreWV2ODRrT0YxT2pDczNtbWh1MEdrRTdMZFZPdmNJblB3MlJaUmdtY3crY2tXOE9vYUhHWDBtLzRxM29sazNUQVZBN1BsYkRXYWQ2YWYrRWNwcXZqM3JzbGpPVnRZQzJIK1kzWDh6eS84OWZXb3pCdFlpQklmSWkvMzhnbmI2YyswTUJweE44ak0rVnYzTVVUbzBqeURDYk5zL0Q5V0ZwNFJ4NTJlczJEZWZPNmdPM1FjQVJpRXE3WE83MVhOeHBzMjFESkdFaWhBMi9kR2gxb20wVnpnZEhWN2EzWnVMc3pHN2UzMXdsY1N3U3FwK003SDMxbi9QQlAvbWpzN3UyeHJZSHREc2VYNDlrM0w4Y1orN1BRQmd2RElMRER4T2JTaGxCeE91WElzWFh2MllpV2tFT0FVd2ZHSW9PdlpZWUFIVjdkbXR5eG5kR0Vka3l0NUZFWW5VMUFyV2M3S2tkUjNnTVF1ZFduT3BhT3BPMUV3b1AzMGpIMGVWWjNBQWpuaTlQeVgzQ1RmMG9ZT09zRURuNjBBVk5zRUY3a2s5SnJmUWRuTUJhTzZHU2kwN1lRQlB3UjFqejlRcXp0Qzg2YXpJQnM2WUZ6MFljTytlbzJVMWxIbjlxa3dwQmFudkNXVGxBazhrRTU1M3hlcGdxcENKSjhYUkRpOWpUbVN5U0tCRm5EbWFjVHRNTTNFVGtVeG56SkMyZXlmQjVINTFXOWdyTmNZYk5OSWNhakFRR0pnaldlbEpFaHpxWUI1dUJPTUFIMEpyOW9lcThjbmJ6dit0STJlVzRZZVpqbnVXRzdmc3FvWnROWXJ3L3h5a3ZUTTcvcm10ZDQ1ZE15OVROZlI5aVN2M0JZN24yTlhzSE4vM1plWWVkeE55M3owbWFjbTRabmdISCtvcHZlY3VLaFpRSTR2Yks4SmVoTTlTMFhaNHlSK3NYdnBHUHlpNy9TWjlaTjRObm1rcWIvR2o0akI5clQrNVpML1ZsLzZpSXBLMXNLVDlUUHRHUTYrMkRHSk84aG9DUFVoYUtGMW1BVUFqZ2QrK240em9mdmpqLzh3Y2ZqL1BSQXBmSDA4RFNqTTVYNG1pbmdrK2R2eG5PT3ZiM0RCT2NhTFU4akJPeGYzTkpYYm9Qb3RSeklCekZvSmxSdzBlMUlXK24wNFZNTlVJUzhQbkZWVG5tVVhhOHoycUtlRGp0QkJqWTBKbmx0UXhmMDFiMUN4U2M1dTVYRGZXNHVqMlQ2Q3EvV0U4eHoybHc5TWdMdHFWL3pmbjJtamNXWGJTRXlpankybGZKS3owNGlkR1daKytaQjBLSlZlZTF2MHV4OEh4b290dzlkOGcwczVJeTgxQlcvRDN0aUN6SWNQWElpdjBaU3ZmUWlwUm90eW1ma2w2L1lWdGsxMitsSXdTSFRDbE9QNnpQMHQyaGlYTWJBSDBPemlxT3BGczU3cjRXeG9kTTd5NlJQQk15YjFqWml6Q0loZWQwOWtNYll4aXdSUnhaTjF5bVJjT2dpRG1tOUdCUDNKdXRWSG5BNGdiMlZaejluS3oveTR0bkRmRlB6WVY3VnIzeEhOaWJ4bTJKazZDVDZrVi80OG5vbFh5WXRPZVJUdko2dDF6ZzdyK1VvdUhia2txRjdJMm5Kazd5WVNyNHlnQmlITXRQYkdMakUzelFqejlSMnBRUDM0N0I3T2VzbnhZdU9GR2VubmpEV3Y2YUI1NlFuUkNoVms4ZmUwK2d4UVB5eFRpZXZwWm16K1Z5THo1M21PZXZNNk51cGlGNHBYR3J6eDdVUUJKdWNnN2FJVWxGbitKRStzQUxuTUpoNVBRVUY5S0pPeEtjKzZoQytSaGxzYmVlYWFSMlZYYWM2UDdrM2pnNlB4MU8rTG5yS1BxdFBmL1hsK1BxcnIwR29NL09SdmdYWEh0RTF3WUdhQ1NCZ2hUK3U4YmlNZUFnUThxUDk2RlRlcUhlMGhLeWV5Mll5WGVHdTM3UlEvK0xLSjdYQmwvb0dGM3doOWc0ZVA1ME10dUF6V0dlTml6ejNUaGxrL2F3endHQ2x2WlVYZXBkczJYRFh0NVRseTlRK0kxL2RybzV1VGRhTEtpZStZMGNXMk9iWWNmdkZKTkgxdFBBY3Z5NDlXMElDZDlxY1MvV1N0YTNKbHFJbnlnM2VzVVVJK3RUZVRpQmYwTEJOcWFmc1huaGR2b3owNEZBYUlZb1NOZ1F1YmRBQUp3L2lOOGdsQmQ0V2hKaVZCWFNPMkFaWkZUb1lsUEdiNTJHRGNZckM3Ukhhd1N5enZvb0ViVktpS2pDV1pSR1M4elVlQlNGcDVFWjk2N25vYVFOazFBT3ZQaXJXUHN5em5razRoZWw3VlZIS2E1Nm1IaXJRbEU1OGlhUHhlRFpsWVErZXBkZjRmcXZ4cFJteXBkQ3FYNk9mY2pLRDFVMHd0ZTQ4UGE4OW9oT1VvcFBCWmM1TnAvaVluSDl5VE1zME91dFpmeWJ2S01MUlpzdVJyMUZpZ1A1YlpORllPSG5WaWRTN2JXRnZheGljMzY0aVBmRVcvWHBVcmdFM3IrYkhBQ2M0NGIxdnVrN2RKek9LM1dRRURFeDBTbDJRWnpTUWFSdjNhbHFIOWo1VEtIblMrZElHbGxZQTkvYlNOYnNKbCtKa0o3a1p3TWhYWk9UT0h0aTlPVG9mNlBJT29GdUpOdmptMVJaclZ4dnJhMlAveXhmajVPUmkvT04vOFB2c1Nkc2J2L25ORi9DOU5PNitkVHNiUjUrL1lVYzg3VzVIdGNwNlNuRExMNGNMNUdsMmVkSGVjYjRFTHNRTEh5NVBBS1A5R0lEY1dXOHdVRE02M3NXbG0xcHBON2E5Uk0vV2M1ckhkZ1hMQVUxU085RzdkTXl4QU1HbGJiMXNNSVdHajhNcVVFTmhHZ25waDI2clVZL2lTSWNKbHVpVlBCRzYvdW05dU9yaGxWVHFuVU45SnZZa0xZQ1JLTEQ2UXR0ZEFsc0NUZ3pyT2xiNGdjYm9RVjV0cUxTblo5cEpVREJlY21GWmdqcjBFNXlWWmJLbEFPSU82bnVWZ1ZMWkErWUR2K2FwWDdsTkxPRkNXMTYySWM3eWtiRkNyanZKaUF5TE9NeVExMEdKeStTWmIvazhqR1hXSzJmd3JnemRFUll5UUxtaXRaY21HMXRhSlVqdHZWR3BCazZacjNXSzJua3RQWGt3bFRJbjNPUVZqaHZuRGhCL3JDTnNKKzg5dWdGdERNaE0rS29zTVBZTXdObXdQVXkyVHVVVnRwYmRPNjkvcS9ISUU5NzhwbVZkN3l2ZFhNL3pibG5KZHNPamVkYUw3TFhUTURpREg2TlJYNjVObXFTaDRaVmhsZzdOYTlyZGh0WnR2VFJ1eng3TnQ3QjlMMjc1dE15a0lha2Q4MHpkQzg2WDV6dE9HaWQ0WEJCV2wvMjBqK3JGa3dZOTZUckdDWHJYYWlCRXdLdlJ4aVdqRGVXeHZnWmJVMlB2YVZmZzVjRDNFeS9ZS0xuRy9ReG5Qams0SENzRXN3ZjMzeG9IdkNQNDRhTUh2Qzk0T3A3eFFtR3RDOWJhVUhBU3JPZ1hXTGZWWGNuUnhwVExRL3k1RG5tQ0xvd1RkUERzbE5YREVPakhlZWtBcGdDYTc1b2p1Nm4xV1hxd2RXaDc0U0dxZnE4bUhkcEc2dHhnSnMxdXQ1TVR0MS9JV2VFU1h3MFl0QW1EVVkwQ0F4QWc5V0g3UUFrUjBsYXh2WG9yd0hZUFQ4cENYWDNRcDU1dXhBMHlFRXE3WmxqYW9UeFRGSjRzYzhPcW8xM29MMUFIMW9xbmlVdHNsRmFOVG5zS1c1MjBPSGtkeWpKb1hDWXcwOUVUNkdBeTdHc2ZTcG9SbHJIQkc2ZlcwSFoyNDYwUDBndFlSWENkWUFHQVNFMHlyd0pWcm1mek5TcnpUUmtKY2JiOG1obXU0MGdveC96MHJOTjFONFo0N01WTXN0bWpDWTMvS2dHTEFBUk1OMXlmTXp5bW51dzFQODFyY01sWFJqTE5rL2dsVWtIQ3ZVbnliSU9vU0ozSlJveXhUUElaeUd4MGVXa2FUZDl6eTJBOXI0WHZaTG44S0hlZmhmUGVROXJtQzJleXpOU3c0dk9RSC9FMnZlQ1FYK3BYRHc1KzFPZStJeDFBZnNYdmlNRTZPb2phVFpCUVdSTTljVGQ5ZVpHT1IrcFF2M2tSVHByTm4vbkNlRFJNODZ3SjVSRzdjbHZPNGZZTjlhc2RJRW1OOU1BWEhEcHpXQkpYZFlwU3hqVGhyZlNSUUViZEdlMmo0NW5reVJHWWRZMVV5bTJpUlZLMnZiN0pWMFdaN2lISEdpT1AyY3JwT0JwbjQ2Yy8vcXV4c3M2WFJ4L2ZHM3lZWVR4Ny9vSzFyZUxKQjB4OFdRWTlhaGZ1b0ljZjVQQUpLdHdILzNWZ1lycWtNZWxBbVJiQ1IveU5QQjFmMmRTSkk3WkZ2bGhnZTVqa3MzWG4yWHliUkhtOFY4ZldNL24zK3BvOGZWSWRTdFBwbVA2cVhqT0tSamRGUTcxVlBmR0pWOGIwdTJnNDlJQWhUNzVyc2J1Q2pzR3E2S3JYMHFOY2lLZmFsellQSG5rVkxYWWhmamdUQmxCb2xLM0xtLy9NcWZyYW1od29zejR1Q2V0SnkydU95S2orMUpVREJFZDlwWGs3S0p0Ym1zSXFWM2E2bDRJcXdrY1pBRVpvMlFLb0ZjOXRycHVaTkpwa1pEeHBFaUlNMTZqTWJIRW9odWRyZk5UcCt1SXZuSWlMQU40dkdMMmo0SEplSGNHR3RUN29BK05sd1ZJditSVHdYN3pWeTVWaDJOdXJpQTRXZWNTcjRqSHFHbVhSa05LRlJnZXVHTkdrL3VZcHRDYzU1TmY3S0h3Nk55K2RyK3dtY2JXT0dyLzVwZmNiL1ZuZnVzSjZYVEE1UlNiMlE2U25xUkx5Q2V4WjJ5SkQrYVNqak5FbE9EeDdoRDdnWFUvYzVobTBtMmZ2bTc0VXZXNCtHay80UlUvbkdKeVB3bldIVE9GTDdmQmdnSU4vWU1oQ1B2VURMYzZ3UVo0NDRjSkNIY1Z5L3dFVFkrYmU4Nks5THpnTVNqWEs1cFovUGhBU3Q5Z05DUFV3QnZuNCtCNFBDTWNPVHdZLy9zNjN4emI3cno3L0QzODczdkRPb0ozWDNidWI0OE52UCtMWGNjN0gwMmVIWTNmM2hIWStnUmRrZ0l4clIra0l4UXYvT2xlL1o1bnBvTXpMTW1VS2NqTTFnemIxTHhaNHhjV1JBUHdsQVY2ZGdCMjZ0Z1ViQkplMmR4WGd0VTJzbmp1cForVlcvRlNLcEJWZ2dwbjgwbC9aYStxUkp5Ny9kZnRwUTllNm9WMU42bDRiOTFaZjhWVWs2UmtVWEkvT0ZnTGcxSzNRdHJYdG1VNUJBV3dNa3JzQTlCT0tNOXF0SUNoUzZ4a1FhVlBLODVYVDJKQkxHUEpJYVRvak9sSnNvR3hDQ3lwOWFwMEo3TlRSbHBVSmJ3OE5aWlpYZFpvcG9jcUpNc0hzVTdvWU9BQUNxWVJXYXQ5SExNcGtvQnBKT0tjUUJCbFM5VEM1cEx3VVkxMUZLbncxbEpUZExNd3IwWlJVcG05eGh5WjFPcEJFN1JpU0R1cFFNdzRqUGZMUVU5bzM3MEF5WkVWYzhvV3JRSkU1dE03QWZWT1NMeU8zSDBNVGh5TVg2L1FJSllvTXY5VjRzcGRHbkF4QTVjbWpEWlJHbXBPaDlXUjU2N0xyZXphWmJ4Sm5KK0d0Mi9oYWR3VmoyekQ4OTV0SUdpajF4QUIwMlJMMzFqVUlhWVNXUllmQ2tLOWgzVkFxaWszUE82K1Z5U1J1N3oyYXorQ2dyR0tKZ2FqYXlMTXdYVGVOQWFVc1FzTmRSdjdRVnAvOXZTd1prUnNOMGkwRitJQ0NBTXNmMjVpVCs2K1UwN0VyUGsvNzFMM3JuUlRrWHA1T0NUeU9nQXhBZTY4dnhzOS84cmU4NUh4RlVPS3JEUWNuNDkxSGIvRko1QmxiR3o0WXYvejBjN1l5dkloK0VRRDVWRjNoVXJjUWg0M3E1UHdNY2JlRHpKa3ZmNURNbmlCNVVEK2d5ZE5HNGljOG0zZWo5NVVWYlVOaHBlRm95QkdhT053Mm9zK2hBY3JFcnM3N2tHNG5hVVJieXR4QlJ0amdNZURvMU1LRXpCUjR4R2RIVloxMEhtS2gxOFFVUVlFM0tOU2FOUUZGKzZjTkRkNlJGWDBtTUhxUEllV252OElsYlFHYzNLa0g5UkZiMUxiZ3lmWUFiTktMY3Q2TU9zWE1Sck9jWWxPQmhTZU5RZm41YXhDTDdPREMrcGg2WXN1cytUbE50K05TaDhzMTNLWkhRWkJFUzRRMHpmZSszc3ZRdkNMTmswRU5OWXh5MytYMlVHRkN3bHpuSjV3VUtMeUJCeHJXcTZFZUNwK2ZVcWw4NFV6V2g0WTRxakhCU3ZrWjk4WVg2Wmxmb09DbnJIbHFmcjJ2UmdlSzY2eURjSlkvQTZ3NFBJVEpOSVJHNkNtZVQ5dFVycmpNazJldnhlbDlqOWlrTHc3elBEZE56MTFYUEgzZk9LeG5rdlkxajVVVlBIVUpEaWJ6ZmxGVkdORFRjSlBjM0d1NExxajdtbzBHcVNFeURLTk9oVFByNUowMjFnRDh4Uk9mbnVaamRFenIvV1J3d0RFc25UNnZQR0ZUNnFoZldyWE5vdUVFSFcvc2VYVXlFdGQyS05yTjBqUnZLeDZyM1RJbFVUYm81Rk1pMW90T2RGRnNKMnNoOEE4eWRXOW5WU00yOEVMMWxBWHpKVjZDbTYzeGF6ZTJGL3luVXpISXNZWEJldnkyQS9vSU16eEpPeGtuaDN0ajV6WS9vRXJkVTM3UWM1WHZYNTJmbjR6LysvLzhOK05xZVVaN2NqaGxBNk84a3dGZVRzckJ2NldzRTA1eXBRSEtibXVrQndSRSsybXlveXJWck9qYXRPMHZpd1lpNWEwQWh1UHg0Q2cvR3F2c3lHR1ExOUg1SDkySm13THkrYU5ta0MrcGxFejdDbWMrcFJ6U3NxNDY3R0RsdFVuOTVob0EyMFdialowYmhDQVNmd1JHdjNJa0sybjU5bXNYYnVDV2o1SURmUG8ydlVuNFJXNHB5S0Z5T1lQUkR0TW1Na1dhVHBFTnFPakt2TTUzWTNCaWdTRW1QaTIrQ0VJZE1ybE1BS2VDdWsyd0ZBL2dGM1RFNm1DNTJrZXN3Rk5KUWFUUWdlaDZpaEZsQXNPNUhhK2RzeDNaOWFFYnh3TVB5UWErZ0ZGeEc3VVZjSm5lSzQwVHJhdkdrQSs4eXNyWEg2SGpHK2Rpc2R4a0hXbEt6OTJ4N25wdWZxVGJmTFhUTkgvVzdjQWpmUE1ydkREaFpjSXZmOHBobXRkQjR4S1ArZk9wK0hHakowR0E4aGpOSE83aXA1MjE2RGV2NHUzVVBGN3IwTFpBK09aWFI5SGc3SWswUm5tVjkzUTB2Z2hiS2s4YmFGNFVHUTNUbmpGczhXRm9lZWs4dUNmTjZpK3dzY3dmSDUxTFU3NDhtclk4aGg0R2s2OXlRdHRGMFV6L3dDVnBzY21QRHVzdnlOUTZsaU4ybmFYYXg2ZVpBb3ZYbjloeWlpR1BCcXg4TXgwZFZvY204cEwxNG95Rlp6b1g1Vm5raDBSVytaNlZhRnpneUc4SjhsbGtGcC9HVytqZXk5MW56L2swOHVuWTN0b2NxK2hsWjNOdGZQUzk3L05yT1lmanl5LzJ4ODRlRG5mR080VUo2Z1lXS3ZtTURKNzhhQjBTY0c5N1ZabnJabllJRlNXS0w0WFFwazFwUytGVk5USXBhLzdWa0NWNkVVWjUrRXZBRC9PcGUyMTdFNTYySFF1RnRmT3dIWVJUWi9yUUVuUWNjV1lVQkZUYlhMVVo5b2V1VHRHajFLNW5NTlR0UUptQUZIYWtvRzh3aWdGbjIyL3NDRjZsVjYwS25McUhoNFE5NjBJRHQwNm5jelBLQ2pwZzVkZEJnUHlTSnp4SXRWczdoOFYwYnZDR1hQVXl0QUNhSmp3Q0xveVVsQWNQcFl5L2RnQ09zRlNFZ2xtb1JiU3o1TjdLR2p4SnVMNzJYc1gydldXdFVQTzhWb2pNZFlFVlYrckRpT1VlYVdUdk5SUndjUmtZNGJpWTZwUkI2QmpCTmRFQmdEbzFIUXZlaWFaOG1YU1lLQ3JpQjNOb0Ntc0FOblc5M3ZQVmVWYTU1aS8xYjNnV0pnSDFtai9WVzZrYnUrK2xFNFhEaUxTVTBmdldSZWVaUHgrbzVnT0V1SlRGTlRqaE5RSWRxM2RSaTh2dElMWlE5STRlQUxMYXRlNWJYbzBqU1Q2NGNPcmJUMER6ZVI1bElyQ2NUZncybi9KbUFKZlBQS2dBZmZXQ0ZiQjBXaW5xcExhTGZLUXV1SHgvVG5uOGxJcDUxY0dBaDNjcEx3ZzgvcEN1Y21Va2tuV3NDNzdKWHJZU0R6SXFYYkxXZE80U2dFOE9GOGFNTDRrdU1SVFE1MzAvY28wdkxTeHRybytyazhYeEhtdFlqd2xPL2hUOXEvMjljY1FhMVJHYlJRL3c4SHdmQ2g3TzJFanFaM2QwS2tlYkMzUjZ0WFFBLzlFTnRvaHRaUlNxWjVCbndGSTZlVkozdUhKZzh5NWp2aFNpL3BGRlRjRFlaSEhXRUdVQ3QvNGdMbldrODVsYXgzQUFmdXNMTDR3MFBJcVhyTjJSa1JMK2xIMkdvOWlPOTVYWHZITVBuc3hnMEc4Q2o0TUcrSy9YbjhvT05ZbXlxL0lKZVpQOG9nOGdtTTVHZG5Dcmp5eXJxSFNqRk1Hbk5yY0txOVQ4SzVIQ3U3UTdpR3FPNGpSSSt5VUxVMnlmNEdTQnZNV0N1QTZlVktCTVpmZ251TnFYWE1NU0VDRFBIbjRzclozTktxMElsZHYzblZmR1ZtdGVuZGQxblRiVTF3QnNHSlRXaGd5dFJIMkdrNjV6Mk9qTDAyZGE0UTVEcVdCbWI1ZnBHMFJ0cU9aVE9ncnBhS1A1TnErdmhkTUJvSnE4VWx6SllUMERpeGpMV0F4QUpiLzFQZnlraFo5bU1TV1FDQjJjam02S044dWFYdGNUVnRuRkwyNFA4OFRsdWV1SW82LzczTHJOdW9KNmhwNVArU0JTUnBjNWp3YW9ZUmlNK1NoZDl0L1VDTWo2R29sNkVrZjB3YlhCVGxuVmZUWXJUclFkNVdSYXAyUGlhR1dRNmhPZEphLzBtV2tRR0pSSi9OcVB0TTduQXFqdXFhbGxCRWQ5ZWFRMk5NSGxDSU8yUnhOcHJ3UW1wb0Z1VlhBS1dvdmR2bCttTWZOVXowK0NRdDhQOGRrak94TGZXdDZnTGpKbE5ldUNKMy9zdFZwZkgzZDJkc2IyNW1hdUQxbE0vK0kzdnhwclBBcTh4YnVDYnROWldOZ2RMNS91RXV3T3g5THA2dmpmL3ZkL000Nzk0UXNlQ2U3eXBQQ1N6YVpJVmRNZzh0ZVFLd0U4dHVvUElEaDlKcFFRRU05NE9kb1JuZ3FtV0RYWVJPaUNjbUM4Y1JhbjB5cVh5WGNjMVl5NnpSUnFDdHJKaThacW1hSHRCN1dsbmJ3djM1RlhpSURiK3VwZHgxYlg2aWorWUo1OG96L04ycm9tcDJwT2VvR0M3OXB6bFU2Tzl0Y1h0UXRocTkzMUZleE5lUW5lVnZHd2c2dEFWOEZQUG16ampKeW02U0MxdUMvL2thNjhtT1RTeStzdm1xcXNJSzZPcG9JYnZDZWZlbzZldEwxVXg4YVJSUzlwL2lwNG9oL29ab1FsSVpsTEw0SE1DdFBPMThHZ25iWHZvMWdjVWNWNW1NeXpQQWtGdUNaaWtmdEZWRWpZSnFQb09Nem1VTk0yT3FYQkF4L2k0UTlHQUM3T0xnNTJrcTlxcE1vcnZvdG1LMHo4amtURUtUdmltMUFtendDaU1ycXU5VHlrN3djQ2dRNDVHMGdlemUrZ28zeGV5NGZYSG1sWWFuZ3RiT1B5NDRIbXRhNDhDeXRNNXd2ck40ck1kMEhURUdNWlFNVzNvamlmUjVjR01leURoaTE1Z3NjQVQ3NENpdCs4eHA4UCtWTmQzT293bXpWUm0yMXh4aUsxNnBXTzFwWEgrS0dGd1dNNTRqRDRaRFRWYmNOWitocTk5ZXJGYkhDa1hCWW0yVG5yYks1ekdMNFdXV3hWcjJlSEJITWMybDNReXIzQ3Q2ZXd2TEhPaUdtVkY4S1hGbzRKSkJmai90czc3bWpPa3NEcTRoby95WFUwN3IxOWR6eCs3OEhZM0ZvYi8rQUh2eisyMXpiSHozNzgwL0dHVHlCZjdPMlBVL1lySEs1ajlHdnZqUFU3MjJOaisrWFk0b3NYMy83MisranRmTHpZZlQyKzk3M3ZqcC85N08vWTB2RGF0M2w0YW5qQUZ5d3Z4NHd2L00xNDByaTB6RDRoMjFXbnhubWR1Y2kvbjZoeHZTOTJBZjlJbHpaS1J6eXR3d2xzb0lsZTBJMHZrVWMvMUZldDFpR1hpN0t1ZWtCbDhDaGRxeS90UFNNalJyUTFmWnBHSDVUVjlBbzd0SjNURVZYYjFkVEw5YzJiOVZqdFFJcU1DRElDTXNDVlA1U1BWeEN0RGlwd1NLYWtybHRtS3hIMmx4ZVN5ZFV1WWs5Q2dGZmJkMGxBSFBGcEgxcFIxM3luK0UzYjZaMzFMSk9kK0k5MnJSYVFCK3BjTnJ3QlN0dENCOWFocUhTclA4bXp5eTErNFFSK2lnQjRxQ0NRbng5UmljV0FtOG9xR2pkY0NBT3RFK2hZd2xwV3pKVlFjYmpnNmdZQnUyM0ZuNEt0Nnd6VGNhUUVCWEE1OGtJVzRPd2xkRktFc0VGaGRKNkdOS1VST3ZCaTJlOGVTbVJlSjNIS28zVTc5YjB5bWE5TXBwWlIvSTJqWWRPakFsTWpOUlZid2M1NmZTMnNoL1ViM25KeE5YM0xjZzJjWE5xakdSek1FNDdzOUdqMmpMNGZSdVlVQUN4QS8vSm1UNm1lL1RmVmE1NmxMNTZpcWRIUlhqSVJCVXNSbzBISEdrOGQ2dE5naFJ6VXcvYWlkN2l4Rm5oS2I4V2JpOHZRcjRJNHFyMjY5WUtFczZOL25WeEhXdENvNlpoVzRYZVZWWExycmJISTZ5NTJnOGs2MnhEV2tQR3RlenZqUGo4T2NjWHJOS2Y4UE5jeVA4TjF3YTcxRjN1NzRYdnY1VjdXUEY1d2ZucitjanhocmVxWTc3ZS9ac2Y2YkcxNS9PQWYvU0NmalRtNlBPVkRmZXhtWncvV3pxMFpMenJ6bTRSTS96Nzg2R09tbE92ajMvLzEzNHpkYjE2UGJRS21pN3VNb2NiMnJTMGVIQkRFcWJVRWo4Y3MyTzhmOHdTU2VpdU1TSzhXK1J5eU5xeUlqamlSSXJwR2hnVkdXcTdGWlAyS2dKdDJOWGluUGFuTHY3YUQ2a3pMVmpLaVZXZWtkRmh6bmFEd1BhVUxRUDhwOE5pWFdkRXZlZHFzL3RVdlFEdUs4aU41UU1TV2hCV243ZGZCeEZtS2RMV1ZqTGluSUJON0FxNkNZL21hOWEycjNYalNQcjBtTi9LS08rdVIzSXZQMUxZc2IrcktpdUhUTW1FTTNwT09vak0xUlg3MEtoNEpxVWRzdkpjbCtLM0pjbnlacWFGckJTSWQwcU1NdEJqdzJxT0ZMQ0xoN1pySmhpbkJGTENTVnpGK2lLYzNnVEdOUG8zUFdWeTZ4QVhsVVlTZWcwQ1ppdUJVNG0wRnlQUHZLc1g3enBPaTF3M3ZkY3ZaaG1OZU5YTEoxakNXZTYyTTFtOFk2WGV5M0JTZWdSRzIrVFBmZTVOS0ZzYTFIOHViYjNHbXpzU0QrYVlZQ24vcm1oRUsrY0ZyMjVJWmZ0QlA0ekg0cUovbXNYclo2aEdGbFUvcjI2Nnk1QWhJVFA1MS9TaFBnT1NGSGl3QkNEWnNJdzFFb0JnTU5IU2NETy9CZHpiQjRxTzFlR3Jia2E5aEJUR0JjUUZpZm9jVlRjSWYxN1RsTWtGZ2xhQTJteTB5bloweG5kc1lyMTYvcmcyZDc3NHovdVJQL3pIcklrdmpTMTZmK2NXUGZ6bHVyZC9oTlp1ZDhlWHI1K09Fb0hSd2NEUSsrK3pMUk5SLyt4Zi9qZ0N4V0QvZFJhQTRJbUFkODFOZWgvem94T3JLNVRoZzVIUkswRHJubSsrWHAreDBmKy8rK05sdnZobi8rbC8vcitQK1czZmdZWTB2T2ZBSmFlUjF0bjEyZURRMmQ5NGEzM252bmZIcTVUY0VyUm5UUjE0WGNmM0xsNmZSd1JWZkovVmI3UldtWGN4R1F0VkVrSEJLWnB0WWJ1dFZYM3NUS0l6MXRrUHNCbDI1YnFwdDZGL20yVmFXVzlkck95UExiRmRUcmdsQStRNmJRWWsyY1BycWF6bGxwOXBBdDNIeFpKTUVsNzkvYU4xMFRwTTl3WkQxcm5qU2FwSUg3VjZYY3pwdDhIVmtSVUhLaEhYQjIwN1I2d1JKWkNvYjY3TTQ1TmZwS1hiSFZUK1JWemZXSzF1a3cxSm1BMVhnWVRUR3BsMTZYVW05UmwrZEFVTHZsOVpYbGo4UnV3b3dpVlRtUGZmNmk5ZXRXSWw3N3lGRFZXYTlWQmNEZ2tSV0xoVzRDTFdUcGE0RUp4eU5yNTNZRFcvQm9VQ1RnbHB3aFM0bGxTTktzZWpmQ0dxZXVNdzNpZDlrdmRDZTZBclR1SlROc3ViRis4NlRwdGVteG1rQTZzRFdRYjNMV2s3eGU5Mkg5YTBqemREaG5JWHdpYy9NNGIyV0YyRXBkOFNpNFFRM21VN3B5aWhLcDRLN2VKNEtOTENHVkVmcm81eEJIdXNiVjR4Z3FlUWl1OE4vUnpnK0lmSmxXMmxJMXlBbzNnU3I2TUUrdW5Sb1IyTndjNnZCS210T3JqZldNSjQyNDlvUkZleXlPNTJmMDJJdmxCL1MyK0hkdm5mZnZqY2UzYjAxTmhpcDNObGE1eE13YXdTWjNRUzBQL29uUHhoLy9DZi9jRHgvOGRYNDRvdlB4dGRmZmtsQTJSalBYKzZQWDMvNm0zSDArazErVi9BQTJ1ZXNDemtEWUovbXVEaGs4Wnl2aHA3eEk2a1hiODRHUzFYd3d4UEFXd1FqUmxISDVKOXdmUGorNC9IeFI5OGF2L244S3phTnZoN3JqTVRPQ0N5N3UwZmpKRk54T2hONFhWMWRIUC8waC8vSitPTS8vYWZqZ01Ebmp2YzdmRmJaYlJGNzhCcUh5L0JLUFplTm9TVjB4ai9iRkJYRVp0U2kvOUdGZ2QrODJvUGxVMUdkMW81RXV4UWVlMFpYempSTXRwcnRrS2tsMTlvSkdiSG5QSkgxSHB5MmszLzlnVlBQMHVuUHo3VGRTVU5jT240bmVlbTEwUm5mREJPTDl0THZJL3FOOWVBbG1Fb2o4bWdNcE9ZbC9MbEc1cWdUZnJvVG5NQ0FnekEwRFVoWmdoQ2pnbkZvMHo3Z3lLaEtIU0ZVUHExTjVjakVuM1NXb1FoTitKM25YOXZDL3VtUkFaUzVUcjV3SEFwVGhvNVd5cTZobWN5cm9HenNnb2tJQVI1N2hyd1N3dnc5OFE5RmNrWFVWaEV3bzRKVm90Y3lxUURnbG5iVHYrazEwaTFGVWZaR3B1WkJITFdnVjN4MzBBZ1FmeXozTUhtMkVhM2JOT1Rmd0dGcTJwNDdML2poU3ppdnU1N3dYU2FzZEMxVGhrN1NzYXp4V3VhaERPWTFyOUdoQnA5SDN4ZzFBY0J5MlRZd1NDZUtBakhZOEJETzlFZ2F5UlZCdzAyNzR0UkFoSFgzdWErWDJNdmI2RzY4ZElqdXRlVTJ2cVNLdmp6RFR5eEp6c0VQVEo1R2NpMi9ramM3UE1VaHBxa0RQVG1tbEkvTjhTQUpBTnBZNDVRLzZtaWtUdjIySEZGeDNpRkFQYmgvaDNmN2dIdHJHM3huZkpmcU5WOWQzUi8vNnIvN2w2dzFiWXkvL0l0L3kwajdkSndkTUpyWk94dXZlY0szZitqck5WdDArWmRqanpXc0kvQzUvMjZONmVMTytkSzR2YkRKUzg3WURqeWNMSjZNOTcvL1lQeVgvKzIvR0o4Ly9YVHNIZXlOdDIvZEhpZXY5djBjN1BoYnBvQVh4Mi80ZUI5N3VtRDZnaWVLNm5IR3ZpeC9hc3hOcHd4NnhsLys5VS9HVDMvNWE1NHlIakJhT3lkdzRnYzhJWHo4NEcxMnpSOFFWTmtLd1VocnhwZEZWVTU4RTVtVm44ZFhqRFFkcFdCcnlFSkZkSUtONENlQmpjMmhKSFhLdnpnelR6SFZzdzg2SE4zWVRqMUl5QlFOV05zdlUyM09lU0FGdGp3Y29NdzFRc3NjUVdsUEdmbFFYcDBjZEJJNDlMYzBaR2hpUk9tTUNxL1RUdkJDVzMvV2JuMlNlNlV5SnYrUUovMEhoYVU4MnhOZ1ZxeXU4MTNrbDR1cUl6VnUxQVpmYkF0K2hGTGErbXBwOFVrR2ZOQUdqdFRGRVFqSW9Tc2c2azY3SkpnamxjS1FiMXdCRnB0bTY4M05SK1ZrVEFQdEpMTW1qYndkTFQrTEJmUE9nOVcyTUFxZGQ3S29LNk1HcTd6K29qRVlEU2tYcmRoVVN2MlNqVUVObGd3a1U3NjhTRDh3REUwVE1NZzc4UXNPL3RNQXBFc3l6OUdCQzMveTRORjFMVGR3bUtKc3puRThZRXpDL3U3RzJBNkd3bm5kUVVoWVUrZDNYZlBrczVQNk1UVmQ0VHlFVVk2bTF6QUdFSjkraVQ0YXA1RTBPQU84alNjOWpjUGdSUXNEaE00eENIRlZyd084dUlXelFUVVE0TlM5RGxTYkR4MmVUM3hCdU9PVHdVNGMvc29NeS8zQXVGYnA5Z2g3ZklNZmJZS3R1RmxWTTNKQnkzYUtMdUhua3BISldNWHB3R2tBOG4zR2pUVytTa0FsZjVoemphZDk1d2R2UXNsR1Uya0FBRUFBU1VSQlZHLzVhbVVjdkg0QnZsb1kzbU9CZkhuNWN2emhILzdlZVBieTY3SDdhNTdrTVozNzRQNDc0eWMvLytrNGZjVzYwOGIydUwyK1BmYlpEZjdzL0dDOFl2SDhCTm12T0Q5YzJ4cmY0dGR2M2lKU3JUTnR1Mkt4L0EwMHQyQnA2ZkJrck1QM0FSM2tFVnNiOWhtZC9lVGx6L21XKzlwNDlBNC84N1c5TXo3OTdNWFlmYk5IdS9qVFlCdVI2ZXlFM3pQa0cxbC9ReUIxM1dlRlFPWUl4RTdSSjFTTzJKVFZBSDNKMnRZeU5HMDRmK1krYlpmMm9nemRMQUZrb0xwRUw1ZEdBdFdIN2x4YldtRk56bTBGcnRWYWthSnFWL1NydmRtRzZuamVydlF0MjlCeW4rS2xNNk5tMjdQdG4wKzV5QWowSE0wRnJjNStEVGQxaE1DS1M3L3pxN2VhbHZYN3lhWU14VzRJMG43TTBkR3pBVXgrUEl6TE9INDk1WVV2eGJDK1NUdHhtbzY3SWxvc01qcnl6aWx6Z3JyYlE0VG55Q1psTHBOdm5FQkhDeng4eVlNMmxTUGFPSWQ4Z3BIRHR3T1cxbGVYUDJtRnlKUUYxY1BlT0Z5dndlaUFLcjU3WnVIVEU4aGdIQW5oWWRvOEYzU0ZQL0d4UGtxMEljQVk0WHBVWUdPWWdvZHlhVHRWc1Z4OE50Q005UTVqbmhJMERYRzV0NmZtN1RRTTVhMVljUVFQQ2tndDdrMGRRRHhiWDF6S0xheEpIdHBvVko3M25XOGQ0VTFkWDFqeFdOOHk4eDN4bUYrL3A2Y0JPeEl0UHJ3V3Rta1hQZnNRREE3K2d3ZGpzRHlMb3RCS0hhSk0rQUxPWHJCNXNJZk02Qmhqci9mZWlyY0FvQkR4bFF5bFk0ZmhLcXBVaWN6cW5wTWpMWC9rWVdOakEveGxVR2xqZ3BaUkM5ZmpyRDVvRDJseXY4NTBZQVhqV3lKL1oyTmwzT05ISHN4anRqWGV2ck16SGpFRnZIZHJrMTlaWnArVXdZUlB2ZHk5YzR1Uk50TTA3R0g3OXNaNHhMclYvdjd1ZU92Mm5mSDR6djN4NHBkUHhzblhqSUpXV2J1YTNlS3AzdUg0ZW5kdlBDTTRIakQ5MjJSazlkSEs1dmlEalR2alk0TFdBNXgva3dBL2k0N1BtTzQ5WVFyNU0renZkTnlCQjM5QTlmRG9hTnk2ZDJmOCtYL3hMOFlXbTBnWGtYUE10c2FuWHo0bk5LOGlENTltSWJodDhWN05CdmpXZVhTNGRFbG80amNMRFk2WDdoZGp6OVkrWHlxOUlMZy9lUHVocXFERHRRTlZ2L3JJcEhmMGJaNUJMbnVUYURkMXJtUGFwdXA1bFYvMUFZeDhPMnBIUitYd2JXdTJ0MjNkeVh6dHlzT1pSK0R4RFZ1eHkzNGIxb0NCRDl1d2dhbjJ0cjVma3ZDY0o0RkdHaUcwY2Y3cnIvSWFFN0hOelljWDk3bnBZd1ZiTkxGNGVIZUVyMTBhTDByKzJtTm5zSzdPVU9OU1A2bkxuM0RFclVzYStsMEdQT3FQUXp6eTROTkFBN0l3c0pwYUdjRkJTNWFFd2N6SzhCV21qZHl6am1hZzBnbXZuUXhtSEg3U2xjYVoyakVkeGxwZk9BOVRYcWlFd05yYVd1cklvT3MwT2NPUVErZlRVNTdLUUN1T3gxbTZDbWJ2cjZKVW5NN1l6aTROTmFUak9ycUtJL1BkSWNzMUFGUExJQi9XdDh4a1hhOURQMFB4TWdMekxCUFd1amEwbzhoSzhsU0J3L0xRcDhBNnducHUzWFJnNm5PQ1BMRE5SOWJtcGpxRkMzbzBoQ05HNS9hOWhnaDVqRnhqTGtOUkkvUXhreHp5MlFhR3ZqVjhBb2Y0VmxrcmNsVHJ0RTc5MmE3eUI5UEpqK21xUDNCNW5aK0xCMWVlekFKMmdtUEt1eUJJeW1nQzQ1Q0ZqSXlvQXk0TjJHbmVNanBmNSttZG16Wm45c0E0SlUzS2UzdnZSSmF2di9sOHZQWDJPMk9ESVBYa3EyL0dlNDgrWXJQbUVVSGx4ZmpUUC8ramNmdnVuZkhwYjM0eDN1RUhJamFXMXNZM3YvaDZQUC8wNmJnOXU4ZjJoNlh4NjYrZmpWK2ZIWTBYOXJpTUduYlluUG1mYnQ4ZFA5aTROV1lIYkVYWWZ6bE8yUXlLdE9NTUhTNnhCbldYWDhSeFRlU1U2ZVRpNVIwTVFSdFo1SWRTajhlcm96Zm8rWEk4NGFlOWRobE5IUkYwTHNEcmxvWVZGb2czV2I4aUhLQTNPbVJFUHVmc1A0T1A3eW9lb3hkM2R1Ky8yTStvOGU0dEFpTEI4SkJQdjh6NE9vUTJwZTRkWGVWcHJBODBkREw0eWpSdThwY3liakRIU2RFYi9FdW5iY2h6MjZKdDE4RkwyNG10WVJQK1VLczIyZmJuZTRBTEtML3RNMDhHV2VjVFNHZDNHbFU4T2FXdjlyWnVQVTJrWGFsN1JSUndkSjhPQ254dFU0N0VEQ0NaeGREdTJrVjJ4V3RmMklibUpTNXRSdjY4Tmo3NFVua0NJQVVwUjE2Zm9GYkhXdkptZWNpUkYzZ3lpOUR1UkVTZXZpQ3Z0VDUyNDhmcWJXbHpaZVVUQVkyMkNxMVN5N2xST3N3YTdTd3ZackZLR2FSUmhmRmRPOHNNSUNyZXZQVGtDSlRwaXdJZ1daaVBza29CZ1FVSFdESWk4OHBoWDRhTE1CWGxUNUc5UjBIbWVZQ21hSERWZVFwbzBMTmh6YlBoZTlRb1Q1bFBlN1l5aDBFZytjcWlvcUNsL0NwWFp5OURjYlJCd3doQWFyd2xZL0ZZRGw3WHdqUk84WmpDSC9XN2pua1pmV29JTWlKdWRPejB4TVpJb0pLUGJud2FMNWdLM1UzUExTTHFtZTFvMUFhcDRBMHVia0RsWDZIQWpmRTRSSldXdklBLzdjMXROdWZDNnlXajFYTkdQOVl3S1BreldRWXJSMVAyeFR5WVlkU3pQRzd4RXZGdDFvMTJNSERYcUc3ejR3NUxCQy9oWEtkNnlNakszL2ZMTzE4NHN1a042MGt2WDczaXZjQ1Q4ZkRkaHdTRGM1NjZYWXozV0F5ZjRTTi8vZi84OVhqNnkrZmp6dXB0MXBaV3hwTTNoK096azRQeGdtbmpLZVoybjlIUEgyN2ZHMyt3c2pVZU1TVzRwWmZ3QkpCSjFyZ2tJQ3p3QU1DQXNYMW5Ocjc3Qis5elhpYzRuYkUydGpXdUdKVjhTWkQ4NnNtWHFPdUt0YkhqOGYvOTdMUHhjcmVlaEsyamp4MzBjUnNkclJPODJDL1BsUEpxYk5FUmJQTVVrRmt2SDkzREI1Z1FHc3g4Q3VtR1VFYzd4d1FyV3lBL1Nvdjg4UUh3cWY5cTI1b0taYjFKM1pQS0xNb2VJSnNtcVhZcm14T3Z0dE41c1p0VXJEL2UyN0tGVHNlZWZLSVFKMmhRU3B0cjYzQWhMbXpOTnJkanN0MGRnR2dmc2VlTW9Db2dHTlJjVi9NSm9lY2VXV21UVnVqN2VJK2RoQUtReEZQK29uekdCdUlCYmVUTVFYNXRtL0FTclpUUE9nc0RqTHJsRDFCSSt4aHZ4S2Q4QmtCeFJRWnRtRGlpWDJkYlEzb0RnQnp0R0VkRmx2ZXFBTWlvaUNHY3hDK1oxeG9JL0xVTEdmWTFCNVdRQnJWSGtSSTRZQ1c5djRqeXBuZUlJNEF5Nm1BeUQ2d05HNGV6QnZqUzBDa05DMXlWRWp6THJNd0xaM0tUbW5YTk16bEtTUU9MbHp6bjMyNlpzRmhGcEs3QkV5ZXdRZXRiWFBEYnhrWjkrYmZmOXVOaUJoQjFJRThhcTBrbEtuL1RNYThEcXRlZDBodUNUNTZUWklLNlB2NVhiMDZMd3FPQkVvYnkrZHlwWVYwWGNTb1NJeU5xNUtzQjhrMHY3VmpMUnBTK3BwR0FTbERUVGR5bTRKY2NIQlZrNnFpeTVSc1pmTXpzZXRlMWdjT0xRWkU1V2haYzFkVVM5OXJScXJTOHBqMlhDUWdiQkN2M0t4R2YyQ3ZGOUJFRFhsMmhIUkRza2xIUUpZSHUxdDBkMXJDV3hvc1hUK0hyY3J6NzNzUHhndmYydnZyNnliaEZJSFBCK2t1K1FmVjcvL0JqbmdSK1BwNjhmalllUHJnL1B2M0ZsK09ZejcwODNyNC9UZzhXeGpjc2RuOXhmalJlb1RjN243Y1pXZjJqZTdmSEh4Q3dkbDRjOGlSd256MVNOZVVtSmlFdi9LT1RSWGlkTWZWMFJIT3cvMkpzTTRMYlpRM3RhL2g1OFBqT2VNUUgvQTVaSjd2eVo5bnNCSkRYbndOYlprRi9tODVpRzJsbTJNaVM3YzZVVU5sQU9ZNElZbTV0UFZUSDZvVGdlQUtlM2VQVE1kdWNqUjAycUI2eG1POEczU3YxVDd1ZWMrMWl0TzFkYmN3SUJ4emFWamt2YTBnYUlUemtLN0RBYVM4NnZiWmtKOWd6RHR2RmpiYnBjR2xsNjNPS1hka1I2UXZDKzhKMk9ibzJBUXo0cWczaFc1bVFKN0RJYytwMGxveDAwZ2lwRGkzTDUyYkFwWjJSQVI1SGFFWFBKM3NxSlNNMWlyMkdKQm44aDVaTWlUT0RGYStGSmR2QTVSUlUyZE54YWx2b1V0a0ZJUHd3QWxVUFZoQmZ5Ukc5V1NvZmpGd3RDaTFPZE8ybGdNb2xIMlJaY3dvanl1N3dUOGVxaGxheFVRRlkzS1h1WS9KMllKbTB2c204RGpKZUs3eGwzVGppOFNzTkx1YXFNSDhGOThvR2h4NThZenpWYzFyWFpHTjJvM2dmUHFheU1vWWFEUW1UZ0RFRk9DVjFQYzJSWGplQ2k2SDV2REJCU2FVcWU2andwMGFFSlljTnNJeVIraWpLb0NWZVUvUFVjbm4yVUw3SXJ3NjhCN1psOWh5WnlROS82aEg2WGp1cWcyMnFRSXZ5dklTY1BIUm82OE9kUTNhRGdYejZ0TEMwUW1OclRCQVNUOHFBUjZOUzVoLzExRGxYdEdBRkxHUXB4M0JVVEZmamxFNDQ2cS95cEd0bEdhTmx4T3hVYjV2Tm5adEVxbldNek9lMHEwdy8zUVM2ekJUS3g5cEhiS3pjM0dEMHRiNlVRTEhHd3J1ZnVuM3g3S3V4c0xyTkZQRWh2N0Q4SE9xWDR6LzdsMzgyUHZ2TmI1aDZIbzZQUHZ4d25QS3RxZ08yRnN3VzJNL0V1NEl2MkdmMUZHZDd5aS9kdkdKLzBDYWJ6cis3c3owK21HMk9HVUVpMDFQZUk5d2pVcmtQU2NmeTE1SFYxUkY4UFh1elB5NWVvd0dHYmV0SWRPUUNQS09oTzdmdjhZczVmODdUdjErT1gzM3haRHg4ZUcvczhodUZhK2phMGRRNmRiZVFpUmpNVkpMNmRvUndUS1FZTTUyZHRTM1V3N1FKbTZUNTFkMFJyK3JNbUJMckNmNTBXbDR4WW4vWkJUcnhTV1k1TWNHQU52TkYzd1NIZEY2Mk0rMUErK213a3ROZTNaNmdmV2hEN2xIakJubUJJYzNidkREWmJrSys5dUJha2tzQXRoVTU4VlBEclhnd1pFMHA5VzFiWjBxeElXVWlYMHUydzUreEh5MjJ5L1VGNzhSb2JyYXRyMTlCTG1YeVhOTXo4VkdacEhWRlU4alJIWG9Rb3pjV2taQ04wdEN0Si96eWJ0RENJR09UV3FpM0JsUnQxT0E4bVgrWWt3OHBTY1VNTnlhWFh1RGVlYlpNT3hSVUNBT1Jpdkpwbms1bTZrRGd0Y1JOSFRSc3hDaUp2QWhQdVRBeUhFYkI3VGtST3pYdCtPbjVPYnFlRzlhRU41VktpbWFYVy85M3J4cy9CVGVqaHpuYU5Xd3QyZzVTVFNvdHcxc05CbVY0WFExQ295Qi82YUJnRTJEQ3R4cy9IVEY1WU1BaytURzFRVFh2eVlRZmVmVm9PUFBWa3poOVlabWk0S3hHS2x6aDF3WVZXUDR3ZGxva1BaUlpGVXdMcDdnTnZPbXdrRU9Ec2xHcGdsR1hYQmZjZUswK2xmdUtIdGJSbllhckFaZnNOWXAyN1dOMW1RVm9IdVd2NGVpWkJpTHZqTW9yakVZVzZPbFdNYTZNTWdpSi9rU1dqNlkzbVNhdU03cGFQTFdqT0Jrdlg3NGFHMXZiT053V05QbFJDRVphYW5xVEY1VFgxMWZHL1Z1UHhudnZQQmcvL2RGUHh0bnJNL1pZTFl4ZnZYZ3hudkw2MWpPYzV4bWpKQVpQNHpHQjRzSHkrbGpiUHhtbkJFWi8yT0NLUUhuTVZOSFI0aW9qb1NVV25Gd1gyV1d0OVRrOGJtNCtHRzg5ZUljblhNakhndnIrcTVjRWtUZmo1Ly94TTJJaUhTQ09sRS9Pb0xSdDJ1RSswMXgrd0g2c01kVnpMV3VaNEdsbzEzTU1QR2xUYlJ0ZEdaeFdhWk5GUjcvSXMrZDZHQThOM0NHZkhlN1VOOWhvSFlmdUFiT0R4bWF1R0RFdk03ZGs5WStTR2tFNE10YitleURnS0tSZXdLNHdZSHU1aGdnTHRpeDZKQVBkTzhKeXoxamFudUJ1ZmcxWXhGVjJFZGpZZzFqS0Q3WEI5cFh5SSt4WW5DVHR0d1lUNEp2c05mRmdLZ3VRZitLYmhST1dZb3ZhMWlVeWxwOFVURDVaazh2eW9YbjdGMDFrUmc1WXc4VDVveU8wTDRFTGxLS25GZVNMT01TOTA5bVNHVDJKUkFpTlY4S1lZUkJKeURVcUY5YlRjTUQ0K0R2QkxJNXJMMTlLcWsyUE5leU5jbFFVYUhPdG9DakY2OHBWZG94dUNrNHluSzBOTXMyMW96S1ZIN1pnMU1WTzZSaGN4QkhoT0NkNHdLK0wyMW53eEpndFY3QU1xY1ViR2tiMkNqYVdGWXhvTUFTSXBKSENtUWFMVThzM1ZwQkZmQUF5TnFHZU9PVFAzdFBwVnpWeThXU1plUFB6U1p6RjBiU1V3L0w1ZTY5TnRFOTZHSy9UZUtFbmZsMjIrRTdQQnJoVjFJTjF6VE9BK2hLMHlhbG1SbEtjOFI1c0cvNE5Wc0NyUDU5SDVFMTlMbHpBOXdYdmRSYnAzV3JBWG1sNitLSzF3ZVA2TzR5UzFsbEwyUURHNmQ4eUk1QVpUOC9PZVhMbVdwZjZrT29WN2VSQ3Z3L1ZEQkpyQkp0dm5uek5EenpjWXhURnk4aGZQR1hMRWlNWVJsOS8vS2MvSEY4KytaeTFuNlh4M3J2dmplTzlvL0dMdi9tVWQvM1d4akdqcTYvaDR6bFR2VDF3MnJOVExiVDJ6dGhQeGZhQzlPcFk2djdaNFRqeXl3dU95dUJqQlIxY3NNQjhoWTErOElNUHg1MFAzaHVYcSt6bllyL1VWOSs4R3ErZW5vOW4vTkx6cjcvNFA4WWlUek5QQ1BDdkNKS0xURFY5VUxCRzU4TnZOVE1kWkFRSjNRVjBwWnN0c0hqdXlOdTJWcVVMOEFoamhEdUNGdlRXS0Q5aU1WNGRiL0N0TGp0Mi9lSnF5U2xVclJPZDRpdTJsZHQ2enRnSzRWZFZNeDBDdjhHbmxnSXFLT25rempCY2NqRks2YURhMDhvVWhOcXYwN2xSUFovcklRQ0R2bndIV2l0ODUwdWJpYzNUYnFBazZVOTFsTTBJb1hWcUdlQVJuamJGU3VMN0NodDV0VFdRKzJwTzlHQU45Y081ZmhXbmJObzliT2Y1eFNJN1ZRdXB4NkU5Rm4zeVNNWVY4ZGxobXpMaWhLYnRLaisxZnVZb3M0SmNjSkdQZEhUQ3pBRHduM3hUakJ5ZVZFUEJJbUJQZWNRYnVQekJTV05BRGoycklWUml0S1NtdUx4ZVVEUGZ4Z1h4eldocmNyZzRhNDFpc29CSFhXbG1xZ1Zuc21qUU1hSTZSQTdxMEZGd0hVekdxMkZzREFOYWo0aWllQ3JNVHoyRmRlUjJ4Uk1TSGR5dEVRbUN3UG5rMGllYUpoOHptNjlTYXFqTXBiemF3TUQ2WFhuWjhNY0pER29HU08rNXlCRGVFV0Z2OGt1QUZLZEdoRHF6UGNBR1ZqN1AxT2QvR3M1QVYzTDRsTk5SaVFFS2d3Wk92aDJpWjJoT0JSc2FTMGxQZzJiU2NKQXBQdUE3N2NHOStCMkx1WG0wNE1yZ0JjdzZpREppUWE2VnpSanVyMEhYbWU0cTlXWkVoelgzVlBFTzNEWWpqaDNXZ3BiQTQ2OG9MK0xBdnNCN3JsQlV5SWNDa2YrQW45RFNPRStaeHRrR3kydmY4UHJMWTBOZk5sVXU0QVE3YkNONDlwSWQ0c2kxdFQwYlc0ZnJZM05sZzA1d052N3FSMytWVHhxZkVRajJxWC9JenZjOStEdmoyQ1NJT0QyN1lPdjZNVDU0eEZUcmloRlExdjBJcUhhaTlzS0t5dGdudkYzeUpQcWYvUE4vUHU3OS9qdmovLzMzLzlkNHpYYUlmWGg4KyszYjR5NEwvVC82MlMvWkVVL3daWC9YeWpLanVrdGU5ZUdwS09PMnNjQnJPZ1llQmNwMEMxblY0L2swTlp4TU1aMmdvOVFaVWVNVUovWFFLdy8zanpBSitLTGR6dmhRb1BaL0FZeUw3ZHFYci9XdzhCSEhMejlDdCtSbk5LMlRrN1JGcDZJbWJUWkJoMnREaEcyY2JRVFlwclphdG9hOUFPL2FtYkRtYWR0Ky9OQkZkZGVFRXFERXg1TldZZnhwdWxYYVY1L1ZWbkxXMzhDclB5WlljRisrUXNXSnRqNlI2UjMwOUR2WjZBNVl2TnFlVStJRUZXekdKQzRvSkMvMnI2M0dEMmcweEl4dVFLUlpaZk1yNS9wTU5ubkltMEZFWm4wQXc1T2RMZ3FLL1M1dHJxNStFb2NGb2FWR1B4bEpjQWx4STJBZDJRVkxucXBUMTlaUThlV1ExalVBbEdQR2llQklaU2lNUno4eHFVQ2hZT0NGcnFNREZWMk40NGhBNWd4TVJOYXBwekpnRkIyRlU5T2xPSG1WaytaQkhMNURwbEd2c2Y5SG5xc2NXaWdPbEp4VkNzTjh5cFJER1pSYlJibUFHMzY5Smw5Uy9nbHY4QlY2OEd3d3FWR3AyakE1NnFPWm5FSndwNHpCUzdFOWhvK1JyZXUxT05QNFhBUWZQSnZuTkUwOW1JSWZZQnMvOWJnV3A4WVo0WUdYSi9NY0NiaVdwYXp1Tkk0bHlJVzZpZkVJNTA5R0VWQUlWdGd0Nnp2c0pPZndxZDhHNXcwTWUwdmFqQVo4Mk9BbzU4ck5nN1FmQThwTXcwNjVmazBnT0tWbldlVVRMNGVNcE5UeEd0ZTdyQ0h0OGM3ZlQzLys1ZmorOTNqSmVIV05UeEoveGFMM1hZSUQzNmJpcWRyZFcyL3h5WmU5OFRjLytvLzBtRXk3RmpmNFZoVWpKL1IyZ0c1ZHp5RFV3am5UVHdMb0prcFpKMUMyUTUyeGcxeGJjZFhOaGVZclpENGtvRDQ1Mngvbkc2eXBMWjJNMTN0OHZPLzFTMzc5bWIxYTd6NUlFUHljbi9zNjR3bmozWHYzODZ2UCtwVWY2bHREbmszNGRHVHQ1M0RnZ09rbzlOVXhlanBEZjVjNHVuVFlCcFpSNVFWbHRDVDZRRlVFaVdVQzFjY2ZmNVIyUGVDSnFDTlhWYi9pbml2T2VaV0pqcUtzMUVESTY5VUVTOXN1VCt3U1BneFRGUkJpeDdZd2RaUExWRmVibmZHS1VJS1E1a1paQlFXdVRmYjBNU3h3WWtPd212WVdoM0FlQ1pMYU9IQWUwcWM0T0ZOVkZGd1krR0l6WEZ2Zk11bVRpVm5wSDFhQ1Fub044Z0lqUHMwTjIrRWlnUmw0YmJqOEh5RHl5Ny9BUVh0N0xVN3pFN3c1QnorNTJyaEgrVHdaSkgxV3ZoS3c4aVFoekVBWVJGa0UwNG5KVStseWxmMFhYR2RYZE80ZHdvRmtTanEzS2VDY3M1ak5XV2V6RVlSdGVBVnljVDN6ZUhGUWJzQXdHU2dyVUZUVXIrc2FUcGJqeWhmR0JZNEVMdW8wZnVzbkQyVTZTbExnb204SmF5UDBnSmJyNU9LUTR2VUl5THFDb1hSbHpLVTgyb0FrNVJGWGdoMlFQb0lHVlVZL3pZdDQ1ZDlBcURwcU5IWFRpS0dKVG9XenJtMlFCcU1CdlZIZjh1ZWVxTHEydUF4Ty9WdVdoVXM0bHcvTFFwUGVTRGtjRGZib0xrODRXYUIyZUw0S00rczQ0QllMMnU0NVdrTS9udSt4cnJTTmd5MnpWc0NIMFlERkNmbTA4QnF2Q2ExQ0QyRmlzUWFzRTNyWUUyRE9PTis2Y3p2RytPamhPeWwvdzk2blEzak82Qlc1MWV5ditmSFNqNy8vNGZpZi91Zi9mdnpkcjM2QlRDeWtyOTBhMzN6eGNueno1V3YyTURHdGdxL1g3TS9hNDBtalQ5ZFdKajI0OWNGSkgrTWhnaWtqQnZST0EwVG1iTXhFL3hyOE9mWFpZVFZlWGg2T0gzLytPZE8wMStQZWJUb3BSajkzN216eGxJOG5ZSXdZRHcvT3hsZGZzSkdVcDR6cmZFZnJDdGx1OFNUUko0dHYvUGw2Z2pTN3RnaEN0QVA4WjNRTmJ0ZG5ERFMra0grTWpzNllScDdDeXdsNmQydUdJNmRqUmpVK0xUeG5JZjdrWkovZ3piSUtzTzd6Y3RIZEpyWXR0UzVIYnZxQUcwOXRMNTNMOXFzZDhGSXErNjBsRWVvUWpPMUFzN0VTVzlhZTBraUJORmhRSHo0NVZUQlFmL3pQMmc4MHkzYmE3N3pYbmh5VjJmSFdOZ1k3V1hLVEgveVVwOU8wSFNtU3Y2cWpYM292dkdTd2wxd3BvWDVVZG1wUXJjM0lEaFNLbm5hdkl1WFg2YTUyMWZZdGJmT1ZRWjlGbXNpQzZPRlJtMVltNFJ5OThsUDFzMCtTa1Vxd0FVTTZRNll6Z1BWSVMrNjlsbmtaaGErNmxwa3BsU09XMHdrbkl5WVo3dXRrVExRaUFNNGRoVVNSamhSWVVDVVlaTzVNbmpnN05VN3ptbFlIaTVLcWhVZHB3Q2lKaXN6VUNvWXJlREVkY2lTQ25MSm5vemlLa0plTW1KSlJJeHpJSTdPNk1FQUlCendLMTBoVW5vY3BQWWN3VnBpUytGd0h1eDV4MFV2N0JFMFlleDB1aW1Vd2x3eFYzMjlqYVdqMVZFY2pMcHlPVHZWYlI0YlJEWTNlQWN0UnF0c2Y4aVJUZnFuVnN2a0Vha1pQaHg4eDNWdGdtd0xyTGdTdmJkZXBjTmh6UDZIQytveS9MS3cvT0VLemppUGJ5K2s5TWFkMXZnenNRTi9SMUFhUDlGMFR1M1A3RmtibUl2TkIxckFNV0Z1OEJ2UFZWOCtCUHgxMzcyK3pSblhNVDhNL1pYRitpOUhIN2ZIai8vQXBvNnhERnJJM3h5R0I2WkJPSkp0QXMzQ2xnOUxlQkM4b2pMdXN5Mnd5bE5sQTluVkdHSGw3Z2lsdHB1elFQYVZOOXk3WThMcDVOVDc4L3NQeHdiZmZJUWp4eEkvdmFqSHp6UHJLVysrOGs2ZlArN3R2V0hOYkh5NEk4QTNUMlBucDZSRy9GTTMzdFBTSjViVTR1ZzZYVVNwcXQ0bDg1WXhHWi8yTElJVUdNZzBGUjFiemVOaHd4TDZ6WFg1dCt1R0R0NUIzSnhCK2pOQ25sTnFkNjVwditGYVg0VFpQRFdObk5TcjJRNFoyaU5rNG5ORVBIZWxrbHc0VTVLVkhPN2ExdGxEQlRJZXZqanRybVdCdkg0dmR4ZVlyMEppdlhaZS9LRk1ORlB3eWhubHR3OXBMYjhhVzc2ekp4WTd3SXZEcE85cHQ0YS9CUXV3NDFpWmViUkNlWWR4Z2FJQ29jcENRcEd1UWtoL2pTKzZuQVVYN05kVVRzTndMcGs4NWNGekFWbXUwVlVzU1M3YzIxai9SWWJMQUNDSVZHNGNJR1JEUVdDRmk2MDNNZFNRc3dxVzhEaUFTVjdnQ0pTaklCRXpDWVlTcTRXSWhWNENHejR1OUNtMGV4WEYwbUxhdStJVHpDSzZxbnZ3cW13TExsSy95SzRnWWxHeFk2VGluRmwvbDZkR3hCNGdwcnpxb2h3YzRCRXBLbm5SeFZpclRtaHpCaTBONXo0ME5td2IwbmtNY2VhSWhQWFVBVEtacm5PVkhIZFZjM3Ftakk3bmFqUzNiQnNINnRXQlJhUnhxVGw2OVIyNGFVVmFVWDBQTzFKVkNQMVhiK3ZadCsrcTVjVHEwdUFvZkd6akFKa0hLelo2M1dQVG1DOFI4UlFFREJxZkI2b3oxb1R5Qnd6cFdlS25YbmRIMXhOYTNIQWlDeU9HSUFVL0JlSkFYM1J3Zkg0eEhEOThlWDM3MU9SeXlIWUk1NWlPMk1QaGpELzZDOG0xZXZkbGdVK2xkWG92NTlEZS80dW5kRnNldDhkT2YvSm9QNkgySnNKdU0yQmJIQVNPZ1kyUzVaTFRIakMxeTJNMndveXFqd2hrcityZVFlNHZnQ2ljOC9XT05DSHEyamJxNGdKOERKbktiNzJ5UC8vRi8rUjk0VjNCcFBQM3EwOXFHd1ZSdGJXY1RIcCtNVjg5Mng4NDZId1ZrZ2Z4ejlvTWRvdnRYVEdFUER0azFId2xvSitURGY5S092bU1wQVVQL3FROHhrUGtjUFdhTkZ0MmR3aXZzNTZ1a0YweWxuUjE4L3djZmo0ZVA3dk5VOVBXNHcwNzROenhZY0gzR09vZm9HWXlCYzJvbVprZkMyWGhOU3hrVXMzNE1YdGpJT2lvdG43WmZJbmlYN1pKUE9RekdidjFxQlJnRHIzMFlsRXpsSDlYUmE1dm1teGQ3UXRmK3d5eGliOWJUZHV5OHkwNE5jclEzL0pqZlg1R2dPdW1tSXhTSENheUIwKzV6YjZ5QVppMnZxRUo5UUxtTGQvUGxKL1hsZVlvdHd0UUFRNW1WSEhpT2lrVkFBeHNaWWFTbWhCS0pZNE1NU0FXVVdaM0lhWUlMWVM1OFZVK09vMDZNeVhhY2hYTWo1VElwTUpEdHM0b29CVG5QZHNxa0lqRjNjR2ZoajdtM0xTS004M3kxMm8vL0ovMmt6SG82dm1kaGEvUkVBMUJmQlpBRm12eTVGbHp4VlZJQ3MvUlVDajE1SGtkem4yRTFYSyt3NEt2ejJvK2V1QTZHVVN4NU9GMWhqNUp3dmhpYnQrc3hZbm13eDh1bm50R1B2MVljWE9CWHJ1b2xLMGlXdk1CakNQSXRvL2w1ODJ2aG5EcHJhQ1dYd2JOLy9WaGRMRURYMGE5UEFUMGd6OGlwOU9DK3BJdEZSbnhNVDJ4dWYzeDBIVjNjWmEvUUxZTEJOc0gyRnFPcmRlUlkxQkNwNjZMNkJTTWl0M0c0RUc3UHVNcFdnaXQvVFZpWitHY3d2R0trbEpkYUNWNnJmTHJsdXovNExnNjVEWi9JUUNDN3plczMzLzdvTzVudTNHR2F0UW5ORjgrZkU2QTJ4bi96ci81cnZtSDFPVGF5U0VEN2NQenEwMi9HRXo0YmM3azRHd2RNTFIxM25NT3JVelNubW5hT3RwUlRXQ3JaYk5sZXNhQURNWTN5U1ZFMklzS0xZOXNqZ3NvZU1sK3h0ZUl0ZnM1cjd3MC9rTXBMei94Nkt0TS92Z3BCb0hoS3NITHJCSk5pQXVUVmVMSjd3UFFVMUM3dXMvVmhHWG45SEhLK0Rnb2ZQQXpsNDMxdU9JWUgydUtVZ0hUQzRaVDFnblk5Z3M4amVMeWtMWndxT3VwMEpIRE1hMlp1NnhoWGZQS0dwNGFuZkYxVm1VNmh5UUFXYlZLSGZ6Q1NEYjYyazc5V2ZjbCtRMysrWG5HcnMySEhQYU5KdHpWWUE1THd3bWpYRnRIR1hHZE1vTkNpMVpubE5RTHFRVU9lUUZvQWpZekFkQWQ1aFlpMm4wNU8rOVFPdVZmdkNVZXFIRGd3a21kTWtEaWNnMStiOTdXZ0NuQ1RuYy9oMUErbEgzelVBenp4SWpIRVViT05PZkVEK3RLRlZLVkJ2cU42Q0JXZmNoRFdqQWNFWFdTSnI0RnphVzFwNlJQS3FRcUV5Zm9rQVdUT2l2V0hjNFNqY29oNFc4REMzaWhMSlpGdkYwamxkbUFweFBGQUk2ektxcEdjVEJaRCtaV2NWRVZoT0dPUFlBdzByV3lxRi9QUUVFY2ZObmJSS2xtdUYrMkFWK0doYjJWU2dnY0JJU05YbEg3VE85bmZHclF4RHB3a3dRbDRReGdyRUtDZ2pLNFZFNHQ4ODdySk9xQnloeThOL29ZM0gxa3JzM1JOOVRRS1NnWWc3Ni81cXpaUWY4TFlRWWduRHlCd0hxc3JZNjNQR1ZSd0JGZ3hZR1lreUxXTDFEdThoYnpKbzdhM0dlbmMyL2IxbVdOZVFQWmxYM0V5bVhGdEMvelJRM1RQWW5PMkxEQVZZNFNVTHcwUXNQMXNNSE5GUmxDclRJbE94bTEyclgvN28yOHgvZUdyb0N3R2YrdkQ5OFozZnUvYlRIOE94czkrL3BQeFBrL2szSHYxakJlUkhZbDkvYzAzZkhqdmNIendyWS9nZFdYOHhWLyttTFVyUDgrTTd0SGlDUTF3NXFJeVBLdTNPQlVPWWdkcHdQWTFvVTMwdHNEZXAwVkdSY3J2RDVJNnRWUHVmZGJOenRETDdzSCtlUEwwYzE0UDJpRW9zNjdGWHJBblQza2w1OW1yc2M5dkU1N3o4aUROT1Y0UndQYlkxM1ZyNC9iNDFzUDN4d00rRUxoQVlITU42NUtPS1c4RVFQY0NHcGNjZUJIdktycFd4UlNRdG5BdDd4Q2ZPSVpIV2ppQjZoSm5WSGRiZkNibmU5Ly96cmpOUzkrdjJGZm1wMllPbUJiS3B3OUU3dm9sVmVvZTdPK3owWFlEM2M0SW5IeUZna083MGwzOGxyM2ZLdE1LTkFrZjZkdjMyaUc1NXdtbE14SmhSSzFOUURlekJYVFMvcWVONlNjQXhnZTFuZkliWUpMSDJYYlhGdFczMXh6YWxMaTFSNWNpeWo4bzA3NVVIQXRLMnJCVFZ6REhYN1ZacW5DVWpYWXNvQXA1Q2wzNE1zWFY3anFQNjlEbXJIODc2bklrWm5zcmwzWlE5SlZDM2Jtam9CN0krU1dIbXhFV0JRcGl3Qkl3d0NBd05rWkF5MEZtcXIrbHFOeFArVExmak11QTl6TFFNQW9NTnpTRzJDMHFtTnpCdEZNYW1YWFJ6d0FRR0tqOXJsS2s0VEVmeERvd21pOFpoOXRVektFajJFdjFmRjBEa1k1Tkludlp5d1h0Q2lwT2UzUmcxeFlJbXVEd3FScCt6T2hoSXp1YitZTXVLbmc0TW5VNm9TekZMMGFpSHFEUmdWaTgwc2s5RFdRdzhoTXV4ajM1VXFQeTQ0S3kxeVo3bHVnVEhtSzE0SFFhNklpb2pFV0U4SW1CK2cwc3ZZazE5WEZuYzJXOGYvL1crTzRIYnpQOVl3UjFlWlNmdmxvaGtNeHdRRi9CY0ZxZXRnQ0Z1Snp5eWZNR3IrQzR0K3VFS1orL3ZMM0k0dlV0cGxWM0NWU0g1TDM3cmZmNHFCMC8vckExWS8xcWgrK3JyNCtqbzhQeDg1LzloTytsZnp6ZXZuOTNmTVpIOTN6UitVOSsrRU4rRXY1NVF2MmRldy9Hdi92UjMvTFVrRjN2Y1RqV1NOQ1BhenB1Uk0wTHVBcU5mQm5GNTdJV2I5ZmdhNG1SbGFOR3A1c1g2TWtSamE5bStTQmdBY2YzNDN2TGkzN21oazRHbkF5SWVEbVpINTlnVlBudXU0L0dvL3VQeGdiVHRDZDgxLzJRQUxIRFZvWjdCTDNIcTB4ZGVkSjU3T2dOdks1VG9hUnh4Z2p1RUwwNFpkVkIxYk43anE1d01BWm5CREd1eVRabytjUXdVeWphMFFCL3dZalVjZUk1UWRCMXJOdnN0UGV6ekw0MjVScWZObXV3eWsvWjJjYllvQnRkcGVNSXpLZkovaERNS1czcTF4M2NMdEVkcXF6WVRyQ1c2Ym9tMTc2Zzgyc3YybTM1UUMxclVJVjdiZEcyaHBwMkQvOTlVSnk4UEkxSFJ2R1lIRlhiSHE2eEdYQzE0ZXlKbks2cGxieUdGNjhISklBSGowRlJIT1hxUlJzbU1sMk1uVWV6b1dXYkM5LytYTXMyNnNaVVBCdXNIT0FzYmEvTlBqRmJZQVh5YkVvQUFGZ0dUQm11Y3RicHpMUzN5Tms4RkdBaTF6OTFVSzVqV045OGNWY1pOQVJCNng3enUyb0RBeTRaMXFFZEF2YzBMZ29EeDdXaXBUbmRTN3NiUW5oN1pqbFNsaXdBU2svaS9LYy9FVHdHSTY2ZVp5ZDR3cGs5Z3IvWWU4WjZpUnNUZDNnZDVOWVczeHZuNmRPMzNuOFAzRGMvTXlWOWpRZW11S1FIemlpbDVQTEpqeXlxTjh3RHpORUNRWmtlSFNPUXJnRXFmSEpkY3Rub1pVemlnOTBZaTBEQ0duQWtHSnpJNkJwSkhwSGpXSnM0eThON20rUGUrZ0pmUGJnY0h6NjRQWTUybi9OZHF2MnNaZmxwbDZ4OWdkTzJ0Zk54YjVNR3JtNzdKZDZGQlp3VXA4dVVrd0R4enR0dnhlRmU4cTJvVFlMWFk5N0xlODBPY2hmUnJmZUswY3o3N3o1bTM5VVdDKzViNCs5Ky9ndHdYdkpERW13Z0pkQXNzbTNnemxzUGVBSDZhSHp4Tlo4N1p1K1YweVNHU25GNkd5VkJIN2w4c2tsY3RSdUpMdFVOV3N4NjI2clRDdmcydkl2ZnAzQ09ndnlTd3YxNzIrUFc1akxmdjNxYXA2RitDOTRBOWM1N2o4WS8rMmQvbHZXaFl3THhLMTZxZnNuN2lodm84WnpndGJhM085NkcvaEpseDdSM0Z0YkJ1VStiSHBCL1psdnd6K0I0Qm44WGRLUk0rakxTY3RSMWprT25jOElsRHZuTThpbHpUYjhGUmdWcU1lVmxCUGpWVnkvemRRcW5qRy80RHRjcSt2QUhPYzZkZGlLcCs3Mnkxb1d3ampRTjR0cVZJN1Bhc1Urd1NCRFIwRFExZ29JNkljK052d2FNUENEQjF0V2JBd1hidHYzSzhpeVJ4T3VBMFgvQkVQdTZ0cnNidjlmKzlDR1QvbXV3L1ArNWV2TWV5Wkxrc05QemlNZ3JNaVB2TzdQdW82dTcraHpPOVBSd09DZEZrSklHSXJVVUYxaEJnckJmWUFYb0EvUW5XV0QvRUxEQS9yVUhKQ3kxb3NRWlVCcHl6dTZ1N3VxNkt5dnYrNGpNakNPdi9mM004OVVVK2FxekkrSTlmKzdtNW1ibVp1Ym01bzV6OEFwYXJpdmdCZTlhcnl1U0NoS0ZtK09WSitCTVk5WmhPNzdybFdISjMyMG5YK0NmNXlvbzRkTUZQbkh1ZTdZYlY5VHZmZTcxZDVjL0ZVQXJwVXdBYUNHQjBqSG8vU3c1bFhTNTB0QzBiQ1FxRjRsODl3K1U1V1Zua005dkhkRGF5ekpJN2xRdUsrRFdaWHUrVi95bWdtQkdXZFh1aEZuQWRvZVExZzVIMUpucjg3bHRTT0I1RUMrUlR1ZnNtR1d0eEU0clhBT2VXQUZUdmJTSHR1OHN6bUFBWDh4aWxJOUFTVmEyWEVvdU0xaVRySFJOVC9TeUw2NGEyMUFrRjlYK2ZyU0xReHkzVFFqUGZrdEFDc2NZRkdpaWd5d0RvVW5TUmhaVzlFMm01SmV3YWZLS0Y0VnFFQm40aUVrQmd0TWs4b3JCampLdWZQRU84RVhLRU9xT0NRYmg1OTYrTHVvZHJaeW50MjlNcGp2ekU2d0dYcVR0NVZma0tqL0dSRFN4SG9Sc0g2bkR0dnBqNjB3bWRBa3NDekJpc1RBYjlWTjBnbFR6cjArT2o3T3RwRE10TEMrbDZmbFpNaUFNcEovKzlhL1MwdUphZXZ1ZHQrbEhLVDE5L0l6Z3llTTAzRDhJZ2FmMCtlY1BPUnppZ0t3SjVLdWl2TWZGTjhrUSt2RHJKZXJaUlU2aCtlTHJFLzloRVNQUURiMmdRM1FZcmVKU2lIZlN4MjVYQnNVbDlaWkNZREVMaXcvNkVHbDBGQzRJbWhQeXR0K1lIMGxYMk9pc2hsTkRRK2thR2s3YkNJZ1dDd0VIbUt6R2tDMlJJbmxqaS96dDVQN3FnT1lyQ0pnckxEUU1VQThZamMzT2g4Qnp5TE16QlkvTUxxUXlKakFhOE40T1BidC9WbE5XVFU4VFZWRml0czJiMStmU0Q3Ly9QZEl2YjRkNTEwbUNRUDFoc2IrUUxoNmplVklaZE1DSERJcG1aVC9pMkRRNkdndFB0cWNmRmQrYW1YcmxUYldTRWl1NkJsdExYMTZocVFRTjA3cWFKckJvbVVqdm1WK2RmQlZldVN6ZEI3OTg1NGIwWjNuTFdUNU1UeDRIcnpBR2Rsb2VLdXF5VGVtdFdQV1RsNFBIZU4rNjFQcXRXL3EzVHZrMTdsL0NLc041UHhxbEhaOTVSZHNBNXV2ZXMwd29SSHpQWlhqdjhobTFoLy8xOWJtRXZ1d1ZRZ2lBRkZoeEVncVZoRzdBN3pnSmw5OVdIQXdqb1JYQThHN0UvbWdLQVlRSXltZWhNWU1EZUpneTBRSzEwVEdaeDRHM0hpVzVneTVESzFpb05jOWNmUGUzQXl4R0lreUFRWTdsYlZBV1BvOG9UWG5xRVBhY28wdmhwWG1aT3g0cklEd0x1QUpCZVlheEgvN3BnOGdJczEyMEg0amU3U2tlVHpVMDJKWHUzcDZDbVM4aXozaEgrN0ZpT1pVcjVUUkk0cnFqK2k1RVJ6dmNGVkFqaTZVTjhhSUpZTDFoOW5CVE1adzNpOXN1L2FUdnhXS0IybVFXVkxtL3VjOTVJQlV5VkpPZjQ2UVY3Vml0d1NRRDBPOG52M2N0amZheDdXUjlQUTNQSUNScStFN0kxOVNMU2NGYk1FMkVPb1laUVhkVEU2M3JSQzJITmcwTzdlbkhTVSswZUcrbGx5anhIY2FLdlgrc3FKMnc3SThPaGlhRDhPN2xGR1VZdlJOejZ1N3RlZXJFNUNHYzRSVmJjTXlpY0dOdWpnTWtYcUZsbktRZi9QQjdhWGlxSnoxZldNWjNNNTcrOWhkUDBvT0hpOEZBRVhvaGZUSGlibHcyVzZuNHQxUDYyRUs0Z2tISFZpRlFsNzRnRHJKT1pST1NqaHZselJvSTlBWHRvQTJma3VUOTZiTlg2ZU9QWmpEQit0TW0vcXNIdjM2VU9zRUowVkhBM0lNNWVKYldTUkI0VG9yamVvT0RLOUIrcG5DOFZ4RXF2YVNkNlNTSXRWRnFjUFNYNWlIT2RkcHVJYmdWNW9GN3g1U1FrNWhjZ051Rm94Z3pjS05WcjduNjVPbGlHaG42Z240aWVBbjk2T21zUkVxYnhhWE5OTVNLNlRqYTZpNVIrSm1nRGVETnptdDlwcTRtV3FjQ1ZsK2FrZW0wSEZrbU1CUVJXSU1JUndTMjVydkVnWW9udnVKZkNLWkxYZ0szY1VFZjBsakF5SzNRNWkzUC9jTEVsUDYwQ2hSMDhudXhrVDY3SGZKazdxU3A1dU5mM3BRUFBkT2VzS3BkS2xEbFlhOEl6K0MrWStuUjh2S3VVa1ZoSHhmbGdzKzRyMHdKWHVkZW9SaGxJWlZwUHNyelh1Q2UvN25KUEhpcDBsWCt0QkJBdVZiYW81S1kzU2tZUWlGKzU0b1VLZzZpejIyd2tJaEFIVUpJcHZSOXVJdUJ5MUl6Q3didVg3NWpoM053VzZIZDZGdGhabUFXRFZMbWZkWGNFSlFNVG9Fd0FRNE5ocytZUFlBanE2OGd4TTdSQWR0eVJsUTRoWk9RK3pGTE1WamFJUDd6RXBiaUV2SGNrYmZqMDdTNCtzRDZpZUwrNEoyYitIRVNtM29YY1ppU2VkS3V3U0J1UXRXY09zYUpxNWJsbk9QcmdmU1FOc0tCZWFuZ0M4SUNOdUdtSFVETE9MYTN0TzF3ZzFid21tZFBCekRnbzd4Z0NicUxjb0Z2WnZTQUZ1MnFyd04vREE5KzhJMnI2Y003VTJRZXVFZ04wZ0t2b0FFTklHQTBQU1JZSng3Myt2bW5DV2x1S29XVjIzSEdScXRoVXBYUnlocE4waHF6MmpoTWxnUTFMTjl0UU5COUJJcHFFcFh4eFh6N1crOEhzR29YTXRub1NKVlZyVVNpdmxmRVcyMlNudmdrM2JuM0Z2NmUwMVJERUZ5NzhUWUM5RFF0TEt4UU53VTFCYWtyK2lLNm96ZlpKOU9OdWVScWtYaTBqQTVtNll0c3ZxRmhXbFRSSzFvMG80NHhzM0RDcG50MzU5TG93RVVhcldKQU1uWjc5SHZ1enRWMDdkWThRYTc5VEJMbk9PamJ5SXQxZ0FPL202UEFSbU5UOWlqMXYxMGRTMldFYnhlcG5OdU1TNk9zNlgxT05UbHB5SnhiRENEYUQ4em5wMjFEbTJFS29pVjdaWjVBT01Da2U3dVl6cmdRa0tyaHpEOWk4ckFQbyt5eDFLRXU3cVhySGl3SGRCdm9tSmczK3FyUXB1VXdrMk5pcGYyWUNHMlFjZFgzYVBpQmVCTVBhanVGSWhCMFpUbHBrT2ZoNlBZMWIxRzM3YW5OYWsxbzhWaEJqQUh2UkorZ3gzQ3V5d2Z4WG02bmtBdkJ0L1JCbjY3eXdEWW9HVFRxOTlDVUhEZmJGa2M4QzVnRWdEcjlMU2lGNWhYeUlYaU9tMXh2OG1LaFFYb3YycVVPK2NXNm95MzhrcCsrVnZsb3pJcXRzSkNhRmxLektRUkUySmtRY3dESE15c3R5dWJaS0F1c2FJRGFoS3RvWEtRNFFGRW5UQjF4R0pRcEVDUGpGbldKWkFjYWZNZHpZYlRjbXhMZGVvVkg3RVg1eTA0SnE4ajFuak9JVHlOU0hPMlB4b0dIUGlsVU1qNTU2bVZwK2hJQWd4d0lwb3RSdm50emxxMG1NK25LbGJGTVhNQlR3c25yckdTOHp2NEJCeGF3MHNTd01jdVNQVWw4Z2I5UTY2blYrbkpPSDRVUUx3ZUNhUTBOVUJFcjhkdGtNQ2JNckxEeS9hd2Q1c0dYTGFnMXpBL05LWU5MeXhEeDNIQjN1akZaU2NQbG8zUit1SkhtcDJmU3kyZUxMS3RqbWlJb3hVOEhlL0U2V0RIc1play9abkFFbGo0NlF6WEdjTTdmcEgvMTQxM2dodm5KaEdBT0ZiZnZtQ2RjemZBSWsydVFvTWhiYjcrVnR2WmNkYXNSVFY0aDd1aGUydGplSkQvVUlhZmdjR296YVdtT01iM1d0bXRwYzIrZHZYd0hhZjdLRGZEVFRMLzgxVU55WSswRE9rNTlFUUQreGJkNnRTRXNqcXNyUVdySklheGpYTkF5MklpdDZhUVdhRjRxQ2RjdE1acXBsbldWNFFqZjNGQS96dlZoQkFBUjd3cVk4V3MzMGpMN0dDY25KeG1URGxMY2JLUVdBa2RUdGIxQmNyN3VmaWFmV2hvQWdtdUVYN1JoR2pvMmtrZG9EdXpESWFZekl2dUpwa0xqVXZ0ekFTWUdOTk1nNVR1WUFQUzFxcG1FYXdFaE5UMDlubjcwZ3o4Z2hjMW1XbDVhQTA3Z0IxVHAxd25FY2JVTnFEbjZCdUpwaTRrQllhYVpLUjA0dnE1Y0twUjBUWEFMWVZkSGdKMHc2ZUNJWnpJMUxpOWkvcVFOMFJsNGhZTDVMaDhpZ3J3Wk5CQStRaWNvZUUrTlhuNjJLNFdna1Jma0k4ZkJ1Z3h6S1BqTk9sUXc0bG5RcTNTYmVkNTcwbGh4U2JkUkovZUZ3V2VaRi9KM244bjd2cUVjOEhuSUNlN2x0cU1qOFU1aGRuWXlia0FGL2kwRGx3MzBkSDlhQ0t3c1pMS0FDQWFpVWErb2pPOUZwNVRzQ2pYTCs4d0JNQzk0RUJmZ2VLOE1ZdXlZQ0JCUWdTdURiTjhKb2NlOXpKd0tpYnhDYUU4S3MwMzhXMS9SZm9HWW9tUFdVOXdybG1MdGgzdXVMS1AveUQyRmFuSUtGMmVXQWo3cnRCMlJsc2M1dytsdmljQjMzWXpzU3NrZ3NVZWZmUHh1K3VOLzh1TzQvK3pwUytBbG95WEhwQnRvYVp4UGswakNkaklJdU9uVXZvZzdQKzFmekdET2pDS2IrekZvZEZUdHhiRTJLdG8vaGFnd1NkMHlqMFFTdUpCWmhBdGg1dnM2Z0JYQ1hXaEN0NllHMDcvNDQyOXprc3hPR3NNODNlVWdoUmN2Y0R5VDh6eE8yMFlnbUx2cWxBeWRKcDZMd3lQRUsxcUVFZW5YcjgxQUNDZnA0R0NkY0FaRUlnd0hraUlHcUkvQVQwM0JJd2o1SEp5T0VoajYxdjIzWTNXd2lnOVBzbjBMVFVxanEwd2RWMG5hdDdpOHpNb2RxWkxKbXRERmh1YU43WVAwWDM3NldYcnliRE8wRjZQeE05NFZWd3BIYUFmQkdvN2NBaWN3V21qMUlDZFdTcUV6QlFXakdyZ3p4TUlONHRad3lqZ1lZREEzMXN1UjlueUhxUnVZRGkvSjFsRER0T3JneFJJQzJPd1hYUU1ZbGNaS29mR2NzazJvaGQvckdzNzZxNnFIcEYzV2wrZVl1TWV3RnpQUkZjaGozanRGYUovTE5OQ2J5aFlERzc2bTJMaU9KdVlZeStEaURVbkF4dkpTbXA0Y1RvM2pmZG1NMURob2d2ajQxQnhkREhKY0hVOU5TMm5OMzY3ME5wa1lwQnZyb1pwTUY1Um5VR2hVczB1enpGMFFocDQ0K1lBREhtbnFCWTFCWCtJazRBUWVQNjAvdENyS0Zqd1NBb1NTMHFIZnN5WERXRkJ2RGgvZ3UzMmxYc2d3eGlJYTRoM3J0TTFDOEJoWW5QdWVuK1ZKTm10Q0ZsVzVDSm5DRDJuZDUvS21sZmh1MXRiNGRkbWVqNEovK0MyK3NrdUtleUtFOTZPY0pxR0FleFVDSUdzWk1DMDErTXo3TW5Gb1JFTENaV05LdmtKd09OaENGZjRXN2l1c0hGK2Zod0N4RHY2S1RnUUUxT0FNRzh2YVBBTWpFYitqS3U3TGNVNGFNRGhEdkZsSDBXWUJiekIzdEpYaGtrQ2R2MzBuNEtSZVo1RU1rVkFwK1JFTTNEUGpvZjJ5Tjd3ZDhPbkQwZkNLM0Q0SXZEWk1MeDJxWDMveFpYcjIxVE5tdXliYXlUQWwydExMRit1WVdRd3U1c1VaREI5LzNCY1htWGd5TGlKV0NtSjBKVWo4UnNaVEtNS1oyMmtSdWdjbXhZQVRnYmlYbjduUGwxaTRFRDNBS3V4bHRKa0xtRzZtOXp5OVA4dGtjY3BLSVA2cWh3OVgwKzZ1eTlBSUc0Y0p3ZFNOUURBOVNpZXFpYjFVR01vdzg3UGo2Y3JzV0ZwZGVjRmQvQmhvWWw2YTVZaDJjT2NLWENMWEZHYmozSlZVSnVWd2l3bmdnSlUxWTZ2TUwxWENTWC9DeHVPZHpXV3BFM09vbHE1ZXU1UCs1Q2YvUEwxY1dralBYcXdnVHZySVBtbzhrdFJDRzdRZlFjZ0tSMm1Jc2RZY09zTjNxQ21qQmlYdm04SFRDVWJTREVGUGYwbzhjUEZCV1djYTVCTlN2TGlDKzg2TktWWlFFVGJrMnpvZ1Q5Zks3a0Y2NTF1M1UxK1ZVSVhqUGRJZ2svc0tJVExDSkRQQWRwOGFBdXFZUTFKdmNsakZUQnVUNk40eDdkRjVtUFNVRUFlTnRSTHZlRzZoVWUwbmFEblNvdlFEMVBTRElGdzFhbUJrS01BVkdoQXJ0WXdXdUdZUkFHRlZRV0NyVWFxQkh4Q3NXcVkrUXpNRXYwVmowb04rWExVNlRjV21mc2JvcnhNYmdvQTJ3N0lSSCtBcFJwN0M0WWpuWFpNbHVwbGRuNnZFSTA0cEdtTnNrS2VJeXhNK3ZNTmRxcUErNElzeHBnM282Z3hYaHNxRzd5dW9GWUtPa2ppUHlZWHZvYmdBVnc0dWpaY3Z6VmErQTRlMEtteUFHMXFRL2wvN0dBM3hUR3RId1NQZHlvTlpPUUpwMENZTlI5bklwZ3ZNaGxDSVN3V2JmQ0FoNUYwV0tnR1pWanA2T2pzK1ZRQjRLVG5WZnF6MFRhSHc1dk1RWHBSMTBHVDRMTXlvSEtoRDBvTUlaOUZva1AvYllXdFg4SWt3eXhmMUZYVnhJNTZycnRyOXpNeTVCc3ZHUHo0dEwzekY5UnBPQjRmbkNqWmVqM0lLc1N5SU1vd0tyMkpXQ1lDQ09FQW85Nm1XUzZSU0IrK0Z2d0RHVlFhN2FsWWQ2a3RiNnl0czJsMVBtNnZiZ1ZpM29wd1JBUG1jMDE0T1dRYzNZamtMUndsTndTd1IwWWZMQVJVSE5oT3pqSDJpM1J6ZDYrQmtuQ24wZWNTVkhabmlVU0VEU0hFdkJ4QUNFd0wxNDdkWmtmcHdMdTB0ZkpWdUVNeTV2TjFLbjMvSnFjVzhFekZGSEw1Z0xGV1B3VmxxbVE1NGFIcEVVaU5vdXRtajAyS3picDBrZFBaWGpjekRBMHBvUWRBTnBrY3ZmcWh5MmtNem03NXhQUTNpZ3pIdGNKWDRxNm5wYVlUWFJWcGNlUVhSWTVMQm5BMENJbGVXTWIwNGVzdXdnNzJkTFdiUjNqUTNkd3NOZzYwd2FLS2g0WUpzNmNRTnN2d2ZyU2hQSERHamduT3pmb2J3QUhleW1wT1g0eVlPWkhEdmFWcGxOSjJ5SDVMZ1VuaXVENEU3T1RHVzFvbjk2aVNkemN6TmFUVEVacHFkbVV4REEwTTR1M2ZUUUIvT3lCT3lsdUpiMCtuZVNYcWNmallYZGlFbDYycExZRmxlbDk1S2FERm5ORm9EZCtobDhjd0k4azVnNEhCcE1rbXdaWWhWMGo2MVkvOHhkaDBnYm93NHRYLzBvKyttRWN6dFBZNDBNOGJyaUJUUnZWZ1hidTVXa3pQTGd5YVBCMnk0dVZkZmFCYUg4SUhDZ1hhbFhZZ2tKalJwR2RiaHR3eU1HWTBnbFU3aWdCZHYwN1lDSnhnZHZNVkV4ejEvK3k5djRBOGlEejRwK0UvT0RJRkZIZkpTbUk3QVovdVpXdVdsN0o0NDQ3N3R3TDNSZGk0TG5kdU9PSUZQaE1sSk55d0RjRlZjditQNVM5NVhrQWxiREdKUmluN0ViKzluV0FzWWdyZWhHUjh6MmRwUm1UWXpieUVFckNZMEZHcnhCYXRRV0doZXlaZ2kzSDlXSS9NVjVTMW8rUWlNazFtcFY0M0N1cnpVcUJSZXRwdE5IK3ZPeiswNFJhTk9BL1dnUXlyemY3bE8yN2Flb2k0LzFkaTRrWm1SQWZhU0liVHpyZGZCVnB2U2gyVlozNUhzclR6dlBKZFpmYTZRcFIzYVZkRG9ISFlaZVEvdFlJK2tiNjhXOTlCU1VNZTcyWDdDck40Rk01NmZ3WVRBSE5xTU1QQmRKSGVoYllWN21NSE91WWt5RG0xRG9lRnl0c2UzMjFsSkFIUXdFSm9IRWpDbUFmQTVEcDZLMHdIc0Noei9uV1Bpc04rV1FNcVQ5UHNmM0V2ZmUyOHNMWDZCb3h1bStNWG55eXp4bTFJSG9ybG8way9HQ2lidTdHUnJEZVBnTnAvWWpxUlo1bkh1bkR4ejBzRDVpM2tGdVlFTy9ESDIyNHVBVVNBTk9JVFAwNlVyYkhSdVVXY0hqdW4xWGZiam9lRTE4ZjJBNWxUait5bXJnOXM3eHh3MitpTHRjTVJXRjM2dDIyKzlueDYvMkUzN0NpOXBodjZhYjh5eGRhNlA0RnBhTmpTRGFNeVlpY1BWQUJodTE2Rkk0Q2dvVGR6d1U5K2FtU1FVc3BGeUJVMXJpVlc0aEROOWlEaTBNcWJ0ek0zNThObVpDZlZiMy8xTyt2enZIcVR0Si90RXVMT1FNc1F4WWtTbDkxV2dKVTZMUHNBSjNrc2F2MU9Fczc2a0NQMEF6ajdhR3FHdncreG5iQ2pGbUV6TjE2WFFOWnErRHhqSXFVb3B3RVFONitUK0dVS2pWeHBHODl2Y1hnVy9oMkY2bTNLbWhGa3B6UHE3VE0zY2t0QVJsRTV1SmJTOGt1K0RoeHpRZTZubEJLMUt4U0JDdXFSTTFzalprb1RtMW8xV1BjdzJLWGNYeUU5S1cvMkNhc2ZkaElYSURvNnBHclVhallJa3FuSWFGTGZBNzNzRlA4WWRZTkkxVW1TYVVIQ3FlWmtyWGpjSm1NaFh2QzkvTzVtSUIrcm4vOGFaU2J0TzJMb3Y1QThBNDA4ZWtGVzlsK2xiMlJEOHkxTXY3eGY4clRhV0YrWnlIVkdMY3FPdlhQcFV4aEZvUDZNU0JGTUlHVnJ3dnZjS3pTdFVlSWpFNVZVdnBiSDNCTVpaSmp0UithNGc0YjBRZHRaTFdZR1RJQVVxQkpidng0dVVzODhVMGdudExSRVdlYTNvYUFGRFVaZXdoQVpqdlhUTWY0WG1wWEMydkVocndkaEs4a0FlOXl4ajNJemxqWCtKTW1FKzVuNG9oRlZCaFE5VlJmQURobkRRVmdZSVl4aG1saXluNGVGQjhrRjFwVmZMYTZST1dXTzdDVzNTQVFXd2JkdDFJTXhDM2QvOHhYM2FMeTZ6UzVwd0RYRVFPSEdtMHVRU2grSFRjVGprRTBxNDRzVFVEbHpNcERERElQYzZEMWR4SUsrbGQrNWVTYjk1OENvOWVPVHFGRXdNY3d3TjlSTElDVk1SaXFHN3g2UjlPaThqNnlWMUtjeTZXQlhzUS9zeTBWNTN1UStmRG52a3lIVmxhaHR4NmxGWEIyZ2RuWnlnUEh2clZscmFXazhyR3ppUitmZjQyZE5JTVRNQTQzdEFCVzZGdExlOVN5NzMzVFErTVpWbWlObmFxTzJnQ25hbFgvejZJVnJvdHFNSVJoQzdqaTJEMU5DRVlpeENLNmM5cHhmVE1ic3AyN0o1WVlEZkVMN1pRV09wSFR5Nk1WdFNZWm9OR3FzVGVzRjVYUWpCRTNKdU1ZSFEzOEdKa2RSR3BsTVBpbkEvMy8vM24zNkdQNDEweWN3c0UyTnpmTWZIdFVQMkJ2cGNQaVNzQXlFZW03NkRwc0V0RU9oV1VEcytaa3oyM0JzSVVUYkJTWmhlMEJVR0grY1pJbndvQzZIRnBOQUxQazliUjJodmUvU0F0RFBWWVFUWFBsdDFEa0l6a3piVmpxUnR4MXZ0eXdOTDNTbGhaSHRvVy9LSVEwNTcxQnk4WU9TN2dpMGMxZUJLV3ZMM0NaT0V0T0sySzVsSC9sSXdRcnl2ZWM5MkZDYUFIb0xMV3JQbWxmbEczbFlRK1JhbCtIKys1QUg5U2JabFNhY3Y2Y0lWVFQ4ZEEzazMrQXU2bHE4ZFMvdG9aZUZ5Y2R5UUQvbWlGZ21hUy83V3hDeUVrb3FJY09Rcnl4Sy8yNThvaXdBVlBtSEFaNWNyTkFhb2VERVg5RVdaTmxmMHBta1h4Qk9DU2lZRkVEdHNqVmFLZ0JCNTBVazBCQkVVOFZtWHozWHMrVlZFRkZjSVBINkVYUzg4emlZVXN2Mm9XQmlFaFg5cVFHSCtXZ2wvdHBjaHBEdDhGOUUraW93RFNubCtoL29Oc3RTeTlBL292QXdCd21ENktVd2hwR3pQd1FDWmRBd1liSzh6N1hPUTUrTm55NmoxZldtU1pmd1RBa3ZYMXJjSVF0ek9ndDFCRVM1ZWR5bGU1b2VlWUhxSVg1aDRrSVB6c21EVi9ER0ZScDZ2ZUNsbU5Ja1F6UXNUUjF6cnY5QnN1dUJBQmhrYkZrSVRPRXZmLytocStzTVByNldENWFjSW1qWU9WdGhQaTB1NzZmb01HVDBKWmtYT1VqYjdnOFM5Wm9pK0R1T2pvSi93alloWGZTUXVqQmdCNzNqcGxHOFMyTmhza2lGMGdGa1M3YUxKUVJFenhGZUJ0TmpxY2tUY1Zmc09BYWFzckQxNytqajkrSHZmSmFWeVY2cnY3QkRKWGdzYy9QREhmMENNV2lWOStYOCtqbjU4OTVOdnBiMjF2MDZIK0hGQVFxeTh0ZWdubElNaTEwQkFnUnMwemo1ZzdVTU1LZTBieHEvaEZ6US9sVVR0MkhReUZwS0JKZ2UzNGxuRGVEbTJDZDErbjdBR2tyTTNXZTAwU3Qvc0N1MW9HQTMyRUM2KzJzQm5CZUV6ZHVjSTBCMU1ZRStwbmgrZjVMVG5CUll2WEhWelM1S0l3OXdFU1dXMEFBWUFyUWRjQUVPRitrNllBSThRS2swYVo3bUl0RFljQ0V0L2VtbkhiVDR1Tmh5VHdubUFIUkZYMkEzUWpiYTNlZEFnOW90VU8vaTZ1cXU5NFI5elF2ZmtIMm0xeWRnNnptZDh5c3ZTblg3VDJBckRkeGs4YUJlNDFNd2RXZWt4TnVUenM0V2cwRzlvMXRncUNRdTcyRVBtNnEvQnN3cDlSWTMrb3hCKzBpRi9JdkYxTkRyakt1OEduVXZydGtBWjd2QUZDd1BoSjM4VWNpQUxuQ3lzS0JyMzVUYnAwekZTT0JrSjhEcWN4cnJBbys5cnJjUjhvRVFEQnNkUlJjTEZnTEJ1Nkd1V0hVSmgzYktGbXBoOXBsNEZPMlBUV1FnbkJjK2JRc1Rmb1pId3B0OEZLSmlheWxRUG96d0RGOEtLZTJFcUFueG9HYmJvbU5OWnk5bEdhR0xVSVRqeHJvamd0NUk1RUJSdEFEd2QwSi9nOXBXQU9zTWZURzhIUS9XMTB6WmdiZFFSK0FWTzIzTkdaWXdZT0FZYyt0Zm1WMFcyellBTkJPYnZESkNJcEQxdWhMWWpraGdMOGZHdkFBQkFBRWxFUVZTbm1QMWtIQ3BFU2FBZTFPVFZqVDBFNWRmcDdPN1ZORFZSeFNRaS9vcVp0NHRWdURycGQrMkRwbzd2QzdldzV1a0dZTGlFTFFROWJVV0NRSEVZSkFYT2JKZ3J6MGJpUzZha0RuSERJMU1HdDhIRWxmSjUrdWFkeWZTUFBybUZFT2pDaDdTZi9wKy8vQTErcUpOMGV4N1RBQUduVUdtU0kwb1U2UXRRaTlROGRST3pKcWJqWUhPdTBvUVdZVXdSejd6MGErbXI4S2l4TmxiZzRoTmhxaWF3aWpaNTY5WVZHR1NMa2tET1hyM2xaODlUOWNZTmlJbWdXclNJTFp6WFh6MTZuRXFzTVBheFQyL3IxU3B3amFZUDUyYlM2dGs2c1VlOUVYVythUVE2ZU5CazA0bHVab0pSQWxlbmlFNnZJQUROZG5BS0RjRG5xWVlrcUFOTERlR21WaGJ4WUtDMGpaWFBJMWI5cnM5TXBULzlsLzhNd2RWTUR6LzdWZG9tYUZSTnFJZTRxaTV5WEpYd3haMmZJaWd4Y3h2UXhzNCtQanZhSGlldlZ6dlpHaXBNTUVaejJDY25iVE0zbUZGVjNnNDg4VDh6azNaRFQ0YVMxS0NmUTlvSGU2UjNQazM5YUdkVkJHQVZ3YldGMEo4a3FlSDNFZVFQRmg2bHJ3aG1CZWxvdlppcnc2TUlWQ1lFZkl1T2ZFTXRqVEh3TWdPRXEzMzIxOGxZNitaQzdnWVdLVU4vbWxmNGdPVXhhWk42RlhDYTVsdG9qUEtGK3o0VmdFN0sraTk5UDVRQjZaTDNNLzBoNk1CdDlKZGVHSEpqUDczVVdqV0xBWU5MUDlubEErSGhMN1JoSDRyLzRoOWwrTWtmL0NmTjh6ektlWjgvdFRTSlVUbVIvVnZDclNEU0xNMyt5WUNGTXZhbjRFMGg4UFNlTERlb2h6aVQwT0lNYTdBQ1h5NEVrZ0xHcXdEWVN2eGUvQW1BVGplUkpCTkVCM2t1VnJKcTZQMWNYb2F4bk00OTN6SHJZbWdjM0l0WC9COTk4cDd0T3hoeEJCZlBCZGEyTXl5L0U1ais5bmJBN1B0ZWZFcHdDcXBZTm1iUW5Ja0RkdUcwUGtFRWhuanZzcysrcWlEem5vQW9STUtoU0dkMFJYbEhkSlFnZmlPL0QvSDlHTnNUcHh3enMyempURDdjdzJkRXVTNElWMytQUXRKL2tZak1kdmh6Z0lwbGJQdEZxd3lnZ2h3OENKajlVWFo2MzRGWDJ3QldmUnFZN1J3MENwTjFNdzZINjJsLy9TVm1CU3QyOWZiMCtTT09yR0pXSGVrQlB4Q3Btb2pWaXdNM1M1ZlpZNGl1RWdJMGpuU0MwQldtSmhQTTIyQWtXR0RYRVU4UVpzV1lLdG96QzhFaFJOTFoxOC9SOHNNQnh3Rm0xUkg3Q0VzSXRUa09ubWhEa0kyd0pjZU52bytlUGs4dkZvOVNqYmlzS3F0dkZYd1pzeU5UYWVmWmFqcGEyRXpqRitVMFhlcmhsQm9PWUVXZ1RKVjcwblhNN0pzRDFYUjNjRERkWkJ2UEhCclFOTnJPTk85NkZQMFVVZlZUbEJraGhtd0krQ2JSSXNZSmlCMWk1Yk1NREFyYUVxZjhURjRiNHZ6RG5yU0J5YnJ3YXBtdE1YV084NXBGcytFd2pGY3JqTkVCZmV2SEtUK2RHbWdrN2NTRzlSOWhVZXcxMGdnbjgvVG9vMkVzM0hwakNwOU1DVXgyZkd1Qy8yUG95ajJSMHBQWlJzOFpmeldISHNaL0JNSFhSazZ4WG16dlFiSkZITEhaL0xSTWFoc1hOTUNmNFJGMXROditDbHU3alBsaWZCVVl3aGJDQlNKVGF6cEI2R3NXU2p0aEtWelNDQzFudnVBOWFWZTZsMTRkMzBnSUdXUExnZ0h3U0g5dVo4cFI3VkNRdEc0OWpLOTlrcitDeCtSQi9rV0NBTzVIVG5sS3hKbUdGQXphVWNqeDNVazA4MDMrWHZCT21IK1g5ZEdLMU1yL2VRSDRndGQ0RnZCNm53cENCa0J6dHFXdk5zZEo4a3krNVU5aHBkSmp1ZUw5RUxaVUdXV29PMlJPUlI4V1Z5R1UxQVRVck95WUJRdUJVVHkzRTNLRUg4SFlZTkIzL0N2SytLN0dZRFlWY3gxRkdUK0x1dTFkNUNHeWs3SVZ6M2dJd0xJWU1wNUI4Q3JLK3huZitiUXQvM0tuSkFQQmNoaEVIRFZUVnpGWEJFSXVZVllZKzU1dEZkOERJWFRNZTZIeG9acjVQY2NsdVFMU2krU2k3bEJqMlpyRGpIL3R5Z3dwVDg0NW1ZWFpqZTBlSGlycnBWWkViSWJJaWQ4MDlocFh0aGZhazNYelZLZ05BQXdUVUVhZ0xBRDRDamh3enlSYWdvUkZlcGo1MGE3MGozOTRQOTI1T3B6V1ZqZlN3ZEZwZXJxd2xWWTVpSFJ5dUk5VG1QTXl2SDFyc2JUZklpdUJzNmNaQkNvNG1OMUlxMlluREU0STV2NW1kZ2g0QW8raFppRHdJQndKelQ2c0V3UjZETE9Oc25uNWpQcjJTQmZUcnZaSERKT08vMTZFODlPSFg3TWtUMGdESnpaN0N2TVZWaXdycENIZVI3ZzlKSGY3R2dLMUR5MXBxa1JJQWZqcWg0R3J0RDlFRy83dXdXOVdwYjlkYUZXZGFDQm5wQ3crdzJsL1FlakVPVmxDendsQk9DVlhlZ21OaW5WTDBpWmZwQUhlN1Vkb1ZMcmR1bEpqeitBcXViQzIwdGJtVmxvajJ5a0dXR1JKY0dMWkk3KzdXOG9tSm1hSi91OVBXeStYMDhucVR1cmFiYnhlSVZSem9WZEJMOUtzUWdNd1EyQ2QwSlptb0tmZlNCTjFhTklOMENBelRNWXFXbG83c05jSmxEMXpNWU5zcDd2TnZkVE9KdlJlVmxRZnYxekZKRVhqcGY0NmZUcEdvR3VDS1hRdUNDc0l6WU14VmxobGdTV3B3Y1FTTWoxUnhiYmRtTmlDK1JDMDRNLzZYcSs2ODczQjBXSVNXajgreVZqWTRKNlRuNU5UVEl6VUtWOTdUOG5ybU9zaXNRN2J5YndnRHlrd25IU2hFOTdKd2l1QVVlNEZmMGl2QVIxd1NlVXVSSVNRbFlja1hqNGpNeThDS29RWVpjSjFBOUZudjVpVGpUQkVOY0hUOHJYOWxCZTlmQjdmYlpUTDIzRXFkWkd0SWQvTTBxNlFkREt2bDVYRkczUk1BTUxFNTFsME9qU2FESmdxWjViV3ZFTzUwSmJBZktpNGw4Q0VVQUhoUWl0S0EwamFjQVhMTmtLcjRyZkJkREwvMzlleWNtZENhQW1YQXdkc2Rpa1FkOW5aME82OEYzQWphRUpZcVZsa0VTWU13bDVFM2hkYW9MQTRXQ2J1azVDUVVJNHQyQU8yR0ZjWkdoOEhQNlpHaDlMMitrWnE0SnNackF6RlFCcFAxSFNabnI3WTUrZzNuOVlWOVYwaW4xL0Foc1lsVmVieGlMNUxFZUd6b1IvaFU0RVF5aEJ5aVZOZTd0OGFTWC8wL1EvWk50TVRPT2F3bHZUYno1YVpaVm5PeDEvU0JlNWRTRkRRMmM4R1FWUnFTemV2WDBrNng0L1pXeWdqcXNiWlI4Y1dBOUFSSUJzRG1VaFpRWE1DRWtUVDFaemp2VjdkT2c3dHFrSTR3S3ZuejlNSnkvTnpoQTZNRURocTJKWjVweHpuVHJTUHBiWE45TTc3NzZidi8vakgrUFpZdVNUTVlXTUo1L2I2WVJ6Vk5Zem0xSzJUR05nOGpZY2p4MU1IWm02WlQxM0daenI3RlliZzBCT1BoRTltYXVNN05pZW1JeE1wQVpqdG1FQ21tOUVrUTNLeWtibVVmdlNQZjVUbTVtY1lENFFWWStVeFkvcm81cGxVZXRCcURIWWFHNTVNaHlRUDNGbGNUVjA0Mml1c0VQWXl4N1F6WGswV1B6eVM3RVNhUUZKNWpKdDQwditKT3hMM09VSU1HR1ZpdlVONi9XSmxUcTBHbFBid25pYzhIWjhlcFluclUrbmVOKzZSRFpWVjAvMURmSDhuc1I5UUxiVEtsaWVHUFV3ZEk5Wk5tUUlXYUlvVlN0cHRCdDRaZXdaQmdTWnR5UGdGL1lZL2lMYnBPTEM0VjA4NG5QYjhCRlpNWkgwK25nRXBQNGdEL1Q2T3NZa2I1WXQ0d0IxNTFaOXVwdmR5QW5NZmJ2QTNmQVhwWmY2UmZ2bmpmekhXQ2hFRG5lV1pzSW9vR1BUTWZaK0ZyS0NrbHpEa1dEQmZGMHI3QTlXQlIzay9DMGNuU0ovazU5Sjk1bE1GbHZkb2w3NEpGOHlocHA4bG04eHFRUnRWSmZQeXQ4OXRUR0kyQnNWeXZpaXlaSHkvMjZLbVMxVEtJSVJrRkVENUVZUVpNZTR1L1lDWkYwV2hDS0hHTUtFa1R1ODVFQ0VrR1NRYlVPdFNLQldYOVFxTDZyU1gvZlMzL2JKMWcvQzhxNS9EWngwd0hkb24vUWpSU08wS1FPc0RzZlpUK0gzZmVuM0J2dElkbTdlTU9adENyZWFtaU5aemNkSEJ0ZzZXcTlkV2QxT2ZEbHVZck9OOG54eFUvV25ncEpLZTZHU0YrTjNVZTg2U21OcUtXcFYvMXRYaVU1OVZiSFRPS0FJVzhNNTNNUURHWTNaSERrRmtSR3ZUYmgvTForM3REVGIxTHFVYWp2NTJtRkxCaHNXYXBuSHltdks0S2JIaVQ5TkpEem16ZE0reS9DZ0w5a2FjNDlmaE1iNFFFOS9CZkRCOHhOVlFnYm05Qi9yWmI4YzlBMlp4TkVXRSsrNCs0UkJvS0taWlhudnhPRFhaM3FLR1dkL0NCTHMrdzR4K2drOEkwMnFJRlRtYy8wZnNReHdnKzJnRmgvc2VXVDlMT0lBLyt2aTk5T3Y5WDVFdW1EMlh3Tld1Z0FvOFMrUnFyam1HcWM3NHUyc2cvSDR4U3VCQkljL2doWE9Xd1RGZHNrNXV0MHkxV293bms0cmJjS3BzMGg1Qjd4cnJIVTh2THg2bjNmb1dEdnRhMmxrOVRZdXNscFo2S216cUhpQjRjeTg5ZlVKbUNUWkJ0eDJUQllLZENWM3NDVVZTS3ZwWUVVVTdzbTNnYXdjdVZ4U1BFVEtIREV5ZGNpMWdNUVZQTjRWTDBGTUxCajlrYkhhQmJSQTY2RldyaHBaNlllYjc3N3lUSHJ6OEtuMzUrRGVwd2tDMHQ1R09HUTJvN2hqeGpoTmxHN2h0dzE5M1FSdE9KRTNvd2tNdVlyV1p2cHZCSXZ5d3diUUFDSEdFcTBCNkJrNjFCaGQwY0FDeWNKRjV6eHoxbTJqRjNkMTlDRWZQdjVhZnBXZjR5TVNUdWttQ3h1Q1BvR2Y1dXZEdjBnVHRVb2k2b1RjRktlODZVdkpWR3hhR1BLSzI1azRQVmpiQUVVS1FoMmJ1OVhLQ2xrL2NkdGJFeDZzTFJCa1NiaHBtT0gxUzUvZ1NRUy92VXlubFBUZmc5V0lmZkdZK05uOWJsOEl1QkNEVnUrZ1FmU2xNd2tKUUtheVVub1Z3RUpUQW1jQUVvL0diRzhCTzVkbXA2MzIvMnhuZnl4SXhkeUxLd3FoMlhhUzdFcWh3c2s3TGhyMXRaZHpMRGpvQXV4UXExcG1SWkVkeWZibHVpaXNnRlRpWFYwaHJCUTdGWkdidDVPekVwbVlRUzFPQlRKMmExQ3AybzJ6VUd1MDdOSTVWN291bHNrQnpEQkd0REFUVk1IQTRpd2x2Ym1HcTlESWdBMndJYnJHSFRpZTJ6THZOYm53anBNV1F6S1VBZER3aktGYThVYjg0empGSTNLZWNkSmRWWmZ1TE1JS0FBUi9aWVR3Tm1ST0lwZXJwT0VaRFdFa0g3SkdyNGcvWjJ0ekFKR0kvNFBBd1JJT0l3cGw3WXJBb1cxRkU5ZXo4TUllV1RoRnQvaXF0cis5Q0tHaHJoRHlFd0lKaEF1OEtOdko5alZoSGpEbXBWWENtYXo3V1VTM2E4U2xKQzV2cm03R3RaMnlJbFVqaXZQb0ptV2cxU1JUTTREUXc5ellKRVRCRFJBdXRiZ3QvMGZibWRycDZkWWFNcHhNY21QbzhkUkduTklCNXEzRFBwOEJnUmprcjBFL0RTS1FKelpXWURNR1ZRajYwQXpyaVBYRWp2R1UwRWNNQWZONEd2czJuYms2dmwyU01XSHExbnJaV053bFkzVSszYjkxZ3BiR09vQ2FJRk8ydmdjbjI2dFZhZWtrSXlyNEhZS0NkVHBEajNaaXBObUJ3QzlLWkFhRGcyN2dsWkVpa1FTYVpjeHdqWnBwa2QyTjBLY2pvODdIQ2hXZWhKYU1WOWNETU91UVI0ZWtVL093UTF2QjhjWkhvK2hrMnpSK25WeSszbVR5R1lxeHJwaVFDSG1taUJsTWZvVEZHZmkvSEhicUFnNEt1blZnelhRUWxCZDJJQjBsVnJhcndNMlYrNEM3MU9SNmV5S09RcUVDWDVrL1QrWDQ1UldlYXBNL0JVOVJqSGZFZWZYYWM1WjJJT3M4M1F3blFONmFHRmp6RC8rVm5hY1YyRlZUeVJtelJDZjZnckdQRmMvblJYUlBDYzRFclF2cDNCZHdtSXhaTGtjZzdka2lleXl1RWdnUHRVMmM4QXlDZldVYjZrSmtpdmN3bHp3ZFMvQjZDZ3NLaGx2TTc1RGN2U1R5cXNkU1htZC9PVys2TnY2SXVKU1N0YzBsMGZsRlMwR0dSN1MvcWtDbFZVKzI0dWM0TElSWVNtOTh1OFdZVkhRb1Nib0VYcWI1REhVcDQ3a1NuYUlWblZFcW5oRThFUjdBYnp5bEoweEFDejZNSzNoTytNTCtZZllUSk9tM2ZpbVBtQUpuV3JWYWtDU3h6K1NmUmFFdVBzZXJqVW5JREo3VE95MzAyQnBmUGNjSmlndFRJTGU3U3V0RHhGcS9SUHhqTXVDdG5JR2VsQW5ZYkRQeGFobi9aVVpyeEltN2FtWEVteHZyU1IrK3o3dy9mU0pNdEpSWDhGSFg4SWxVK0Ixa1oydDFCV0VHa21neGRISTl6OTk2Vk5EdUh3M3QzSDRZNXBIOW9GQ0RicElRdHpLVVE0QkNRczVhd05TSXFIaDhITS93UksxMXFsbDA0eUV2TTFOMll1OFptbWIzaDFyWEpWSzNTMTRNTjhNQ3kvZ0FPZHlLUmFwdzFlRUhxNHk5Ky9YVmFSWGlNVFF3UnhyQ2Z2dmpxVWRyR3lUM1FoVUJFZzlMY2MyV1N3UTRDRmIrOU9JbkZrVXlzQnMvUVFiQVVZVXpDcGNDbjIyU2tIZjJkRG9iL3BDZFhFK3RvU0pwcTJ4dWJtR1NjZlVoNHg1V3BHZWdMZUo0OFI3dGl3elpPN2dhbnNwNmRsZEl1VWU2VkxoWVp5RURSRFNPWjMrcUNZTjFPaEhRbitITUo2WmpQQnJBY2d3L3p1VHVPSlhHQ3h0d1A5UTZnbFp5aS9RWi9RRmVIdER2RU9PanZXa0VEUG4zRjVEREFpdWcrSzZrcm01RkhyZEpESG55Z1BzS1dMN09vMFlQbTFVSnl1cFhIa0pLTERsSlpRMGNHMGNvNmRqRldqNkUzYVZPNndXWE5jMzZEZzJEa0VQYjhSZ3I0aW9lRWlOOERmSUFIQjJqWFhRTmgzYmg2TFMxSnU4RWNRV3ZVZ1ZDaFcrQUsyZ3RHeXZXNm8wTCs4Ri9FUWxJK3JDNTVRajZ5TE13U2diQ1VNN3VKMjR2TVlPTGlVanNUU3c4VG9YNWRyU0ZqejFyU0VGcWx6eStrQWJEcTZuMWhNdHBIQlpWYVhtSHBSYitsZzB0WVZGQmk4N00zbEdBeWpKM3l0MWNnZ1lvRVhLbHFoWmFSbUxJalQ0MG1kMGFKRzlLZThvWFV0eHBOU2Y5NExYZlFPdmhldEtHUUtBUWhOM09qZklRWlZ5Q0g5a1R1YXhYNThoMkoyOHBpQmdnaGhCU21RbjBBOUp4WkdsaGhTbUUxaUZUNE00eStHSy9HN0JCc3dqc1NmbUVHTzBEQ0ZYNGRNY0YzeHhzZk50a0J1dE43WkN0d2Vmd0VqV1I4WkpRQmFaTFFqMndBUERlb0wvYURJZGhjTmZTSXJCemRiWDBVd0VjQ1hZSnIxR3ZhTEJ5UzRUK1QrSHdmZUNUZVhyYVhmRXpjMVI5OS94djRlakRUV0JBNEkxWktaL0lZczdZNGFKa1lEZ0t3UG1nK3pjeVNKUlRpZUF6RDd1NTdrZzNPZXpmNVNpVDgzOVhDWWN3M013dVV5Zjh1RGhVWU8zdUVHekEzV0VaZm1PZjU2VENtOStuKy9idkVmWUUvMGhEWGNJSnY3dXhGcnFkek5DYzFua1B1VFU0T3BMZnZYNDMySzJpQmp4NHNwT1VYQjJtaXlpb2VtazRKSERLUEs2KzRGRVF5QUQvQW8zaHoySnk0SUhrZ0JVZDhOK3pCMlZiVFVEcjBWV2swc2lRd3ZpZjRzYnI2VHRQb0dFS0E0NzRteWNOVnFYWng3dUJnYUx1SEhBWlJnbkdKZ0NYUWQ0dnhwWDM2NkFuT0EvaHNYRm5yN1NYM0YrUGdHUGVTTzZzRXJLZTBxd2FuSnFVSnArSktkQm8wREpQQmRGRWVtQ1BxbnI2WWFmUzB2Wm11RU1qN3diYytRQUFodk5qR3RiUzRoY04vUEkwT2o4REFhdDVvYlN3dWdFaVFyTDhSQWNrcUkxRFJMMzIzbVdIVnNzVnJDR25SeFROdEV6VWNCYm5DWGNyM1A5TW95eC9lNFFVbW9WeHUwRFJCb1dWbE9SV1RNa1Y4S2JRYTZwQVB2UjltV0lGajNtZG9vbjdieU5xUmkwRHlMbi9nU1plR1B0Z0lmbVk4WExid0VKSVI5dGoyc2lMcndTTU5lRUwzUS9od2dUTmJXL0FRUENFZk91alN2dU9yUUZiYnp0cVpQQXV0VWliRElmekNpQXd5ckVHQXZSd00reHlWZVlQN3dlQis5V1dBRkVIQXlTTm1rY3NVSm42MzR6WVNnby9mR1M5S2NiNEZUVXBxMGdSQ2dYS2hQWWhrcVpRT1c4NTNBcEdYd2tsaGtlMTFFV1hIbktPQXlRNENqKzJIVktZQjMvZWVBV29DS1l4K3htb01zRmx2bUdKUmcrM0lCTUxpNmhrcVByTnQyTTJVODFrSVZQdkt1L2s3OEZrSDlYYXc5YVdGb0ZwOXRSaStIMDAzKzlOSEFydytWUEYrWmxjUEpOVnZaL0wrekZ3aUxmZFBMY3JzQy80TzB6WHdFRWlsTFFuWGxTREtNUE5WU3VSVkx6ZGdzS08wUjRLK2daNUJOamdmSXJEMll0dkhHVE9iRzVKeE1FRllNQlZ5cVVHMDlSR3JWdHRvVjAyV3l5RXZ0dXgwVTdlemQ4WlRINzkxem9wTEJheCtJVlA2OW5MUGpLU3dRVnJEdk50bk5mSVFScXV4ajNCL0Q4MFJvdHBHc05YWk0zaE9TTUFaMjBwNktiKzV0VVAyaGh2cGYvanpmNUtXVmhiSlZuQk9GRDA1M2wrc2tlQ1BaWDNOUzJkV0pnNEozY05hMjZqTGszNUFNeUlLR3BKUnhMa2tBdzc4a3U5bllSeCtOOTQxVUpGQkFnYmludGpFL2NGM3JxYUphVk14d3doZDdNMkRlUTRRQ212YlJ3VDlubkV1NEFXcnFacXRkV2k4VExZR3hoc3ovZ3lHYWxCT2huUmlrVWJLaklYQnY1cExXZ0FLU2YyekJ0bXE4U3NRbkxDTitIYUNjeHc5NWNkZzNRRldhMy8vQngrbmR6NThHeHl4OVFtU1gyUGxzZzgvMnZUVUpEU0JOZ2lkK2Q0aHE2TW02bFBRUU0zRXBCRXZScGZWK3VVRWV5N3pNbUQ4SjRib01wL1puSEpDTkVzSzc0SVBHVXp1TXZPQ0U3MDBMVVNEYk52cE5rU0Y5alFOQTN5ZnlTdjBOZmhXNFVNZi9SNjZKTlhaM3hBT1FleVhnZ0o4MEh2SXpKWXloQXFlME1Db3o1US8xMjllWjZjRGFaandIUzh0clRQaHNab3NuUXQrd0o2VkZ1dU9TUWRZaWxWemZkM0NrT096S0s2TWtEYmhUWHNZaXh6QXdHS05HcFhqcjBZQmNWOVdUSmtBMEU4WlhXRVFBK2owcUpTbjNHdEU4c3p2SWR4b05BUURkWWFQaVU5WlJnVFpVQUFsSXJqdlNvVkN3eC9obUtPZVMvVFJOaWlucWRpNndGMEh1V2d2anIraXZ1SjNqTFM5OHA1dEFTaE5YY0pqRC9JZ01uSThreEFWbEpSaEZuQ21ES0t4RDBHZ2w0TGIvc0hJc1RJRFVValV2cVBxZTBEa2U0MzlPRjB3M2EyMzNpSjRjU0w5L0c5K3htQk5wRjF5bjZzTjlLQ0pOQ2dUcm5GWGYraEwxRUhQQ3JnZGtDeEU2UzN0dWFIWUdRd1FRWWs2Qm9OR3Y2NWZuU1VIMVZCYUlLeWd4YkxVTGtuNjlIVVpqVzQrY29sRnVGeTVjOFoyVTIwVnJXWm5qNVZCWW81R1dWNVh5enJCNFdrVXRPUEUvOUx6NXd0b1dNYS9rTUdBRlRoREdkclI0TnJVNGlEOFhzSVR1akRudG1IMGJWWUkyOGhNMmo4NFNZNHNaa01jcDJVRTBnSW1ZR3c0TGxYb1YwLzYrYysvVEJ2ck5YSk9EYVdwMlprMGQyTTJMVDFZakxUREE4QmduSmphaldtUEdhSXdwNEVxZnBpVlFvRVZ3aXA2NzlESkpwbEJ4SmZPWWpYV0lxMXdwVnJGM0RhQ2ZRUC9XNE9qdmNna1FSeldJZWI1T2lFZnV3aXJPdGtzYXZqUjJoQ3VUbWh0K1BKT0dmczlCR2FkZm0rVEc2dEtOb3BCczZwaUk1a3BvZ2NZMndsMFZSczlJR0RWSThVaXFSK2FzWXNkK0g0Uk9OSURXaGhqY0lpbU40d1pmY3hFOXZQLy90L1NvMWZQQ1NobXpBSC9ERk84d2YxR0V6OGtndDlKVktlMGsweUZOazIyR050ek1GM2RPeHFUQ3ZUZm9RU0RSK2cwR0lBemxCWFFTZkNqOUFzZVF2alFpUFNsNXVkTXpTTjFNY3o3SnBvMHVmZDlEZTA4VnhCRHp3MWU0Q1Y2eXcwZUlkRDBFL3BUZ1N5UFo1ZEtGbTQreUJaSEJzbDIzZnRvempRVmtBRzBxdm01MmJSR0xOd2VxNk9lcytqS3YwcEZDOGFLSU9XQTMvY1ZwOG9KNVVZV3pQWkpJU1h3Q3RqZ0RiNjc5VWg2VmJDNVE2V2pyOVQ1YWJaTE15UFpXUm16RUQ0U1Q1YlE5aEhHQTBsUnhrNXgyWWszUDRNWnZIL0pmRXI5dklScWVabUo4aUtJZWlrbC9nTkpJZEQ0R3BWRHBMNXYyNXBTK1RScUJSd2Q1YTlvUS9OTjVvK2xXejU5Ym1YQ253V3hTUGEzMVRxUUlNbkdLYXNBelAyS2g5RnVtTU9VVjF1eVhwOTdxZEk2ZUxGZ1FMQ2lYWGNIL0NDcFNEM3E2dm56RjJrTllkTGZiN29WWms1V2czVDBxdXBIZWd3SGczcnk2Z2NFRG1IS2NIbmxJdzltaEJKUVJuK0VTODJhU3NaUURiSXNkWFdxRHdjN1cwUFkvYzg1eUt4UTdnUnVob2Vyc1JmUVF5R0V2UmRHUENFR2EzaGtnSVNEVnpEYmRqRS9XdVNubW9HWU1aOFljQ2VJSHRTdzJCek9hbzhhbnB1WTlXVzU1ZU1DNFNxZWp2azhKY1Z2ZTNXQ3MvK0EzZXdOdkh1ZGVtZG01dE5ERWdWKzhYaVJtS3RSekxDclpCemR4Znpad1crREgybGtuS3dPbGJTd3VKRSsrL3d4R2cwQ2dINE5BVjhQeUd0RHl6b0hUalhOTGdoYUNqS2R0SGlXbFBrSVBMaTlwdEFnUEVsYVJ2Y3NQMU0rQXppaENHZ3diQXRhNUc5dEJ3R0FablRPM3hFYnFWc0lyRjAycnA4UzhZNUlSMmlBVC9wbGtLaEJyWkVqSG1wUUZ6bW13VzAwcm4xZ2lIUXkzR3R4VDlxck14YjdDSnNhL2hoU1cybk54OFJteUVPbllRQm9lMUFIOS9FZEhkZUl4dDhqdStrQks0d3Q5blJpQnJKNHNRdDgrbkVPOFMwNTlwNUhHU21VYUVkdHBvdStTSTkxeHNFRkd5ZHRKMUd0QytsUW9TSy94UDVkUHJWS0ZCaVpwa0ZldkFHODRGUGhGdkF3Z2JWQnM1cityaDU3WmlLWTVjLzNlRVdCUlVseEduRmJ0Z01zMHBGWEZMRXR2OGNMOFNVTEV1QlZ3TVJxcDdPOENnejR1c3ZrZmV2MmJRcVM2dWpCRXpSSzZjdHkwRHp3NUFrYWhVQXJpTmZNV0Z2SW1lQmpaSXQ4RzlZWGZRbFpZVytvMi92eHpGWEMzQW1aSEtMVkNRMkFOdVFsbzFtcEdoQzlnNEN5WlBSWklUajhWSGdVVndBQlJJWFdGRE1qNzJVa0l6V1JySm9pemdaZUlsaXA3ai8vVXdQU1p4WS92TTlmNE9VU2NXb3FZdDBPQ0d1RzF6clZncXpUZ1lnaThjellNR05Ib2tjTWlIM3pIVFVSMjFNdzJuYnVLeW93UkJqUEpVNmhvSC8rdVZDZ05rUHR2Sk5ucE9XbFYybG5leHNmengzeWVSUHB6RjQxZ3dNOVVNQ0VoVDA5ZmRqeVpyUTBqZ2ZDVnNXOU5CV2RQZXlTZUE5Y0ZnUkhZZE1aRys0d1dlMGcvYS9DYXBzREpUZ21IbzFubWRDSjBDSmhSWjNXMFI1RW95a2p3L2ZqQUZialdtVjFVS0x2dzBUVkYxSm1tMUVrbm9NSjkzRElheUpXMmVOV0xIRXI4TTBISlZBTmNMTkg2SGM3SzMzOTQ3UDBwNFNqbnpQMXdFMFZaL3NHb1F2WDd0N2hjSXA1TWdZTXNmbDVKejE1dklTZ3JtR2FWUWhsMkVuLzdlZWZjV29NWmhqOWNtdkxDSDYwYnVpa2hMRHZEb2NyZ2g4OEJoTEFjMmdMam92ajRleExYNWkzOG5PWmxHZU9uYmVNajJxaWpwMGdjTXY0VGhRbW02d1FIckpTK2NNLy9GRzZkWmZRZ29mUDZIZFhtTHNsS2hwalFhVENOaGRERDJ5MmlmU3A0V3cvWmd4cTRLY0diZXpDWkh2Z29FbGJUY2E3VHJ0dWZFYk1BQXY0b2MyV3JLQ214cXFoZ2tmSGRZbHRUZGR2VHhQYXdXUkFhSWdDL3RuVEZjNW0zRS9EUlBLYnhLL0ZpaURVallhbzN3a1RrSGRsZWpWbHZvYXc4cXpHQzNEVkpvemdRVjlWN0VmMVRmb3FzeGN4VkJGMHpIczZUcVJleFpHVGF1WUo2UXBUblBIdHdVK0hDS2NHVi9BMEkwR3A5VEV1ZmtybDByY21xSDlCN3p3TGZ4TGxGVWJXNllTcmNBdnRDamdWcXNJb24zZmpDcWtRSGlOOXJ6QlJlVkNKZFp1YlhuNVh3NklKOWxIcXlyRWVlU3EzTHUySElrRWJNY2JBNEVSVmFGeHErL3AzemVpTFNXaURBVFVWVW9rRkdUaUZnWVRocDVVb2VhM2VNakhUQmNDV0IwbVh3c3J2SVVRRWdIb1VCRXBMdFF3UkdnUjUrWDRjVUVHN2xxZGdSaFJsVlNWdHVkQnlyTnU0VGRPS2hIVUFER3B0WGlIZy9FMkhST29aUkpmVlRHN1N0Z2dWNklEUGZ0Z2o0ZVg5UUJqUGhEbDhFM3o2anIrOUhJam8rK1gzRXdqWFZaaUxZQmhtYk1DdU0zT2NvVkhOalE2a1AvOGYvMFVhSnVicC8vamYvejNDUkJLQU1KbHA5dGxudUUvZUpaZjhyVG53eDZDTDIwaFFLRnlCZHlPUjZWZkE0UHRxZ1dSVklIdm83VnRrOW16c3BHTlczRHlGNVpRZHpoMDQxWGZ4SlYyUVpWTVB2cE9XdUt1eUFYcDRlSXk0cUlPWTFYcklMTHFQajZ1M24yVnVZcVA2KzZ0RXFKZlJpSllSaXF4MjRpUmRXbDZscitDZFRwa2x3Y25rRkEzaG5FU0Fwa2plMmwxSmQ2OWRpOU9qMTFZWENMTW9rWWVxS3dSMEM2Ym9KWGl6cDdlUjd0enRUKzkvK0JhYUJ3elhQcER1di9jV0RQc2c4bUUxOGNVZFkxcFY2RitQT0FhZmpvTmo2a1RqS1RtQmVSR0ROSUc4OEFIcHBNNU1sZWxRR21TOElGNlo3NWpRQ2hNTDNuNzdibnJNM3IwanRrbjFrZ3ZySWRIM1Bad0g2RGFWR2l0d1ZZNGtLNVZnWHQ2TFZTdmFoUjFqTEkrTnNZSjJQSkRWbkZMblNKTjJoRDNuVjZST3BHSW9BekNXV1VqYk1BR2JaL1YwQkw1MVVDbUExSlRybUhvM2I4MmtiM3o3RzJsa3BFenUrS1cwc29aV2hVQ1VOa2VHeDZtSFdLd090aTdodXpLaVhSUE03QnpHSVhXZmU4U0dZUkVLTHpRU2tPSktuWUxBc0l2UU1yVUhnUVBTNFowc1lDRDZFUGh3WGNTME9USFhnVjkvckR4clZvaDlkZzVVMlNDZWR6YklFekFkZFlibHhGaW9DTWdrYXJxYW9ncUowUHpCVUtGdFNROUJvOEc3K09Db054UWE0UFFFY0dYSStOZ0U1blU5L2RWLy9pc21LemF6ZHcwaFhJMTNVNWxCSTJaY2JTdjI5VHA2dEIyOFFEdlNmTGJjR0YzaFl3WUltV09mZWJGUU1LUUJUTUxTcDFZV2pPdnlNVC84WGpDcy9RbWh3aWNQWWpiSnFscG1Qc3Y2cDVNU0dnenlDazJLVHZpdWYxNVpneEo0L1NnS0dBZE42c3h0eDR6cWRKcHZXVGxmc3hDS21jaE9LY3A0SG0wcStmM0JvQ2x3ZldhN2x4VnlQd3NzeTJSVEF3SlVHRlBBMXdRc1pzZXN1dkhUMlFtWVJKaWxnRjkvaXIraUx0Nk5HWVo3RVZlQzBPaUhFZUE2MG52MHNscVUwc3JTQzViMVg4YU1lTUVzZlFGUlgrRDBwZ2dwUitCQUhiNjBvNG5yQ2xUMEVEd0UwZENRaVF2dG05emF6bUFab3RCTnR0TlQvR0tueEgyNWJjWUVmV2FLUUdlRTVaajUzZW5QUDUzSlhoNWllb3BnNkNMN1poTXpxc3p5ZVJQYnFaMndBc3VGY0NPT3JJNzUwc1YybnNtWlNSem1tREdldE1PNGlKZ09vdElQY1pTbmpwNzA0VGMrUm9OaXhlM1ZxM1JuZGpyOTNwMWJhWWFBVExxYmZ2cFhmOE9HM2xxYW1leFBnLzN0YVk0VGV5cTBlL3ZHVFdLZUNDbm9IMDd0K0dkZUxaUFZndFdpWWZZR0RpSXMyYlZDSUNOTUZ0UUNWQXlJNlp0aklyRVRQRGY0TUV3SW5QOCtWMU9NY3dEQlU0TStUMTZmVFhNY0VMSkNZcjdmdnFBdG92MXZ2alBMbnNJaGp2UGFUMDlmcmtiT2RUV2U0VUUwVTRVd0pqcjdiUENmNGZURjlsUERqcFZaL1NTWTMwM2FPY1YwUGtOS3NUR0lUZGVFZWFBeDFJSDFCUG8rWWx4MitMMERmdmVJODZxUjZVSmhWMkozZW5XZ2c5VlJUSFJTTVgvMTZCSFpQUmJRdXRpVmdQbko2TERwbXNrR2VtZ2dyQUFCT2tCVFE3RG8vL0VJTDdOc2FINUdMQllFNFdaZmxuSUN6NGpSK1BTY1RQRU9pQ0dNMVpZMTAxMDFoTVZENEpxT3gxMVcrdGcwQ2VXTUFUVC9ibkR2S1VPK0Q2ZUdNQXA2MXo4R1hUbHBPRUVpQWpNTjBvWldoSmVDSlRSYjhKT25ENGRJTVNtOXF2RjJoRWExdExTTVlQYUU4VzZjL1gyOFIvb2RGbkcwbG5UT002b0V0VUszakdIZTltYnR2QjBNd0NmbHMxeWdmc2JMeFFOYmN2eUZJUVRXVUYvZnB6WXVvMlFWVDZId082SGxmUmsxUzhQOElzWDlqM2VDblczVkh5RnA0NzYvNmF6dkFBK01rRmN2UXVOQzBJVEFvYURQUXkxRTBCaHpJc0U2bThSOVVPT3NFL3FXMHdyUDdWZk1PbEVtd3h4QzcwM0JSN2tza1hNSGxkUmhLbEtYeFd3djRqOUFvak1EOU1KdmhwRzZ6eWdRc0FHK01EaXd3cU1LYXgxWk5aWTBLRXg5K2g5aUV5ZWF3UE9uajlQT0Ztb3d6bGVET0J2NEsrcG9WalNCSUNJU0hZWkZkdEVCeU0vKzh0VU9nVzNhcGwxeEVlMEpuMHpnTC94a09NWEgwZHp3MnJJMFhnV3dUbnhZbXpoa0lRWk1EMzFwSmxnek00RitFbm9CdnMxbkRvejJrUldiVTVrZXd0THhXOE1VMU1jMlBOZ1hEazFuNCtYbC9UQ2JGT2lhbGFaYjF2eFJ3QTZOVHFRSmZGSkgyMXRzRTBJQUVqZjA1YTkrQ1c1S3BGaWVENU8wd1lid0ljek9MZng0T3h1N2FXeG9MRDE5L2pKMUQ0NmxzWmtiaEZlOGpObDNHT1lkUWhqMjBrNHZOT1VrSnhFNlkwZi9uWG5BUmVDR2NmT0w0U0ZtNkRTdWpVNmlwYkZDNjRwb2xTUFcrRnloN1FQbzlRZC84cjEwL2Q0OEIyQVFkNFhQN09YaWVwcTdPcDNlSmRIaFFXMlhqS2gxMGlMWFF4TXBuUk43UldnSWF4QXhscTU4T1JJS2tZZzBwMm5IQ0FURmJ3OVlWWEFkQXVjeFlCd3ltVFRab25VT0xUc2VuV2daYkg1RWFMV3g0TERNY1hCa054MGFqWkFRTEV5WUQ0MFd2Smoxb2gxTnBoUHRWTjlYanNXVFBqUDlteTdHclYxQ0plTkxBV1hHVVZEY3FHNHNITTNIQlAwNk5FQUM1azlhMVJlbTA5NkVqWVpaS09aMURWUll4WFgxT2xhZXFjdmczYUJ6NkY2ZnFTYWJnaUlXSlBodXUxNHFBTHBTd2tJQngyRWlLdUFjRyt1aC8zbU93NXBBd0hyU2RSOFRWRGVwZkF5TFVXc3paTVNWUHYya05CVjByVnZGVHNWcXBud1cxVW4zNElGMnZHTDQrUjVCcVpUeENwNGtGdVhUUW9QeVJrNm55Z3VYaFN3b2dKYnh1WDhpS0FnTGphVFFha0p6Q3NLamRScXlXWVdMblMyQXlJS1ExNzBYRlVNZ2xKVnBGWDQ2aER0eC9DcElKR0wvYUNtRVROVEpTM1lrbUp6NzBiYnZVMDYxMWZwelgwQUdiUVRNdkJEdGdtRUhpaG91NitBKzdjUTd3c3VmRDNML2tQYkF3MDI2U1lOY3pqNitIVWlGdEVNajlCMHVpZDBrYWhPWVZ4OTkrQzVNeTFJK1RuZFhtSTVZS2pya1FOTTRHUVU3M3VxYUNBbkVLdlhiNTJpR1B2cWJ5cWhUQW8xVkd4aGptdlRNSDkyNVRsaUFCNXVPNE54bmsrOEcvaWRnejdBUW13WHpTM0Q2b0daWXNSekU2ZDVnOXU5amxlK2NlazNmYkRCaGpiOXVOQnhWZDZPZ3pSNGdrVzBSK0ltT2pQQjE5a05NSWx6MVdiVVR6S2pnV21lZjROVFlXTG8rTjUyKyt1eTNtSk9iYUFlY0tIVHZIbEgwSzhBMWhqQTRpTnhQNWM0K2ZHYzdIRm94azBhbXJxZlBIaTZrejRoMk4rcS9HeldpQWw2N0pSOXdZT2Rqak8wM1ZLdUdHWk9MRE13dFhzR1pyU0RoQlh3ZkJtaTJvY0VOVExBQm5GenR6M2ZXVW9sUWd0N3hRYlFqVmdnUGlYUkhJSyt1YkNPa2pzbnAzaDB6L0I0eFlvZWNuU2pkTkFpOGJlR014MEpsVlpVK3duRTZzeVBpSGZ6bHJUSFpySkltMUtEb2FqamoxYnFhNEVjZkZtZkRvZzJ4NFp6RkEzMkJWOW1VZnBWVU9uM1FnU2JiR21FVW5qSzlSL0NvcGxhNE9xalBTSG1vaXJIcndLUmtWeUx0bTNWQk92ZTRPRmQ1RmRLR0dNbW1JYkI0dzRuUk9RanVqM0hXaitWTHB1SFJEK1lCRi8wS0pXU0JIamRVZS80UXNPUUVVOVlyc015TFppQnlZZXJKcGZKZEJITVd2TWJiVHVxYWFQS1B2QzlQT0xrNEp2eWtYakVKRFhQUHhSb2tPNW85aXhLc2ZJNk9qdUoyd0c4ci9UUFJkeUhVRHJFUVRqQ2I2VmJ3Ukp4cllBMjBxYjlZTmxKTTJrN3dJVFh5OC9WMzJ3dytCUjZ5L29vcUFmRVYzcFJoZUZIZXRwRGZCVDd1UzBpOEpLYlViT0pkVlVMdUZTdDE1bkdLMVRyZTk3bXJIeTVYZTRWd2NyYmttVzFaazBudS9LWFBLZ1FqNy9pcDltS29oYk8rbW85THh5SW5NaDRLSC8rcy8zTDQ0eDNmRTJhWFA3MkVRL3k2T3FielQ2ZDU0SnM2TFdmTDJUK1FIMENEM09NdTcxblE1eUV5NGEwd2FibXY0SEpxVmtzejBaeXJSVG9NZDFoS2YvL2V6WFQxNnZYMDZQTmZrOHQ4bHJlcGhPMGh3K1BkYVdYbktQV2RkS1F0TnQ2NmFxWWY2aFFpRTcvYStCSzVNQ244SWpBUE5qVVhsMlN5OFB4RktwT3VaR1pzTU9LR1RMSjNnWFp4emphUVRyUWhDYjBUNGVnUzgveTE2OERhWUlVT2dvRklqNG5zTmp0cU56T2dHbjRWSWRZZ0VyOTJVTWZ2TUp5NjBZeTZ1N1pvcHdlaWNpTXdxNXpNOGhla1kwWWZTRk1JdFlFT05rL1g5bEx2bGVsMDk5MzdtRjJUd0ViaVByQXpNVE5GVlAwRUVkMnVvcmFSRXRtREowcnBPempqUC8vaXQ1d1UvVVVJYUplMzkyQ3ViV2I4S2xwV3AzNGNHS01ZQjJsSWs5UjRLTWZ4bFBHMlAyNHFsdnc4enFzNlBweHV2WGVQakFqNGtkYWVwL3NmZlRQTnZYVWovZlV2Zmt1MmlPMjAvWHdIemMySWNmRENCTGJFZHB3emZGVFhibDNsRkdxQ1F3bWlmVlZieFBiS0c2N2JvRTFEWkF3MFBrZDcxSnlTQnN5MktqOEFJRXlwVE5HTVk4eUE3UXdlTUplWDNndEtCRDFPTVM3dmZYUS8vZDZIMTFNZERlKzQvblhhM0Z5SkJZQVJCTDJyWm1kb3hQS0M3N24xNlpoSlRNWVBXb2MySXhNcFVidXg3UVVxa0FhY1BLUUgrUzE4dnRLa2t6TjNmS0xMd29CV2lvYVdvbHRDcnFLNm9NOFdOSFpjOSt4TU5INEVTaC9DM3RWb0ZjT2daK3FJSUd2Nkw4azdRWGhadHlmek1Bd3hnUVFqY0YvNGhlVkNZZWdZSVNnOS9Wc2t5ZmNlZktzZlZoTzN6QVRUQVo5b1pUVEpxT0VDa2l2VEppOTA2cGVQc3hDazdjdDJGWkQ2eDJtVWVoV2s4b1lLRHhEeDIyY2RRNzI5bndwOGFDdEM2Q0E2NGd5S2YxWXE0L3NKVkhGUDMwS2gwY2pnZHFRdzVXVEFNTW1pMjZKV05UQm5FQkFSMGtHT2FRSzExT2R3ZUVYN2pLWktyMjFaMXJwOUxsSGJHUWxIekRySWdocC92c3NYSUl0eXRtOWRma1k1T3U4UStEczBxc3NYYlZzR1VRdk13V3E1RHV1S2xSVGdzRjF4d091WGplVitNNjlBVUR3QzNqNThBMGE4ZDJzV01JdXNMcnlJb01TeGtXRUd6ZFVPMUZvK0RkTFU0YjNIck5zeTRSL1MweVZ5U2NENk04d3dxTEJUdWNSWFFtamN1ejZmM3VIRW5vT05sVFJPWlBzUlR0dTl2VVBVZm9tY29RL2lvenh0bkdHTzFqaXhwZEVrM3plK2xLRXhOeVozMFk2YWcwNXR4Qjk5cmpJRGpuSll3Z2tCcHRzN1d4SGtlb0hLb0dCUXMxYlZkNCtiNXNuSTJIUWFIWi9pcEp4R2pNRVlncmpORkNab0VnUERKSHRCSUR4KzhpV0xBNTNzalR0T1F4T2o2ZXJOcTJ6UEdjZDNSam9ZekZoUFU2NGRjbklNaEcxOFV6ODQ3Mk9NdTJsTE4wQkdBZVBPZlluVHhRaGpyU0pWTklMNUJJSHVZcitIUVd5aldmMzZ5WlAwZkdzM2RRK1RpWjRWMUgwMHFHTUNaZGZRL0tpUUVKQnNoaGhTMElmRCtkMzMzb0duRUlhTWJUdUN1d1JubmlQMFJmNDVNTlNaUkUwUzJJSytkUE83U3VkVXlHREEvRXgwZkRlRGgwNWt0UXJwU3RwdzQ3RE9iQzMyRzFmWks0Z2dYVjdpUUZrMklMdXR5ZkNMb2RHcDJKNWsrbW5OTSt2b3dqUTJKNVphVWc5K0xyV3RPdmcrQlY4bTY1UC96SUd2d05JTVpEYUQzbVI0REhIdkFZUGpxTUNUSi8zbnN3citJZjZqVEU0elV5SEhXQU9idElVZ0hHUWNQTHBORGMyTURuUXRKbnl3d0hjMXJUekJ5dy8rU2ZlMllUL2xERm5BZSs1T1VQR2c4M0hYYlY4U29TY3pueEFIVjhFRVZNT1NoaTl3bGJqcC9FSlhnaUV0SW9xMlEyT21qb2dXb0w0WUZ3U0RNSGhsM28xdk5BbVBCczdqRWJ4bWQzbFowZUFBaEVwZXZFa1pDNzgyNnk0SFNvQjFQTXRwaGRybzkvd2E5K3lRd29YR2RNb3BUUlZxRXFRTTZXTWxwc3UwaGM4aUl3N2dxUWRjeGt5a1lLU1NDS2gwWUtpVXAxbjZLakdzSStxanJmQkxJY1VWUkNHTkF6cmVrQ2doaEdpSzh0YVNCd0hUaEZVa2tWTWNLUzl5RkdyQ3FSQlgrd3ZDbEVEb25MaHhWYVJESHdodEJrU292ajBrdm9Pcm5JTFFSQWdNeENHN3RMVEVWb1VxL05QRXI3R2Q5a2dZUitxQVZDWEN2TWtweFB0b1diRmNMdXowVTl5SnkxZ2RoYUVVUk1hdmVPSktzOFdlTUhUOWZwYU55MlVQUGJWUHhyYkEySHczRktXVE5BaThqcURCbHpMR3NmUEVRUjBnUUtHVWNQeDdUbUFIQjJjY2NZQkVpYVJ6VjI5TkVMbSttSHJxK0loYTIyUmU0RWd3bU93VUhEYUJINnFsUGs2N0lXSjdhT0pLMnRqZFRTdmJtK2tFcmExR0cwUHNvOXduM3VqbHdwTzB1YnhJRnRiN2FScE40d0RIOXRoSVQ3cHo1MHBhWE4rZ3Z4M3BMdDhWZUtka2JhaWg3YllnYWhjUFRvbXU5NHFsYnprSWZNZWRJQzIwQ3NaRC80NDdCYnBoN0pzZnZKM1dHcnVrTEQ1S3M5ZXVwM1pPaW5pNTlCeVQ5U0F0a2h0c2RwS1ZRWHcvSjJTUzBFeWFtUnhqdTlCNCt0dWYvZmQwd1E2QVNiWlFxWks0K25pc3YrK2NjYU9mSGtsdjJFS01BM1RxR0VoNUJoWHJHb2p6WllVUFdyNUE2RWdiMG1PRUdRRGZNU3R4Q3krZXBmTkdMNmNEN1JDRE5zdStROHpQMWhhSGw2eGdOcnFxcHFzRFh3NHVnbTZTTFVZcVk4cm9GMm9pVkdMTEVOcWU5QmlNRENJVVRtWkc4Q2d2dDlqb0M5SjMxWVlRVndPekxPeE4rWjV3WnNzdjRVK0RmdTJEV28rNFBRUm1lZGpMTXZaV3ZsSmk2MnZLMm90dUN1NVNiK1NvQzNxUE96eVhaM24vOHA3cWhDdWRIUXJ3NEduTVlDS0JUOGtHd21scjZZUUZJdmMvbVNiSTdXV0lGZWhUZ1E4T29HdEROYzRRWWpyMStSbDB6d3Z4bjVKSU9naS9NdC90SW13WHRLM0cxVkdjU3lqUS9CZXFwd0I2RlozMHMvZ2VEMENrakd6ZFZseG9NZ0lmd2s5YzhMelk2bFA0aWlRSWZWMVJCdEtVSUoxTlJVVEVmL0NlSFFoQlIrVVprZHlFT055YkphZkd5cDdTMi9ZcEk0TDlWTEFXS3FWQ3krZTJMOU41WDJHRDNLSUtCU1ZtZ0FUSHJPUjdoY0RLL1ZGNHlQeWFLQXdpR0l0M3FjZnlyclM0cGNUVGlBZGcvRjd1OWJMcXhzbyt3WkdzN0RFRlRPTkh1bldIVTQ5WndUcG05aDlCbStsR1phcVNYZE80TEluTVk2YU1uallWam1ObGQ4SWZBSkVaUDJOM25WMUxESG9maE5XT3FUYUtSck5PcXBnRHpMa1ROUVJlTERGekRiQ1VmM1phajJETlczZHVzclJOdERlYVhRZncxV0dLS2duNHJ0NjhCM0taMlJHdyszdGJ3TFlHd1oyUVJhQ0t6NGRjNkVTdmE2cTAySFprQ0lSSHZEdXZOdEJTaHNkbjB2VFZhMmxzL2tvcVlTSktWUHJubWtla0d3WXZSdm9QRVQ1eFRIL1BXNGRrL1h4SllPbHpWaDRSM3JSLzllb3R4cmt0TGVNSTcrQjNCZndQb1psMmkxTTZybk9XSVVYZTY4UEovazNOa3pnWEVLSnVJVXpMaEd0VU9ZSDZLWTc5QTA2cC90Ti85Wk4wL3h2M01RVlpFWHo4a3BYTTBmVHV1OTlnNHprbUNHMGN1aVhucUlWSlJJNHl6TW1QdnZrdWVkK0hVNnZHVGdVeUtLaDlsWEFPMTBHanE0SEdkTWtkQ2lucEJJTE00OElZU1k4S1FHbE4vMnZzYTNSVlV6OE5kUHpOOTYrbCtSa3lzNUlMLzVodFAxdmJUV0xsZGhIMkxISjR5QVZDWHQ1d05VeWFiekdKbmZDK2s1Q0NXSWUxL2pzblNENmdCZjVIbitHeVM5cG02S0JiUlkxNFY2REovSkhESDloZElGQ2dtYjgvYnpBbmdTUDA2VWIyVTJZKy9hZ2xGbThHd0dFSGdnU1NoYWJCdDBvSHRPNWxuWFk0ODVDQ0l2TkI4Qkc0a0QvdGV4WWs5a1BxQUNiU3pMZ0ExTUl2YXI2eUptTnVKZzlLUUtNc2tMQlNMYXh1RFd0aklVa3pYMzVWV0dYbGhUN1NhWGxPWHZRS2hZY2FMa0dMWi9HQS8zVjBkN1IvNmc4QmxHbWc4eWdRQVk3Y2s0Q3N5T2QyeGtzbUZwVVJJVS9GTWxxOHE4U3pGZjZjSzdOcUdhL0Urd0tWdDdvSVhHNlBNUXlCRUZvTmxDTGQ2TGV5elVKd1pEWGNHYzlCQmNrTWtGY0UwTkdTWmtTR0w2RGl1NTFWcUJiZy9BNFpsaXNRWXgzMnozdGVoZm5ydXlHcytJeG5mZ0t2L2RZTUU4R203N2cyTzUzdTQwT1pIY2NjSURWdVA5ckVLZGs0Wi9IMVhMOHhSMERwT2ljbFY5TGN0R2NZbm9TWlZDTEtYUFBva0NETWZaMnM0RStHa0MvY3JSK0loWkVsS0hGMWRXWTgzYjk1bFVTQld6QTJtUUV3TFE3SjRYN0tzcnhhbG9Sb2RnUlAxRkg5djNMclN1b2tVTkNzV08wSWhaSEpPYlNSTzJnVUhXeWJ3UGxKNXRBV0p1TnhmWmZOejZ3NlFzRHJxOFJzSFFHRE5oSkN0OG9LNHFtNXJnaG5HR0tGY0cxclA0M056bU1LOXBDTllJdm5IUGxGNUxSVTRKYVdDeVA3RHcvUzBmNE9lRUdvb3hWc1E3eFRrMU9wY2RTTXlQeG5MOWNSMGdTNjRuUHJZcHhkTWV3SjJwSXhOQTBSQ0E0Q3VJNk1Ya2d3WkJ3K0krZ0FndC9CMUgzd1lpRnRrT3VxeGlialI0dFAwdGN2dmlZamhWdWhYRFlucHpwWlJCKy9JR2NZakZvSFAvVVcyMjhRN3FaLzdpQWJxSDZpNGVvNEpqa3BjYllPdU1mS0tvMDJFSlJTdHN5b3JGRFlTNWZoWDRXV05KR0Z6Vk4wbkVrTW5wUWhHWUIwWTM0OC9ldi82U2RwWm5vQXJYb0J4cTdFZ2JiYnUyWmdKZGhSa3crdEw0UVRmcjllOHJzYnRSNE9aMzc3TEJ6V3dPYmVVL1YySjFsM09oaXVRQ09oVmFuTm1XblVBMVM3Nlkrc1pyK01qajlFTUtnQkdVY21iUWFOb2czcVh6SzR0YzdxcEFlTERBOFRqd2FEYVFKYXIyMHBNSVBYNkhCV0FySXNLUGlQZ2lHczVJTUlPK0hWU0xZcDNmS0g2TVFGd2c0QmpoM3JvMzNUWnhza0dpdS9qS1Y0N2NGUFdzS1BpbWdOM3JVZGVTejhhRkVmL0VuOUJXOFcrenFGd2JMZUw5N3BHT2p1K3BRNjQ3SVM3VWtGVTFHNEFOeG54WlczcUdTVlZHSnpOSjExODJYalNrb0ZDY2hIaW9lcHhYZC8reThBdFlSQU1raHFQZWFaaXZnbXFsRjRVVGpLMm1IaGNjWTFDK25ybFVOaHZSUk1GT1Q2K3dnUFFVTWRDdFZ3emxPKzZFTThzMzJlZXhXQ21BSVFiTmJlek80UTkvTzRoQi9Pc3RiaGJHY1dnUWJhMDhIMlJwb2VKUTZKN0o1TkhPUG1XdC9lMmNRTVhLU0JFL3hPek9xRUpKaHZmSmNOeTJ1czhKWHc5NmdhNzZBQjVOUzd3TUhnQ0pmYVliVEQ0RHJwamFydElLZzJscGJaVDRqdkNPWTV3SG5zdW9KeTJ3RFNRZUtpOG9va2ZpSUl3d004WElydnhNUzd5ZG1BMTIrL3cvZUI5SmYvNmFkcEF3MkYwMDhqVGN5OXQ2NkU0MzJRcEhzSE1MdmFiNW5Od3oyb2kxMDQvSVhsbkVSM0o4elNBL2lrWHF5dnBiLzhyLzgxVGN6TlJJeVRqbkdKZjloSWMrS3hUazg1TldhZ2xNYW14amlsaHNSNUhrUkJ4b0t2dnNLdkF3T1gyQ3pOY2g2YUZWdU9NQ2RLbUNxUlFvYXhVMkNKZjBXNC9xcHp0RXVEZFQwTGNKZnNwZFBzcC95alAvMVJPcTlnRnVHN3FrNE5rMzlzZ1AyQ1c2VFF3ZjEvM3NmeFhmZ1F0OWtZVG9hR01qRnlHeXgwTkRBN0haT2QzWFhDVGpaaDJDNE94ZDNsVUEzQ0RHQTBtVGs3azZFRDVJUGJjZFRpMVh6VlhLUTNkVDVGMmhsOVBZdm4wQ1k0N01XeC9PRTd0d2hxcnBFYzhMTzBUYlIveXlWRUZ5bVlHSmd4QW41WFludHdSQ3VFMU01Y0ZOSi9HaE13R251a1JvYlFZNVZVOHg0NmtPd01ROGdYd2Jab3k5MzQwd3pzMVdRenNMUkJVRzhUMDZxT2o4cVlNcFdYZUZOcGl5QkJJa01Mbk9iRGhOSURmUTRpT01xNk5QUzNVa1I2Y3grcFAyS3NvUmtYMDBJTzhFeWxRaUdlNlJKeEV6eVorY1o3bmZUUFdNUEd3VEhXQlRudGdmRWNiUzdvaU84bGhLdVRaenVDMjNFTmpyWU90VWNGdnpEd0Y5b2o3UlJLUXNHWHdsRjhseGVEOXp5WE1MN0FNRXE1WXY5Y0liQUV6T2RldnV6dk1LdnNDUGY5Wjh2Y2hTRFJFQzR2Z3hxdHo2bEtvZVo3L0loL0F1bHJTbml2bks2Q0FlS202VHA4VDFrU3ZnS2VGeVllbFlSRDFQYkN0d0RNQ2pycmN0K1pjTnBXMFo2Q2sxdHg2ZmhYcmZVemwxUGcvVTZUczVCSUVhSi8yTi9vSlJWbEo2U0lrMERVVkl6dElVODMrOUJ1M2JtTGhzTk1BNkdlUVVBbWJETXgzaUZPeDkydERlNVpIaTBJRTZVSG9YTGx5bnphWlRmN0lScElKOGVuSzdpY2RZTmhJREpWOUJJSFR3d3k0UGN4TDVkZnJhREJjZEl3RG1VZDk2NE15bGpkQkplV2NiTDBjVkRESWI2RGZmWWI3cEZFMElERlRtS3pldnJJQXNyV2tDOGZQa20vL05WdkVGVDlZYkkyT1YxSGJmRGE3QlNoRHFSRDN0aUFjazQ1dkdFUVJKQWRBdUlmWUpHZ20wUjNHMnlpL3VrdlAwOHpOMjZubHlUeisvbG5uNlhGMVJVRVd4L0NhaVRWNk9PWkovWGdnRzlnRXJianIzQkQ4dnpzakVNZUpwYlIyd2VhRGVDR1VhUitUMnhtY0hqUFk5dzFseFFzUjdTTmU0K3dBY3gyY0hDQnlkRkMyeHZpcEtJeE5OcUh6NTZtMmV2ajZjLysvSStwajREYUpuaHJsaUtYdTlUdmtlLzMzcjZUL3BkLzkyK0R2aFlSMEh1c2t0MS8vMGI2OXJjL1NJY2NZMS9iM0dPVGN6NE1GelJHUEpVSFM3Z2FMZDBWUWt1TklNZk13ZEFRV1VGYkNoUXB2VXgvZTFnSmE1SGw5QlJhR0dYMUZKYzJpd0JrdCtDSXJ6aHdRYVdWU2RzekY4L3dLVFlwWjlaWk5UdkRTTTVZZkltOFYrQkFFMDJhbFZPZ3R1Q255QUxMZDA5NVZ1MXVnZ3RaMzVndGp3OFRyeXI5UnY5M0lCaTBCTExaaVlBRnB3cGVWMWk3TWVXSENKRXA2V1JDQy9JQVZIa21SNkhUTG54amZpdVZBRjBtWm9OVmpSTWZYdkprd09TNHlNOStVc2NtMjhScW5FblpSYnVRRE5vaVlSemsydS9Hc3Voa1lzNjBRSTk4amtTTmRFKzB6N2ZYaW9uOEZvNTMyK0F2bElab05mK3Y0RWMvTy9EQmZCcENpSUxaZHN3TTY4T2lvSzhwclB4ZG1GQWlOalFYT3BoWENCa1JPaWZUS1NOa2Nxcmt6MjVZbC8ybm95RFE3eUxXZGkzcmFodnpRWFFnVEVNS2hJM01wMjFLUURydURieU1SWUdvRStGcFJRb3NoV0xjRTA0cXVtelBId3JlTjgxYmhaSjk4Rk1CVm56M0xhOHNXSzFINHMwQ09qK2hWdHF6VDJqYmRoVzRWZGtoSG53LzgvTlhBNGFsbDRzTWZGNk5jVlhtZzNmZmc1aGhaZ1pwSENmd3lNZ1Fnd2V4TU9CN21FMEgrRnhNeHlFUnV4Wm0vMEtRTXB1WEVWanRFSGtOWVhLQ2dMbDVaWXo5aEYxb2IreFhaUE9jc1YzR3pVblVveU9EVVlmSVZhTjF0YVpZS0JCM2YvdDN2OFFNMm9KcHY1bnUzTHhDUHZiMWRJQWdOVVd2SzRLSHhOQUkzMXQzcnFWZVRJMFcreUc3RVhxb1N1eWY2MHJqOHl6Wmcrc2xZREZseWc1T2VGZUZaakg3UnZCM1ZmWGZITzBpYWN5ZkJaT2dWWDc4OFNkcGk5VzhKZkpRRFhDQ2p1bHVGT2d1a1BRd2NReEN3SjJZeWhVV0l6cE11Y3QzeEQxbW9LWVJEQno5UThBaGtBL3JCK25Sd3N1MHh4TDV4TndBQXZHRUxUQnJyTElOd1RRRWl5S2twVGxYa3QyN3VZWmdyU0hBVjFrNU5LUG51d2lzMnpmbjB3Vm1hYmY0UHNSSnpGN0pGZ0tEMFNFSE8zaVRSc1UvV2s3NGxCamY0QTNHU2swL2o3K0R6K2lIaHRWR2JyUlNta2FZVGs5UHgyNkM5UzBPeFVBb25tSFBSZ3dmUXFqWFpYNWUwNG5lU3dxaWRuN3JFTzlpOGxHbzVGejdqaHYwcHpCZ0RCV0thamdHQVR0aDYzWTVCdC95bkdPc0dZbWlRaDk4eGkzcWpyR0hqcVJwTDAxcU5lMDYxa0lYcm9paFlVTlk0QW41RWh3WTcrVlkrVHZuYjVPNEZWaUlFL2hKQVIyYURhWENyMFpaY2R5dWtFVlE3dU1xV0Y5Y1RTZE1DS2Jxc1FNdUFKWFE1am80eE5iTjRRcjhEclZDNE5IVXRUMTZtclVxUkhPV0Y5Ukt1OEhySW9FcjQxcDQ4bmZ2Q2RmZk13bWpvUDk3NHlXWk5vQys3RWlVQVprT3J2cElEQ2pQUWwwVW1Wd0tBdjB2K2FKZzhZMnZPWVJBT1Bnbmtya1VXd2FRdVlQZU93RzRuL3pGNWxqTGdVQnJkeG5hQjhvcHIyS2cvRjVvWXRyekRsb2cvZzFFRkVKWG1QMWVYTFlYeUhDZytPNVZsQTFZM2loTGh6SG4xRWJ6TE9UQWF0dlg4U01ZMWJ0Tlhpak5TWDBGK3JrKy9zWkhFY1BVUU9CMG9TYWJOMnFEclRBckJJRFdpRkdCdnVnRWtjS2FWMnp4MExGdmN6cEdTL2lUWnRsdGYydDJnaENBQnNHYlZmQjZrVGJZZW5JdWcxUHdCSUhUUXdTNGdsQm1HTU14ZmNwK04zMWE0a0hoWUJ0Yk9Pc25TSDh6TzRjV2NBUU1MNzlHeThEaGpKL25aejkvaXJaeVFkRHIyeUM4aWNiRmNqdDFMaTB2aHgvbjBQQ0d5UmxNRUU3cUlZSjkwL1p4V3RjeDFVWklYWE1YRFpCV0NNVGs5Snl0bGNnYXNZK2Zyc0gybmxXRVNYVmtMdDI4KzJINit2a2l3WlNIRUN2YUxuTnNGVTZCZi9nR1RsbnVWUGllWSs3b0pqRHNROEJSQXRpeTBzUVBONWZlKzliN2FGNllrUWd3M0xuNG10cFlwVnloemIzSUFLdUdNMUFkUWRNOVMxOTgvaWk5d09kbE1HTWRPSnFOVFZ3T2gyZzZYY1NobmFZWFQ1ZlFSZ25kZ1BHT0dUK0RRTU8vR3F5VlRTUnhKMTFBRkNIOHBYY2Q4akl2Qzh4TVJuZlMvL3h2L2lLTjQ4Tjg5UGd4VzNKZWdMTWRhTnh0TUJJUlcyZ1ErdDBzS3B4aGxrbXJmWmpmZWNXUU1TYUVvYzZxcXNrVGtTREJROUt3eWtCb05HaDhycEs2eWwwbXNTQ2lBaHdCQmZWR0dpRStXNnBxM0EvM0NBMUt2Z3BLNDdsTVY2Ui80cWJGclFBQVFBQkpSRUZVeTZTQStyNUdDYkpGdWFkOWE4cnhidTBzRXJtaUNIRFVvV0R4dXdvQzljWlhsQW1JMGRDU0NQZUI3bUJDM0NHY01iQzh5WG1aNTJsc1lDaWQwUTlYL2dhSTgydEQ2KzlBNDQ5ME4vQ0JmUXQrNGpQNFNRbnJKZWhjQlo4cVoveUxIZ0dMOFBodXdhL0tISFk0a01BdjF4a1BDdFhNaW9xQ3hYYy9nOUdwUitQT3lnTlJkczVtY2wvams5SDNKNWVpQ1pIRTQ2enFDU3p2SWxBY2VQdGpKM1FZQWh0bExwSE9QV2VUa01jZytQVXFDbThyeEd4UnFTV3VKWUNzeVhrelh6SytUa29kcldaTjhCTGVRakQ1V1FpbC9FYitmeUNNL3J3cHVMem41YWQvR2pWdXJZZ1V6cFJWZy9Ia0ZXY2tpY2VZRkU0allwYms0RTYwbUszTjVTQVNmUmZtblRLZmxubVVlbGt4TlBkVWsrODZaVTBCUTBjaUZZcXpua3ZDb3d6OEgzNzNtMnl1d2NtTm85dERTemRJck5jeWhRcmZ4YUVDVS9OVWsyQUliZWVJV0tWK1pybUpzZEZnaU9XbE5hS05FWmpNNlB0c1U5bkVZVDJNRTNwc2NBSWhVa3NQbnRRd00xdnA3VHR6eEpXUjlZRG9kUStJZFZQek1IVm9OcTJ4WEQ4OWR3VlQ5bnBzdnhoQ1VCbkpiRks2RTdTcFR2eDF2UkQvSHZGaUV4ekRyS2F5aTJPN3IzOE1vVkJPUC8vTncvVGcwYXZ3MjJnR3lmbDlqaEZmTlpNTldqM0R2RklZblRtb2lqVHdBYVppQTNZWlRXYVREQkNQWHl5bm9hbWg5R2QvOFdlUlNIQUx2OUZ3WlJBTmkxTjZpSDh5T3I4T0U0VWZqN0hYeHpZeVVrblhPTHV3ajRSaEo5aWJ5d1MzYmhHSmZrYnFHWU1yOWZPb2pYZ0ZLU1BFcE5lSXdvWjY5WEc1SktBTWNxeU5iQi9ra0llYjE2ZWhyME5DRjU2bkowK2ZZWktiL1dLY1NqQUwyWmh1dnZrZTQvUWdiUGQzaHNrRjNSakdvSWJsbE81cWNkQ2NJZ1FoNDZYWVVJZ1lMeFdIaVRxaG9TV2VNSEZvcFVqL3hsYVpTOHF3QklXYmZLdEE5RjB2SjFSbFdRUzU4dHNra3lQazVPOEJCMUtwSmJWeVRHOHNQMUpsQ014NFBRUUZQQURmVVREcURzMkkrNTBJL0NZcnNGdHIyNndLSDdFRG81ZlFGZGF4MWV6QVRkOGdxYUJadGU0azFDY0Nja0drZ2tiRUJyOVRvYnd1L3lsZmZDU3ZxZkNvWkJROG1lL1JaKzdKVnhHYmh4bmNNY0RtNTBMQ1dlbWJWeUNTZTFFeGxZYXdzb0N0MERNSFZTUjVYMkdVTCs3SHMveGVrYjNSWjk1M0cwVEV1WUFza1p4WCtuaG0yNkhiUXFwMEtMQktlU0hTVnhPQ1N4V1ZmeFoxQnJHVG9UN3ozUTRXOFBFMWZsdDNoQ1M4Z1lnQ0lRRVBCUXVUMFBlTE90N3NiNEdEUURCbHJNK2VLbWhkalZFcnNNZXE5VFdXZENVVUJSR2N6QzU1QWhqeHkyZytWS3NWWXBId1Bma09JNml6YzNaeWxqVEhVNFFwa055TjJDZVpUQlgvUXU2aGZoMzdiZmdFRkFLTjJnNkNvQnJ2N2VFZjJTWHZsRDRFaVpWTzhCN2FDVUtqZFladjZ1dzROSjlLWHdXZkVSdGhlNGRKVDhOcUhmRmdJNWlPWlRTd0tWYjh0dGFQMHM5K3VVb3dKblhRWGhzK3JlbHgzaUdFUXBQUVUxalVDczFJY0lRcDFkUEQ2aUNtNk96Y1hIcnI3aDN5Z1JGbkJzd0xMNTZoNWF5VDM1NTg1Z1J3bWpEUVRhK0xaSjNjeENIKzJ3ZmtDOE5Vb2dyNkQyZUFJM01sZFdFK3VOVHRzajREU2p3VVlRaHNzV25oSXpUZzFYaXBNN01za0ExamoxWENBMkJxWTFWMEZ6d2FWN2Eyc1E0c0xBRHc3eGUvZUlweitTVE5YcjFPV3p2czU5dWhIUmlJQXpQdXYzY3R2WTl6M0ZROGV3aTFaWTZ2UDJORGVBWE53SGNpOFFvb0QzTUxtbExEVWVQUUROTXM5VFFiR2Y4Y0JnNk5Ianlma1NXakJMenJxNjhpYVYwSFppMmVPZWlSM1FYNEpVL3dHemtaYVpZcnJBd2dqajJwOUwzaGRoNW9xTW1ZcVRHNU9peFRxOUdGc0hLMkNrYUZzbHd0UlZqNTU2UXRyWEVUR2dKZXZzZGtMWThnL25pU2FSaGFqSlYxekc3M0xycTlTUi9URUp2QSs5aDVIc0pRUVNjUDJsWDZScFg4eHBSakhCUlVjbDVlR1plMjhjenhUUFpzRXZTOFFTYUtmY3plYm9RVnRhQnR1V2tKVForQTBUSTAzOFUrVDNkSzJLZmloQ3VGaGUycVJCUjhxa3ZGN3dwcVYramx1NUFKZkxjdmNmR085NjFNMkRxcTNkMmYrbExCbUg3L2g1S3VrUHdGVXp1d2RpZzZaWVdYMVN1MGlqSUtIWmxjVGlqcTVBdU16aC8zRkNhV2NRK1VqdlBRdENnZEs0YlU2Wks5MmxZSWo1RDB6b1RPY1Z3S0xtR2dQWW5LUVM4RWo0L3o2aUd0MEJaTkJUTVhFdDErQmdJbzV6dGU5cy92bGludzRHZFJOaEFKMGlReSt4ZG1td1JGL2Z6a3N0L0tLUGIxUVh6dWpEOWg1bXl3L2NLanNrNkp1L245NzM0bjNiaDFBK2YzWTJaVnRDVXBoWm40RkMxSmY4USt3azY0QmFtTit4S0l3cWpmNDVId0MzWEF2UE56NDBUTTR3Um5KYXpHYkk1S0JpNXRuaVZ0dk9Sbk1qaGVJRFVqelJ1UDl6b2tEcWlHQ2JTTlJtR09kZzhHS0FIUE1JTG95WlAxdEx5RE9YdUdEMGs4a3N1cTJvdEdpbStwai9ndVNEV2lsczN0ZEVib1FGZHBJSDM5OENreFhEWFMwb3pBY0NlRWI1QjJCbUhzdVlGRWRiQ3hHWUlFRGxQWm1KTDQ1cDMzMHlpQ1dWTytUQ3pPQVlHd0xWWUs3WDhFUlNLY1FvQWhGRHI3MjlJc09hVmFCQ0Z1d2hEdDlQMmYvY1UvVFpQelUrbnJaMDlUR1NFNFBER0M0S3FuSnh3RFA4ekNoazdlR3ZGT2h5eCtkTUpBVFlUOUdxdUJDcUxSOFZLYW5lWDR0UXEwQnUxVVNOWFRCQWNyK05TT3dGLzRqeGhuR2NzL0VNcC93QzlLR1ZzbkpxYUJXQm04Z0VZVU13RXpETnlQUTluVGs4eWQzMHRFdWFtb045aVRlYUp2RVpYVXJVaDVlNHZDSld2UUVvbWhKeVoyMUV6ejhBZHBWKzNKTnIya09SVnRWK3NNQXUwQUZ3cFFCWlZDQytUeVRNSHBJcGNtSy9RaC9JdzMvdythc1IvaEwwYURkYkpYaXl0VFNBMnJRdEJxZHE0anpLZ0RNZWhyL0NrUW9CdnVDSVA4WVB5VUUzRWNCWVpXM0NUanlLdUZOVndDZThDZ0lRK1BVLzhSSzhRb2U2bENvSFNKOHc2NjJHVUJ1WEFCQi85b0pnc2krTmJmc2FXSHB5b2Q4bHp3cVNDQTh6ZS8yd2RlREw0STdZdyt2RDQxNTgwWG95a0FLUzQ3VUZRa3NtUVMxVFFkWm9ZdEtNMmpNY3JGWGlnYkFnbHFZTnJrd2ZoQkZkd0RBQmxlUlB2Y3FjTFZOOXVQZHlrWHdhUnhENFRHWUlBME9tcStiVnduSUpOQnV3Uk9pZXdWZ2dRSmJNTVJMQW9ES0tkRFRSWWVMb1AxQ21FbHZINlAvbHgrZXEvQWd3TVdBMHFmaXN2ZkNwR2kvdEFrR1RnM3pCb2Y1Z0RyNTlsbnhxa2ljRXpYMjRPZnBLZnpOSVNNWnBxcmUyYUJIQm1mWlAvZGZucjR4WlB3b3d5YnR3cXowdVBOaGRrZWx5RDZjMDRTdm5GN1ByMTNleExiYVIrRzlMRFcyRUJDcDdNMkdtWUJ5RlFHK283eFRnckJ0Kys5aTA5bEw3MGtyL294V2VwcU9FZjcwRnpLK05aZXZkcUMwUVlSUE1UL0hEQyt2RE0yek16SUxFLzFtSThWTWpvUTN3WDNkQkxaWDZrUlc4T0szaWNmdlkrUTJ5ZVFGUTBEWXE4ZjdhVVpRaDQ2V0lIcUpuajE1WVBQd3E5MEhWUERqYkJHK3grMGFtVGRYQ1hFWTRiRmdROUlJZndWTXpWYW02WVJNVk1LSmhQWC9lUW5mNUx1M0p0Sy85di8rdTlUalJYTFlRSTk2KzBuNmRkZlBTQmFtMEJkY04xZkhVNjFoUTBDWWh2cDZ2UjFBZ2xQMHFPRGhYU0ZvTmFIejVaeHNtdCtjMTdqWkUvNnppZnZrVXQ5SUQxOTlIbUVsanhaZVo1ZVB0Mk8xTVVWZ25nVjRISjdCQzA0RnlxczFHZ1VWdElyNCtBMkhZelZFRHI4UklNbDF4TkM2ay8rNkFlY2lkaWVmdjJidjhNazNDTGVTNU1QSWFDQTAzVEJkTEp1dFJPRlh4Y3BpSFJQdE5CdXoybEhmVWp0ZzFFTFhuQVJSamVKVHV1d1FBQkgwL09jN1ZaZG1IUHRTSVF6M0FCTzFFNzZXVG1RaG1GNnlGdWxQQ3NTbXBZc1pvQ0VNbTZKTXlZb0p4QXpjSmpJejhrb0JCWTBDNkh4dm41YkJDZjlsVStGbDlxNVQ5L2hYY2dhR2lDdkcxYkFxNFhsdElGUDBvTTZYTlNwNGNOc01HNGxhR1NBVk14bFRNRjJjS0xKNmo1Tk9oRG1NQTJFUExEK0VHQnZ5Qlo1U3g3MGt2Y0svZ3laNDIzZzBOV2hVdUc5eU9sZU1HWUlIUnF4Z24vSXZBVmpSODBLSS9vYm1ra01Ea1JOWTIxb0Z6SjBPQWFwM0dWaStrN0hjOE5SaHdNRTJHanJsdzhBTkFTQkVoc0llY2ZBMFRZR1RyZ2lCNUlNNmowZkk2eDhycG9MUG5ObkwrRU5LU3lCNGFSVm1IYkFuQVVDRkVBRll1eWJuZmVaZjk0WFdRS3JnUFh5dVZmdWQwYW83K1V0UnVCUjFabjNWTlBWZER3dE9HeHRCbjZmNE00dUJGQTcwbmFkRUlSYjh5UHBxeWN2TWN0dy9QSnZBSTNFQ1BNMW5OZWpFeFY4VVd3VFl0bDVrTDYxU0RQY0FCTU40R2dacndPZVhVMGM0Rml4YzNiYWJPTmdidGZ2QUo3Y3FtSGFGYzBHTlJwalhseEtkOThiM1dJZjRDeWJzZ2xaV0hzSk0yVG4reXhDNC9lL2RTLzl4Ly93ZjZkWHhJcE5YYnVScG1jcjZhdGZzVW1icEhjbWtOc2xZcjNTUzNRNVJONkhVMHVXTHJNQWNFaGdhQXVOelEzWGJmalRlbGtrV0NBSFdBc0JqS2JPNGdMQnNEN3ZNUEEwYXc5Ly9kUC93aGFoTm5KbERTR00yTGg4M0puKzdtKytpSmc3Tll1WjhjRjBaZ1lGUWdTK2Z2NG9MVzQ5WUlNNFFaMkVjQ3p2YktmLzZ5Ly9ZeXpwdDJQT0hXQUtQbjc2SExQWVZjU085UC8raC8vTVp1OUJqdTBhY1RaaTVSRVlNTVgwcC9UaDdCNUZLSlVaZzM3aW9vaTFUbC9oL3lKRWp0aXpjVFJOd2hGZ1pJK21jb3VUam41OVBoSzJMamJsbFRUbytCcUE2ZUViMGhRRERhM0EzTVJBVmNmSEk0RDNnQzFIbW5WVkFtM3IrSFdrejlCa0dWTUtod0M3Z0tuckNHZHpiblVRcktuQU1ZWkptbEV3S09UVVBOd1R5c2hHSHpyQitUUXJ0Mk9qSEJMN2JEM01hRjBKMG9XSHVqb0JLeFE3RGRWaGRjS2M4Nm9UVW1zSUhiOEZ6QWFmY2lBdk5HbnVMc09JWkVxMU51bGRTMGQ2NFVab1FtbzJ4a2hTT2MrNkVPeHFWdXRwYVdFYk9qQVpJSEZtTEdRWXNHMk0xeURtZVIrbmdidEFvczRRaTE1b3RGcExBUnMxMlRkOWd1RzdGaTdxTC9pdjREV0tCUi9LcTE3NlpqMHNWMUJDeTFRSnFSSTQ2b3ZGUzVsQk14TVgzMzA1TktCZ2FubUZCdWxjSE9iQXMxaUtEVVJwMG9BcUVHSThWUlFDT0pFWXFxdlNrbGVOTVZMNFdFNzB4ajl1QklDODVaS3U5WHNwSk5TNHdpejFKZjVjWFJIWklSZ3B4OTJ3dHlQMUtzL1ZnT3lnQ0hwOVVZNnFlSjNXck9meUVqa3g4UHdXRC80V0x2Rmhsb2xRcmJudk0ySHh0M0xZUGprTG0wOHFSa25jVUs4NFVXT01mWXJjY3FuZVhPdEQ1SDhINGhBc2dyWEp2cndqQ00rWlh2UDR5dndjR1R0dklTd09zdk9ZV2F6RkRNdnhia1NoSDZhbGwwK0lOVnFPTkNGdStUZzZSRE9KUHVvWE9NZDBJMnFidHRRUXhsZ04vT1NUNzZhdnZuektadWhUdG9rYzBKOVN1blA5QnZ2ZU1CUDN0OU1IYkZVNXc4RzlTWGpEeFFrK0lXYVFHU0xmeHlaNjhFK1FQb2FJOGs1Vy9Ub29JNjQ3WVBweXFSK0J4QVpmMHMwb0ZEelM2ZkVUaE16aVFvUXBIR0VxRGcrT01nTjMwU2UyclhBd3dRSCtuQkltc2t6bVZwMWYvTzNuT0d6TmJYNlIvdUNURDlJLy82ZC9uSjRSSTFabkJ0L2QzMFJ3TjBpUk00SlR1ei9kWU9OM0gzNFhOOWpxK3hxZEdDUHlmbFRaQk0xeFBpQ2hGQ2VudGJRQ005V0ovdTlnZGM0VHBHdVluVWZVWjFCdlNUTUs0ZlQ0SWF1SkJNZSsrODc5OVBiYkg3RlN1MHVnSjFrcldPMlNCdlU5cXZWQWFCSjJhSHd0R01Sc0hBWStHdDlsK0EyU0tnMFRITHROSE5yQ3MrZnNtYnlOdjY1Q1dJaWFFS3VEQU9lSlJCM0VNZG52RHJRY285SE43S0gvTWdRNXZxMXNCb0xaNEtrc09ESnQ2dXlYdWdqSUpWRDRFOGJwQUFmKzh2SjYxSi9saW9JdUN4MEZWeFpZbWU0MURlVTFGUWk3WTZhU0UzeG9nMHlTY3pPampDRTh4LzBRYkh5UmxhVnpIZmpTdDZsdWd1WVJOb1krTkRGeEYxNnVrS0FQU1krZE45elBhdlQvejlWN1BWdDJKWGQ2NjlwenpibmV1N3F1ZkJVS3FJSnJOQnBBRzdJNVBkUndnak9LbVpmV2FDWVUwb05DaXBDZXBNZjZLeFI2bE40WTRvTWlKa1lSWW1nWWJMYTZPV1Izb3hzb2xMZlhlKy85MWZmbHVoc29jUmNPN2puYnJMMU01bTlsNXNyTXhlUmtJTGV2b0h1WWdObHBHcjhydWhDMUgvQlRLdWNpUlFkV0tFZ0VDaFE4Qkorb0dkR2I4VTdmSzMrRnFuaHhMVXdtRk9Ea2JMK0VaQ2wrbU5QZEIyUlFRU21BNFlLWlBWY3dlQ0doQ0FTQ1RxQWd6L25TTUVSeVR0SFhTbHFPNXdLOExFc09sK3k1TG5QYWdBQUZrWlJ6eFdGcDRlWExxWGkzRjZpc2RkQUFHR2ttYkRTL0krYUw1d3VWa0J2am5raUZ3Mk9oY2xJWmJvMGpESWgwY0hFK0FFaHBpdmNMdUxaTFZkT09DY09qOWVSSm5mbXNvZ3hxUC9uRGpvMXpFRWVjbzMweEFNNlVsa0cvbVVCTlNVQ2ZJRk9KNk9Yc0xLY0x3STNyeEJreTFldWx2UTBBSExKeXRVVUFyZUU2dWozc3NJcUltM0NvSnRXb1JxMTFKK2tISDF4bC84Tm13azVNdVl5Qm41a2NaUlQzQWhnRmxhcUoyVk03RHE4SktiQ2R0Q1pyT0pFdW9iNjV6eDYxSVlTQ2xVUXlDbFRWa0xFVGV4aVRKL2FJQmNKVldvZ0hIT0Q5NjZtUG5FNHk1UW5oTzIza2swSzdnR2d3M0VLOCt4QjE1K0FRbTVYMnc1QUUxWkpmYTRmUW1FMDJEejNFUldNZUo4SUY3QnV6ODR2TTRrZTRVU0RoRWJlM1RJNnFlKy9maGVubUFDcENsS2piNHR4YSt1RkhkeU1UNksvKzloOVlqU3lsVysvaGx0Q0JOemY5NUgyWHgwWlFBUnZUa3hjdlVnMGhQME5YQjdGaDRkMitPcE5HV0tINzJaLzhORTBndVZZZWtpR1VSWWg5bnRuVlZZUy9KZ2hzUlExanNDSng0UzUyUE1kbUhTZlh4YlU1WEJuMkFOK0RkUG55R01IYUpOc2pKbEhWTDd6Ym9hVkRKeU1uSHpwZ0g2bk5SUkZ0UmxkSEI5UHRhMk13TFpNbTQ3ekpPR3l5UXFscHhDM0x0RjBLZkljQXBiNXRybmlHcnhTaFFqVkVEZWlmcGQwVmdvRkpNK05LdTU0S1gwTEdUN3RZSldQZ0JxL3JlT2d2TFN6Um45eXJ4SU1rS1BPNzJDRll5R3ZTckpLL1BDbk5VWGpRcWRLVEN5YUNpd2tXZTVCbVRmT0MvQ1kzOG8vNzVDMTVpdkxDeTUwNkdaS2t4SGFNNUQ4NXRaQzNhcVArdFdRU05lNnpIbW5YRmVKVGdMZ1NIbWhsWmJvWlE3dWhRcFhVM1NuTy82SmNhaU92aUFmKzQydTBYVjZYZDRLM2ZUL2YvZmlNOS9tZjlReHM0WkZZbE9NNks1QzE5NzFKaHJQeHhTSFQrZkZjZE1yRjkzaTdPaW92Tk1hS3UrS1JBclFFSkY5RzJkOVdKaXJMTzdTc3k3aTVTczVxNnRzRm91ZjNoM2dxNE5tUk1SZ1dUNEhGSjhwWElnVHN1QWVhZ25sVWdUS2lSNTM1TGpHNUpLeUlIYjFIRVlKaEJoWVJQeCtLNUxiUFRoSnd6ZGx1V1lLaXdDb2wrYzh5Q3ZDMlh0a094MHpDTzB3eEVrTVJIWjdycnZKZjY0ekw4NEtvd09XNUZ2SXk2UXV6dWpwUGlXZHBlR1NjZnFoUEU4eGlpOHZydUNXUWRoa2tXU1h4V3hXRVVZUDlhNXpVdTMvNnc0L1loN0FodmNZbTVUNTcraDZadnlueUp1R0M0SjZJR3ZCZCtxNGtsR2NIQnF2R3NPNHM2YzdKaDZSQVhwbGJRTDA2VGdORE9LOWlNRGEweFl5UzVyL2F4RnU1RTlYajVlczMvRFpOU0NWdUVRVDBJdTRyV0tDc3NQRUNmbVpJVElzWXhEZloyZm1JN3czWTZnNWgySzFWZHFYR0R1YXVOYjI5dmNTVzdTQXhWK0VKM3dQVHNCSHJuZmZZODdBY2VlanZ2ZjgrQkYrUmZ2dXIzNUpwQWJWMHNEVTFkMWFsSzdlRzB5M3l3RSs4ZVlWeG1EQVAybWZpdlNFa3JUSjFYV2NGVW50WFJ6Yzd3UUJxVyt1N2FlNE55K3ZyK0k2eDkxOEZxdFlhSU9ycVhLYzUzUUZWdHpVcnN5bUhtVEFya0JnYm11bXJOZzNvT010aXd4b2RKVGxpVXhQalEzMWhXZ090OVcycWNPd2dydkRBQUR3a1h5WDQyMWZIMGlBcGROWlFWM2VKY0hqOWNwRnJoR0RoQjNlTWVoVGdBVFc0aWNVdVBsQm5nRHdVRWpZbzF4ZE1INU9CUVFZSkVxYStHY1Iwa0RiRVNuOG1YVVUwa3JjMms3V1R2akIvdkxSNnB0ckhjM1ZJc1dFcmdvb3NNMEJDR29jMnN6Q1F6UmZIMEtTcWJFOVhjMlNzclN4VUxLUU95OU9qUGVoYTN1UjV5QlcrQTFoeCtaZ25oT2sxYXJRcncrNWNyVStaRXB4YWd6YXFLbmlzR1pCcXhzWERkTjQxTFBZUW5Fdy9LeFhCYTlhRjk4dmpDZ3ppVEJ5ODZGdGVraWZqL2d5Y2dVWDh6cmpBZmZTSklDeVBLL2RVNFM5MDM0SURSS3d4UjRGOGZpOWU0cmtBTk83eHRmNk9mL2I3UlFWc2NYRXRBSTM3Z3BIcHpqRDB5Ynd3clg0cFhoRTg0bzFXaEFieU05NG5VRGhqMlBINUhkN2x0N2doR01nNVF0Z3BBbE5WdzZMaGxrWG5NTEw4enM4Rk1LS0huVFBiZXNiRGQ5TWJWajVtdk1MWWFMdnMxOElmVEdDMEhGZDlpbjRSRksyL1BSamlMbVY0VFFhTGdhSUFiUjcyRjlXQldKbTFVQlVnTjdQOHNucG96cXB0SEQzcnNIdWc0ckQ2c2cveHQwR2c3OTU3RjF0VVkzb3pod2N4ZmtuMUVFSXIwc1hDMUZSNjlCRFZDZUhyQ0dmUGZhUURGeUhNSG1GTW1zU3JEZWFJZk9lTkdNRGZvUnhUdWxRUXREajlhZzYxYVRsZHYzd3B2Zi8rRGJ6a1lYd0k5ZTc3SDVCWllEazJTSFhYbTRPREN1eGRCQmNqcmZTaUd2YjJzUHNPcXVFVzRGU0ZYV3FGalVsM0lkNWRKSmhGd0c4ZE40a1Y2dGtDQW84VDYxZEpmWUY5SEZ3N3NCVnRZdkJmUlhMcVlvYXZTQThlUFFZZ3pHaUY0UnkvcVNPWVc3Y0o4STFNRW4zRXVoSEVqV05zSThiY05WWTNyMSs1SGxMV2d5ZHZxQzhybnRnQ0YvRHdmL1ZxUGkyVFRtYWQ4bDg4blFRa0dTdmEwak04bk1aUjk1NjlmQjBTcW1FdlNyYm1Jbk14NUNwQU0zNWxLSzF2TDFFZWNZK3Fia1FpYkt6aGxjNTRiaUZobVFLbGhUQW1wVjVwU3dQNENZQm5jaitsUHFXMVl6enR6L0c2bDZhYzlYZlowOUJzSEJCQXVLMUlXMlo1UFVabFBaSjJBRTBua1NOc1hoWlJyUnNINVdsUUx5YlA0QVBLMDBsVTREeERzaktENlJkZnZJZXRzd2theUNyYkp1YUNRbFdTZlBjQk5aOHhhRG9Xd0FCY3lWS2lVOFhUcU8vSGlYdW92dzIxa01CcnhrZ2pmRlo2R0MwQTBNTmttVTVNekhaTTFteWtRUXpveXhmVDRYVHJSckJtR1hIQzEwVWoyQVllVlJZd2s2bXIwdTdNNUM3aWtackd2Z2wrdHZ3czBNZ2ZIc1ZmdndlZThGZU54ZnY4RkR3bXo0a1ZZa3NJUm1vNDRBY0NUVWJCV0tFUXVIaVpENFhVWWE5d3ZQMWJlNDh5aXgwajNGaXcxLzJJRDFaVW1IWVdzZkp4MklFQVVQaGdVYjQyTE1WelFUTGNHWGpROTFsQm5jM0NWWUVPQ2VDSnp1ZFppbklHVW4xVFVuRWx4WTBjb3ZNVWx5bjMyNnlkTm96eS9HUkp6UHJCVEpRVkFFelpRcUhORThGalJycm8ySUJJbnZjd082T0VhUnlYaUc4Ymk4TzZtYWZJNjRyaW9UTFRudWdIcmgweitqdElWZTNrMDY3Rm1iR1doRXhIcHhBN0VrODlUTm5BZm9PVnVKb3ZMVTdDdUt6QzRicWxBYmdDSDUvS0N1MERHbDcxcnlKVEFSTEVJWG5DZXpzNm1JRWJZRWoyeW1OVnFoa0p5STBPVW1VMklLdTY2UDlTZzFmOW82ZVBNUDVDeUxzMGt0bTVCWU44RHltV1RYMnp1Yk1JVTFTbkwzLzdUWnFlbTRiUjFsMDM0UDNNNW8yb2E2aHVqZVZ1dG0xcXhvTVpRR1NsYVJzVnR1cTBqSDJHOXpHalQ3QVFzTHUyamRwRkZnQm5XU1MyNDBZWTlYQ1RVQmtNOGFoSUJ1Yis3dmNQWVZ4aXkvRDdxbXRvQzZKNytQQXJWaWtYb2w5NmgyaFQwem5xWnljcTQweDY4dlhEOUwzM1B3NDFibUp5S296NHIyZkoyNFVVcEZINTlLZ1dWWlQ4NnRobTlBbnF3YTdWM3QrVHZuejZQSjFnQzlzRUZBK1E5REFIaDVQa2tmNWZxTTJmZm9MRVZhOWRxRXhTUFlMVjI3clRxeGNMR0xJeDVnUCtleVF6N0VNeVZPS0Z3OVByYVlMRVlkNHpFTEVlcWVHRXZqWEZjQmxWVVBPQk5IaUFlMFVMcXBDVDJSWUxEdlpYTFJMck5qUEhLVkllbWo2cnh0STk5a2JBSk53RXNCZlMrZHluSk81RUl3MENWaERXQWYxVnpWamV2b05YLysxaGFJU3dHaWFkdG82NldDaVFzV2VtVjZtZVJuczBBNGhmZWhhc0ttQWt4UTdyeHZ6SUJ6N0dacVpkMkszc0d4aC9iV01DUUFZcGFkbEozUW1hY1lQV21Da0I2Q29rM0puMDV2VThhcklaT2JqR1BkWDRuR21YcmNibFJuMUMvaTR4VVZVeUF5dkZCYWdJT3ZDazlTb08rVVNlS0JhelBDL2ZaWURLZDBubjNtUGRBZ2NvaDZhRzBGSk4rZkxuS2F2clhzdjVzTGc1SHVCdmxCYU44aUVHbnU5K0hCUmZFb0JGSlFLb2VMR0h6L3FvVzNIRmwvaVRwU1BlRmtER0hmeWxRdlFtZmN4cEdKWnpMc0U2V3VFcFMvbjBoU1ZTak0rTGZZTGVSVWR6WTB3SU5qaUFMYjhqWEN0OGpFTUhQUWRSOEJUY1RIVVJkZUNhUmF2MkZSM2tDWE5tbVZYU21VcEVDNVdXMmNrTy9sWnF1K2dQK3lFcUd6WExmbGQ1cHJWZ0h1ZXlneTh3aDNjenRnTXZSS1pJNmxKUFc0ZDZXMUVRRGdnTUpqUG5hQjgyaW1XTTRFZ3cxRm5mbGxkdjV0TnJwS0VLaUl3NTJOQThMS2VJOUxnSTNIdnZYYVFoL0trQXJEMVdJanV3YVRVdysvSVlESWNmRW94Vmd5cjN6dDJyN0haemo1MXJYcEwvaVdSMzdmMzRTSlVvK3pWT2pwT29NdnRJVjUrRTNXeHpleGxWc0NrWUIvY2dWRlZzWXhobVAzai9HbllQak5yWXNseThVQUpzSWF4RUVIcEJ5TXZhTXBrcGlBczBhZDRINzkxSXF3RHY4ZkUyNmdHcUtRTzNzMjlub0k0Q3NCcWJ6Y0pwL3FZUFAvcUFQcWRKMUhlWldMUlBQN3VUZnZDRHUra1hmLzJMaUVjam1YT2FKR3ptMWZPWEJCTjNSbHFjRmJ6dysvdUc2QTE4M0FEaEZtWjFCQVVZUTJOK2ptK1U4YzJ2SG82M01ET1VsY2NmT3RQd2ZJQUV0YkF3bndhR0IvSFA2aUozMXJ1c2FpSzFZUi9TYjZ1TVVicTdPMmZXTUgvVUZwRUJya1JENm95cEtsVmJjdFBjQmhqSThYcU5DcTlQVlRNU21kS01hbTlqR2NCaXNXU2Jmb0VDZkJEQVFXS0NIdHB3cWtTNGd0a1pWU1k2dDVDWG1jUE5nUHVVOGd5TTd1NXBTdSsrTjVhdVh4OUlnd05JZXpnTUcxenZpcTBPeGZyV1NTZlpsUWkra1o0cFY5cHpkUzdvVnZybEhyM2h1WU00endhU0daSU9HNXFTYitVTjd4ZDBCQUY1RTdoZ1lxbkYvcmlLSlArRzloL0dPODJ3VWMra3BLcHFOSVpCMSs1UjRKZ3FYT3pnZzNXS3JsdUhxY01zSkFWV1dhNDhuVFVVYWJ1b0l6eEx2eGE0UWdXcFV6YkwrSXlDZ2JnamozcklGN0hZd2ZmWVc1UVo0NzZBa3h1U0VUc3pKamVMYUh5SzQ3dlZOTlVvbFRJN2lhWlNxT0FBcklnSVVZRllDZVNPcUFRRXIvZ3M0VXVzU2tJaFdYRy96M3VFQ21nOWVGOTBYK1orc0libnNNRjRWMXlMaGpOTCtKRFNrYzhMbENCWmJETEpjOTRicFFnNjFOT09qblo0d1NkNUxsWXgrS3VFbFZjWExVWndwUjFScnY0bHpDalUyZnJZZ1RHYklSazZDSUszQUdlL1JWbThWK215bUYxOFB6b281L0Fmd3Zia3BoVG56TmFET0Q2MkUyWlNUUks2NmxvSHhsVTBRbUN3SDRsdkU1TWt3UVAwcmw2L0Zlck81anA3N3lHaGFleGNZR1ZxZzVURzdqaTlpNCtYWVJYbnVCZGd1U0pzcGlQOS9OLytESVl4THMzMlkvOVpKK2pZRlR0VzVGYVgxaUJkRFArOGE0ZFpXK08wYVkzUDhKMHlxbDRnTjJ4b0gyYnQ2bTVFNGlITEF5cVRrNUNaSGR3TW9VeTl0UVBORVJwa2VFa3JkcVVQQWNZS01pek16MC9HdG1FTVZsckQrTCs5ajVUSm1MU1NYc2QzcWdicGJOckRaNVBWd0FaVTNYZHVqMUhWUTVoeWhaa2JleDVHZW5ZdVRiTVQ4L1FONlZBNldUakEvOHY2Ym1EY1hsNVlTWC8wK1dmcHZSczN5TDJGcXNwS29CNzRUamg1YUtFM0pCeFhDK1VReDgxVk5CTWhiaTZRVGdaOWVoMlEyaWFJZUJXSjlZaTBMN29vSEtDZXppeHVrWjJDTk0rNGJwZzM3QktydGtZeXVOT1F5UmZmdlgwampRNzNwM1ZXRmwwWkRuc1QwbWJFa3BvckNJRFlvazhYeU9HL0R0anB6YTQ2ZVlJcWFGb1lrejFheTFwb2hLNEVBSkI0b0Vzbk50MGczSi9RKzBmSEJ0S1Z5NzFwZkt3M2ZmL2plNlJjbm1aMWVCRzZCV3p3N1ZyRXkvd1lXeVZUTGU4RzZPUTVlSWIvUTN2UkM1eEhza2JDazBmMGtlcEYxUjdzNjRST0lReE9abk9IZkl2MFJGc0VQLzJ3cGxHMW56NmJ3TmxZc0hMQkJSY0c2dTdLb2JSdXNraURFalpvbjZLQ3EvZitLNU45MWowRlNvU1JtYk05UUlvMmZTc1lVSS9nRi81NmlDL2hwQXJOK1YyK0tqQW5ZMUVHc0ZoQW9NcUJNUmYzVmRXWGF1NDdzQUUwblBUd2hyYy92cXhnV0VFcFF3SXZwck45a2ZmeXYrZzB2akFJQUoxbGlhUVgxM0xCbkJJNU9hZUx2aEtYWlZ0R2ZyTlBXNEdMQm5KZjZQZFJQWHJLbXh4YzduZldqSHQ5amZmUmFBbkFjeTd2Undlb2t2SUpTWXYzQ0VnT01pZXNXcnlJNHFLRFJYVkZ6eGh6QU1tQ2NoZ0IxL2tSYllTOVF2S3pIT3FnNGQwcVNRQXhJUHpWRmhBRFFIbUtBUzBZZks5ZUdXY1ZEUjhsRE9YWW12RTlRdFU2MlVYcW1FY1N3VWpNMUV1UFFDZ0VEMk5zMTExZ2JPd3FDUUEzaVVYRXRxTEJFZExzSXVOb1gzZGIxSGNWMTRaOUdLMEtBREZidzdVYlhkU05iQW5Zc0NMbEI2dURwMGhIalJCcGllVm83VktuNkgyTjVYYnNOQjJBL3psU2h1RTE3dGFMb1JrcHpnMVF5OWc1N0p5bno2Yll2QURHUTExU1RXMG5jTFlTSjlaakFQS01DV1FQQUQ3RXFGNlAxRFU1TXdrUmJ4SWczWWthQkRpZ3F1RmFCUkNZc3drN0M0c0NBdnN1YmcyN3BJUTV3azVqckNMQ0lTNFU3QktNZlE2SGJ0dzNNUDdqa2IvUHhnbGJKTmxiUjcyckpJL1g5TUlHL1VKcVlkVGRMejc1TUYwZUdrd3ZuejZOd0Y0M2gzQURYYmV5TjlXTlkyV2VLS2RUaGVZRytnN0xEWktaTzJSamUxdmZ3WGgvaU5SQ2RncWtWcVdTRDFtdHZIbm5jbHBlbWcyMXp3V1NoakkrWElEZkpxdUtycXp0NzI2R1ZGaXZBeWkwbzBTazA2WXhvZmFkaVJWMUdOYURQZHh1K0x1RGZVc05RcGNXRGRUbVpTOUJveVhLTFNRV2Q3MXgyelVYRWVBeXpBOHBEUTBDMUN2ejZULzkrcGY0UDgzZ2U0ZGFTOStjNEpxeVFueW1NYVJuak9VNWs2bm1Fd1dwbVBpZ1NTZDFLQ0kyK1hXU01NTm9INHNVM1lRM25hSWFGL3dhYWlOam9pM1RmUDlUTTB2cHlkTnAra1dWamo3RHdPNUVMc2lGTUFPTjJpL2E5NHpVMERhb3F1aytnOVNNREJYc2xRbHhsM0ZIVWZYMENCNmhQZ29MQlo0SVFzR2I4bzNZd05qNFYzeVJoL0o5Q2dXaVVqQnBQTzh6OGxVVnptVDNYYVdRcWNNdWRDRkplSU1mQy9KdklXbEZNVEkweFhrK1FPTUNNQlRmTE5SL3dmeDJDT0RsZmVCQ01JTFgxTE5OVHFiZUhGWG1HUjMwd3ZYQSsvaXVUUzNBakJ0OGkzRG95cDJTQUVNZkVwbDF5Q2xJTU9yTDFQU1RvQlIzWE5RbE9vTnpka0RVemZPQ0hvVHEvWDVYY2pUOWk5OTltMjMxZTNRZXYvMmVqZW01TGM0Z2dwUnFaRWhYTmlMcTZXOW1UUXl0aHVtRWVncVROV0pjMzRPWTNWNHJ0di9DVmFHRDdJOGFuRHNBb1A1TEF5ejltNVpFSXpUWkJKQ2VKdDVNUjRhRmlDTURoRXp6TzlqYmxycEoxbWMyQ0ROcXp1QmZWVzZzU1YrZ1VnME9OakliUHlZR0VHYXJLbU9vSi80T2Q0TUttTGVSMWIzUjBldUFETzJvYW9LcENLUEJadGFJelVrYlNSVVNYQmU1enovNXdZY1E0MjZzNXJsc3ZVekE4d3I3NlYwYTZzS0JzVDM4cEJwUXgxQnkwOHRwZGpLR2JoNi9KR1V4aVF4MXNxekhSNmZVUWpZSTNyK0ZuMWcxSzNxMzcxeW4zODlSWldWNGpOZU11NERZMWRtYVBuei9WcWlhN29xdEYvZnM1R3dzSnF4dEFDallVbzZwdHp2d3RBQkVyc2pKMGljNzVFbC8vcGd4UXh6Vm5vZUVRQlFtYXQxTytxZC85c2VzTnJhbGI1NDhnUkVaUnlSNW9uSWlzMmtEUGxIN1NFeHJNTnNtbnpWMzBYYXlvTXpiNzl5a1A4aXB4WTdONGRoSXUxYVlYQTVRN1p6QmxEUTFMTGVoTmtvVDI2eUFHbjZUTjVMUXFINENZQnRhUlVaUTFDY1hYNlJSaWFJT080L2c1QXFpazdjMDU1aEdNQy9qZU1oWXg2YTUybW9BWHJOTG1LanhqUEZlbkY4SW8vY0o3Z1hHS09vaTRnWWtTazh1NFRpT0VXVkJPMTB0VmdvV2lJNVJpVU1icEJZbC9PaUdDQlp2YjhIWkZsQVBGWXRLUlB3aWRJN016UjZPSytrbGpxbnIyRXF6dHo0QVQ1M2Q5N0tCdHBzczBFVURreDBlMGc2bC9TYWtLdmZPck1JUkZTRVc4REwwSjY4cWExWUpiSkFuZUZmQmQvSnp3YWVlTHd6ejltbGtnbERRa2ZjQ04yaHo4R3JtUisxLzltY1ZlWjd2ODQyWGFzZkprbEV1ekE3UGh5OEpsSVJKRFl5MDBlcmZTaXVlTCs0WGlLaEdscnpvT1NVd1grb2dDVUxDVnRpeCtFWWQ2WGpRblBLOHp5WGxrRmc0eCtWb2dBMjN6S2k0Z01RbnRvRUNGSHkzVE9LOXhmVjRGNit5RHBhbGJPVExyWitFNTdNQmZieGIwS2xGTExjZCtzOElTbEVPZGN5U28zekZqYnpIdXRxcEVtUUc4Tnd2QW55MCtlSzZkWW42VXBZT2pKb3hETVh3M1hYbVBrSk42R0NndFF1VmlXWjNnTy9BdEdQWHI2YXBPYkk2TVBzM280clZJZW5zN1c2SGdiZS9yNXNOTEdBc21QN3NpTjFoc0hsWjlobXVEOHRyRzh6V3FJL2pYUkRtSnM5aHF5RWxjR05OYTFyQTBXK0hsVFZvRHAra0poalVYT2VzQUpFaGZuWnhIZ2MvWmxzQ2paOC9mUlg1dFhaWXRUeG5sMm43dFpyeVZROE5UcTRFTEhWZ0hMblVIMjNmZzZIY2xKVzh0Nm1sZjVTdHI1Z3hrUmpha0ZacUNJNFdyUGFQYTlQMXE5ZGoxVWcvcXJCVDBwY0dQTytneXJteFJsZEhFNkZEbytuRjh4Y3dSQ1gyTWV4SE9IL1dBMEtqVjY2bVE5U1JHZXhlTlFCdlN5ZHhpeGlyLytRblAwQ0FSRFdjbncyVHhCcmd2RU81RzZ5VzNmdisrK2svKy9PZnNmSEZYUHI5TjZUT1FUV3RaeHphb0pWV0pLRnU3R0g2azhTZWdseFRpblVmdjE3Y0VWYndSZnZtOFFNQWpOUTMwRWdFSnlPVkd0N1VpaGYvTlh6bnpOYTVTNmFMNmFrWlZGRW1GbWd6Z3Q4Qkt3Rkx0VW4xVTJLQkhHSlNDVm9EUkpUZXBYczFBTTBocnR6cDMyY2lTTzJiOGtBanF5NU5TT01Da3RLY0lObk9acXh1TUZFaWUydXByb1Z4SWhra3lSU3JDWnZhaDViTVZCb2IzaUpSdVpOT3RXSXE3emxDUlZVS2hGd1pRL1lZNkNaZm1mR1VMdXJ3TC9pY01VTXdaRHU0bGZUdzBTVFNJUGNEWHBwZlZDT3RsOEhpN25iVGpJUkl0Y01CMWwxejNBRktYekZYRyt1UmxMWDlqUXoxQmoyN3VZWjhaRDJDeHk4RUhzOWxZSUlIdlJESEJXOFd2M2pHSTU2WG1jQVF2d01kRkVkakdNK3FVa1hGZlkzV01sK3hXaVpUZXZnM015cUlEYnJHZHg2aTE2UGhxa2VLeHI1R3ljSVpSQ2FuNkFBb1JqU1EzK3ZaaUo2dmk2QnhqditGaWlhTThLem5LRDBPQjFnN0YzZndIMERCQ0VnQS9sK1V4L29UUmxHTmppRjVvWUZGSi9FbnEzNjUvcUZTVXBhelh0RlA4WDdPaWRwS1Z4S1VieFpRQldQYnJjSFE4cnpYUXdPajMwMXhhNVhzU0M1N2hjL0ZQWTRxbmVzS3FEYVlFMVFweTRmdGtZQ0dRc3B5ODh3YVYxSW9xeTVzUnljNFJqN0g1MldKVkN5dG9hYTRqRjVKM0Y0MzZwcDJnVFYzYTBZTk1MOVdTMnM3b1RyN3JBWmlDTWZlSk9CV2taMmh1UjQ3Vm1jREdSY0lkbDdIZG9JQUl2QVpnOVphYmtzUDJkQzByV3NFaDBra3A3VWxWZ3hMTWZQT1kyUTlJZCs3WVQ1VFUyOWl0WEI4N0FyQjBqQUh2bGxkMktCMGE3Q2Q1di9lQXNpZ2hOUk5xcG1uYjVaUkpWWnhHYmlPcTBKNzdNMzQ0T2xMVmlpbnlHdlBpaHM1cktaSXVpZkZHZmx3UUdqTkNYVFV5b3FmSzJ6UEh6MmdubWZZOUxyU3EyY3p2QU9mSVBwdCtNYTFOTTZHRW4venF3ZWtQRjVQaTBpS2dzZi84Ti8vbkZXNzdmVDAwUnQ4MGJCSGNhNldWYnIvN24vOGI5Si85ZC8rMjlRL1BwNys2aGQva3g0VG9CMDdyTkNtRGxTUTZ6aUdsakY2cjJQb1g4R1ZZcGY2aEVySE9KL29FSXFVWURiWDI5akdydCs0alIxcWpRa0VOdzlvenZ4Vmd0RWVkZCtqem1iNXRKT1VNZ3pjbDlaYlVJTTZpSHRVSWxHcUx0RlAwb2VUTUVNZk5BdFpRQXRJZzlSWjZ0ZWVXOEVnbFJuZlpvQ3FIbURZWnFYeEFGVlZKOWRkcERnejFKcHllUm1iNGVRVUVoQzJvMUFIS2RSVlFITlVPUzZDakFBVHhtcWtOTG5YVldyQnNRNHA2QkxPd0dWV0hEWCtWMkxmcTJaaEFLR1dGZUsxOUppeDJ0M1hsc1hNUmxrbDdwZHV6T2VtbmRxRmhXcUF5NDFhdGtqYXFGcDdqbFB3bWJHa2dHRXJrNW1aVEcxREpYUXQ3Y3ZUMnNhVVZoVVdsS3dLKzdmQ1QxYjlYQ1RSdFFYblU1QlYzc3g0b3pia0J4N2tyenh2UWtXeEtiQkZ4OUZJU3h4c0JZTTZxOUlaZHJqU1UvQ2lrZ1lsaHFURmVaNk1HU05jR0dSZUdWdFpOQ1FtMlJNQTQ0WGh0Yzc5QVVKY3ppcGpCZ0VySWtRWlltSEgybG1Sd0U4VW9IS2M1SnF2RjBRdTFFcG5NTTRwb2lwZGFjdHloY1FHSXhjd2MyZ2NwT0U4YXpFaC9sTHZBR1Rxb1pIUnVrYW5DYllCVEJybGxiUUNacVBkZHJMWENtQzFUQS9MdERHU1JLaUZmUFBkRXFDWEtnQ0hvczJ1bkFqU2xtdjZGTE00dU5vRFBXQ0xhaUhEd0FhRVhoK0VicVlHTTFHb09taUFMV0UwMWNlcWsxbTl5RmVFRGd4emFaOWdDVjBwaDdMZFBzcWcyemFjQzMvMCtUMGF2cG4yS2V1QVpIeGJpUGROck56SVVwc3JlNnpxNFFtT1hVbnZldVpLUW41Z1p0U3lTbWJ2eWhKT21iZ29sTXZ1SFZlUnJsMjlHbllXaGdTQ1BZb01tcnNZbjEwOUs2SHltS1doaEkxbkJZZFJnNlV2RFYvbVZoaVlVQnkzRjJzblBqSVlpRVdHWXo0TnRMME5rSElMdEdQS2tDSSsvZjZucWFlM2g3Q1RUYVF1Vmd5WEFCSXpIVURRWDczQWNaU1l4MVZ5MXk4QlZ0cVpEQ0QvK081NHVuZnJTcnIzN3J2WS8zYlNvK2Z6NmMvLzFVL1R6Ly9kenlPbTdYZFBuNlgvKzY5L1NiNTJNcEdTN3FVT0FybyswSit1OWZmSGhQQjZoVXlwVEhXVmdOQXA0SEVLTThvd1p5eDhZRmhENHNLNUZIdk9LcExwTElaM3VoZFhEQng5TVpnYi9XQ1N4bTFVWGZkNU5CTkRTTmlNcDc1SVRod0NsQVo4VjlCa21aQzZYQTJFOXNEbEFEdkRZTlJtZUhIWU01dHcrTzNzSlBVUURyTHVxblR6T3FtMldZVVRvQStKd2R6RnByU0VYUzkya0lZdXFIM1FmVGc1WC9DbE93L0pSNHBVcHNMUjNVY2pQVGVpeHRhbDBWRWtjT2pXRENEblNLNkhaRnA5L25vMlBYcG1Rc1ZEN0U1ZGhJV3hBeEd4cmpWSWFlMEFzSks3a3JSSkFMY2NON1NDTnVKS200Z1ZhMlNpN1VCQzdzVk1vUGU4WVdGT3ZrSkFDQ0Q4RlZ6a283ZjVTa3p4eU1Ea2RYbktlK0FmZ0Y0TUtBU0IvRmVGblVId2tnSURMRnBWcnFtK0h3WFJhQXZYYlVCcHhFSTlSRHNQR2M3Q1BmUlc5L0E1N1U2T2pqT0xJbEhJS2R3WCtycjM4ajJrSng3TmdFVkhDRkRSeVVvcFZJcnlCS2U4c21qNSticlhmR01VelEwKzd3K2RKS0dXYUVlZ3NRMml0NFJBVWRueWN2bjUvVDV2MHZ0Q3NySStHdVlMNmNsMldJNXR6bS9Nei9GLy9zc2RIMldIbEJZdlErTExMaC9aN3VlTXdCM2N6cmNnMXZBcHl6MGQxM2FRVEV5VjNNckduamRHaC9FOFgrZjNObjNHakVSYjlCNCtSUnB6WmoxRWd1b2tjK00rUWNBQ3RzVWc4SWNOYUJ2alBaM0d4S0lFUjU1MGxwOWJPK3ZUeDUvZndXY0pkd2l1WVFwUGN6TnMzUVdEbFZHeDFoWndoR1Qvd1E3QVJMV3lWTG1IZ2JvaEFyTmZzQ25HYTdhV1h5SmViV2dZYitpdWh2VDgyWk1nUU5XaFdSeEQ2MW5sYkFDb050alZlRkVEK0NveUZtcmpFV0RWT1RTQTNhZ3pwM1FoblhOdmYxK29KelZJSWdZZlgrb2gzQVlncUFHSXpadTBneFFoNDN6MnhRL1NiZFRoaDArK29UMGxiR2dqNmRYRVNwckhGalc5c0pOKy9Sc3lPckJkV1JPQVVZbGtVRVlLMmxxWVNodnpjNm1qM0VGRzBlZkVIZGFsTDM3OFJmcjlsMStsLy9WLys0djB2L3p2ZjBsczQzUnFxR3hBOFFWQTZiZEthR1dKbGIxcGdIcVRqdHpESDRuR0lSR1Fzd3ZKd1ZWazZVNlNlL042RWpzV1lVVmtKOWdCUERWczY1UnJJajZCYUdNTGd6ZS9EZjZ1b1EzU2lwT2QyN0x2QWV3dTN1MHlLeWlFdWZ5dmZSVkVENm5JbmI2ZDBQUVFQNmU4U29LOXRRc09EdlNTN1lId2w1bE5mTUI2aUFpNHhhb29lYi9vVzlQem1QdnNESnNWMHllMERaMEtXSHgwMzFEdDAwQWVmRUwvU2l1bUdBcDdNRlNncEQ1RUZFRWZPYzdDV3NXbUlBZllQcCs5WGtpUG4wOHhnVUhiK0pySjZwWnhoRTFQQjlrR3BNY2pWRTZJakhmam1zRXFjUjBHOVN0czZOc09VT25nMjRYdHRaV29qQVpzZjBaN3VGZWkxSzhtSXZ1RkVBTmZoVmJHMzF6SGpBWGNHRmdqM3lrOGVJLzk3ejBleFROZVYwVlhZQWxzZ2tlcldoc2E3cXVlZUhnRFR3RllTaGNYRXBibjZZd0FDNzdMMkRLNkZiSVFaUnZSTVZ6djQxa0s1WDZMdEF1TGlvcThVU1ovYzNnTzd4SkVLQ1BLaWc1M1VDR0lpL2U1NGFKbGNUWTZQRmZQem9uSzJqMEJUazQwb1JyeVc3dVlkWEYyQ3pYVXpxQXVBb3hCb3E1UzJJYXd3VkcraC9XS1R1TjV3VEkyZlZSazU3SWRhaDA5UXYyTloyZ3Z6OWorSWg5WGxFSEZWRTlqbHFFZTlpdFZDd0x6cjJsQnlyeS94MEJSN0daYmVDNjdLblFkRmVqV3pSdjhYbWNKZXk1bS9oT2txSVg1TlNRUG1BUm0wTTFBQW8wZG1PMEFKQUd0OXZ1VW8vL0wxaGFiU0dDVGFtcHNSR0xCZGdVejdqSlRON0QzM3REZ1pjVDhSb3pqNjdSdEwzMzh5WlgwM3IwYlpQRGNUUnRJR2dlcy9MVzNZbmU2Z3I4VzlldEFBdHpWYnduVnFMYW1UQTZzbGZUOE9WbE1BWWc2bUxXUk1JMVp3b2ptVnJkUzMvQUlTZlNHY1VzQWRBSGxXME5qYWFpbGkvMFVXU2tFSkdvWW5FMGttNWRJUDl1ME55UUJtTUNVMFBOcnM4VHNLZW4xSUxtYzRqaTZpZHNCRWdMajNZcWF3WjhBWEhlSUx0T3ZmV3d2dG9KVDYyLys3cmU0VVd5a1VhU1JDaVNZdi9qTGY1OSsvMlFpSGRBZkZUV0FJLzVFSlJ3Y2lZQUNRSGJTNmpaNXFwUk9BTDlsVkJrZ2dLSXg0TlBIMHE0WmFVOFJwNENCMUl2TjhKU1l1VWxzaXJ0SXh0cUkxbldoUUNVVXdPcFlyWkFmVkZHMFhUbmUrclVwN1F0VU9ndWI5OHZ6WWNiZ0dVZ1BubUxNdUY0TFRkUUJDczB3ZW45L0IwTklVa0hHYTVSSjdJRDBRVlBUYnlpUGR3Rk9Pbkh1UjBvWmdZakhmUy9NNjhZVHZndkNoQTZya016UkVEU2J3TGZHTzhia3krUlhUNnFYbTllR2VCY1NJZU4yekNyak4wK21pQVpnZFJwcHV4WVBkbGUxMVVBTzlhY3lsWTFhREcyVDV3UkljM2ZwZE4zUFN1TXd3ZE90YllBOUVSazEySzRnRlFDRmVzaUowRHROenZ6S2wrZ2o2RDNqUmVaOTcvU1FWd28rZlB1Ni9PUzE0cE9sVnN1bE5ueEN3MnRHSmJRamJheWY2QWYrejd2aVpkK2luajNHRVRZVEN2V1F5V01VdUY4VnlTT3ZBaUd0TVRBMlFLSUx5Y095dVQ5MFVSNlRsUXV4Vm9EMGhTR1Y4VGNER0JWa2dBTDg0aHpQOEp3ZG84cW4wZElackZnMWRDQTFsb2Rrdy8xZ1ZyUW42aGNkYUdkd25jSHdDTGNJNzZPVDdEei9lb1NoblRwYlZ2WU5Rd1YxdG5SQW9uY3lXTmtXeTFLeWlqN2lIWVdVSldEWkZ2dUsvL0dVMTZ3L1FkRTBvaFdBNmNWRm9hT3RGTGFMUHBqRVRLQm1NekNndUtXRmRMN1lzMVlKRzZrSGdOendzNHY4V2M1Mkt3UWJIeklXcmhUVk5XQUxZaVk4aEVtT21BVjdXQ0Y3OXphN0k4L01VUVlyVGRqUURBaXV3a2c3U2U2dFdiSnc5bDd1VERmZnZ4N0V2bzVSZXdlSnp2VENWd2JiVXhrMXB3UGZwNkcrSGpZbmZVV2l1M1VNclAzVXBRL3BqOVV4VkNWOXdHQlY0dVJnMWxwVVB6N3VoTDJGTGF5RzFESlZxR3B6VHdTbjlUU001L2dCWVBIc3dVTmlGVGN4WEpNSERHbk1YWDFldnA0Q25BaTI3aWN2Mk13czZWTllVaWVwWGlYdUI3V3NEc3FJeG1pNjNIWGlTaWJnY1licmdEYWVIZFNrU296K1V3RGlyOWtKQ0Z0OXFpYWl3UHpzeHdEREtmcVhFbDA5NDlDRWJhZ1IyNUtXeEgzRzRoQzdpeUUzcmhvS0hLNkNHV2k5aGtIN01qYTNzU3RqYVpKYzVZS3hIdnFxdkU1S2tXNkZPaGxJbk4wRE1KNGpkYW5LbVorc0d1QU1VSU9HbkVqZFZFUkhUNzNLVDZsVEZhcVlGSVo1S09yVVFSYUtNemF0ZmZWNkJzQnBURi84OERQRzlCUVZqUzNpY0YwQVM2RS9YREVPbGZRb0IxcXlYRUdLenVHN0V5aDlBeTBZQmhZU0RXM1dPQTNwTWNraHpiZVUwdVh4UHVpYmRoQWIrUExOSXBMVk5PNFhUT3hJdGZwcnVjcXQvTmFNTGMwZG1BUXNiWFB5d1E1QXJHdEVVMU10Z2VoOXFhdE4zekg3QXJCSGpWYVY4MTF5cy95VCtVQVRDV1F2UDFKdlB3VVErVjB3S25oUUh2TDNQejdFb2VBNTI4WTlQbGZjVzlWY1czdmZIeUZKOEJLcUV5L2tyaWpNMVRidFU2RzJVYmhYQytkSVgrd0trTktYUU1UL1F1SVNKT3hBRDh2Mm8zVGlmU0wzdHlvbDMrMHdueFhvd2hBSlExdCtsdWg0bTJQRTUyMGQxN3JaS1AxZ0hNUXd1anRZL0l1R1dVdjZJVUNVT29XS2FGMTRUMXlQZG1UZ3NzUHNVTTliRnhjUHZEL0twMjBPbkdQaWRkdGJkTHEvaThIZ0srK0RrSUpnOG5kVjVBQmt1c0Y2Q21MR011bzhxQ1hpNmhqNTBRZTZXS0ZhakR4RkIzcCtMODlGdlpzQXJKWU9WZ2R4akR4a2c5Qkd3bGEyVURYV1VkdTJZRjU2SGJWRi94bkdCbFg5Z0d2YXlYUjNNSXVBdmpGNndPdnI1T3k1ZzkzbHF3ZnpxWTU4NHlPMzc2UmYvc1BqOVBYdlg2ZnU1dTcwazg4K3g4TjhNNDJ4eW1OOUR5RDBOZXEwRHJoMWtyNTViUk40T3RIVkFuY0FqUC9hUkdwcWp3bTFhYWJmNjBpWXQ0WUJsclRRNUVoYWVEV1pucUdlSFNHZGxiRjNHTVp5d1BKVE81TFIrUGdJMHNzQU1XY3RoQlZoUko3ZUpIWHhUWnhIYjZSSEQ3NUd1blQxMEx6MUVDdXFTcGw5QlVjR0IwSTlYc2Uxb2x6YmhEcDdrbFV2RE1mcmdOSWlEcW9IMEFJSlRKRm1hQ3VnZW80WTZwSThMSmRxWWJZRzJ0OEZFQi9SLzhmMFNSMUF6bHlVMnJCTE5Tc0p3ZXhIcUxKc0tFejZsUjZram9ZMGcvUzRnanJtZm45bUhJR3NvQXZVRjJqRDdkZjFkbmNEV1FQcjkrbDdGMFlhK2EwSHVQUllvN011S3FPRUF5bGhxT1paNmdsMXNna0dORVQ0UWh1TEJXM0VJTnAvQm1GdjRiTzF4MnJuRHA4dG5OaDJkdXgzMnVSejJuaDQveEh0VWY0VXFHSXh4L3I0RXZrbitGQnBqdWNFU3lDNms5QXRzOVFhN2ZGcVlpazlmRG9WRHIwblNLQXVIR2ptVWFxc2NpVVk5YzZZUlJvWU5HUnRCVjIzV0d0cExhRldzb3JaUUF0WWFmVDlJYmdnMFVabUU1bU4rOE1EbjcveUZOV092MXo0bG0rQ3h3QkQrYVk0Q2pBcStNcnpmaTkrUjJJRGZ2dXNuOGlIUlpORFYzVFZJWGVBUUNIVFg0aHl2cHlIckVnd2FrZ1YrWlZLVHhwRkExRTV4UzF4bjJBaEExQi9heEFWRUJpOHo5OGVVYWtMSnZlOWV2MTZqZ0pCY09Sb2psZ1NCMm1WZUdJMmdFbmplYW1PbDhtUXBzUFFmaENYZUNZYlF5ODZqZkt5VFY4UXplQmt1VVduMnA3ODNmZDZ4WEpvZDN6aC9haVdNWHRROTZJUHZPUXpmcmdib3M1QUZvL0UrUXg4MmMrRUdaOTNCTGhUNTNPSXpzMHBUcG1wRnhaWUltY0ZycDZRRlFIcmdDVjdDVkxnY1JWc21pM2tYMDJRZG9hWmJnTUh4azJrTDE3RldHazNBZnh3N2pOOXlBWXFSRFYySnRYREJkU3ZmUXprblJEZ0dTQlR6UkozTSs0R1p4aVk2NXZiMHpGK1dJK2VrUnI1OVNvU3l5NFIvTmg3V3RuOGRJajlDS0hYcDg5STRZeFUxSUh2RTE2YmFSb2IxNk1YazlpeTFsQXpLd0VmZ3BmeENLOUdsY0VVQTZQQjJLaVZOMjdmamsxZGR6RE8zc1VSOC9xMUsybCtZWTVRbnhWY0NEcklib29rQnBEVUlOSHNFb0t5UlA3M2QrN2NSQlcramEvWElqTTdxNFVzUXFpaWFPUFNjVkVtTngyTXVldEozaFVxOFI2MHRzWDc5bUM0SSs1MTBhVzFDWHNVVStVNS9WUUhJTlRpVEZ1SDlOS0FiYWticHU1bE1VQW9XY01tcGorUkV0STVmWFBHZFF4a3NTTG1SS0xVdmNpazRBYTNTMlNDMkVlNnFVZG4xNzFEYUNqQmJHVkFUaW1wQVJjSlFleVF6Qll4NFVFSHhpeEtRdHE0WXFKamdncDVJeVprWFF5WWxIbWY5VHNIQ0RhUWJBOEF4Wi84NU1jc1FQU21ONU1UMUpJWVJDSVR0cmF4bXlsVkNoQ2MxY3poZGxteWg4QVZ4Q3I5dzJkR1pHaDdjbkpIL0lsM0g2UGVkUkVHMW9lMHZNNG10ZzlZSlY3RndGN0Z4SkwzOElUNXFZY2VYZVk5YzRJMWxiZTdnbE5TdkM5NEcybEtwK0grM21aV1VoVmNlSVdNeGoyUU5mL25MMUprcVBxZXRZSWNDZ2QrbCs2ZC9QMGVmSFJ4cnJpdnVCWVBYZnd2ODlWM3ZDZVBlbmkrcXJVT3gxRytlTXFIZFhvVUdBcTdqUy9VQ0MreitwSjRXQ2FuWHFwWTJmNmx0QkZOQ0VhM3lrb3B6alpLVnJRcEFDZWVWYkNKbXpsNVVSSDlVK3pzQURpZWlmcnd2TUFSc3hwbEJMQlFVRWhMMXNVNkEwQVdvZlBjR2FKc0JyUXNvZEZqZEJabDhUcStSR2ZGZGRxV08xTDE5enVweWZLc2xqT01hcWNxU1JFdVpDSDJnNGZQNXVmemIzb2gyaWJFR1docU83UW4yQmFKeVhvTC92YVY3OWN0d3BudEVOdkFHcEtHTnBoR0RNRFgzN21PTFdzTUpqY21qODBZOUpwbXRsekh3SzJFMU5KTThyVDJWbVkvSENBQksyMHJocjY0bGRJZURvRjcxSGtITzR6T2tSRjJneUhVUE8yMStQRWM0aVd0MS9vS3h1ZmZmL002RE1rRHJPUmhGbU41ZXl0dG5DRHhyRXlTSjRxRWQ5WE1wR3lndXN6S2xIYU9xM2Z1cFcxOG9GVGpERjNweE9GVjM2eGp3bHpzUDZQMzE5ak5aaGZQL1Z0c0UzWUZSMUd6clRiQjJEcVVIc0RRbUpPUVd1YlRKcEpNUzNkbnF0UVprUUJ2amRYTDJNbmNodXQ3My90ZTdJczROYU9mRTRDQlZMVkhhdVU5eXEvRDI3MEM4RHpBbHJLSFVWbXBTbS83UTZRc1YvWkdVRE1ia2I2cThWY3JBUVRkMkc1NjhSTWFZZlZ1bkd2dCtMNHRzUXE0QVBncG1kUmpWQy9SZjBvZWJmaGh1YVdacTJEN1RuNDQwVzRBV0J1RXAraGNxY1JhajRUVGpMRytTc21DZm5hbFQxNHhMVThrN1dNY2xHeGtac0ZBUTd6WlJPVXFEZC9hdUJwQXVidnYzZ0NZRTZyMWFpeXdRR3h5ZHRDbTlWSjk1ekdpRFpDb2thUmRqVFhBWGpxcXBUMXFPNUdaRkg0MGJiQzJMS2d0dENQcE5tZ2RhSlhoekhYVzFkTkczNUg1NDgxU21zVG1kMndJRWRjeURRSUlHUDZiOFFlc3A0MitJNXhHUWFtczFLbU5vMm9DaEFQczVOMkRwenptZVhpYUVseHdnT2Q0UzlSZFhnbnpSM0E4ZHdUdFovNFFaQXJlQ1Y1ZzdEem45K0RwNExzTWJQSlZBVmJ4REw4OWludjlIb0FsK2lqbWViTVNEYkJrdS9ndlB4QUZXVUYrOGg1Wk5BQXJHSmVCWTFqb1dKLzNDUkdYeWlKOHlMUUNGclRCL1ZTY08zbWNqc3FnWVFoUDVKSmlwTDgxa05zbGxHT1ozaHQxdGc4RW4vaGhvMkI4dnZzUmtyQkxzdGtuOS9vQTk2bE9PanR6aWFMOHkyck9oU2lheTZCMENDWGF4YnVzcC9YakxkRzVyZ3I1c0FRU2JlRjU3N0h0UGlPeCt2R3dMaEVwd0hjQlM0QlZ2ZloreTFPVmhkNDVCRjJKU2pMbTRMM2FnYlp4aUNuaFJkMURFSEVGOFlXYkd3djhKU2thYmdPOXB1QTE4d0JqNDNKemJ6ZlpGdm9Ia1JMT3d6UCtBTXRyRGFyTkliUHBBUVN2VWJpUzFidFd0bG82d29QYXJiMTZleTZSQks4clBYMUs1b01OSTc5U2V1Kzk2K2xmL292UGNDTllUSk5MeTJ4Q1FTcG43Q2E3TUdvenpJbVhDb0VBQUVBQVNVUkJWTEsvVTRFTmF4VmZwRzEyZWlZcEgxS2dTL1ZXM0IxeGRIN05QbllhK1kwdkk1c0RIdWc5YkIvZmljL1Q0MGVQMHJObmp3Q1ZzelJ5WlN6MVl4dHF3b1ZDYmpXOVhVMFQrWjE0WmdFSDFoY3ZadWpucG5UNTZnMVd4VGJ3RVZ1RFVabkFZTWphaHVxMFFMQjNCUURoUG96N01QOHBOaWc2Zy82blIySHdUbXg4TFl4NUdXbW1EVnROTjgrTXNLZ3hBQTMwb2JLVU1VaHZBcHJ6MlBpMkdSKzNPcXRudGF5U3ZpdmphbEZIRk1JeGl4WHZ2WE1EOEs5TFR5Y0JWa0tDemdHZVdMeGh2TnVwYnp2T2txZTZkZ0Q4Z29EamVBUklNcEM0bThEWU1qR3NycGh2MEh3QUM5TGM4R0J2dWtYQ3huWHlaKzFyZ3lNSC9qQ3E1eWZmK3dBNlZRWEhFWlpybXppTEtpM1BFaXRvVGpHemxDcnhLU3hJY3lYVVRBblExVHNsZHJnSVdvWGJvTDk4b0FaQ0oyWnhjUEpsRllSMjRhdEdDTmNNOXN0dFUwZXdJaWdwYXJOU3FxcGpHZlh5NkNXazZWYmVnODhXcW5NSk1EZjFqdVB0cnRINmxQWDNkMGNDd0VvME1ERlNNNFQwSEx4RTNYaXBuTU01QUMwbWRybFNEU1E3eTJhMWticDY3OFVoL3loeEZRQWxLSGw0ajk4elQvS002akRuL0hodlZaTTJMRi9IaTJSdXN6V0s5bWZNSHBZaEd4czY0TXZ0aDFnUnBJS2hIaUVCWlNUMFpUQ21GYUNxd2R6Y3IvSEo4QldmazBFRkJmVmNmM3VQc1hwdVpYVU1RZWwwcGxoclF3U25rRmJzQ3hBL3dFcHBpOEVKWXo3Zml3WjYvd0V6d1FudnNzczhUSGNya0ZqblhETTdOMS96LzBwZVhqY0ptaEpsVVZiMkI3T3FFbDUrUUNrcnZsSVB6MFFiTE1TKzRZTEFsOEhVTmpIekFYSmU5THZRUkJPNXp6TVp2QjI4UTFiOVhPSGpadFE5bkdDUnFQcVJlRmdUQ3BYQitMSkdDS1VDSXRyRG51RU1lUFhLWlo0N3hybHpQaGpGalVyRGVSQW1qRGJTSjBwYnFzNXRMRDAzNENpNWdSMW1pazBEU28za0dpYzJiMzZlYmNoZ3lydjNicVlyVjd2VHIzLzdCOUtvc0FNUEcxUXN6S3FxTmlOWjRSRlB5aFhJT2Ewd3l5OWhXenBVOGhDdmpGU2hsNnVKa1hSemhGNWlJbi95K1Vka0FpRGNSM1dXZGtrQnJVaU1EYWlvUTZNamJQdFVqMHI1QkZVVWFRKy9zR2t5SnBTNFZvVlVjNFM5WnBaMEtlYlpXaWNwNERvUzU5ajQxZlRKWjUraUppUFpjTDliWVczaS9kMUFmeGdudVg5SWxnZ1kyWHo1ZFl4VENZWXVvU28zd2t3M1JnYlNkVmJlcWtrQlhZL3RyRk5nWWZKNHNieVVacEd3ZGhsTGFVVEcxTmp1TUsrUU5zZThYTzNZRERlUkdxY0FER01nZFJ0aEVNUE81V2F4ZGZTdE5rRjVRdHNXUkJaT29EdllzT3dmMCtrWXFzTm94N2dySmJ2THpPMmJaRFRGVjJsaGJqcFUvYk96L1hUbDJsaTZjZXRXN0Z4OVRxYzJNbUVKY3E0QWJ5UFp1UnU0RXBSMEp3Z3FrUnVWSVY5SzcxU0xkc0JFMExEMThWRENVZWlBMG1PQlNBTytvVFRhdzNaSmszMHFXRUViN0RyRFNpL3hEcWozcXZnNmZFcllBcU9DaER6Z0JyODZubW9KQTNyWmRZaGRvMXZJeG9Ed0poUUZTQWJSOFZ1QVlsSjJNczZuK0EydktJVjZpQS9XVVlIRWlUeGU1dit0Q3dXNjRLWjBKNjlHeWluK2VvOGFYcjQvODVtODVtODJVcTI5bitVVWZhMGdOOTZubENBd3lHdytMc0Jrd01xcmVRNTZWSjE3TXZJSlJwQ3lqYlRUb2hObGNKL21CNEFuS01RTXhGOFozUEpkQ3RjQXIwUmhUSkxCd25aQTFuVUZLQWJOZnp6amJPY1ltY28xd0pMemhrSXdac3prdkpmM1IxMEFQVVY1UWNleUpHNXVwWU1FeTN5UHRSZXRNMUJSYityamUveWRBWXA3ZmNoMitJRTVZcldTNTcwU2JoLzh0WjRTbW45Rkpab1RkYlM5YUdTZXVqaG5QWE5idERkb3lIVWpWdFc3SWFTU1ErTDN6S3QrZWJRYkl6V2d3anZQbVRCMHF0d2k1azN3cmtFcU9DTFllQUtQNStVVjR2MlFKQnBRdmJheGc5VFdraDhKbGNHMHYyZmtMWExqQ0tYUENTU2syU1hzTkJERkVXcVh1L1VLS080Qy9mRHhNM2FmM2tpdGVHaWZuYkdpV0dGc21JR3JUY3pHZ0FUTWNhSi9EVFRoRnV2VkVHVTdzWFRLeVJySTdkZGFZaUpWcFRwYldxUGM1OWk2bU9yU3BaRmh5bUZwZ2Y3Y3djQzh6WVIwaHYybHNRM2d4SFprc0hBZGF0TWhqT214emVMQ0VzbjVsbGYyMDRQSE9ETnVZYmRpYkx2N0JobXpodlRzNGF2VVF3eGxPNnRWZFl5MTlhbUZOc3g4MEVqZnQwSnpOZGluZWttVDQ4NDlwOHZMcVJkMXNBTzcwQjZUMGl2NmFFR3dvdzNTY1MxZ1NZOGdYU0cxa0hjTWRBcHczNEt4dFNtNUFpMU42QVRzeDhubkZOWE1XTDhqdnUvVG44ZjByeHVGbk5FL2RGTFdJaWhiVzlBeHJoTmRYYTNwODg4K1FsSjlrUjU4L1RoOThzbXQ5TS8rK1k5eFFhbkU4TDBIaUQ5REJTY3pCMldRRXdRc2h2YXdtWm52ckM0Q3JDVUNRMlRNVTQrOUVJZGJDRHI0SUhoRTlKRDRwVGx2bFhZcHl6cTZlM2JzTmNES29DbVpZOTlIYnFwZ1lxOUY4bkxYbjdLTE12Q0s2Vy9NSGl2VDFqQkcrdlp0U3l0SThZTHdHUzR2dXQ1MGQ3U1F4MDBwanhmYVpidzdTMDZadCtUUE1DUFJYL0pJSkNLZ3ZzSDNQaUt3Y2RCdFBNZDdtSWhPVU8vZHQxUEpNS0lDS0Zod3pueVptNmFrU3JkbTNxYnNxdGI2MG4wTEVyMUU3d3RXallKbDZwQlNlSEUrYUxSdnBFSUJHcFRrVDI2TG1naFlYclVzSlpkUWw3aEJmWmVocDlhVVRnZEdTZzFmVG9lNkI1OEVFV0lzOXlsUmhUaElvOHg1eFFsbU4zVm1nUzVMTGQ4MmlIdDhvNkxyQVoycnFDd3cySEU2NlVWYkdGTk9SK3V6aEVmZGZiZjNVTGVpSTdranpoZjMrTHM0N0FQYjVIUDJrVE5kOUFQbE9sUFlvNTcvZHJYVVUxNmpmR29kYXJIdnNXOXNRM1FuZjBsZmxjWUcrN0N4S0lxZnBuLzJzNSt3c2xiRGpzbExHT2NKV29aQXVydkl3c0NUcmhpYW1NNFFFejJMdThtTU1EdzZFbmFnZGR3aHFnRXZWVVA5ME9vUTYvVy9NblJuSHlac1FhSVpiQ2ZMQTZ0MzFhZ1VKYVNsZllDd2tYUXhTaktYeG9mU3pkdlgwcFBuVDltVm12QVA1MWJxWmdCeHlVMEZtQ1NhVU9mZ3RmQWo4bnM3cXBRRzVBalhnTkFtcHhkQ2Vpc1RBTzBxcHhzNDdGT2ZQV3hLNEN6bEVkZlhqdXNFcXU0YTRUYXNMK0hnU2Y4RFhnZElJZ3ZrMTVwbVk5ZEZZdVZXa1I2M1VmOVdNZWcvZXpZSk1GYXpTeldyV0RXbW1NWmhGZmVIQ2dLQzYySGFTdXgzTGRCYUwrNFlSNjVrNGhuZnpmWmszYjNrazRjZXZ3SzhKcENnanZIUXJrT3QwNjFDNDdnTEcwTmtTVzMzT1NhZGVlNWJwNDhOdlhIR3J6ZjBCdTNBeEgybVdkWk5ZQXVwVGR0aENic1pSVE9PanFoVEc4RENpaUVQaHZwdW1oZHRWcTZPdm5vNUJYaWZwNXMzTDlOTFppVmxKUkIvdGNtWkJleUNTS1VBcEt1ZlJ3UmFhOHN6d1NPaVI3aEtDRlR1a214UXM3WkNIWXRyc0htYTJnYVRHZmRlVE03Y0Uzc1A4RjU5RFpYTzVEMTV5Y25SeWR0Skg0TWFxNjBzUXVEKzBvc2JEUmNwTzl1c2E2RVpYWU0wQ3lpVkhXa0NBUGpnTGo2NE5rQ2p4QjNEdXd3bTdZamtBWHlUbVAwbmt3a0RZWTZCdDRKWEwzak0yd3Fla3cvODd2UGEwZ1M5TEUxQlo1em56dWhQbUNmekdPK0s5TWo4OW9oVlFwbFJFTEF3SlFrWkxaNzFVY29JaHJjb3Znc21vcXlNTGRCNEJOTnozb0d6UGRrbElZdDRXWHJqcEdEbWM5d1RTN3hVbUdtTzl5bjZacUJTOHNvTkVyUXlPdWY3ODd2eWpJZW9TRVVLVU5RL2lzZ213STA3ZWJsMVVMUTA5Q0xxUnpzRkRZRWxyMUJTWDY3N0hqOGhZdlBYOWhlZjRweHRzeTk4bDM4OTd6MTJiSUNSZmVFOU1LT0g1ZWN5NkVmdjRaOTMyR2ZlTDNGelEzd2MwRm9sUXlTVWRwYmFUMGk1VWd0aHQ3RlN0clE0eXpzUnhTRVN0enBmeHgrckRtZE5BMk8xdStqL1kycVA0WkZMeklMSGFab2RWVnhOWWo1QUdtTk0wRGlQWVlSdGJERW1jYnVLeFBNeEdRa1dYcnhNVjlnMjZ2cGdQNnVIcUZVOG83SDhyQnJWY2ZwTk1HU2xESUhVNFd6cXNydTdWNWVSU1B5YzRBbXQ0ZG10eWMzNVhsTkZ2R01YanFwNDVHL2lrcUNSMTlsOEIvdFpNNTdRNjBpTGh4RGxFallhaWNlZGdnOU5HU1BZT0lIQnVFMm9laWFuRXl6TzhRMDZ3dy9yZ0JWQk44OTROVEdUNWxCWnYvajBEbkYrUTZ6cXJXUDhKVWdheHQ1YUkxQ1o3cXhGTXI4emVvVjhUNWZTcTJta00xWlhXN3I3RTk0WTZldloyZlFOTVpFN0x0ZlRMaWZVUG15QXVoenNxbzR1TEZCdjNDbFFuUTdwcHoxQXc1VFQ3dnJUSzdqU1pwbGMwREt6aUdsalRFZHMyQXdrQlAzUXp6QzJ3MisyQkY3QWY0QUNmbC8xK05xOWV2RTZYYjA4bXNiWXVHSU4yOXpFeEZTYVI3cGRKT3hubFpXN2ZienB0YVhKRzZwalN0R3FZNnB5MWRTaERrTy9iaDU2a2d1SXNXMDlFcDJlN0R4Q25hUnRwQ1JNQmRxN0JDdHp3Z25HU3JGS1NIazdlL2lQZG5BSmtLOGlBV0tKdlNTN0l2TEMxZGhJZDBQYmRwZ1F6V0lSZm1jU3RDNFAwR2dKVzVlQit2cjJLU0tFc0tKaG11OGhiTUMzOG9Ubmc4ZThRdjNpSE9mbEcrbS80SnY0eXoyZUMrMkU3L0tHZkJMQ2lyd2NtQ0JQWm9EekR2bTFTc2RSQzFCcThBZzcwUVV5eW56QlpoUnM0YUtpekt1TnlDTVhscS81T3dRaUpTRjVVbENJYy94ZllPTjNUbU1EWTROVXprTFZJTGk1M3NNR1pBRWN2aS9iaVZRYkFTZnVsdmxqcFVRcFJ3aXdMTzRMYjJKK00yNjhLMHRiQWxoMEZnM09IVVI1VUpSbHFsb1ZFcFR0S1FBcU9vSTJlM2plajg5NmhOcG5nUmRIY2Q1bnZFOUowa0VMVUFJVXZlN2RTZzRlQVpUTUlzNFNXVUxrcFAxRG1XWVNvbVd4QWlTMHZYNzVrbGxNeDBsSTVRUUFneGwzVVp2Y21VVTd4QnBMN1NXTTZvcnVocERNRWpPM2dZTW1oVUJzQk5YU2hqclQ1NklGSHBMN1NmQ28xV21RMlJsUkxKMGdZUTNnc0ZxMnorbkRlamErUENSTXA3bWQyWlY3Um9kSHNTMnhTb1lOeUhwMW9TNDJBSXhWcUVQR2ovRTFZdEpLdlAvMGVBdGpiRk42NTUxeEFyczdzZE93dnlKU29iR0tFOU56WWFQU25XRTkxQjY4MUx2NjB1TDBZdnJsLy9OcmdyVDdVbTl6WjNyNDk3OUxZNENwQ3ozdUdtVHMzT0Vlb0U4Z2JvbmxkKzFHVGVSNlB6L0QvNnVKM1pMMzJZQmpUYWtrajdIUzRDN3RsTUdtQU1WbmhBNHQwUmR2VUxFZlladWFnMTYzcVBTeG9JdmZtSkxOR3JheUtsUm9BV3FIbFZxelQ1Z255K0dTOXJVWEV2MkJqY2Z2MmQ5SzhuVkx0MHFBMVpBWWJZbXg3UmRqcGdwajZtUXBVSjh1KzlGVTFCOTk4QjU1ckZiU24vN3NUL0JCdTV6KzZxLyttbWNZUTV4dlhRVmxaS0FCeGd2d0xGTnVpYis2YzJ4cG00U0d0RUVlWXJRLzV3UG4wUStOTEthME1NYW9iS3dnNjFwUWlUT3EyNGJwenFLa0loMW94M0xGOG9KenVjZVZSUUNEQ2FvUkFOUU9WOEY0bW9QTEFQL0lmb0xRc0VPWlMweU0ydStDNzNoUE85RUdYUjMySFJJdTJXM04waUJYQkNqeEpmT0tQUEwvMTFneVgyUWg2QjlyTWw3TFh1N2F2UGpIMkFVenl5dGNjNFU5YTJaWktNZ2FYcDd3TFFzSnEvWitBQk0zZTRSY0VOK0ZHMitVdWV3QUdaVHJTaEdGSkJUM0NTWVNrQUJES3k2WVVTWjJCZ2NuNHY3Q0xoWWJGZEJoU2hCbGlSSHVpbUJtYWwxTng0V0V4N042dWFOWWNoWkNpYW9KY0h6eFhTQzJyYlJXMXRpYW1qak51QzhIU3ZXeVVFZGxCdU9iUW8zekdtVllWK3NzdUFUQVhBQlNNUk40ajBjQlZ0NlRKYm9NMUlXa0ZaS1hZTWgxQ2NYRFFkQU9wa3JvakNPb1drdSs4S0VOZ3BmZ3lFOFR3OUdkY1o5NWxOYndybTVzckU0M3JvMkVZNkU3eXl5U1piT3VGZ2tNOWVOY255b2NMN1VQbU1GaGZRTUhSRllFKy9weDhHUm1OSmxjTStsWUdsaWFQMU8xY1daRDdMcjN6cTIweWF5K2pDL1ZFVHZQTk5SVnBBOCt2cHNxOEtzNXJ0eUhDZWcxd2tBUTAyZ0xmMUNCZG5IS2xBa2pCSU1aM3Mwd3pCM3ZqaTZZbzJtVHFWY2dhT3hHTlREM1BsS1ZobUZ0TnpLOVcxTzFvRUswTjVOQ0dIZUxrejNheXB4NHJwY25rc1diNXhNd1pYTWF1enJHN2o1MkR4S2gyUWhZSE5oSFdqTTFUaGxKN24vK24vNGQ2VXVRcU5aZmh3Rjg4aFV1QVdnckxmaVA3Y09FbTloOWx2RFduOFdsWVJPazMwVXlXVWVhT0FWMHFtRnczTnpUR3FxeDlPU0dISnVzbW1rYmg0Y0Q2R0kvUHZzVzhEQ2NxUjJnME92N0JEdlRPajVrMnNzRXhHMnpLR0NVajAwZEtDdnNYTkNlU2Y1VXQ4SldTc1gwemRKcGR3dndORy9XYTV4cDNkNXNpNVE2eUFjQUg3WTlVdGNJTmhxK0txbElDeXVYUmhsSWwzdE1QRlcwbzBROXROZWVFc1dnNnRTTUh4dVBSem03ckRZNlFlczQ3SFppMG44dHE4WFNuZEtWNU96RUhPNDEwTGx4czNVQWxTbHlWQy9OL2VZR0hhN2cydys3cU1pSUVEamxHaldSYzJZMW8vSmZ2VHlVcm93UHNsOGwrMFJpdjVSc2pRTU93U1Q0VzlyUHZDTFBGQk8vL0ZkZ1NzRXJYcGRQUEFxUWlyVGsvUGE1NEQyK0M3eUJKZlFqajlCUDhsQndVSjc4bThrNHluMXgyRWlQNHE5QWxabVhCK2dGa2RSQ3dsRU1qdE9EVzI1OHUxSVpMZ1VHUlVmTDRqdi83RHhaTndZQjI0WTY4ZWRmdkkrK0RjRVJmS3N4MnJLS3pwREE2UExvZk44WmxhY09GUkNQSmRYR0tsdnVHTlhCa0xib1RDVXM3VmpjRmd3YkRhSlEvMW1paHdhL0FwVGl4TVgvUENlWTJJRWUvdmE3SFZqOHR0Tjl2aGlRcUtBTjVkNG8wNi9jWTNpRDEwSjhENENGcUdBSUxsT3ZEUDZHT01RN3FKdXpvRUJSeHRieXAzLzY0M1RyeGhXWWwrMnp5T3BnSUd3dHh0Z2E3QXpOcEp4eEVNMkVhWXJqZS9mdTRiclFSeTV1RXVraGpaMUNjTHArdXdHQjZrb0xqTnVDMnJXTTJyaUhQNWNFMWp2SVpwaUVobXpqRjZYdGIyYUdsVEhpc0IyakE3Nk1YcnBFM1hIYXhCN2tDckVwWnZTQzNrVHljbWxlOWNWY1VKdGtBWFc3cTFVOHd4Y1hsa09xN01BNE80eDNkUmVPcThjd3ZhbUIyd2doV3BpYVJiMmJSem9pbXlqU1ZGTmJXK3E1ZWpuTnJDL2dxb0NkQkdseUQ5RFR5T29xNnVZbWZsNFl5bTllYThGMWdvMGw5dGZTK0RBNXRraGs1NzZHWnl6UTdPREhkWUw3d2FHMFFqdWxESGQ4YmtSU3diK1E3QUtrN29WbXpaU3BsMzdzaUEyWTQveEdQMlRha2xCMGVYRmJNVlBNYUZlc2dNRk5yM0tJLzVUQTVDcWdDem0xQUl1VGxHUGx4T2p5dnVNWHEzT2NFK0NkdEYwTU1qR2ZxVm02dTNySTA5NkQ1T0ppQTNSRjNjei9wUlFFZHFCMjRyUUxHRlVnSlVsR1RERmgyRC9odXd0WTlZSVhkS09yamYxekFOcUc0eWJsSE5CWFNrUTEwaFgzMjIvOHlUWWZhaWpaQnQxRHc2cXBiYWgwdEJvdXdOQ1B1aXVmYUwvYm9aNTlnOE5NbG1VQUhickNLTzlFTkhZSmQ0YldPc1plOHFZUG9EdmZFM1F1TDhZUFdoMHYrazRJZUp0bi9PNTlmZ3Jlc3I5Q2NxSWVudk9hUEpVQnpYdkZHVlZKQUJ2aEpsN0QvOFNqcXZiR2h2dnhZaG9hcXBOTWJRWG9mSUhJSTBRK0pCVmZvbjBvWmdha29lSUZjWk5FdzRmbThBSUJTc25JbDFnYzU2SmN4RzRhemVpd3dsV2IvdXhmL0pOMDVlYTE5T0xsUktnOHNTVjRHUHFVUEN3dmlnc2lLTlFwTTJFcXZZUTZ5ajBSbHNOTFloZG02bmFBTGkvY1NKRFdKVndyS0VpQUVka0xsTGR0ZnJldXhhZjQ3Vjg3MENPa0lmNFdBT1cxNGhPZFRkblp5Sm5QdStyamE3V2grWXlxb0laU1p3N1ZoOUR6WTBEb1lXZFE2dEZNM0dBZFJ0NTZWSzFEN0Q0dExITWZzdm5BNHdkZk1VdXZZOFJtaGFaczZBY3pOdnZFNlFZeU1FaklCY1NnODZDcmJBdUx5OWl0aUJ2azlWVXdnMzhIK3ZwUWJXclQ2OGV2VWlQdlZBVWRKQ2Jzdi9pdi8wMTZPVE9aZnZHM1gwUEUzUURNMWRnbHBSNnc3TVJCY0d4NE9NUjJ5MXNsODZhNXBmcXdmVEZid0lqbW1FZHRwZHhtL0xHTS9YTlRESE0zbVhaNGY4K2M0NXNZeDVHUEVhbFdsdVlqK3IrSldEOGRaUFYwSDc5MUxYVmkxL2svLzk5ZnBoZXpiN0RwQUdTQWRTdHVEQWNFNGJZQXBqZHZYc0pMRzdYb1lCN1F4amVKTEFPYnE3aDlhT2NDTEJjV0ZnRWl4cHYzbnJGd1VPOGVpNHhsTFgxU2d2bGJZYnF4RVRKSEFPcE9ERW9sa2k2OXc0ZXBVT0xpWHRnaVFFRi9MZnNmeEFkVVNRSE1lSmxXeG1nQ1Y5eHFjWkZvd1ppdmFVSUFkSmVZT2lSSmFTZjJFcUNQb0JMNnlyMFlXM0gweFI2RmZleVAvdWduak5WQSt2dS8vM3RBRmtuZkJRK0FSYlhJNUhkTmZBd2hPc1pQVE5vd2krZ1dCdjQ5eHRnZ2ZJUFJuZUJLcUhNZFhkMzBMWXMralBreFBHV0VnYXZObWgwRU5HbFA5ZFJKWDlZSmdJSEpTNVRUQUlpR3h6NFg2cEZDeTlDVFBtbTdUSENiQVBNdTZyR1RSUlZqckcyMUZkT0VxNjQ2QzU5ZzV4UktOWC93c293SFNQbThCcjdMbWtwb1Y5RUQzRUk3NUEzcFg0RDNyOGZiL0JVcmhhcWtGendvUDRmR3dtOEw5cEVvNTRKM3YrVTV0bW02YjBNREFBUWN5K2JoZ29rdFdKUzJNY0JDbkEvWFplNFR2SHlXK3VXWEJFWDRBeUNJWW5nT3FVY2dDOERpbkprenM2cUl1a0VVK1FhaTZWY1BYb2I5d2xRWFhvK2xXVHFvY0p5VHhNUzVHQURmSjZNeVdKeUk2am9UeGM0bDNPTlN1allBYm92T2RQVENQbmhSSHp1dmFMeGdVUUNUNTIyemg4bktjb2ZiY2QvZDczTWVQdlBkb05CYStraHgzTm5Fai8xaVNiSHk2Vi82dzNJc1YraTJUNzNCMStselZZdDBxWEhkL0UzVitPV2NzZTlkQ3d6WEFzUFVhZHlHNmZaaEVxUDR6MUhMcWtDakJtd2FZRE9HM0RuMmo1dmpMYXB2U0FFdVl0QTNycXpldUg0ZHd5b2hJUGdXZGJnbEUvVXlwcTZWbENhN2NNNDJxVXVXNTdhd1ZmQ2IyWHR0Z3pBYVZLMVZBcXpYTVhwM2t4cEdSOG4xeUd5S2RvWFVZcnJqYXRMdTFsRTNGem0wWjBhT0o1YkxPOXVyMDhoSUs3dlNrQm5nWkJOR1k2V1RaMHpXTnpVN2cwRjhKNjBBU011azFYa3k4enJ0NExEWlJncWJrZDZCTk5UUmcvYzVRNG9ieEx2WXhmN2xmLzR6K2dzZk1rd0h4NGZWNmRFM0M4UTRic1hDaEhzaFlueERkV3NMME54anRYSVh3N2daTUYwMWJFSk1LcGNyc2JGMVFnOUlaL2h1dVF1emFwMFNrMnFkWmdVVDBHbFhyNVZKZzFGeExJWFFCQjN6Z0JscFlGeWdQbG5hck16UnZvZFJYUDhoQWRzeDF5NWxNTFVNWUdCMFRMUUE1Q0YrYWVZOVh5VzY0TkdUeDRBbFNFWFpHNncwZ2pkTTNGQTE5cWw2K3JNSzIxOExRTjVDWVBrUlplNHhzRHBEUzROYWJiZDVSbDV3VmRBQTZ3UEd6ZzlUTHBObDNzM0tmUjVEbTZFZGV2QTdKcG9FYkdlajRVUUNBa3hoQWtuQnhWVkJ5N1ZQdXVqLzhMdEM0c2Faam12YUtrOUpKbGxHdWxVQzRrMjBNVHVIYTRIbU5zcnpvSm9YZktQK0pDOWtpY2wzQzBBRmNFbi9mdUlCL3VnbkpxOTRlRDRtK3ZnT0pVT25uZ3R6RG04TGRac0hnK2RhU3FYN2RyWWltTE9PUGhFZU1wVnFIVS95aStzWDUzS0ZhQkhuTEZTbXk0enU3d3hvUHF0UlBSckRUQkF1LzZnUjNpd2lseEZORzFBWm5rNjhTYi81NmlreGNyelQwQXNZamR0ajBLMkxBR0hISzQ3bjdyQisxb2RHK1Y0NkpBZDYwaGkrcTM2NTZFSkRoRmErMEJIOHlmWGlmcHZEV1ZVQTIvV2RCS2xQaVRNSGcwRkgyMkVCVGp6cjROcSs2RlRxWHJ6ZldjM3pBVjZxRjc2V01wdzVsZTVpQnVjZHhRYXRsaU5adThLWkp3ZmFCd0dINkF1QjJhTmxBS2NKRGpxR3NWMk51M2tkU2FTM1JlaE9kei9BTTVwWmNuVjFFU2ZIVnNUM0pwd3RkMWc1SkVFZUJObUQybEdEOGZZSVY0QnFxSDBmdys0V3dMTUw4RlN5K3ROcFFEVDFXeURrNXU5Kzh3MFMyUkxNaVgwSGQ0SVh6MTZ6K2xnaU4xTTcrOTR0QVJTb2tpM3RwTGR4U3luYUFMT2FDcWRVZ3kwRWphcWVNS0VqNGdFOVp4OGNBeFExMk1OR3IvYXgydzliWWJIeGF5UGU0ZXdYRUFud3pIRFpRQnhqNzZYUk5IaGxIUDh1M0JqVzV1TjZFM1VlNnV4Si9XMmQ1TG5DYm9NZjFZa3BZRmc5UGNGMDBONkdaSGZhbUw3KzNWVDYrUDEzc0orUlA1Mk5PYzdQMkNRQnc3d2JaeXpqSVgrSVZOSkMzNUVvSm5XenNOREpDdWNPSVVNN09wRWlPUWs4VUJmUHdlZ3d1eGxEM1dldjF2R3cvZ0FIM1F1VDRNRU9XRUV0dEJWWEVkcXVLaWRyUllaWHdLcU02dVNBN3lPWkNGWjBBWUNFeXVTRWc4UWpTQmlYSjcydEVIcUVTSmpHV1Mxc2IrK00rOXpuOFJqZ0svTnNCNXBHU1NNNERxaVJFWlI2bWx2TGpUV2FrRWkxNlNyVkthbHZNN21iVU04RWdydW9jWm9LSUxiZ0Fhb1hnb0haUndWRDB5c1pNNmx6ZEJ0bWhEck5EN3hIaDFudHBRYlNiMktuZEErQmtobElBVEpYcXQyRHNZeVBYdzlPd1FNREhVaVcwQzI2cTlaaG9VREhiOEVsNk5tRzgxOUlSc0Z2VmlmemkvWEp4blhCSndPVG5SWUdlenBHUHNvWWszbkwrejFDRzdOY1h4YmpKYWI0WHY3SFVkWFYwSGcvTTZGeWdJQ0E5TURnOFkzdk1xNDN2MVVSeXNsSXpqMWVpK3RVaUE1MmhOVEVRb3JpR2RWQ0RlVXlLV05KaVlpd0VGVTE0aklaTHBodEVYM1I1MnRJZjNKQ1J6Z1laM1MyTTVyR1BmY3dqRm1DSjJPQ2dseGxjRm9kUWErU2tjdlFjWTdUU2xmaDdDYllxWVl4YUhhZ0hhYmRTOUNKanVCdkdLU3BXNmlZM3M5OWhiNGR1enpiRnM3cnVlNWduVERZZVRVdzNrb2JvNGVDbUJ3cnIrWGpvcVB0UC85eHplSFdLVGNNdi96bTBlalRjOXFxZEVnaHFBUnN1a29NWDI5bmQ4eUMybm1NL1R0QTRyQmZiNzF6R3g4WnNuT3lPMDEzZHcrRTE0ejlpTzNpSWR4ekRCNXRxRVR1Y2JjSElkYVJ6cVRKOEJPSm14bTV6SGgyb1daMnMxcG1mT0VadTlMb3M2UmZrVG03cTFEUnkxUksrODhHeHU2OWJmcjBySVE2dUVteVBoeGF3L0RhekJJN3UxVWo4U0hFSVpuZy9rQlovcXRHZlZqYVpyWkdZamlscm5oOUFxSk5JUkZzd21TMTlXMHdXd1VMQTlyUWFzT1hhblM0RHpjRmVneFhBdjNxOVo2L2dYbGdDeENZSnhYTncrZHZ3amRyZzNDaStTbHkwQnZNakVSMGdtSFlPTCtGRGRSTmpOb0xLK3VrbHptQzBhZy83VGRsakpLRWVic0VNWDMrZXRsYXJRVGR1WmtzZ2l0ano4SUJSbTdqL2hpTnNNZkpFTnBNREV0UjdRcnBnRFlLV0lmOGRpWFI5TUp1WEV1M1FuY0NGRUhRMktDY2k2TW5wRE4rMUhCZkl6UU5RVE91eERhUzhLNjN0dyt2ZWxaQ2NkNnRCakRaem9MTlo1RVNtUUJZeDBSdFp0S2ozdWJyMzlWdkRINXlOK1ZLd0srWHlhaTlxek90TUxZYXhua3pkTU5raHgwM2R2MkdoSlIwdFMzcVVLc252NWxCbkxZN21keDZXQWlwd1ZYRnpYazdlanJ4UnlPMmNwWFlRbk4wTVZYcWN4VTcvREFHTFdTZGRUR3N0eCsxbHJoUktzV2tDOEZTV3ZZT2tKZWhBY2Mra3pyWFpDdC81RU5lY3ZLM1QrVXBnVWthenNDVi84cGJYdmU1NGxtZmMwR0pQeHdaWDdMS3FUa3FsMW5WV3FxN1h6Q3lzNmxsNThMeVE5N29VU0JjRnVOOEVZd0xzNGtmTW1CbWRwKzlRRmhHVlFBVTNEeVgxVHhFY0ZadDZvai9NclRrZ01ZWXF5UnFVei91QnR3WVJQaUxqMUh0d2d4cURHcU5neUU2KzE0bEV3VGZlR2VJMWxRZzVFTGVjeWp6VTYvSVgwUmo3Q3lCMXk3M0tOckJGLytMamkzYXFIUmxSK2NPcGc0OEcrM2hPZjltNlRLWCtYWlpjWThnNklkM1dVNmVRYXl6QTV5WGNndUp6alpvZjlLdUpmQUo2cDZUd2R3aTZWVDdCUVM3aHdxeXU3L0pJQklQaDlIWXpBNzZYMmtiVVV4MnEvTFlQUVlDcm9TWjkxRkRxRDVHWS9vWjZhRVNKcWlzT1dFNW5MUzI2RnVOU0Q0dEpGODdJV2JSNkFCTVVjeTIyQ3VRcnRwYmF0a2lmamwxWUVlcWhKQm5aMWNvRlJDbVkrL2MwcytwQjVwakxGRHZPakY2Ly9HUGZzeDFBMnc3OE9EK0dhRWZBQ0FyWTZhVU1YTC82ejg4UlFMUjFjS2w5eHJzbEl0c2RqQVRhVmdXVjViVEJ1MjVkZlZPNm1uSExnTllyMkhnMTE3bUZsK2xVaFA5VXBlKy9tcWFUU3FXVVhId3BrY2lsdzdReDRoTDdFNy8rci84ZVJvWXYwSzZtT1owNis0NzBCRzJMU1RqR3BpVk9RemdKWGhic01hZzdVTEZFWDJxeEdZYWFxVVBhZTBRMFBad2ZLUSs2YmtHeVN1b0JjWS9oZWFjUkkrWWRmVFJxcVJzSlhhM1YxUEswTGhlOEd4SkZabjdqU3ZNdmtRVnVDSWdQUkhrN1pncXRXNFRJZUJXWi9xMmRWQW5vd2NVRUhUSWJNYytWa05mdVQrZ0h2U2dYdEN4dWNxMFV5a0ptRWpRQ2RrVmNRZ1NtdkhEZHo3QlozelZrSytnUUdmRXFtZTlyZ3hJWnk2ZTZFR3ZvWDBGVnhNRHh6WGU2Mnl0aW15VVNSdDAwRXcwUVU5UEN5dUQzVlJCdzdjOExnYllSNENJREg5eEJOM3pyZ0o0UE8wNUQ1OHJQcDdMZUtGd1lUbVU5dFp6YndPVzJKT2I1THVpYVJjOG1RR3dxcTJ1ZEQ4WGtBdnhibThzQ3ZiYTI0ZUY1NElLNlN1anBQZEhERjZRQXVjQ2dXbE12RjB2ZEdZUmZVazZPNUFhV0ptQVNPMTRTcU04RVZzbWQxWmdCVU1FMUNEbmg5L2FDdlQ0dFh3UlZ3bE9FZHgzT2pqaFlRK25Ta3pPZnFlZUMyTElhSzdhSm1oNUZCMWxKOW81SGhsc2N6dUs3OS9wMUZsMTVPNFlNdnZIdHZta1lLT2s1bEdVNjN2QzQ5NytvRTdHUzNxemcrZTlFbFpJZDV4MEVDMUxrZHQ3VkRHc2txbVVQUlZpUFRxdWdMVXd2MElaQUR4QU5EZzBFTEdGV3p2WWVBQ2RQcGFkM1pldmhDaC82OWJWQ0ZaZElmUENLc3hSYnNOaHN3RjFzNUdNQTZTUnFVSVNjWGVjZW1iUndXSFVOT0lBK3pGdTM3cDlLWTFpeUs4RUNOMkg4QkN3YVdKeTZUS3hJRktkcVlvSCt3ZklMNDdLeUQzVGI5alVkWG1XK2lETklIV1ZjY2RRU3VyRmQ2c0o2V0tkRmNUck45OUoxMisvUzc2cng4UW9ycWVSNFJFeVV0eEkwMGhNYjE1TnBkR0JVWUtEUjlLVFI0L1owZ3EvcWRrbDdHcnV0VWorSllLMk41QUNFRXhodUFxWVhLTTNhYU14VUhjUERLVkwxMjZtUHp4OW1aNVBrYjhkQUdqbTJqeXVGS3NrSlRSWG1PbDN0SjhxZ1c2aUdwK2M3K01QTllSYUswMmlSZER2am9tcGptUERCc1pKczRKMklnSHZuRElFckYyQVpnc3BpU2NBWlNkR0NJeXhrUS9NaFhYa2VEUCtBb2srVVJRUTlIQndzTVVpd0ZrYXdWNTRqc1MwaHc5WXBFSUM3TXFBaUo3MHFxWTZoR29BZCtQU0haeHFOWUtya0o1SVc1UlZKaXNvdzQ1VTZlYTBxTXQ4ajlkWUNlcnFwQ3FQYWRkMTRoTkNiWjhxcmlsd2pwblUxcERVZDVDbTlSOWJ4SEhWWGEzbHVVTkEyQW12QXNtckRsV3dqVUQyVHZ5dWhvWjZ3Z2ROalNoQ3o1Z2s1QmZkTzZUejRpaG92dmp0MytLY2YrVWxqeEFhN0xmNDdqU1hEL3ZRZS96cng4UG5pdS9SMFp6ejNkN25wNm9kbzdzRlp1U1VFYTNVZDBocEFSNFdVbFFtN0RwMGFQN25OVjhrUStkLzJuQnFtUzNDalo5Qm8zZzZoUmtlMjFVMUV0VXE2bzVMeTFVTVdnbGpzMHljYlQ4U0VXb0RjNXkyaFNvUmlNN1g1T1FLaFFNams4dlYyb1pjc3M3U0UrL2xIY1pTR2FZalVVVk9LMllURzBzaGRCcjNYSFJHYmtjMEs5cFZkS3puQzBNaGVCZlBGbTJPVGxPdWd6QnRxd1pCVzF2MGk5MXRUL25KVWxyMnlLZkcrUmx1Q0JzWm5TN1FHV3ZuakI3dDRTRUp6MVVoaFJwWERIVkNOSzJ0TytRZTRKdGtaUDRlRE5MYzNKYmVlL2R1QVBmYzNDeDJvRVpzRFdUMlBJSWcyVDFIU1V2bnhRTlNzelJqL0c3dDBuQ2ZzSjlvVDJJVkRWdFRBek4vQjhuZEJ0Z3R1dHhTaWZmMVRCcS8xcytxWW10YW1wbENEVTZrd1FVMCtyR0xFWnF6akQvUzB0b0t6RVNLbXZVMWpMV29OaGpQYjE0bkcybWpNelFwWW5hWFdlRmN3OTlyanF3RysrblM2R2hzVExxOE1Jc0t5QUlCVE9zTzBuUFQwK25PN1hjQXEwdnBiLy82VituTmkxZll6Z2dOdW5rN2ZmUE55N1JNVE9FMjIyaXRMS3d6WWRISDBFTVZITnRLZU5FWlFPa21DeStuWnROZi92dGZwbi80L1pOWUhaMmRuYWJzdk5JMWo3K1pMZ091bmlyeGFGTnlRdXZDSS8rUC8vZ3pwQTdVUnFRc3dXSUorNUt4a2dnYmdEZ1RJaDlqSGQyZzFLM0x0blVzQmZpVTJxWFYyQ1lPd3JETXpNQkk1SmdlbElDZ09BQURpUnJwMG0yeUlnWVBZL1dsN25aVWJhUStnRS93Yk1lZG81VXhjM09PTFZNSU1jNDE4SUI1eFJZQUV4WkRDV2RpY3hGVWFWZkF0VlVxZGUxU0w3UlRKR01nU1dMbm10U202Z2V4eEFwcHpyY0ZiZmtjOXJjR2QvR2hadEpaTlVaMjIyYUcwb2hOcEQ2Q1ZUVUFYa2FxVWhwME14UHp6TGV4RTA2QXVuUkpXZHJQZkZlNEdQRE5vK0NsQWx6OFhSeCt0My84K0Qxc1hGd3V3S2w0dmlqajdmc0xWYko0M252OVhoeW9oRFgzbldsOHlJK045d1lyNHNjQ2l1L0ZnMVlObnFOUk5zTmYvSTV2bHNFNWlDV2tMYTRyTlFWUzg4NW1IUGxjclRsRWFqREptZUNsU3FpUnNvN08xVGx1WjhkQVREcVlwNHhoYzA0TDV6R21NVTVUT0VndktQRlJRb0xNZUpjZHcvWDhKbmsrSmpyYms3TW41T2NjT0R2TjgwcFFrWGp3Z3Zoc3AwY0JYdjVWTWxNYTh2dTNIY203UW1XbWJWNVg2bkZBTXZnb211ZnJvYXJTZi9adEFES0E2K0Z2SGcyZ05UdW0vd1FyNDhOY2RiTk1wVW5CV2VCdmErMUVuY0NwVW1NNk84R1lxMnB5aXBDVitTVVlwMFE4SVpILzE2NlFIbWFHWlc3MkVrUk5VU0l5dE9idXgrK2xybjVVRFZiMVdpREtEWXpRQnNicXdxYkV1NzZ6QVFPd1F0V08wZlY0QndsbEdoV1N2bWRscUJwcDdSaEp6SHp2MjZpYTV0emFBaFNyalBBbnIzZFhwN3V4ZEtkN2Q2OFF3a01HaW4xV0dGRXBSdGtTdlpLeTl6R2UxeExTY1VLNXpaVFgzZFZNUnMrdXRFbUlpcjVZaTZpY2IxN09ZUlRmUm5Mcmpkbi9CZTR0WmVMMEtuSGkzRUpTTXZzRHE5aXBHcWF1WTN4TW1iTVBJNXR4WWdESlRBbkM4UjhFV0s5ZnRSNEVrck1Zc0VOZndiYUFFbjBMaUxnbzBkUUswK0hYdGJ5MEVLcjJLcHZFSG9GVWpIQkkrNUtXazRnVG8yRXg3dm0zZ2JObjVGQjM0S1ExMUxRREpCWlh6STNyMDNEdnlxeGo2cVFmQm5KQVFKWGVuR0VJc3pqS1VvWjBCQTJaRVVMVmJ4UFFuMTlrZXpYSzFMVmdrVlhZRld5SEJxeFh3ZzhuMEpQbUVvM3JPOVJoQndPOVFjbkgwQVF0WXJLQ1R2bnd1QVFiQ3phUjJoaStsWXFOZ1l5TlVBVlQ3b25KRU51aGRaQldYWlgyY0VjbU04UFcxaEY2MDBGS252NTJ4aFZEUDRYWU16Q0lrZ0svTTJDRlBRbjZ0cHdDVVB5YitTbWZLL2dvWHNEL3ZGZVVrSStjdk4rKzduTUZ0dmpYMzM0OGl2UEJQeGVBNWJ1cU9ocEs5NTNsN1hCUHVFcm8zK0x3QmI3VXYwVWhicVlJM1FkRUtXMXhJZXhMTWZOOCt6SXF3M1BGa3FnMmhwSEw0K0Uvc3NVQTFESXc3bmNXS3hBQWs0YnVOdFRGZFRKUkFrbk1xaVMrNytsS24vL2crNkZXTGErdzJzSVZtWmcraS9xYXpVRi9tYkI1S2ZFd2d1RkFTcHNkM0FBR1VGVlIxazUzZ0cyYm42SnovR3Y3b3NPc096ZUZCT2xMT09JKy8vSnhWdllRZ0lvK0NtbVNsY0dDZ2tJUzVHNkJTNXRiQU5nL0dtU0doWEt6MUJpOWFMMHBOK2dEUS9BSk03SGxxOUxvU2QzUTJCd09nK0cvdzJ6czNuWXJxRXVyYk0zbHN2YkMzQXpHNXptY01WdlRIWXp6dWtqTWt1M3owdVVSQUtZaXZYNzVGT2JjUXhLUWVObmd3VVNBZU1nZjRpQkpUb1kwU0ZvV0pVWmtnTlFJNFRZU2huSGpMcnN5QTFZYTFQdkcrbFBQcGE0MGVnMlF3RWVxZzUyRTNZdnVtQjE0akZnNFJkMDY1MTY5b1FkN1dEVEErSTdYUVd3TUtrTzBzeURndGxDSVN6RnVYLy9oR1VDRzFJUWR4NVczS1J4S0p5YW5ndm1VQ3FRdE4xdlYyL3IybFRGVWxYcnNYRWlQZGhCOU1qWStudjc1bi8xWjJpVms2Y25YejFoVlpSc3FwRDhsREZNNzcwTmZUbVYycWhxYXRyNXRKc0pkY2xGdFliaDJ0ZTVIUC9waHZMc0JkYXgvWUpCd0YxY2VtU0FwM3pFMXY1aXF2UitsLzFnOWh6ZE9hZHNab0VUcHNiMlhOS0doWGhPR0Fldkc2dW1hVWsvK3NsYUEyaVFrMXFPM2Y0anR0TnBvNnd4WktkWmlJbTBqMzFrVkN4MXppK3NSWW13eVJ4ZWZXRWJCNks1c0JFaWJLSkg2SUZJRTcxU29hWEF0MHhjMEZrQUpRQUdtR3F4MUpkTmozeFZIWWNjVlQzY0RoeUlCS3NPSXZBWWNvWnJXSTJtYTlhTzNweldONDUvbmR2WkdMYmdYUUpUTGUrbU5lRlp1MHNidHUyT1ZFRHo0eHp3a3pkcFhuaSt3b3NBT3k2T2diM2xQNE13MC9wMFFVZkFVRlkvbkM3NzhiclVSUWNlVGNRTVZzc0RpOEtVZXZ0akQrMlRVYkoraFVmNExRT0k2OTF6Y0RqaGNNRC9FR1c0Uk5NSnk5V2w1OVhvQ0h4TnNIc3g0SlVUV1dwYStFYU40bnZtTjIvUnZjZm41RUg4akhma2FjQWhVT3RQRFY1YTJiTXRVZEZmS3NTc2w0RGlVdUtoRXJFcmFGTzVWK3RFd0NYVkVYY09HRkVDUUpVbzd6WkNkQUN1ZXRWd2xNaGttNWpMcnptRzU5b1lNYjBORE91TU8reWhmVTVMRGhzUHRFcnV6Z3JPd002Yi84bUJ6VDlRN3oxQnhEL1VUWkNVQ2R5YUozTitzWmtsUU8wZ2hsVWhKODZTWTJVR1ZNdU9rNFRiUDJLeWhFUitqWXhqSDk5ZVZaNWxOVVFGd1F6aUE0YWJ3ZUYvQ3FWSlA2WWZQSHFFR2t0Q1BySnJEZmIwd1V5M2U2MnM0b3JKeTFEY0FZMkIzb2JGdXdTN0JHME9vRTJjcjJSWnVmM1EzMWVQaFBrbjhYeFgyRlNlWkcrL2NDZCtpMy8zRDM2V0JUdEl1NzIya3ljV0ZOREtLbmFiMkxMMUFWVXZuNUVydkhpVFAxVUo2K1dTR2NzMjd0TVE3UzJsc2JCemJFSXlEcldTYzd4c0cydW9uQlczVU1LSHBxRXEzcFhPa3VDbzgycFd3VjlkbldTM0dIc1B5K2hHNTQ1MnQ1dDVNcFAvd2Yvd0ZnRnVaYm8reUt6U3FvaHVzVGovRnZvWUxoNXRQSEtDQ1FoR1VKNzNndGI2QmRFR3dkaE1aS3FxSUJlcnRIYVNvTDZFWGdCUGZzK2ZQTWNvanlXby8yMFhhT1hFeVpQSndmQVVDM1F5MFJ4cjJwTEhlREJMbnFsU01iZ21IVzBtakJobzA3WElkS3FGcG0zc0I2VmJHVUtmVE56T0xBTk5FUkFkMGR6UUdjRlFqOVJoNHpYQXp2a2gxckppYnlscjdLejZ4dkJ1YVl2S0p0REVnYjdEaXhkK3dmL0srMk14Vk91V2k0QWs1TWNuVnNGaEFkbFpVVG1uSjUwcmNFenRUYy8zWWxWa21MbDBZekg0eGdzMnFuZlE5OXBNM1YyaEFwZS9jOU1Tc0ovS2RHZ1NrTGZrSDBBZ3VCU2o1WFY1Nkd6T0s3LzROSUpLcC9JK3lQSXBuQzk3emIzRVV6L3FjOS92eHVyK3JPc3VsKzV3S3RvcEtXYU9MSXh2T2MwRStvTE9jeUY3dFFGcGgzaDJzekNPK0pMTm1sc1pDOHFFZkxVNVZ4OEJjVis3RWx4STZmQTJBVlVNb2hNR2NVVmZLTlpURWxUTDllNjVoSVAzMGUvZlMxMTkrU2VnT0sxYm1mSFZBUlRiS0NJTTVEYkVmSENRQnhuL2hOTW9KUFlaRHpSSklWTWQ0eHBVMVFhTTRyTE9BRldLeU5ncCsyemt1YjN1ZjV4M3dhTE1TR3ZYUGl3Z1g4NDYvZllheWJhZHFvQ0FwTUliOWpnNnkzMElLdlNqYmQwZmZjUjdTNEIyQ0wwMkxHVkc1UUVMZ0hoajcwSm1jNnJyWFhBM3VCM1V3QmxESVNoc2JXbUp2cUszSHA0M1FDVDNJMXpDcTdsTEdFWlU1SnJkU003YVNiaVNIUnV4SDduVHo4VWYzc09OMEFQNEg2Yzc3OTlJUU1Yd3pxa2Y0Nmd3T1hVcmpaUHprcFNUMG00ZEo2ckZ2RFFjVGJlS3VZQkIxTytEVlB6aEFWZ1ZDWEtodkc2ck5HbEplUTJOSGV2K0hQNlh4VGV4M044L21xZ2Nrd1NOTFEyVmIraWQvL20rUW1vZkp1OFdxRk9Pa1IvVUdYdkZ0WGFOSU1JNGo1bVVNOWJYYWxZaFZORk5xTTB2NTljejY1dDZxclNlVkMrRGxubmNDL0E1K1E2cEhoZ2U1WXFxS2FEWlFQZVJyVlBjWlMzbE9DZE13Sm1udUVIdWVPODVBREVnYjNFT2Zyek1KZlBYVmd6UTVNUmNUd1ljRUtsZGplTjVoNVhLSWhRWDdYYnVYWVRBdWZLalNoVkhiRVFORTlTWXZVZllaZldjbUJVRVpTZ2svdHc3cXJ5L2RKVExJZnZIcDkzSDIzV2JpZUlZTkVPZFZBTkdNRC9Xb3ZZTGpObTNZcFQrTUw5UUk0Z29lMVlOT29TSGlIcXNBTkgzRmREdlFydWI0U1A5U1RtaEMwS29jQWFYRzRsT09McUdPUVZ2YXJyZ2VhaTV0UUpwV09qekhCaXZOTmJLcVdZMjlVMVZ3a0IyVHFtdWxMSjY1b0ZtcUVYMW1oWnhRcFc5cE10TzM0QkYzQkswS252SkJRZGVPbFlmOEpPTTVpVWM2R241SzJ4NzVHZm5tTzQzSDU0UEg0bjJXNTd2elJDOGZ4ZmYyaHRyNzhTT1g4KzMvZmRET0t3N0ZNaXNpTThwVVRBTHgyMEw4aUY1V3huUVVVVTEvOEovM1daQ2l1VEYvaDl4WHhXeXF3MTJWVGpGUk9UTXFza3FDdytRKzB0VUpkZ2gzSmhsQ3ZaaWJuTWN2Q0RFY0E2eE9aZEVnRytKTVExMW80b1Z4bjdweFRvSVV3MTNSQ1dkUzNxZC9GcFhNZFlmUUxNUEJkTG0yNkFpTjZkNGpNZGdRQWN0N2JLOHphMjRPakNNUjhGeElScnlIVm5PZmRpcjZpM2RtdnpEK2NsK0FsY3pDSWZpckl2cGNyRUR5Mno1VlZEWkV4ekt5U3ExVW9QZTB4T2tLS1dFaUdFYjd5S3ZkeTZZQ1NsZE5MVlVZemNsbGZobUhTN3k1RFlodUo2V0tQam1mZmZZajdoc0tRL0wzUC9zODFHNDNaOVZGUXA4a1oyc29sV2s0TDZFYmc2Z1V1cnEwRXFwS08wNmNOVGhrenJNdjN3NUozWWN2alNFTmwxbDFPMk9ISDFRWjZ2ekJKOTlQejc5NVF2emhJZThhSUNYeTAvVGt4U3Y2RytmVDRURnNQeGlJVDBsT09IcWJMYnhXMlhtSFhZMDd1dEl5cmdhMzduMHZmZlRwVHlOMXI4NlZ6WUNwTzg1ODhvUFB5SUo2bFhhN3lVVVpiL2tPUHUycHRadjJ0YldIRGNlZHB6c0pFZkpjQytxdk5zaDFRRVp2ZmdPT05haVhjVlkxTzJrYmdKMTNiQ1psRC81RW5md09hWUUrMmdNNDlRd1hERnBaWGZ6ZzNyc3NkRlNoV3MrR2o1cytjOUo2R1NCVVVzYm9ocm9KNCtuSWlwcmFTWlpPaytGSjlpNkVkT01qcGRvck9YOTQ5eTdPdUV0cG1jeXE1enpYeUdLQjBpazdrNkhtUVZOSVRhWXhycU1mQlMyV1FRQk4wdTZnNWxjVHBpUDl1UW1ydm9qMUpDR1VQelNVaDNvYWZPUUVud0ZjQnNzbUhKa2FjR2ZSeG93S0FVNEF0WEdJZ3BpT3VPalV0SU9KRDNBMUJyV2tkTVVpMkJCeG4wcWRUaHcyU1BOSitBd3l5V2VCUmVxbG9XbzIwQSt2RExvdStGNk54NzZTWHdTbUFrc3lKdkJLNk5wcndWZnlRV1l2WHZVZHdQa0crY1hEUGkwTzc3RThqK0lkRmVOdGplUldrNmtzS2Y3NzdpWmVaZ2xLQ3o0WGhtRHVyS1hqYll4UjRPWVdja1hPL2N0eUkzeTVqY2NmQjBhQTE1d1lYUHBLaDBoVFdEdklQR21NRW1JeGtoWWJ6RkUybllNS2VjUm1DRXNZZms4ME1ET0FiT3lVNm1rSUNUZ2dTblZqeThXN21QcFU4Z3g0SDhDbFE2YjJoek02MUZYQ0l6cnhnTTgyOVR1eTBSQ0hmT3BlZFI3UkZ1cVZrNGdKUUJrQVE2TGlmZjYxayswa1Axd05TVkJRRXF5Y3BWemFqOTZsL0ZnVW9LN095bS9QQ25xSXg4REZTN1c3T2FnUWhVekFvUlJnSlBvZXpxRWF3N1VObWpwRjFkRE5EWFJDUEQzZlNZMXMwMzRWUjc3cm80Mm9WYzBrM092Rkp3Z0FRVUs2T25xVjdBYm5yUEwwc0VIbXExQXhxa2pldDRKOVI3VjdGMFA3ODBlUHNDMjFzYlhZQ01aNmR2MTlOcGxHeDBkSkNkT1B2NUpwWFFocndZSmxhcHQyUE5LbkpwY2pMOU9sNFVHdUpiemZWMklWN3AxM0w2ZFBQdjBnOWdiOGovL1hmeUJSWHBuNkRMS2wvR0lhdk5TVFJzYUdXZUhiSk12bU05cFFqUzhYY1lYNFUzMzQ2YWNBRHVtZFp5WklxOXlIaTBScitvcnR3QnB3UjJpRjBUYzIyUyt4ZjRBNlZPRGFNRWM4WXp1RzZaWDAzdnQzVVhXNzBxLy81aitGM2M2dHFDcVJoRW9ZM1N2UFN3RE1DaTRURDJXbjJFeGhmNDhGRzhiNWpIMFNKNlp3dWtYU3JDWGpoYy9VVktQQ1FqTXVOTGhEVVIwRyswNXNTanRJVzdzQWM0TnBpcEdXUHYvSlQ1aElxOU4vL0p0ZllQOVRDc0VlT0RNZE50VWU2SFljQTc5YnlVOHNiS2JGTGZZekpPMVBGN2JXRmlUQ1pkUnAzUlRjTUxhZklQQmU3R09IZkIrN2ZpMDluWnRMRDlpREVKeU1uYW5iY1B3TmVJS1d0QzN0TUVsanppZDBLcTkwMHd3bU1CeERJVnh6V3lIa0lpUUNlTFJXbWdTeWdoWXJvQnZQQ2s2dVByWUFjdFdZRjg0SlZUckNydWUxYXBEVThCeE5MdWJmMTI1WmoyUTZNTlFYZGtlbFJDR0ErVDRBUmhVNFZFbmZoYlJYMEsyZ0l2MW5qWUg3cVJOVE4yOG93SVlXVVRjbmJubkRlc3BzYWxoODRaT1BPTTl2ZVVGQUNwQ1RUL2tld2dEZjg0U2Z0U0pYTlgwKzhHV3N0ZUVDc0M1UVRFUVh3V0VxbmVpOEtWUWxYaTVJQ1ZvbE9wTGlvd295bFladXR3Z3JSTWNUWnBaejNCWUV1aXJQSzZkVDFpRUd5VU1xV2M4TTJ0UkVXaExVSEZkSnpOMmt4SHRBRHFoTnZMZFAyZVhsRkZXRVVOalVURnNyeURGZVVZRXpJUTZQekdrd05nRWFyUCthSmlNZ1NDSlZqYU9qSzN5SG9BVTQ3Z0c0dTh4T21qNzBha2JvanZ1MFZkbXVBQ3phRlNsdEdJZ0NzTHptVVVoSi92V2NBeWRZT2xMT2VCNEJhTndlc3g3bnZTL3VwVHpqMWh4Y0pTa1BuNUJJbGFBRVAwcU1Yc1JzeStwYzdtY3pVQXBZYm1xZ1BlL1ljQWs4MGU5ZEdVeTNyN2FsR3pjNlVpLytVNnNBdzhTcmlkU043YW9adFd3YVc5UDgvQ3dyVVozMGIydWttM0dEMGlVQW9BVVY2d3dKcVUwN0JmVlozOHlwVXFxeFRibXB3Zm82bXpsMDQ5OEY0MjJSV083RjgzV2tKZjIzekZORi8vT3Z6SGNYVUl4clZFV3FJYkM1aENSU3hoN1YwQUk5VUpiZTBUczdiQitHNnZIT0RYWmxKdlNucXI0MVhidHpKMzN6K0p2MDhPRUQvSHdhVXkrcTZkVXIxOVB3clkvUzdPUmtiRnJ4OVRjUEtMODZmZnp4SjdGaVBEczdpWEY5QkFmSDgvU3JYMzJKcjFJTFVoVVpHSGordzQ4K0lUeG5MMzM1bXovUXZ6QjBNQ2JiV2lGSmJlaHpSQ3FiSjA5bUNmazZ3RlkyQ0MwZmtGR0NEVjRKTlZJdGJZQlp0UWVlMC9aRzdFc01HeE11UWMyQXhnanY3RUdLZS9MOGVSaS9iOTI2US9uNzZlWGpSK2ttQWRzVnJBQ2FIYlNpc1ROOStYZ2k3WitiRERCdkdKRXpXckFRQWdDTTRXclNCWTFQdjNxRnNiMGhIVU9YOHl2NHhlSFBkc0xPcnhVWUdmUGtwMjhkK3lOeWZRTVZjNDFWeFZOb1EybTdHaW5McWMyNmdSdE96OUNzbkFjdEFWU0NsZlJVQ1gxMnNwRFMzVW9XVVJDeEZvQSt4ZTZwUDkzUXBWNUNsZG9qb3NISlVkZVVQZXg3cG9kdUFtUXRMVFpvZ1o2ZE5Bdi9SbW5Va1hleFNsT0h2cERTdFR4U0FBczNBRkE4SXpCeEJIOXdyOERuSWQ5NHZBMUMvdlorTlFwNXhySThDaDd4MnR2M1ovN0tJWEF1eklXRTVXcGU4YkppSlV4MWlSWlRTYnFFNndWWStWZlBXZjhXbFZkVk03Z3pkR2NlczJOT0Vhc015YW5WbUd4SGNQNlVHWisxSG54L1RKVnJIaVYwYUZZbWtGbVJyS2FpczNiWlFCTDdLY1MwandQaVVScGdOV3A3MFIxL0tZOGxsOU96SFlBSFB5VjAvSENVbzM0QjhOWVZNTFNMREJ6ZEI4eE1zM3RrWjBNTTlFS3NBS21qQjVCeTNrNXpoU2RXUkJpWWI5VmUybXRuKzdGZjdGUS9rWDZXUWRNQjBQS0ViRUhKZ0dDK1FsUjhSOW9NMEhJVU9PZnpvY3RmREl6WFl5QzVwb3JDelVGOGtBdjN1eTRrQ1hHZVB0YmVkMERPYmNObXJzTUFROTBDL0ZacTYwSDlxR1BWamZUUzIwZ24ybE9XSTN2QmJ2b2VlYTRtSm1iVHhHdkFDNUdmVFVZSS8wQmloUFNyQUVVZEU5czdlbkZ4MkVWNnloS2tIdGlEZzZSQjZXUmpWMWFzbHRpTHNHemVMZFR5UGQ3dkpxVjdxT3ZISjl1a0lXbFBsNGI3NDMybXEzR25hTDNtNTFiY2Y3RE10VjVVc2xKNit1QTVQbEpzQkdGSUNpRDRpcTJtK3ZwS2JKeEthQWpTWVUxMU0xdVRJVW5GdS90aFJMYVRHaGltSHBmU215bXpkN2dweFZxYW5wa2pmZk9IcU1JdGVNci9Ib21yUkpqU0hhVEFwZlQ3MzMyRmhHQ09wMU1TQkxha1AvbnBqOUpETm1WOTh2ZzE5M2ZRanpWSWdLTzBjeTg5ZmZJc3ZXRzNhVUdndGEyRC9xaEpNNi9ua0FoM1VBOHhVR3Z3UjlJTWZ5a21qUWJjUURRK3V5TFppOG8zOGZ4cDZzUWovUVR3MHMza2tGenpFOWpxZHBnNEk4U0tDZFBvREgyVlpPNTIxRmpwWW1PRnREdlFrY2tBNjVIcWV0anYwWW5UeEl5Nk5oakVyNWY4LzhmVmUzM1plUjBIdnJ2RE9kMm5jMjQwME9odVpEQUJCQmhFaWtwalViWXNqOGV5eDU0MTZ6NTQrZW5lZjBQdjgzRGY3N3B2MTJ2TmVNYjJTSm9sV1JaRktqQ0JKQWdTSkhMcUJqb0FuWE5POS9lcjNSOUl6d2MyenpsZjJOL2V0YXRxVjlXdXNJc1FJTVBhMGxUQ0lxN2pxOCtKWTdwWXhBS0pjS0NLcUNkOXZBZjhOakxFVkRxZHVBdzE4Ym5KYnFqeG1DMm95QmFHSFdLdUFqOFBGdFVkRmgzUkxwdGpKRDNzZEtpaVNsSjdYT04xOFU3ZkhiUVBiVXNmNHJTTXhEOFBQK1VMU21MeUFROXB4UHRpNDgxVytPMWZ3WUM4Rm1QaW5KL21jL2NkMG9oSGZtZCtUNzZPc0VIL0NtWm1PN3dMZ21SRnQrSGlwdWhjZE54RzVJWjBDb0oyVzdud3hUQzJManBIaC8yVUM4c3hQZmFaS1ArcE13c004K3Vzd2ZrMStobG41Y2FnSkdTTk54T21YWHh1SUwzM3U0YytrWllCOVBBU09hQllKVjUrNlRreVpEYW1qOTZtbWpDaTl3RW9lWS9jR2E1TGY0QUdFaEo5RTRCeWJPNnlQMzRKWXpuRXJnMGdjdmJBREFwbUZZd2srcHFaa3M4VUFPZDBqTmsyUGJ4V01CNmxTU1ZRK0NPdCtmcDhMVjRZZkN3L0l5STRrZDRUZGovZ0l4eXQ5dUlTWkYvREJjTDNzbmFxbHNuMzNJU2d0L1RaTWt1UUhLSyt5dTgwbVFxMlllYjFsZFUwaGhIN3lTVFh0OWlTN2tPU0pmekRuYXRqUTYzVW9CdEdBaUFITzBRd09icVdUbHdjU0FQNFJpMHVqU0ZaVGNXY2JNRjhkTWpVU3FZckFyU1oxbUY4NDh1enFBK1U4dXBnTWFoRHNvUEFHZ2g0ZG1VcmswVFFsTDBYWHoySldvRnYwREY5bnJBM3RSNUMzWWRwY08vcTVoSTJJWXBGb0ZhS0s1M2RNQjJrT2RXdU05ei9WejkrazFTN01JcUgxMG0zY2cwdjllc0J4SWw3OXpEKzlxWnJIMTJMZk9KMXJQNW56aDRuc1IrNTJqdjYwa0F2YWljN2Q0Y1BEWUJIUyttOVAxekNadFZHNWVnWFlVNWZhbTJBZ0V2cDdkOStrQjQrR0dZTWRSamgzU1FpSnU3b1lWUSs3RnkzdjBpSGg3clNHVFlYenIxd2tmeGM3R0lldWsrQmlPdXhVWEg4MUNrbktxMGh1VTRncVpvZ3NacUZibTF0bmhKcEUya05BL25TVEVMVmF3TWZhdExERVV3WDdEWmFqcDVsbWF5aFNORXMwcnM3MkhxeGQrMVF4R0VCZy9zS0VxSUxhNVhxS2ZDdWdQK2Q1RlFmMlVZOTVIM3VtaXJGckdMb056VlNYUVUvS0tUVk5TUnJNNGxHbmpUeFRQcURjZkJ5SkpSczh4VDNsTmc2MEZqYzVkMWtYdGR3Nm5YWHVLZm5FQXRBTDNDaERlaFFyUUswQTcrQWxjd0NKcTFHSXAyNjZJcWJtUitDajhBdU14SGZKVVdKNTVscFNTTUZnN0tkNHBCR2JDT2tKKzdKdTk5WjJ5aWUvVHFOMmZlWWZCZG83dmRaaitLZStNSC9mTFo0bitlQUpZMUsxSWlBUHFSNkpQRUpGSFArMktocVVJNVB5cS93dnFKek5rSVRCeStFbThZUEprZXV5MkFiV2FWZmV2SDVNSUovZXVOV1dtQlZqM3ppdG8rdFlaNVZwdldsZ2ZTM2YvTW1Fc3dlL2tTNzZlLy8vaTBNbDRzUjM2WmtvUGU3VzdYSVF6QThBSSs0cHBwaWVJWGpWSEt3UHc3T0xYQXVoUlNvd21oZEZnMms4QWRIbXp2TCtCeTNCbDUzRG9PNTBMNkFFK0IrT21FQ1NyaDRyMGVvY3J6RDkvam52UjVlRHpiRlozRnZaSm1nRFE5ZmJRdXFoNHJjUG11TVdBcmRBQUJBQUVsRVFWUy9kVDRVeHRGM1dpaUJrQ0tCTmtGZnFXMnNCRUZVc1pMS05Iei9Nc0hBZGFRUzNpVkozd1krT290czEzZjFsdE1Kdk5hNzhFNWZKSjZ2UXVCeG9oTE9DTG16UHNlMXdBckMyekFUeDdxS3VqVHkrREhqZzg4d042WUpya0FnNnl0S0JoaHFDYk1STHZ1RWlTeXo2b3NIVVlvS2ovYmpKekRJbzk2dnJFenppZjhReFNUcThNVEdMSkxHWjUvUUZvVXRwb0VOVTlEZTNvT3gvQ2hNRmRzS2h1MWIxKzZsenovNklsMTg4VGlxUzI5NjR5THhkU3RmWUo5aG5DeEFrM2NmMEQ4Y0psbnBaOGJ4OUo2Y1lDT0JHRURpRVAvbHArOXgzMzU2NXZ3SmRqNnAwQVBsTlNNOVZqQU5yR0hJWDJJWHJhMitFNGZaZVJoWksrbUpYMDBQUmtZb2lUYWFmalhQRGlXN2lmV0VEdFVaNkEwejZTQVkrTzZOYTZqQ0dObDd5VEJLT05GMzNxUzBHQWJycXg5L2t0cUFwN1BXemtaQlEyTXJZVWlqYVh4a09JM2hVckxMNEt3RzNZcDZ2WUFsdlJFY1djV21WUVh6VXMzTTlsVWNQdDA4QW8rcWtUYkZDYjNoalVjY3hlNDJ6WTd1TktYSnRyRTFnb200WitqZERpNXpqK2xxc0lsQWdpeFcvQllYZVZyS0RXSEJ4VmZKeGhYVFFHY1RENWFaTC9ITGNuRkdkRFR5VHQxa1FQejRpMFVWV3g2WXpUK2JVcmpnKzhHZk8zODJ3RThKbWY5NXlKajBCc2dMY25HdlY4VFhqT2ZpdTJkOE5yZm4rZUFWQjgvNTIvczkvRjdRam5idUloYnlxL1p5Mjk0ai9kbW1lRi9RV3B6WGNSUklCREVJbUpKc2xodXpPSGpRRVY2b3JpcFZlbDdwd3NZOGdoSDQ2VE1CdHR6eFlId1F0SjVVbmF3QUwxMTRNWUl1RnpDS3FEcnR3ZlhyUUFhVHBhM1BQVXh2ZnU5Y2V2YTV3ZGpwV21LWGFlemhHQ29oS3hxQnRnL3VqTEhTNUFGb3ZIVlZRMWFLdmdqODRNQzgzODhBRHQrZG5JaGs1N3RDall4Q3NNVUtBRkhJV0FQV1h1ZWFLckRQeWhRVVFiOE94R0tzQllQeW1zRHp2SkpsNFpyZ3JIdWVoK084MkNIQkJ6eTVKZ3hGTnAxQmZUWmd5azMyVFdqYXA3QVZnSFNHaklqd3RVcWw1STFxSWZaUGcrb1d4SEh1aFNGc1JLZFFLeFlqeE9ZdmZ2ejk5RGYveDErUTFJNUNFdVo0QityckcxVklKZVRwbmwxamwyb3g3QmExRU93YXpMNXY0RGcyRE93WC9LYWpFTFRNQ2pzQ1VsU3BqRHNCZHAzcWFsUngwdjdNa2pUUFZiWVJsd29adTVsR0QzVnJyQ2U1SDlrWGFobzZpTFdqOE9yd1krSU1ZUjZMTUVXcXJtemlGYy9vWVNBRUJUTzRtMThPcDF2WGNYdVlwRkFFY1lVNytCL3RjMDg5RjNIRVQ3WFlkS3pJYk14aU14a0RHc2lWVmsxT0psQVh4MGMyVDVBZzNXU1lubndjTzVwM2I5eEpYMzcyWmV6SWpUOGthTm9LTkxnSWFCdWFlanlaUG56dmNocDdOSUYwcW1KSVVqMVVOT3NHenBNSll2VEJjSG80UEl3azJSbzFITGUzQ1dQQ1RhVENlNjlmL3h5WWpTTmQ3WlBTNTF3YVBINE1GWFU0RE5adCtGVzkrT0o1K2tkSk5QcHBXSTRSRiswWTR4MnJPZTM5YlVJL1Z0T3dwNXJvZ09uRnJpVGpZZ0dWSWJPcHRNWUZrMDBUT2NrZnBpZm0ydXdMZ2FmQTI3aGIwOXVFL1Nwb1R4TkJGaVJBRTNDSWhIemdxY3hwQjd1Y20wNTFTRXorVnFNeEkwVTlFbW9MUlUyY0FGVkJsbjZrTENBS3pZaG5NaW9aZ3pZc0UydTZlQVpUNFFXOEt1TXlNK0Q3UEFyODkzdlFoMVRJODRIelh6dW5GdVpEQmRNSjNoQnRTbXVaMmZtZTRnaGE0SVhTbnM4VVRLNDRYOXpuczRUbTFQNmtPQ0UzRFdiRUpOdWNSR1M3MWF4b3dkMGd4akFXTzVxRERpbnJaQU95MHBXY3NSZ2c1N212QmFCWEFaeGJ0Mi9oT0ljVElrUlNZa2ZHR0xWTjJpMXJXRjZiSmY4T3VjbjcrOUl2MzM0M2ZYejVOc2k1a283ajBGYkhLalA2WUFyYkFoSWJmYWxoVzFZZkZjdUR4Wmp0aDB5Q2R6bWdBampodE1uZzNUbVU4RlhqMEh4WnRZeHpCS0U0ZHJBWitGeXNPTFF0MHhKWUJUQ2RJTDg3OWhnL3p4WGZpL091YmNMS3cvZDcrRHZPQ1VBblhpYlAxL0Rwb2o5bUhvMTcrQjg5RHB1QzRqcmZvdi9pcHg3c3F1RTEyUEtPZEdHTWZ2a00zdE9sTklkRWV2SDhZSHJ4M0FtWUE5OWZJbWRXRDVWMlpvYkphM1dOVkNKNG1rTUIxdmpEYjVCeHAvU1hKTU1iT2tVUmlGbXlmMktZL2M5LzkzZnA5VGUvaTl0QkgzR0NUd2oxZVl4azVVNHFPMWFvOE5iT2MrdC9uZVJ1VzlpOG1wb0psTzV2WldlM1RMSkFHQVlHN1BubDdUUncvRm5DZUZyVEZPcGFGWVVkVHAzaWR6V3VBS2cvaHY0Z0lxS0tMZ1NNVFRwNDRkenB3Sy83Mk5mcVVGdGFjZEhRaDhtUUdCblRLZ0crNXZ6cTdXZlhqWENoV215YytwTVpUeWx4YVF6ZlJGVnFncGdQVWRSQ2ovTVNDR3RXangxY0h2U2pXaVR1OGNHOWgrSHFvTy9VQm94c2ljSVZqM0hjdkgvM0lSc1ZFK0VKYjFCeENWUEM3TlFra3RrQ1BtV1Q2YzdOVzBpaXBINkJHVUd5TU0xR05qSW1TU0U5QVVOQXNvTDVIajU4aERFdFVUdHhLUXpsL1FOSDAzLzhqeitHU1NCcDRZM3ZibmxMQy9tbmNCaWxXNmpONjRGelRXUktjQUZkUjlyZDRZSlZ1eU1KSC9pd0c1SzFpNTl1Q0JJc3ZtUzRReGk3dU1va1dwWXM0dm5FUXhpTDVnUSthQmM4QVg4Um51Z3pZVnRJaUc1NENHdWw1d2I2b0ZyUFRSanl3UzN1WTFJQzMwTnI0cjBGWFFmZFFCK3hrTnNCRGhtc2gweWsrUFIrN3czR1F0OEJVL3oyblBUaWRTV3pjTUNtbllLR3ZPNDFtNVoyd3ZtYWNYak9Qdy9wUjRtcU9JcjNmdjE2cUlTNUlWL08yL2xRT2xJMUNkSE94c01ZQjZCWWh2WERvYmVJdjRxY05CMDk0Sk5IUTl3eWpwQi9aa3l3Tk5JNktzYzhTOHc2cVdkM1ZOMXdUV2hsSzNzRDNYcU5jK3NXVENBNTFwMWhpaU8wUDBudnZIczczYmczamFHNVJESzQ4Mmx4SEpVR1I4RnQxQVYxamJDVHNUTWpOdWdZYUVyWEFtZ09XTmJndGpUcyt1QTZnUEk4UURGd1ZrbENIN0N5L1JaWVRnb1RwODBJaUJXd3lsSWJ2NHBWSlFQNXErdU9XNEpRL3pjbVMxaG9xL0k5MFNZbjlQVVIwZHkyZGtxTUI0djdlQzRtblFsM05WS2FjZ3k2U29RWXprM0JmRkdEd1BBMFFLemR0MTUvTnYzbVorK0gxUGw0K0M0SjRCNmxJeVJaZStIc29mUm81aEdHN2Nka1BpQUpYdnVoOUhqMEZrUkkySXd6UWZ2N1NHZ05TQStubmo4RGcxcE9sNjkrbWw1OCtVVXlFYXlrc3krY1JOTERWUVQ0dGpZMEEydUtWVXlOUTJpTWhScDVla09Ya1hTNlNZcDM1c3dnS3VjbmFmUXgyUnRnS0lOSUlTVUNxbXViOXRJYkYxNGxQVWxYK3FmLytqL1pxVnVFd1JFZmlEUmhlNDNFRkY1NCtSazh2L3V4VmI2THB6djR3VnkyWXlnM2Ivck1CQnNwU0N1V2pUZFArOVllMWE0aHZtOWNlQTJHWGtuLy9NOXZRK1FrTkR4M0ZnSjgzbEhCZU54VVlPT21STDFDcElvYTRnK25KaVpoaUFjd0Z1RE03ZHJxZGxxQVlabE9wUlpqbDQ2MXc3Y24wOVRvUE04Z1pWQjh0aDRHM1lubmZuTnJKKzJaaVpNQ3AreUNQaDdGWUE0RGFXN0RtNTU1RUhtdXJWMlBiQWZyNEplN2cvcjYzYjVIZUJBRzVBcGhTTHV6MndSTnM4TU5VMjFpcDNkMUNSaUJieTBzQ0Vxb2E2VFBNYk11R01xQnhFTi9hRG53WVJjbXBqUXJibGkwUW51cDE4V25JRTN3SmI2cjZZRWF3VWFZWHhtK0cxN0w1UGszeUx3QkoxenRXTktLakNIeXNQbEN2dHVPNlpjQVAyTUg1MEc4ckNGd2pYWUR3N2xKZlBjb0ZtYWxIdzNnZFFnWUJRTlJVREJ2bmYrOFR3YmpZbXpqUldZSHp4VUx1Wi8rNVVRRTBYcU0xWE11U0k3YmQvaE1ZWTRwbnJIOWVFZGZhOU5QQ2s0V2pVRXNYbUE4VHpzcjBMS3hHaXlJUVNzWElNYkROR1J1aFlTakxTeU1hVUtGOGFxRG0zVkJmeVJ1ak9xL1p2bHZaR3U2ODFCN3VCd1lZRnFIcFhjWDRyeE1YTmdkZHBPMlNJbGJpd1IxY25BQW04MUNHaHVaQkxoSUc3eFBVVGlXQ3NTbENQMFJYQXdZU01TQWl4WENzWVRqS1AwMExrem02VW9XbVVBQmp2ZEZrSEhBVFFZQjhoejB1NENIbHp3bjhKd2tKeTFnd3psL3k2QUV0RHhQaUNscktXRVd6M212endhZytTNU1iRThtRll5S1c4MUZ0R2RiZkZjZGlHSWN2aGM0TzZZeTIraXZYaHhNYjd4Qm1wYlA3cVI5MUxjeko3cEIvbm5zTyt6NGRiV2x2cU45TUdkeVU2SDJ6S051M2I4emdlUkNvRG5iK2xWVWdxNnRYb0s0MXZDWHdndWRvT05idDBiU3BROHVzZE0yd251d243QmpOVSt5dmdyQjFmdk1sWG12akRtcmtKZHFEMm5Kd0ZxTFl5eVFSMmtGZDVPd0JXSVA3TUNZMzRTYXRBZEQwcWZuczgrdXBBOStUOWhPMzJHWTIzbWVxME1GbklycU0yYStIQjk3bEw3NDhtN01WMDlQSTZxZVZZZE5lNkt5Z2pxdmRLR2tRdGFKS1N6Y0ZTUzZVWFkvNTVHU0dxMitBL3k2Y0JxZFErMzk3Tk9ya1NWemczRjkrOXV2cEdPNEhIeHhWYmVKOW5RR2RYbUczVGxEakxvSk9BNVREbjVoRFhYc1NFUG1Wa1BlSUgyT0d5Qk5xTDlsRmtkckhhNlN2WFgyOFZ6QWNBYzRMMUlTekxqTkp6alJQbVJIY1FPajlqS3dXc0YyT0V1LzdhOHEyOGpJTUVSS0lMTWU3TXpiRWp1cnFuT3Q3SVJ2dzlRMGU4ZzhYSmlVNWswWjNZUmZWSDNZWGwya0lHcTRoWE9lR1lDaFJaZ3d3QlZ4WGdSVDhnejg1SjR5RExBQjVsc1BySlF3YVNibVRIemtFbmlhODM3MTRuaGREeFBWQlVJTlF5U1JKdVZLL3ZTZFFWTXU4TFNqWVo0dmdkdlNRTFoxaVlaNUlmYWN1Q3p1K3huMlZ0L3RiOGFmNmVjcjN1RnZtYUxYQ3liSDdRZlA1MDkreHJpRFBMaFBldkhQUS9PRHp6MmxJUm1ad2FkQlVQeUkxQ2xnaFE5TFBLNVdTakZ5WTRsYmFTTnNQQTRRd0FGQ1hxWWZrODlBc0JKZEdMaVZhQnlZRXdvZ0pHVzV0eEtERTRGWWJCUjlCYVNmWmdXZVIycWJ1bzJUSVJXQTl6ZFJCVUFDSTk3LzlaZS9UM3RNdU5Sc2tLMTJyNnBkdHB0OUorK1NVVG1nWUZpT1VHWWc0MkNyMktScFRzb0dreElTRm4xUTRsRC8wcG9GK29DN1RCRHZVbFZ6MFBTT0NjZFd3S29STUdDOEJhQmxnSzR1ZmlwcENqTlRNcnRGSExtM2FFOW1wU3JxaXlXdVFpemVSR3JZVXpMbHNIOU90S3VTcXExU1Z4WHdjRkpWVVhTOGM2czdpc1VDUStkT1lwOTRndC9ScmZFMFNPcmZjOCtkVGw5K3NaYkdNY0MvLzhHZHRGNTlJeDBlN0NXMmJ4MG4wUkZnMjV6ZStQWjMweTkvOFU0cWdURENlUkY3MC9DY1dSUkFPanBkalM5UUhTdjkzUTIyMXFtVXM4dE9XaFdFMkFiUmJkRGZNMmQ3a2RZNjA5dS8vZ0lRbGNqK1NZWktkZ2ViU1VIUTQ3WWM2c1kyU1JnZlBoaUp1TWZwc2VsSXlmek5WODlpcjN3RlF1bElJL2NXMDRQcjQ4VGNyYWRwN0V4dG5kaW9TQW04RHdFdnN0T1pHaGczWTNhWFRJbUMvNUNDcXRNUThZSDFUZTFwRkR2VkxMdkRwWElMY0tYLzR3L1QyTFJTRkxqVDNrWnlQS1F5VkloUHJ0eUJrU3pnZEFtK1FkajErRDN0b3dadFlwdlN5M3R0ZlNxS1ZDZ0ZiYXlpeWpIK2JCYllRNW95c3NMY1g4VDhVYjJIemdZanFPQTBXbC9Ua0hvd1V4dzVOcEErL2ZRTGJIU3pCRmRUL21zRmw1bHQza05mV3hxMDA0Ry81UDhxQXh0VlBUR3RBYWZVTmh4Z0ovQjZMMUZBdG93anNCbGdON0Z6MWNQZ1JZZE53cFBFVWJyS0FnMGV3RzAwWWJqQkVLRkFqQy84c1pEVXhKYzFVZ2I1cmhha3p4SUVWY3VmTmpwZEcxUVJsWmRDNGdkcG10bm9xQ2VFYXdmcFd2cUFYSGtuaXljMElxWkgxUnptSDlrbWFGcGFsZFkxaGl1RXVCTXFvOHJTVUdhV01pRHB2NkFKNllYdTg1dHYvS2RkVEY2Z0lDTSttM0JSZW5FRHpudjlpOTFLUHVNSER4dU9KOTNHKzJYWWNVbmE4Q2JKa29GOTdjQm1KbGZOUnd4SUVZKzc1YnplcXZTa05PSWhNRHc4NTZDRHhHRlVjcW93c25NdXNpMXkzVnhWbktVakVMS2NqRUZWYzYrN0lCdjQ3OHhPNW13RGE0dHJhWWVvY2U1Q0VtUGlkTmlDWUp2WTNyVThlSWxKWTMySTk0YXF4ZXZpN1hUSlQ4VmRwUk1IWnVpUDU3U2QyU2VsS3M0Q01JRFBsY0w0VHFkb2p3YTRMV3h1WHVCK1J5bnpjclh3dXNiM1lFTEFRMll0clB5TTNOczhMT2VQblZTWnRhL2tUMGFsSVpJTzBWaGVJV1BGb0U5Y0JpbUFDdTNiTjltV0txQk16aFZZWnFtcUxhTHdNcHBnUE55dno5SHk4c2N3aEsyMFhMdWFmdjQvM3dsaVdhMXE0Zm1hTkR3NWxzYXdiVzFRR3FzcjdDZjE2YmUvZTUrc3JzdnArRkF2YjhVdFloNVZvWE1RNGx5TjdKN3cvN1E3ZzZxSWVsYTJxQVJJeit1Wkkrd2wvQTBNZGthOFdXZG5CU082ZmFYVXZMNCtPS0cyc0J0U0JmSTNvWG9RUFkrYTVnVHdMUDVWZlVoT09LUmpDcUN3NlpXUDBqRUtyQjQvY1FKN2owaFpTUStRVkthd0ozWDFkUkNRVGRqSzBoclMwRkxZeDFTSjNhVThmYXlYVW1TZE1JUEc5T25WKzBnYks4R0FOT0N2QUo5d1VpYXZGOVFhaTg4S0VvMXoxZEJONmhidXZmVDVKNmlxTUVIc1B6SzNXbHhuck51M0xaTW1ITWROQnJmNnRmc1lVN2ZINHFoYXFaRmE0N01aRkZxUlZnMTRObVh6azRrbjRENzNFOUM4UWluM2VoYWFMUmlXS1gvRTBhWXRWRC9Hb0kvYkRuK2RoQnV0a0FwNVpYMGNVOGh1T3RwL0JFbXZNMDFRUE1ONHZFNnlrc0FYTUJta3lKeWhEK015N3hFbnhFTlRFdXZRRytGWk1FQlczQ3g5NCtvanpEdkptTkdDdzY2N3gvdjBTMGFpWS9RMmk1RTF0ZHZKdG5FSTgwQ1o4V1MxVUxVUlZ3K2tabFV1ejRVbUJQUVVURHduam9xZmhZYmllVzRNaEg0cVBYSGQrNlJ4R1ZGSVlHS3gzRkE2UjYyM2piak9QTW5jQ3FtTTAzRjQzU09ZSHJUbUJwUTBKZjBxOURpVzJOamp1MzZQRW1seDNlZWVNcXhRZHpnaG04b0FBSUVCbnQrakF3ZURsSE5LbVRZZXpBbE9IUGN3QUE4NXM3UXFvamdRNzVHbzlQWEswZ20rTFhQa2NtZmlOOUhucThsRDRnNUhyQTk0WTZ2NmxXRlM2dE1HZis0eEtUSTZzQ2R6NnVEQzJ0aVlKRTdMSUJ4c0hpZy9HR0NJMWpJWmdRckJxK1ByODhLSm1DZ1pya0JRVlZTU2tkaHc5N2Y3VExyT2JGbnNqY25oT1lIdW4vMTNMTDQ3SnNiZlNrVytuekZrUXlLd29VM3ZqNE8yaTJlRlN5QWg3OTdrM1RJc0VUU0w0bmFQaVdQaS9TMWowOWZNOHUzam84dHAvTkdTQlUxd0NLVGE4ck5Id2s2eXM3cVhSbWFlc0ZxNmUraCtFN3Q1eHRHMWRhU3JWd2xaUVhJNTBqOUV6cWxKZGd4SndqYy9nbk1pVlhUWU9heGp1aHJDNEwxRFZrenlSZUg5clNmN0h1bUlMU0pSUTNVZU0wSlkxZWIrM2JFMGdGRzlYTUxHUlIrMXpUVWdGdUJTUmJ3blJTTFlRcDhod1Y4WFRxV0lFZW16ajk1Tm8zY244Vm5xU09mZk9FM2dNelloR1BQRHNlMTA1OTRjWVNUMTZkd3JGNmtNdEVIbTBZZEliL09Nd1NLc3hqZGlyMFNTV0Y3YUk3MFFDUVVQa1dVVTVqQ0hmOG9zMHJrWkhTeWdxdi9TRW82c1NpSU51K3lFc1ZKYjhhYUNCZHJaVWRLM3d2TU9DNkQxQWRkZzVsdmdHNXdUUEtxR1VjSGdrSWhLcElFNWd0UHNCczZsN2ZpQ05lTkRwcEg3SG1FMDl4K05zVnRJY1ZyU1Nwc0hIWkxDTllGSzNMZ3pMTEVKSkI2SU52TXdybFdrWlBPODFST0h1YWpkYkhtY052R3RBdzFXVngra3FZNlptRmNGQWVzSWxwQTBYWWN0ZkxxcHBJMXZpR1hyTFN4aHVKdXhoUmEvME45Uis2cWFuSmtmbXRrQWFTY1pZdzlNeVR6dEpucDBYQzc0MG9KTXlYaENqZTI2QTRsejBxUU1Ra25mVDBOMGxJWU1yUlBIMVJ5czZDUk95L2lsSmYrOHBrUldNQXlmRGNiQ3VXQnMvRlliQ2JwZ1hJSGJ6SWVxS1lRUGJCUmNNaDNRalhpMmFOdDIzUFcwemVLYzlPSjNEL3ZOLzRNZXZEY3pTTnF6TXg3ZUtLRUZzVEo0VG5DN0YvelBEdVpyM3BjSHdDZklhenBqQ2JVNGZGN0lxU29XejhjQU9PL0drYnNncGxVVU1JMUI3SWlaeEhaWm1xZ0tJMjJKckF6dUxDb2lXd0VrTW9zUzVxTlhyTUJ4Z0RKTVhoNzlEU2p6Y3Q4cm8xSVdzQXN5WG9HcTNLUy9sdXdJOEtPUjR2L0JXREl3dWVwNDZLdWV2bzYvbURESDQxaGRpZnowendsMDdJNDIxRHJPQ1ZTNWF6QmozdU5ZczJoTmV6Q0ZyOE0zQ0lrSjlSRDVGZXlFYm13REg0QVFsZ3BpZTgwVHdBWmZ0U1ZpQlZ0WldWdEFRdTB0cS9oSWpUNlpTMHNncHlXaHV0ajVhMFI5MjhENVV3ZlUwVWVQZ0p1NWtMYlRHSDQvWlppTHdjdVQrRTF0QU5QbUZwaU1SbVFRZHA5Y1ZsWmIza2U5TVJOcGlVMFJoK1ZXOXlxcnZ2bkpUSCtzWDQvQnlpV2trakpTWEIyN3ZFcHduZGdqMGJ0Z2lvdW9mTjBRTndrSFVlT0crbmZTS1ZTcG5XMFM1ZTFNUWlRdEpCbGNnRmdyNmZoSnZkbVJXdFpJdVVKYVpNMERscmphSU5Qb3d2SVdLWEttVXVmaGt5Qzlma2t5bEdPcHNvYWsrZmxkWEFyYWNOTFUzZ1h6WXJQQWJBcVZLb3EyMHRjU0lVdzdsRWhUZkRGanhRN2NaSjdxUVZaYXJpR21jUTBmTk4xMkdxa29UVFFNTnJCNWRqbVpYMEsrdXRtbDd1MC96Q0pXazM3LzFxZDQyQyttSTRNTjZmUXpRK0ZBYXZyalZleGV5OEIzRVliOTdLblR1SHhZVFh1Q0RRTVhWdFE4OE5ZZDlRM2dvb3VCVmJpREs3R3l1aEZoQkloVVZWOVBqQi85MkVlVE1ETkVoUkNlQ2w3MFcyeVVtRXVza2ZicU1kSTdSMHJkNHVzK1k5T3IzL3hWTFZRdHFtZkZNZHRDbUZiY2VjZGU2SzZpdENqKysxNVFOOTRYVXJ3MEFINW5waU1OOFIrcXNYUVRaaDdvMFlYVjN3b1owb0k0TDE1N3JyalBUKy96V3FpWC9BNk5CcHpSVkpJWkdReFNTZldBV1lYcDV1Q1pyN2RaOUtlNHoxNFhoOWVrZmVta2VML1hhbnFhS2o4cEhoUlRaUklTcytkaUFEd2dSNDUweEZ6M2hhNGEwWkRmWldUOEs0NFlFRGNBQmlZRkxodU1MbE5qbmpEUHViSlpTQktmRWU4QjhlcFk2UzVpbStsQzdONWhWNUFGQlltQ0ZRcCtHc0hBQURRelRTZVA5bWhEZnhjbGtyQzEyUVhPK1g1NzlEVERBcjhSenVSdk1EUDdqeERBeEFyWU1KRHpXMGtucEJ6T3hRMDA1Zmd6b0d3MmI4OEdVNktCY09qakhwLzN1ZUs4REZPWVNleXVOb1ZhTFhnODc1L0k0QkVWZldoWEJtbjdHYTRIc0xRZlBDVEMxZEI1ZmRrYVNiUENUblVhSkdQRDlzb2NLVnhJU1l3MGNmTGNJQTZqelZTVUlWY1RFcE1HWGxVS3Bhc1ZjeTFwV09YOEhJeGdBUW10UWpKQWpjNVYvTGwzeWRTU2dRQW14b0xmVGFxYUVwS1ZyZzNIamc5RzFaeXhoek9vTTdnMFVNaWlxbnFEUU45ZXNwZ09RbEFWM0ZCSXhRSkMzM2s0aWtvNmgwb0VzUks0dWJGT2pVSVlxTXRIQTh5dUdwdk5OTjd1Nnl4VTU4NmZoMkcwcHcvZXY0TDBBRE1hT0VHSzVpVlNCRk5LYkpYMFFqQUc4M1Mxc2l2NWlFd1AxKzdNb0ZhVjB2ZmUvREVNRHdudHpqaUV3WTRiekdjVFpsU0RHcVRVVklmenF4aytXbkZGcUdZZVRwODR5OWdhc1AzaGc3Ykd2S01TTGFHbTFlTnJaZ0hZZmNSVkt3QU40ZHF4UlNoTFYyOEhHejRtUXB5TjRPQnloYzJOWndhSmp5UTdCTjc3ZFNRV2RMNTFON0I2elRyMjFoNDgxdnQ2Q0dkaU0ySUduN2NkWThJZzJuYmNJaW93a0VZV0dKVTBUUURTbEhoVGkvU2tGR1VPK0Uwa0tCY29kWEdyUzF2ZXE0VzBQVjI0cHNqYXJPUXNRNjdXVm9VMDFVYnE0ZzZrdlI0MldtUldocnhwYzJLNXpUWXAwWWJ2YWorZ1d1QndHUHVoUWY5eEljNjVaSXF6amtlOEM1d0ZEejM4clZRVTBsV2N5V3FnT09wOW52ZXZvSStDVHpoR1VkdjdJamFSVDl2eXQ0ZWZ2alB3MzNmS1kyVEUvTE05Mnk3YXl2Zm52aWt3K0Z6UlRxM2NOWGVlQjJ4VUsyQndhVjRrWStCbXQwRTlaNE5aSldKMTVyY0dRZlhOa0tiNFpMaTVjYjZKTlBHUDArQWc1T2RLUnB2U3E4MWhURGYxYlpPZXgxU1lQVVgrcTVNblQ2WVBRZVJKUEtiWkQwUkVaclZIREpHMFl1WGcyVzFYVDZRdDA5aEc0UXJ1VVRXa0kzbFFBQ01rTGM2WlBVRVhCMzI1dGhIdnFqRm1Na2UwUnhmZ1lHRWs1SHZFUXhIR29YUWtEQXFwaUVzQlNDZTJBSmpYaFprT2dqRUo1blE2YU5NSjhvaUp5bC9qWmRHZkE4bE1tTVE5dmgrNDZueHZQK05aTGdraUg5S09GU0t6RWlNd3NzcndEcUVlUkxXeUU5YVJsa2w4Vno3YVFmWHNQMFlOS2FXZi92MS9ZejQwSG12TFlHZVArMHRsOG9KTExDRGpBaWxPOWlIZ01pbFRsa2dUMDRYL2xJRzhnOGVPcGplLy9VdzZnY2QzR2J2VHRVL2U1emxzTXFnOUQrNU40WE9rRFJBN0RlK3c4c3dLVytjMTllMHdFVlJMR01BeTB2RmViVnNxOTdTaEN1Mm04YnZUU0lINE56WGhuckF5Q1FNQkh1eFVsbEJuV3R0NzB4ZGZmSmxHNzJub3BsWWlOUmY3Qms3anFMbWRidCs1RDZ5cFg0amQ2akFsMHJzT255Sy8xdFdJMVZzazg4SXZmbk9KWEYwTGFYUnlQVlZXY01BRVJ5VFlldWF0VkRKMUR0OVIzLzdxejM5QWhaOGVkdWhhaVpqNHg3UkkraGMzRGRhUlNxMld2SXBmVkEzcVlYTUQxWUp3SE4xRW9uSHp4SnFZOXltc29XM3VFSG5ObTFvMVhEZWtsMTQ1Uit4bGUzcm50Ny9IZUwrSXY1VVZieHJUbGF0amFSbm05cTF2dnBLV2NEdVpYOE8vYXgxYVFaV3J3bkhUd1BBNkZ1NEt1NEhyQkNMTG5LUUQxZ21RaXU4Z2pmblpWZjNCek5pcE5hTnNxaVlOOU9aazJKV015ZXdrSmZZY2FyOVNra24zR3BnYnBoU3NvQm1lOTd1eHZiSStwVE1sTWlrbTBnanhQaG1WK0tjMHhQQWx2VXlIZ1lmZW1lbEIvQXY3clcxN2Z6QkRHYUptbElKNVpGTkt3VUI4SnY3aUhoZmpmTDkwSVkxNHVDQkxUejVUOEptc28waUQwQkhuWlZZZXR1Vzc4cUV3ZFBDVkQrL3h1b0pNRUY0UUtUZUhWQkJVWTJlNHlGTmhLK0pUVHVoTHRhMTRjQWUvZWIwZGpuZjZRaDd4ZXp4TDg2bzNxa2tTTlcwb1hWbHl5RUlKdTZnZnBtcDFGK3k1czZmeFlwNGkvOVhEMkwwU3lNQWFJTkJtTUZHbUdDU2dNZHBYWE1RR0JBWlk0VGp5WWgwTTFFSDVIdDhmRlhrVnZYbG5PQmZDSFZ6MUhWY3dUNjU1cG9ndmRGUUZ3QVI2dEdWL2FidVl0T0FvOUtjQXJqdUJXYVZ6d0xSTDQvNEpGK1dsNHJlZlBpdk1zbEhSbFVoRTREVC9DMGswbW1DOGpFLzFOMEprakFVREdkdXBackpXUmVYazJlblVDTUt2WXJNYUloZld1ZWRQRUFsZ1NhM3AxSTR6WkR2YitEdWs2Wm1teUdwSW5yRCtDbEtIcGU3UERwMmxOTllnRHFZMzA4eWpVWXpJMWVsUC8vdzc2ZS8rOWkvVDN0TGo5TjdQL3duYkdMWWdOanltcVVjNFN4dXVuSmFIY3BlMmtUYlcyR1hid2Q5cEI4TGVXQzZsNTE1K0NXZFU4bGJ4Tno0eWx2N1hQLzg4cEl1cU9od2xkNmcvU2VJNm1YdzdLWUtlUC84cVd1aEl1dkhaSDlLcHdVTVVtcGhMUC8zSDN4QVUzUUVPK0E1aTRsQTFoMGRRUTl0d0ZrWWR0aFpnRFlIU3YvaVgzeEhRanRzQUlUQnpTR283dFpTeFp3Y1FvUzlWNEFJVjVtR1REWnk3Qkc1Ly96LzhSZnBmUC90WnVqMHhubHFvdzdlM1c0djdCRGU2UzQxcVZZS3hOZUJlVTB2YUhtUDA5dGl0UTVqSDRGK21lTVlRNmpOMlBGd1NkRlFkbnhnRktaQndXUGdXaVRQMG1YWjJJYytRNXVmWTBFbkdxb3FKd1I0Y1hzWDRENmNKU2JpVmVNZzFIRWxsU0kyVzE0SW8xdGh3Y2pIUnByYXB5ZzZPcS9xYlpFOHBmeC9iN1F4WldFczFhMmdQTUdXaUd2YXdtVmtJdGc2VnZabGNYenFIaXU5bWhCQ256RXFhSFd1emdWdHRLQTZ1Z2JsY2wyRnhMKzhKMnlwd2ttRlkxekEyZXJoSHBpRnV5bHkyM1FtUVB2bk4vdzZhQ3NUa2xpd1VQS1VGbVEzakNuc3JkeHJUcTdRbmo5QWZTMXd2M0JxOEx4Z252Zks3Ny9OUG51SWgvM0U4eFRzSzVpZitGZlJudTZpZkVBYmNLd2lVQitXNWR0TkJSQ2dHbkZKdTZUay9nM1BHUUxnUHczcHdGZjRmTzF1QTNSSmN1UVloS3dqWFRhUXY2ZXB0bnFVU3J0TzJmeG9jVlFzRTdjakQ4VFNNb1pORmd1Y01VV0NMbXI4TUtnM2hlQW1UR3FPRnJKUW5UNTVJSjArZEFNSE1wUVZ3QUxTRGlSMlE2QXZ2NEh3d0ROL0Y2aG5lK2pTbW5wMjVmeFpGSGJmSUltQnRvMWdOaEl0U0dFLzhHMkNHRkFhOEZKc0ZwQjBNUUFzSmZrZDcvNmFkdkxJVTkzZzl0OGw1MnRkb0tpdzhLek9YY2ZrYlBoL25RQzJNck0zcDVaY3ZwUFBFWkZvTjJLMzFPWGI0dG1GYTYzUFQ2Y0hOSyt4RU5hVnZ2UElDUlE1YTJNeklXUWV3c1JMVFp1V1g3ZlRtOS85ZGV1WDhDK2tSM3ZBMW13dnB0ZWRSZDVxQis4M1BVUTlYMG1jZmY1amVldXUzU0JnbFZLOTVvZzF1QkRHYlloblFnQXZHRUNJVk0rNU4zQ0MyQ1pVNWUrSVpmT1dlQmI2VTFWcWhweHFSTWZTYWRybEV5TTdDS2tTNmFmV2RNekNpSStreE1ZSlRqNUgrMkJVdWwzZFNCem5QcXlralB6WDZFRmNXODZBalZ6UCswZUY1ZGtUSnZVNHFaNWNVaWE0VEtjYzAwWnZrZWRyQTdvTnBpOWc3MHVOZ24xcmZwbGJqQmd0SFRXUDYyUzgvREgrK0xaalVHclk1a3hZZVBVeWl3NTUyRmtMSWlZSWFiaXpzN2xMamIyTVJsYzcwUEdSc2hVRTM0amhiejZiRkxPUFhKbVhxbzRlb3UvL3dYLzk3dXZ6SkZYWXlXd2llUHBzWFNzWXdoRXE4aDExdmxkaEFqZkZPV2h0YnBGMDRvYmFUeWJNYU00ZEZWUllXY05saGZLS1RUR2tYUnJ4REJnd1pDWjBPTngrakF5eStVVVpsYk9DOUZvS1YvbWFtcDNsMk5iWENKSzFmV0lNa2FZSSs4Y1UxM1h4Wk9RMDBxaG8yell3MUJTNXlEN2drNDRpREQ2VW5hZHV6TmdKNVpqeURMbUtIK29CcGlLK3UrK0txMy8yenJXanY0SjV3UlFoOHBnMEhKeU9GTjJoVzRnSDZlY0RRb2hrMU12bUZuWURueUV3UGhBd3ZGenlvZUlkY3lJV3VXTnlsUy8vQzB6MDZkeUJGQ0FRSkovNHhtQkFwZWJrZFVOcmhXeUNRdjcxSGRZbWJPTnlWQTR0Z0ZNSFoyZUZ6WjVBM1lyU1VpMnJUNGpKL3NpSGZ3VnlCY0Z1cDcwZy9KWmgrQ0dMOER5YVpsTDhON2F4QzJDZG9iNXZWenJ3K3R1dHVUZy9wU2hZb2tHay91c2lyTkUwOXUyQXN0RmZvMXE0UWxsenlaZEZmZW1SeVBMM2JkL1hQb1Z1SzVnR2NHSWZkRkRoZi9XVXhGU25PQ1E3ak5CTW9RK0xQNThKMlJaL0NXMWpWMld1MEdmZlF0MkJDbmdBNCtySjRlRTBWemJHWW1WU0dxalFsK21SNHhtMWhBeERXL3VVODNNQ2R0anFKcTN4NDgwRWlHMzZFcDl3aWpjcU56NzlJeDQ0ZUlYeUhsRE1FUEQrNk93T2k2L2lKNndFN2J1dnN4aHBEZC9tRFQ3Qmo3YkxETlpsZWUvWDU5RGMvL0tOMDVhUDMwL0REZSttTFAvd3UzYng4bWFyRWJLMWp5cWlIWUdKREJRUDVHaXFPcVlrbFJBT2FLdzFOeEE2eTY0YXR5dGkvRlR6blozRlRHQjRkQm9nN09MaStUQVpPVTh4MHB0dFhiNUxBRDZkZGlOODBNci8reFMrWnJ4VXFzd2kvZFVyVFY2V3U0NmlYVE84S0t1Z082dTRTTzVoRC9mWHBHeGVmSTJSb01Sd3Z0OWRKeFl4VGF3TU1ZQnRwQTZVTEJyV08ya2R4VlhVY0VFbVZpVTZET3czRUVFNVJvQUxwaTBuZXhSaS9pZk14bllCNUtSMVJhZWhJTXc2ajFCVkVXaHgvOUNnTTdUdDdsSnpqSFRkdjNvNHNwanFNSGgwNGpDMk9UQmVFL0RRalBUejczSXYwa1JBaTRHVFIxOS85L2crK01qMGkzbktkSk93MTJNbXNKRzU0enVqNExJeXJLNzMremRmU3I5LzZYU3phTmRoczE0a2dVTExhaHptSkZtSERST29CSURBZW1CcHpIbmpCZkp1VnRKcktSUzJvOFIzWUtSc3hyak9pY0VBVlY4T2xoek1nSlVCUWs4bHFHR2dHcnVYRlhzbEtkeVh2eUhMR0FZN0xORFRwZ0xyYWdxT1lCaXVPREVLY0RBMkhkOFE5ZklyUEhwa3ViSXp2Z2ZPODErZGdSdktSZkE5dmk1Y2QwQlY5SzJoTGZxSVVGa3pRWm5oR21zclB3YnhsUURTZW1abjB4b2poQTFLUTc2N3Bic3FWbjdOSUp0OEZtYmpKWFF6dFZid3FDTlFHRlRkclFJd2dXdHBWYkxNaDd3a1BYWkFITU1JdjhHZGhWd2FtalVodkhuTGJvR01NMnBwcE9uVWE0bDlUczhtdUQ0Wk1kcVhuRjU2UUd1VmVHQm9CRjZyaUtuWXdNZ213YU95aEZobWJkZkhWYyt6OHNCSlQzL3NMTWorNFVzaXMzRW5TbmhiZ0VyQTJUOTlrcis1V0NBNzVhbXdSMnpaQTJ1STUvWjhzdngxTWhtY0tvUHFwRkZiQVJBWlZYQVBDTVpuUk90OExXNWJ3a1JGNTZDb2hYNklaamp3QmRvcmI2UmozQ0R2YmpIdFJTYnpBelY1MmdseUpoS2xHRDZXd1ZSajB3K0ZISkxzYlk4Vmx0NG5WdHdJREtlR0xkT1BXTFppN3U2eFY2ZEpIdHlJVmlqYWJEVElEek0xdHByLzkyeDhqcVRTbHl4OS9CdnpYa1RSYUllVHNPckM5UGgrbDBpZUdIeEJFUEpOT25UeUd3K2d6YVdMTXJKL2tVV0llbnp5ZXgxaE84ZEsrVHNxY2Q0Ui9VeE03ZWpYa2NGOVlKT1FLUWwxYVJTSmFuaUlldEMzOThFOStTR2w3UW9CbzQ5SjdsK2lYTVkyVTlrTEtIWWNCVFU5dVljdEtaQ2dsWlEzenEyZC9DUWE1aFYyeUJsdFhGYnVXMy9uMmVSYW5JK25xOVJ2cDFuMk00REM4UFNTU0ppU2habmI0ckxsWGlRbkZGUUJibnI1anRWWDRsRUgzTGFobUQyN2NUT01QaHJHZm9hcWhjbXl5aVdNVjZzWDUxZlRjTTEzcFQzNXdJUTBOOUJIS3NvbGYyQ3hHY3lSU1JRMVVkT3YwZGNOb2RJYmNSWHJhWnVIc1B6SkFWb2QrZGtXM1NJdHpOVDI0aTM4VnFYN1dHUHNpR3cwTFpNL0FVSWkyQ1hOaDdsb0pNVnBFc25MdWV2cU9wTy85NE0xMGkvbWJvbFQ5Tm91NDBwWk13VlRPWnVpd0JxQ0xtbHFCOWpRWGVPM0NxQVA0aWxXVFFxZ3JsOS9DbHJtSGhCWEUvRFVjVWtWVW1oRkhNKzY0cUVKdk1wOERnZzloSXhEd0FBZTVydlFwYlFTTlN5OEhqQytZRGQ4OUgrb2JkN2tiYVhzaXFXaHUrK0tyakMycmxQeUt5OUFYZmZHSUJacDMyaThQYWNydldWREl2RVllbytsRHpwbi84U3kzdTVrUU5Id3d0dEE2b0t1c1FOS29qVHRZdTZubmJZaGowU01HUmtkOVNYQkRHRnFraGFBRDlzTkJ1U3RoNzh0TW1vY0QyR2UxbGNHWnhWQVgrekNPY2xOdERZNmpCTEMyVUJyOUtCTFQwTEVqcVE3Zmt0SEhvNmx2Q0Z0SU54eVZsQ1RUanhlb0xPeFdzRTZXKytsRmRoQzN5Unk1aHJIMXhWZGV4YU40SjAyd2tzNndZK1lFbTRreE9BTDNTL1I3dkRNbXpJN1J2N0RuQUFUbU93QVMvVmJoaUlseFRGNEFaTFFqb3lvT0FleGZBWHpQaDRPbmJmSWVKemZFV2M3dlFKUlJBbzN2dHBHZkZXbjhPM0E2WllLZElCbTNTS1RoM3hYUUhFNzZ3cWh5cXRyYTN5aDB5VHRxOFNkYUpqQzR2RWM0QjBpK0xueVJuUGFRQWhwYXRPZFZxRzR6bis0K3dBdDhCd1lBRVRRUzQvZkNtZFowSG8vMWp6NSttUFErK040UDNraERKNDZubTZpRlplb1Bic0VjdHNtVzJON2FsVTcybndEdUZxMnREU25XUFBwejJGTjBDMmh2THlNRmJhU2JHT0hQdjNpR0NzelVqMlRUWkpLODVaTklMMDNFRmJiaXgrVjd4MHlTaDNSOTlaT1AwekxPVSszdE5hbU5zSnJXNXU1MGZKQmR5UDBaak9MczZyRnphRVhuVFJZbWp3WTh4blhDN08xRDVUOTFCQ1l5bnU2UFBBSWV0ZW12Ly9vdnNhdTFwbmZmK3dSWVl4Y0RQdnBLTFdQTXRqeVhxVndzTk50TjFzMTljN1V3RCtLcTJTMEFjaXhRb3FpRUlBRzdpelZId2tFTHRqYmdlckNPN1dzYU5iQ3lzWkF1dlBROEdScUcwcjE3ZDFnOFZ3bFp3aUdYZU5obDRPMU9xTzRPbU5QWnFXdEZ5c09YVURzNU5zVUdGbklKTWxLOU1IZk4yQTJYa1V3dlhmb3NQZnZpQlc3aW5haU96cVVlNEhybzExdFlCWnlySUVscHAwUjRVem5ndlhpSWM2YUpuV0ZUMmRoeHJ5TmNNaDd4RER3R244S21ETjVLbTlXMEVjd2xTRkhwU2R6T3pBSDBlNHFMbmpkMXVZZXdFRTdDUlp0VHhQL3hRM3psUW42RzM5S0dOUDExV3NnMGtkdGwySEdQcEZhMDYzV1BhUDlybjdidHRaQ2E3QmQ5a0RuWkRlOHQvbncySkRpL2NCVDhCOGZlZ2hnWkFJd2g4b3F6QW9SZ0NqR2JmRXpBYklQTTlObEhRNnFRRy9JdVhpNHo4TVYreDFaRWgxd3RyRzBtZzdFQ3J5V01kbGhwbFpSWUFOUEowNzNweE1sRHBPb3dmY2NnaEhBOTNSaTVtYzQ4LzJJNERLNHNrc0dTdUs2VkdzcDlzZXFkaDFtOWRQRmkrczF2M3NKL2g3cHVWTWd0RVFObStJNU9nR1lVc0txT1hzUzVFaTVBc1hQMFZXNnZENDBHZXhsdkxTdW5zdGcrQ0dSbEhTV2tDTzdtM2pEMGVTOWpVTVhJS21ZQm56d2JYbE5hQUx3QmVKSEVDUkM0U2psK2o4eWt2Tjk3NDM2WWtMRHptbit1dkI3YXEySVZBY0ZsVk02YUNLVzBtZ25MNytoTDJJL01BOWFFbExsSnBsQUpHNkVMeVdhWGlzM3R4UGp0WUtoK0hPZXFXWlZiR3JiSkttQUordlowNmQyZlFYQVVmemhXVGkrZVBad0dUeDZoelNuR3RrY1Y1a1hpK3liWnVxZkN6Wi85U2ZxbmYvakhkTzNMcStrLy9kVmZwOSsrL1ljMFI0N3lIcktjdGpZREsrdzlGWEppK2Iyamc3eGJ4UGVOamQxTUYxNTVPVndlUnNjbjBpakZYTC80K0FxeGVJU0RJUFdldzRlcGwweXByNzUyUHQyNFJnYlNpZUdZZ3pwVXB4cHdZWi9WdzhySzVxaHF4bDFnSGRoQWpzUUt3b1N3NlhqOTMvL3B0OGlmMWNLdTNEWFNQSy9pc3dTN0lIdG5Vek0ycVViQ2tTQmxPQVpqeDJDSEZMYURaSG1mS2pXZ0JnSGl5eXlVbWNrdmtQS21DdW1wM01ETzRFNTl1bi92Q1F5WEFHandaZ1Z2KzhiV0NsSVgzdmY5Zll4dGxwenc5NUV5MjdBYjVUVEM0Y0FNWlNMUXBWYmNHWDc0b3o5T2IvL3VnN1REcGdJQ0xReVVSVmxwRVZwUndvYUg0WXJpenVwSytpLy81ZjlPZUczRW9tUlNnR29jUjFYZVZ0bGhiY1dRYnNWdksvQ3d5aUd4Z0s4U0x2U2tEQjVWckZGVnhJbHRWMXV1eCtMclBTSVZhQ21laXU5R29yalJwTlJTSENIQktNVnBJdUVJL0FQbnd3Qk9YMlFRTHB5Wk9XVGNsems4eGNVRFBJOTNpTHRjazRIeENHMWw1aU9PKzRpZCtlcGFmcGZ0RjNndmJnZHo1WDRUVTRZS3pKaTk3dUgxNGg3Ymt3YVU3SVFFclFVdG9kYkRuVzJJbHdHamtLd1VEVFdjV1hzdDlGbFhMRHNGWjFJVVZLUHpGVi85MFNEWHdvWWxVd0JnS0dwUnJhUUs5V1dWN2U4bURKcURSMGlQVzcrWi9xLy84ei9qejlPTWgvTWt1MUdUWkdlNEg2V2hGcmJ1RTlMQTVPTmpNejJGR2tFclpSQnFGekg2M1hjdklWRTlqdkwxTlRDR0xod0lWNGpDcjBaME5pNU12eXNCWnJXY1BBa0N3ajZ5b3NDazhtNEQvUUtBc1FIQU9KaGJmZ3VZNExZeElobERNQTN1c3gwbHBVSmE0b1lBcmtaZ0FlOWY5a2lYbVdWSnkzdDh6cGNyS2VWRFJwVW50OWptOVI3ZmhlVWptSmFycHN3cmZMaXdLVGlaMmtQMG5LNEdzV3RRNTFRUk9zblFjTGozVUpyRGtMdU1tOE1PUnVqcjErN2poMk1PTE9QdXlNTytRZVlMbUZ3WnFjU1FreTBraERiY0hZYXZBOFBoTDRFUjIvaW9rVnN3c25aMDdwbUowZlQvL2IvL1QyUk9xS1VQYi8zclB5RnRFVkp5cElsUFl6ZFIxZlRCSXZ0ck82RThGZXI3MWU3T3BHKysxTTlPbW1PQWFOdHdySFRuU285eUNvVzBZRi84eHVzWFF4SitRZ29YNTlrZE1DV0lZd0Z1RE9nd0dQWURzTWtwTlFpak1wbFZOOUxIbjdEcmlaMXVsOG83NHVTbER3a3pnbEdyd3F5dkVoUU5jOXZGOEY2RHhOa1k3aEx0RUNETEVEYXJFNE1uMDNzNDJWNysrQkkyS2IzYVlYRGdZTUtVb05vMmltL1hPKzk4RXRXWWRuQndKV29uL2ZzZnZaYWVlZjVrQkZXdkEvZEpjbTVkZU9VQzZ2SEpTRG16eXJ0N0NLZXBKYlNvWEZvbnBjODMyV205aTdyOEJEY0pHQVcwNGs2Z2twUDJJQmVmR2poT0hmYTBmZXg4YTlRcFdOYSt4RGxMaCttTkRqcmdIc0lPTG9aMHdNWXo3TTdDNERaUWpZMHdxS2JOc0F0SlpkNE1KREl6VURLRkxtbkxoVTljRFJQTndTSW83UVUrKzRSNHpaR1pUR1ljWVRNRmIyVllvVS9KaE9ndk53ZU9Gcy80WE1FOHhGV1ppcCs1RHpLcy9OMTdmTVpQRHhtTmYxNzNmUEZYUEs4VXlwUHdHY2VUYWN4bi9XNC9pM2JzdXVjTUxzL2ZNKzFsd3crZGQydTk2R3pXVzBFaWdBajVJb1dFd0FyUjA2bmdBdDdQZ0hneHJVSm9XcWt5dzdNd2hIcC9aMzlqK2cvLzZjL1NsYzl1cEU4LytUSnNXU2RPRFVYeU9kelkwNysrL1MvcDgrdlhRV1RTaTh3Uld6aEg2QVhPZDVzZzdpb2lmc1FSb3JEdWdnQjNidDNIZ1pKa2dJclFTQndiZUVDdWxmRVdkcG5Dd0N6ajNNYmVZTmNFQkozaVQ0Qmpjd1BKWXo3aUxrUmZQazNOckErWFRDUUNOY1VKVmlGWU45RE9nQkpZYmlqa1FPak0zWjh5cVJpMjE3T3hWMmJ2T3d2NHFkckoxQXVkbmRaNWwzREtzVk0rbCsxdkdQVjVEOURrazd0a3RzNEZLM1pVUlVhTUVzNkgyV2pBbTRmVmZSRUdRZlViSEJxSFIxQjVaNG0xaENCME45aGlCWFlWM0dYYjNwUXdlMnpkUDBKbFU5Um9ZYWV2Q1ZYUzNTWVRtL1IyOTZJMWtjMXpuWXdKU0d1R2dUU1FPYlQ1Y0Q4OXdjRjBiaTdTLzdoZzdVQk5qUmpha1J0WmdQRFZnc3R2WS9EdU1rdkQvaUk1eE1rTTJ0MlIyaW1NWWZhRDg4Y0gwamdaRDJhUWVMYlNWQnFmZmdKalpSeElyRy84OFJCTWhwQ2VKb3pMTy9QWXdGQi9XSHlNYzhNMkRod3dXSFA5empCT3FJVFVHSlowNmZJVkNGcE1Rd3F4ZDRibXdHeG5jQ0tGcHBHZ1FHR0kxQnovQmhndnpST2tqWTJ1ckIrYUN5NDNXZGZQM2NWZEpOa1pkZ08zVUs4NzJQRnI2VEdPTXFXQm85MjBpL3BMK05Jc0VkalkxOGwyMnBtZXUvQkNHaGdhU0wvNDZTOHdVY3hDMkVoMnFIb2J1Q3ZjdkhVUHByOUxmdm56NlE3dUhKYjdDa21CQ2R0RVhkN0dibWJOeG4yWWszaFloek91MlZUVit6U3NpNnptd3JmS2t4UnVCSWFhZ0xpc2RGOEQ4NUpoYWFOZFk4SFhGYUlSZk15RURxd0MxOEVyVVZZYzRzLzNpM1BpNFZjU1VTWjQ2U0hPMDVjdzAwUlNtNHpyUHVlMXArM3dQZnkyRHRxMWJSZnQyR0JqSnNUblFwMHNtS0h0ZThpc3ZQYTBUVTRFWFBMbGVBL05SWWlWeU8xN2JkdWplRSttUFhCWVduQ2MzSlBIeDdnRWtFekhQeCtNN25CUzdwM0xkcXZ1aUF3NVl0eGlsY0tkMTlBUTNCMkFDMFJnR1kyWkhMK2UzWXp2L2RIcjJCandVdDVlU3IySE82amVNcHMrL3VoeWV2MGJMMFI1cG84L3VvSk92NEdOWko5ZEdhVWtLbjZRNVhLRGlYY0x6eDBlbzlBUnNHTTFBUVN4Z3BZQXhnYjJoTkdIajBQaXE0RzZRNUtoenhLN25oWU9VR082c3hsTVJxUmdZTUdVUVlKcytIZFZrQ2dZS3lESUt3L1NGSXdzSjFITEs0cmcrZDhCTHF5RW0rL3hXbGJuWklLd0xpZWZhd1hpQkxCOWdRZWZJWVhTRnpOam1KdmVZTnRhSkFDNlRoZVJpckJuMGF0Z2VDRWRzU08xdFZWUE1ISVBVazBEQWJYVFpBQzRuL3JKYUxCZldvdnNsL1dveDlxYlRLdXlpUnF1b2E0RFY0Z1diRGhLR0ZZWmFrUXltcGdhb2IrMU9Hd2VpU0lnSy9OejVGdGZ3Qk44STcxdzdrTFVDQng1T0p6YSswajVRbDZsWnVMbklqMEtpOEVPZWFQcUNHN2VJT0NhS2FBNk0wSERKV3cyTU1NeVZYcXMxdTBJb254VTVYQnF3YkYwQTJhMGgrSGYrbnpkdUJXWWRHOGYvRmxsZzJVYUQvUTl4cnJGN3VDeWtpR1l1QTR6MG9teTB0WUY3aEZXczdCQ2NEUytUOHlaM3Z0eUVoMGlJK29DV0p2UzJUaFRDeXBZU3FvTTgzNE1ZMUVOckRYSW1mWWFsSGlZNUEwWWxpcFRxZHlLd2IrUE9FWVl5T29zU2ZmbTB0dHZ2MFdzSUs0eHFIU0xxS2pQbkhzMjV1TTN2M2tuOWNQRWwvR0hlancxZ3hURmppYTQ5N09mL3dyWERSZ2x4Tjl6aUh4a2oyZWlxS3lwWHFRd2MvSExKR1d3OXNId0d6UmNyb2x6TEtUZ3pSNTBzb3ByU0NQOTlGQjcwVHpoTHZLK1RxYkFhUnR4ZEEzWUUycU5IZERnWlRaYU1HVEpXRVFtUmgxNEhReUN4WW9YQkU2TDErSjlaaHBadzlBMjYrK0NPVEJWNE45WGpJNUxuRHJBNVFNY3RsOGV0aVVlOHlIcTh6M1RSajZYa2J1NHAyQld4YnM4NzNzOENub0pOVldkbHpFWDE3eHUzM3pPdjJCUVBzTllvbSs1aWN5d3ZPSHBXYjRyQ1VUamRreEpCTjFmcEREd1ZPN3NlbGVFM0hCSE1EVFFJZ2hYNmFLam81dnNreWZTMVBKa0ZKYWNlcktVUGxtNVRFSzB5ZlQycjM3TGRqRnBkVWwxTWprQlVxTzZsMWdaOWJGWnd3RGJRWXhJSjc1RzY2c3lLa1JtbUphK3dFcFNWaVEyWEdGZkF5RkEwR2t1djkrVlZDNE1NcmphT25qN3pSY1pRWXpQaS9UZGtDQnV3ZXRkaE0vMkQ3ZCt0MUdoUkFUYjhSQmdBcnNBZUFIczRwcFU2N1hJZFJTSUkrT21YZUNYUmR3RDhSWllPcVhSVjVoVDlsRmhPTUZZWVc0Z2NXenIwajBaN3g0U2ttT2dLVUpJVURQMEhkcERmY05KOHRDUlRoZ1VqcEJJVzBPbkJ2QVM3OHlHZmp6RWo4RzQ5Y001ZlliTkNhVFFoMlBET09NK0Ixd2JTUUV6bnZvRzI5UFI4MmZUbDlkdXBsbDIzYnE2eU5pSkV5WVJPekF2MUNZcTZheHdmcXV1QTBKc1RLZUdDUG1odlAzZEw2K1R0RzhPWXprTEVYRnN2YWVPazZOc01jMk5qYVZ5UndjMktNcEdwZGJVTlhBOEROa3J3TFVHNzNNOXZVMWIzSHZvUkRxTWk0VTduY3VvK3RwZlZsRXptenFPb3c2Ukd3cUd2SXhVTkkvZHFvUitkblRvV093YXp1TUcwY2o0TWFNQkgyTGxNRmF6bE9BMWp1U0dCR1BSRFN4U3poUTN5SlJFRVJjNW5VMXhhdDBtVkFZY2NMS1ZzcTI5dDY4dkdmbThIdHgvaEE4WTBuZGFKZEZnTzlrVFdnamhlWXdFaXNpT3BHYkN2OTdEUjNGTmVKU3VmMzREd3p2ZS9UaXdIanQ1aHQzS3VqUXl0b0FkOWhRNTNZNm1YLy91UFhaamwvTkNBemRhWXc3cEhEZ0xmb0JYTXFWTjNXS1lIeVZvelFDbVczRlpVNklVSDJtVWEwanJwTzNaeHdZbnVodWZwLytndGl0ZFlEWm9aMjhmM3k1dE9xQm9MTFRjSS81cnk4b2tMQTF3NWdCM3hWVnhQMHNxR1Y4TEJxRVo2Q3YxSzlOT1lMNkxBM0NJUkowMmNIQ0VtMFR3aFV3YnRCelBGMjBFN3RJUHBVbXZlVWdmWHorQ0RqbFIwR1BSejY5L2FqTHh5UGU0c0x0NVZqQXhNS0M3dnZ5VElNeDRCLzhMSUVENElUWFJLWUFjeG1HQndyKzh1aUYyZ2lDSzNKNFR1RXBoNnJjU3JhWEN6MVB4cHJlbmwyVC93NnppQkxWU1BrcTF6anA1bHE1cXhXTzN0Nk9CSU5LajZUdmZmSTBVSm5oblR6NkpOQ04xZUZWWEVJbEZldTBuR29obG1JclFyamp1b1lpSUlvVEJ2dUtzNkNmVHpyT1ptUTRqRGFZVk9NMy9aQXk3TUkxTkpKc3R4dU5FV25IYTRGVlZOT1AvdENFVmt5b1NSSXM4RjB5RTkzZzRaZ2NhUVBVcmsreTRaVmJDVW1SVjhuUXkvWjF6L25qL3dVVHdHWTYyZkxvYXlneDkxcTFwZHdaTnNYdmtNRklBQk5zSVVhUGR4TGIyd05GRDJMRGE4Y0t1SjlkU0d4c1hTRlJ3L0RYeVdCMDdjUWJtUmNnUzdabVdkNFowMU5Qc2NLbTZiRUtvbHJ0ZndlOUlONFI5M0JYMmxGajRXK2ZaTFJqVk5GdnVtM2lRTnphMm9hcXRBQmM4NjhrNnNJaXgybnhVWHR2Y2tybFNSeEs3elN3N2dEVWt4TnNpdTRiWEQvWEJ5TEFzeitIL3RCV09rYmd0MUpGTTcvU0ZOTkIvT2kxUTZzc0E1Q29Lb0RZMjlLYlh2dk9ueENJZUR0dWJKYngyWVVxbktOLzEzUi85S0IxNzVpdzdiUE1obVpYd2pSbzhkaUs5OFozdjRJQjZHR2JHODlRSU1LRmRCZnRiQ3daNVBmbkxNRFJMZURuSFljUkd4UUxJZ1J0S3M4czRIY2ZXT0VpaU9jQ1VPbFk4YnNPL1NkZVhXZTFNeTJ4WXRIU0JLYlJCZjdSRHJRRUxwZmlMRjE5amgvUVZVbjJQNEI5R0ZSMk03RDM5QS9pZldmOFFOWkw1YzFkY0c2SnVDMHBSMnJBc2tDb1QwOVhUK0U0WnRtcU5rdTgyekgwWFZVOG1hL2lib1RtYlNHWXlNN1dBV3BoVkJYelVHZGpLMzQwV09iQjNYSk9CaUhOUlpZbGg4alhPYVVNVG44Uzk0cFBidlpyeE5lNEQzeGl6cHB6OHBBMzVmRjc0NDI3YWtBNEN4NzJMNi9tMzN6M3YvVm1TeXhKZmZuL1kzbXlPRy96N3QyMFVURE16czh3MGdUVmpEQnFndmNKWjIvNzdEbmNRcFJHbGJNZGUwMVZYL29tNnNwU3QxSkl6R3dneU9oQ0FFTUdkZUs3eHA4K0hEZGtJWGFKRlJIUzR2a2poTTJGSWh2Qyt2SFl0UFJwNVNNN3M1VFE1UGgxeGZDYlcwMGd1RXpwejZtVDZpejk3bllSd1ZCTFJ2NGlkdjNNdnZNQ3FpTEVaSnZ2REgzMmZnZXlTUTJna0hXY244ZVNaVTJRYm1FcDFCSzZhRjM0VncyUXdTR1pOS1ZESlJRQXh4L1F6QXp2Q2h1ejNBY0FaU1JqbHRSczRWVzdqT3V2YXJ6eGNBUlZMVlIyS01jWjVmM0FJZkJtUTR5NG1LZDdKTTNsaWFJOTdGSXRWVmJJOXpRZUJGd2ltelN6TzBSeVE1SGVPRVhSeXZPN0UxY0U4TGFmVlRmSzNYdXdvM2VTVGFpTW9XZHRSTzZtbExlRytoYnExU0V4ZkhZWmVuUlVmc3hnc2tlSkU2V0hzMFVQZ09jeW14V1NhZlB3WVptYU83eEsxSHBmVHpPaEVXb1Z4Vk1GNDlnamVOU1dOSHVWbTFGeERQVmV1bTV1Y3BxYmhQYXBKWXlBSG1NMmtzMWttMkhkc1pEVGNIbGFvWkN4amJTTkJuVmxpVjhqQXVVTUZIM2ZhNnV1YThKSENQNHY3elhEWmhFcXAwK2tDanBjOEJBT2tEelBUTUlvdW5INHB2NFVhT2NubWlrYTdacVR5T2xUTEN1bGRPbG5vdHBESUZxbDRzNE11ZFJ6SjV2VnZ2WUVraEdTK3NzU1kyR3hoOFJvY1BKSXVZbWZxN1QwTUxER3dJMkcySUoxWE1NUkxrUEFFbUkxckc2b25PQ0pETWJlNkRLQlVRcjVCeGQxQmhaWkJiZkdlT1d5Q3V1eFlLSFVEbzFxVDRVTGdkaWQ5TTYzeGxjK3ZwVCs4KzBua3VsckNqalVKazV2RDdtcVlGSWlFM1F3bWg4cG14azhEKzZOTUdBdnFNbk5nY0xPWUtDYlZRSVJLaURyNGVpaUR1MkN1WWJSWHlxdURnVmxyMGx4amRKT2QyZzZrNjI1ZWdlMVBSbXdqNEptZjRwODRWVEFuNlU5Yy9Qb1IrQWd6eUdsbXNIUFJScjVIWE0yTGFtNFBPckJaMmhUUHZTYy9tOXYwdkljZjRxN1h3d3pqdldCUFhyQjl0N2lkbVZLK24zRnp3ajU2TFo3aFUzV3ZVQ0Y5bjMvZVlydFBud2VQL0M2OStIOVpmakFheVJBNml3bFdlZ29qTkRmN0NpV3NHQkNUTGdKSVhLcGNxbzQ4SGx6ZTBCZVpGMkpQMkI5V2thckl3a1JsRWxaRjBoMXZ3cVM0d09yS3pvK05zcnBQVGsybkRZanZ3ZWdEeWlFMXdPMDJpSnF2RUF4OUdEOGZIQVp4SkR4REhtOWpDZWRXcDFKemQwTnE3enBFZkJkcGM5ZVdHQ0JLQVVpcTdRaDVKZ3k2aGdqWXZ1amhmM1pKcVNNR3gydGQ0V1J1MjB5YVRBdm9jWTV4T1hFeWNlQUE2RE5INTFtSHpzZ1F5MkZpTWlJYUQ0RHlUbjZGcE9sV3NrUEt3R0RxZUI4YUZGSU1yK1daTWh4WVVWMEdTcGQ1Ri9kRENCS1NDT09NdURMRmpoWUlaNHpoRG9aalZkVTJ3bE02V3ZxdzhTbUJrZTZGekFDMERQSFZrN0tFM1VDTTVRTURnN0ZnckpPd3JnTERXMSt0QitsUm9laWpoTFNGLzA4VjhYS08xWG5jZ3VDdEVibUZkTFhNdFVXWVVBVlhpRTJNdTlzWTZaZElqN0pLR2FwRjBxZHdleENYdHFRNmlOQVFtWVg1TWl2K1lTU1NGWXovRDBNeTdlbnBDWWF5REtPNWMvc09ZOXVqU3ZXelNEOUlNSXkxSHNiM2hQTlRNTVJ5cVRPUytLMWlROUx1dE1mWUZtRnNXemlTM2lQTDZDTFM0UktHZjZVUGQvcDJVUUhIN3Qwbk5RMk9vTFJWalJScXRzMiszdmIwL0F1bmthNmEwa2NmZmdhakhRbnBwcE8rdEhjOUUvYlFSeGpFbDJIU3UrQ2RGWlZOL1F5d2dDVlNKcTQyUzlqcWRwRlNYYXpiR05zK0V1QWFhcXF3WEVOeXFpTjR1YXAyRXhYN0RrVlVrRUl4bXU5VFJGVVR3dXF5Z2VGTjdJQTd2K0NnRWl0U3FmaFRaaU5ranpsMXQ3eUdUS2ExN1NEblFBQUFRQUJKUkVGVU1DZmRIU3BJWGZXTVdYZUY5dmJ1WUw2akU2UFl4SmhWY01GTURrcjhWcjRSajNWR3JVWnlFTDhzVmU4NWQ1Q1pGdkFFTndwT1BHVUduSFMrTXNGblhKVUppQU15ZU1QYnZDYURDNk04dUJtQ0JqQzFqWENYNEc3eFBGN0VXOFJCcFJ3UHlTUE1SZUNuZGx2YjBuc2dRdlJBYkhGY244SW9NY2F6V1dyeUtTbklIc3U0K0wrNGZOQ21XbzcvOGk2NnRDTk5BRXZibG9qaWdVeHpham04bWhhNFNCTTJGeDJuNVRnY2hHY2pMdzMzdUd1a2l1ajlyckxxMzJZUzRKWVlwQVBXMk8wek5VejhEdFdhWjNjV0lCeFV5Rm84aGsvMnB0TW5qK0w3OHlEZEg3K2ZHbnBYMDdGVC9la1oxTWVtdG42aTh4K2xFOGRQeGZidWV4OStuTHI3QmhERHoySkgrRHk0YjJkdlEvcVMwQWxYd1k1RHZkUTBKSFNEUEUrOEhpTzlrNUhCb2xocGpLS0ZEZXljeU9qRUNLZ1FPYkdObGVqckxnamdybFJzTm5CdFc1c0JFK1NFT2ZaZ0RFeG1USXkyTzhidllYc2lqUVpRSGZ2Y29mUlFRcEhSNTZrQlNaRDlaWGpoZDBXN1piYWtZbnBrZHJ4UEZVYnBSMEtNS0FMZUtWSXhLZlNGZEN0SVVVMTRzN2Mya1FjSiswNDk2cEdxak1obk5vYVdGcHdYZFVha1g3VUVEYXVLRzd5cUIvVXUxYlZqbnVpWE1adHVoc0RaWVdRR2k3dWFzY01HMDZzbnpFRFJmSjBWMzlXOWh1c0dJaTlpVTFwZmVVd2ZNeklMeDFtWXlEck1RNFB4UTFRaEE0ZFZPMjFyRm52Vnd1VXYyUFdGQ1FFRHN5ZmN3NUcxdi85b2xQcWF4OEEvVGVEMktwTGMwaEtwY0lnMTdDWUpYU1BlNitPWUFxNWN2WVhSdnpVTkhSc2tySWJzQnJoY1RGSTJiSVhkeHJhT0krVDR3cytNM1QybEt5ZzcvcFpweThXcnNjRmRaVUp3eU84dUlacGQ0Y0lyNTFsY2E5TjcxUitsMjlmdmtaMmlCUU41TDhaMVl5TzMwdmo0STZyc3pLZXFUZE1FWjl4Uk5WMmxHcENiT3V0SVdBdVlLVXdEdEFhT2JaT2EyMERzZlJoTjl1VEdGRzZZRGJoUXVBcW8rbSt6TUp0UklXSm9rV0lOTW00Z0tMMFdSMTFoMkVvL1pHaFY3T1NhdEhDU1hWVERnRXE0YWtqODNpUHowbkJ2YkdVTkM0dm1rbTBZcS9VTTNIUVFOVjJFOVhkMGZzVHRNT1J6TGJRS1dwRlpCQlBpdS9nWXhCSDRsWEc3MkJUaUYvZTVnSElQei9NemZ0dWVUTmhGMkZDYTZEUFg2VmFZSG5nVFk0STJnbEhsZDZpSkZaSVNYWTgrK0dyN0pJMkZHdXNDVFNOS1diN1B2am1lNkFmZjFaWXlVK1VNYytuR2xJZGpzWTJnd0JnWVQzcWpqMExMOXB2ZlRDUTNtZGRLY1k4VDhSSnRQZUFDUUxQREVGQzhrV3NBVWJ1U1RMQzZpbW80NUNxeVdrNHZoczBPc2tsdTd5Mm1sa1BsZE9GYlAyQjdlUktiUkZQNjhLT1BjRnhrSmNZVGV2N0tEWndSTDRkTlFwdUpoVUR2M3NZRHZxdVhQbFdUVTVzRWRheU1kUmpmRFhGUXpOZldSU2RqTUhaY1VUVU9aaUN5alBJamlrMklESXpIdm1ybmtLbFdzOUpHQ0FBMkhGY2R3Y2VJNFVpWm9lamJwWCtVY0JGWWhSb29HQ1FNR1lYTTNGTG40RTZNWDFqR3loS01DeVpwbitoTFhwRzRSU1NVSS9HQTFYUzBZK3hqdTdEd2FpZHBZMXBnVGdiVVZtTjh0MGhtSFV5dWx0VldtMDA3RG91R2ZXeXo0eVZpcktPNmFHdnljS3RkYjJVVElIck4zVXJmWmFvWU1oYUh0T1Y1bHlDbFJaMXRzZmtHckNXQ2FxUXFrVmhFaW5MdVpGL1FQY1ZuUElTQnlmTk14K0xPVnhBaUNmOHMybW9PY2dONmxVN011S0RSZjVVc0hKdW9ob3NySTZpUDNJTXZXV1JHNEtXR3FYenl4UU1ZbGdadmJHWVk4Wit3QzFkR0ZiNStkNVQ1UlVwa3Q5ak1wa1lzVEV4L0ZMdDF6cEVTNEJxTWFSVWZ0R29LYmV6VmtOVmg0eUZoTmtpS1NQVU53RzhhRmZuR0YzZm9HeVhmQ2FjQkNzRzhtdkVGUEgzNlpBVFEvLzdkMzZWSHFHQWw0dlE2elEvdjZvM3p5Qnk1dVdyd01EZG9XYVpRb1QyTFlDeFNhSFp6aGJxRC9nTVcxYWppUUJHOGdJRUJJL0hFa0xONjhGRWNtQ1Zab2c3SmU3UWhYVmppQzB5Z1JOb3NVbmxlUkJmSlJHcVY5RWJlWVh5a09DbjFScXBrRjBUd3BKbk1xQkFkTUVkbEJ6N1N1eGxKYlZiNmRPRUU0MkorZ3NFRXZuR1JJeFppK2hvYUNEZ2ZobngrTzVmMk1mQWFHaXBocjFOZGxMSFExRUZiM2dlOXNPaXFmVHcxQzBVL1hjUzRWWnJoaXl3bDFFSGFOZTZXRm5qVzlxVkxwRUhvUmZLejM3WXBIY2xzSGJGSHRHT2YvQUgraFkyTVgzNjYyRXRQSHI2RE9ja0dPanNmeUJrUGVMTkVSc08wb2wyRkJUTWFjMUtDMDlGWjh4NkpuQ0o1c2NwNFczaWMwNWthSXZMUG5UK2RPcENNbmowM1JLakZqVFE1VCtyWXUvUHA5ZGUvR2VXa0hsSks2ZkhzZFd3emxEVmZtR1NIRWVkU0dOSWNZdno0a3hsVUYrS3hPZytsMjdmdjQ2KzFoQ0dUeUhvSVFmRVFZdzZTQ2daTTM4bG42R2NNVUlicTlyQUFrQUg1RHl4akxBSVljUG9Kb3BqZUdJRUZJendURDNEZFhWSnN0MWlyREVZVWMyWWtmS0h1MlB3dWtycWJJY3lNQURDMWlJNS9xb0xGeW1YT0xsY0wxU2dycU9UVkowK2UwNlRYdmZOUUFTR0ZkUjNTV2pXU2FEZWwwQS8zVW9TQkZYaWYxYm9WKzFVVFRLcUNmVVRuVUNNSFZBYzFzRnNuTHlvRkl6bHAwTlZnNjF5VVVHT0lFNlova0JSOVVDSXdvc0c2ZHpLQU12M1JTTDFKQVJMOWxicVJJaXBJY0pZR0F4dkFBNGdUWmlYeWJDQlJyYkd0NzdoazB0cGwzUHl3SW8xcFo1cWFPNGtqeE9XQktzWlZWZnA2UWV3d1Q4QUM4OENleFBpVm9qbzdlNWdYNHU2V1Z2Q3htaWJzYWpyTmtlZXFrNlI5TXVramd5ZGlBK1Vla3BUaFFBeVR1VEFwWVVvamxCVzd4NzNlVnc4emt3Z2MwL0ltOFpXeks2a0x0ZG5TNjVxU0lsUUhacmVLbEdUT3REVlZUVzFzcXIyTnBHZHVmSkpxVURuWGliaDJNMklmQk5wRWxXc21YLzJGRnk2Z0JoSk84K0ZIT0ppUzVnaVl0eEh1MDlURndrRE85bG9ZNHM0TVRyTDBXWUlRdmpVd0pXMm1va2c5Nm1hZDZoNVNyazROaXRmdTNBWlJndyt1cFJIM3gvM1dQTnlIbG1UTXdsWUVOazVYS2N2eHFiSTNJZTAyazUzRVJJUEk5TUFYS1lGR05PcnZNSi9hcTVTT1JQMW9JL0F6RzdERjA2ZUxEZWRsRXRxZ1BTY0RLQnlZQzBsTUtSd3hKTm9MdW1IdVZmOXFyUDhKbmdMdW1IOXVZRzVrT2tFU21icEVhTnZubjFKVVZXWVdRVU5jQ0RxQm5JQ1JERXc2c2NkWmM4czJMRVFjNlpVWDJUK2JDL01KdUZ0SWVsNkxFRFlSUEhORllFWm5CSzdFNWV0NU5VaE80M1JXbHdZbGxjaEp4VUFjdkw0aVRvQ0QwSjFCUTZ1TXk1aTZNdEh3cDg0Y1RRTW4yZ0R1Y25ydjBxL1N2L3ZlZC9BWTdrNi8rdFd2MDAvLzRlY1JIemRBZXBJWExweEhZdE9tb3pTREpJV3R3S3JHVnBHcDR0enc4SjJ3UjVSTGVNMWpYTjVuUmFqR0NMckJwTzVDSEkwZ1habkp6VEdQTUNZbVJJU1hvVGdHLy94UG9McEZMSmNMNEVDOHFxdmVDOG93VGdBRVVYcGZTRW0wa3g4VHNWMXBzcGd0MERkUkU3d25WQ1llbFlrSmZHR25PdWNrcS9icEVMZ0hVaXJPNjlpb043TVRLOE90SjQ4U2p3UXphWGJuQzBTWW14N0ZJRDVMOEc5UEdobzZDaU5uOWNjNXNveDZHenRIM084N3FqREFHdU9tdXdTdXVoQ2ljcFQySnR3KzdBdUliWW9lcXljYmFLNFVaYi9jSmhiNUhFdWNzMm9TbldoQUpiRXYyc0JFZm0xV01tT0RnY3U0S1lRN0NlOWxqY0MrQ0NJekhnOHpFeWpGYlNJTmlRZm14WElIRGZHVjlpRStwTmQyWWdrNzJZM1RCYUthT2RRemZJb3NEd3RMTzZpNnJZeTFENktrU0N3cVp3VUQvUXJTTmE1WkpOOERIN2kzalJUQ0JxcXZBdk15TU5NQlZPYTlTR211dTVkdnhtNWVNenVHN1RCZDNVeHFwZ2s3ZXJLQXZjZ0sxZ1kvbzE1VG9tc1JpWFFXQnJiRG5HK2hZbUVLWTRlUG9yQXd2VTJTN3pWVkhvWFVhN2pRS3VwZVBjNmwvVEJTNHp6VDdidU1hd0pwaVBBa2lrQklJWXRzSW13d2ZtbGxtN3FIYmxqVkFhc3lTZjUwT0pheFdEZWcyS0RLUWdDTEdQWTBiVGdXR0c1Z1h2VS9FMytVS0pTWVlEVXdJeFlSRmlUemNLbk9pMHR1SklpUVRGOWVVQlU4b0U5VlFnOFhGRzFDcXV3ZUVuOW1EazZOTmxUZkFZNkMzMSs1SVdUR3BpUVRLaW5YZFBlUndjbXdJSExRaDNiQUY4dlJoVlJIMzdrUTQ5S01BcGNRS1NXYm9MVkkxVVRvVlZZQmVZNEw0cFk3MWZJSHg2blFvNG1DN2lLaHF5N2Fkajd2UFVGYjRMYnN4OWpLeklEbFI5eG9hZ2xKMCsxZ2pkR0thQ3lpOUNGa2s1QTRHRzNvbEZIZnpJN1JBVHNwa0VKZDRycUgvaVRoUEVxUy9WNHFud3lQMzhYcHNUMTkvNC9lUUNLclR2ZHYzVTRuand4Q1ZQdnB5MXQzMDV0LzlNY0FZaTk5K1BINytOeU1oMWQxTThoNGhLd0NEYWlKV3dEczRmQURwQ3dDVy9FM2VveGRRNXZDSG9PMDRza09SVmkxbVJpZVU2V2RpcjRwK29iZHlINjZDdEV2QWVCR2dVRFVGclVKMEFXUTk4dGNsRUNFanBQcUlTTVNtQXd1eHVlOVFEb21VZFZHaHAxQlFGL2dlQUxVZDlTRDNIN25LUkFXWnNVNGRRamM1UDZpNmxBRENDdURNbVZMVmtuZGpDQlhOL1lWNi8vdG8wYlB6MWdvdEpUNktNTFFnNm9va3pLRzBXN0tjU3pRVVFQajloMXJVTGNlNERKaUt3ZHBFeE43cXBoTEdiS1pMeEVHZUJmSWdaZTZPMVlhclIyVDloeGpINVdLTGYya0dpSXpxQ0pQK3FLdTZCeU45TXRydmxxSldrL3lCYnpDbFpwNEVhNG9yVWhaR0s4aHBZWmd5Q0F2NHpaZ1d2WE96UVR0Y0JYc2JBMzBWNXk1QzROWklxbWVwZFYxMTlCSXo2UFlyRkJOR2NQNmxoSUhmWk1XZ0xlRkVpcjBRUlZ0bTlRMmpwVlh3ekEwZmhNWXptSlFnM29zWTEyRFFVMU1QOFp2ak56dFNKS0xiQ0JvOXByQ0J2WmdETmNac2xkVVVLK0VqL25JQUFKcU9SNzU5RWRWWlFtSDFRMlk1Z3ArWTR1b2dhWjVqaXdMU21UQURPeEM2a1hhSXh2RUJ1cTdYdWpTc0JzSWhnZHBkd3RpQjdrMEhPc0xWODhjaUUvYmhBajVEbkhFRk03U1RpUzdVeXBFbXRXdXBVWlRRUzNWY3JDQmJVNEdXUUZueEJVM01GUXAxUkxDT1pyZUJCNEhZb2pDQnd3Q1hIVGg4VDB5cWNCVlprc2M5YytqZUM0WUhUZ2FHMDllNEdiNWdqdWs5bldQYkFoSzlESWlGMjVwSlB6YUdJLzNLZm1wbHZvKzhWSEowOFhiZC9zT1BxTFJVREc1djRCaFBNdHZtYWRIRnA3QVRTYmRQaXRBUmEwRjJwZHVlWG1xNmF1UVhvWkJPNkFZR0MrZ2pVekFJRjBZOSt3VS8xeFZ2YzhIOVhzeVU2TGlzQnhldlY0aldTRUNLelphY2FTTkhOU25UZzNneDNJdW5UNTFObDM1K0JQY0hNYlRzWUdqRWY3d2FHeU01R2lYS1dVMWxnNzE5S2R6ejc2SWdYVVVKdGZQZHZaaFJHYnNJTmduWG4vOWRlSVAreWdFT29Hb1RvVmdWa1lKdHd4UUt3eW1CQkNENmNaQTh5UUNtV0MrNFZNbW9CbW5zK0Y2cE4waGZvTVZHcDBkdENzQlpCeS93eCtMZXdTaTdXajNVcm9NR0FFWEpSNG56aFZSQkJENHJpSjUwbG5CSUd6MWVLREdNL1NNUHNya2xGVFhNSlJya3pCWTNHS1lyYmhxNlBGc21FazNkUWVQRHg1aHkvNFFEQXdKRENhcjFCQU1rdWZEa1pEM09nNFJ3ajV6MGk1aUtNNWhOc0ZRUlRiZTZXb1ZDdzgzeUtqZE9UVDVuZ3VPeU8yRHNXcUNhSzZtTzBpdG5BeEc0MHJvTmYrOHQ0bWRyeVlrTVhjOXd3TWRlRlJJOXhJNXUzaktEUm1naU9vK0Z3VXYxZ2h6YWNiRndBeWRWcWtwa1lPK2pPcmJURlZrSXhybXpEUEY5Uk5EZmJIVHBzcTNpYVFPWU1BN0pWRllBM2drczI2R1lIT2xHd21hb0dJSWZRN24wa1dDVCtrZTRVWVVUU1hsc2JQc2ZGVHhmQVdmc24wazcwVVlWVWdIWEpWNWJjTmdWdW5iSExVV2hhY0xnVzRkQzNqOUw3SHp1VTdpUHl0Rlc2cExuN1JwN0U2enBvYVJZU21PMDQ2YkZTMmsyVEZ6aDg2czJpcmIyQVJ4YkVyZ2EwaXVmc3F3c21ZaWsyQThqR1dMUlNJWUFyRGdCczZyd2JqQTVRWFZPcHFzeURBTWR4SWJJMHFnZ1lWTUNRVUFaNloxZ0hQQmRHakNNVXZvempmZGk4TnI0bmIwR0pqNjI2TmdXREtZZ0pXMHdUdTl6enZpUHM2SjZ6SmVmNHREMHBHTWd6UGNKUTd5S1c3VHFjQjFhY0QrZ1FmaWZHeFNjWXZQRkRqRVE5R21kbFI3SnAycEdma3VOUVBob20zWHVmZVpFRUJvTDBMb2VEWVlWaENoTCtFZlBaY1Y1ZTkwVkp0T0dMOTRjWFJUdlozcjBYbnY1eDVYaVNpM3prdVZKc0tHeEVTdGt3TTdrdnpqd2I2d1FGNGx0b3ZmZS9lRFVDR3N3UExlcFU4anRPSDRpZU1RaWlzc3UxdlF6YWxUWjNBV0hFanZmL1FCYXVONitzWTN2cHVtU1AveEpYbU96R09sODZBK1BJQXAxQ1FyOTlRSWNONmRKVU5vVHlEVEg0SGxvS09yZm5FUytJdko0TFIyS3haRmtBRm1Bbk9RNjZnR2g3MkxObmdKYlFoODJ1RXZESDh3QTl1SmY5enZPZitFa08yS0NIUXptSlRTYWpBckc1TFJRK1F1QWs3SUpqRnhHMGc4cGhwcFJaMXBoUmswWUdCdkJEbGJTTmZpZUZhWFRMTXpHOXZzZWp0cjg5Q3VaRFh0VU1ObG1NRlk1RGVpa25Nb0E4MTlWWEtVT1RrbXh4Rkl6RzhsSHl1NzJKKzhNdUpDd0RuYmttbkVmZlRaalFXUjBuR28rbmswSWJtWUZYTVJXNkxTdVJzRzhWcndZSlB4ek00dElPRXNoTW9xRTJyR0JnY09JcEcxd3VpUmJpRndLL3JNeVFRd29EZmpFR242SVRQSW1qeXdGY0ozUmRlajNmZzZUUTlWTU5NS3NHbEFNbXRqTjlIZFhRMzF5MGhBSlFpN2kvenJSM283WUdxb1JZcVRyTXBHUnVnZ3JKdUdSbkh4MGlCbFE0NjBVVVoxYTNaVXN4ZjVMamkxQWt4SmY4U2ZteUhHOEVXQlY5d2JOdW12ZWVpVlpHa3lHSXpTbk9QWTVyeTRvQWU3QkNqeHU1QjA0VGZXQkFOVG5kdGtkOVA1S3B4SzE1R2NsSDdkeVZZZFpIS1FqSldpd0RuNnY0T25mbHNMbnY4RFBVaDQ3aUtMc3pLT2pJOWlXK3dPTXovT2E4RjRYSkRDVllEM0YzaHJYMktEVEh6bThMeUhiUVFlQis3Q0RKeG5yNG16Y1pYM3daZ2NqM2ppZGUvM0h0RCtnQm1LMDFrVkZXZGN5TU0wNG1MTnZmRkhXekV1UDZWUjZZZVdnd29PK3VTejhoSWxhZHNQQmduTzVsNjZPSE0zNzY4NVZGLzNFeHZsRi9jRERRRG1hdUhEUWtmMXlrT2dDOWdvYiszcUhmZHp6VWZwZmR4bEIybllrSWdtZHBEKy9NL2ZSSjJvU2RldWZ4NTZjUzhTMU0zYncrSFJhMWx2N1ZXUFNQU21FK1RyMzN3MTNiLy9JUDMrOXgrQ2tDMTRFRStrYXpmdmdPUkhjQ0RjVEpldlhJVlo3YWZPdmw1VURhUVUweVd6NG12ZzNPZlBtblJoVDR1K3d0SHBWNndFTVRaUENpSW5DOElGRUFLTzBTb1dZSFNGd1hqVnlSSXdqRG51ZFR6OGk3SHgvMEJFSnM5emVmdllGU3pmNzI4ZkQ3RFJyTytud1FBeTB4c25aTEFhamZWc0RvYkJkNUZXZy9BeWZ3MzhibThsc3lSU1J3c016TW1ITXJBaE1GNzhtMlp3SVpoajkya0ZDYzBWZkhHSnNsMGd2cE5keGNxZlY3WE1QT0s3L1hlY2pNL2Z6clBNeTY1RnVFb3dZS1JONEpsZEwxQnJVR2tkZzNPOURzSEt2Q1JpLzF5WXRKdHBsMUlObEFtc0lPRW9OWXBvdWxPc1VYNStuTUtqUzlpRW9oZ282a1EzTzRHOWJDU1lycVhDZlJyQ1Y1QjZKc2t2dFVEZStBck1xb0hJQjQzNDRlYUJvWHFONit0SVBSYUhjT3dXWmJRV1h6TWJDaDJveUV0STJQZllSZDdHSnRuYjNrQ3E1dDdVMzBzMUdhVFdIV0NtbmN0blYzaDJDWGk1b2d2Zlp2RE9zV3RPNktEbW9pWUQ1OTY0MVlBM3NKRlphWWQxRVF1SkFvQ28yanZPRFN6N2tvbk15bnhYWWNQaFhVcUJ3bVBiWUhMK3BBa2RYUzBlSW01NHYrOXFRcHFPYkJOSVM5S0piaE11TW1BUGY3VGo1S2hmZ3AwR3NYY1NFMnBrZ3pVRzNjU1JQbDJNMUhBS1p1QzdZdEZrUGdOditRejBveFUvNDV6SWVYRDRPemFWeEJ2T0I0UHdPK2Z0aysyR1pNNDUvd1VUaXpGR1M5RWVTbUl3RWErRFZZRXpYNzFOT2xDUVVRTlIrdWM1Y2RFLy9vVkc0em5hbEptNlE1bHZ5UXV0N2NpMy9ZeG5BbmZ6UFRqVFNyWjVXRm5zY3hEY0RTS1lDeXM2enVVZ2J3R0RENU1TQTJCakloUXBlWndYdTNYS2FZREtzeEJJN1Y1ZE9uNzBKTU5pdFgweWdoaE1sUDB1Nlc5UERLUjd0MGdqZzhHMWkvcDRLM1AzVWhtaXUzdjVVbHFhR0tQVVZFUDY5UFBQMG1QaXQ0YU9uYUJlWFdmNjlhOC9SRUtqUkJPVFBiWDRDQnNNUGtOdTdTTkdTNHpOaXRZd0R1aUppU1BQRG1MNk5xdFVjSE82bzgrVms3d1BNb2NCRTlSZ3lZNmRUNW1KYWlXM0NCNnZ4SE1LWTA2VUREcUF5ZGpqQytmMTFYSzFGcGpocmlCRDhqS2Zpc1pjZ0ZIUUVJM0ZDc1VQNzFXbFZFeVdNUFJtYjI2cElLMFExRXJxWGlzeUx5N2djZDZGYllSZ2NhYWJiWEpXWFd4ZFNtQnU0NU5DSWRRK25ScE5McWMwYTUvcnNkTllIcXFSblNlSjNpT01yeENGN0ZiQ3EyRk9RMjBOWXpsTW0ybDNTTzQ2dXN2cENxWUIzUlFwU2x3ZVNnUGFGNVFNM0VYS1RBbDdGa1NtN2VzUXNZWldTSjU0OGlUdU1RZDZNenQyblozc0hDSmQwNWpjTUhKZDllSE1hVkN5am83ZHFHOGJ2TWNLMGpKaGZjbGtMdTVvaGtPaEt6QndWdzFxNWhPbis5akY3Q0Iyc1F3c05XaXZZcERmWXY0dE1YK1lWRGJ0d01reGF1eDNWOVpkMzhWbE1qY2d4ZGJYQ1NXWUlydCtGU1N3SnRSTHBkd05wSFFqQ0Rxd0VZVkVwK29OM0UyK1p3U0JpU05WNjF6NFZOZTA0V2o0RnVlZGQ0Q0F0TTR3Z1pXRUQ5ZmptN0F4OHdJN2xnU2tTOUNiTURtVFcrcUUyb1NMaDFLUWM2c2tLcnl0RmdRbXhhS3JoL3NhakU4YlVTTTRZcC9yd1J0dWl3bHpaMUQxU0R1V1FnT3Y1eS9qbnd6Qzl6bTJVT1c0S0hNSWhzRjkwcnA0cU5Za1R0aVBTRERBUFhLQnVNNW4yRXU1YnR2WktUcnY2TWw0WGZCa01qenFFOXlEaEk0MmxSZkxZQUNpZjl4MzBMbDRYOEVBdlUrcUFHQmhZaEpXUVJ2MHljK0FJM2RJSXk2UVhpOXNZZjZHWVRGRUp0ZVRzVVBHaEVVREREcUlqc1lWeS8wbkp4YzhqczR5M2hJalNnUG51VVk3UEJIcWxwTWhVWm1qL2RpWlBnSmdqNmJEUjl2VHZidTMwdERSbytrbzRTWHZ2Zk4rYWlNLzFuZGZQZzZ5TmFmTE9CMVdzNHR6K2ppNXZBbm5lVEpEWVV6c0Q2NnVRZWdNWUp1RTQ2b0NwdmtnVnpLclAzRnVJSUpseUdXdU96Q2hXaVpmajJiVHp1cGdhWUZXd29KamdneklVWmF5bndJdFFBZlJLL2tvb2VqcXNJYzY1V1NvVXNweHNpT2JTT3FPaGNaWHBCR2UwWUV3SXdMdHhDVHdFRzBvT29mdUhhMEtXMWk5UUFlWlpXWlJmUmY0Z0VwaGJHMEFLWStoL3ZhUXVxV2FuUldUdnBVd3VPNndTaTlnazNKY0dVazAxdUwyMEswVElqdWsyRmpRa3FJZHM1SE9ZemRhaHJKYkNVM1JuMGt4UFNhYU8vd2VlWnBBT0ZVNEIrZ2NLNG00d0dpRGNnaXFneEs0aG5kQjVETXhOTGlic05aQnRoYXZjcVZEVlJtOXRac2h3SDRreG5HWWxrNmpTbzlLRmRZSVhLY2QxVGpyR3JyVEp6T1FNT3RoR3Mwa3pPdkZVMzJjOENIOXNHWXBOTXJEdkk4RmhKMUU3VlROU0psenFuUE1wWEY1U3UvbXhESjJiMkVSdnk3RzBNYUdRRHNMbWFncElXbFAxWGROK0pnNngxUkNlbzJiRmFPUjVJTmRYVTBoYWVtVTIwaE9aVGNFc2tNdkJTM0lpbUdxRzB1TktUbk40ZWt2dUp3cmZiOVVaV3JKWDJVK0srbkd1VlFOVjlvRnRNQlNQTXU0dG9rZGJCZFYwWTJlbko0SmZPRzdhcTdueEljU3dKVTV5SndrYUZVcDU2RENRbWFpeWY1RFBUQXRKR1lJVlk5L21ZTnFKdy9sQlpieEJ5UGdTa2hLOUZTc2xTbllWbzRWcFBmQVZGeVZJWVZwZy91TkEzWUI4MC9wTS9DQ1o2UU1jY043WlhabUh3N3FENXpobXFqTFdLVUY3eFVPM2gvYW1jLzZyZ3dNem10U3ltMUdOUjZ1YXo3UWtHNmJidlQ0ckl6SS90azMzK3RSZlBlODkvam5PR0MyZHM1MTJLRnlrUThmaWNxMHZGaENkYkoxa0F4cHdvWUpOVEM4eGI2N2hhb3FGc3pNQ1dBVXdKT2RIZkl4c2V1SEgySHFIenFmSnNkbUtMVnRvWVJONGdPSHFXSzhsbDQrVDVGS3lpRmR2WG9IeE5qQzYzY2pUU3c5U0V1Yk5haEorK25LWmJhU1lXTGdCTy9Vb1JMaXd2bXNoSGM5dkl5MFd2akgwSWw2MmpRM2xqdjRabnAwc0FhaGFyK0FKTFBvVFg4TnZCVVJCSG9VR09VN3BuSEd6dzZJbzNjYkhxUUlvTWR6TXJNODRhNHVBdFpWRnVnOUJTSS9nSkdRNDM4SDU0VzVnQmNXUHA4WGdvd0VyTDFoZzVLUklqSWg5dXVSRHRMUzV4NGNaT1VWZW14dkFnOUxtYTNES0t6MHM4NDUxUUlSVElhbGcrSStrcVdGT2YydGFpVHlxQ0phL2lyN2Y2SGU4UmF6T3lxVitCNlJjNTkzV3dnQjFncXhpQ1JJb3dkcWlQaGdmeVBUQVl1U2xPak81eDZGUlIwL053WnllbzlTb2p0a01xaGVKS2pKeVpuSXlyQ0ZuVzBQYVVWbzZzYlMxZDRPa1VNY0xNQWk4UzdxVVlWZDVCNFdMb3NyVEU0dlljOWFERU82L1pWaDdZVXpxZ3plRkRJeWQ2VVhiQ1F3UzUwN0YrWXN0aUd5S3ZuVmhCUW5rOXZ3Sll4TkpxWHRiR2NKWTdiU0liYXZKcVF4ZUJsRDJDVFZUVnYwU2FKcndIYW1oR21CalYwWTNSUTJRK015TmMzcHJ5UjVWYk1ER0R2TzdNd3F5V3pnUGlMOHdnR1N0c1BXNWh3d1o0SXB3bUJvTy96emhDZndNRG1nNDR0RkFxa1pVb29GeVJBaGpmbnVzTFd6Y2VBY0syRzI0dFNxTk9RN1FqV2xmVkNNM3d4Q0FxYlBtY0NoWGw1cW1tVEhrNG1jTC9ITDhTb0orWWovWjYzMzN2Z21Md1NubVdQcFh0YWkxRlZjNDBsK3l6REFNOFpndisyenRCNk1qL2JjVkFpVmtmYkMzRUovWTBIM2pkd2JXZzZObTU0cStzSDFvdjFnUUxUcitiZ1c3WUVmOUtuNDdUMEZVL096cHFldTlKUDRBdUtLckw3Rmp0dW92M2xuQURLQXdNUEIySkJrd2hEUFFCMkEvM01BUUpwVmwydTBaY2hPTGR4RUpKcWFla0syMFVPVW1Yb21QYnIzSlVHbDIra29oVHYzeVpXMVFVeWdha3dYdHFrK1ZNaEVEYnA3OXg2RGpPcnBTazY4QUVKVDFUTnEzcDIwdWhMNWxUcHEwbk9udXlpaWdKUkZidkxEblhYa0NzY1ZvZzZpWFZzSW9qZGN3N0pJRXJKK1drcFBxa0N1eEhaYnp1VnVrLzVJV3lDSTZXdmRRbzhVSll3bDN5UERVZFMxRzI0TVpDT244TEFkeFhJbk15Qmx1L3lGVStqQkNoYUlRbHVDTnI0RFdDZFBtMDBMeFRRa3JHME1yUG9GU2ZqTkdGcGpKL0NBaWZsT1gyNEVBUmpLTjJ3enJPeUdnYWltMlFkM1ZRS2htUS9ub1lLdmttcWJ5T2R5bU1PcCtFNmJwbHdPZFFaQzE2YWpNNmRoSDlsaldxbEVnempiOGhDbDQ5RFFhaUN3Um42WnFvWmVHYUQ1bm5oMTJIVk1OUjFlOWdjUzhXTnNXUE42ZWdQYlU4ZjYwd0JsdHF3SFdOWnc3Qlk1aEt0S2FhRU1VOGVzR0x1SGEwWmpZenY5eGFZSU0xQnFrVm5OWTl1cmdWbm9MZDhJWTZLN01KTlYvTGptNlFjQjRUQyticHdyKzJCK2JsWkk2STdiT1JmaUt6aTlidEZPZ3c2NlhrTktWUHF6TUVjejBwTFBXRm01RmJpcmVpK1E2bVp1ZGpva2V4Y1ZKUWVaUWJnaXNKcVlEVlRtQStmbm1nczY4dzljaExkTVQrWWYrTXI1d0NDZVY0SlRhcFg1aUQ5S3pMdU1YMEVnOHAveFc3ZWNOdDB0Nkp1cHY5c3AxbXFRdGpVOFpSemlBWThIOFRyWEVxZ0xvbU0xWk02NUVCZjg0ajl4Vmx5UTJSZkU3Ky80QTJjOUw5MkxyNXBMWkpJeUI5dklqQVFhcHYzaThGeHVtVDdZRVE3YjlYa1AyOHJ0eVFSWjFBL2E4UjZmOWIxK2x4bjV1N2pmMzRVSlFqcnk4SHJ4NTIvdjlWbmJBSVo1UUhMUDhMRkM2ckE3ZWI3aHVIRDlYWWdseEVNSXd3S293V2xCQnFXdjRKY0JKeUVvSjVaWnlieEFFSkRUSkd5REF5ZlNFYkptdnZQV3IzSDBuTUpBU2dvUDdDTFZxQmZIS0NtTzIwejY1ZHNmNDlOQ3pxUVYyQlFUckM3dnhCcGoxemZRenlnYU1jVFBFcURhd1VyWUR1Sk1wV2ZPOWhFWVBBUXRrTjJSdmxUd0FOOGt4Y2tDK1ltZVRNK1RCbVEyNHRHVTBtUUNwbFdKMVlreEkvSEhqQnU0YVF3ZUE4TURXN3ZYVndCblRrTU5jZUpDN1kxSFdLMFlaMDdKSE5ETUU4ZURUQVBqejVNcGdpc1ZWSkZTSlhieFFIQW5Sd0l3dUZNN2c3NVlwZzNwWXV1Nk5aZ1h6SXB5VXpVUUlzSVVmVUcvaC9FYjM2ZVBEMmRBVUlqT2RsamZ3ekNPMGJ1T09MVVd2TXAxa1ZEeUVXWU1DSGdnamZMZHlYWUpsV21hSG5tYmRzTXVSWVlDa1dFYkFsU0NkaTUzWUZhRjNZQkdZQXJZa2RqcG83c3dFb09qTGJ5QTZNRzk0a0UxRXA3R2RtTU1iVC8rdUZmcHFvbmM2MlU0akFuOEtpVVlBaEtaS3JXS3VUVW1POGsrb1dvbjBkYnVrMU1WeGxXQzJlcUZicjhqUUYyRFBnSFVTb3hiWmpoZ1hES1lCcGpYRUlWT1cxRXZ5OGF6QXB0WVBKaGJvd0xjK2FzRi8vUnIwNVZoRWVOK05iYXFadHB2eDg1MkdQdWJOaStKUy91VlRIMFpOWEdHdE4zdWROWXhqeVVrUFNNSWhHa0ppUmJzaUUwR3BWVklNT1pCL3VTR2hFNjJ0bVdRdWd1ZUVwZk16R1NXOXAwSGdvRkh6S2cyS1BBN3BBNjY3b0lwN1lndmhoNDFvNG1ZNDM1UDVzZ2wwOXlZZ1VKVks1aUM4d2dlMVdoUERpVE5FazhzbHRBZWEzSW0rRUJjK3NQTGZRNGtpRStabGJqcW5BZkRRdlVYYTJXTlJxL2tBR1lkb0xOOXFZanFBUFJJY1M2RTRuSEdIZHN0R0pCNEp2OVNhSkVaTzBhZFk3MDNmSzI0dDJCMm52TitueS9hS003NVdUQXZ2L3ZuT3p4cS9WRThWSHpuRkljTlpwN3FoSW1KbG9sWFJOVDN4SkFHSk5SWWhYbGxFTG82dmsvRWZ6dE1NUGVUcGpzTllyZGExUlpCNTV1YnlUNDZ4ZTRQTnE2QjQ0VGNqSzZtUDN6NE9mNVZlQnhqZEM1Vk42TTZVdnR1Y1NZOWM2WS92VURGa1ZrU3lFM3l6TjRhS2tmVkd0VllTQmRMZWJBZENnenVibE5GeFIwbHZPbTdPdWdYdU5GRWxlVG5EcldsNHlmNjAyZWthSjZrR3JCT2dMSFpCTExYNEQ2eFJ4b3RvVnRDYXRzREljcDhhanpWZndvVUNSdFc3SVR5U3diaHpxa1Q3VW9Ya2hhR2F1SGxSTGoyQ0U1WGdHSnlSVlpockQxRlFnMTlIamhxZDRuVjJzbWtUZjgxd1d3YXNOSG9HYTR4T1ZRQXNpMkE0YndEbU5Mbi9VZ3R3dXJFVkZTeGlDaHBxWGJveTdXcUNrYS9ORFpiaGRoMzJ5OTNDSlVxUkZWbU0yeUJkQjVibVV3ejN5TURGUUd6eW92a0UvY3BMY1JxQnZNak5RM2pqN0FnUG0zSnRyVXZpbFQ2NHNVMk5XUFJwcU1kVGR1UkJLZlVvbHRERTlKa0VCenZra2hMRUtLTTBMUTBNdk5CRnFUUkNYY001MVBUWGt0SVY3d21KTWxZU0dHbzdyeTFrTnpSSEZpYjI0VDc4Tm1Ic2IyNXdpSkpyNVVTOFdHUGZ1L0Q1Q3dScjROc0YvR1hlcEt2NEU5VlIvQnlINmxvZXJwSlpjUDdJeTg4TTFlTDAra1dqTmlkU1RPc0t1M29Yc0VNQW50d2c3blducmNKNDdWOHZITW1BUmtiSjVWYnAzQVZLZFNJQkNBTG5pT3B5Z1NCVGJnMTBJYlNWenlqNUNQRENpbko5cUVkQ01uZFdPMDhrWWVMdVJITzRhZ3BMZUtpb2QxSHFkZU11MHhxekNrengveERBNHpURStLWXVPdXo0bWJFUElLRDJiNlV6OGRpNXp1NTFlL0JiT0lKMzhOSm5vc0ZqamJFQVE4WE1OQXJmdnVNNWhSaDRPRzlCVE41K2drdHFUWks3MXM4SzU3WW4ySW5NL3JGczdibFVZUUo1ZmM2aml4UnhUUEEyZC9SYjlvQS9XVlkzdlRWZ0cxUUZjZE9PUUhnV1I2STV3QzBQdzEramZFQk1GZUgyRm5rT2FnQkpGYlVWQXFoeWd0NXlLOWV2WnBlZWVrVUpad0cwcU9SQnhHUXVyU3dtMjZNRHFmRFE2d1VUVWZUMmZPTnJHN3pwQjJaU1d2enMrVEoyaU9YT1dFYkZGejQ3Tk1iNmNiMUNYb2lFdTlRdGFTWmlpaGI2ZDNmZnNwN0tlODlzeHdTUUFlMXJDcnNDTFdpSmpTekpkeWlhZ1Rkbjd0d0FxYTFST1hoUmJ6a0lUalVnblZXK3V3dGprRVZxZEh3SkowYXQwVUlrZEhCQVJTWlZCQTU1NFBaaUdpTVhXQjZoSk1iOThyRWhLSG5sVEsxb2JsaXlyUVU2MTIxRE11UlVIUVVyY2R1MHNwdWxPcWJXL3hLTHNaUW9vVmtUMncyRXJTdFZlMFNpc0pLYUVBMFltbll0a3hqb21ybVpwcTdTRlVWUzY5cjI0UEo4TTRnSEhacDExR3IxaUIwQzNLS1FFb3NZcW9TV3hQU0Y5MEZHWEdiWUlJM1VKMzJZcmMxeDBqYWR3a3J4SHZiNUg0blh0dGFacFFpRmFvMHRyVjlpMUl3MXk1a1lyWTdmVXFSRFJqRVcxRnp4QTNIVjRQRW9uZTIzdWVOMk1SV3NkMzA5WFRoWE55THdaNXdMR3I4dVh0cnlOSXFDNXBTWUV5SDhGVjZLUkUrQkE3cVJIcUk1MXBnV28zMVNMSUg3dzNWRDhaZkluVnpOV054MTNFWE82YytZMXZBUWdLa2U4Q0ZYVHZtUlhWY0F6cE5SdDFDRGUxdThNZ0NuVmM2UTUrWk01aVVsWjBsWE5WaGxocmdYSXAyNFRqMFM3KzVadHgxd0N2VVQzY1U5NEMvS0tLMHAwdUVqTjkzK1NramtwRFhhVk1wUmtwVHRaTW9wYnNhOEt1R3hjdllRdWRBT25UcVJEQjRoZVFXdUphMUcyZVJRWEZOZGM2NURLTTc3NDRkYnA0dkdJbmpDUWJGTmZIVlEzeFZJdnIvNlhyUDc3aXZOTC96b2xCQW9aQXpRSUlFTXlsU2lTMTFubFozYTNyYTZ4bnY4YTQ5Zlk1OS9OZm9EL0U1KzJiWDl2RjZwOGZUdTlQdVhjOU1qenBKclVCUmdaa0VTT1NjQ2dWVUllM244MXo4Tkh6am9xQUt2M1REODN6dmsyOHNzTkFUaDZJZCtWaVdtQXc3NE5JTVhEeExvU1R1STMrY0FvcWc0cjBFSFFOY21jWm9oNzlyYS9QR2ZzNzM1UXZYZWEzdDhCcXZMZTRWSjUzK3o5OThlYTEvMERlTk9YM1prTkRCR1dCVlp4bVVFWXVqaXNNaGNYRmpkWEZYUGtQMzdiWWlPbmNqWHRIMW1RbmdheXVpbFFUOG96LzlNWk96bnQ3LzdZYzBLQU5nRDFVZDY0bE1ldEl2MWg4U2ZNaDJYcE9YUnluNFA4NEdCVlcyaXZvU0w5SmcrdnlyYWNySnpES3BKNmgvdDRoTVh1WnB4K3lBM0k4WGtWMVlxRzRacVNKSVd1eUpTUkwxTGpFclJsS1RFb0k1Zlh5Z2txNWRPU3RsY2ovcUdzRnNUZW9aclcvcjhZSm9LUCtCSVkyVkYra0VrTnVuNFh0N0VBd2dGYnZ6Mm4vNnlwQkgvL0owTWpIOG5JRUpWWVp6RmRVRDVEbmZRVlc5a0JtNllSNUdGQUFCSVBCNEdZT2tMVU1qcnlFQ0Zuc1REeVVHQWNpd2hFNGl4eXVvV05aRjByVmJSbVNNUUZIbXhMNXIxTFdvblJLWEFHaW9nSEZqUnA4TFdLN2syaSswOVlUQk9NQWoyMVlFbnliQVY5UUM4OUY1cFlYSVpEemFaRkJ0ck5nU0N2MXcwWkZweFc5ZlJLWkV5V3dKU1J2VFBqVzFRdEptVTF6SFpIQndnSzNhaHRMaTBqSU1hYmlDcVN1TlZHa0Mza2dwK3pDbzZoSW9GelJrZGRVRGl1QVowVjFoN3QzUnlFWFN2UVp0cjg2RlRzN3BZQ3gyeVc4c3MrOWlOMVVqQm9qVms1Nnk2a2JPSnJsL1J0M2JCcHZxdURKYVBKc0txRWc3T1NhSWQvSXFIVmNsSHhjb21kc0ZRMmxvaUxDSnlQVlU0Z1pjOU9yS252N3RRWU42OVFRcXdjelFBa0ZZVlZCN25tRG5Yb20ybVdaRkNJTnhXVTJjSnZLTjl3Z2dRNFhYWUwvTFFtSWVvcDVXSlRMYkxhQWFZcUowcXZkYjZkWHk0VXAzcXEvY0lZU0JNTXJ6bmNmdzRwMTJPUmJTb01Ua0lxdHdwTG5EZVZJcjhuZGZBcVAwN2JNS0tVZ3k1emEwazdPYy8xUEp4ODhaUkpUaUJOWnNvaEVVQzVEeG5vVU5LbWpmQndQcDJpbkZGdWs4Tjh0MkNyMjBnYitRcGdRckR2N1RjekxvY1RqYTRKajQ4bmp4anRlY2svd3hMblNXR1RnbVExdU1SR3JqdEcycE0zdDlZWGdOYnhOWHFrNXdWaUNscTJxMUc1YzFxc0FlWHBZeWh0Wmg2bVhYaVI4YTNqc0g0V0d6QUN4WUs5UFV5bFJzSjY1cnZRZFZybVh1SUYyY3dGWkZFRUlEaHV6dUcrV3VMZFRJZXB5K3k3NTIzZVJqSFRRM2tVcUFJbGJtUVR3b0RhU2xKbnZNYVo5cVk3WHRJT2hTRzQxVkg5akRJRFdvVGI2NGdlY1JsM21GMzRjNlNtbDBZQ2hWMkE1ZG9sc2dRZGJvNjlFSm5vVzlZNDE0bWZ0VEc3RnBKcGZUWjNyRzVEbHBUREc5UFJXekdZaVlTSTZIVWZhbGdSVjRBalFZUTVuRExhWTZVZFUwdG5iRGtMcW5IVnNPQTJyWTNXaTNGUnM2a2FpQ1daQk85eURtSS9PbmtLU1VMTUlMcTFSSGcweEVkY1BUTnRTUGtveWc2Z2NCeXBBU2lNemhaK05uQkM0OWpJcndNcFJSMm9kY0d4a0JqSzBNcTlkVlFHNGxsN0dNSkZGbTY2eWdDZTRqRUF1STJxNDB2RnRPMnRDQ0puWVdGeXlEVEpWUzY0eWJvQ1RCQ0pLalk2T29ZVlJGUlZKZVlaR1p3RDJ2eEcxaFBEZUVrTEVrY2xVZ1FWb1F6NVZVajZsQlZXUDhVY3NjR3lTcEhzQzlFNGxVT211ZytqWllIUHVvRkZFTmljNTVZWTVjTUJnbm1WRWlWOG8wM2s1QTJhWUNoZlhrL1UxcGI4U1lMZEtmRENWUWhTMFdZVUdzblhBU3ZaZm1hTHBZSzNsNFR3R3ZoTU5BYmN0cXBDNTBOYVEwMis5Y2E5UFNveXNycXM3TDhBMXNkQUdTeklWQUlMd1lqTnBBUTFBS2N6ZHRJUUFTQ3I1U1hBNndoVENzY3VGOVRSK0xNc3F3V0FXTlFjZUdhcDgwRjdZaHJnMlBObjJXVnNObXhIT3lCS3lrNk14Q056VGQ1M3QvV2QvNWpUOFB5TDRCQ0xSYnlZalB0dC94RXRRRWJhOXpIS1F6UHhldm9CUHZlWHEvYVAvWDM3TnQzSE05N2l1T3gzc01TS2pEL2w0Y0wrNlRWZEIvVWpXOUxuZ1FQaXlIWjRHTFl1SzhtQUhMSUdWOUh4cElGOVdmUldrN0lIb2JjMldnS0Q5d0k5ZERqS0NJNW02SVdXNUhCUUVZZmtEdVh4ZWkvNjkrOVF0U0pFcnBlKy8rS0ozdy9SOCsraFhwRG5pcWlGZnBvQ0g5MkNWdXN1Rm1zMWxMWDM3NUpDMnlnM0dkbWxjcjVJbDk4KzFiN0FiZFJZa05kalorL0RodDdDelN5UjRJNlFRcHBRL1FRaDFjSmprVVkzc1RLYWJHZ0x1OFZXR2lYbGFuam1Qcmt1TlZ3dU5ZUlFjd3JXTU1TV2VVMWFtZDBJeHJWMjlSY3p2eExOSklZTUlxSlhwSGlTeXVVOTJVamF0RGhJOFZpWHM2RW5rRnl3TWZnOHZjUmYwdnhrbGJrZFNnZGlManVzcWFiYThLS0FHcGVybmFocWRNTUFLT0QxQ1hWUUhUTVF4SnFWNDM2NndBQ2llY2YzU0NsTVY5TERNQ2ZXYmdZc3hsNURJMXI0eHZjUVZYK25JeVZjT1V2cHhjejFIaU1nUkFSbkJkaTNuaUdxWDdFeTI1dEE4TTlBMXBBTDFaZ2dkVVRYTnF3cWgySjFSN3dFQkhoZW9KRFlvKzlaVFlqQlRHVmJwcUFXekFIQzVYeFdFeG9yMjlBTXpaaVRNd1BrUWU5OE0raFBvanFTdU5PSTZHTGxnZFlBL2JVNFZLRFFOV2M4QlFYcVBlL3o3TUxvajFxRG96dGhxeXJTZWwyOTVnVGttdmc3bTBrUnFzQldVbEZjdmcrQ29NOXBhY2NWNDZLTFU5UERSTVRhMXh2STNFc1lGeTlzM2NXUFBYNUZwanI5cTVweUR0SXFVVUkwZ0tXdnVBYnhsSGcxVWVJdHFkOXBraUZic3JBVzU2ZHkzVG8wcW81QzRQdVRqRXdzU3ovRTJwMnhRd2N5TmhJZHJvdkVBRlRxNlR3SS9PbzVMSjJqb2JCUU1ZTG5Tc294R1NZWUp4U0RVeGlrcnhTdE5PSUhQS3ZaMzNiRnQyZkFTa0xBV0pzbDRYVXBpUDRmeW9pK1Y5K0M4SG4vSmIzRWZpelcyTUJabmZCQS92N1hXaFNURCtxbmgrRjlpS1kyS0RmejVMTE5FaDV6a3VKb0t2RHhNRTQzeWRCWHozMlNGcGVaUm41SGJtdnZpOUFLbmlHUjR2QzBRaWN4UWJrNkljUEY0RzZ3bk53bEg4eHdCcHJBMVZFQUsyM2xTWlZWNmlOSmVydjYvQ2hnT1RGT3JySkJWaUxUWlJ0UVNzeEdXSmpVMk03bXRzZ2xuamN6c0cwUTVXeUNxZmU3QTM3TXpQWU5BL0ltNExTM2dycVJkYzUxNTJXeHZ6ckx4bTFwZll2bnc4TGN6T1k4UnZwNzcxMlhULzNsTjJaV21ra1c0TXFPWCt0QXl6TEcrdkJVUDJ3bXc5dU1uTGJEN2F5cXE2emRZd08zaXNyQmZmVm1YelVMWkZIeHJ1U0crUWtQMGYvK3BYYkVHK1JkMGprbm9CamFQOUhmcUQ4Uk1DUG1SZ29WZkdBTnNDaEorMy8yS3dHV2duSjFZY0pzMlgzOVdqbzFZVEY3VXhMckVSS0pObFZyOWhETnFiM003S0hZSXNHTmRPQ0liRXE2VFREcUNLQ1NWcUJqRjFNTDVTZ1lTUjd4bVRKdk1qZmRrb21WZkNrYUNjZk8xa0VwUmdLUUdyUnRTeEF6bWhTbDVlcjlSbGFJY1I3SHEvQkE3dEhDMHNIakk4Sk1hQ2c2cERuendQcW9nQVZpVXlhMHVaVUJ3SjRLVEp0S0pHbTFhaWZhT0VPTnZCZmRxUVFpcEtJakprZFFpVkdORGtITDlycjlIcnRvOTBvVFJBaXdGR1ZEN3RXdlNqdjU5STlaM1dOTTl2YnZ4cTFWTU4zMDN5K3c2b1BpcmQ1Y1dVMmxiMEs4STRBT2dqQW9pVlFzMThxRmFsWlppVmZqbXUxc2x5MGEyUmwybEo1K0dSNFFoakVBeFZmMVc5cGYyd3E3RlFNSUxSbHNoaFpJd01PbVd3R0JjYXpMT2s1UTVvdDBUMGhkNC9FNVlkWDBORDlCenJVSWc2WTlDMTQ1SzlmdkFSNENiek9UZSthV09zWW8vamFZeUZhdEVwYURrdS9MbFJxalpERGZ4aDhBL0pPYyt0QzFXb1VUd3YvZ1hRUWFQTWZUQy93eDkwSXdENlBCY3p1RmhzczdYUXJxTWYzM2hUSS9DbE5HajZRd2FlREVqK3JqU1hnUWdwSGJxZ0M5ekxWWTh4NWw3NWZ2bSswbGdCUUQ1WDRQSTVHY0RvdUlUQXMzVzAySVFRa25pM1NUNmpBS1pvc3dOeCt2SVpNWDU4WjZOZlZpaUluVWR6STFDVEh5VUc5VnhYYmUwWkp2MjZCWHd2Uk1WWWhMcG5OUFVBVWNONzlhMDBnb2plamJmbTlUZGVUZi9yei80bG15TE1wZi85UC8wOHpSS3h2bGt2VVJmcklwNmk4WFR2NFowMDFFMk5iNEN3Q2lHTnM0S01FVGpxRHRER1dBMnhWTzlCZ0hvUTI5bEhyeE5ieGVEd0VHVkRqdE5uNUJXT2p3MVR0ZUdIc2FyT3pFeWwyNisrbFNvbi9lbjkvLzR4Tlpxd1gxR0RxNHpvWElYWSt2RUlUWkkyc2tTNWtoSUVZMjViS3lWVFRrcmRlSHU0UCtyR0JxckhCbVZSM256cjFUUy9NRXYxZ0dYS29FRGNaeStsVnZhZ2UvSjhJVDE5UGhlTXFiM09sVmg4Z2hRWk9abVZOeWpCQVkzZ1RNYkxWWStSNUoxb2F4SmVsWHJLQUdxb2c5cWNJT3BPak1wS0J3TlVzbER0VWFWd2hlL0M1aVdCWnREVFo4bUxzZEtZTElGSWxLclFMTFloWVVDUG9lNFkweU1GeVBpdTlwNnppMGRMUU11RWcwUW5yY2lTTGxETXJZU2wxMGtRc0MyZUorTkdUcUcwQWxFcFhVaFVTbnBLSEVvUWpXM1VQMkxuekJPMGVDQ1gwamRyY1hHUmRqYzh2TWZZQmQyMjNlUmRwUlhJSzQ4Sng2c0FrVkhvVmtJSTVpQmNJL0lVQVV3M3I5RGpwcjJrRllrOXZIVVlzMDErdHNTeUlSRlZRR3dMNlZ0UHBReTloL25BOFhKcGhZY1pSNlJQaEM5dE90cTZWUE5NTEI4ZEcyRVJIUURyQVhqbXl3MHl0RWZaZisxWDl0V1FEdFhJaHBJajU4aEFsaTlXNnRQajVlTHU5UjB4VDZyS3hyUWg1Ukk4dThkY0svMVpEVmVhaU5XSHQ4ekF6QjNYT3o5ZDJLZmtzYXd1NXZnclEwTzROWDN3SC9tbXF0clFtN1l0dDdCdm9TaWlmT2NjdG1KTGN4SHpYdG9zclZYR2tzRnZ6c0FwUUFFeTlzZjJGM3d2eU9YUGhjUWtmME9wa2pYMG9FZGZFb243S0tpSXpyUW1BNWduQmNrN3k5eUhzZVptMGt3QkpyNHJjYjBNV0xaUjJ2WTN6My81NVQwWWxQaXB1SS9uZVEvdnBUVG1kLzh5RGVkN1lNT2k0VGFRd2JIRGJnamdCVEpkOXZReElJeldNVVplRTFBVitjK2RHNHM4c3ZzUDc2VUJndllHUnZpREtGNTk4NDEwNzlsVStpLy81OC9UaDRRVFZOamdrNDJjcVdHMW5lWi8vVnZpWVNpcVJrMGtkeUl1c2RmZUpBQTB3SXErWDZzbXdtUlNsNm9kaEdnWjNrUGlrZXBNamtYYjlsSFpsbGRxNlJ1djNXTDdxMUZxcWQxTnQyNE9wSi85eXo5TFAvK1B2Nk5VQ0p0bjB2V0tZSUtLaHhrQ0pJYVJXTjJiTUVpRnNpRlZWdE91THJMNTJiSGw2SUFvYVJobEJXTXIwUmRwYWhaUVFxSWNwRlN1dHEwMmlBRFNaV1p3djNPUFZrSU1IQ09uelVKOGprM28rSTRUd0NSekNGVGE5YlNGS1A1cjB5aXFOVXJ3alFaLzlSNVVFeVFQQUd1Y0RUaDdrVXF0TTJVdEorZVBvUXBDakJXZjU4U0VjY0FWWE5WRmRTRUNTM2xYTmRHR0ZRWlpwRlVONEFZeUJ0SHdYbUZCY1NOV3QvejZldEloQmlXUnFNM1BJcFFsQkZWbEpDTVlMU29TQUFvRzEwWnNFUFFRaXlIUHFTSHBDRkF5VmdPYjVHNGRVQVIwckZhd2dWMHlwRWJBVnR1YThXQ3U3bnJJUXZnSGdLUk4rK2w1TGRTRXdwd1RDNlZoRzg2NWRyQTZkYVFzSzlPTjhmeVlQcXBHOXhPcnRnWFRhbEIzRHZXcUNiemFkMVlJOHBSbWxYYTBBeG9xNFRsS3NZWlNLQTBwZFZxY3NJKzVqWlFtQkZRWEY0Mzc5azF2bkt6SjBBQTZxdTBZMG1tUDh5ajNHdEJhd3lQZFJQcFd6ZUVLZ0p1MjBZRW9lY0xZWjBrRzZ1QTZReVdpcWdmMDRJd2FYcUdCWDM2MW1LTWxtS3dNYXlrZ24wd3JnbkZOalRGVXhFVkdpU2dxalVCN1NtR3EvcXFUSElsbmNZdjhiSGhYeVM3VG45UUovekwzMG1yK0RRaHlzWUZHcGE5NDBZN2djNzVuYno0MHhETmJBVW5wUjJBSjJEdzlYeHVaMHJjU281SzZhckd2QW9CZUJwT0N6anp1WjNIRTgvenNLenVCOHUvaC9lUzV4Y3R6NHRueUZIL3lsL05RM0xPNER6M0pTRm5vcFFjTUF1S1VQeU1KYVpSRnV1Sm1VZk5hTlpFR0QyandacFcxbXFXYlp1cnhzR0QvLy9hZi9qUEdiaVlKNDNxVFZhTkdhWmc2RXp1RXVuT05tS2pXbGpPQXl3YjFzQllaUjVKYWErdnNMa0s5YjRobWo0SnBkVlpMamNQdVhyek9kdlQzSHozak9NWjBybmN2dXN1WEwxRmNiUUhiMVNHMnJxVjA5NVAvbG1hcER6NUs4T0JaY2dqN0dBRFRkdW9BRFlKZHFLR3psREJodmFiakxhelNHK21yK3c5Wm1ROWpVOUtCc3hkWXRWdlQyand4WDFjdVFMd0hhWGwrZ1ZDQUJZSXJ5Mmw3RnpVSEw5MFJOalZJSkZhaEhNWHVFTEVpK3l1VDZESGQxWW9TcnRwUkg0cXhFOXlSRThKdUl0QXBDaXRoRFZLT1Z5TzdrbzViWlpXVnZBZ0JzSWE1cTVKYlNqbFpSbVZITEF0TUZMWUF4dFlLbEJLTnhHWDZURTdhOWR3TWxvS094bjdtbktuU3htVjRBRUFBQVhRaFZVaDRlcW1zQ2VYem5XZkxveVRpMndUWm1IY1dEcGRlVjN2YjdPK2JSSnp2b3dMdFlIemZ4OU5sYk40QjgyWFZCQjhtZ3d0UWJhamV3MVpWQ0NNeEN4T01xMlNnOUs2S0ZMdGM4OW1OVTFjQkhJTjZWZjBFU1NWN2d5ejdlbERqTUpUWDhBcXFscG8ySk1HNm00empvZUU2Z2g3NTdQZzNBbUJnZjdoU1kzbzRNd0JyVmI4QktqS0VSTVQzWFZSTjdXekFRa2prRlNUM0FleWpla2kzNmRQbUpyYXpXS0R3bGdva2pFMDNWU25hQUhNWFc3MkFZZk5oeWs5d0tCbTNGWE1JMkZrMVV5K2dwaElwUWg3TmpKcWwzRkE5T2RKZ1RoelBzaDVLNWxwSnkzT3QwT0dtR1VwVmpyeEo0dFkxVSs1Qi91V09NRDVOc3JhV3pwbVFyTGhlWURJOUpxdFhRaEdBdzdXT2hRc2ZrMk5QVG4vM3pxZnRZbDY5UnJyeTVieDdwZ0Rrb21lN2ZJNzM4THVtQjErMGxuYjZYSHNwMEdlc1VCSXJKQ1YvdCsvZUwvNUpqTHlVbkcyYll4WjM4cUc4QXFENVhBQ1cxOGJDeTd1L3hUbTgrd3o0aTdnYkRwd0NLcXduL1hFZ1RvUkk2Smp3WEdLMUd4dnJJOFhtR2p1bHJMQkx5azQ2aHkxcEM0Wll4OTVrWGFrVDFJRi85WmQvU1h4TkkvM21vL3RTS1M3d2svU2Q3NytPZEhReHZYaDJEMC9namJURnpycS8rY2ZmczlNd2hkUTJLSnRDMWRBZGpKcFdqeXhCK0hhSUpyTzErbkk2dTNZR0lsSktvN0FhSW51cGlUVFZ0cDIrOCtiWnlGZnJJaWZ4M0dCSGVxdnpiSnEwVWdHcTBPT2RsZlFaOWJmdUxWRG1oQlY4aTRsUmF1dUY0STlQa1BwWU1aNCttMGxENXk1QjBNTnBEUnRXbzA3SkZGYkRYb0N4MHM0ZWYwUmJTN2E3bk51S3MwQkFadzZSRkpnZzNsMHB3NXVCL2NZZFVhSTRIVzNYVGErOVNpbktvRTZCYXBocXFXZkdoNk9jU1JmUDBCanZwSGl2SnUwNk9VTGxJR0ZTSXBZQkJSOUw3bktZOHpLeFNTVGF0T0k2UU1ESlV6TFpnT21WcnR4d1FZTzloQ0NST00wU2t4SUxITXJFY3ovTzk2VTByZHJvUmhRUmtjMTg3NUR1c3NtY2FxZnFIeHhGdGJQcUE1NDBKTEpkSk1SdEFNVDVjUXowbExrWG4wbkxpdncrektoOHR5WlQycmhNYWVmTFo5bEhieHlQTVNEV0FZaG8zOUkxYjYzNkF3RGlpSHkrYlVCUUc2bWdYa2MxZDBlZGtLQzRYeXlVakxGSnVxckxiZ20zenZPTWliS0hUZVpGc0M0QklsWnV0WllXajJGdVNQRmhzd21sM0Noa3lQVkhMQjViYkVaUkEyd0Z1eVBNQk83azNJRXpabTcrS2YyekpyMGVUNUVJRHloUFVBckxHUU4yRCs4bk5ldk5KNHk1WWV5VXBrMFpzdlgxa0tCUmh4Z3g3WUFCWER4VHFWaTZFM3pETUE3aktqbnhJTnJZRmVjcVBhbWErYlBYV1V6UU81bDlRR056SlFqdTYzd3J2UjBDSWtwRUp5eGMyWnhqV0FGdHNiOEJWRG8wT0JlUUNRZ1NtQ1JZMmlXZkN6UVpXTHlwWUFlSThYREhVZ2RUWVdTWEI3MnZ0T1VyZ3dYb3dLSWN3ZzF6cEZOQ2Vjd3dwK0JaTUVQMW41OW9ZK1lQSFhTQ3JNRGpvaFVoRlp6UGdOQkdua2s3NDVpL25iNEs0QXBOajJ0ODk3eG9nMjV4bmhvRDV2bmhlV0RTeTY3Z2VNNWNMNndkcEFlaWoxVmdqSFNLN1kyVmtMS2NoQ3MzYmxDMy9XcjY2TE5QMDk4VGEvWHJEejhMRzhMTzJoNVo5TmlyT0dkNWxhRFBFb1hJMkRTMVhsOWhwWGNYbmZIMDFZTm5yQm9rT2pNM05RalA0TU5PSnFLSzRmMEFLY3RWYXdmVm80S0VwVzFHSUxVV1ZHdTFrYTVScGZKZ0grL1MwRkw2NCtjcjZXaHJKczNEYkowWUR0ZjRXMkx3RituUER2MEkyd3FvSndQTDRLTWplTG5RVlQvNStBdElBN1dSMkt3VllyaGFpQVd5anRmMUcyZGpNQjlQcmFVdkhyRlREN21LbG1yV0MrcXFyVFJnTUtTRUhiWUlnUGRZbXhFY1kzODdVRS9hMlZTMG4xZ3k2N1FiaEtxS1kzaUM5cWE5T3JNcWs4UHNFckI1ak1mSDJPQUFPbFYwcFNzbkxVUjVUZ3dweFdlZFNob1NZQVNGQWpLSzZ3S1ZrZklTVXN3aEJNUHBQb0w3UUV5eDVtUHY0bngzM1phWU5DeXJWc1pXWXdBNXZZcjIxZGhYYjdQMmd2N0tXSndId3lrMTlocWpoQmR0SGQxOWhYU3JsZVcxa05Sc2J3MkhpaFVZMm5CcDZXMDlPbm1Cb1p4SkJaak9FRE4zREdoMTBnN0xFcmNqZ1hVakRSdGZaUXYzYU5NMmtrMXNRVSsvbldQVm1OaTR3M0dSOFdJc2xMVVlHeGlnaEJTbXlpKzRHWWNucytrWUNJS1dlYml6S3B1UzZCN3QzOWxieDY2Nm5sWUJQRE0wMmdVZnBGaUIyd2h6dDlFeTU3VWJHNnFoSURLdXdLaTA1ajJObzdQdE1yempickJzUko2em9MZ2hhc3hqUEpYdkxEd3VLcHdjSUpKTkxsd0hXQVl2TTBkS1ZsRWVoajVrcVpPb2U2V1B1Q1lEVEphaWthOTR2a1p1bVYyak4yUVc5QUdXMFRaQUEzcDBUWXA3MG5lR0ttaUNJV0FNc2xRa3c0ZUtDWENFeWtqN2JGZXVQWllsS0o4ZE04TDRCdUV3L2Q1TFFQYWZQNFpobjRXcEJkb1FvQUpvQkU5T3RQMDU5Q0dyYzRKaXZMajBhK0NKK3pnMG1hYkRFK3Y4bnI2S2F3VE5Bc2pVREY1K0FkWTBpWHRud21BQUVVSmhJWkNTTkFTa28wNk02UU1EckpSSVQ0M2FSdnJ5czJVSWtzRUFBSzZjdjVHT01KemZ2WDgvUFg0NkhmYU1Db1B4eHF1dnArZWxPYjZqNHJCeXpVN1BZOGk4Q2VnUi9JZWErR1J4TmMyU0ViOS9BQ0dRRjFpcTROS25mbEtVa1dGUXg5Z2xSNC9lelB3OFFYU0RFQmQ3M0szY1M0K2ZUYkhKNW5UcXE5UUFQZkxDdWxFeDJTL3VoRFNjanhacjZRRkp4Q013aDJyb0JsNldReGo1aEVrcnMxSllwZUVBYVdpVHV0M2FJbm9CM2hxN255aG1PK1ByRkdNenN2eTFNNE1ZK29rZDIxNU4zNVNiajJnQUFFQUFTVVJCVkxvOWlWUjNsQjVNNHpra0Y0Nm1NVGFNRC9ZMXdjZEpGRlI4WjBoUXZYQkpVMkpsbjFwVk9pTU9qOFlwQlQxQlpRRHlIN0h0TU1oTUZqZWhMVTVJZGorandpQ05xWXA0SDFOUVhOa2tVSjhXb3IxRUN4QUtrQ1hHVU52SkVlclpNY3pSZ2MxRzZVRDdRSlN1b1cvR3lybEZsOUtRVEdadDlxMnRkWXpLTUEzRVlBQ3JkelBHeXQxNk5GNGJKMmExZ3FtNTFYVG5pNGNSWnpUSkhvRkRwTEYwWUQ4NmYra3lxanRicnkxOGx1YXA4N1Rybm52YUYyRmUyOWcvZ2hwSWlJb2xyUzNUc3dFd1BuMCtBekdiNkQ1SW14Z3puaW9nYWRNWndGSFQxMDI3QUN4d0pZaVkyeURkc1cwOVAxaFJOb0o3bVQ5SFdoVlVCaEl3WkxZTTlxemNvWWJqQm9GeExNVmpmWCtSd2NxMHFyMHpTMnZweWZSY21tWjNwZzI4eFRTQkJWVjdGd1g4QU9GQmRzWHBHUndIdkpFa2tXcUZidWR4MjhoNHhseHd0MUtHSGtQQlJlbEY4QktNZDlqK3k0RFZzTGV3RUIyS0pvQ3RER3BJaWRmTExHb3g3Vnl2T21yUWJpd1lMWGhDK2QzRnlmNHdBTHhEVHdBUUVBQXY4QXgrRHhNQnZ3akFKV2hJcVZISlpJOFVMck1rM05uSElPWGdZWUdTRGdya3NYbXZJKzQ5SEx2VGRrbDNrcGJnRU9vYzU3am9Dc3hDak5FQ3dGR2NvOHFvZVVQcUZtUThoNWtJZ0JLa2ZCVWdZNThObHlqQXFUam1jWC96Zk4rOWgyMXlFYmE1c1VsSzNDbmZ5M044K1Y2QVZYR2R2eVBCZWlNL01yRGN4R0lhMnBjdVhCZ2xuZVpWR0pDTkh2R0FYTGw0Z1czTWw5UDg3RXdZMHVleE1UMTgvQ1N0c1lLdEEwSW13UGJKZUF6bU9HclBCdDZaRFhaWGtVRjZxaU9JaFgwa0pUOUhEV0RMcHBsRlFoallOdW1JUGVuWVZLS2JpcEVIMUNZcVFkeXRvSGNueGxuc254QmhlM3A0NzNINnpyZmZqbnJ3K3hESDhNajVkRzYwQ2hFdXBNZlRIK0dGSlAxajRrcGFic3l4Ty9SNjJvWWdxb2o3TFFTYXVncEVVS1lGOGpBWTcrTnRNYUowaTVJang5Z2c5a2wxMlFkRW9OT3dUK2lGZXZpa2djdVo0b0xkRGk1OVFaMTdQa3MxQVNZcTdEWUVyVG9KTWxjNEtwQXFUc2M0MUJjcnN6clJkVHlUYzNPenFLMTdNTktsZEo2S0JYcXdBb2k4bUJjeUUvOVR5a0xjRmJDWVZPMGJuTVF4cFRLTnIvSUE3OHl1aEJXR1VRRE5CVVpDMHU2UmlUUWJLRlhSVkZ0a1dtTjNURExlb1g3VUhuTjBSTmtacDdvVENhVUxGVXJKdVkrSThVNkFTdld5Yk1VRWJGTFJCKzhObVBYRDFCMFlyVWRKWHFmRUU5NDc3RTJBWXAxeDF2TlU1MWw5MUd6dkpHaTNuZkNUTXA3YUZ1WlJlMW1ORUpFWHN5OG9JVVJjWERmZVhwaXRqR1RUeHZ5b2loalVDV3R5UFNvY0U5NEt5UGJvRllUK2xPeGtPc3U5Q01iR2JPMVFBMTRibWd1T1E2Z0VvVmUzRjV1cVNkWktzcW9nT2dLMjZlOGN6cDRIVS9Na3pWT2VtMkhWSTlzTlVCcVl1c1MyWFN2cmJFZmZ2Y3FpVFBROFNkTHVhbDBWWktDYkp1cXZsVjRQaUErMEhJOWpKY2hyMzVXbUxYWFVaTUZRZ25YaE9ZS3VEbG1NR0gzYXozRStSWG9QWStSc0s4MlVpUWM3UWlJVFBKd2pTRHptVVVPLzUvbzduZVB4QUR2QUszQzErUnQvcllDUzlpVGo0U0o5Q095SVFHT2FHL1hqb1EvcFhTZU1MMmt6VkRkYnpaaTBNRDZDaG5Ua3ZTWGFrSWhZWEVKbGhHN0M3TUc4MmsxQlFrblJkK2s5YUY0NjlCNzgrZkkzWHkrRFVYSE1kNDhyblVtbjNxYzROenlFZkZIYUsrN3RzUXltR2RUOFhyU2h1SmUvdFo1dGIzM1BPQmI0TEhUTk5pU3JLZ043N2VKSXVuRmxqQ0MyQmRJc1ZtSDg3aWpqNjBhUS9Xd25YKzNyVEErbmxnazlNTDRJbFJGR2h1elR0VE5ENmg3c2dMUGtJNUhNK2lnTFlxcEJLK3JZYXF4dTEyN2NjaXJTNHdkNDU1QVlldm9rWW5WaEJoc0NhQUIwUmhMdlF6RHVMMmVwMlFPWWJSM3BaWWphU3QvNzlqc2M2NkFtL0NQVVNWVEFGV3hRNkpWbFJQMHF1L2Qyd2l5SzBucU5obkJsOXhFNklVTzZHYWFSMW03NTNkQUd3bWRqZ1NSUWQ1dFJKOWV1WTBUMU9MV3BXbHZaNlFXdjRnN1BXTjNFN2dFeHNKQ3lTdEkxaUVEd2lUUWxhVHdJQzNNUlRPWXVNK2E2VFo0L0Y1VU9vRzRJeGNsaE1waEVpVFhpM3lSTS91SzVvWDREU2p4QUFzcTJCTDdMbVR3TENvemZYRjNkd0VIVk5qWkRsUkE4bjk4bER0M3lkWmhhZFcrUExkRFdWbGFqdUorbGRqb1lFOHNDRHlIRnFQNzBJMlYyRVpMZ3FtNDlNb1llME9uRW5yVkYrWmJONkl0R2E3ZldhdUloM21KcitYMFllSU1FNTBYc2l6S0lSdFJSNHBzR1dYUmFXNjNEWmM0ZjVYL0k2elI4dzdpeDRVRzh3YjBENGExejAxQnRlQnF4bnp4OUZxcXNOcXFLS1Npb1kwYlBLejNyS01nU0krUEpjWmxuQjF0UUJKc2lxZXhqNzBMTWpjMDd4Z2c2TmNaTisxbUVYd0J5MDdNcjdNbzBuWmJXY1FyQW9PM1FRQWZBV0FVUTNjRm9GK0NvUXhPcXdEWEcwekpEYXM0YmxKMjJwTElTbXJYZGw1WldzTGx1QTFqbUN3TE1TRTdHU0lXWEsxalI4QTlDUExRdk9jL1NCQktjekthazdOUjVYSEIxSVl2MEhQb2kyRXNITGtwWjJzN0FJUlRJNXBuWm5WcjZ4THc1UHFaSVJkb1ZkT2g0Q0hSUmhnZGVjYi9KU0Vqbm5BS29DdStnOU9VOENSbVNTd0VrOGJ0VXc0LytlVVlzaE5DVFVwQkFVWUNJeHd1dlhRRkszQzVlSHZQbDc3YkxkL3ZoL3dWdXZ6c3Y4U3Z2TmtSSGlwZEpzMTcvTWpobVNjNjI1dnQ2TE5yTTk3S3JiVENiQ010eEFyUFNJQ3ZpUldwTExTMCtZZ2VVV2ZaeU8wekxIOTFEckNWZkMrUEJoVXVqc1hmYzlNSkdTRVFsUk9IcjVPeDkrL2IxMU11cS9OR0hkOUlGYW5ncjBXeFQ3bVdmRlg1MWRUVU5vbTUxVXhaWFQ1SFR3b0pCdkpXeE1OaW9VRS9xTUozcVhJTUc2aHJXdm9WNUtkMTk4RGk5K2VwbDBqeFcwc2VmUHliSThFeDZjbjhlRHg3cVNobEpyWE03YW9idk5Eb0lUb1hoT3dSZFFHZ2JRKzRhWGlGc1V3UDkvZVFlTG1NRFllQ1JQRTRnT2pjc0tKL2tKT0J0UEQ0eVF3VkpyNGJiL3FQUEY5TVZ5amtQamlFTkVCVmZhc3VxcEFUVDBrTDdhU09SSW5tQ0lDcGQ5bTRVb05GM0g4Q3UxZlFHOWxJNlpvaDBJaVErVnQ0TlN1TFdLd1JRQXFRR0dhb3E1SWxnTkxpSHo1ZnczR0JUMEhKY3NwVEZKRFAyVWQ2WmZ1bTI1c0tJcnU3VTBjQzVGdjNiUnhMUWVLK25xUUZvTldEd0RhS21QV1lsMHo2a0lCT3ZiV2VWTmxVQnJURENNc1lkQkhscUYycG5USzVmbnNSV3RZa3FpVWQzY1M3Q1BGaUY2QUdGNzRiYjBzNWtiNXAvUVYwdUpKVkI3SFJuS0huY1l3d2M3VFo0MDJCaUJETnNuUlRJZHR0NUtzVzJ0R0hQWk41RHJTNDFJd1p0bUxTb1F5UVRPc1ExaENMb0tjT1FFbkZsaksvN1VyWkZQWE4yb2RIMnhxbDBMeGdyb3NpaE8rZTUwd1dSQmErOTNVVUkwTm5aUnhXc1FRdElydGpNd0pwMHhGZ2YwOEhkUTJMSWtBQVBxZlFZdXpKRGhHNUtlc2dtc0JwRHdqVEM4RGJkZ1lpL0xWSzdCbnZMMEU4WGdhanUzU2hieTJSSVlWU04yQlA0QXZDWVB4cW5oTnVPQktrM3NZa1RJZ01iMTloSGFLZVZlZkFsRUxReWp6SWxod0xvUkV4a0pNNUZqUk05K1d2UmE2bGF4bno3VXFYTTBmNUtRa292U0ZxTWE2VHQwQzdUdDJ3akgvMlBNWWZQT0NtRU4vZ3BCNTBLTEpvbkdBUE9FaUMwazZraUJtdzVTWDdpbVY4RFJhamt6UEhwdSswdUFFVkF5djA0bGFvNHhnKzAyYnZ3em5NZ0RzazBneGEvZWR6bkZnRG45UVZRT1RZeFBod3Y3dTN4K0cyaVVublA4c0FHZW1qQnY0b3greEJwWmdnN1RnT1ZhUjN2emVqNEpBeG91ZDZqZFBsaWY3cDA1U0lYbDlQOEhBd0lVN3gyYXpLOTg4TTNBU0IyVENIczRBeWJnTjY2OVRwbFpEYlRpNW1aMUVmNTMyczNyN014WlJlQWRKenVmUDR3RE83VkNxb0F6MVJFZERXS0hXRVE1MnZZRDh4Tk0xWEV5WEdsTzNQbURKUFptaFlvcWZzUUFKdDVQaDlTNFRpN1NyLzc3bXZzM1ZaSk0zTXYwaGoxME5zSXlOSU8xOEhndW1XU0tTL3VuTEs2Z2NIVVVaUFpJUnoxZjkzSGxwMlZVRlc1VkRmYURlUmo1Yk9PMGl5UzRqd0cyeE5BcWtSdEs2MTh4Z1JwTk5idXcrVXgwSHFVVEhCV3hkSXU1UDJNbXpwQnpkUlFuM01HOFhCSktQeUx1QzJveUdPU2g3WEZuUlNQSzduRktrVmJKU1R0R002MkVlcXU1RXFBbnFPaFBaZWNWWnBDNnVDdmVOZUQ1OGFrbS94cG8zTDgzRXV2QWlob016UEtXMm5UY2M4cm56UXFVTm8yU3Uwdy9uTUx5K0U1TEdQTHRGcG5wTnB3dkFzcHJJRVVJaUNPWWJzYUlrdWcwb1lxM1k0MDNOdkc0c0hDQkpCTlAxM21id3ZnSHVLMzBYQm9xSDRwUlRXd3dheXdpRGtkMnVFTTBUQjJUSnVVMHA0OEp3Tko4bGJYc08vU3ZVNEdiVFJxQlNWQWZJRGcxR0drYU9mVDF6WjBPcmUwa3g1UExZYWRyZUtpQkdBSmM2cHhTcm1XOWRFN3FoMUlLVWNwUm5XeEROQldBRDRlVGJBbTBqMWcyMDNZenExckUyZ2M1M2dPbTlvaVBkbGVFOXRqd1pGK3VkNEZWdW5XWFpDQ0NXTXNzMXJtb3VEY3FxSUxBQzVHU2x2Wk95Z2padnBYUmJPL1dhcGlOZmNhcnRXN0s3TnlZVWlkT3NwVStRUWtyL1ZlenBzT0JBZ2puc0VocnZXWjNrUDY0Yjc4RTJpVlpJTytQQWY2OHJNMndmQ0EwN1lNRXQ0aGo1ZWY3RlB4S2tEbWYvZzlVMVR3dG0ySVo5bFlYbkh2MHpaSzY4VnY4ZUgwdUJLcEw5dnVlQlcyTEg5amVwd2dZMlRjUXFrdFRVNU9wS1VGZHRSOVBvdnJsRHdzWW9aZWUvc3R3R1k2SGU0c3AyOWdpTDUrNVdKNjlQaHBHdTgrVEJORDFUUTVTaEpyTy9ZSVVrMTZleThBS00vVEI3LzlCV0FHQWJETjlnRnhVWVlyYkxJRmVRUGJ4VDRsVTlyWU0rNjR4a1FSeTJNVlVZTWpMYjE4UkRxTlluTVB1d1ZMeE9hMTdRTnl2LzNEcHdRUlZyRUZYVTFOYkZXMW8wM0VlUUpDSzMzcDlWZXVZU2orSkgzdm14UUt2UHBhdXZma0dWTGU1NlRtVkNuRE81RU9rVEFXVnFaaGRwWWFCdUNFQ1crRklidUpNSlV4VEVnK3dhYXpUK0JpdzBHQ3NQZGdpRExlUEwyRCt6QkpDOTVMZDFrT3dnRFFMWTduZGxONmtDUVlWM2FYTW8zclhTVFhtdXVtemFvWENTRlVDUmpDRFZRTkpIVE1OYkpyT3dwak93UWpPUWxjTXFhVHFyZ3ZTVHBoRW82Q2lKeGtNS28yUHUwWUIvVEJ2Zi8yeUtGcm9BTEtoSVluNUoxMWRzSU5yaW8rT0R6Q25vNkVLc0FEdHN2QVdMMWNYbU82REVNY3hCVUJoQ3hLeHhqUFg3bCtrYllja3Azd0RHbHFCa0E0SW1oM0RFTXg0SXY5NzVXTHZTU2tzOEZEcDd1N3JFZW1RdzlCd1dPb2dxTmpZMmw1cDVTbXB3SE56ZU4wNy81TUJPV09qTnpBbGdLRDBGUHRXUDJrenBSYXFGT0ZkQzBUTlpGT205U1Vsd24xQ3UvclFNRzJaWWdCQ2laelJlSXh0S0M5UjF0Tk85NWtkNHcySENReURSZ2tjL1VXVnVZSnU0R3BvYWt1YlVlRVVrQllSSW1yL3JQa01BYWxFa1VIV1JnTlcrbnV3UkZBUHFTT0p0Ym82S05xWVJ2UHVuRnBNTDEyZFpLd2xCRVdCN3ltTEo0SFRIYkV5VEh2clN3Q0xsWWxrN2FqRmhpbURPaXJqWGxVZGRURHFwR2RLV1djVVF0ZHlGeVUrTzU4YXdOenZtVlNGNlpqN1h6TW1lT2hTc2VVaGpsRDVqMGt3Vld3MWhBdThKcEhLbkFKbkw1TFM5b0l0WFZaY0REU29oanQ4QXphY2VtTTYySVEvTDlnUWgra0wvOExNRDBGSmovenlOTy9VK21HZGhYQWxZOW5RQlJRbEk0Szc3WnRGWHhEZ3JYalBDZWV5am0rQkYvSEl2WXI0TnJpdCtMNXZ2dnlQc1c3ei9XUExBSTZnUlFnQXB1UDl2RFJYVlFOMUlkaDhxN1k4T0RlczBlcDlja1RFa2ZQNHNsclNTUG5ScGhjTXZkUFp0UFAvdWRMNmNyMUMxQUFZalgybm9mUDF0S25uejNBc0c3aTd6alI4YWdpYko2cFFmYjU3RExTeWpyQm9DOUM1VEZqbm02RjVLRktHb21yb1BzWUZUaFhWa2pEUUp6ZXhaNFU3blZLMVRERlNIdUk1d09xSG14Z2NJYUk1aU5kelB2cFBrblRKd2NsTmlDZHhNNkJSNDkvWGRXK2ROekFjOFlxZW9ERnRhOTNNRzBkRU1zRnNVaHdKeFQwbzVaTlNGZkcrbWdDMWZPbkJHYkdmcVdqRnp0UXpzV3JVdkRQZGhpVFlwQ2gzcmtHS3NveGRxZEJ0bVozUzNRanNtTzdlWUpwbGVpNkFWZU4wWU9rTTNVaG5WUlJUVHJ4em8wUTNhK05RNkl4UHNYSmsvamkzZC93ZWhyaHJTVGh5aXA0Szgrck11a043RUR0TWlwYSs0NmdGdGU1eW5QYUFmRlJxaVNHS25Sbzh3QWNlL1Ntc3VXNmFxS0EyVzVDTFk2Q0tQWExzNC9oVUNVQXlKeDdvUG9TNFcrRmhMYnljQkF3bWl0ek5rVnA2eGVjYzVRdUlZRzNsUnFrV05WVHl4bmFoVlRWaGlvMmlHVFp5emlNWTJOc01GYWZmdndvUFovQ1N3ekFMaTNYOENJL1QyKzhmcDRGQ0pXVVZkMlZ2WmVnWWV2QTE1alhmbFJuamUxMlJLbTBoVG5YMHlhRDJrK0JOeXFMd2dCK05qRzRqVUwreHIrNU9VY0x6NG5nWUx6QXMvTnN2cnZIc0NFUXQ3TklXWnl4blRhWFdGQlpqZmhEU2dSY3o0NldZeEd0RWtqYzBiWkpTRXlWZnZXVDBHRk4vZU4wKzdYUjlNWnJWOU41cW5tWUlNN1VNNzZrNURqL2pMV1NtZ3VFM082Q2d4d0NEMlc3NkFGZ3lKQURKSXcxNHhOZ3gzeUdaNDV4dHc5NmZNMHM0U28reTdoY1MzOUQ4ajFpUngrQVNJZURBQ2JRYVpjVTNPcDROSDJXMHBJMXR0cUlCOVBNb0ZxczBDS290eUlWSDlKUHlDYnVKNkRJWjJvellWS2duY0tDeXBYUERVTysvZUIzbitHZnY1OWl4dGUvQ1JyRk9RSkxBVEpocDZPTkVWaXJSTW05WEhpMGt4VVNrdFV0N0kvbkd1YmptR2I2Ujh1Z2ZjV3JBQ3EvMnc3UEtUNjNUbmFVM3VzaWRLRWZQYjNNMXVCc1hZTUtSNXdTWnpUbzdZSTVYSHl1MWFpOXpzcDhIbU44VjlWcyt0MTA0OFk1YkNTcnFJRTc2YXRIQyttdmZuRUg2V1kxTFZNUnRJWjAwZ2NSdHNLY0pzN2VlekJGN0k2NzlPcFNKenFlaVQ3QlhxWDNibzJ0bmd4a0hCek9CdUVOS294cTZIVVNjblovbU83Q1ZXL1lRQTN2a2pXczJ0aFpXdVorTWIxQUMyRjBCdlB6TDc4azVtWWpQWHU2SG1xbDd1QXFIaUMzVjJySGNhQjRYRFVva29FUUJLemJyVXFvOFZ4N2hNcGtUcWRRT2hzR2FFZ0hvWTBHSEZvcnFoT2pyUlZFZ1lob3MvVzl0MWxaTnhrbkRldG5Sa2NJcUIxRE5TUjVHc0lTdk5vZ1N2TWd4d0ZqN1VqV1BJb1YxQW5ubnJFYU1TblNpTkhVcW5YWndBbkJjYTNTaE8xV3BMZE9sQktWcTdtcnFoY2RFdUpneExrNWR1WWR1cDVwNUZRTnRiQ2NNVTE3cE5ZNHhqb3ZYSmw5bWFvaThlckdOL3BkMjVHZU5sM3FFcUlBNlpaZEF3RDdEdXJ4Q3VFb1pkenh3d1BHTEZsVGlpM28rNVVndTlKWnBLcWgvbEVXaDVQMHh3L3VwOS8vWVM2eHl4WlI2LzFodTJsRGVyNXdjUWpWZEFqZ3Rod3kyUXhzUENGZ0dYL1hTM2FFd0IwQm14Q3ZHNEtZdmhLMktzVmc1dGJhVUVWOUtGWlorb2lIRXFlUHUwY3pOSVNnRVA0Q0xUeGYyR0poWWl3RkRDN3RBS2lqb2dJQUdQdHJoc0VYdXNDVHpicUNqWW84MXQ3MmRBN25nYUdnMndSRzM3b3ltdjc4cDk4akxHVWNhUjhiR1pLenpLdEU1R0xpU3dhMEhuMGQ1NGJTcUg4NlU0N3BoMllNNTh6RlF5TzRraGF6SGVBVDRNR3hxRGpMVGJORW9jREFIQU1vWVM2Z1F5NGt6cSswNHJ1TW5PMVRnVEx4WGVDUHlxY2NGelpkM09LZjMvbnpwM2llZ01VekJWMS9zek11SEhFVm43V2VGU3BhQVVRK3oyY1hBR1dmdmFmSGZmZSt2Z3Rpdm9jSDBudWRnbytRVjV6dk5kbndEc1R3Mlg0SWJuNzIvaS8veFhGKzkrVzlYejZuOWEzSm9mZk9uT2xoSlU2SS9HNFJoVjJBc3JJakUrZlNnNmRQaUUzSnRZNFdGMWRZQlR2VEpWSnNCZ2tyYUVXL2VERy9sbVptaVg5NlNxN2dPaFBUZFFaVkRTTW9Vc2VsU3hkWk9iZVFyR2J3TXE2eHVwUGkwTnBOT2tQMlpxbUdPVUJHVXVzVk9uZCtqSWh3VTFiS0FZN25KODdqRWNSd3ozSEZXNzFhb2N1elNpa0puWnNZSU5uNlN1U2dFYWdjTzY4c3JpeVNZM2c1NG9abVNQOHgrTyt0Yjk1R3FobkVxN2JPcENCSG5Jcm5ZV3RBTEcyaERkQVhiU0R4bXI3dUlOcnZFc2F4VGR1MVVia1NXc2RKU2NlOUR1MjM3dVNvY2NVeHQ2SXlPbDV3alhwQzJFRUdxQkFoWTU0N2Q1WnR4b2ZvQjdFK01KYXJyS3VMdGc2OVJub29KWEtUWnd0aVY1cUlsWlEyYVM4SkZ6RE15WndHME5TUUlBVWxWeW9uWGJ1VlhrRmpyWFlBTFRjNmRmSUYzVWltQm94RFZRRDRJaTZJbFRraXVDRXdLZGU0SGw4KzE0MHdKQkFCTTd4ZE1Ka3FzQTRMVlNLQklRenhqSzNlUDFkK2E4MVhDU0ZwT2FxbXVlbjE5TUh2SDZRN0g2OEE4RVp6SStFQldGMUlySmEwdm94MFp1NnBDYjJxclRPejJKa1kyNUdSVWFST1UzMUluUUdRbFJ4Y3lGYVdWMmdoNEFBd0c2QXBJempPdGxFN2wrSkVKN3FjdE5SQWlsNGpnK0x4OUhKYTJtQjhtVlNGVTg5RlB1R2Uybzh5UUR0dTJqZDdjVmlNc0lDTTBpYkRHVGFXVjZrQXNzUEdHZVBwSnovK1ZwcWNHS2VQTUIzamFZQnFWSnBBZXZTK3FwTUdNZE1Fam1FNllCNWhaYVJFc2lPWUE0SE1CU1ZDT1JoSEoxRHdkZDdDY2NPWVM4Y3VXUDV1MzV3WG1WcUpKRENGenhtRVpITG1qOSs5bitXRGNseGFsajZjSTZXUVRDdTV6NnBjNFlWRXdwUGhmWDZBRlhmMC9BQUNmdU1pV3AzVk5COHE3WENLcmZNU25pZVFaWUFPVU9KOFgvNVdnSlhmNHhtODUrdFpSSG0rTjRoY1Y1L1BkVi9ic3dCMUpiRDQ0eHl2TGU3bnZieXZyN2pYUysvK1Z2NnpuN3lURnVjZXBxbkhEOUpQLy9SZEFPc3dmZmpKL2JRMGY1QjZZV0tMOTFuTzk0Z3l2TSttRmxqQmxqRnMzeUI2dUo3ZS8vMGYwdFZKRXBJdlRxU0hyS3B6YXl2QjFDV2l0cDgvdTB2WmtVUFVOSXEzSWQ1WHU0YlNLdEh2TytSc3VYcXFGbG1NemZTVk5sUlFEZFNxcE1ZSHRhQ21yQzNOUWdpaHFBQWFhSjJzTm1PczlsdElkT09qQStsZi9ld3ZLR2R6SnYzaXIzK0ZNWDBlTlJNQzdEeEliOTkrTTMyT1ViOFBhVkJWOUpYclY5S0RoL2RZN1ZudUQwMnQ0RjZjYXhVVWQ0STVpY1JoSmNJNlVoYXFBOFNnd1g4UGlXcDFkWjI5NGNZWVVNVjMxMGVIV0ljSDZoMkEwQW9nZGlHOW1HUmJnZmpkeGNWbzd6cDVscHNiT2JkT3I1eVZHc3lIbEtEY05kbjVNR2ZTbFpoYk1sbE9waXVaNDZLRldGdUJXV1NjNi9rY2Q4NVZKelJZMDh3TWVIakpsQ0FOa0xUSUhwZUg4ZGt3QUIwQWxxMnhrTndPaHVncTR5MjRRQjVJeHd3bzkxYk5hQkFyWmZCamxPdGxjZkE1TWxVdnRzWkVtUjBOdVVwcEk0TkRGRCtrSGorQnBETXZwcGdiR0hZVnhxUVk0a25MQmtEMkZJOHlYclZOcEhXcXU1NGg0TGQ1aVBRR1lYY1REdEREbm9BNzJEQm5ueS9yZ3N1NzB3Q3dNdnpjL0N4alJIdVpNK1BNOUhvMWtNQ2lsVWhOMm16MHlEYlpWWnF2ekZVRFVHQVJRWFdMM0VKRXFSTVd5Z1ZpK3F3bUsyTjZMU2Jac0JVZG9DWnVBL0tIMEZZM2hRcmJrYzZQVlplWUI1Ky91VUVmK0hBRjFlL21qY3RJVmVkanNXQzJzTG5oZ0FDQXRIOUNMckU0S00wS1dCYlhNODNMMElLUVVKM0hrSGkwUVdGbUFOazBJd2lXdEFUNndnUkEvNHpqVXYyMnJ3SkNoQ3B3UGljeTMxbmlLS0dyQ1JneXJkSTJReG1mTXpCa2U0N0hYSlR0YlFCZTNNUHpNakJhWmtaNk5iOFVLeHJQOGQ2Q2tESTRING9YUHdvbTNzOC9uUUtxYzk1SC9ueFpKU3RBcTNndnJpbmVYY1I4cGdVR1E0TFNSaWZnOGFPYVJJN2M1N2lVS1AxN0xzKzBYOFZ6ZlBlN2ZTcnVXNEJZZVgwZEw5amNQSVBvRHJ2TDZSQXh2UTIzYnhrQ3VIbnBFc0YzaTVBSzBiMFlpUC93aHp0c2VQb0FOMzF2NmtlTmZPWGFtM2hUanRKbm4zNkFZWFlwclczYlZLYW1CMXROVDB2NjhUdmZTNWV2M1dJWDU1MzAvdTgrWnNBSVRPekRiZ0FCd2ZZNEpqRzRzMnByTk56RWhWN0ZzRHMrU2lBam9ycXEzZ0ZHOEJLSnVOMDhyNFBxb1paaTNzYytkdlhLK1hUemRSS2hkNG5qUWkzWkpPQ3hEck1jd0p4My92Z0pUb09OMUYvcHBRektVZnIxMy8yR2UyK3k2UVFUaHJmSm5YV1ViblNaRzR3bmVraHdWb0RzSjZod0dIKzhrYzNPNXdDMm43QXRNTjRNSHdEQStSQ2RLbFFyMTJFK1lXZEJ3QWNDMUV0a0VtODM0UUxhRXVwSVFpdkwyQzhhRkthcllYc0t4d0pFaXhybXpjRWprVFA2TG1HMGhucUcrTS85emJ0VDFYUWZRZ3NKZWx5d1UxMktRRkVZUmFONU51Ym0xVXlwUVp1SGdZVW1TTXNJZXM3Y3RXZVB0cWkycU81VldUeFVLVjNKVlNVRVlVczJ3N3IwUzRNeEVoYkF0YkV6RjhRbDQyMHhmb05JV1ZYQWRHeG9EUEFhWmd4M0tWbThqQ3FLNnMzNVhVaFpnLzBBSk43alZyWnFPOXh2eDJZNUY3Rk9oanZzWWYrY2V2b2liUlBIZDB6bENxM2JmVWlmaGxjSXlGWmNNS05CdDN5VGVSUlQ5UUFld2NCS0l0b2VHZGF3TVlhTno5OVlWUGIzMlpackIxQ25YeHVrRGUzd20zUG4vQXlndG80UWlsRG0yZ1p4WkVlQTdERjVxNGJLV0VYRU10UG1IWTZNbjB1WEw1OU5FN1NuajdnMCsydzFCOVlLdElSNnhPQTFRVXB6RWcxY0ZheU1nZHNDdU9EcmtKRFZFbFd2cmQ1aDBHeURoY1RqcGh3WmE2Z0JIc2FDNXMyNllQRmo3STNvbC9hemdaMlZ3b1l6OS95ZlA4SGIrMEZ2TENpUmxnT2QrU3BBVHVuZjQzcmFJelFKR3RIenFKQ2g5aElSL1VodEpxYUgxTVlqQW1pOFAvM3pGWUFBY0ZpUytXVXBKeFpvMmdtV2ZBMGNYaXVZZUkyZkJaUzQzMHYzRXBEeUFrc2ZYVGtjSU5ES1BpbE4wbUxtaW0vUVluR2ZRb0x6bVg0MjVNZGp2cngvOGJ2Znl4VW0rb0FVRlpuUktxQVMxN1ZybDlObjl4WlFiYkJsd2VRNzJEL0dtY3hyMXk2a2FkSXQvdXRmL1gzNnp1dFhxVVcxVGpMMFFIcmoybGtZbGVxZXpVcTZkT2s2amVMR0xXdVVUeW1sUjQ4K3czczRFS3BsWGE4V2RiNDNzSWUxRVBmaU16c3BRVU03cVpCZ3pocFJ6eEJZRDZ1dFc5UHJPWFFMOHdOdEdhZ1ZldnNrMXNjUEhxWFBQN3VYdXZ0YjBxTW56eUw4b0pYazZUYnUrZkVIWDJGam9ZNFdBYVNMNjNVWVpKZG5zbG93a2E1c2NFdElOMDVYQjBZL24xRW41RUdEOVc0cktUOGFxakVHS3pZYlg3TzlzZTE0dzg3NUx4Z0tZbEE5WllwaEtJZ1JXMDk5bHpnZ2JHckRlTW5jTGFZQ21sbmVoUkdQTmplUUh0c3hEQnZoN2FRYU9oQ2JETUFjaGk1SXBvWVlhR2VJM0VGWFJ5VlJ6bFZWY0pYVmczZ0lvemlwVHI1OThMTkU1TmhaVWhtODQ5NHlzUGV5YllJY08vSUF5SjZyRWRndDNrMkpVSXF6VWtQVWNxZFBYTVV6dEljUnF3U29TeXlxbjZxLzY4c2JTRnFFTUdCVTd3RmtyRHJSU3lXRGJvQUdkT0I1cUtkb2FVMlllbmNITUtucnhhS0V6eGE1b0p5elpiZ0JhVDlORnFFdWpOK0RoRUlNRTFsdTM2eWZydlBuQkMvZElYV3dqcGx6Z2NLTk4wNE9vVW5Pc2JxRjVWbjJ5REgxYzVtRng4MDRWbGRKN3lHK3JRV3ZZd1BBUFFTb2xjaFU5VWN4WWJ4MlpTSmhadU5hK204ZUhFWjN5OStZSjJqQTZ6Z2J3R3FETXpiTkVCZ1hzMDIwQUlhQjhTRXJ3ckkzNUxQdW9PS3B2aG9lbzBSTXAyTnNUUHFQdWxYMG0wdUNHYlYxcXJvWmc2VzZxSXBkb2IwTlN6UXg1aWUwengybkpTcUI1VVM2NEo0eGg5Q0NCSmVGajd5UVNRL09oZmw2emlHeU1mUG5YTk5QZUllaGl4ZG5CQzFsdW9CR0VjdWtFeVZwZ1YvYU1BYzIyZytvNWVjQkVyUlJJVkJnVUJvS1FKRWFPQ2M3Y1hSb3lBRVp2RHd2Z0U0YXBGMHZnMHBJU1RSQStBMmJtSTA1YmF1MDdJc3JiRWowSVdpU2U3OTh6emlIK3hhdkFydzh0enoxK1ZScXJqSFJTRC9HcjdUenZ0OWNvVVlVcnVweElwclhWZ2wyd3pCT2VlTHpCQlRPWWRDY21kK0FHRmJUSzVQZGFYWm1JYjFONWM0TGw2K20zcUVKenUxTW45MjVFL2FCbVlYbmFZUE5CK1ptMmJFR3dtWGVITkpnU0p1dTZHOEhaUlVKeUFFZElLcDltSjF5NWxlZVVaMlU4MkU2OTJvN01RZ1FFVnB2eHZMcVp2cjFmLytNeUdsU2R6NWZKbmcxWVcvb1MvL0xYM3cvYlM1UHNZbm5Lc25NZ0J3cnRpdlpEb0Fuc2J2cUluTWcyemxZZUFRaG5sNjhtMlZBUkZlem5qZVdVVDVqQzRMNEpRWlZ4TmdabUd2Y0R1eVlSa293R2xlakJESUdmVGZsMUc3VlJUUjFQL1lRSThnN1VjY0UveEJyamU4QkNKV0lKT1NJeStGK3JveG01d2ZDdzN4QnZCSU1rZHF1dmpvRWFDa1lxNmVNcEdJSk5rQ04rN29BY2IwU21SUHFQU05WQTRLMGFtalZ1Q2xBVXpYWFVJdDliSFBhaUZRUFdsVTdJRHFOOEQ1VGNOSitaWjBucXlCSVBOd1pBQ0NuajNMVzJoMTdrRHlzSkx0RzVQZ0FFbGtmWlZtczU2VnRFaEdJRlZxdkp6RnpTQjlsdkdMdS9PeU9GVmJQUENabFpiOHVBQUtzNkdsZFpEYjBZc2gzRTFPekFueWV1WUJIZ0pNMk9VeU5ZYk02WWk4MlFhQ1ZQU20xSGJad2lGc1FMSW9Ia2ZzU0p3dzQwWDRBeGxTZWh2byt6TkZGL3pzWUV3WEh2cDZqZEpaYzJDN2FxYVJxanFvcXJsS0tGUjQ2TU1UTFIrWmVidFAvWGNJb05zaVZyQ1BWV0kyaHp0Z2JMdUw0cTNiN2lGYWtWcjFmeUJnc010cXZsSUNJaGVNZUptY2pwRUloU2hLQ0FlRE5QSFpRT3R4cUM2R05JeGkwRXRlbjBSMDNZZHpUWFphNFpZQ3FMQTF5OFB4TUt4V2s1cENRT04weHRLOTVrWEpzNFIrZUFXRkNEN3pUVnMrTk9lUW5Xc0F4RjJyQmhmSENZYVF1TEJBSlFlYi9hVzlTNG82VUhXOFRZS0VFeE5YMFI3dXI5eE9ZcExVQ3BBcWdLZ0RGNzRLSzUvSS83czdyOUJvL0Z2Zkk3MWtLOUh4NXhOK0t2eUk4b3ZoZVBNOTdsR3VMMmhRb1ZFZlJ5RVdOb0Vnd2dzb3U4VkdQbm1sSHFwRy9SeXJGMmpxcXhUcTVVQmFBWTlYRzl2UEc3VGU0NWpNMmVwaWxWTWMybFJFYVNEd0w2Zk83OTlJNzMvOEdiblZpZFZBbEQ5aSthNE84TGVhVHFUREFFSVppNWE5MmFWejBhWFFHWXQxRGhYdnhZaFU3R0xCQ0RTTHpybHJ4RExtQ09GRVJNd1E2U2J5ZlVpQlFqODNGeTJmWVlJSVVoYzBWNW13emZlK2QxOVAvOVovL0J1YXlKRzgveEk4a2gvUjBvTnNJcHBMNG1GYUlDV0xqc3lwblc0WHJtVFFISnJ0aGVUNkVxQkhkR0tHc1N5dUJRZ3dhdnlBMGljdGlkTWF1V1FkcWtCcFFRM2c1bFJBdGQ2ekIvR3RiVVR3Nmk4OE91aThaUjdwMEt5bzA4RmdaWTBYaW1OVmR3NGJGb3pUOFI4cEhQRHU3dWJWbEtZWEl2UnArbFloY3pUSFJoK3BoNldyVkRPdkJDL0Q5eExSMUlSRnAwTGFQZWhNMTFJZWFpVXBpUTdTcHFVNVlwNTFSb1g4U01nMW5uQ1JzcTJab2E3SEkzUnBwT1Zha3NMK0QxTUIzUzNWeitReCs5VnA2RTE3QXNPRVFWcUlhWlhHK1BrSThlcEUrKzZqRlAwS09aZytlUVVNdFhIbmRocXVCQjFOVlN4dUs2cW5Cbkk2TnhtN3IrTHQ5dmNuc3pydHphVUJzTDVMOU5zOVlJNnNob3h2bkljbTBBTlluQUVSVEFDUkt2WXQ0UUwyN2pHallmUVJreXhrYm1GeG5YRGFwUURFUG5lNHhEZzNBcXNtenl0SU9kT2c0MU1tZ2lMN0JzTmJ4ejVrSXpHUFFDY3pIVWVQYTFBZ2kyRk1pRTdRWWIvL2NDQ05pSFdtREMxa0JPSm9jWkZDWjB6ZzR0UURUckxUcCtwTG1sZUNOOXhOa1ZmZXpDZzl4OEpJdkhHOFpYMkFwQUNWWFlRVzRBQytqNERVWldQWmNjQUthYkJyUHd5eWpZUTZRcDRuTXYrQ1grU0RmUjFEUmxxVmpBRjYxNzN5MzdRWFFCTThJbUxhQ1B2amRZOXBCaTdiNFcvSHlzK2ZGMkVEVEJTaDV2RGpQWnhXZlBWNm9ucDVUdnNST3luMERaOVBjMWx3TVdPZndSSHFCKzdvTmI1Mzd5TlgyTmlBaVBJZW9oeDEwYkttVnduMHcwZjE3ejlML3czNTBBLzJOTkhHdVB3MWZHR0h5eWRGamNtOS84enRJVzMxRW5rOFRjZnlNRkFlSzlMSEN0Z0J5TXIwWi9IMnNzcnIrZDdHbkhFR2MybjhNUjFoZSs0QWdVenhCckdMTVR0aUhjb1ZNcXdtZzJrQ3dMYXdtRnBNYkd1NVByNzF4T3oyNmZ6ZFd3cnRmZkJVcElzdElpcW9rWmRRTEsyYzJJQUMzVXdkdFhNSWdPRmVUTEZYVnNPMElVcTA4c3dsWXR6TzJRWENjcnpRa1dPb1JxK29KUkZwVFhGYWEwVjNkRGZGWnJyYlJJS3hoOHdSdkYrR05CREtHVVJPQ2tLZ2xRaWVQUnROdkp6VVRxL0ZGTG9wT2ZteHV3WDNqeFVtUXo2bWR3MDlPWkZZeERJb1VCSXhaMDJHd3RyeWVWa2hJbDFuMDVPa0FrS2d0Z0NqQmEyUU5JSXZBU3JjWmMzTmJwQUc5bFBSVkVQQVY2Z3Q5ZFRzMUZGZkF5ZzBkOU1wUnJhTWJ3bU9zbEh4Z1JWU0hiRkN1SWZWdWthKzN4SDZDN3VDc21qallUK29LZmQ2RE9hM24xVUg4Mm41dEtUWWRFVjhyYmNScUlSV1BqeUpGazg3VEJpUEtzS3JDcGwxdFk4ZlUvUytRT2xneTVoNkcraE9BZDUvMldHUGZVWEkrVGtpdHdVcEhMRmRYR21KeFZWTGR3bDRrNjdpUmhwdWs2T0F3SEtYVlJRa215RnRsWmNiWWh6RlhONVhFdDVBYUtjMU1MaW9XSlJaWmJGaTBlNXZxSVFmc0dkRGVnYVFJeld4dGJjVFlDUnlHU0FneWpwUDBFQlZFb1VmdG9ENWZRY2U1bGw0T2tPU0RjWmtqenhjUURwR216UlFSTU1MN2h3RGd5NzZwL2tLZVhKUGJHYVlBbmxXbklxVXFuTmtBMnFRTVZaR3hwVU1vTWtDT0s3aXZ5NHM4Qm0weEJzYmIxYW4xWm1rZ2JiWVdOaER3WFh3RUJiR2ZaVEFBVGFtK0FDSnB0Z0FOMjErQWtaOExDYzUzejQrNEt0NkxjNHJyUEZaODl0M3Z2dkx2K1ZnQmFzVXg3eWxQZUw3SHZMZHQ4ZDZlMC9xdkozdmVxNUJqZFVSZzNjMDNyNmVMdDY2bkYzTUxkQVFpaFREME1wbUdNdFJQb1R1SzZDMHZicUwyWWJpR3RKZXdhNWdzaThMRDZtTGVJS3NpQVp2V2krcG42L1VhZ1RpUEgwL2pNVndKRzA4M0xtNDNHekIrYWhBaUw2TTQ3eEkwQ0txRTdzekNreVowSlFPVWE5cU8yQjNHU2RiSFlscUlLbzhUNGc0c1Jod3JJU21HTDdCcjhBbEVxemRuNnVGenlwNHdRUjFJVjRSUkdKVzBUY2tUcTdvYytUOGxLMzR6b2wwMThBQkcxSnRwMm9wcElXN0txVDFCMjQxcWg2cUtVazZ4ZXpNSEhYSkVmTGF6QXV4SGlGa2JvRTg5Qm9mU1BoMERDQnNoVnVmVmovT2x4Smd3STN4WnZRRWIxVThuSUNhQ1kwNVNFQVBnb0JkVDRJR1c0aHhERGpJUkNvNnFXams5SlVSbnJoUElqZTBxMmhtck1ZM3dzU1lFdTNLeU51WjdjbDhCdFJzN25kZUZ6WXg1Q0djQTFLdVU1U1lQN2lidHZuaUNwYURQZjR3N3dhcTJFM0NIK3JuV2VZZVp0K3VVaWNIQXpQSFlCNUM1TWQreVJHbHAxU1ZkL2txbUZ5K2RTMWN1VTI1bmpGUWFKQVhET1FRcndYQWROVjR3MXU0WDNrdjZIQ1BBOE9rSnRUMjdxUFpXRjlXV1p6Sjc3SGdOYzhwMWptV3VyS3Iwbm0xaW10ZmFBVjBya0VZMUIvcGpEZmhGVEFyVHMwdVV2MW1nOGltMGhJcFdKZk9pekJieDJxeXNONjlxS0IwWFhzQ2N3c1NBTXFnOE1aNGZkajQrMTZFVjIySmZCVnc5dVJIakJJMDVkOEhJeklGMEkyZ3EvZWJBVVZVaFZHbm96SE1FREY5Y0ZyOW55VjRxOEh0KzkrbnVVaTFEZi8zSGIvWmYrdkhQZS9ydVM0Q1VacFRTdllVeFlad2R6M0ljWFh6Vm1DTFVnZCs5ckZEUjhyMVkzUG5SKy9zODIxRUExc3VTbHRmNDh0emlPczh2ZnZPNmwvOWlGSG1XNXhiUHkvM05VdW5MMS9rOFg5NnZ2TGU5bEhiNDNqVktsUElvTVNrWEJza1BheWN6LzRnVkNCc0U2czBpRWVvdEpBa2ZOclVIV2Z0Y0F6ZUFnNlIwN3RKcmxBOXBUVThmUFNUbWFEQmRKdUR1ci8vNkYrbjh1U29ldDg3MDdUZGZ3ZWF3bWo2K0MyZ1JBbC9CbGpCQXFnZ1ltbGJtTmpCMlk2akdPRXBTQ2VDeWwxNGhHSFVUNEZ1a3lrRHM2c0pFZDdwbkhsSkNCNTVKVjc5Tk12MGpGSUlPek0wVHEwUGx5Qk9xTjdnSnFpbXNvN2pnTjdjUmRXRk1QV1hBRXU1d2JXWFllUUtJeWZsaVJZek5ONWcwNDZQNjZLZmJRc21jWld3WFNpdXVhQktXSy9ZSlVxRHFsWlVGWE52Vi9kMXNRR2RESDlHSDV0cVZjT21aS25NRWtlcXhjd1dWd0wzT2xWUGlVTDB3eGNmSkMyVllVUjJHRHFaMmRlRjVrbTBBbHVJZEJCZmxaZmdzQkptV1lxVUJjLzBFSXUrditoaDFsTHduL1FIK3VBRnFIbTBXOWRvSXduVTNaZHVyaE5WeGdwb05jS3ZDYU12WVJTSTd3dkFTZGRYcjV1eHhFVUFsY0NrUmMwcEVmZ2RSQTFqN1NGQjYxdzZSeUxCbHc1eEl2RlNERUFqYnl6MzhvQ2NWdFlIeDdpWUJ2QU16QXV3Vit3RmE1TERPdVlZODFESEV1d0JwNXpwRURlTUM3bWN3TVY1cTdrbDN3cU5YeE85RUNBTjlVbzVSc2RsWGJhTlBiU3lnZWhrN3lDWTRCTHlVQW0yWTNySnRGckVaSlBjSXoraldSbmRFNkFPYjl6SUhMVGdqMmdsSDBWWmxhZkExeXRkc29DN0xaZzR0bXJYREIwZzZuNENNS3owTWI4Qm9rM0YyTWQzbm1GSHhERmN3bnd6b0RXUm1vVUZweUw0cnpLb0tjbElBczd0RW1hOW9qSnhxV2h2UitNYVl1U0JtS2N4NWwwbUwrL3JaaFNNYnkybFdQRU16UWdZTHdTVGJNK042MjNlNklIcHV4TGl4SUVkOEZIUnR1NlJCanZBY0pYR0FJNzdUUmw1ZWF4KzhkL0huN3dVZ0ZjZjlIZ3NuYmN2dHlOZmExbWk3Ri9rWVhrVjcvTjNQUlNoRkFXeUZwQ1pBT2RiMkxXdGtMdWlxcW96aGpadW9ja2cwWkhsU0VtWWF5V01uWFo5a0g2TktQK1ZqNWxEUnRwQWV1dEtGeVF0NGViYlR5Sm54MU1SR1lLMGtDN2l0VVRKbWJJQThLOVREazhabXV2dnhoK203My80bU1UZFQ0TVZCdW4zck1rbWsyTU1lVStZRVc5THMvRUtxYkRINUVGVmo0emoxa2dEdHhxRElQR2tNd0R6RHRsNHkzQmhTUy9Pb004MXp2bUx2QkNWM2g5bjVwTE9yQi9GOGw4Ulo2bjFEYURLYzduWXJMOXk0UG9iYkhta0todTVBSGR5SGtROXhaNnZTME5md2dGbW5Qb0NLWXgxNktSbWNNV3d3d3hpUVRlOXBRc2dWa3B1WnF4Z3dpVXJMaHdaeWlhMEV1Q2g1dVBzSml5VVNLSXdCc3hBUkV3WmNQWHRLTlFZMmhxcXBSQU9SQ1NwS2poSGZvdlREL1lKQW5EanZ6LzlOdWVHaXpIQk1sdjlrU0U4UXJHaFJnSlRxbklYelZJOVZtd3gzVUJKVURSSmc1ZlFUSkZLOVl2WmNiMUs0enJtWHhKbnJvZ040Y0ZsWmFTUU15NW1aTXlFUlMyVVlBL2MzcDI2UGVkUE9aQ1pCQzR4MVJQK1VjQ0lMZ1hkM1grNUNsYktXVmFmbGF1QzBRK3lab1RiVHRsNmtkSGVwR1I0WkRJWTVKTnRCQW5RYk10Vjl4ek4yMEJheEdGUGpkd3c0dEMxMUFFRXc5T1VVR0dDcTYwUXA0eEQxUnNsYmtEN0F3MmlJREhqSC9NSTh6R3NMVXQweEFMK1BaTDJ5ZFl4VGFTMEF5L0xQM1pnNEhOSk5iSE1IVFlwSDhrd2RMYVpaeVRpN1ZPOW93aUZsUEhpQ2lpcFVUQUgvbzFrWmtKa2p4ellLSWZLN0txR1I5SG84QlFEbnVFb3VxWFlwRlU2TjUrRUI1bmV2RS95OHA5SnJCaUpvRUZvUi9OcG9qNUltWHhrcktJRy9BRU11OExObWxYYnNGeGwwcEkyWWRzYmN4UkFRaCtGOUtYVjZuWFNpNDhlRjNqYUdFNFBqam5HQUMvY053enUzOHZ3Q1JQenNPVDduWlVCU2NyUWRQczl6UE9hNzlPMWk2ekVYdUdnSG5janRsQXY5N0ZpS1luN1B6L040SVVuNXZQdzc1M0F0SThwWC81ai9XbU9GY2lwNExLaisrV0ptUFEyY1gwcC8raGMvVFMyZC9la2YzLzhJZTFWN2V2UE4xd2dXWElzcWtELzY4WGZTYno3NVE5UjFQNGRIYjRkeXlVWTR2LzZLc1N3WDBwT3BKYXBXcm9ja2RPWWNOZDlKVUQ1aWg1d0taVWM2VUxlMldjRjNpVXFXRVRzQW5IQy8wMWtaNi9LbENhUzNIa0lobm1JSHdQM2RqcEVXbTBlOXRzVmdERU1Zck55bWxzUnF6c1RBUE9hUTdST0lPREJDV1pTYm8ya051MHFOSGFKVmRRenMyeVEyckVHYzFva0RDb0ZYRWRmSnVzTGpCRU5CY0owUXRSVUdjSHFsalRKYnFtTmtSZUhDRHNNR0F5aWpNaVBhUHdTVXd4SEM0TXRnbnlBRkhDQTVITk1tM2ZpdEJGbkN0a3lRQk1hQW4wNmlVbHJZWkx3Ym56V2dPbUdDaFVRaGM2aHVSSG9PRTNVazJNQmdzbVc0cy9tdUFkWFZSaFUyak95R2hUQi9WVk5TZUpTNW45dzYycWhhcUNwUGowUENVMDJOV2txQVBpM0x6QU94N1dLN3k1VWdPSTVkUk9OeEJHZ0MyQ0dOUW5BTVdVZ1dxam1xUjZyZ1NnWlI5QkRiaUJLR2pnZURVZzM2TmJyYnFIT1R2VHNvMDJPYWtjRHExdXRXOWpSOFJGbExsVTNwd2RnazFWKzlsZG5iQ2VneUhyRkpyNG0rTUZ2K002QTFTMXpHb2NuY3dlWDBpRjlEbWp4RVNuUlREQWlXY1Rac0FOV01lRDdCMEJMWTJtR1BzQjBkOExjRnZjeFNRMDNBTUlQQzlndkloaDY0NjdadEV6UUZHbXRRR2Mva0hLbU80aEVKSUhFYmVCY3hwV2hwVGFFVWM3cnJUWjU3cEROelRuVlpRRG9oaVljVXpIMlo0UXhvMElBU2hBdWNsNm1peFNJR1hhZ2VlbCtvVGxLQ1ZnUUUyc1Z6N0wvZ3dJTUNHRnkwbFc1dFhtWjZhWXR6NlZNbjg2Q04wdHIrK1krR0NWalNjRHcxZzE0QVBOLzFSQnNIVllDVU5Kb0Jrck5Qd2MzN2hyUkord3BnSzQ3Wkg5dm1ndU14c1VsYWwxQUZjSm9jenhWVWJXTnh2ZTh2ZjNhKzQzeUprSXNjTmJ0Y0hzRndmY2hrbHNoOG54akdNd2NJL083OVQ5TUtOb20zWHIrWnJyeHlJODB2THFWL2VIUWZrWDZFYzFjSldTaW5SVlREMmhwNy9tMmdVc3pzcDR2RFhXbTdEOUVib0JrNVI4RTJjdWYrN0ovOU1QMS9QLzh2dUhXSkpDYTZXQ0xUOW1WOFVJTmRjbHJ3VXg4VEZ6VllabDlEdklsVDB6TUVoVjZDWVNudGdtZytPbVp1SVJJVnJ2V25UNSttT1dvejlTSE4yVk5kd2szQXp3azIvdWJzN2JQRXlsaXVwSjdPanZlbVozWFV6U1l4V01TQW5oekxVQkFYREZTR0VkanUrblN6aXlZNWNQM3A5VmVwV0xvOG5VYm9RMExpZXpiTnJqbUFYRGRlem9nTmQwVkRaVG1COEkxdWx5RmNWZDJSMkoxeERpbGExOERJdkU5d3FxRVBUcFkxa1p3YUpRa25XRU90NlRLUjk4WHdhOGVLa2g3MFZUR2RKa1cvSXgrTDZ3UUo3Nk5SWDdCU1lndlhQZEhkWEJpZUh3blFDcHZPcVFSZ1FLS3JtOWtDZXdDN256WE8rbndKUUkrbmRqV043bnF0REpnOVpHNjJ0K3JoeFFzUElSS0t3WXhLWWJycXZTNUFoZWxyZ1FFMWJzT2VNRkwwTGhNaTk1ZnhoNUhLVEp6Mk9Od0tTR0NmcEgzV1hHdVM3cVRYYmdTNzN6R1NlWTFjU0pYZkFUeUZndXdSSzdYbnlMeEtpK2JpN1dKQ29CbUFKb1RPZkxjRndhdjJPdi84Y2U4OWs5QlBpZG1RRHgxQ0huTThyRkZtKzQxSEVoU2p2N1RZdnJtaFNkV3hZYjVLSGJTWDJERHRhaFZzYzNvTm15eG9ldERjY0NOQ1VtQmllKzQvMlVmUE1Dd0hnRXVEZmtKVjQ5MVI4Vmt4VGtwbW5LOUgya1dualg2NEUzaHNCY1o1SVdGNWhRQk1tMTNvQkU1Qkp6dEd1TGRBeFgwelFORm4rcVBOU1pYT2VWV0M4am9kSmtmd252WXFHVjhhOVQ1K2p0eFpGMDdhWXVwUUMrMkF1bmdtMHBWenlYaXJ0Z3BXTHFDK3ZMY3ZuK3VmOXlsQUxMZEZtc3VBVlJ6M0dzOVJtOUFVSTNqNXZUaS9PTzR6Ykp2ZkJjUGlQajdQWThYOWVDUjA3bUlLZjNBZnp5c2JvTGRKSmM3dTduSTZ6MTU1T3l3Vmo5aHQ1c0lycjZTZi9QTi9rWFlRNTZlbW5oSGREbEdTdGxQYmVwRTZXK3ZwQWphdkU2S1h5NXgvQWpNOXBLRGU1T1Z6MUFBZlNxVys0WFQxdGR2c0c3ZWZQdnJpQ1pWTGI2V1p0WEphdUQ4WGpINm9od1RpT0VJVVAzdTJQLzJiZjhkT094dUw2Zi85NWQrbXUzY2Z3SnhrMDJNWCt1WjMzbUpTc1k4QlZ0TXZua2NBSGdIU0VIUWJNVE5rc3hORDVXcHo2K2JWZElVWXNjYjJjNlMwNjJsN0hlQTg1SThscDRvaDlRVDdteFU2MitpMGNUdmFuVm83M0FSMkE5ZTRLeE1WUzV2YlNIZDlxQ0F3QmdSU0FsdzZrYllxVEpZN1d4dEpmTWhmTUFOTTM0RmtabmtaNDVGNjhJNjFWU1JpVjFzblEzQWd2dzRHY3lWeXhkSzFuSk81Y3lDaGh1WllOWVA4ZVo2MEx1RXdTNjRraDRqOEZqNDArdHZ3aFFBdCttT0J3TGcvSUtDcUVsdXhRWUMyVDRhV0NXUW9rRm1Lb2gwYW9BVlJDSnp2U3AzdXNOUFg1NG9tSUdEbmdsakZBaVdBU3RUS0p4UkZwb01SdEwzc0E5N0daRzNqS1hPMXN6NStsZlBhS01vbkkvYVFJTjZQclVycE5jQWFwdStrVklKSnp1c21oZE1uZ1ZpSnlsU2p1a1p0Vks0cVkyaGZmUmxJYVRrU3MvZzF2aCtnYXROdHVvSGtBdzJRQm9qZGpyR1FPZTBoSCsycFRoY0J3ZFN0TWlFdmtZM0FXS2hxSG5LTTB3QlJka0lpUmFvTXlIaitOb3V4dXh2MUVRZ3JLQldlT05zUysxZWkzaXJKTmRqNlROdWk3YTBDYkNGSmNVNERwNDlNTGxQYUJzZk5jUUYvWXg0TVVuYlRGbTJYU3NuT2s1dnF5cUNxbmkyTWo0eVlkeEozem1WSUdKZG51c0RGZkhpZURBcGp4Mm9XVDhqQTRYSEhORUlVNkxlcFB6cUpYQVJiTU1NbytVcDdjUzFqb1RPa1NvQzJ1YVZsZzhOUDFWem5oQTVBMHpRZG9MTlBhZ0NaQnZPekJJOENhTHhmQVQ0MEo5K2ZkOEhFYTN6WEsrMTRxREhvdkNxdUxhN3ozZnZFUWdKWUNWaSsvTzdMNC83SjEvejNkVnVLNCtYYUNoNGViRXlIdlpUY0pTRjFpSHlxYTVPRGFmVE1BQ2t1Qytsdi90c3ZNYlN2VSs2WDBzZmM0UWMvdU1JQW1NZUZaTFZaVHIvOHY5bDFHYVAzTWdYK3QxRXpEcGlrRGRJMW5yMTRQejE3UEUwQk4rd1U1ZjEwblRwVjl4OHZtMGJHeEVDY01LTHFwb216aXdEa0NBWDRmdlNqSDZmZi9lWWo3RnliNmVJckY5SVlVY3E3dGMzVXRZNDM2d1VUUnlUOTVnSk16TUk5UUJ4UVM5dEJ1a2d5OWcvZitWWjY4dFZIcUpIVTVScTRtVjdNWXVOQ0ZiUjhja2N2QVpUUWdPRUcxODlTOGdaR05OV2pFeU01Wm5VWVlKdHl2K1Q3TURnVnBFdmpjRXFzYXJyUUhURDNpN05rdEN0UkU0SnJFUUJnV092UE15MEFZZ2RlUXJ4ZTFETXY2VzFGWWpTSTBpaDJWUW1qdUdNRlkwSk45SWIrK2RQVGhRb0o4ZVRBUTM0TXhNcEVFRktRVWhYQm5Nd1lUOForWVFzQUI5c1pCbjNtdHhPYldJQ2g3ZUtBQks1ZEIvcUxraXF1NWtvRVRqN2tHOFNqWGNtU0pHVWtRRDl2UmlRL1VsbVg5aS9LQ2lIeFdFL0ozRGlyVUt4amlBWlhJaXpFc0JaamVicVFGdldxdG9kTmpnVUFxY3FZS0QzS0xQUkk2WG5zSkZ4d0kwSXVCRDhyUHRUSXM2d2M0aHBoSUt3TnI0ZFJZM2s3OUFDLzhDTDRGTy9oUHJhbEppcWV0dElzUmNnUUFqWnRnYmwwRW5CTDdrUGo1RGpHeUR6T0R0SmZqSjB5RU5ucUV3d2ZnQVFvODNzM3RkM0tTT1VCZkRDRmpLd2FYTVh1Wm5LMWk4Z3hVcUg1Zm1HSDR0bFdncFdwR21SN2FMRG5hYlFIZXhuMFUyWmpFc2M4WHZDZEhsYWY1em50MGpqdmZrYmt3aHpDV0FCNlIvUkpoNGVoT1lxcEFwVjl0Zy9TaEl1S0M1SlNpa0RsZG5JUkJlOGNJMlZLT3pGMnRDbUFoUUdPMEJBR1JpZUs4WG5aZGtSSWhlUEgvV0t4cGJTMUM0SE5iWWVtajdFUFMyZVJGY0NpTFhoNXJxQWpZTmpuQUNDZnkvY0EyNkRSNkZFY3MydWVVMXpqZXdiSnJONkcwOG5lT1NpOHZLZjNLc0RLODMxNXZBQ3U0bDUrZDZGMTRkUmU2bjZWdmxwL05wbmVNNTJpaHlCT1JkVjlKSVIyRE41Ly83c3Y4YWFnOGdGQUk2aGxWODRQcDBzVC9lbmRkNzVCb09KU2V2endJYlliTmpSZFJyMkFhUGFJeSttaFJJMjVhKy8vOW1INitYKzlRMXdOcVM1NEJkMVRiZ2diaHR1VXI2OFRzNFRSWERGWHBtOFNjdkFGZ2FiWHJwNUwzM2p6YlFKSGw3R1BZYU9Cb2E2K2NqT1k5Y21qQjVTcVJYMDVVRlNXZFpGYzhPcDk2OXZmU04vNy9qZkpoWHlhN3QzOURDL2tYcHBtdjhGbDlobDBSNXhLbGRJbVBIT0ZMZEN0TzMvdDBubFdQTXJxZGlLTndFZ0lIZGpkSm5EWG0yNkIxSVFLdUxKRzZJWjF3RWxaa21CYUlaeVNqTUtTM3FaYXg4cXNuYzJBUnd2aEtkRm85TmI3WlZCZk5vQURwa3kwdGlvWjFWVXpwQlUrWnpVd3I1QXluZFZWWlFDM3F0SStwZWZQU2hLeGU0N3pFU0VjcUowUXFzY0tkYlFQQTdkcXRNblM0R09reWhnd0trZ292Y29wb1NaQzhJWnFlSjNTYWlUbnFoTHdlNFhBeU1oL0pNUmhDTStxa3FmRVRTdURVSFpOVVlFSkxFZGpiQld5QUJKeU8vTnMraEZCbjBocTdzRGpkVkhEaXV0a2RFczVHNTZnQzkrNllFUGtaK3Bra1JoMUNrUU1FTXdEcFFaelJXd1lZNUNESGZFZUFoem00aG5USndNd0RhaUlWbHVGaVdIUUpqODBZVjVoK0JCVjNIUWlHYzVuNlBHMUJsak9NcUJ5Q0pLeWJZb2RuQUJrUXlDMHFUZzJFYjNPR0FzQUVHUVlveFhkSElHOGpSdVNKTjVWSldubk5vQ1BZeVpwTy84eXNZdUNpMFpFamdkREt1a2g4ZkVuOE1pY3pvOGhNa3JzN2xYbzNHUVdsdUY1TnEvTTNLcUVBcFpqWlFnTTBpYjlDaHBUUXVjZUFRaWNMMUFDSTNIY2M0UGh1V2todmNSejZXUCt6Z01ES0FRZTdzK2ZOaXVsYnhkVVFjdStaRTgyNTNKbnI4c0JxOXBjSGJNTUxJVWtKZkFVcnd4bUFxUFhRZnYyajNaN0QzOExZT1c5QUN2cHdQWVdRT2I5ZlhuY3VmRGRlMmE3V2g1RE5SVi9MNStacE93cm9RWFdpK3BEWkQ1QnZha0RPaTBIczBoSHN5UVpYMDdYcmwvaU0zdjQ5U0k5c1gvZnpPTlpxb3llUTRxeUJqdk01NHJHTGpNMVBrK1F3eWNwM1hybGJQclJEOTlCUmJ1VS9vLy84TzloN21ZYVA4dXEzSG1Oa2pPVXBVRjZNNy9OK2JQc3lFMVUwQmZUTDlJcUpUNzBaQzNNcmFRUGZuT0grbHZEaEV0TUlJbU5JSnFEdUEyZWcvRzJoTmpVaFJyeSt3OStsNzY4OHdXRjE5clMxUXZuMHd6MnA4VzVIVlFXU29lUXFMdEltZ1g5akFGMzE5MDlWaHAyMG9OUzlNQ1ppTTIrZzZ5dVRzNFJ4THFGNGRqUWd5NE4yYXlFNnZ3TkdNSzRLOE1zZGtra2JxRW1WQ2ZlbjFZcW1nb3NHeHRyM0xlUzJPNENWYXM3N0VZR3AycWIwSlBIL0FTREdFMmVhMnRsOGYzUXBHMllVNVhFU1hNbDBYNGlFUnNwenpySG54SURvSU9EUXVhemxJM2V1Q3JxbGw1RmdSOHlSZDB5bGdaQ1FDb3poVVNRVWVXSU1zb3dxdXJDSVJIaFBpZGZvNXFtbllkaWhkeExJdDBGTVBlUkpEYXQ1ODVpSlJod1VxaHAwQStma1VKaFhNSGZpcXVXaWc2dmxnekQySnErVTZHdERXeUhuVWhORWxtZkFjZmsvdTBnOFI1U1VGR1ZGTGhBMm5DbmE2Uld3T2NRTDZVT0VYQWdwQ0pERmhyOGJnV09ZK3lkSlJhbmRpUmViYUhXdkRwRU91R1IwSVAwZzQyTTlqdkhZVGpIZ1NCNHFub1p4RnB5bmdIb3lOM2t1NnFTMGZIWlBrZHlNMXJCRnBKa2hZV3RYVkVTc0xYR082d0I2TENRbzBvYTQyYmhQdk5PVFh5MmZMWjJ0MGp0b1cvQnhOQk1xR0lzVWtvR1RvdkFyRW9vK0xYU1RtMXNnbW9nc00vZy90cm1lRmkwWDZsY1NVdWFjWUVMR3hmbkNSYWVKS01MdEpvWG9LZ0FlN1VCZ1ZTMTBwdW9raUhTQmVNYjVXNDllTWZDTmpyM2JXb0kvTzVMbWhBY0ZRQml0eWJVZGJHakNDWHduR3lIeXRLV2JjaGcrazlTV0FFMjBuQ0FEZWZZWDl2cFMyQVNhSmhONWlVNjh2VnZCYUI1RDQvN24rcXpjK1FyeHRWTHVONTcyLy95emJkdXN6MVdGcnZHa2FUbUthYTNCNENaNmQ3RzVnMTdlS1IrLy83SFVjbGg4c0p3K3VCRFN0RThXRTZYSjFFQmRocEVDVytsS21rVzI2VFZQSDIybEM1ZW1BQjh4dGxnOVpzUWsxdVFxMWVuTkRPRFVac3l2WjFRNWYvMGsyK2xkWUJDTzRhdTNsdTRYbDU3QUFCQUFFbEVRVlFBNGpycEhyLzU5ZnRoZUdXTWlhZHFTNC91UFNJUDhSbjNzSlFIUkVBVkFIeUx1VE1ZMS8vdTcvOEJZanBLaytlb1ZvazZJakZ0YnlQK3c2amRWQmkxbE0zeTZwTExHL2N3dFlRaWJSTVQ1RDkrQlhGbHRXS1h0SkV1TnQwWUd6c2JIc1Z0VWtpc3lxa0IxbExKNFVZWENCd3NKcUdMUk5sQkVwd0ZlTUdNcWVSY1BXTTllUWNhR016S2w3clc4L3hvSThzRVpLa1JBVXZnMHVza3NVcmN6a21VdElGNW5DdVpRWUEwd1Zjdm5FR3JTak1hMDAwTUYyU2dDV3crZVlYWEdPL0txYUZYQUltNlZraDEycE0weElmVUJPR29Na2cwRWxOaDQxQUtrS2pjZEVJRDlpRkdmU1VQRGNrVm90ZGxISjl2bTExSXRNTUpRQ0VWNGEzMWZvNlZvUy9hajN5V084dVVXVkM2a2RyZEN0NVZ0M1JDSFhqbXg1Q1VLTEVEVWRRWkMxb2NFZ3ZOaG1ub0U0dWVOcUFHWSs4Q29SUnJwWUpqRnBjU29HSkJSRVl3QU1jcUJ2YWpGQkhjem8rMnJLeFNXV1BOVmI1SkFyVWdZTnRNVlZKUzdVQXkzUmNrb1V1Mzd6Skd5NEtJcXFaVzJ3alZpUEZWaW5IdWxHVUVqMTdCaTRYTTlDRkJQL1lGQktDekZ3eG01dm1SUGNDMWdsdG9FWm9Ib2szUUJDcXJrcGhwWDNwYitRYjE4RDBReVFkS000QVNEWE9PeklPMWtUS3FURTlQZzE3Q3ZzTTFNbnhVZnZCY244Mlk1MXhUSlMzbjFXb1dPRHVnTDJsZmdPUnBRVDhta0Vka08vY1JEQUljNGpsWkJlVEJQRmZReUZLOW5rWVJ4ZkgyVDZtdUFDdmJwMFRFeVp4Qm4raWpMeDFHcXFHQ3RML1lmaVZKKytmTE52dFpXcExPNGo2TWxmT1crd3d6Y0tvODRyTkQrdnp0VjlQcDdQbUpLUG55K1lObkJHSnVSYzMxRXZGL1AvamhMVUNJV2xQb3dnZllkNjVNWENUSitFSmFmdklrdlhqNkxGMjhjU085ODRQSjlQRURTdERnTHQ3WlBFclBIMDhUakZkT2YvczN2MlNqQ2JZRTZ5VWZDMEpZbkYrbUNOdzFhbFIxcFZYeUY0ZUdPZ2tsTUdTQlVySVF3R2NmZjVKV0Z1YW9iamtVUk5XSlZOQUZDRFJaT1piSnhyY2UwYzRld2FXb2hOcFlTaVRHRGcyMnB6LzUvdHVBNTNDcWIyMm1oMTlPUnl5TzJlLzBFbWNDMGZKUnRRQkRLY3c2T3p2UDdqc1hTRlkra3paWFp5bXkxNVV1WFI0TjQzd0xLLzc5UjNPeGd2ZWo4aWt0S09QMHdLeFZ5dWxhNnFVajRuZVVjSkF3SUd5OUw4YXp5TUFNTVRZUUNCbW05azhvVTFJVFFDd0YwNFJCREs5UU5WR0ZrWmlVTmx5Wm5CemJ4d3h6YjFOb1REbnBEclhESFpWVnd4VGRGZG56SnFnd0E5ZklSSktJcTZpQXBVZkoybHhLYUZhVGlPSjh6TFZCam1ZRzdDTkptazlvSHFGTXFvU3BkT1h2aTZUNHRERFdsbldXU25xd1VWbmRVMTZTTU9zNFp3Uk5ZOGtFM3FnSGhjb2lHMFZZQWtOZVl3R3p5dWtJTzJ0M0kzRUw1RG9pOURJZW84NExac1pNV1JhbVNRSzJnWitRRGJGU0dvMFpCNEZTNUFJa2pQSEtrZGhjQzRDNXZiMzVyZVlOY2lxamF5UzlDNEVxTkNFcWpFR1ZNVkM2RjdUc2kyM3BaUEhTSTJoWVJrZzhuRkZqYjh4ZG5wVlZhTlJJbUsySjk5Z3gycVNNdHVrK2JTeGFWbWxvRUhqcXFxK1gxMWdtSmRadTVsdDdrODlTc3RTR0ZNdU9jOEt2OHFQQnZnRXdNaVkvMFBWNGh6UmdZQ3RaQUM2Y3E1ZFJvTFB1K2hFZEUrUlUvUmlGQUFBL2FKTUt3N2tWVnprbTh3b1l6aE1YeENLaVhkS1g4V21HZ2hpV0VaSU4xMHB6bnQwQXNKc2JoQlVoU2ZlWlRnVi9HZmFSVThuc2dVL2xucnd5Q1BPTisvaTVBTFFzT1FrLzNsK3dFOUFVQ0JnTFFUaWVTMS9qSDlUQmQ4KzFQYjZNTFpQbWZaVzErZEkrKytmOTVSVmJZTjhrQTRZbHdONUxzOVRIczlwSEx5YzJ5a29mZnZVNW00WU9wanJxMGg3TWVldnFtZFRXcWVxeURNR1JQNG82aUVXU1hWaFdXSTIzOFNnT3B1OS85L1YwNCszV05QcnBFeVNvdFRUM2FDcXR6aStsZDMveTdUU0JrWDV1L2grWmJBSUdCOGZTMDYzSDZWZS8vQ1RkdnYwNjllRUgweWQvL0RndExLM2dRYnlhcnAyL0FOanRwbkdLNVdtWGNuRGRXY2NvZHRMN0lmb2VDQkxteC83RWZNQUkyRWZ3L0YxbHV6RUpzOG1Pei8vOHozOUM1LzZBZW5ZMzlaSEhLRVB1RWFrL1BzRldZQlRRMnlmNWVXVnhJMzM0SWZZc1FpejBRbGxoMVNxcXU2Ump6R0tvWDhVQjBkTTlDR1BpSldMQWpTY2FwQWpnb0p0S1lMUlhuQTZwQ29sUEVkemRYQ0F6ZmtmQ3dLYWo5T0ZLRVc1dUp0QzVkMFVWdUdRWUpTNGo2WldtVk5zOHhRbDFrcFNhWExFMTRwdEdZZ0UrZ2Nzc2ZxVXNBUWxhNXJsNTlUYTYyOGxYUkhmbFJGSGlYQWdkQm5LMnJYa1Z6SXpLS2tGSTJLcE1rcEpsVXR4Y1ZSdEdHM3NJQ2o2cXhZcnlNb2EvbTZvams4YnprQklzTWFNa2x0VVBYZlF3RnVkb2Y1UEFqTkVhWTJ1M0M2VGZ1TzloaVpBVjYyVEpxRkVwZ0JhRzZFOS9XMlArWUZha1hDV25BMEJvRjhsV2gwaWJqTTV6QkFJSmVKczVOQ1hJT2xjMUFHc1haNDg3VU1QZnZGaFNYTEhSa0J3bis2aFVwRTNHdUxBSzc5Mm8wR3BkQnI5dVkrUGNvVTB1Rm9ZMEdFU3BnVjJwU1pTeHIyRlBCTGhPVEo1RzlkeER4VlpTZHlGUlpWTlZ0OWE4WTZSa29pYzZjaFpwb3d0UEIrWVJXSmxqQnM3U0RzWmMrMVVrTlhPdXc2R3h2VVVKS0VlNVJueWR0bG5CUVcrbjh5WURPMTQrMDkyc2xaN0RDOGk5WFdTOHQrcXcxV2tkWlB1dEpLSWpSS2VNd0JMU0YzM1gxQkRneUNLZ0pPU3VQeGJsMUViVWhiUlpRdkp6ckNNSmt1WVZhcHp0OFUvYUsxNThEZkRJdnluWktYVkJ3NHlwZ0dlZGVpVksyK0o0K0JMUS9PeDlvMC9TSVFPaDh5MGNIUGJ6OURjWDRLaUJScC9zZzljb0xYcmNlNVRiKzBsMm5ucVFObUhvZzVYTmRPM3lRTHAyNDN6cUdlMUw5eDUvQlVQRE9KMHQ2Y25qaGJSQUliZFBIajdqWWJqN3U4OWl6MnFrZTlOUGlMT2h4RW92YXR6bGZsUkpBdlBXRjlNWmRocjVOLy8yWDFEOWN3cEFnTG1aQUpua3p0MjdxSkZzY0lBZHlQaWFxZWN6SlBIK0xYbUtLK2w3MzMwelRWNjRtQmFXaVc3SGJpRnpIeUgybXlyaU51RHRFR0V2NVZ2YUVXLzNDRWhkV1p3bDNJSVlzTWxzSnhHdFZ6R3dIN0twYTRqYURNVFltYk13U0R1clNvTVN1TmdyWUl3OVBIbm54b2NnOWlwT2cyMkk3ampkZjJpU0xnT0NOSFhBeXRvS1E1NEFVZzFVcE5WVmlzMmhMbGZZWDY4RDI1VmJlWVZVQTBQQU84RWcyZ0JLdE5Qc2VxNWswTE9hclFyb3lxMVVJaWdJZUJGM3hUa1NuZ1FzY1RxcDJsa3loM05UQ2NoZWNJTEJxcUgvQndGSkNEQXR6S0l4bHk0RzhVcVFTanJhVVdJWEhVQlJjSkpoZkk1TVpGUys4VmVxNGp3SVF2TVlaV0tvNWpCTXVwUk1ablQ4Q1F4allySmVUc1Z6aVZSanRsSzBwWDUwQkxpYVNueisyZllXdkh4RFZJTHR4aUR2WG5odGhKeFlyZE1PSENJNVdLRFF1bHU5YlBsVlkzeDNsUFNRTXZaWjlhMjhxaFNxaEhqaU8vMHJFVHlyTjdmQnZDdnBiTlAySGV5WHU2aUttdFpNQzNKUmNaczBCZzR1QXl4b3FHRFN4UUtsMFQyOHVSenVVbUpDR3RNN3VFYXl0bU9zeW0xN2RLYW85amtIU292dE1GcDg1bnVVLzJHTTlFN1d5V09zZEZDcHhBWEMwZk4veko1OXQwaGYvZ3l3TUM3T25TQnVvS3IzaW1SN2dNZ3gwbTVycWUyczlnZzBBQlJqZ0JVbURQaWlxelFoY3pydlBzY3hyckNROFdPZVgrMW9NUytNRytlckl0b29yNHlGTFlZRWRaWm5xMFlwL2FqR0NkUXVxdTBzUk5wc0JSWUJ1Z1hBY3RrTWo2SDM0YUgrK1NxZTQyZEJMVHljSE9QV2NVL2I1cjBOOFFqTnhoTjV2UXg2M3NQdmprVnh6Q1lMYnBZL2ltTThMbzV6amtEcytDalp5U3NGV0FWNHZaaGJadk9Ib1RDbWRzR2dyN0d6eVFEaTRnTDFwTDc2ZERuZGVPMFNUTitUWnFucC91V2pXZXdPVm5JY1RzL205OWl2Nzh2VTFsTktWOTQ4VDFyTVpGcDVNVXVzMHduMTFWZVJ1R2JUaStVR1pXQWVRSFJzTDg0S1NLNHNSazYydHFjeTVPRWhSbDJZemppakhaS2tLK1ZPalBnckJCQit3a0EzeVNWazV4TzJDWE9RSlFhM2VPckVKakpFTmRQWXhvaGcwSGZmL1VINnk1LzlsRlcwalpMT0sra096enBBMVdpdkVFZkVkVW94cXBBdnB0Z00xcDJNWTdWaU1DRG1BZEo4ckwyMXViV2E3cUVLenM2VEs5ZzZ3RXJJMDZBNXZYN2JBUFJ1RGF1WmJtQ3FBMWdhcGNJWU9YRHRxSXB1bk9CbUdaMTYxNWc0YmlDdGhraE80RHZFcFJnZ1ZMaHk2MjNqeDlPWEJtbGpveFNQd3lZRjB4cFlhSnBSQmFaUTlQZlA0bmV1ME43SHZ6enBFQzRyYmhuQ0U1RENCcUJxWk4wdkpBaHJYaW5aZWExcW9XQW1JTlNRRkxhMnRwRTA4RVpDRE5hcXR4cG1INVZXbFNDa1VjVjgxUjJmTFJISHBxWklrWUtVQkY2bC82bUY5SlZZOFFGMm5pK2hXd05zaEFvTU5KMHhGNWhkdmZFaXFsYlNGaE9ocDJlVzAvT1p1ZFNGZmJISmJ5WVpheUZxUjQzVnUxcGxmc3JNMnpHaER5ZDRuay9wTzdXWW1NNldjd2VFSk96eGw4c0haOVhDUUZ6cllCbXczSXZEcUFkSGpBVVVUL2p1YnRlUlE4ZkdOdnZRclVDdnl0ekdIS3RPbStJa283bmZZTlJoSjhld3dvSlZCY1ExYkF2K0p3Q0ZhbHVkOHN5NzJ2am9tM01rUTRlcXlQMlVxa09ka2RFZ0hrSE0xU1RBaXQ5OE9YWlNnL2MwOUVTbXpNd3VzRHEvYXNKSzV3S3g4eUF3S3FtNFVIQWR3Q3I5bGx4SW1UdUJSdHBSYmJiOGp0S056NE9NZUdsWDFiYVdBY281OG84ZkFvQlVvU1A0MWxBU0FMOGQxVmx3cjdCSTJLZmlGYlJHUDVYUVE2M2xzNkVWdGx2bFRYcnhIUGtCeklyM2NETFE3dHozM0NZQnk1ZDBMcy9iOWdodG9tTWVDVkNrNGZFOGVoMzNQZjA5QXpDU0xpRHRxN1ZuYi9XOXZaMzFkT3ZHaFhUcjFhc0VaRzZ4b2NSZStydGZQMDBibXhyTFd0S3JyMTdrQWRwb2pQd0ZkR0E4QjNkcFlRMDdFMEdJRU1ydDI3ZlN1VE1UNmN2UG42TDNWd0M4WFhaTytZcUJxcVovOXVjL1RaZXVYQ0s4WVRWV1M2UEFMMTY2Q3JHeXVzRm9KYXVlY3IrNXBWVkVmdEk3RUZtWFYydXN4QkNXWldZNHo5d3BkZjhxRTZIeDI4MUtCMURuTmpZVzB2VFVFNlN0emZUUkgrL1RNZFVERW5PaEUrdk9iN01SckRoaGVkc0RKdEJ0cmRvQUg4WGxQaVNMcWVmc3N2S0MxQi9hV2NhbzN3NkJxRXE0NDQwN3pkRDlXTjBpM3NyS0RBU1hXa2RiZ2k1RDdLcGgycGNrU3lmU2xTRW1CVUtLbUJrbXMxaGhuSWd3aEVQUW5QcjFOVEVSTUpBcE1oRjl6VEhWTVdPUXBELy9vSXRnRWczWUVsOEVnaXBkT05FeDYwZ2RFSU1NNGZPeTNZVjhJd2xWQWhJZ0xPS0hhcVhLSVpOcEFCVjBWUSswemNqTVZYTCtPakdndXdLNzRhcjJNKytsZUc0Y21EWVcreXREV1VwYXljOXJod0gvWHNCQ0lGQUZVZExzSm1pM0U2OXhCYldqM2FSMURPNWY0RWpScEdDTTFRNVNid08xYUdPckZsdTd1ZHR5Ri9lMlFKOHJoOFpvVjJCVlAzQXFyYUxTclJHM1ZVTzlrNG5DOXNINE5rbkxzUkRnNVlzWDhBd1BoTlBDRUJDQlhqdWFHM01ZT1cvdEsxVXNyN09Va0t0M3VQUVpSME1mQk9neTczcEJCUmpwVHRYUERBVTl0ZUdBQVR3Q1NBQVp4OEdGSUNhU3MwUFNEQWtOZXVWZnVPWDVIaGtKdkJ0elo5VUUxbEJBMEtrREhBSUFtQ04rVXlyVHN4dmVQVlZkRmtCZkFSRE1GeWR3amFFYnh0RmxZQkg0QkdLajk5M1VXQnF3N3dLcVFPSThDeEFDcW9aelZiV3dvVG8rQUlqbUMrMW4zbHUxTG4rV2JKVE9UNlZOQ1RkZWdBbmpJbmdGU0hHdjZEeGo1cnNqR0FBV1BPMnhVeERqbXFJOUJYaUZJeWJHMkVkbmN3RTNDUHJLd09Wbi91TFJMZzd3R24rdEEwZnB2YVVsTm1nQXVYZEk1L2pveXhmcGQzZVcwdUlPSldTUWVoYVhGeWtsMjVQZWZ2TldlRlRzOUNLMm5sMVdXQk5jWFpHUFVkdGVQSGthTmhlMzBpcFhCOU9IZHg5aFlPOGxEL0hWOUNmZi9YNnNXZ3Z6TXhEck90Y2RzNXYwR01SQWdqUFhXaDVaRzRRMTM3Lzk5dXZzQTNlT3FxWkxFQmtEVHFlVnpxeE82aVFOOVBhUkpEM0FvTzJ6UmRUVDhCTHVZSEIvZE84SmhORUpzdzJ4R3BYWmxwNnR3eUFPZVZsRHNjR0V6RTBBbnB0Q0tIMVl1dGJkcVMwSlVDVnEyLzNyck9aZ0lxNkFNVWo4MENpZVRiMmJidm1sa2RLOTFMVGRSSUUrM2gxRVZ6a2pqVjN4TkhCTG1CS1p4R05DclhxNjA2a1VvU3FwalNHa0ttZ3VqSzBRbG9Ca2RMVU1KT2hKTURLTng5MU1RTkR3V1RKUVNEWGNTeUtRV0NVMmlWU0NWNzFScGpNdnprRFFXTWtZeHdZT0FRbFhRc3Z2ZU12b2kzc3Bhc2ZROXFKM2xNNEhvNms2R0prdVFNVkdDb3lqY3k5UUhhSUhiNlBlTHkydElTbkF2dFE1VTIxckE1UUVLQmNDazhQYjhPcTFJRm1STnNEaWhLcldONEtIZFN3QUpJQVZadDBtQmNzeVJTdlE0QWJ4ZHhvcHJUUG1KZzFLZFJYS0Z4Mnc4aSt5VWNRVHdtRnFBSTk3QWJnNUFxY0JpaGo1U2VHNmVaUDlBOCtPMGcvNjdKaEovVEtLVWk4eXl6NGcxNFJtdFp1WmsrbnpkV0pZeFVMVzB2RHVJcVlhS05DNUtJYUVpOGhveUlqeFZxcWdEcmVMbjFLcktyeHFqUXptWEFXd1EyT09XY3dudjRWZFNiR1R6NWJtRVRRdG13eFBoNlF2czBxam5zL0hhSy96bXhsYzZRWHBoaWQzQU9JQ21MLzdUelV3Rmk1QkdjZUd3QncweHB5Rjl5M09oV1pZZUZRTHBRTVhuVXcvUWk1dDFxWWdLRHZYL05sK3d5STg2cC90VXR3THJ5RFBFOERzVDlaNlBHaTdPWXUyaDJHZS9qbXVZYjdneHdLazVOc01jSTZaN2RDTXdJTFA3MzR1K3V1NGVZM2o2YnZhZzFIOHprUGNuOEZ2dlZqdGVVOVhxQ3RPcGQzYVZ0U3pTbWJkOXhORXVVcnNEaVZqOGVwTmtMWWpvMjZRMzlVN2NBYXBaZ1lHTEtXM3YvRkdldmZIZndKQjdGSnRkRG85bmw1SnoyWVcwNWQ0RGhHVzBqTEE4K2pCZy9URm5VOUprZWpBNEQ3QjVneGJhVzRHUUFJdzZxUXNST01oQ2owckRiN1hXQ2syc0VVcEJ1cUZVNjFoVERROVVFZ1FrUitwcnJiTlpnWVE5N3Z2L0VtQTRkM1BDWUVnUW41anc3cnhUQjBESzZNZllBT1JTQjFZR2RDb2JJblJIWWF0MTM2Q25hSGR1bHZhTG5sR2tDTE1vTXBuaFV3M2ZPM2hlZHEwdUNWdGRhb3pzWGlCaWNZaGFYZ3RneCtyUGdOcmZKYnFWeGhLR1h6dEpVb3RNVmtRaFpTdlc5bkpsU0NjTkFFbXRxNkhNQVJFRGFzeWxlQ21weTBtTjY2RktDQmtKYmhJWTJIdUpHQnRGWmw1c3BIZUJrZnBYeVNyR3VLcUJscmQ5Kzd0NkhtcWdlWWFLakZHKzNpM3ZQTC96OVNmUGV0NVpYbCszMFBNOHd4aUJnaHdTakl6bWZOVW1WV3RWa3U2VUN1cTFSSHRDa3NLUnpoMDQvQi93Yi9FbG54dDM5aVdMaVM3VzFKM2RWVlgxcEJ6Y2g1QUFpQXhFeE1Ca2dEOC9heUhwOTBIUER6bnZPL3pQcy9lYTYvMVc4TmVhMjFnemRxYXpZT3VBNEo5b0xuVUs2cjJPVmV2M2xnKytPRERjYlAzMXRkZGZPZWR0OThiSUFUeWFPSkEyMDI1Zzl2YU1ObVVSYjFwa2xUM1JOT0RLY0JqS1lNTzZpMjI1TnhLblQvRlZhUTlzR3kxNjhsZXpNSysxL3dyU0M1ZTlVNDhkYXZVbWUybDIreHI1L2xRMXZXSlp3OHN6ejkzWnZsbVBkek9kM0xUTGk1d0tRKzZSUUI4OUJGRFJKZWJ0ejlyaytkcWZOcEdRT3RHV2RtWUlacVVoRXhxMzJOMXRCWk9KV1paYmF6WmVxODJLRExYZmRzOUpFU0FpaUNqMVFnYk1lLzVyRmpDQ3dCWGF4a1BGNFBMSGJ1RjcvcWRCUWF3OERacjE2WUlQdWkyOC9yS1MxeXZoTGoxNW02dXBTOXJHR0FGTytzZVFQYzVZREpKekkxSldnMWdNUjhiRDdzQzVuVmpBZ0I5bmR1WEJRK3dBQmMrbXRlN0hzOU5Bbkw4Qnh5N2NkZkJwZjdGcnl3cy9FT20wQkx2VVphK2pIVm84alU5ak5HY050NmI5NGRlbEI5WjZuNk5GNkN0OTNSZkZQSFlidDY5UGRudTUxaWc1N2Z2Zm4waXh3V01ieFEzK3ZJaERWL3ovYm94UGlybW9Wemx5MkpKRjkrN1ZOM2ZzZnpkVFIzWGRTdlhxSVorMTIrMWZiMjVtRVRNMGNCKzg3c1BsMS8rNnVQbGFzeXhiZXYrY3JnaVpyYnY0NnlQRlBmeVgvM0ZYeXgvOFMvK1lubm5yYmVYaXg5Y0t0aktFc255Q0VpK1pFMGxHTnRMa0h6eGhlY2o5SmJjd3FzbEp1dTF4RnpsT2xhSDFwYXNRMHV2RjFQYmxsbCsvdlRaQXZCZjF0bjBTc0g5VGpYcG1ROCtiL0pOVmc2WWszNmZhY3VhWnRIRENjRjBXZWpSR1pYcXpYSnoraDFSM2IvSERSRDdLY0FzZjBzRmdQZUFpUHlhdUh5SWlOaTBndUQwOWdRZkE0N0pueURvQ3RxVk1Vc0htV2JKTU9OcGltSGkzbGtYeGR6WDFBTEFRYlBqRGU5WkhLQW5VTzlHV0VmQ0lqY0pDRTM4b25GWjZKWHBFNUlzUFBkM1BTc0s4S3VidTExc3htRzF6dmx6T2hGRzIxMWNTQk0vRE8xTVJvS0pjUnZDV0JvWWMvNTFyZnNDWG1jSjNpekY1UFBvcHhQRHJqNS80Zm5ubzllMmxOdTE1ckoxMlZ2aTdKV0s1ZStVT3VFMDU1Mjc5d2RHcFVva2tQbmRYUnNZOXJmMTNWY0t4ZTdTTjRBV3BpeC9wcDNaN2NXVU9uVTdNTDhkNEQvTmdybWZHM3RiYjY3NFhueEtLT0RNeWNQTFMxVXVmT09GNTJwOWRLSlVoQ3pmZUdrM3Q3cTFWdElob2ZkNjgwYWZXOFVqUDh2MUJCNHMzTnRaZG5jTEYranlRREFvQks4RHUxYW4zMm4yVERqMC9ucitsQXpYMG1HMkN1Nm5hb0VQRUwydFkvSTNidWJhYzcwNFV2ZWJXRklYK0oxN2RyOTUzTGhWWVQ1TE9DWWJxenZldzVkdU5BRGh0LzlBNEQxZnFzb0dHTGdVQ0lzMUV1UnAwTmU5elhQRGttRnhBU0QvWE1NaWxlYWhwTXBTQUtwZHVkRjdvci9kNlhWSGM3V3N6R2NkejhxTEprWStCcFI2eG9abDVCN0FaZ05vek44Nmp0VVZHNDZDN1hNKzYzNy80ZmZjb3c4TVQzLzluay83ekR3N2RoZ3ZJM2tENEw1R2dVOEJacTRVQnVYQzNJcWdOWnVOT2NvN3lyemV2cW0rVDZIdnJXSktmLyszYnk0dnYzYWlHc0liWmFCL28xMmRrOHQ3NzczWGxuN3hyRTgrVzY1MlFzM2UwZ0EyeFpCbENwUURrNEFXOTRvZGx2Tm5YdWdJcmw4dGYvV1hmMVg1emRzSmlDTGNUUVg4NjYvVmd0eHBFUW1ybU5DcGVtN3RyRmJ3cmJmZjZ2Q0xHRFdYZ3BXbGxvc20zbEUrMEdxSmZiWDgvdmZ2VGVPMVQ2K1VuRkVNYWtkYWczdTBOVVFTcVBROWRXOWxaWXQ5UEU2TDcwd3d0UWNoaUpNSTFIUHRCQ0hpbUhHOUIwakZtd0FOTUJLbmtiaXBjbjlUVzk1Mm8zd0RxZGw1U1dpbkdKWE9iaUlTRWdHVjkreGVicmhqNmUwWUhmTzVmd3NXbzAzUXRqRURBZTEvN1RnQ1J4MVd4YlFlWmNGOEdVR3gwd1p6QVFjN2poWnhCQ1hGNEJuZHRuczZ0YVlrMnNEcVFSWXlhK0pXOUpYQlRyQU9IU29udjkxV3pHck80NFp5Vy92V2hzVXVJUURGRDRCS1l6K0IraTFaVEMrOThrcEFkSEFVWDdxMElIeW5RdCt0VDlxekhiUWFXRWxzVlNOcTdydnE0c2xsaXRWR0NlSzhTREZyZWVEd2tVN1JUdXRIVTdXSGQ4cU4rdXhtOUkxMjJ3TFFXMW1DdDBwbzN0b0JyTFpkZEdIWTFGaVNyZVc1azBlcXBMalFtWmUxSTRyZnRwUmNpcDVmUE16MWFFMGZCaWlDNHhqK1VVcG5keGJHMlhPbkcrT1JhSzYwNk1CeTlyazJkZ0xXQjFseGN0TytqTzV5NzV5b3M1WWNjYTNVZWtxMlRWZ1RPbTJWQ1MyTEFtMCtmOXB1WFVEQWJSZGZGZiswRnF3bFFrYjRmQ3ZUb1dnQURXdk1UdU45bHQ3WHJyNHM0RkZrZlE1WVdrUHVKbVhpTTQ1OGsvMnVjZUJZWVgwZVdMQmtqSU0xeC9BR3RmNzJOV2tOQURoZVJ3dGxYNS9udlRqL2NWZWdCZEFBSVo3Vlh0dE9jbGowNzhGbm9DNU1NTmUxZ2FTUitkMU9jVFJwenNEUi9QQnZQK2JMTmVQQ2pVVm96azJnTHo4M0xLMzFiLy8zRlBSanRhMUFSWGJ3Q0VEMit0UkdSbk92TmF0bDgvTzdkN3h1S04yeWgwYllCbW1TQ0xzbDYwcGxkMk9JVU9YQTFPZDZlOHh4NGZ4enk4Y1gzMHVJTzYzbTdMTzFUejVjUGQvMXJKc3NtUjFsblhkZzZlZVBpODRYM0dZMlB5cGxncWI3K1BLbG1PL0w1Uy8rNno5Znpwdy92THoxNW9jdFZCTXFvSDZzbGpEN0txKzU3aHpFd0VQVi9KVXJWM3VQUzFoSHlCWkxEaEJUVlZuRkZLbzJNRHNrTjZ2LzIxbStGd0ZVbXZKVnU1SVovWDMyMFp4WWZPYk0yVndaQVhobjgrWEh4eGliSXVpV3h2Wk14QjVtaWlKb1MxdUkxUkJraXlxRjRVakhRUjBvMk80RTZzbDV5bUlUaTJLVkFDUk10R0hsQUpMWldtLzhoSDV1Mm1qRXBWQmRQR0hqZWIwUVRYT0JLNFBSZjB0Q1gyK082enFOK2ZMelIzdkZHQ3d0TGgzR0JuaHl1OVpjTGhaVzhjVGUrOUx1VDh4MFA2QzZteldoaGN2ZFhMajd6VnNjeWowUDVKS0pXd0V1cmdUaDJwbUM0ZjZZcXlDOGtodUNDcXdNbTd0eCtQRFI1ZHk1OCtWWlhVandqd1ZPdFpMcGV6by94UERIanA4b0VmZmtXTFkyVFk0ZVBaazFWQTNocEhuRVE4Vjl1RE1zVy95RWpWbkE4cmRHQVRXKzI3cHNOQWVOR1QrdFFlTzFUbkxlWGNFeUFMd1o0TzdNZXZyR1MyY0xRN3k2ZlB2VjUyc2pkSGdBWm5OS1NRZUpFWFlDMHhyc3JSS0J5MG5SSE1oTlBWS080YlB0RE85dlkrQmd4OEFkYkdmd1VCVWFqaTJUeWI4cWtYV05wSWZndCtHSENNRHFNV3pLZ1hDS2kxazdrMWhCcVN1U0dTaU9iOFphVFlMSFJjTkgwZG9tQ2ZrU0hLZWd4YkVtQmFLSGtENzh3emtFc3ZJTUNiMzd5L0ZiZytYdXoxQ0ZUQ3NRR0I5Z2NpRWVrTHNHTWQzSC9RWTh1eDdQamR1SFo2THpkSGJvcDdYRlUxTjkwVS93QVZqR1BRc0h6TTA5ekV1S0NZTGdZMDljLzdlT2U3QWllUmhBNmszeEw5ZXRzdFR6bThzR2NQbm9obGN3ODBDbjVqRHpNb0pSQnNDUVVuZC9ZTFdPeS8yM1BNME01ejZ0ZFhNSXRoS3Q0UWJ0RVVLT1JnTEtSSDlTMHQ1YmY3eXl2SGp1cGVYNTArZVd0ejc4UXdLd3EwTG9EOEtjVG1iT0JYandSZHJ5ZHBxSDFpa2crcWljS0tlbTdJbHhqaDZ1aVBxbEYyS2FBeE9maU1jQ2p3Q2szSzFUSjNjWDJENjVmUFRCMWtWd2ZvMWhoZHhBTTBKclJTc0g2OGMvKzJGQTk0Y1cvVjZXUXEyV0F5OFd6TUhpWTQ4Nm9QT3JSM2VXRThmMjFPWW13ZXlrNHZ0WkRCKzhkekdYUW81UklCeno4K3AwZEJSb2ZTYlE4Y1hOWW1WYUlRV3FvK1Y2Tmg1UXZwTVJVSTVSYmxzV2cvN2tZaE1JYUZFM0dBNlkwWHJ6MVl2QXhRSzRoclo4MktJVEJHQnJ1MTJzNTBGdXQ4V2NSYlBZZlk2bHhOeWZoV3I1MWJUNUpnQVAybHBYVS9qVUlrZTdMUS9iOVJMTElnUjlUeVo1OS8rY1ZUWTdZMXpiNXRNekhFdUdBZDFmMmNldWd1SmMxbVBIam1IVjZGTjlYblB0U1ZrdE82clA3S0NJQkMzeXhsQmlMQUYyOC8raSt6MEo3Q2QyQW9TeVJMaFV4cnV0TmlaNytwd2cvbzVhK0l5TDByVUFjc05LWUg1SWhLUXhXVE03ZHU1ZFhuNzVwU29kUGwzKyt2MkxLYjRPS2MzTnYxL1B0THZGaTlMcFBmT3I1U2ZmZjNYNXhjOS9GREFHbGpWMmxEUWN5YnBkYmxzTFJkajFoWkt1SUZoL1BBRGRYWXp0ZGlFS3NUR3hHUWVsMlBHemVjRE50K3U4SHFEaHdOdnFPQU5RTHFKK1dHdGRaM3lTNGhveGpYaHp6bU4vczBvRnhJRVBpOWp4WnBvdkRtaXdySHRmSEV5OFZEQmY0RjZDTXl0NVQxMU5mZmFPbUYzemtxYWpEZk1JY3A4bDRFQUcvK2hHd1ozY1VUTkwxaFB1c3Q3RzVHczJWcnIvMDR3Q0d6QlNQUENWSUxvekU0YUhHc09PMW1WYnJaV21IS2RuczVwdFJQUldQMnNJa0hMZHZ0UG1GeXN2bVJUUGl5dkFLS3NIN3cyRDROSG14ZkxDMTJqT3VyVU8vamFIYVQ3WU5UN2orYjY3YUlEV05iNkFJMFZvcmhLcHZUN1g5cDduNFRkQVNTN1dXSmZIWjFVK3Yydkw2MTVNbHVkRFBYK1lkNWcyWmpTWXpKRnV3Z1JOSzVjaWNPbmk1V3J5bmwxT256dFdzN3VQS25PNXYzenIxZS9NVHRyNzczNVEvVjg5NEdPeUtSaU9VYmJYK2ZIVTJhTzVkUGRLSVhoditUZi8rdDh1di9xNzMyVVJmSlhtMjdIODB6Ly8wK1UvLzZkL1dxWjdtaTlMNW8yU1V6L3A5T2F0TWZ6c1VMU1lSaVVoOFAvMGYvNXYyeVVzVS82WGY3ZThVZzNpd1FUdVdpZFhLOVdSakFvby8rTi8vSlBsei8vTGYxWXY4MTNMYjM3N3gzWTFPNDJsNEMxTFNJc1VmYkYyUnN3ZENSbHJSK3lNK2VsdzBNMkJGT3BiQUxsY1U2ZEgyZFZyU1hmVXJlWHBLUEJsUmMzV2JBU2JuWlh1YXdGV0FhZnhzMXhpdmpIYjNTZUEwa2RKVXVmOWlyZnYzdTFVbHBqZDZiaGpRamNtUWVCcHBaTGxRWk9QUmRYcnc3aU5FUTNFNGdBTEs4RENHamR6WHo4akxxNGNHd21pQkdMd2w3WFlaN2kxeW9sazBPL1BhcEY3ZCtEQW9lNG4zZURPeEhqRWxvNElpQjg5bWhWMVBIclhTeXc2QVNTV3NyaVArSlhhdmt1WEx3OFFiTW9LOUt4YmdRSzNVVG5QdG1pdFRJbUFpVSt5UW8zWHJoLzNCZTl2Rk93T3EvZUNqZzkyWVM5K2VIRjVKd1h6SU9YNEVBMWF6ODl5RjE5NTVjWGxuLyt6ZjlxbXpaSFdyTjNwQkFsSWoyVnJzWG9GMDl1aFhmT1NiSWlVdHhVb0FPZ3BDTzludHh5RndVMUdWN0V1eHBHMXQraVVrRGdYaTlPNjBQU3pPOXBGQkdhRXIzWGdzdWxJQVFRbkVEMVNBMEFDd202RTE0QUFDNVpRdXdkbFlITkw3Q3FTTlY0N21KWE1VSmE5aGs3dUQvVHdwYzlNNktIWHhUZTc1YnpPNVRkT0dFQjJIYThtTm9pV0FKVEY0MXRveEdZQUMwOW9ZMmM3K0JvdHJqdDAzTVh1MFhObHZnTU9JQ3ZYeStzVURJV0lCODFSR2c4d29xalJ6WGUzbnVlYnhGaDBPRFIrdFE1a0FYOGFwTEdzRmgvd1lWSDJnUms4cGJkaGFlSnU5ME1yRS9VM1JkdWFOSzZKaS9YSzV2TTd0NzYrMXZOMGRWOHErSDFoS242cTgvUGNTRDJYSkVNOW5HVDJYaTdvZlNoWDZkbGpKL3I3UVpiUngzMm9Oc2UxYXpsN1psOHhuTnI1RnVBOVUwdWFrd1ZJRDlRelBlY3dTK1p1dFZoUE8zRm0xN0l2Qyt6bGw0NHYvK3lmL3llVjA3VHpVNHVUQjJuV201M1l2R3Z2d2JUcm8rSXV0WDZKYVJ3THRhUEUwVzNWSHgwL2NyQ05nSEtuMGlUUDFvVHRZSUgvYjMzejlQTDlIM3d6WWR4VjU5Skx5OS8vOXIzbGJ3SkZtZTFxMVRCYlVZa3ArOWplT1BmR2JJLzdQRUdYWFIycFdoQVRyVTk2QzZqVVJzemp5TEdESFdYZStJOTB4bUlXMXQ1MnFIWWw5QTZqc01qQWF0ekFtQXJsV0ZKK1dkMEg5WHVTT1V0aUpMQUp6N3A1WUZIU2VnazNUZW85ekVDenU4Y3dlUXRIdU1VWUJIaDl1U2VYYVlBZ0RTdFBhM3o5R0JQM1NLK1loTVFXZkZ0Z3VTZmE3TS9xM1orbHViKzQxWUZjSWJsU1hEREZzQUJaejNaQWRmck11ZVhFeWRQTlVTNFZwcVhCQ2FsczQ4QWpqWHczUUhJczI2Zlhhb3Vka3RBU1dXd1IzYTduemoySUwrSy9nS3NXUXUwbTU2d09zeE1pYytoV3c3QXNNeGFtZUIxZ1hwSFYvR2pWSlNYNGNUbDVWU3l3SndvckhNdVYrOS8vNy81Rm5XRmZycVl4dDdFa3pzalR6WUtHbms4dzhhaWRMbUN0TGxOMzBhdHRNbHkvZmkzbGNLOFlhMGVTZFh5ZEVwMmJqZlZXZmI0bVdOMjFkc2xaTEpQMDJCcUlEYzdPYVBOSGMrUDJ0L0VCbVFSamdGQ040b1lnZWczSVRBRTJnR2pIRWxDTUJkSm5KdmFWQnJFKzFvOHlvUXhzVmczM2NmWDZBcTZ5NFUxb0ZYaUtKeENJWDhTYko2UkFpcnNBWDdGaWdCSEZQc0JnSFBHVTl6Zkt0Rmh4NWpvZjYzL0dCSkQ5ZEIyZXBRajNBT25vQUZRODIvWHVPKzVzUDhXYmdMUHhyTzhEbEs5QnFPZTJrSE0vSUxnQ3pLcEVWcEJmbGNGWVVjYlk1L3krQWI1K3grdmtpYVU0cVJPOVJpNkFJRDV4VFdrTjIxK2ZoVGVnVmtiTzB0cVdGMUZEK2didXlLK0czZHdRbGJtMk9RMVlMNnhyTjh1Qk9aeGdING9acml5WDY2ZSt1NkxYUC8yUHZyMDhkN3JkcDIzM1lxQjdMV1QxYWJsUjMvbk95OHQzWDN1dTdnekhTMGQ0YmZueGoxOWREaDdlVTF6aytHUW8zNm1lOEtNT1V2M09kMzhhVUp3b0sxcHZxK3N0VXBObDVVU3lVKzFVUG5wd2Q3bHo5ZXJ5V1VIVGI1NC9YKzFhUWZtdFdYTEZhSTRkUDdYODZuZnZMNy84aDRzMThDdU8xbUkrVFFOWjZLM3RmdTRNcmZlbCtiWUdXbCtWZDdIMlp4SmdsZCtreUZVRyt4cVkzQlU0N1M0d3ZMTnVEbjd1ZFVocXhjamlOaHM3Yk5yd0NsaXlKQkNVTmlLUXRPUkdGOGhoMW9TaWRlNTlHbHhBM2E1Y2sycFczdmVGK1lHZkw1cG1neGxHOHdhcVVoTHVWdEJOYzhzczMxMlNwL3RnMEtkOVl5eFd5cjZBLzlDUkl3RlZwVExGbVhZWG01cDhxeXhVZ2tLQTVTSUptQjhveS8zSTBXY2JTKzU3TGlRdHpVSVNSOEU0Tkt4aTdzM055MEVTWEdxbFRuWUE5MlNCN2Q3ZDZVbjluVzVMU0hNREo1OHJsNmdkS2VPeGtZQWVMRHluMlppam5WU3huTFZBT0xicXRjbElEMlRROFk2ZHROSmFDUFRSWnc4dnYvaVRuM2F3eVk5bUl5WDRqQ2NCdEsxNTlYQUZqeHVqTDZWYzJ2VndBUUdXekg3V0MzZng4OXhNd1hNWitqcmF5di82ckdkSXBTQVVYTm81V1NpWGlNS2dQUFNDUTYrSk54bHZ6MkNkMkQyMFR1aWpzSmhGTmNEVSs2eXlzWXF5d2xrbDA3YytHYkxXczR1YzRLMkFsWUxwODU2dGQ5cDZ3TWNxNExQdUpoVERBRXRqQVpZYitXQkFDcEQ2NnEyeGRsaEVlMXBuVFJrTk5QaHFUcXUxSXI0SkRNUWxYZS8rVTFYUm1zeWN1eGRMRFcrdUtRbXJ2QXhZOVZ4cVZJOHpRSVFnbnI5YVorYkYrZ2w0V2tOOGJKeDRSNXh2UUJRbTlubEFQNVpUZjgxbkc0T2ZHM3p1K2U3cjc1bUEvM2ZOdUp2OUhHL0dHUFVhZ3BxOU5vUjVYRTNKMHlhbkVEWnl6YVJuUUJIdlNUZGpFaGF1aW0ycWNDOVo4Ti85N1J2Rkg4NHZwNTU3WmRsNzgwcG1lSWVoWHY1ZDhZTXR5ODkvL216NVZwWFkzR0xXUDFoKzhPS3p5NnNkKy9YbDB6VGVqWTg3Ris2ak5IcHhqb0w1SC96KzJ2S3Y2aVgvdURZa2VnLzl5Ly9QditvK2w2WTFjN1JveXJsRExjYmRXL2VYdi8zWHY4dG5yeWRWYy92OTc5NnVkOVBWNVg2eHVQTXZYMWpPdkZDcFJMazZtNnR0dEYzdVFNL1pPT2p6WTZvSHZNbkxsSWJJb2tkWWdYakVZL1U0M24xek8xT2Jkb2JxbXlydHdEUzVSRnRyZWJ5OW5VcytQb0RhK09LdlN3c1JTd0R1Z3VIaUkyclVsR0FFKzdOWXoxUndMWFpHT0Vkb2UwL0dzY0EyVjFETVN1d0JnTElVQ0R1NmM2VWU2MUF3N3RRWDAwV0JJcm1kc0QzSW1pRGdkaFFQRnF2aEZtQVdGdEdZM1kzSG9uUDM1NnUxZTFocmFUdUh0R3JkblJMWWdMU05EYWZGQUdFYkhNMmcyQ05YS0kyZTVtMFlFU3hyc1hqQTlxN2Jyc2RWekU2YWh1bWE3K2RINVRmRmdEM0QxMFBkVXMwMyt1a25CZFFjSGpKemlrYXNtRGtQTDE1ejhJTWlZdGJjTTgzNzJSUEg0cCtQeTM2L3RYei9XeW01YjcvYVBIT2RKSDJhVCtDcU5UUzNZdzJXbzMvZ244RGdaZkhZSGpnZ1NWQW9FZFVWdmQwYTVaNDBvUU1QSFZOV2JHd3Mxb0NuWXI2ZE81c1A5Nk1wNktmRzdURUo2eVBMM1hwTnRuK2N4RzJrTUpSQlVTVDNVOHhBNTdIcEF4TmppQmJ1SUZiYktDSkdPV0VVV2JRY0FVNjRiZVN3OEJVNG13Lys4SzNqQk1Ec1VkM0RHckZBQUd2V2M3VGtVdnRpUFZualRiVmYyaEl2NmZ4S0VkeERZK0djdnZHMTlhU2t4SUtudWVRajFsMktKTUs2MzJ3YzlReDFuV1I4N29sL2pMOTdzSVRRemZUbU5Sd1dyZVVFVGVQRnhnQ2crbC9YQmNJdTZwb1Y5TmJZRm9BM2o3bXU5OHpNZFVEYlhUMlRaUVcwK2krQVhXVmxCYkVWM0xkczNwNlFFWkMwZ1FmUWhzWHErclU3SlloUG83WmJ6OUNqbjZKYkR6WnkvcTRqek4rdkJ2REU4U081RzRjbWlMbHpkL2s1THg2UG1OYzdGWHB2MWZoUGw1dlhZL2o3SHk2WDNuOW1PZnVOOHdsOXZlUGYrRjJ2UGJQY3V2eEpiV3l1ZForT0REdno0dkszMTI5MjVOaEh5NWtUN1FJbEdBSzVUUDkzM3Z0dytadC8rRlh1WnR1VEhScHd2VmpRZ2RxNzd0aGFnTDM3T2I3cHJROCs2RWluRzUzZzJ4UU1NK0p0enEzVjZ2YVpFR1BjQnBaT3hHSENJOHdhTEcraG1QRzVuZHV6cUxSUTNsZmk2SjZPT1QrY0MzcWc0bWMxVjVoL0JiZFZZeUErMEtNMXhVT0dTWHNXSzhMTlYwM2N3b3hMSGNpM0lHaU12Qmp3Ymk0WnEwbmQxNWpvRmpxYVQreXdPS0FBTXEyOXUxMHQ2Nk8za0FXY3JleWUyWlV4azBUWURyeHR6bHNDeHFsdkRGZ3dKcVh6TUJlS3hhR01oRFd5SzZ0b0xNTHVTTEMzNUJLeWpnQ09udWZHdmRObm85MWtoeWRnRXh2cC9kMjVtYzlFQSt1Uyttb3VFZ05qbUhiMmdCVmV3VEdDOW9MRmZzZVVHTjdtelZmbHRla1pKZlN3cWZkbHlqK3M0ZCtVelhRZlcvaUhTMVU0aytWK3NCeUdWMTkrcnAyOGFnTXJXSTg3RXp5OEdnQld6a1d4U3FoMHNnMUxTNHhSM0hBMkgzb2VpNFl3MFBxN0MreHZCSGVWdm9oYnNvQWZaczBSZXRVTmNnRnR4cEFGbGlzQkhYY29XdHdvLyt5WmRyUE5kYW9HQWpxQXBWMjBWSk83OTdhM3EzazkwbG5BVldZaTVJQ1RYdlhPOEdUcGpaRDMvZ2gvZERidXphMjk0UHdhejFtRjJLWUtIdUVLK1RiV0o0MlRtNmR6eG1yUjl6NmF4WGZjNE1kUDdrM2FEU3VKRmE2T2RnTGczWXRJbzdYMW1lY0E0OENHRXNkUGVHeVNUaHRyZzJ5dEFvM2VjKzhuZVNqelYzVHcyZ2hXdEtGMHhpdHJEdFo0d0xiWEdtTDNYQVArK0pyM2doYWVnenErekduYS9jUlRZeHJGUnlzd3VmMUtIK0MrdXBiQXE1djJ0V1VzaWpUMHVBQXRicmRaTFlBSVlIWlBRbGVEZ2NBRTFjNWhVMXExZUwzT1JiaHVkRGpCdFZ0WDA2UmxvcmZqcDNENGxlKy90Snc4ZHpCQ1g2bmx6SWZMNWwxcGpSaFdPK09IaisrV2JOclJXZ0hNN1dJaUw1MC9VZjROcmJsVVlQMVdnTEZyK1VlLytFN3V3REZva210emRNNUh2RmtKenR2dmZwaTdVUUE1RiszNHFjNHh2SEN5cmpmM2w0Y2xCbDZ1ZThQbHlqc2tuMjV2UjBUUEtCb2tPRWxqTlljNFlHZEVtM1FHQU5hOFdKaFJLaWExZTVRZXpNSnlvTVMycktscDFsZnNaMThDTkc1WDQyUEZiRTliYzVGWVZFb2VFTjhpcjE4WUlZM2FQZGVkd0RVWTNocXNpeHFUc0FvRTN4VWZUODVWN29NRkZmUzBvSGJFTUpQQ1hFekV0V0RlKzFwakdJS1lRS0JUbHdPN09lMm11ZTNmZnlod2ZUWnJ5ZUVRN2JEbDl1aUdRQU5hTytBNXdlTG96a3JrK3BnUGdWVnFzeU9yY2xlSGtaak9aOFdyV0FIRFJNMVJBaVFOeURwdy9SZUJ6bXcyOUpvTmxnSFFyc2ZvbmdQWXZUYmF0aXZXR0E1d3hiamJBNm1TS0tPSnJndEtzRmd1ck1pSEFmaWU2SEFxSlhHN2U5RHVuOWZDZXZzT2ZMbkcrZGJuUm94TW9kVE0wSXExSUU3R2ZWWUxhWE5ndzBvVnY5bWxiWEwzRStjRHpLd3I2KzkxdThLK3JRVVhjbk03aWZoQjNNcmFBdWRqeno1YkRLOVFSSFFoc0lMZ2R1dnM5T0VmcnRYWjA2Y25ucXQzZnhNM3dONnlvczJURzl5aWpZb2hSNjBYc0IyaDdIVUhhUXpqdUxpUE1nck1mVlBybjVET2UwTlByRExDTDU0bXFJNW4xdmlsZGZueWNZZDdCTnJDRnJ3Qmx2dWtNaVRQNitHMExQaXVzMjdGcEkwU3Z6MTUrbURaVXo0bVc1QUwyaTBIT0R4dDFyYlgxRmxDaU5tb0FsYTlOOVpqNEtTYnlsaGhmUzZEYnVZTklMOXFiZGZLZzRBcFF3cVU4ekNBNXNnTzY1Rkg0R1k5QTZCUFNDVVptZlh1Wmh0QU5ncGt6LzVNNWZYcUx2Qm12am1PN2JSbEdwT0dJb3UwbEJGcXJyKzFVb3JKQWs4elRrcEVDTHk5RW94SUVjQjFnczQ3VjVmLy92L3lQeXpmKy9IcDVidmZLN252MkxrQW9LM2x6emRWSEgxeCtlRHYzeXArOVlQbEI4V3pybng4cGVPaHRpMGZ2MzluMlIrb2ZlUDVROHNQZi80bkJibVBUd1c5T3JmTHRVdSsrUFlmbGp2WFBzMzBMVURhdVA3UmYvU0w1Zno1ZGg0N3ZQVlJPMjV2L3JaNHhQVUh5d3N2bmwzT252OUdwK3g4VXVaK2dlQ1NHdmV3akpyNGxoaThtSDI1VjRGVkRMTVIreGttVDRoMVhaQ3JKSWRIUWJETVlGYlBuU3c1K1Y5eWR6REZwdHhQS3pwWjdmMU5JTVkxQ2dCWURvQUtzV2szTnNmd2JJc29jMzA2WUhhTkwvVjJrNktRRmlJc2FDMEF6TjBZeTIwVy9tc0dhaUZIWWJRWVlqTzJvdTNRN1dndDl1ODcyTzdxMFJGV1pTTnZ2NU5TeUFKUVI3WXo0UlZrbDQ4azBMbzJvZHM5c1I0YkFnOENlMlBWM3ozbm92RzEzcm5iZ3JDc3JnbStSKy9WWEYvemVKS1NlVDRHUTBmUDh2dFlWUDJOVitMdHVhOVNKcDhGRUxUMWh0blBjZ3NYVmxCb2JsSXd4SjRJMTZQaVVDZ2tnZlYyU3NwR2dOalliRlJFR3pBbGZZUGRVRmd5bW4rOVlaSGdTQURGejQwcytzUy8zY004Q1FucnlGenRWbXF6dzBPWURQUXNUekVlZ3FFektRdnRYc0JFRG9RVnZFNlE5bVpkSGtraDNLOXk0TFB5d2diTUFvVUgzZDloSHZMWEZMRHYybG5DTE9GTFFtMW9OWVIrOXQyY3ZtaWR4MHVKcG5GRzQxbFRNdEJyRkVvSWdPZnM3cTAveFpDNnpsajZ6RnBJdlo3NVNNb0JvdmpnMWc2bkJiRGNWcTdVNXI3RitPVEJiZTY4VFc3ZjdKYkdxd0FCWUUwc3Jmc0N0aWZKdFozVFdmY1V6aUJJMTZ5V0Z1dllpdlJOZnFMSDJGcGp4S3lLMUhWVHp1UFBZdDJVcVhqaGRGYUp6dWkvNFE3U3ZlNkdSc0J6Tml2aUdlOTdiZTZmQVFOUUtTTGo5bng4dGZtNzUvZS9yaDlPdDgrSGprZ0kxUTBuajZRRnh5UXlzcUU5eFVEVHFuY0RBTnM2aVdSbjFvRkM0dm5iNzhWVXRoVUgwUzNoM1hlckkzeno0N2E4SDlVWC9odXpheVVSN240SFQ5QjA5N01PZHRXNjVVaTdXTzZwQytKTHJ6eS92UHJhcTdrTE5RM01EVk45LzZ1Ly9ZZEE2NVBseHovNldUR3hUeWE3K1QvOXgzOWFYdGlka2cwL25rTUNEaDQrSGlqdXFtaTZrM25TMm1mT25DKy9abS9YZjVqbHNhdHMzbElrU3MyUXlTd3JtUVZET1hONU4yZFpiUzJZem1YVVN1U0xzcVBWSHhxamVqYlVJWGdZbDBaTEZFZXc1RVFwd2FITkxUNlRtR1pHdzlXeWFBRWlwclZtY1ZrUVJIZW1vYmdPeThsci9QYUpzN0JNdm43T3VGeDlSdDdXckVHZlc5TWl5Z25ySDNma1VIU2orUStXR0NsZ0tsWEM3aHpta0pFdkRxUDBSVjkxMmUxQWl6QUNOWUF4ekpnUXowWkx6eUpVYXg4c0NiRzI3Rm1TV2I1ZHd5b1pvUXVRT0JLRURWb0lTTHZHdmVSbnVXKzNHYzN1c0ZaZ0xyWEFQTXlWR3d3c2dETTY2OC8va0xYWk5YWVpKYnArV3BMeEoxZHZaRDFXUzVxMWZLZ3lzRGtIc2cwTzkrQW1VQndEOEZhbkI3SmVkQzMxZVd2UzZnNWRQd3RjN0ZwYUgzUyswOTh5ODFtZEcwWHFibUNOakpzd2p5QzduL1hQWmJSbUF1MDJKYXlCbnZCbzJvSVBBRUpuTkdkWnRmUmRtd3Vhb3FCZ3hDVlpaUSs3RjV0RU04SXZvaG53TWtaajU2cmFlU1BHNXNZcmNJOEpnRWRYYnFCWW1UR1NMenhsakphQTllUDhSMkExUE5nOXhGRzVud08wZmNpODhPYkdGK0VIanI2QUxwNElOMWZaN2Y2KzBCbndNMGdtR0E2YzRoRWdnQmU2K2J6dW1WTU5FRitZNzZ4UGp6S3ZrWVZlV3hWSXMrdGVya0VyeXB6eU1EWi9lODlQbi9mN2pLRy9mZFk4QnF6NmJEbVpDVVF2S0JNd0tRSG9iWm1nd3hRTkJuajVXbzgrWW9HWmVCWkY1dWlVSTBSWVNhVk1RazNYTUpqNHk1TW54VGdTM3V0dEg5LzlsUzN3emN0M0puajZiSHgrZTNubjRwV3NndDNMNlhheTNuai8zZnFzMytpUWloTXh4TzNsMDV1ZlRPTGd1UXN2MXF4dFUyY2FYbDErM0lFV0w3Lzh2ZVYvK3BlL25LMTRRa3ZibkQ5N0lmZFNDY2orNVhTQi85Kys5ZDh0di9yMUg2Sk9PMzNGdnBLbTJ2OWVhejUxZUdqa0taNEphS2I3bW5OV1pJTCt1TmpIN1hweW9SNDNqOVlWZ0Q1UXZwTGROVnZlQ0kyWjlVU1M5YnV4KzhVQ01RNDlrbGhMRFdzWWdFV3hzUkFzZ3RreUQ2UXNDSTAvVEJLOUp3K29lM3RmdkVyTkdJQ2NuYS91eFVyd3VoUUFyem10Wm04dW4xd282OGE5dkgycnVzK3NsM2l2TVpkbmxXdTRMVkFVU0xjZW1Fb0tBcURBSUhiNk1KMHhpT2R3RHpIRk1MRmtRNVFxSCsycDMvdkdXQVNDaFJqUlZvQnlWV01EMzF4SDk5S3hjZ2M2TlNhV3BJVE9jVys3VmprS3QyczJHSm9INjhNeFprNkR0dFAycUZpb01YN2FpY3dmVkJoL3VZTDdKN1JldmJxUEhyeVRvdEZQSGVESzdZb2ZFM2VXMHNya2dXMkt4dkZmVW01WW9MdExKTWIzZXRFVFNqdWN2Z0NqOEFldDdSdm9TQXV3UnY3VEhGSmFoN25PaGt5T2hSUUliWGVPdFhPdDRQNzZ0YXRqaVp3Ny85eWMxWGk1WStxa2U3Qml1RHBxT05GWFp3L3gzQWVCemYwQzg0OTZmVFpFZ0ZBQ3JuRWs2OTdPbmhqaHc2cERBSlY0MWVPQzZNcWJ4c3FpTUhLN1dZdU9Yc09qRlB3YU00ckdnYUd3QUI1NEppdHprbnk3RDJIZldYZ0ZQMU9pOGhTdE00Q1owRUpXRERrSG1GdzN6NTJUaHlpclB0OHdoMGFBaDBHeUJ0a0ppVFdQWXZqUEd2VUNYc1RiYU4yVFJsNjh4cHFrV0ZpQ2EwNGEvZ2lvdXBiQTRUblc3WWFzekxXQkRvdFMvSXNHOEN4ZjN0djh2WE83WHpmNHlmcU93WmhrSm1jaC8vMU5ZMGlkR2J3c2x1VU1QdjJZaGN0TXhMVWFqMm5seTg4ZDV1dytYeW5QS1c2bGVWckhXWWI2YmJYdnY3RHNPdER1WVdrUWo0dlJKRmtsaUZicytyU1kxcEdqeTdPbm55dndmV2c1ZEtMZVJxZWVXMzd6eC9lVy8vRmYvdlZ5cWM2Z3YzdnJnK1ZpekhFdlJyVVZmLzdDaGVYeWxldkwvOXBaaG5mdkI2QlpXSC9mQ1RvM2EwVkNHOXEycG1sb3lTK2hkVVQ0dklXTkkzTUgxNjFrNU5YSzE4SWh5NHJrQWdWcDhUNDdnY21teUZWakpYQTVMSXA3N1dqc2FnWlpuUngzMXdNMHpFNGdnUng2QmQ4alBCWmxQdHRQb0FSMGZVYlRQVitzTHNIZTJiWDUyb3pXeThrOUR0Ulc1MEJneFdMaUFuR2JKcjhyNFY4enUwdkhLRDlzMzVRU0hTNDFveDIveGozZExGbUFBQlNUOVAwZ2V0eXZmazdRdEVzQ3RpeXhMSUlEV1d5N0EycXBFZkxNUXB6dWpibFdwZ0hjYy9KUElEQVo0UmpKTmJSNzN4c2ExRzdnbWpzazdoa2dqZ0RVSlZiMmZjSXIrTThhZWRLWWxCTUpZbCs3Vm92dGp6K3RIT3Q2SlZ6WEE2N2JBVkwwU3BBSXdQUUtJOEJOaXNDU0poVUlzclZiekpoNkJWcDVUaU5DL1E4d1Q2ZVBYbE8yUmZsMDhjUjM1UHlOSzV3N0JUQVU0WHFQU3lWVW9LeUhwVUlHdHNkWDJweHdtWjQ5WHF1aG8wZmlxWHRaZ1ZmYW1GbTd0UUpucCs5WVg2Nlk1Rld0bFkxelY4OE9SUVpNSmRuS2dadFRxUU1GQzJEVGdPQVN5SG1oWjlvTlhLM1NGVkRYV0ZXY2xHV29hRmtSUHQ0WlVJbUdkalk5MjVqZEI5K3padkV4Z1ovNFZVQXMvV0VBZ0dIU2V1STNBWG84UjNseXlRbUNqWWN0dmNmeW41SzBIa1JCQVMrZlozVUJMRi9vck9EYzYraWxsVGl3cCtCOXhoeTk1M29sVE9odU41WlhrQ1N0OXdnN1lxYjVCOXpNeStjMnJDMXpjdS9OcjUzZS9mbzh2UGRIb1BvOHhQTkFnL01RRE9BRHcvQzBaclY2ajl2MVlOZU96em1QZGNPRVo4eGltdU9aRWt2M1pqVVZPRS9Mdi8zdXRZNzN1cmU4OE1yM2xoLzg5R2ZMM2lPSGxsTXZ2ckNjZXZuVjVaWFhmdHdpbE9IZThXR3YvZWhQbDUzN2p5MS8vNXUzbC8vdnYvcnI1VzkvOWQ3eTE3OThiM256N1d1NWUxZDZFcVo2dXJ6eHhydkx2L25MdjEvKzlwZS9EYVF1enJtSXB2N2IzNytWQlphR0NwMmRZd2NXeEdYQVVUK0d3Y1ZETUNEZ01qa0VwRm1iV3NDV1JuWmhud01naDJQSXlUL0NYTDBYRFVkSUVkNmlZZ29aekJOWCtock1MRDVRRWNzQ0poSkdnWVJzNjRnMEFpejJnODVjUUV3QktHZkIrVjA5WlNQdUlndVp0VWZ6QWgzdTA5VVNON1hsNFlaaHVvTzVld3BZRHg4dU55clFNa1o5dUR5UGUrU3ovK0VhWWxJRndaTnYxUG9LN0FNc3JxWG4wZmJ5bWFSY0dCTmhNVTlqWWtuWWtXSVZjZlhjSDIrdzNqYXNSc0RFUlFQcS9UZE1aMmNRS05EaUEzTGNxNjY3bjl0MysrYWQ1ZU1QTHkrU2o2L1huK3orM1o0ZEVGa0h1NFlzTm1zRW9NV2RJbUZmckJSS0IzOXl3ZGVNY1ovQjVFQzJIL003QzlBWXpkZmE2Tnl3THdXd3J4dzFBc3JkNUVKYmp6NDI2U2lUWWhKZFdLb1BVcEN6RTJ5dGMzUEZONTAvQU1CdTFBaEFiZXVobEszN2lXZXBXWjB4TlNqSHBiRXl4QkZaWGR4ZUI1SklGaVpQN21zNkFCZVFrOEhFZXY2WnI2LzFOWHdqVFFmZEhUNHIxNG5ydmNZK3ViaXNUNHBpd0NxK0E2S0UzT2RkaHpFQU9BV0lSZ0NPUjJXTngvcnBKM25uR1dVWHpiaDl4Z2VCSTlySWpadWRidmRyZnVnNmRPc3FscHZyYUVvMEVlUEYxMkJvYWdVYnIvSHBoMGZZMWtxU3h1KzE3bVBCME1RL1A0MjcvNDNNckd2YWZYNXdidS9yODhlODBmdklGUkVoc2Rkbm9OMndYMmN5bzVVei9XZVNDWDNURzhKcFpCOUhKcWhNOW5xcEh6OFlZQjFvbCtwSmNaVVdxT1BwYnhaZmVPUGROMnFWdkdYNWFTN2V5UmRleUxrc3FIM0hRWjFmMWJPb1dNZVRiY3RmL3J0ZkxmOWJZUFRtdTVlVzk5NnRSY2luTlhXTFNaNWtxZTNkVmRIcVBobnhkU0hvTTArKzRrNDk3VmtKN2FFamxmNjgzeHdmWjc0ZlQ3dnJsTENDRUUxSThKeGM0OWh1eVgwV0k3cEV6Q2lKaUYyOE1ucUJ6QUJzdEZIYVZyQllXNXM3eFljd3JHeHo3WWhaRW9TVGF5RWVwZWVRKzlJc0FzaEF6SUppR3ZSanRRaHFyblJkdDl2bmJ3c2NTTGpQV3REOFpLd2MxcEw3TXRuRnA0Q0M5akR1TDRaeStQQ2g1V1QxY3F3RmpJRUI3eFVYdkoxQUVpWWxPNExaNGtweW5ZZ0JnY1g0bUZZWFZZSjdNTGRjYjZ3V2RkeXlTWWFNVmx4RlFnWW9nY1l3ZmZmUVk5OWhGV2huWHViblBmZjN1MXJKM2dwMHVMZ3hIckNDWFAzT2dpRll5ckx1VktCOXJjVGdLOFVuTHhjaXVGMGI2MGRsMU5zMTB2cEgyWkkrWk5iaFViVCtZbHpBMWp5aG9YQ2U2bVBHdEppQmlJK3RJR2t0ald0MjZPSnJBc0NsZGpEc2hydWtWUTV3M2wvK0doZHVkNjZiY3dhZExNTjZkTG81SVJxWExRc0NiZWU3ZXdFTWdIVDY5S2xSRU5iNjhpZWZqQXQzcExJbU5QdnNkaTVnd0E0QTduYi9ld0d6Nm9QdHhlSDBKdE5taHZBS0tSaStkYmF6MTJRbWxqUzVhL0VsbDNEV0ttL0UydWxwWlY2c2VyeEcyVEU0V01JanE0MXJqSWpXVjZqQ3pRRUpLdUFiWVFXV2xEVVYzWXBNczJiVEZLQU5nK21kbGZ0cko5NVlXTTVqRVhXL1VWNHA2c25UQW15TlkzWTV1OUo5M051MTRyZEFpeFhsMllEVmVxenZmZTFkOUxkMW1hTHhlVzk5WFh6T1p6M0xYZFZoa3BmMU8zcThkbWJINndnRzBVdzB2dTh5VExWYUIwK0xjV21QVEthNWUrTFZqTGN1aXlEY0FFaGJvN0J1N0VpblRXVzFIMzEyNS9MZEg3NWNvREV0bnk5ZWRVeTkzQlBZaW1Mdng2VHZ2OVBCRllISnpyMDdsdi9YLy9BL0xyLyt1OXJJWEs5SC9PVWJ5OS85NmxjQlhBZWgxbDVYZStXcjF6UThFM2d1L3ROVy9VSG1OY3VwQlVJSi9aS2crZEZudVRIYjY4WDBjZGJhdHVXMU9xUnl0VENwbU56MnZtMURmNTdacnVCMWV3dEEvWXRITmFVaFptS1ZCeGdaWTFnQ0txaU9tWDByK1ZoTEw4UjJhS2pWNnVUNnpVSjAvZXFpYWVmaXZMNE9lbzFCZFQvWVcwYTRJOEltMFRFNmo4WFFZb2svRWZUSmRXa2NZaWxPR1FaVUdCS0F5UmZxQWFQRkNoSk9DNWRUWjA3V09lRnNRSE9neitlR05xZGJOMjhFVkxXWURyQ21yM3NDSjZBOXdjMW9oZGxwWlQ4bnZsVThhRWU3V2x4QTlZUXNqVG1yTHliM3piMk1iQUFBUUFCSlJFRlVPdXVOKzBldDRnMnVWbHcwcjNIcmpHMzR4YzVjekU4WndQd0plUGZMWkxrSHRENFBxMWloOXdQM085RlMzZUhIV2N1WEFxcFBQdjVrdVZtTThXSDFqRThESzYyTXR2UjVkbFA4dnV6dGY5SWN2Z29FblhSRVVUM0tRcmxaeXNhVG52bWtoU0IyckNoQVl6M1FTNkFhZlZtM1hIUXBKT1pvSEVxaWhBQ3VGb3V5dWNFeTBqWERMcUI1QTNvOXp3ZFl1SjJ0Z2NSaFA2ZHhYMk8wTTRvaysvWldTUkFOV1ZGQTYxNFc1L0VUSnlyZjJsdGN0TjNFN3ZWRmx0Tzk3bk9qblVTdTRLN0FrWDNBNVdOMVRvNmErUVkrV2pvQkFUeENZWWdEaVVHTndDYURvMnlpaC9lTlhjc2pHd0lFbkpzOXRaN2RzLys2SXhaUFZ2ckhBdk1jZzlhalRxQmVMU2Jxc2RJSkFVc0pLSGVyY2h1enhJQk9BTFFsK1c5ZnFueXhZby9sKzIzS2V0dlVmV0ZMM0RIMzZPYU5NUXZJWC8zdTU5WSt2L2FibytRYVRmOU56bDYvYysyQnBOd3lEQkljRGpnTllTTE90TFJwdkJNYjY0UEFtTXh0ZnUzVWp0ZkZXdXhNS0ZhV2FPa1UzcW1EYWtDQ3lVcEpoUDIyaHE2VGFkdWlscWZaTlFGWVF1UzlIZnpZMFAvWXMzdVduLzcwV3lWaGJsbmVyVEQ2ZTkvL2VhaDlmUG5MZi91cjVhdGlFbzR4MmhTaEh0U0VEOURjSy8vbnczY3VsWDd3ZWRxdTVNZ204K3FyMzJxSVcyTHNCOVVGWGlrMm9CYXZSTDNTREk0Zk85STFraURUZ0JId2NiRXo4YlZ2Zit2RlB2cEZ3SGV0M2NUdlR6dVJqOTkvUHlJak9vQnR0aEg1U1lIZWc1V29HT3UyQkhHTnVYSC9KRU9tc1l5dithRXVKdUF1QVJJV0hxMDN5WWlORVFOTjZVUFhZUDRodEo5OTBaYXVkMnJ3bnBpVFFQV29ZVVJtcnM5aUlsOFdSQXhoU21vQ0tsb2ZBSEpKQnRnU25GbWZ4cVpWODZsVEowWUwwcEthNmMwcHpWbFU5eElPZ0R4bkVrYlg0WTRlSVg1a1BPNkJXU1FjQWhOSG1SRWNvTThLWTFVRHFzMEZZZ1dPdVlPRVYyd3VFazVjQnpqaWVUVHd4ZjFpMW51ZHU4Z2k4UnhzVE9NVEVMazJnRUo4UjN2c2ExZlhBMHJlZlB1dEN0dy9tWFZKM09LSkJCUWY5bzMzQ0tNRFdmZWw2WGMwWHFSbE1XOXFteDVZdmYveHBlbU9JRFk1Q2FGOXJtSDJuUmJ1L3h3dFFFVlFyUjlRdFFZc0M1bnB3TWtMTjI3Y0hGZFl2YVVkUmE2eENkKzhlYlA3QnVLQnBHVGF6N0tLTmdjMmMySlQ4VC9iOVN4WGM5UHhBdWloQyt0V25lV084cnVPdElQTDJycVRaOEd5QkFhT1dCUEhBa0lzSjd5Mi9tendUZExHeEhSN3pTMmJHRkJ1TDVvQzVONGMzbEYwUGNERmltaWVGQ0ZMTE9pYnRRQldjMWh0OHdNbk5uU0EwSVIrZWcyZHVJQ3NsK0d4NUdMRHNobENOdzZPWENOSVhsdlQ1T3laRW5lQlZKUk1vWWhadHQ0QnBESGhmUzJ0ZmRzTUFGUXdoT0pINDRtZjlWVFBtOTE1TWhDUHh6QURWbWF4NmV2ckdBV1V6VE40S2RvQUtYTG9mUmI4NWgrZDIvUDY1djd3TUZyTlFMdHNibTdSc1orQS9QcGFwbWlFMlFHNEFnbzdodDdYeGlKd25TRHFTM1ZRZU8zYjMxdys3b0NLZllkT0oxQmY1cWJkV1A1UWZSL052RGRMNC9renArb1krc255MFllWHBzWEpvZUlwejUwKzNuMis2bnpDejVhajVXREo2M0pvd2ZWT2x1WmF5WXpmWGNuTi9uMjVWSFZtZUZBNWo5WTQyOXNBK0ZhN2p6Lzc2VThLM0Y0ZndEcGV3dW1uQ1lNY3IxMHgrUGJHNXpUbHJ5cWYyTlpBVCthcTd1LzBseDNOZ2VhdzI3bUo5a2h6V09qbzNZS1dPc0JseWxXaXhSekdNSFZOelhjV0pZWnpXSVdEVFRHUGJnUHlxakE4QnBiOXZMTEdhbDBRNnNsR2ppR0JGc0h4azVVaWowYUxZcWIwQ21pdFkwQWdTUk80Y05uMDVPSzJBU3ExZ1BjVEFxNnBsc1VQQ1VFQ0R6QW1BTjZ6aUc1TDNUUFRzUEdGZnUzY1R5NUUzRWt2OUY2dVFlTVJKQld2WkFrNG81SG1IMDBZSVdZOEdDMGhudkgyV2VDMkJyZTdTYy94WFBOamlmbWJsVFVkSkl5cDF6L05nckllbHorK1hHRDk4bkx4bzB1bHFWeXVZZCt0MXZMSmNpQ3JlZWZYR3hpVHZoQXR0Q0FTS09lbWhRNEJabXVZUyszb3F2Yy9yamk2T3RJdllucmxTYW9GSnNEZXVNWnE2WjZVeUhwb2JEdWpnS0RQY2FuTlFhb0Y4QkN6QXpKNmJZbnJzV2hZNUN3d2NSWnpRQ3NwQlRvL1RCZUlDQWYwYndaTUdpVDYvTjBzY2E2ZWI1KzFFL25lZSs5bmFlZHQxUDNpOU9renJjc2E1eE1mQWlPVWtsT0Y1UFlCSnVzTmRLd0pONG03eDQwMmJxNlh0Uk9ZcCtyRVBWbGpFNGh2bWEwMEpRam9LRlcvajBYc3ZmZzlidnYzejZBb2VTZXQ1dHhuNHRSZWF3eXNtckY4ZXErTGtrY0d4dU9POFN0NXUrUHQ5dVRCN0hhcVVFblZHbHc2VWFtaGp0dzhMVXNBZHV6cXZkbDBHeUFEU3NKRS9RUmdlV3MyRGI3S2FMRGIrcFJTeElqbVgyeHVjdWg2L1l2bzl4Z2QramN4eWVndzlaRHhVOFlrUXEyeHFzMGhLRXRyMkM3d0VMUmpKbTd1WVZ0RHU5RUdEVlM3MVduWmF0dXhMOXVQR0g5WFZzQ1J3L1dvS3IzaDZ0VXlsc3VoK2pnMzc3ZS9mYmZYMmkwcGRnVGN2bWdoSDhZWWg3citjVC9QdlhwaCtmWjNYaXFRL3J2bDNzNnZsbmQvOSs4NmJLQnhiTzVrNW9MMjF6KzVNVVNRS2YvZzN1M2wzTW1qeTNleXFMYjIrVDNGWU9MWjVXLysrcGU1ZzVjYjUvWTZvLzZtNTZTNSt2MlpZbWVTT2NkaWlTaEhTcVU0V05lRnhMUDVJV0xNRTFOZ0VyM0hOMmY2cTN0VE95WVF5dzl2Z3NNZzNUS0d5QVNQS2Uyc2t1UGQ0bEpLZXZvTWJjckc0aklLK2srZFduV0F0cko3TTRaWUxhc0pVblpQVENrckc5Z0RIL1FlTjNHQTVISEFwOWxjTzNjeHRsakFyVW8vWnJzOXhucGNydG05QUoyTGszNWROV3FNNkV4QWRYWmYxT21WQ3luNVU2YStJTHZmRFhxMm10T1lEb2NWSXhLdjhWckkwSFBVeWRXQnR2Rk5RaXlBS3p0OUdMclAycUVUa3lJWUxCZXBCWVIvOHpSclhBdTBwMzk4RmpGQjQ2Wjk4TUhGR2o1Mi9tUXR0YnR0OFozeXhRS0pSN2tYWC9iNVhRSCs4Vkl4eG9wSCsrWktWY3FCMDI5K2IyN3l6ajU0T3pDOWN1Vks3Wmh2bFFMUXdTZFpXZGU2RjFkWFdjM3BlR1VySWV2YlliUVBPeW44ODF4a0ZzWjZrcldkU3Eycm0zTnhLRzFybnMwSzBuM2l2ZmMvV001ZmVMNTFyNjlhYTNIeTVPblZoUTJVWmpNcCtueFpPK1g3aFN1T1RISDVzL0g0MVRsWFUzTkFtd3AyRDlIdytMRlQwYWxrNkkvYVJMait1NG1udnZUeVM5UGs4TTIzM3N6YXZETmdJeEM5TlFFLzBHbE1jNzVCWXdNNnJGTXBDazR0VW1lSVI0R2E2M0VRbHo4ZnB4REx1b3MzNFp1c0lmUGEzMXBQbVZKZGcrL25ScnRXQ1ZQSU1PNHpSZXhlbEtIWEtXSloraXcrSHNhT05IaVA2ZjZxUTZKalBFNVdLSHIxalZKWGtwUTV2M05IdGJpQzhOMTQ1QjlRQXJLbnBaaFF2bXcrejVBUzFSUkd4aWpIS1pmcldsOUFqMUlUMTF5Qmg4SG00dDVQcVh2NjQvaUlRb3lveSthZm5WMWUzOUdvZGxhVHQxV0JiajNRTnhlWGNqejcxS1hGcnlheFE2MWV6TDJKZnhWeEJMcm54TmdSMFQ2WFMvVlZRbnE0emcxSDIvcjl2LysvLy9YeXYveWIzODh4V25mcUNiOUxQL1VFOXBrbWM2aFd1dXF5Vk4wVE1IR2VvNVZpbkQ5Ym4rN25qbVFKbGJuK3V6OHN0K294ZjdXREpSeXd1VHVnZUJLUnYwaEFkMGJjNzM3NzI4dWVOT0lINzM2dy9QMHYvMkY1NzUwUHFsY3MyRnlNdzFGV3o1Ukh0SzFUZjI1L1ZpeW5JTnIyWE5SZFZVdnYyOWMyYmorZkNlMXBHUW14Q0swdnUzSWJHb1psTlNjdzl4eXhKSm5BTENaYURuaFlXRHR2VFBPOVdWVzIzSm5VTkRrM1NGeUtOdVpXNlNCQUFUZ1VrK2tQQ0ZxNXNjWnNkd01pQVd5ZllVbjZLWC9xeU9FanMrc0hDSldFekM1YzgyZjVmS2xGU2tLN1dsUGlFY1dVQ21LdndBdDBvbE1NTUYxQkEvUkRLUkVKb1FxTWpVa01hMC9CWmhzb1hKN1J4bEVEbTNKSk5YOHpUTFNZVE93K0I2ak1nM3V5c2hybHVWcUo0NDRrQkFCcWRiM1NpTjdyY3c5eXBUNzg4TVBsd3hyelhiL1JTVWE5eG9yeHZscE5oMWFJb2FETDJBS05TWkJhZmVYMWR1RHVwMjNsK1NtQnVaTXJKcVhsR1Vva3ZnR3lkaVBGR05ITkRobzZQYWliaDV3c01VZ2FmYXlHNkFaa1RZd2J6dEpFSndKM0tBc1dIYTVkVHpFR1dPTitaVms1dCtCbWJhWGo5TnhDWVlrRXFNbkxoVUtYYVh6WVQ0WG80ejVUU0ltSDJOOXNXSFFQYmlZM1VmTHFrU05IYXVGeklocG55UlYweHk5NHp4ZTYrMVViWTYrdGNhc3NxZmdNd0NUR1BUcGViZnkrdzUxNUQ0amhiVUIwdjVwUmMyTDFrZm5aTll4MkxES2RNbGp6akE0QWlPYVVMc3ZIeGNQamxhVDEwVENndjR0UGg2VnRQdldjZXNGdERoZWV5QTZRVkMxdEpicE8vRGZBVVpmTDh3cTFodTdpVXVQQ2RWK1dFNE9IbkFrcFRSeThTN2YxTzQ5R0UwWUF1WjVheExNcDFsMGNiNmZ4ZFozYVRtTjByb0x1d0p2LzAxZDN2TDRydDJyclpLMnJHVnNCU2dBZGtHMjNLeEU2YTJNY05nL0k2R09kelBWNmM0MTRURlhDcmpzQlJ2clJ6MzZXNW52VW9SUWZaTUxueXRYYlNqS2VIVFlXMHBPQzhZL1R3QS9MSmovMzBrc3Q2bGZMTDMvNXErWHNzV3JoOWhaWHVQSmVKa2ZXM2NQdFdWZVZ4WlNqOVdVV0E1OTR0N0tnQU9qRGQ5NWYzdmpkSHhkYjRmc0tlajZiVUg2VjRNcnAwYVgwU1ZiZXZYdTJtQ1VBQWg2QTBZa3N0WXpaVWNxRlJXRTFOTFBHRmlqRlJHcXdOQkNVR21EWGJVdGFlczRHYko2VUM2YVpOSVN4cnRZWWxsSU9Ba3RRdVVKeXVxUVVmSkhHbjV5WUdGcnNSZElkWWNLTWVvZmJQUktjNzVlRVpVMFJjQis3bTBmTE1jUEFMSmRydVUxMi9qQTVhYm5WM3pldUpmZ1MvUklNWVBkNWxvZDBnN3VCZ3kzN2V3VzNIZnh3OUdpOThTdDBCa2czU242MEJ0dUxVd0V0d2VGSkdPUWVaUFdLRnhDT0ZuckFaTUNYb0F5VHI2LzNWblJBaURpQiswazRBakMwTWkrQUJYak1RMFZCbDQxNzlGSFcxWlZMbHdMZTRtemRVOGI5MFNPSGw1TTFnVHgrd2hGcWp2K3FaMWUwMzEzY2IyYzVVQWVQSGc1dzkrVUc1aTRYRHhJVGtnUzVxNjZ6TzR0QkFrOEprKzQzZ2ZER1E0aWNKYWs5RXJkZFMyWE12aXVBOWdYODE2cUJ0ZmVWTkFLeE4wSi9zSlNRYTlldlI5K1NST3ZFZWp0NjJmSFRRb2RMQ3dUTWw4Q2JPeUN5bmxwT0F4ZldHbmR1UjhwR2ZJeVZoaDVLb2Jpc1ltazNPeFJEYlIrQVBGRmdIbmk2QjFxN0ZsOXdUWUc1d0x2M3VaL2NQM0pMR2E2VzdxcE11SE5vdmU0WU5xY3U0a21JazAzK1hPdHV2VlpsdzBwRHRRRFB2NjRkNjZybmpSekh2MDVNMzV4Y2FEZTlRNHczV1g3aUZQWGNQY0R5T0xrVlJHYzF6NjV2dDlONjZLbXhBcWQraWovcDNpdFBVRXFLeE9EUEM4WE1nYnl0MVRSZGJINWN5RTNoQ0d4cGhNMHJaZEJhalhJeFpnQWRYU1N5aW51UGxkZ3pOditUbDdlL1RtRnhSU1lKdE5IYjVzZVdKb0lJNGlOUW5wczBlVm05OFV6TUwzZUV5VFk1SkppNTRLNnoxNDVtRXYrVC8relBsK2RlL0VacENSOU0vcFRVQmRwVm9oK3dPdi9jaWVXN1AvbkJjdlBPNC9LcC9sRHI1Y3R0YlgrUVdyaTZ2SGptYU5iVWsrWDN2NzY4UExpVGF4SlQ2YXA0TU9aQThFZFpXUWl6cjZDeFFONkR0aUFscnFsaUZ3UDVQS0NTY0JrcHU0NUZVZUxncm1kS3ZDdzNiSCtKbnR5WENQWTR3VlZyTldjTkZ0QjN3dk9HNEVscTQ3Slo4SFgzcEVXQjhCRVBVOUV1YUxZUklKZGZCS3cyS3VFZkJnU0FnU1plZzYxcmlzUGhMQ2NaOFpnLzlwczRpVmdKb1hkY1BBRllydzk4MHU0U1BPVjcyZFc1VWxjTFI0ZU4wSFRmMVlyanFtUmxjUjFhcjJkeThnOFZOemx4Nmt5VzJwNXhuelN0MjVxRkt2akxMWnR4QVpibXh1cmJWcDdjS2lCTWRDWS9aVW1qbWw4QTFyb1JVbGJreWx3MC9wb2dURXRqTW9JMFJjUXhtYUQ1Q0ZPOHc4cjU0SVAzNjNad2M2NDVIZ2k4K01LRkJQYlo1ZHlaazVNYWNDVHdzcUdnQzZyR2lVN2tQbEJzWjg5K3VXRUhKbG5UM3dlUDFnMmtMaG9PVGJVK1BYV1luRGJudG9tUjBNVDdBelJIaFIzWVYvcEtETDg5dnFWUXJZMWdzNDBqTWFXMTBKYUZWZ3R2Y2NlQTlPTmliTnhzTzZmR2ZPSDgrWkdINnpjNjhpNGFFRGpBam01Y1prcDQvM3cyWU1wOXZKTzdKNkg0Y0phalRxNnNWYUdGU1hHSk5odlhvUEdwTTJmSDZyTGphbGNaVGZFd1lHVUZpVDlaakZram9OWDc4Njl4QUxGUkhna3EydnZiU1VqbUoyNXBEa3FWdUpiV21VWGxlOW9nZFJjdHF2SDZLT1pBbUNKK0V2MjYyYXkzbitKTFlvTEdONVVYSTFISlErbEZNdXNuVnk3RktVWGxVUVlGaTU5cmU2OU1BTXBKS3BBZDhCNFBZRVptelVzYzFxR3Y1b2VYMThKcEZxVEhyOC9IaDVLMWZXN2t6OStOZS9OUFRqM3ordE5pRkk4NldsZEMyNE1FcjdGMjAzemwrcUU3NkZRWmdSSVA1UnB5Y0w1UzNLaUF0K1BpbC9LZ2xBT3dhdmp4alhsNTk1MkxFZTNwOHNPZi9pS0xadjlvSjR2QTFYcmxsZlBMbi96a3RlWGIzMzQ1TjNMWDh2LzRmLzR2YlFmZmpXQlpMSlVPL1BSN1o1Y2ZmdWY1Q1RDZk9uTTh6VnZIaDVqa0J6LzY3bktzUGtuclVkMlBsak1GNlhjVmc2RlJhQ1RneE1KNTdWdmZHbkQ3N0dZdGI0N3VXWjQvZDNnNWZWeDVSeWtEZFNObzA3aGR3NGhJQU0wcnhsT1cxSTloR0JZakM4RGl6dW5BR0FuVFdOd3VHaE9kZ1BSNURDYVhCbE1vYXFWaHVXSVNWVEhOTUhnZ3g1SVMrMUk0S3lndjNVQ21OTzFxYmx5TGt5ZFBEcVBhd1ZycjM5WnpHUlVzQStkcmFYbnJvajdTcmwvcm1OSllhUzlsWW05MFBwQ1ZjT0g1bDVaekYxNkk1dHNLU0hmNlRqazFleXVPL3FUZHVVdWRFY25GQWxpMExNRzEyOVZkMWpZclBZZmJPMVpTYzdabTVoQm4rVy9tejhvRlpEVGY3T0pFQldDSHNTUEgwSWY3TEs0a1lDNllmUG55cGRabldWNTgvc0x5elcrOUdnaWNDNmhPZHZyTjhUa1kxMGt1WW9IaU40UjdkOWFVV0lqNDRkN290YThRZ3NOMDFieDYzWUVnaHlxYkVqTmxDUndvYnNNcUdPdWdhL3g5c005NG54c0N4QlRSYzRGWGtNWXRhOW1KOWFZZ3VHMTdzOVM1ZHM1dDNOVjZFVUNOL2w1ODRjVnhONEd2K1d6UVlqWmlFaVBWRFE3d3NDbGliZldDeHlkSFdnODdvK09LUldzMWpPSisyYUlwNFE3ZFNDRUJ0Sk5aVys1RmlKMTJoSGFBaTZET2JxdDFHUmRwZGVuUW12SmdRRkFnREkzWldjMURzUEhESGJWczRsUVV0L2pQS05xZXZWRjFZQkxHSlpqTnd1TWxqVjBUNzNLUFdlOWlyODREa0UvbnFMM0ViQXlPQnhrRTkvdStseEZ5LzA1cEg4VnA3MmZkeSt3ZjZ5NFFzL25nSUprSmdRUkMzR3o5KzRFc2tKcWR6Zmc0Q1d3b0NaKzRMK1UrUUUwWWxYdlpMVjl4Q1IvMjlyTDV6ODd2ZTkzcE9JbGl3Qk1BeGNCYm5kYWJTL1c0VmpJR0xJaitLSXZuUVNpcUZZamRqNGNCM0plNWJRTnFBZHVqaEFPQkhqV3hPMDNpcmJmZldmN3lmLzNmbGpmZmVDdm1QTGQ4Ly92ZldYN3hpNS9WaC8yNTBQak84dGQvK1crVzMvemhqOU5QYTErWjJ0K3RzZCtPVGZlWEMyZTJMMmVPRnlkcWQvbnpKL2NuR1BvWW9PWSszcXV6d0tWUFB2cmE1YkpERTBGN25ZQ3dobVNWaHoxSlVKMEtOclg5dWp6b3NNMzZsQi9JaW5pbTlobTVoZnR6ekRkSGxLMFJ5QWFEWm05VFA4bjl6WGZXeDF5cHhDVElSbHp1Z3ExNTF3Q0svaGhHVmhTNkF0Yks4R3VXc2Q5cHhlNFY4NGhGTWVrUDFaMlQ5VFNXVXd5TmNYMHAvemh6NnZSb2RvRm81d2FLVjAwbmdtNi9LeUVERHVJZEFJOVF5OXZCMUdvQVoyZXM4WEZyUGV2UTRXY0w0dS9wSk9WcnhWeUszU1FNOSs0L0xMM2t3d0RyV2txaG5hZFduY1prWVJBcUdwZWx3SGF5S3dlazFnenI5SG1NN0p2bElkZG53TDE1QTI2dUZhRkJCUUhkTGh6NkFSM3JzYnBldmQ4RllrdDJVYytjUFJNNEs4L0toYythT2hTZ2lWMUlxR1VoaUNQT21BSWg4NmFJTmx3Z0I3d21Ndmk2Y2VweVVkcElQL2RGUS9sMyt6cnM5a0R1SXJBNm5vdDU1RWhIVitYU0FIendwSWVXemdtei9kNVA0L1ZEdWt3VEdHdlYzOUpMRkRqZkRMVGt6NjFkR1I0dnoxMkliOVUrQms3bVk3d3NTMVlQbDB0Nmd3ejQvZVhHT2N6aStyVTY1YlkyamtSamJleHFuR2lvNEJwbzRWZWZkN0lSZ0RzN3REbVdUQWxybEdRNjROSjZOU2J1SWtzZTJEcEdiZUpQM1J1dHNIdVRhZ3JjeHpXVFg4d05ZUGtKbEt5M05lVXAyZUdWckFxZ2pBOFJnRFozRTI5RjlsNHlMenV1dkFTdVA3N1d5UEJyeTZveHp2MHpYaWhPUUlPZmdEMCszTnZwMys2TmQxaHdNOFJHTXljb1lZaXVNemFBaVBjWVFkeHpCcFVhSTg5ME9LOXZWbUlUajlja1JxZVVmbkYyNStzR2FyRVEwNE9oM1BpbzNYZ3lpdmthM1JUM1BlbG1kZ1dlQkdicXZNYWY3WjVjbks4Q3RhOENzVWl4RkJLYmcxZy9TOFA4K2g5K1g5ZUVkeHRudmVBL3ZwZ0wrSmRyRC9DdTMxSlI2emRmZkdVNW1jbS9hOXZETEtjWTd1eWg1VzQ3U0RjeXFST3JGbnYvY3Y3RjU1ZUhwVEhzanhGZi9lNHJ5NC8rNUFjQldHY1J0aGxBbzl4dHgyeUhqZ3VSUWs5c0x1TFRHUDdRZ1U1L09kUlpkSFVSM1pmYkp4Vmg4c25TVHVOR3h0QTc2cldrbEVpWFZZU0lQZ25LNmxPUFg5N3FzTTdYdkpKK0lycEZicldZc0xRdXdMSklhRWNyMGlpYmlnMkppODFCRHdFU0M5QW1nK3hwQjBFNE5Wa002dE5PaStIK0FjbXR6WVdGeDJLU0JuRnZtTGZkb0FSYnNIcEtXNXFsUlpjZmRLMkVVWjBWbmoxMnNzVEdMNWVyeGJnZVpCVmZ2ZkhaOHV2Zi9tRjU0NjIzYzhscUY5MW4xVlN5cmxqUE9pdzh6SlNYMElpSkpUOGFNemRwOG1YNjJaUkhTOXBsWTZVdzc1czByaHBoa1Q4MmdBN1lZeWkvbzhFd2FUUkRHNWFZRTVNVWtoODdYcTFvZmZJUEpkUTdBNWx1Mi9wbGpSSGVBTW5taGZYcmd3bXNrTU5LSzhCSVNOZnQvbHdiZ05sbkpWbnViSWVXSzBxUXVZQUhpNEVkRHJoMnRNNVBVbUNPZUNmb3c4S05TWUlveGFFQTJqcnFNREV1UjVZMGF3TlFzTFM0Ym9MNUI5c00rdVRUVHdhTW4zLyt3dXh3aWptT0ZacFhNSW1icldkRG5oU1QzY1VJYlNJOWZGaWI1OXhJNi8vczhSTkRmK3NLQ3V4UTJwQ1luS3RDRXVqSnNqYU9ZNVg4N0s4T1ZDVUZJT0txZVI5dysya3V3aDZzVndvVXZWdTJBU1k1ZzlZQnI4ekdRV3ZJN2VOQi9mL2pZZ054Y3cxM2ZwUlB2RVFwcnp3Tys5aUFYeWNKaytuQTZpdjM2R2RNbW40Q29BTDd2UjRPTUdid0ZDOXJhNmZIVTZib0U1a0hjT0VLWTRiRkpHS2xnQjRvc2VKOERoam1vUFN6R1haZlBkS2VsSEFlZDN4OXZhb1U2eHlmL2RtNVhhK2pOc0Fpbk5NYU9XRWRkaVVYWHdzblJqVWg4UUxFd0p5MG9BWGd6amtsUmxPelNReDFzd1I0WjMrTFBlM3VrSWp6NXlzaDZSdzRRVUk1Tlp0YnFNMjFMNUZ6dGFrQmZ2VFdXNW5JbmQ3OFpWMUVqM1ZhY0lkd2J1bjBhRWVkZi9NNzM2a1o0Tm5HM09LMldKc0RubU9uVGk2ZkIweVlTb3hHSHkrTElzaTVzOU4yN3RVZjNpR01lOXI2OVh4SnJnTEJhNUpkNHlRUWpjVzNkSUxSbGczYm9Sc0NoTFBiTmNJWndMZWdMQ1VCeGtqU3MwcDVJR1F4eHRDdTYyZ3BMcHI3UWJ4SW1kWXZvVEF0RFNUR05JNnFic0FGb3ZHa1lWeTdkbTJTTCtWaUtZdFk2d2JyNVBwMVBFVGczdWVkWGFnZTBjOTd2Y2RpdWxZODZ2QVI3WVJQdGZoZlZFUDVvQ3FCejVmZnYvbjI4dFk3NytiTzFGb2xsd2JJQ2VJYkx5c0R3RjI5ZHJPZS9OZlM5TVh0ZXAwN1M4dm1VVVgzZ3ZNeC83ZzhyVCtnMHEvTCtzK21RMnZQaXFKQkJaZUhlVWFZMWgxS0xQTlZiZ1RlWUdrUlZFSk1FSzNQZ0U4M3d3ZGJBaWt0Zm53R2VTWnBzRjk5c1FiRkN3VzhnUXlldE5OSFAzdTJ4bkFBYTNLM2pEbGxzRC9hMm1FYWw3M1BHSU8xK2ZMTFhPRjRVdDZhVEhsaERNdUxIbE0reFU3dGVaOW5rYklFcEpSY0MzQjhBZHVMSDMwWUgrMWFuanY3M096UXF1VUV4alpEV0RHc0M0ZTBERDE2cGxRU3JwZzRHRGZYYnFqTmdiMVp3TWJrOStMYmZmbkwrR29HV09uWFovWC9Na2ZuSjdLc3JObkVmVnFmWVo2dVJTc3UzbGk4dzNPckZXWWUxbkJjcmo3TGlKRGhUNW11QWZkdTBYeGRZeE9BVmJNcE9scFhyL2VSNUZjMndBcDZhK1ZBZzR6dmdRZ2xTWmx0TFdWREkwYmUxNU9hbWdFYzRLVWQrZWQ1WWVLdUN0TXBRMERWUkhxQUdHSUtJbEQ2TWtzTllPbEU2a0JqaXZNaDd5M1hVbk9DTHdCZ1Z0M25lVzRhSi9qcGxHNDVncHYvOFlXZHI5T0ljOFFQazdJVUJpYnU3RTZrT1Fhd2VoeEIxemViTlNQL2FZNXNiNUVuOWlTbzJXUU5pN3hLQ1JCdmFEcFpDbFgvcC9XWXBSSTdiUjAveWdMQUZMTU5YWTBjRjY3TnYrVWIzM3ArK2ZrLy9sbkIxdjNMdVpkZksrQjZZcGJ6clhmZldkNzc4Tkp5NHV3TEEyUi84N2UvR3ZmMHB6LzdSUk41bUN0VmE1Z1cwSmpWOWpuaFJVK3VDYmhyR1J4WXljcWRyZTlBYkVYOEVMNEZNMnBGMG1OWnRpYXQyM3F2TkRQemRnU21lUU5wWmp6aFkvcUxNN0FBK05hMjF0R01lUGpHdU5JR3RBZVpZSFdmN2VYR3dSUXYwZkRPN1doeGRZQUE4SzJOOVpSWnBKMTZQRXRLTE1SZ2JISUFZbkVFeDROSlNzUU1UT1RubjMraHBOblhoaW0wUUpGaC9mYTc3ODFPb1FmYXJaRUw1cmxpTEk2eVVxL21mcDhWc3ptY1czYm0xS25XVU5aMkxrTWcrdURCblpTQUxoYzJTWXAvdERhMjBkZmQwWFhEWVRZQkFuVVdvM3c4b0RjdVFGYUFVaEJXZ0xHdnJvdUFMczNQOGxvdEFMOXZXQUkwL0NSSVJrTnpOMjdqbWQyLzNBWENPVzVkOUtWWXBwYXUxeWdLejVDKzRMN0F3MmZXbjZVckFEVDNoa29KT1VHZzRhZjJNLzZMVS90TzZGby9GaE9obmdEd3hCLzF6cThsZGp3cUV4N0lXamZKcnVKU1J3cGhyQWYreWhDdiswUHlRRDdRQ0U5VG90Ym55SkVqYzMvVzA3NEFVTjJpMy9mM083bGlpUS9mR0NPWkMyaWxCRWh0SUM5aWpGeE1COVJLTzZDVWdEUDZUbmZWWERzdXVMamVPbmNlUnA1Tm40MDBBWGpYWmprcDEvRlpBSWFldnZ5UXF5aXdEYkFBRVpxaHdicVJzcnJ6M1hnK04ydlplR0w0bEVHQUUraFBrdlhYd0QrYk02Mjk1MUl1bm1WYVpHRnpOWitVazF6TUwzbG1MQ3JXV24rTGthTi9MQmtmZUwzeGQyL2VBMFBrWWU5VDJ1RlgzbFpLNGVkbk5yL2VxTHV3SGExTVVBU2tkUnIzUE5RV3ZmSUxHb1NBR3BGREVDYkkydWN3S2tzTFUvaXNTMmhWOTJKTm1UeEVIemM3TXZGSk1ROTkyU2ZMTkg5Y0trRkhpVDkvYXZuemYvSFBKczFCRTc1bkN1aC9GZUorbHBDKys4RUh4YTV1TFg5NDg5THkyemZlcit2REo0Rk51NE9oOGdPSm1XbkdtVlRqa0Jnb1gydG5UTHlqc1VsKzY0V0k1OXExR0ppclpZZHRUTS9lVnBwaXA4MXFhbWJIcko4QWNLa0J0RHNUVjF1WGZWbEFjOHBJekRzbWRvUkVxT2xjMm13RTIybHhzYVh0Z1kvbkNLcGpFa2VIS2NDOWxudHhKNUNPVkFONmhKRWxRNnZScEFLNDdzM2t4OVRUM3lrbXQ2aDJUcmlUSjA2ZVdpNWNlRDdMNnVTa0p5aDNlZXV0ZDZzY3VOZzhyQ1VUWFp4QklmcVdMQnY1VG0yL0J5eWpkYU9SUWIzeThzdVR4b0ZMRGdnYWwvS2hQOXJueFFvZjVkSThmRlMvODdheUh5WkFUcVgrL0w3NFd1OG5FT0k4ZGc5cGVnSXR0aVJvUEJxK3lWbDdVbUVPdmdFSEFHRnArdmEzcFdGZnNGQjBZV0MxNHk5MEVOdVkyQnBBeUpyRGV4d0tOR3hCdTZmNGgyYUdLUUxybkF2b1Bac2czYTV4eGVBQXRMbWhoV3gxTVJEQ01LNUpQSU1IWjlPa3VlQnh6L0JzZEdaTFM1ZkJUM2NDZHp2VTRsZE9oM3JoeFFzTlV6ZlV6MWJYeXZObmJnbFdJTiswcHBSSE9ZN0VYLzZvQW1rZE5WaFB0d0pCSFVDR2IxdXZaREZ2Z3pGUUdWWDNvZWpkeC94dnQrT0dqK3d1QTB2NVk4Wk1vRFpLYnJpTHZCdUtpVXRyRGV6aW9TN1hkK0pZMFFBdjZoc0dtTkNaSWlLN3dHcTZZT0JubzRrR3ZxUVM4QzRvRlRSMUh4bm9MQ3Q4VHptVE8xODZNOHdhZnoyRzZmNFFvTExTcE5rOEtPWU5mTlNyM205c2RoWGxEbjZSL0U0cjVlU1BsZWFmZTQ3VkN3eXp3SnpaeUt1WnpiOC9lMjdMNjdhSVRkNFhna2d5bzltaE1nM2tKaVp2MUFMYllrU0l3ZzJjZ0dBTFF5dGFjRWlQb0lSdU5jVzdQbUhiQUMwQ2JjdVZJTzBtcURIZXozNytrK1cvK09mL2RIbjNvNHZMSDk1K3R6eWJBOE00VnhOdUx0T0xyN3pXRHRpWjVmLzZmL3VmbDQ4dnJSMUZvZS92ZmwvUVBoT2ZxYTRKbjkyZHU5WFhQWnRXMmg4UVpDekdBRmxZV1h2Y2hZWTRqQ2hVSlJ1YzlwbThrUUJybXBORmU3c29BdTgwcHZHenBzU2d6TS84YWE5eFE5dSs5VHRkM2NRbjFzUkdjRXk3L2ttWWxlc211WFIzYnNPdCt0NWYvYlFlWUwydUtKbzFKV2pNOWVLT0RoMmpLY3ZEczJsWXdYVTVWaGFMMEFxNm56bDl1bk1mejdVcHNUdjNvWU5weTlCKzg4MDNvOU9OWWFJUk9NTFhjaWxIQW9iSHlzRG0xZ0F6MWhrTFRpUEFGMTU4UHJET1drdTRUN1FESzZkTWNyQzhIakU4bXJ0ZnNtS2FhMEk5YXg0U2NDRXhNY2FuK2NWeEtEQlorT05hOWpxZUFWQWJZSVZNRzM5SDF1NFZ0WG93d1BNVGJkZlVDa0swbHJINExFdlcxeE41Z0s1cGJnQUx2VmdEQkU2bTk1U2dKR2dEV0lTdWErMlFpUXZwOGpsSnl5bVZGY1FBdXVMbHRTaWNWWWhmMGN3OWNUdCtZRFVBRm9taGxEVHI5T3IxcTFua0Q1ZVhBdnZMVnk3UDg5ZDRtMCtaSTBIVzllTGhXTHJBV1ptUkhXRTBzbjdXVlFINDFuaEZDMkE5bzZ6TmhoVS9wN0JUUFBIS293VDVSaDA2N3NkTGRwalh3dml0RTI1Z2FZMDFsa3lOQW1qc0FBcS9pbThOTUpOTjY5bXN4bXJOQU9FVk1EUWkwZEIwWUtKeHJnbXExdHp2eVc4QUI2UjZvZitpZSt2cVBSdFFEQmp2S00vcjEvNEcvaXpzSkNKQ1V2UXVZQXpNam5uek1JWWVQUWJSeE1penFFYnVqSzFIdU43ZjRvMEdKekFQZlhya3JBWERZUE0vZVhIWDY2d2dYeDQ4eU5rVmFwNkFsbmdHUDkwQTV4cXF0QnZZaXR3U2NaUzllSmliQXpmZmpiaTRQT2FKSVVKWkkxZzFxMjF2YnNGcWVXM3BPVWZUR2ovL1IzK3lmSmJmKzRGaTJKNTFxZktMKzNVQXZYM3prK1d2LytxWHhiN09GY3M2MUc3ajJmS0x6cmE0QVdKTWR1cGtoMWVVaXNzOGRnVFhrMzQrRXlPZXpOWFpFMEE5cmVmOEZsbjdDYUxFMXpWSmJkWGdCTHZoOVNWK2xVc2MwMmcvcTIrUmJ3cy9QMk1xQzY5TVpFMUZZSG13TU5JYWZUcytxZFdKb0V2akxNY3FTNHlGR3JldGxsT0F0Rm9uOGs2V2lVMGN6T1VsaVBMZGtKWFEyZ1hVK0kxbTBScEdLZ1NOdXovTjdscXV3TkZ5bUhRQzhCbTdVSmM3ZmZsS05YVVkwQ1BIdG04KzBrY2tKd0pMWlNQUFBYZXV0YWczazVoV08xYlNOVjU5OVJ1NWlYc21ibkxzMmZLZjJzVWJ3Q29lQ1VSaGlIWTU4b01rOE0yaEJxM2w2aUt2WU1XaUViTVREN1FWZnE4MVZIS0RQMWg1QU1ZM0M4ZVg2M3g1amJENW13WW5iT3RYTE4zOVZtQmFoUXA0RW9JQktFcTEvd0RidUMvZHc0NmE1RS84Q1VRUllqUjBQb1RZbjkwN2VXN1dqRElHRHNxSmxLd0k4Z1AwTDdNcXAzdXBNYzlRU0V4V1E4TEdzaFlrZDQvZHhTVGpuczRMK0dCMkUxOTk1WlVDOG5rRENlakdYUHpFbjJKa3dnelNHbGdid2duNGhSVjY4dFRKMWJwcXJPczVpcDNJQTRDYmp4MDY1U3Q0Z25LeGswYldwTTV3NDNXZm1GMWN2SVNQNGhsek4yZDhTdUNWNXN4NnRUTUtPQ1ozc3RjbkR0Z3pBYlROSVd2Z09WeEM3cW1GWTkxNUhSd0JvWlVTemNlNzhkbklFRElIYUVNc2xTOHBOdjk4ZnJYNlZpQ2lYSVkzdXhzWG1USUFSdU8xNEkwK1lpTmxaSEh1WUl3VUVnVmxuSTNKWjRLdHlRME5remIvNlhQYlhoZlRjU0ZHMFcvYTN4N3YvRG83U0I0MkVYMldpQnQxalNuMTYvcDdpME96V2V0Vlc2NERNMm03RDB6UkRjMDFpNUw3eWZBVmI4Q3dLdVYvbDVYd1lTMUhBTjR2Zi9sWHBTUFlOV3piT2JPeHNIMGxPQmVMQ1J3YjBMQXhjTCtNZVRXTnVuQ3kra1lidEdDN0k3YVdKRTl5L3lwaWFiY0lNekVwVjRKaUlnc1Nxa1Nvam9VS2tBaTIrTncyVmxsZ0pTWEJsM0tNejNMZnBpYzRvUU84dmE0OU1ySjJpMmF4dXBHN3Nzb0lNOFptMmJBNnVDeDM3dHdhelNaN1hrbVAvQm9NU051MlpJMmw1NWF6Z3VtVWdSQUFtblpmek9pMXFlNlB1VFRwVXdBdGhpVWoyL2RuQmRTSGtZQkNRc3hxblNMc0FJdUxCT2hlZXZIRkFlS1BQL3A0eHNZS1loRjg2NXZmVE5OMzZuT0F3UG9TbzloVC9wT3RjdGFIUHY3YzZLc2QvS0VNYUQwZ1lzMmlSZys3dnhyYnNVaFJoUVVtUmdrUVBZTm1IV3M3UWRrQUxMeXpFVWVaWGFub01BalUrSEhjV0J1OTRpYzZDdlN6NFBDTUU0UllTKzd4cFhoazZ3RzRoQmltOER1QmMwOExaRHRlL2c1WHluWG9STm1zb0FCQWkrM0ZNNUczZVNhdzF0TDk0bzAxME55b1Jza1dUd21JRDFRN2VDT0xTQTdiOW9CZDdPNXFGdTBQZnZpam1iKzQ3S3E0eFhUanZRUkJDb09ORkFNU2hGN1hlNWtZTGg0L2UrNjVBSDQ5Y1VkbmlMRk1vNEx5S2JFaDR4OGhENFJuTTZ6eEVINktrdXpaWGVaUjJIRmJZNkI2dk9uTTBlNHY2Nzl4aitzWGJVZjJtaVIrWDNNTFdVSTlLeDYwUmtCcndqNHBLN1F3WnJGSjcvV2grZHU4YUhpdU1IbHJ0WnBySzc5cS9RR2U0ZWY0eDNveEtJQm5IRDUzWEVNRXc2MFpFVUNxWnpRZnp4cms4bHUvRG1SYVowUU14QUVoNFBMNTJSejdzd3U3WHNjSVBhVzN6R29WUUw4VHhyQ3BnYTlXaUJ3ZHlOZUZ2ZU85MkF5ek5hbnBNTmtiVTQrWDRPaEJSZkFzQU02d1N6SC95akRYSFdGWFFxTytpT2I0NE9MSEZhRGVHTk5Ya0ZkRitBODZpT0pFUXJxN0hiK2J0Y3Yxdkt2WFB1aytwU29jcXNGWWRGQTJOTWQ2aHh4Zjh0bGI1UFROc2swRUw3QlEvd2lzRE5oWUdzSllUbnNxVi9FMzVoZjh0MnUyTm1wcjZ6eW1aK1U4NlBOcjQvL3VrYkJ3OVRBUTYwa0prclFBbjBNam5SQjJCQklTQVNVNmlobmRWcWc4QXIybEhiS1lxUUZQdi9BV2xPWkVSaTUxS3oyZzlHbEFkVDBRc2p1RjBULysrTkswT0pGWEpVZEh4cmNTbld2WDE2UFgxMzdtWWpURmRhTGhycks3V1VsU05pd3pLK201YytjbTJIc2xpL1hUcXl3eDd2aTlyTFRqazdncEgrekZGNTRmQU5OU2VTM0RDcWlMWDJFUVFYNE5BM1VsdU42dUlzV2pZK2IxQlBSV2dBVlFDUWlBdXRYdTFvM09reFRYQVJKcitvUjRDZTM5dFRMTXlzR2tlQ294R29ERmpIaXF5Mlk5NXZyR09ZMzArb1AxYjYwSTFSenlFSi9hM2JLbW1OcXVuT2RKOG1STldUTnhEekcvU1lBTXlLYTRHeGoxRUhJd2JuZjNFWEQydTdpUjhSakg1Tk0xUUh5QTM3bi91OXZ4UzFTWFM0VW9GS3ZiY2VYeUFaVnZmcXROajU0dGw4clk4UWt2QXNpd05vNWs3Ui9LaXlBWEZLS1pmMXFuRW5FWnRaNjNvcTk0SnhjUmdJbC9TdnBWem9QZTVzVUNwUXpSU0p5VWNUR1dVV00wUi9mUVBjSjZ5TmlYUHdha2JxZzM3WHJqQWo0K3B4enJTOEFETzFaMDZoZFdmblFlRng1T3hOUHhxMDBhc2JHSllZMUt5Y2pvZGJ1elhtZjF1Qzhlb0hnOWg0VUlMM0NoNDhuUWUxYTc5WFBmTUdnK1l6SUFpSkUwejQxV1krejBBZXR0TG1SRERlN0lhdmZCTzV2LzdQbGRyM3ZvbU9WbTBZVkFhTnlhYnJxUlYyUXdGdEZnQnYxNm9aZkd4TjVBOGpIMWpLakJJaGpHY3FvS2dVWWM3b09ZZzRMR2JYMC9mYWFNM1JhU2ovdmRILzUwK1QvOHQvL0hoTGQ4cFR2WEszUnNlN2tIYURjamUvZTE3M3lyZTFUUVc5Ty9WNy81WWo4TGFzZVVCbkcvak5zSHQ4c2NydzZzRlZuMkFaaHNlOFdWUUdsY2pDWnNMQmlTTUszOW0xYXJjRnpaQ0dYeGFYZkZ3WFpESFpIRk5RUktMQmluelFCZ3k0RXhkV1hRdVlGRlJxT2R5bDJ6NjNmcHlxWGlWeDFQbFpVbDdyRGgwbG04aHozYnp6bmxPQ0hSZGZPVDNEbzBVSmJDdW4zM3ZmZm5lYTltQlowN2V6WW1MQTBpUnJORlBzRm9yaThxeDJUaVFzQ1MyNjdtU3p4TXh2V3BVNmNDOXNNRGdqY0NHUE4xaW8zUFBCOUlHWmU2U1EwREJkWDNCNm9FMS8zbEVISG5nUnN0ckpnY2pTUmYwcGphTkUraVpEUmlaYkwyTGdld2d2OHNJOHpHdW1FTkFFbXVsZWR6YysxWVlYQUt3bGdvTzZERlRWbmR2dFVpNTdMaFM0d1BnTVVROGR1R0FBTUU2Mis4Z0FkZkFxc0h4Znp3SFhvQzE5bjRDTWlFTEd5b1dEdThPVGxNZ1pVZHhtd0NyMFpRTVpaV3V3ZFpJNG0yYWk3dlJwOTlLUXpOQjRHSVk5VzRhdW8zSGJOR29YQzN4U3dueUIyZlN3WEJlMXhRR3poQ0JidmF6SkdjaTRldUZQNmdqSFRHWURVbi9kVjdsb3ZYMk1tZThaclBJenVHalg4VWF1c3pSa0poR0FLbG5ZMTRJcXRKWE5JWkJ0SmhXSWxjV1RXTjI3S3l4Y0ttdDcrMXRaNWpZS3hLeFB6SkIwRWFsN243V1FkOHhQdHBFZzF0QlpPbTFXc0F2L2V5dUt5TStDckFlZHFPSDJQTU9raFpRTWV1aEVwZkEvaEtWN1NITmF4ZENheDRBTjBUc3ZtOHY2ZFRhdmNPTWVLUDd0SnJ3TTYvemY4b3dCb3RnNG1nZU5ldDIvUzVCajFVZmFERm1hNEQvVzFMazZVaE1EK0wzMkFCRmNZY1N5c3pQb0JzRUhKeS9EVHBmdlRkR0djclZmS21jYXFVZjV4SkMwRy84NzN2NVlKOXZ2ejF2L3ZMaWZQWWhzZjREOHVmZWVYYjMxaGVmTzFibysyZWUrSEY1ZHRkZXlzR1VmZUYwVzZXSlBsRkdmWVNZRmxjQUhSeXd6QjV6MVRWRHloc3hTSUFmeDlobXh3NnhTREFNMDJiMERQL2Q3YlltNklINEpieU1GcXQ2ODJYaXl4ZEFXQWRMSU9kUnNRZ3h5dXY0WnA4OU5HSGphSFdMZDFMV1JLTnpCS2o2VERMbWswY0hSdWo5SXVyMXdMbjdxbjl5ODFTRXo3ODZLTTA4c0hsSnovNWNlMUtqZzRUaWIvUXVQS3FnQzBHVzNkdUVyeXNUSEVlV2craENZUWNJTSsrR1ZBQk9lNk9Pa0xqVkZ5dHprM3lwbXh6NlI1MmlRNFV6d0orWWNRQXpiUTd5WW9ndEJNYjZYV1dIeGNhcUg1V3p0QUUwVnZVUzVjdXpmWS9BWjNYR2dsaFkxbUp4NmxEVTI0a0dSS3ZFV2F1bUJGalZremNMeU9NckFBQ0JqRHhqZ0F2SlVLWXhDcnZsM0pCaUNhR21GWHpWYlJCZHdwRjJ4dEs1MkZnWmVkSnI2d0orcGJITXpGSk1jSXNMY0xDQlhhZjBkNE5oRlU5REJydkFvVklOVDhCOVkzRzdpUnJTYjNYc2lKM1pQVUxMWXhsMkhVNmF6akE0KzRkVnBIeXB0WEZIK3UzTVJDNEtlRHR2dDV6TkJ1cjlFWWJTbWZQbnBwTWVHTXlYOWFnbitKZ3hnUm9nQ1NBUUgvMzhseFd0VlpOK0krbHd2ckEwaFBmN1hkbkUwekxvTUFGYUIzY3A3ajhRR0taVEhIWjBhM3J4b29LT01iR2JCblFPNHl0clV3L2s0NmVObVFaWTZQN1c5OGV2ODY5TlNOZ3dGMFFYU2RUL0cwY1hPVFZZcHM3REJoeDkvQ3VaN0NtQnVpNkdRQ2JOZStEM1BvSjlMdXA5Vys4WTNsQnc2NnR2Y3kyMXcxQ3NOQkFJRHRBNnJranlGRnFCSGVBcWdIS001R1JQY1dRVGNxaUFDbzVUdkpRMWtVMDhFQWdjMjZpL2wyam54WWNXN3QwTnNsZXEwQ3M1d1JhTWVtMUc1OHN2Ly9qSDViekw3eFFIbGFsT2ovOFlmV0RQNHJSYnhRMzJGbUxrc3ZMby9xOUh6NTJwbU84L3JqODRZOXY1L0pjR0ZENzRPS2xUTzZ5aUNNMFRlM25GSjIyd0JnQkEwYmFGamR0Mm5jVW1Ea0NKUnNIbUZHbXR3TTduNG1SdjRoYjVZRThhR0h2MGVMTmpabnVzRkdDSThGVHBqcWFFdWhUcHpRcXZMbTgrL2JiemJ1OHBPNjV2WTZldTh1N3NSaGN3TEhNK3QzdUpFR1c1YndoekxTS0puSU9iRDJiUmZYZDc3NDJDWVpjQ29XaE43TXlkUS9RaVFLRHFNa2krT0lLQk02YTBIcldrQ0RTdk9pdUx4V1E0R29DN1AwQnJJMEYyZWFuVDVVU0VlaVFFNmZKekM1bzYwOEJ5Rlc2ZTZkVWhnNVQyTFkxU3pMbW8vbk5DMkN4cmdDaFpGQlcwRWNmWFJyQW9kRUpsRjA1MTA4aGJHTlFibUpuR0RCSmx2MzAwMDhIV0ZlR2pPOFNPTHQwZ3ZnQ3luTENwcEFjblJvVDRjVHNldWk3RHZkVFRFN2NtY0xzcmx0M0JIT1B3eDFKaHpwWFNIdFJxU0dwZUY5cklmamQ3V2F1N3ZsNXovSUE0S1R6QTJHZTlLQ3VvYXdlWkpGOEhsZ0FBVmFEZzFMRkZBWFAwVjluRENCdGJVNmZQdE4wT3RLK2xBWGRPWUFiQldFbm1vWDVPSnF0U2FXZFMxQnlxM3BKTzN3UHMySjFiaEJPQUlJVXdiaFZLSXFSQ1dLalprV3hSQnZXQUEyZVptZ04yUGNpSlV5NTJwMmVZdjRzZlo4UnU3dmREclY4Snp4OG9EQ0wrS2k0RjZ0ZG5oNExFeCswZEkwM2Q2OWZiRlRwSzZiQjRuaGdqWUlody9yQ3l5emNQdEU5MXRnZndzS0lWWmxTb0ZtRGNLSFBpR2VOQUhidi9nc1FlMWhmTE1sUkZQMk8zcjRvY3ZNa0gxNkNMZFpid0Irb2J2N2hpUzJ2QXgybTltalNYcGFHYnp0OUpVS00wZUpLd3V6MjQ1NmNLQVppQjRIcm9KWEhybHdTZ2V0QlI3QlU3U0hYaTNzRUhTZWduYlZqc2lZL2d4L1dXUWVwaG14VFZzTDNBcWkvK0cvK215YjRlSG12Yk8xN0NmSFQ3aVBEL0pkLzgrdDgvOHBOZnYzbThwdGZ2eEh6WlEwcDZwMWRzcWRwdVdOcHJLdkw0elRVc1Z5ZHZlMXdLWDZWMzlSREpldU8rN2tSTXlIb216SjFkOWdkeTdLVWF3V1k3cFJyTkdVRS9jN0N4QzVjQ1JhVEltT0hOaHc1Y21pQUdXaUxUM3lTQUg1MDhXTFh5QmVTUUdobnB2dkZFQ3dMdTB4ckhWVm1mZ3ppaTVYQ1JjSjRYQUxQc1ZYK3dvc3ZKc3pyWVJYYzU0OERBeTFsa0V2c0JLTUJwdG1XZHFOSVNKalIySE14NWRZRWhrVm5QYmtxdHVYM3B3VGtkdTJvU3VDVmI3dzhqQ1ZsQkZPdzJsYUFaejBKZUZjTGwrQnhCOVZWRW9MVnNzdGM3eGxBQXhBZlBuSzBzV2NwVEY3UnZza1ZJclM2Rkh6R1JTbEJGcE9yQ1hNUEd3b2ZYdnhvYUUwcDRpdW5iYSt1YUowdXhGYTZmbUpnMFdtVTJ0QktjTGkxaUhGWnh1Z0ZFTkdFNjdlQ1k0Q1F3SEFpSFV6aEVGYWxTUEt1cko4U0d5MXFlQVlhTk43Tm5UTk8xM1B0NzNTdEJvZG94NUltakZNajF6MEprL0hiZldQNUtaUzJVYUViQWNIOTZLT0xVN0pqN1d5Y1hLN1VpaXNKMUNqQ3NZaTZqclVHbE54WGt1aityR0c5djRSYWpoOC9ialc3WHhaZHltQld0Yyt3UXltaDFUcXgwNW9yM2J2NHpCZlBaazJya0FwVHFLTTFzMXZMU2hGS0dFdW0zM2xLTjR0MTNTNE9LZ05BYmFNNlIyRURyaGJnTUJmdXQ1YlVOckc0aFZxR1V4cmVuNDJVeHRjRUJ2d3hMYVd4Z2hCck9HOHJ1bzB2OHJVYnlXQXdWa29wUXZSUjgrKzdENk96Kzg3cDJvMUpuTS84NXFzeE13N2cwbndCTjJ2dzgrZDJ2ZzdSeDZUdXAySm1PVTZJT2k1TUMyYXhHazAwWERQWHYvbnFLOTFzYzVyeWsvb0k3VitlZi82NVlYd2FQZkZ1MElMemJZOW1jWTJGMWNQOGJId3hlMFRwWG8xbkpzQWRjZUx5NWtEait6LytTUm50SHdWQ1Y1WmJXUVZ2L2ZZM3kyYzNyblhVL003bDNiYytYUDd1bCs4c3YvL3RlL24vdVRyWFArdTZhOHVWaEFES0krd3p1YU83ZXVZT1ptVEJlYldFaEY0Y0F6QVlBQUkxa242TmtGMUhRMDdRTlBDOW5VVkJBR2ZzRVU2dTArNnNobzF1Q0ljT1pmb1hLSlZreTNvNEVBaElMYmowMGNlajZWZ25FOS9yT2RPbjZtdWg0NVBUN3ZKdnRNSnBkQU5tQUUrNmhDTG9DOCsvVUVMb3lkbGRwRmpGZ25RNVVNZ3NwVUVPRnJkZ293eUZKak1YYThMRUZvUWR3T281QUpkckpJWkR1TG13NGlnMkxQU2VPdHB1SXhDOVV2QlgwYlY3Y204SmtkTjFOTm9UbDNMSXJHY0NMajNaL2R4VGNCN2pVVHlzbHM5eWd5UzNvczMyNGpIYzFtc0IyUDNtempJUjU5R0hTMnhGS1JERndJMWhRWDFlWWlvcjBrNGdrSnBsYVQzR0lra29GTlFEZlR0WTJCc0EyeWxUZUgrN2ZMdEhFeXNwaHRuejcwWlg3Wk9mcWpsTFdjVDljMmlFUkVVVzlCeGhGbUNOVmRmeldVbFhveTNjMjVybHJFdUplTTdCQTRkRzJmVElhQmpmeFAvNGxvWG8yZElUSGtZN2xvQnVxSVNjVlhrcFdoNCtjbVRaRndoY2JOMCtLSW4zYmlBb01IODBGeERZVWVMNllYRnRvWUFDYnArOW1VSlN4c1Z5VnA5cFI5R21paktacVNGc0NLc3NBWW9WcU5BTEVPQ0JNUlFTYnE0amhlRW5rTVhueEpiTWljdDJZYlRNMm0yTjdWeUtLN0tZRHg5VzQ5a1l1MWJPSGVPRE5UTXRiMXJyYnBYQnNpb1QxcGoxSjdlOEpkbnlrazdWZHhydnVHK2dDR0QxUGpRekV2UHdjMUlsdk56bmZLUGp4S2ZtSVY3MzNGYmJXdlp6WXB1OXRwWnNaYkgrNllXOXIzdHp6TTl1aWRscDd5NXZYRjBRZzgwaUp3aCtZdkJMRjlQNnhZMFEvMGlhNjltamgyWkhTOUJ4bzEwcTRVQWNRTVUwbGpGdmNVMmk4YzVBby9ZSUhILzdTQnBtU3d2NDk3Lyt6ZmpWMXk1L3ZMenhtN2VXRjg0ZFdYN3l3MitYYlh4bmVmT3RqeVlEWGpmUlJ3OVhzeDlEMEZxSWRhS1l6NEYyeXg0TEdrZjRKeTA4aTRZRk9UdDZjYUdXSmNDTndHRlFGb0M0QWFEaThpakdGWS9ZbTc4dko0eXdPM1BPd2EwV3d4d1ZBanRpeTVsenRwWWRDVVlUY1BIOFpLWEVLbU1SQVFOMEEwREdzanVtdElRVDArcTVYTlFYWDNpcEhsWkhSaGlzZzBadjNLYXhRQUlxR2M0WWl5YWtLTGhOeGkrTlliVzB1SU81dDMyYnExaUtPQTVHcFhqTU14dTZlZTFmenB3NTNldWxLN1JyS0ZXQnRhRnNSSmNDMTRsdjJMRmtSV2pKSXAvSGp0dmxTMWZtR1hKL3VDRTdhZzNreEJxbEpvTG9odzhkSFV0T1p3bUNtVmNXa09nUHRzWlZuQjR6OFlzWWUzV1RWK3RjNmdJZ3dCdDRaWFVqNjZjVW5lKzI0M2gzQkd1TlJVMEJkMG9GUUw3ejd2dFpERmtMdVh1QThWWnpqbHV6MUJQNG5ubXZhNXlzYkRkTzd6WWd2YnNnTjZHVjU4VHF1MTQ4S29ac3pRRkhvWUI0NmZEaEkvRks1UzZOazJWdkY5dDQ4WW00bWZpZzl0Y3k0S1hVcktVeHZKSmEwVFRIRTZkT2pqVno4YU0yWGxMZ0xHeUI2ZjBwT25RSE5PSXlNdEtCbFo5eXF4Uy8yMXhpT0RnMGw2dklPMEF6OFNucEpodWhHM0V3Z0pidzlFMmFVbGpKSjZzUjdhMGpldXI4SVg1bGZhenJBRmtmR2VEdzZmajA4OWJMK1FDc3FjT0JyUjF1blQyNVlNcWU1S1VCbWJHMm91UDJzSUdzK2FuQjM5cmFoblVsdmt0eHVoNVE5cUJveHFXY3VGZ3YrcHg4eDdDczY2SjdmQVQ0QUJQcmJETHZXMHYxeXFZMnlyK2ZRQnFvaldMK3llbHRBMWdEV2g0WXpOTDRDRFZQamlDQjRQaW5oRkRKek5NS0hzZDlUR2hNaFBhVFMvTDUxNFdXRXZKWUtXSlQ2ckVzU2hmTjE1U2dRTlUrNTdpdFhRRkVGQXpjaWxFa1pCY3VYR2pYNzhaeTVlTDdjMExIdDc1UjM2djZ2SDlWOEgxM2lWbmJxd2JmdHIwVFQrclhQb2R6ZGw4TUJVU2VwTFdmbHJtZG1WZ0xtU3k1aUFiWm0vTzRkUDVtNlhpMkx3dnBOeUFobjBqaDhjNEVWeTBqVGNWVlBkeUJGaEpDRWUxMm1sRHUyTkdzRkFtU3RxY1RoOUVHbUFHVG9CdUxTc004VzcweW5BRVFpd2JUSGlqcjJYaGxzdHMyUDNuNjVDUUFqaDVxTUlwZmdZQmNIOXJIWjdpajQ4b20zQk83eUMxaFRmbjhtTnlORGZCWUo1WVZpeElqZTQ3NVRkdVRkZ0ZQMUxwNlZ6UVVKNUhTb0pQQW5vUVllS3FiQkU2QTRuSnBFR05ORmR1YXBuYlYwSW5Yc0NBRTgzZG1TYkdVUG1uK3p0dWpvUUhqcmF3ZXhDYTRuN1NaUVB0emhZM1pPQWljZVFOU3drb0hlbzMyRms4UmE3UGJCWER0ZUttUHZGWnNrSnZGdGVVcTNlZ1prNFBVanZDZDRteFRVSnZDa2hhZ25jN1c0a3pVeGRVMkhDWjNzSEZaUzRtMGhOSE9sREVBQ1BsWkZBWkxialpzakxkN0FEYmd4ZFVTcHdPb2xQZFlNL0dPWHV0QVprODAyeFBOcGxTdE9VMFlKRXYyU00wSXVmeVg4d0RReFp5a0pWakgyVDN0M3FzeHNNYU9BWkJHZ0hpRmZGQkloMG9ZWmwyTzRNNk1BbzFvdGJGRFI2Ymx3UTJOQXlqWjdaTTNHRUFhTC9yZUxTWnFaMWhNYlpSMGRIWTlHdzBndFVkWHZHcHNwbzYvaSs1dGFDVGhZekVKU3dBUVowR1NYZG4zSVVHV0ZJdEsyeDdKeFZ4MDNnMlBTZlM3UytQTjJTRk5uaFhTYTVLNUsvbjNMSVhXWXRreGR1K3gwdUtLakJrWUlxVGhwL3kzZWIvck4zZ0d3TFArNXBxZmRTN2hOUEdLcVVheUc4UmNFRVBhVldNeFRMeWd1SmJPbFBLcnRuUll3NU8wRnlHbkVTeUlCbDRXUjBCUDROalR1RHlZMDVZL3MzRmlMejFaanNmMi9qYUlBWkdBZ2NaUXJUN3RYMHI0M0x2emFRM2U5bVM5R2NlMUFPTHFCR292VlpxVHdtK01IVHJaQWs2Z01jMEhzSjYyMEp2VGZ0bE5BV3R4bVJhZklMSSsxbTFZbXFQdlFJem1vRVhGaEZndjJya3dtemZuSG1oenV5OEw2M2phMHE2YnNlbGJKTGZKRHB1ei95Nlg1SXB1RTNTTUVaajVtSlJ3a0VSV3dLMUFUWnlJaVg4b1MvUklBcjl6dEtQTTdNcGhzaXFWV2tTMllXQW5PaXQ2bmlPbWFQUEd4S0lCcUFTYWVjeWlFaHRFUzlZVUMzaFNCR0lYRmdqQUFVQmlQZHd0c1JZcElMTFdhZkNKYzZCWFk2V0pDYStsWjJFUktrd3Vid3NRaTI4SUJyL3h4ejhHMUZzSzFKOGVBT1hldlBWV0JlbVZCUjN1bW9OOVg3MTZmU3hNK1VqWHhkd2FwOVFKNEkzMUtFUlc0VmkyclF1Qm1CYThCS2Y3ZmZySjFlVnFBczRORTlnR1FDd29yWjBCaXpnY2NKemk5dmdwUWdkY0FVOVdoSUE0aGZkTTl3SGNjL0JzdEFENmhId0MwMDNTYmg2UXRwN3JzOVlkVXU3ZXBHTjBMY1ZqbmRCSnAxUjVjY1k2ZkJ5UDhSb1U5SE5SRkNwejR3QVI2MGtnbjZWbEoxYVBMOTAxUHYzMFpzcXI5dUQ5dm1FRTNBcDRQY2RZOFV6a245MWszVXJGR1FtaVVBYmxTb1lteXpzQWNpVjVRVS94bmtqYU9HMVNVTW9CYWV0bkxjbkVwdmlEUW5PZ0sydlNaZ3NQZ2dFaFpqaTkwcVA5NDJRY3NLaG1zSkVoMTA4MlBzdEhKOVY5ck5KbysxWDg1elZncGQ0ME02eHhja2ZqczE2alhNY3JFMExxK1ZyUTJCbGxWVzBKaER4amZnK1VXRkR1QmFBR2lPSXRSb1RjN3NtNzY4Nk9BWnRjczY0aklMeWJxVGY5ajEvWTkzcXlNOFFCV0lTSDJUb1dWQThpWUFSNmQ0THRPcVVRWER4dWtPdm5BNzBqVHNHbm5qUUlTTjREV1ZiQXl1THI3b21hQ05OSzkxbVp5SGJQN0h4NXpWWjFjWlZMK2Y2M3J5NHZ2L0Jzd0ZQeDdaZWZMUy80dll6MVQ2NENxNmN4Z2Q3Z2d1UmlHaTFPMG04QmRzWVkrd1hibzBLWW1FQkdsTkJaZ0pmSlBCMG1HZ2FnbXZoVkU1QUFhckV4ZVM4dUIzTDlqdFJpV0Y5eHNST0hJUUNqUGpKZEx1K2w2YS9JeUdmZXQ4QUNyNU01blhVNGdlUVdsOEJ4dDFneG1JZzdjaXlyVEtjSHJvUWdLdGRERE1SbmdmNjFHOWNHcUFTdzlRZWZNcHl2QTdIVFNZRlZGWk55YVZrc3lJbHBDUUdCc3hQSnN1SFNyMGw4VG9mdTVPam9wb3ppUU8xS3JPdXF0Y1VscmJIbWdQVVJhMzBCODdnVkFaN005c25oaWVILytJYy9Ccm8zMndrOVdaeWpYazFwL2pmZWVHdjVxMy83VisxMkZiKzg4TUtzTDJBR0VPSWlBR0puakU2UXVUTlRTSjJtanljRGpFNDYwdUlZcmpkMndLaDBTVXlxRlp0eC9mc1luTjNLQk4wT0o0QTFWendHTUZuWEJCVm8wZTNpa053L05FWS9sZ1dGTXE1ejEwOFF1am5LVDBKM3laYTNiNWY4MnFBQXY5MDBtekRXSE0rY2JHTkpXYzM3Nzc4L3dyS2hJQjRWQnV1SlRMVUFBRUFBU1VSQlZHR0JzUXFObXhDSjVlRnJIZ1c2aWtPSmRWS08wbEdrZUZndlFXUDNRYU5KRkcyTVJHaDIzWHkrT1Z4czgwYVJOQmN1MkpyeEFSN0E2LzVqWmJYdUVhUC9wTFNneFpxVEp0OVI3QXBnVGV3NDJxSVplajZLbG1qZ1dEcGV3aXFIS2U3QXc3cllvY1huTExEK0hJRDlQTjdZRmEwT1ptVTZMMUlxeEpjVncvZWhlTjNtUnFBU1A3SVc4N3Q3MWdyQXJIdDBRU1BHb1RVR1VPUTgwcmIyV1dyTndUaFdFQ0grVW82QzVKN2Z6V2JjQmpJQit1WUhFTFYrMnZ5TDB6dGU1enJ3RjRISE02R2QxZytZR1lRak9rMmlTbC9sdm9lb1lsZUR0ZkV3R3AxMTVWa1lhVG9GSnN3VzQ2c3NNY0FGNGVjTXYveGVZTUw2MlpiclNQdEFmRTNlV0FFbWM2eld4cTkrNDFScEMwZlNoQmRqd3MwVGtQNm9PTXBubnoxc2grUFo1bFJtZVM2QkxkUFpKWWtza1c3Wm5ZQnVENm8xelhjb0FVQXpQMmJ5Qkc4UnJlZlJDdHlCeVhGSzBPUkJQWGVoMXN3eEd1M25aQlJtT3JCd3dPenhZKzJJOVpxRFd1K1huOFRpRVh6RmZJQ0F4Z2Q4RWlOOWV5WVhpM1lXTzJKSldWZHU0K0ZpVXJTZGJXM1B1TndtZzBSQ08zT0VoNGEzYTRTNXBSQW9SV0xoekFJMmZ1TUdYcmJpV1hoMnBJeDV3N0ppVWNxdXQ4amJ5dE02MVBNYlhtT04yYXhhcjYrQlhaWmU3MmNoQ2JnREEyREYvYVZkMzNycnJjbTRaMW5xVm5DeTdoQUMxWC8zZC84dzQzcnUzUGtKWm92anNTYVY1ZENVMGo3c1ZoSlFuVHNKR2hkMlQvRkZHaG85ZFhmRnlQaU1OU3JYajdJMEI4cVAxU1JHK0htbFdRQktMTkE5S0J2ekl5U2Y1Y2IwUXNCWVltMTBReE1DcXVNRksyb0FKQ0ZrbGJnM3NKSUpIcWVPSlhFalFOb0FLQ2Z6V0dzQWgrZUJFb3Z5eHJYckF6cTAvWUJPNzN1K2pTQXhuc2c2YnFHMTZkSGRvNEI1cng4TDNLMlQ4Y2pkOG54dXBDOVdGS3ZxVGxhZzJKaTVvSjJjUGIvalp6MjBiTkw0WWxGdldLZ3NqYkdvVzlDeHNDRkFYK2E2QVZiNGo4d3hPb0RWREx3QjRpVWJSZ000Zld5Tkw2OWdJQzZIWjBkb3lRdkxPenBRTm8vaTBZUEovUDVvQXRSbVU2cDFJRnVzS3NxRTdPdU45VVh5YjF3c2ZKWWdROFVJMFdHc3AyUi9DcXZqUVcrZ3FYc004YnJHNzNoSXFzKzg1My85eDhVMTk4MC9QYkgxZGFqYVIrWUdkbHFtRHFrSE1rbEpHVFJjdnpISGxza2pBVnhhK1dJd1cvaUNuLysvbXU1c3liSWp5ZEx6OFhsMmp6bUFCRkJaV2RVbGJMYndBWGpCaCtNRHRnaUZWeVZDa2NxdVNnd0J4QnpoODh6LzA0MXdwR2U0SHo5bmI5dG1xa3VYRHFhbTdnckZsV3EyYUlMaGt3Vmk0UnBnVTV4VkJXQm91cUVsU0UwT3dYVWZQcTB6eTNaMjc5cnk4TStyVjkvbjlxMXFKOUxpeVBZMDN3bGlGaW05MDFkSGxtaHFQRndCNit2enpyaVRKWFFmNXlWaUl4U0E4anNobXJVaStLajJwS3A3Lyt2cVlJNVR5STlaWmtGU0lMSmtVbExBeHFubExndjBlOWtmaW00aHVWTDJmSGxlYzhEQ1QyWXdkc1VOVXVMQXpWb0tPWTlIbVZoRE1SSEM5YlhhR0c3SW0zYjgveFpZQ2RoelZ3Q1ZJK2dweGJKNDJLRFVjZ0xRZ2swNzRhd2tZZFJYekQzUE85ck1XTGlFL1B5ajR3TDdvMWliWGU5VjgrMVVsNTZsdjVsdmdvdjE5aGpEcE1USnlBQkIxQlVBTTFJZC94Ly84Ui9ObGI3cE80SGEwd0hOLy9rLy81L1pxak1wOFJjQmI5ZkdycHc4RFZRQm5iMlJybTBMait1cU85S2FCL0NaQTV1dUdVaXhLbFgwa2dXa1V4a05TODM0WVl1Zk5iUExpTTFaZTYzcDdGdGI5TE81S09DZis0cVZMSWN2VUl5TVpXQ2w3c3Q3QjZSYlN5N1Y5TFFLSkJYWmNxdXZieTRDNDU5SEdmUnI0MjVqaUF3SzBPTGFVbXdieDRHZjM0VVZ6cm9ldy82eVJJdzRFRWF3RjJNVTNNYnNIUHpoWkJrdGI1d01wRXBkNFBscjRJZ0pKZWxkcHk0YXVlZVBQUU5qUTdsbFU3RnZ6L3F4THJJeWlJRE5mbFRHNkZ1VzJQV1U0WWg3K1NJWFpEbzFINk5zWHFhbUxPVVhTbENLd0NnTVcrdm05dFFhaDJjazJ3UFFyZnZNbCtudlA2d2ZBMU04YW0vRGpjQjg2MkhjUittSkVpSDZiYzRZZjZURS9zM0V1cytGQmQyWGpCbGIvMmVVL1FIcVlKTUxrVkZENWh3RTQrcnUzaEU2OURNZkVYdnJIMzl4V0M2d0ExYWJyVjhtYVpsQUgycjgzYnhKN1FQMnZlbTA0SDRUUVBkNklLQk42dllXcFMyamt4TEwwSkF6TjVndmxEMUEycXlCM25FVzQ2aFRUaHdESkJpK1ZoSGtzTFNPN1dJTklhbis2aVpwSGdxbzVSdEQ5N3YyRkY3VmVmQ1A5MjlYZi9udXB4NXViZlg2eDM5YS9mYnU3eWxwMloySGdzUzFOcjR0K0g1OXhkVnNvRTBXaHRkVXpxWm5pazVveFdxQTFNTURTNzRrQXNUZmRpWldWYy90Qk9XUDB0Q1lETXU2MGQ5cWRCaHdkYmpBd1UrenhXZXlkbzJWdTNWOXl3MEVVc0NxT2V2aEJhbTlKaU9rQWY5czJtMml1OHpNMFdGS3VRK3NXakNNUkRXODRQcHBRS0xhV0hZU2NHaCthUDR3SHNMNTJIYWt5UE1JQzFhR2lUZzFTTHBkaDhhekdoaGVkT3daSzhmMWVGR1YvTkpVYjNNNlliRE9zbFZxazFncFFveFZqUkEzUHNXUUJBdXd6SDY0aEVDOXpzKy8vbHFNUlZzZGJZaUxmZlErWlFtVVFSM1B5RVNmd1RDQklLVUJYdVAyaWtQRmpwTFBMTE5NbzVOZ212OUF4SWxCM0FVWkxDNjd3M1h0TkFBV0pOcHpmeTZXS1RHUUd1VEtPazE3Y2FQOFhZeVE4TTZZWS94a1o3KzlwMHB6Rkx1YW0wbjBUQll6cVU3Z0NmNTlhMzl4Rmd2OGpORjM0ak1aejRCUlViRTBqSnhCeGJ4dmFsNTRjVlBEdnQ5L21TRHpQLy8xcHpxT0Zxb0l0T3dQdlQ2clBPUjVSN0ZWSEh5WnpGNGwxMDlMQm1HQ010Z0h5Zno3c3J6UFdzL25HWStIMTgrcVZ6cnJFSkQzWFZ0dDN1bHFyemx6bGlmakFLd0F4RTVqVWdpcmQ5cHB6LytYdXBFOEJLWjJRNXllVlFONTBPRWFUM01CVXpqclRiYm9uV0prYkc1VmJ6bGdSdjNKZ25WbTRJREhlbWVBbW9mclpOVDVvd3pjVFowV25CUFlCWHF2ZUZMejJ2cVNXcHYwRDVxZTlWenVIYnFUcm40S3RMWmJROTFBVG1MdUNubW5EWFdlMG4zdTlPVUZCaGZBa0xYdTNlUVBTMUpmMXczNnVUaGNyNU1kdDhVbUp4UFkzeVo1bEZ4NVgxZElwcndoVnRYNkNhdGdqSk5NK0wrMFNPNkw3NDNPNGp1VUVsSk5oWE9LWVVMblVJWnVpRDF4UTV6SUlrTUQyWnY3Zm00NmdJWWJlcUZCVFJkVGcyakEzSURkMnRsaVhNbmJYRStkeDJ5aFNXQzRqUFBWM3hRMzdoMXlhMnAxWEhwM0s2RytEQnpXT2hqMXRsTjZ6cytMenp4NUhhREVWR3FkQ3QyVktFKzZ0ZHRwMnJjUjhDM25LUnFTTWVZUzlvejlOZ3JIYmRtckxrZW01V3R4cXJVT3RDQ3NudWpCKzNzVXBReEtDcmcxU2hJSUJXSGdXazBqdUs2SldTbkw4T3lDcVBZZmdtRDNZbjNROS8zNlhrbUhUN0EzUVFaV0RBTmx4L3hrWlRFcWN5ZDJCRFJWdUN1aGFDWm53UWcyOUFVT2FMNk9DYjhXUzhPcVpMN0VhNDRyRkJRanduNi9xMys2K1ZlYzZyNHRSd29seHFDWXRQaGE3SWFiSlVtQ0xVNlhoZGIwcXd4ZGYwZnJaZmlBRUtCc2FITWQxOExxQUJSR0NEem00QXlHb0RYMk5ZbVlyREpRd0d5NHhTT1FYVVRnbjFJNlJ2NUpDUXh1cUlBNnNMZXZUb25KcDJKTGtnOHllLy9jUHIwRXFOZVhMaFBjVmJFMjYvQSs5M3l2NnprYWpld3FxY0I0Q2JkdUUrYkJ1aGdITjQ5WnRNa2IyTzMybnM4RnY3M3U1em5XUGhmZE9vaHZBa0xNOGp6R3phQXdRSlBKaXdsLy9LUTljbXdqR2NLeTZJb0NXUE9vT2VXaVlPVDBiUFowQ3NoYlU0bUoxS254Nk1KUkNWQjZJYWdOWks4eUtveXU4TWp6eW1yMEtlUEtIcGMwbWJHbEIzMXNXRHNaeGNnOUVNTXZhVUhXNWdHYlkwWVppeG9YcXZsZHZJckFxTEY2WFVqQUhBSXBQd09RYVo3bjkyNEMyTEF2eFUwS1NLMmQ4STE2QkZ2bGhGcDRFR0tCem5Id3p1QnVaQWFRTXBpWTNId09NVEgvL1djZDdTWXdUaXphK01aNEpwTit6L2FQdkRNK3ZXdGt3MXdwM3lGSDVuSGovL3h4NS85ZWZORzVYSlJNOEl5L2FBS1FiSjlrMVRBVVB2ckNzbXgvK1BhNkVYaGdvQVpoRFloNzU0U1NTMzU2OUZGVi9DaHhRb1JhVWp3dTI1d2UzVUlSck5tcTBtU3JmWkx1Ri9jUi9QN0wzLzVsdFZ1QWR6cU4zaGhmdFRhM0hadDBkaDBiMEFYVFhMWXczWGMzNE1sd2RYOUl2d1JkbDhWcElmcTd3S1NNWUhNUzJKVWlqK0kzNmhhKzV6V3R2YjZlMEw0cTAvUFRELzhVRlM3T2xDSklDL3VpakJmOCttR0JjWUFXU0RVNFlISW1JMEMzNzVMN015NWhvUHVzamJQbThlUEVxSllqbXlqdHhQVWFqd1d4TjlGbVdHNEE1Y1RDdUlCY3IyMnRicHN6THJiWW1sMzRZbDZXVlk5d2g2cXF1Tjh0MWV3NW51ZSs3V1FjUHRXVEhBdTI2TTFJMXBBYnRaUU1ZQ3JQbjcyWWVKTng2YklnbnZmaFE3dit1NjhEUk5VWUVUWFVuNXZnWkcreVFwbUJFeVhGWUQ3VW1hSnBxMnpnT0tWZFRsOW1RakZjV1VwZ0MraThpY1huUG1KZEFKNFNjMDhWbnZyNzJ3RDlXd3NjRmZuZlZTTHdLUmVKcTJmL0k2Wk1zYkVHMmJZbng1MWYySDJkTFFpTWRmUjBEaUZEb0UyT0RnK1NEMXdZZFZSLy9lbkhBVXp5Q2JDd2VZa2xCMytxRlpSZEExaUFZMlM0NStOQ05pV3hvd3g2Q3psRnFxMkY4WkFaSU9wUURjcks5Ulkya0tRQ2pNQkNLUXN3TXlkNldwR1ZiR05zdTJST09nWVlGY3VPZDlQMTdSelIzUEU4a0JLTEJMTFRza2NzSkIwRGxoSXVqRERCR3BEdGVXNHpjZy9kQTFDWVUxL1dnNGRETHpGMjhrRFhnQ3F3dXU3MTZjVGEzRmxyOHJPVTBMVE9BZW93dndFZFFFWlB1bWllbHVzREtWdTNacnRTaGhIUXVLWURYYVpHcTRka0xJQ2Z0WjNlVndZVm1BM0FKb09ZMU1TN21zTVVlekNFQ3o5ZElab2pCeGwzMFQ2MFlFU01FTkwxNW03V0ZBektvYllvSGQvVUJJbkpZQkpBUzlFZGdQQitic1p0Y1pRQktwUFhvTVJRSmtWcDR2cTRZNlNrZ0FrN2YvKytadlkyN0dyN29rRHZPbERERHByVnVZZGc3SmZPUEx0T3VZNmZ2VjY5ZVYrbnh3NnEyQXB0SHY3OUh6MUJDOXpwT0o4Q0tsbW1uWDYvNzE3clBmalNXRC9oY2dwT2k2WUN1TWRzOGxqYUppL0dJQTd4TmVVY0M1REZHTkQwT0QyVDJpSi9aOVZrOGREbjB3b1ZTZWw5ck8wK29iSnpuK3VFK20rMEYzS25GallLRXltMUNkOEpjRENTNCtxZDlvdHRpSyt3TGl5cWhkak5kYkFabWNLTEVjNytxNTRCa041MEgvVmRsSEhaQnZTdG1MT3NZL0djejUrV0JuemliM2IvWXlSNk5CM0c2clNWdVRnLzdlYzJaSGVmc3dFZ203QnRGMnFkdXVlWFQyVVRlNys0Rk1EQTdHU1AzcjkvSHhBVmlDNkl2YmZ2cUN6dGxESGVhcXR5WWNTSkZyZXgrNVljVWZNajZXQTk3YmZEcUFrNllPTGFTU2FZUzNGQjl5ZkVBQS9ZTUJDdVpidU1TbnNnQTJ3SjllKy8vTnJudVlvYkZiaitwVkRBcS9uZFBrM2oxVDVIYlJaRnZXNE51Q1plVzA0ZXpuVm9ESlFYMEpqZnErdEtQRkpZRmRsN2dRU2xWU01FdUxKcElZYlBrUFVnT0tZbERHSnY2V1MvZ0ZSdjRRNkpRZWtCcFdzdEZ4c0ltNnZ6eWl5MnM0NUpSL05hRnE1NUpnZGZLNnJXVyt5azAzdlVxdjNidi8zYnpJODIxRS83ckgyalFFbG0rM3Jrb2hxdFFCTlFUSTFaZjk4Ny9HNDhBYVUrcnl1SWZocEQvOXpmbmI1OGs1NGR0VWJVV0ZaWjdSMmp5VENUK3lxUVZtY2RhemNCOXA2TDdxV05BeEo3ZTg0YVNDWUNJYktBNVRHY3M3NlRkTURRdzRLdTU4bk1UZjgzK2dJTHhGLzlEa09BMWtQUHZDZnBVU3pTK0hkemg0VjFVdm8rMC91YVl4TnBMaWVRM2dkNWNYU2x2NDVYcE4vN1hkZld0c2xmaDkyblczVFJOcjNVWW9pQTJCaDBHVUwzbUhVUWhINE02WHJQb1BWakxJb0ZHSDh5aFVmOVpodFBrMEQ0UE5STlIxbkw2SFNaWHV0YTNZU1ZBeFUyZkpvb1lPSDRIbFpleXRXQW5MQ3hjUk5vdFZCUUZPTzRmU3hyVlM4ak8rby9KUkIzYlZ4OUNBeUFJbVpYY0tsN05ubjUzckk5bjcvRVV1cUR6QjlmbGFGQVRCMUx2aFBDYjBEeFFBYXdTdWRPdDRrQXg1N0lBV0c5c3JvMnQxVE1pRlZTS0xvWCs3Skh6aVVGeGxsR0FYeENQOGZRRTh6KzI2b21iZDFCRjdtaW5BMFdtY0RzRm5RRjl0aU9ZSzZhSGN5U0VqcmhSZWJIQVIwYlBkdFU2RGNHOTJYbDVxVGNGaFJ6SVpCWXFENVVYSEpuMjJHZ3FzOWZ2WDZla01ZSStqN0pMVmtLVkR0dEtBV2hLRndJd1ZydTE4STBKQ3pheUFzc0NGWDBucHVtaG9oQ01SZ0FDN0MrZlBXODF6V0RxNmlrK3dKMHNVdmdOWVlvMnpadFFRSVlPeDJzbTNvYTE1V0VBZWIrUFlnWkhCNDZVY1lSVmlsM0tYSXVKQVo1MEJ6Yk1pU2QvN29TRXZQMjg4OC94MDRDcHBpbXdQUGYvdnBqOGFQVjZwZTN2d2NrNjZ2WEF2eXNjUGZCWUp6Y2ZkU3pBcWxoRWEyajZ1dmxlSG9xRVlNSE1zbnB6U2htKzAzVjBNVlFuYUlOb0xpUWtnR3BaT1BQTlV4MjFnTTI4ekNGclkxZHljZHN4OGxGU3lUR3lBQkRuUk5rK1E3dU1scjd1cUxXQ2pramN0ajZLSHExSVZxQ2hjdURMZXZRSUtqK1l3Y0FYMTZlempOZ3dhNHRIb3l0Q01Ucm8vOHh1ZHNwYnZlNmRiNXZySklJT3ZNYTk1SU5YbHhxOC9rMEJtNmpOMkN6VjFHU1p6K2pJNHUvc1dGM2hDbExQNHVEVG9hMXNXUGNON1Y1dHVJOVlySzM2QzhVa25UWWljRG8xWVk1cW1TbjI4T1VpaWsxclUxV3NOSjh6YzZFR0t3MUkwOW5HY3dsMjZqdUVrQW00MmF0LzVFZGcrbWovWnlSSnpNQjFGeXZ1WU54NjExVHAyS0RBbnJHTnNXa1hVRGl6SVUyWldtNEJ5NkFrajRHR0hjKzNSZEVreXBWVHpFTjRQc2RBQUNsY2VGWTF4N1c3eVpteXU2YkREUVN1ekZORnRJMVZSTTc5RUY4Q3RqcEdua2haZDBXR3dkaFRpZUViaXZsQ2FsdFJsVm5Jd01wTHJEYklqUitNSjF5TFRWUVUzVGF2ZS92c2FEY1FUUzV1NG92UGE0cmx1dmxKdUcrOHd3YjVRQ0hsc3FDNjdQd0NUbHVMbzZSYmU3UlpHK09lcDRLN25KYjlHRVhoTnhQYzV5OUppM05ZbUNhWUw2TERsZ0FNOWJqT25lTE9UaCttc0RFQXNWWGxzSStHOEZidkJTTm9CQUVFNGF0N2hlNE5ZZVhZaGpOdGZJQjJhT1AxU1V0UUtXT3A2eE44OGsxT0NybUpIN2x5LzR6dFRGZkw3NVc5dkU2VnRoQkNTVUt6czdxRjU0aXUwbFRPZGJ2VTBxRE1RcElDM3dEMEdseDB1dmlHc1pnYTRaZVdrdk5VdkU5MjBOeXI1YURYYkcwNGxUTmpia3o0Zk81UGt2d0dCNTFUTit5Yy9zVXBuYzVEa3N4SW5lcVhnOFpuQklhZmY1enovRDBDVGZRbnRTM2sybFU5dkwweVVIbEJOL0hpTmJiRHZSZnpmblgydUMwclNaV2dIMEpNM2cwTlhlZWo5dHlGVXZ4bTBEeFRwOGp0MXg1OFJmc21sRzZqTFgvcFZJRFJzR1hHamxsS2R3NmdYVHJ3VFZqc0drSys0K2ROZWo1T1RGcWpSbHN3ZXpscURiTTBtYjVuY0lURG5LMXNWcDVERGwxOElKS2ZQVjN0Z0FwV1ZCa2E1N3QyM3Z6NXMyTUErdkdIcTFOVUZ3Z3ZudTBzVjlCTEZrNGpFV0xXWElySllxRUN6Qmt4c3BodWRzbEYreFdrQUdXZFFiQ09sUU1xS2RuMW5xanRRaDJ4aVZjOWtZbXJ3SERmcnBvNzZET3ZjQjZiMHFDTXR6SmNFbzRKVTdpVHhKbGQzVytvRjJRWmVyLzZGWHpJeFIwZG5xZER0ZTRNa1BqeEtVbExnYUM0VUNYd3A2NkppUEE4WFFaSURpZzFXeVphNzgzdFdNUTRFaERHZkMwSGt1c0xYaHRXT2xPTGxzWGFCN25RWlVtOUZNTDNldTlDTVI4Y2ZXOERzVTlEd1Z5SVJZY0NxTDg4OG1zaFlDeGdreHVncUkvMW90QUt4ZzFjZktpUHF0cklVQzVDWkJRV1phZkFFdGw2aFYxVmtEZGZWekx0Z3ZLY2hsd1dIUTBIQXNBQkFLaUdOWjR0czJHKzBMOXpSaldMRngzWlRVZll6YVBMUUJmMVdPYStNekFzQ251b2pqWlFkLzZYd24rQWsremlJSGRWQ3RFVVBkeWgrNzdNT3VodEtJbm1XdmM5TXc3QWU5aExHYzZrdWJ1WWxZS0VxV291MUFUdnNRMFdDdnU0RWFDS2VabGpHSW5BckRZMnB2ZmZzL2wvWnhpbzlYVnFHVTFuYjdpYmhqWFZDSG5XbkFOMVQ5OTErR2JjeHBMTVJuSGMxRTRNWXBKYTZjSUg5dkdJdmJHbGJFV0VoMENwMmNKNjZUcm13Tnpxb25mWVVJOGZaY0NZZTJUeDgwQ1lvRzBNKzVrb2JoTUd1VUJNTEc2L1ppT3dEUkpOUGVUYkdsdXNVN3NSdXhFSFpNRjBwMUFieTdQWlpQOTczKzhLM09YQ3hUWU9EN3IyZFBqdmcrTHYvMCtxZlRqYXJkc3lib3ZhM3dkR0l0TFlqZzNGUkJQZlZKeVlIZUQvWkJpZ1VJTjJPUk5ETlBQdWhKZ2lwNURTMmhqd1h5VnIzQ05BTWJsRjZ6WDlxeVlMaW52Tlo0Rm84a2JtQkJKWVpMWkI3dUpqV2JFbWljcStiVXM3VlhQOCt5eTNtZTV5NitLdWYzV3FVNlNCaXIwQjB6U1JvZUYvTzFmL3RhYWJ3UkV4YlNhKzltVW42eXROcHY3MktoRGN5VjBIUERMRTNuNzlzTnFQWkM3emFOWWUxVXQzTE1YYmRBUHRCTkV5UjBnSjZZSW9JK0w1ZG5mK2JrT0dlSm1aRzFFdmVjQnZQVE5NOWsyeDZQUmNHOUhTNmJIMkhUam03YkZFTVAxZURQSnlWVkc1alpsbDBIZFNxWTR5ZHh0ZmJoQ3I5NlNydmMrYnR0bFJ0TWNOblg5bXpQWmF4TWJieHh4bks3UnYzU3VRVTJzaXc3NkpqWDlIMDdzNTk0NTQxeCs2ZFh1dDdpUy9oVGpjMU1zS0ducUFVTHdGZ2pOdHpIUm9QdC9WR3RZMUxmVVBjRWpmNWdDT2lzKzRuMHNNMHJKMzRmS0NzVUU1ZFp6NVJTVHlrWm9NOEZLUVZ1S3N3VDRlL0JPZXQ2TWljM3B2d0haZGcrTjZGR0FialZqRVNPaEFNTm9HcC83RFJEMFJoYUdRQW5veVhKRUlydFA4ODhvOURvYUNseWR2TnhOZTIvUGxNWHFoMkZVWWhkN05UbGJxNTVNRGRKbDJSQ1VuUi9meDFvSXZua2czbldCSmpkWFlhU1p3NkxFQ2REN3ovV0FuN3FsalFMQk1aMXZXU3BDWTdIMjdURnNEQmhvdXBPUWNvTXRVM0duM0FoYllYUkc2TTFqU2UzMGx5MlR4YlAvelNaZGNSckgycVAyRHVnVTNILy9vWktEN21FYmpyZ1JLWkY1RTRjVWExSEhJeEFxU1dDT2wvUDVPcnlqTVJNZ3JOZFdJR3hYOEZ4cm1DMFZ5VW5neENpNjFua1p4RWxEejNJVTg4bGdxT2hlbElHZDdQbUsyNGx6VE4xUWMwdVdLQlJMNzE5YmJRRHhibTdueDdKOEY3RXY3cHQ2c1NkUERzZXRKVHM2ejRyM1lJUmNjdkp6bjFGWVNoRmk2akVSQms2V2REYzUwcnQvcWFCdWZXSlRkN2x3aks3eEFtT2dmeDZJZUU1U00zczd1MzQzbjJRTW96U3VVMk9XZFNNOHl4TWw2ODA1MW5KSG9KcnpKRDQ1aVpFRjN1ZVhhZ1NGTEhKVGsyOWJxWjVsWE41M3lPMm5YTVBwN0JyenVFNmVmcSt6aDh3b1EvTzg3aGo2d2xOVk9rTjBqd1R1SlFvQ0xXR0ZxK3JyenJZdmgwMithZHNTRi9GMUozdzc0SlhPWVh5eW9tSkpPOFY4WmhzYXBwdStpdFBaNTllUFhZdjY4QXpJUG4zQTdzdmFCL0E4bTUwZTVyYjNYMlZnUFNJNXRubDVDZE1vaVNELzZWZnYyK2daMTdvbkVGb0lUZU5vOE5iMHNWb2dJUXU3WFRBdjkwUkl6RG12YVpnWHJLRzMvV013QTNwaHlJeExwWHh5cGdpWVRDbGlaeXd3MldYb3JiR1BzWFpxSkN3UUZrVDVQYW1ienJJMU9wTktJU2dzRUltYisramlNaVRZUWNHOFpnK1VXSU40RmxEb0tsMHFxc3lhcGZROVpkZEJRMTA1OElxdUsvL0haTkRBbHFEM0JTSlpBQk96S3RzM0d5aVBWVXBYMXBBTCtYQlNBZDhGUzBKNWU2akdxcVNCUXVwTG5oeDFiN0dYcmhGTm4rZUJPdXBPL3JTcUZodHIwNVhSZ2FwN3hsaFE5RXVnY0pZYkl5MnVETU9SWEZOQUYyTUNGdm9zM1hkdFJadGNJQk9Lc21PcVp0MTQvdkxERHltSitxaU9PbzgxVFBEZjh4cGo5NVNLSGlNUkE4U0VMSkpNSkRxUFljbVNiaWRJYy9ocE1aOWx1MDVkTDYxTGMyYXY0Y1RFZWhaVzNaSG9YRTFnMVdQTm1va3JFdVlCcG9SeGU3djJOQW5XWmhsSGdxVGNRWUduWFF2NmxtL0ZHQTZ5OGhocmNqTHV2U3RObG0vbnNMMSs5am1lcnc0VEpQVkEzRlRQQ2h3eDNOMkF4WE53Vlc1aVRuMTAzSmVGaGNXdUc3dVdMb0wxd1BoREFIdGQzUTVBK2VHbkgxYmZ0NU5nSXpucWhkbm50NVFMdFA1eG5pbFhDSGhsODl6THZkY1RiZ0ZvRzk2VmN1amYveXdRRUN1VEhWUzRxYzhTRjRvaGxtb25KNHdzYjhCY1NGeHdvNjc2M1h0TW5oaWJ6cnNZTmdNbzYwWmhzQVd1RFNNc1BrVDJsdU96aUxSTndqSFdtTmJOTS8zMU13NFpRUHFpNndWRHhjZzZoWnM4T0tDRXNjVllnVHRndVkwUmlsMitycm5pKzdlZmVqWXNoK3ZhbHFiTms5VnZiVXM3RFBoZUJWaVk2UncxaDZVMUYxZlY0VjIvcXgxUW9ESUh3TFltM056YlpBS3pwT3hwMmdCc0UxcFRnUUFvYndXb2J4U2haMVRGbzRDRURPYjJZRUZyVWNaZFVnUXdZVnV6MXVrQUFvRmxjMDBrbkJBUnBJUjhiNlovWEwzMW1pVGNkMjJ2QVVwdG1jbGRrOXp6ZUoySHhsMFhHMDNxMDZQVVAvanBQVjBiSGxrclk4SVdmZlZTZ05XSFRUZ0w0R0szc1J3TGR4ZUQ4QVlQUXpuOHU1MENkNFZ4clNnRGZnRW95TmxzQmszNWw3NDR0S1lYUmE1Wm8yYWV5d0NjN2dPbVlaUmRFNzBuMkt6SlBHemdoRElIQTFNdGZGT01RZkR0b2MyV3JEQ0tmOWZQRGlnZ3lHc1ZWZlpLaytNNk1aNEdmTmNFNG52N2pkVmk3WFhjZlU4d3FKOVlWQkNhQURZNVl5MXo2VmhIeXVia0hwbWVEMlhqc0lUbjlmbFNNYTZXeDhSNW5CR2kzbCsxNnN4Qi9MUjd4alNBV2U4amZDK2Z2eGlMSnRVcm9IeVVVdGd3dXg1WU80U0F1OFE2VHR3blFUN0xxbEV5aFg2S1J2ZjNtL2ZtWTRwRW0wLzdGcWNHck9mU1FscmN5SHFZZi91dlRzLzFBYStZTDdkc082VmxYWWVKUlBlNUFMWVRLUlI4ZWxJdFZFS3F5K1A3NG1OY3lmL3RYLy8zV0d4cjFmeHQ3SlRoM0MyZWVGZ2NoMk1FVEdNd2VsemRaVGwxamhTWFVmaDMvTFI5a0Nra2hvemxDSDV6d1QrOCt6UnNVVEJmUUo2eXpuTmsrRlN1Nno4dUMzeGEzT2ZxcWdCdHdzbWQvYjdDU29hbXg1cDRGTEFTN041S0FjVTZieW9qa1psTW9IcW1ERlF5aU5Gd3Q4VzlUazVrTGdPUXhpTWJ5OEFkQmFxRVh0S0V6TFUwZ2ZVU2NPWXBNQlNzdnA1aGxFM3hLaG5QekUwc1RFVTJ1RFFQRCtzeTJMRzIxbXFhT2VZMXJLVm8zQ2pQZlJIemREQ29EcTNpZlF5cjR0SHpDeVV3OVNPN1hFb3QxTW05ZS85SDVUTGZyZDVuMEY2K2VCTExldGY5SENXWDJ4YXo4SFAwYS9aUWltRityZmZYUTNJdjVMRDI4OCtyLytPLy8vZVljTWZlRi84VnEyM1dlazZ4cEhZT3hPN1BZNWRhSDVFemh2UzJwQmdXamRIT2h1ZzhrTjJ1dDkyL3N0NDZsbEIwbnM4T285dDk3aDRXUXJHUjhWcHYzaDl1WTZVWkI0eUNXMmRpWUkreWxNZm1xZVdLTFBCd2dFdnNxL1VXTW9FVmpEelFBMEowbkF3WWF4UGRTK1FNV1ZwMHg5L0VUR0VDUTNiZFdEYnZHZEFFdzIyNzZTYUdvWElXM3hGWUgrbzJuMWlDWkY3alJxQjE0Y0RjTEIzTjgycHdYYlNpOVc0U3VzWmUwaFozYXRBQldVRG9JUmFVaE85TDRHMHlpRTBZNWNiczdPcFdJdUJha0JxR1BoS2dsdUtpQ1QwNmpwNW1uU1lMaFU2eWtzT3NCTzhUbWlaWnJ5c3ROSnJwMEMvWHIwV1gwS0NMUzZDMHovZTVCNVh3SHJwRmtqMENRc1lnbUgwU1ZjZUlYbmFncUpOT3NJMHUxZDlqYlZoUWpFVWw5Y1pXNE9QWmxEVnM0MFBBck9mcjI4NSt4WmIyeHVrMCthenJ6QUlXbERYcGsxVkpzTlVrQVMzZk5pTmpnbE9YMUNMN1BKcHNRN1BPQytNdU5CQU4xN2kwWXp4NmhyRjJXR056eG1JVFNxelYvU1k0M3Ard2gyRVN1OVd6S2NwTVVWbGtSOXJ2VlY2aHJPRVNrR1RhSE5ScWJWZzUxK0JHS1F5MHRqWUsyMElpRGlhbVk4NGNCTHRqbTFaeEx5Y0ZqVHdrbE43dlBWeXV5VW8xZjJjZHRDRzRLNVd1NnZtK09Cc1pQQXhvL3ZxVEFIc0FuTFdmbUlmMVNmQmwvQmc2V1YyeE1JeHA5aHNtTndEc1BPVnNTYnYzU1dDbkswZWRKbm9OYzV6ekpBTXdyV2pNT1RaRUdVWVd6RkdmVTNZaDhDNFpZUDRsQXF3eklKVFpITXRQQVBwaTVlY244cGNra3dselpLNEUraitOa2NCb2wrMDk3c2Y0cUFTbkVrSWtzdGJRM0R3QU5ic0g2SlpTQjZDOHN4dkFwZ1BtVnZadjlMSDdZZXAyRjlqeitJOS8vREp6OFZTY3RiWGtXbzRybHV3eDlNQ1RWelJ4cmVhUU1RRVNYR08xVzJUcEVlaDRpaitmQlhoWWF3Q0RGTVQzUmg2QXU0UVhUNERScGwvK1BnSDB4dVBMT3BrRUpVTEwva0RHTm5zZUd5YWFBSXdzbTdPcEkyek9QSjlTbm9VMUxSakNwZFFQbnJNdXpveDlNcnppNVF6SmJPYnZPaE82R05ja2hCUElZNmtGeDB5dVdpRytLS2V1bHl6VExLeU1RaitsT01DclA1VDVFK1QwT2ZHZVptSVd2TFhwUzREZTRnTWpnZ3FrdW1LNFFxbWd1b0pNQWhUUzVGS2txS1Y4MTJJc2RWbGVuUVVTUndTdC93aEQvMHptVFJwK28rQ252WUVtNExEZDh2c0o3azFLdFJGTDJ5K3VjcmpQOTExT1RYYnRxVk5wOGRZQVpVcmxhQ1hGcG1wUTdIWGI3RnFBUzY4andWZ0xTZGc4NDIzSWR4MWJ2QW53TmxQK2t6d2NRT01VR2ZzS0ZRc0srdXJ6VGtobEdWKytlclkwUjh2aUEyM1hBbENBV3FBYk9BdnlBaXIzWUJBSUJiZENESTBSOFJvUW9Vd0F4Unk0aHBqVlNkMFh4RnJFa2JobXpYTDNVRUVkVURRbjJBMUdhS3NMUUtOZ2xGbjNneSs1bEQvOWp4OGJ1L2dFVjJHcFdwOGFxOTZQWFFCSEdjT3g1TGxWMWs0bXFNWHZuZ24zZXB2VkM0YUwwWGdtVEV3bkI4OWVvZEhjYjY5TjZ6cVgycjR4ZFcvSmpoMEkrNVY4N0FkMlAzMzNmVzJFbXR1cmF0dUtMM2tlckVXY1JFbkNmY3hPTXNhMkpZc3ZRd2cwVllIYlBEOVowOWJ1NENpR2t1eTZ4aFNOMXY1SVgzbEtyWVJDb21DdDkxdFR5cXhJYzloVWN3eGdGWjNxcm12dEdWa0tRazVkeTV3QVpHVWw2OGtzbDFBakFHbDJ5dG5iNWxuTnk3amFHU054TEs2MU9pak1FR3NRRHdWV1R3djRNNHhhMEt3RnFNSWg3OTY5SFRsVTFJa3BnZ1lnSW1hTEphNjNKaHQzNjdHeEw1MTgvdXZxL2xYbEl4a0U0RStXdm5ROVRNbXhXcGlWTWVyekx3aThVMDBpOW8vaEFJa2VlUWlJVExtMjJIUnErc0oxSHdGMHdHSWR5RkJEOE9lUjMvR2NXcGUxbnYyeFVoNEVCYnc5SWcxMDJMVUJYd3g0TDczZ1JtUGxkRmU0UklpbEJRa0VtNmNCb1g2SXJpRkRnTndtZlRFeUx1WFF0KzdoemY0K2Vrd3V5SWNYb0Rrcll0K1lPSklQR29nUG9KVmNGTEdRUmpuV1NucGVVTjVnREJ1NkVyU2JYRDVNYUsvRmd1QmlHbUlITEM2bEdwYlIrd0VJQlBjNWlnYmtKbU1vR3hIU0syZmdVazAxZWRkalhiYWJEUDcxL1lQWGwySkYxY3VYZ1plYXJZc0M0WWwwejU1aVhSUWpxQmFMQUxDZXJFNnlGbnJudm9vL2RQL2JSMEp2eTBWQ210QmdMSUxoWWpsampSdnpnSGozdndiS3VZL1N6ZTVoeTQvMk9nVGJOcVc5L2RwdnBNd2ZLdXhVTktsQy8xMW5LV3FJaHZZQ2JFSU9iS2F1cERuR0dKclFVUmlaV0FBdXNHNmJpdUphYVhCVWVqYVpkZzBDQVBTQjZiQ3hCS3RIUzdDV1pJSm5uV3B5Nk4rVWZtTklEQS93TWUweVVHL0x5aEVVOVVxeVppMjVZb1BXcHMvMVFReURRYUN3dnJFMDRNd0NXOHUxNnVtOGQrclErZ2lsbGRIY2ZWVkxsVUJVM0VheExDQlY2T3JaZ2UzV2JZclgvSEpyQmJpeDJLUGVjL3I1WGVwWlhLalhTQlBtT3lVc2hKMFJOTUNla3pFTitjYVF5bDdxaElHSllKYUN3eXJJZ2Nmelp4VjFGbWM4TFdrQWlLWHJ0MXJiUkhlQTJGWVNCb0J5VWw1clRaNThQNVl4WXlSYzU2elBtMXYzQUdxVDljcHRFOWV5cHN2bTQ0eDdpMEJtL1YyWmlEb3ZBSFhjQnU4LzNtSTc1bit6ckhlc09ybVJiY3ZwREtRdkFxdnR3aEJ0ZUM3MktMWW5sdk81Wm84U1B6MzZ5SXpxOE5tUzB2eE14alBqZ1htTEs0M214dmJGZklIeFRlR1NYWmF4TDYyYkZzTFFlS3ZOTUEvV0RiRFFoMUJvNU5zQ3poNjlYaUk2akJ5OXhjd21ydDIxUGFPTU45ZjZNVFpZTzk5QXFtdjE3N1F2YWl6bWt5dDRsYTZLUldLVlBCblhVWnUxZUZLUmdQNXpQYnBEN3NYdmpCL0d3SVAxaU1IVTIwV0lib2N0SmdldEV4bHVpbVVKRFJSL1dvQnE1TFlwdGNIVjFLYmIvWUV3cGZqelJGM1E2Z2RJM01jbHNONzd1Z2IzWXlQRW8xQTJMYXErVGtxSGRsTWl3bTM2Q0NhYXY3ZnJvVVBpL0hHVEpoNUZtRm1UVWV6ZVMyaUdqU1QwVXRBc3Zlc01UVzNTVk0yeklENUg0Y0srMVc1c1p6OTM0K29ULzdycnNuQUo3NzFKNlQwN2dZRllnZmdiWUpnejNDcEgwSWU2WVk2d3NNNUtEaTY1Y0lHU0FsSEI4NWt2RG10ejRuVWdnTVZBRHoyd0JCd0I5THRpWVFLZnJKMUJlUTZMeEcyYnJSZFpia0Y3bTJFVlVXSkc3dWw5bTNzc0xJUk5ZUk4yRDl5ZGU0Ykc3WE9lRzdqMk4rOG4wR3JFdUFYajFuUWRhOENTaTdYSUttb09oNG9UUnBhVkFBYWJ4UlpkaDB1OUdKbVpyOGJKNGlrSEVJTmhiYTJ2WjFQQ0lEN2pHZ0NTZ2x0RDdPOG9waVB3TDRiV1cvdkswQmduY0k1UlVWNzFic2ZGMHc1alo3YyszMXlLWHdGUmNWQXk0ek1QZ1RaWFFROGs3cmhuNHg1T2pLaGFwOE5jcm1HbDNXZzV4YVprUUVEcE9aWlRoQVRIbHkwdVR2Tm1USFhrVkVJaUxERHVUdGVia01VTUZ2ajg2WXIyclBaVFR1ZUpubStBbW1UMCtyaDN2WTlMMTZDN1RwOXJ2QUNMd25MZGg1MGxyL1lhQ281YlJ3RHVqTUcwWm9EWTlaOFZhMUxvSlZ1bm1wOEwvZkNnSzhUaWlsMTlTQ2E2cHZER1FjeGVFZkxuYXJyb0N1WXR3VUdSelIvREtTN3FjQmFWNmtEZE00cnpJaGozeWNsZVpRL0FkTmtFbjZMMEdubkhOcmxoa3dsdDdiaGlVKzNlZGNWSjdVWlJndEFTUm1Ra05CaXpWamMzanU1MXBmRlc5Q01MVXhxSFY1TFo1bFVvaUQ1MGVkTXdmNXY3bTd2bWszcGdhTE9kTGVQa3V2VEYrKzBKOWV4aWRaSjV4dHBxcFB3VUxqQlNRTG1Vd3J1WW0xRStkOEcrRXVxVTB0cTJSakdDeFMrbmhPUG5kbWNMeFdWY0JETWxUUWluODZCRjc0WnFmMFl3NXpFVWtySXFMVWorSDNxYnJJMjFHdGVneVJLTUY3algxZURKODdKSVhjZTFmWGt3K3hBWEZ5QUwwT3VVQmhqc0pyaGJ1VUhQZDE3UHd3dUs3eFVqdUVwWnY2YUUybFNveEQ1S2tCVTQ3dWY2YkVYWlpZUXdUc29zS1ArdDNVbTZtYkwwNEQzL1dMYWVDN2hvQ2IyNGJnNVpPQjNnZU5FMkNxQnEweXgyUkxBZEg4OGxHTmh2bmlhMjBMOW8vV25wZThkM3NUQmNuR2x4WEp5cGdmZU0wZVQrMjU4QTkvb0UxcWUwSXpZd3dOYUVZUXRZRGFCUmZzQzk5THczV2RpdnNZUWYvL0pEQzk2NWhzWGZDTFcxMUFyYWRwdjhyb20xWEJRY3hwZkpBZ3U4RVlpcHJyYjVHZ1BXK0pCd29mVUVYcnhvMlQzUE5XK01GcTczcWFXNmpEWE04M1dkM2w0V3NtMDgzZXU2dUY0OHBYcXlqRWxKRFRmYmFJM3ZNMmoyOFRFQVBnOUE3RFVjQnR1Y1NNOERydW1TMEh3dVBlVzdXd0RFQmNLdXJJa2kyaDQ5a0Q1TlJuTnpHNGVESjlUd1llaGZNeUJPcTFaajk1RGJzcDJyZEZidDBHRXRDUURmSkkrTXFtc3BsRzQyWmk1VWNJK1I3SGNhaDdGNlZqY2I1dEJyZEF6WWN0MzhEZFBDakt3VlEwSldCTnkxVGdMdXZ0MkhpNGlOOGw1bVUzalh3SlM0czY0NnpFelppK2RzalhrRFNtYXN0OW8rckZ1c2tCdHJiTlpDVEhFM0QyZUR2amFHWWNPdDJYYTdNbVFoWFJQSUdvT3hxaTdmMnZhN1RmM2M3Vjd2NTRtSGV0YjBlVGUzdlFkc0hEeURvUzZOWDBobUlUVkF5cFJNckE5SlFXd0N1S1dVWWY3UThNS1R4c2h0eHNDUWtQSHFXdStCTlhxZExFejV4QUJkVjAzMy9TNVpKb2tqL0ZMOE9yY29nWVBHa05Ha1FyZjV2eFNVVytKbTQ5Y0NzQlJhKzlLdDZtREVCU3oyM1VTM1RVQi9TeTBoNjlSUmVTVmhtWDdRQ2Qxa0NWcmRZUjA5b1VNTWdFQ1NPd0haellSSTM2djdBR3ozSGtyWS9wTHJVaWJzTklIakxuQWRjMzU2endLQTZuSnNlZmxTaW56aVRpeDBDMlovM1dPYnBDSDhibkdFcmRMNTZ5M0lXa3lNcXplV0tiQVNXSllOazZLMm53a29rOEFKektmNEFIdnFyWm8vZ0dtU2JZTlFnTGdFVTV1M25sSFZOS0d6aEk2WHdnaHNnQldVdGROY3R3b0NOSS9iWEhDOUxJTDVuODNOS2F6UGNHRVhScE93dFNabTFCeWJXL0dKc2ZZcDVEQXJRalRLV1lLZ09BRUxQM0hGQk9PWG4zOUpZVThHbkU2L3RGMm01OUFicVVjc1psZWdkektPYW82cUN6Tm5vYkpua3RCUVB2RWxaZWFTRTBSZEppbW4rTXBoSjI5ejdYMXp1WHFpL3N1VlNDYk11N0lEdmRQUHV4RXJiYXZWVGF3RGszcFNWYm5ZRG9ZTjZQWHZ2a29wZ0sxWW1JeWluUmVFbVFGakVPWUU4dVplUWVSMzFhUmh5aGpCZGd6R1BhZHNvZlV6aG92S0xnRGZ0SzBKRk1YNUZHZCt6VFVGZ2t0OFZtR3JqZEhMSVEzcXhSaGd6MktkWEQrQmIreGlpZ3M3Rk9RbnM5eDRyRnQ3SEgrZnRzSE5sYlc5andvQUR0bHdydHE0LzYzbk1FTksycmgycWxHU2hiTUdkTVEySExGT01nTzhUTFpyMmVDdWdOczJLN3F2ZUJPZ1lDYkdmaE9JVVg1RVkvTXU5N05NTk9acDdmV3JNKy9DSnd3RHBzMFFpQzNSNDNINW0zT3E1eHFNV1VyYUdzZkVNdWdNcExaU0tXYlBGSEExVGtGMFdmZjFqbUluaWZSZitZSEVSVDkyb1lHY0daOExEOE5xUHJyOE1EZi9Nc2kraGdoNW9XLzM5MGtHWnE5bjRXNWJ4LzR5NzdPMTdpRTNkTHY3em54anhMWXZTQ3ZhVGdNMVVVQVBJNlBTLy92MHdxeENZcE52YjltNGE1Q1A1VXp4ZU5QZUxqc2lrT3hEQ3VBZ29wOGYraG53aGdNek9Sc3RCbVkxbHJsczIzMDFOVGtSYlN6VytBOW90Q2dKOGFkUHQ2dnZLeUV3U3hUVXpuVktTOEdtZFV3b3p0TEtWdTJra0FETFZneHUwMkV4aEt0NkVHMEhWblA2U1FvNllOaHpxaExlVGZsc0UxTDF2QnRqMkV6bzF3T2VOR1MxdTVhZ05QUVpZK0lrcG5PZjhvb3pjSkhPeWtiWmJzTDZMOHFmQVBWWkF2U2gwMmhZRWNLdCt3S0xCbWdwTzhvK1ZxYzVZV1hVRHdFb0Nzc1FtRTlXbWRJbyt2eVd2ZUllV2hPS3JNcWRtMGdvWEhzalVHWUlDTTYwMlduTi92Ty8vbGRNK1c2S01hWDVCZktkUnNNZEdoRHNHVThyS3pnNTRUNHBzR3c5bWxQM1BBak16SUZFZ2tDMEpaeVlEemV2OTh4WmQvMXJQTUFOWEZHaXhWV1BWVFQyblJUbXB2alloQVI2cnFQV1E4eEhDVUp2SEZacC9PY3BxUXlZWUQ2d0FwRDIyM0Yzc0NKTkZCR0IwNTdoYVIwdkpFb3dlMGtIQU1jZGw1bWRIbVBWSVMzbk5sWmVVVHpyYVl6Y2ZGTkVYUThXTnpHUVNmbVVaSHpxL1I3T0lSS2ZNallNMWNJUUZ0bFU3UStBM0E5NzZuRmJwK0pFeVlBc0pObVFNZHV4SGdFWUxzeWcyVDJ4YkZsWjNHU3hNYTZwQjluTFJkemRyTEN5OWNja3VkU0ExUE9JRXlweEFDcjJQTm9mZU5rYUxDQXJZOGJ3TDkwNVBqT1dmZE8zKytaYlVIcGtvZnM3SEdKQVBZSHdMNE0yblZJR2w5S1J4c3lEK01ieXlDMGduQ0pzU2h5SXpBR255UUlBRklheEJ1YjRNdmZ5SUYzY0RhU2pDVDFUZ05uRXJGYzIwMnowVVd3WFMreTcrWm9RMFJBaDRPVFNvR2h4RVozU0RhNFFvU1hPbkM2bkIzU2RwMmVjeXo3V2pGUHg5SEhoazd1OG84V2lMSDU2NzI4aVdUQktaOEFFc3hFTitqNEFqd2FHTUMrSzF3VmFvRDdRNncyZ3o3aW5nVGJUM2FRSDdnSk9KSmwzL1BrYVp0VkxBYVdpc3dLUFRlWmw1eUYrQkFLVDNpeGdXT3I3cjMvN2Z2VS9Ici9IUnB2ME52cTJuNUJnamJXTDRjbFNYVnprRmpVSk96RktnQ1hUSTEwdjdTNGxMTDVqaTQ5cTROWWdKU3NqRmpoNWp6UDJqckxDRTRkcnpGelEvWlF2YWN5S2VKN21nWHZRdUUwZ0txN1B0UVhXNS9yK29CWXNDZmFYdHI0b2F1emxtUmV1THNYNEJpcm1RaGJTM3ltRkwrQVBkSUU2Y0pueWpOWmlZakFCRnpmS21nRHFFY2JHWjRrSFJGTVc3Z0VXeUtqTS9QUjhhb29jdXFvLzFiLyt0NTk2L3NlMmQ3eE5BQks2eG05TlpVU05DMGhpcTl3STJWbWRSamNyZFNBOGdFQmQyQ1E5R2grUTVIcXIxd084MEpHcnBSTFp2R0piNGlxc1BJWjFOVWZjTjVldHhXM3Z1VTl1bG5XeitSMFRMcWtTTUYzMWpQYmVBWFlaek5uQ2t6SUk5Z0lLbTlxNVBhK2VkMXBQcnVSVlRNMkdZcFg0UU5wOXVkTnYzdncyY2lqWm9hWU5tR0VXWERIR1piYnBrT3V1aTBYWjR2WGw0K2xVMzR1bE91N3FxT3ZMQm5iRFlYKzJ4M2l2K2Y3R3JLMi9rSVNzNHpDd1psOXFuN2lMN3pMV1FJUkxPRzVtc29RdEEzWEtLcGhzL3JFcEFYYWV3ZWRLUmhUbnZtclRPYS9oano5VXY4ZkdoQkx1TzcybkpJd09Eb2x1TlZiSlhqS0t2V0dXcjhwR1lwUFhOekhZNXVJZ1JnV2t5SXRlZFkycWRjWjBzZVpsVjRYNURGcG1QRTFIWHhuTVhnTWVQckY4S20xTjlza1BvTEhHZGh2WVNTQ21kRlp0RjREYnJJQWFxSk5yTllCVCt1QkdzYjVIOGsvM2pTSjVFNGRzS2xzMzh4WGhBSVR1MXM4enB1Um55aG1hUngwMXlBajhXTFo2WmV6SnZ1Y1FIMkNGSUpNUGNnRUJqZ2t3cVVzTlI0dnFBV1M2ZXEvT0NSNU1wbWFwdXhFUUMrQzZxUlEyUmlPV1pTT3E0clJwNzhKQ21NZ1c3VklNcUNjL3ZTZ3RXMEZleWQvVmVVTzR2RmxBWnFkQ3VDZWRtck8xd3hJQmtQMkE2WEwxN0pVYUZTMVJVcjREV1JrMU4rMVBhMThaQUFBZVRxM2xkaERZdXp0VjRGclRkcTJ0ckRoc05VZU5IbEJiWEpNNmFYT1RHTk5yYmlGcGtwaFZxNkxZd2dOWFI1RDEyTU5BQ2hWbEFlc20wV3VFeTVIMzRHUzZBSFM5MmFQWVg3UzlrVTBSeEx6TUlrYitSaEVKZmV1VkFNdU9sdUx2RDh2aEhheWZRelFEMnVZTGM4RUUvVHRDMy8wQlIvYWplMkN5U3haMytqTUYra3Z6dmJONnIvK1lPM3F5ZXZ2bWJjSU1VSEtma2p5SkZMRWI2WDhkS00yWk9CQ0RjdDljSGg3MEhJMExXR0I3T3BxeXhKUzJTU3pRWFNBNXdWelZWWVBTYzF1QWt6b2kxK0xpQUN6S3FXZFlGeC8zNGpRQkp6RU0ydGVBNlN6M0hkdmxPajVKNmFaSHZzMjFYWE5KR2tqQ0FIVm5KblpQY2JBQXp0YVZFKzJmcytUQXc2RzBud3BDcS9uN29XTE1xZHRwcmgzOWZwbzdxYlJEMGUxNEVjMVZBMm8rOTlwMjFKN0NHT2YzRlc2dUozK1p6ZFZocjB1TUM1cHowL2NDV25FdFI3bVA2OVBIYjVvTHg4RFBDVVN4NDZ1cjVMSDVTTndtTnFhVFNNdmZmUEZFZ0pRMXBtVEZMVE9VR09kaENZc29mR0JRRExqNzZFOW1HNUl0V0U5eTRaM2ZLTnVzV2NEK1h1VXJ4VTR2TDl0MkZVaGQzRmErNEdZOUw5cWdHKzJBUmZjUWVoakQwbmdBQys5Rk1vMnhZSVRjV3h5VndSaVFTTkM1L3ViR0NWZ050ZkcyM3ZRaE4xNGNkTGZud1B3amY4TnllVFozM2VmazhObUF5cGZrNk82bUEzYXh6blJwdC9qeFl5Q0RnWWxma2xYdTQraEkvOThkTWc1NVVPbldnMmZvMmFhc3FwdTdQOExCU0RFaVlvQ010WHZ5cXVBT29ySTUyYm4rSU5nKzFzU2Irb2JTQk05ckxQTE1maFBnMHRxcWpzc1k1UmIwOURmWkx1OVRIc0JuVmh6b3huNzNuaWtPNitPQzJsZUtNRnVRTDFXTjMxVUJUcGtFeEtIZ1h2VHlXVUw2MSsrT1ZpK2ZDWGptTnF3RkhQWDhFY2NTVDJLOVhCZEFiVWV0K0xxQ2k5aUw5RDVyN1l0TE0yeWhlNWtrbGxKdERGZGhNbE1tRUlzSnFFd09Sc2thQUlmZVBkc0pLSmtDUFdNN0tIQXFIcWRsclJhK2lpOGhQNENqTEZvdGQ0bXVKZjdSRlhwK3dyc3NlaUN3MkpzVUxJRUFyR0hPTU5BK1k1eUFoNlhyMThBOU42UDNqWVhwT3BJYlU2ZENLUklLNjhYS3lxQ0ViUUhURXBQWmkzbHA2dmUyRGdpWDFUZGhEWUFBdURxc1FjWklLbm1ZVUo5WHRxSWJobWNjeW00dEFsZmJSdndMUU1abGFGemlnaFNTYStsZjcxZWgvZTdkdTRMcEp5TzR4c3RWN0kvZGQyRnZaSWlMOWJHTjJ6cE5ETlBMRGRKZFZXVzJqQmwyNUJrQkpWWU1wQmtkYTZ0ZHprRUE4ZDEzTHlhd3JkRWVrUHowcWUwb3pjM3JxdVVaVzVsV0RROHhRM3N5TVN5dXNOVjB2YTJ5Wk9RUUk5TjJXVDh0ek9Id3p4Z2p1Ymdxa3dmYVpQVllmRWJ4eGNzcSs5TUgrVENsQ0JRLzB4NVlGVlB0ZFhFbmNyS1RvdnFNdFIvbElsUEpoZENCYTNvdWpRRU91d2J3OUNLNXN5MkxnUDM0d3cvSkQ5UDNXOGZJL1RFSkJITzB1LzlqcFczdE1RM01rQWxWL0ppVDQ3S004MG9WT2tLQUlBUkk1M2tVbXdISXhJMjZIdUlSdmpYRzdwcUJIR0RLRUN2MlZVTEI3Yk5HNHdJMm53ellVbmZJWTByZnlpSWZIUEZtMnJoK0J0UVcxcmFWVVp5dE9XdnUxMDZNMWs0NWttYzk2UGVkTGF3cEpsbHczdDdQaHQ3OU1QMkF0Ry9NZHZFczBwSGthV28vR1FXaGcrWkRqSGgwc2k3REZFdnB4T3h4SG0zc0RTT2NUWUk0MXJoMXZlWXBKNkRhZzNnNEYvRGd2dmpYZkZiQlhFRlpJR2VTS01HMFR2MVRVSFV4MWVKRm9KU2wyU3o0ZlhHcnVGREFWWUZmbVlnRS9VbXRSWjRFQ3Q4OVAxZzlPODU2VlVtdUQvdERsdVNoOTloRFp3SUJBYXZoWDRxd1dSSHBveFl5RnJIL3VCYUUxYjhOMmtnblZ1SncxU1ZlbEhWS3dCNnJXeEVNeFFwWm1WYXRkMG8wY01lYXNKN0RaNlg0N2UyVFZ0ZVRpaVU0S2RaanNybWIzZzlJbFQyWUl3eElZempDU0hETjVjeW5zUWM0RnRFYzNyY1FkLzBzbXlnNzZEVUN5TjRONENYODZ0c1FhNzl6UldScDFESVI4dWtSbGx2ZGFxN2UvUEpyejdaYWZmZlRQdzFvWXdwUGl2bE5JRHRqZ0laelA3R25DZFltQTZ5MkdBdEZ2NGoxYkFYQ3U3bG81bzFyaFcwelBoZ2ZLaTl6Sjc1Z3ZjMkJiUmUrbHVPdVNzQzBIbHpvS1ZvTVZCa0h4WDU2Tm4wdDhQK2hJbExyQTlTMDFkRXp5bnphZE0xdEFXVEd5VHlUUlVzbk5xYUxoQlBHZFVDOTZObUJwTlkveHVTRUlXd0NVK0htazRuZml5Tk9MNi9XQTZBNW9pck5LbVozdFBvbElPRGlQNjlqd2pPbExFMDZRMnZibVMwOTVFSVVudHM1UGFhU0kydkp1eURyWStCYUgxazdRRWNPKzhPd0czSmlyYkJxaktaMmJ6RXN0Vnk1K29GQzJqTE4reEx5NldQR0xXS1l6bU9KVGl2NjZhZC9UazYxZzdZRDRuWWFLNTVmZFZabmMvSHk1WEdnbmdmU3ZSZ3VzVFRuSlNBRjl6VU91TzFRamN4V2pKR0xXRDFUYTBRZUdNRDFDYmduMThPa1BCOVE3WGVmN1UzR3BYalUrOHBLemUvZXd4MXhVTVF0WU91L09IQWtvQzRxMVJnbUNKTUJCdVNQdFM1UHFKSTEzb2k0YUNWQkFlVnRvWVllY2NDSmdkMXIzYWV3dGRjMkdiVEdNSVFvd0YzRG9IcGRrOFF0dTJabTVLMU5BRWRuSW8zelNtVEZvSHNzNDBzSUJkNHQ0bDNLOW8xcG9YUmVVNkl3OVRvdUYzQng4U2J6MTQwM3RhcWc4RjFJZ2VObWxKTG0zcmNnbTlVUE5UMUdPWVZsWjlId05MRzR4RkY3bFdKakNTQjM0NGZ2TzVUem1FVXZWbkQ5dFpzc2V3bE42RVJ3ZWtnQ09VSHdIbERoV2NOdTNGbjZ3TVNZS0NQNnlQb1BrTFFndzFaNkJ0WVNxRXI3eWk1eVdUY1R6c2RjRm1DSExjMUc1VmtlMlpLdTNqTVpLemJET3U1V1FmOXkrM21yNE9CUzIyY0ExbUpGSjZOS2tjdWFLcngxTGFDR3Fpc0h3RzRjRFdWVHFrQzZjWW1mRVJvZEd5a2cyOHRLTXdZVHVJOEZZQWZBb1drZElIWU5BVXBiTWJTSmZ2UHI3MVp6K2l4aG4wNmtia202SjlBa3NNbGgzNG9WdmRGWUhHbEZzQ2kyb0xRc0YrQVV1TWVDRkxGeWE4U0RnQndGd2YzbTMrUmFjSHkvZ3RuWmtOMjl1UVhxeWZZbllZSHhNaXI2UnBYOHlMVlV6VzA5Yk01VjZrRWh6eHM3RUZLY2FWdU5MR05DbGhGcUZnb3BXRk1DZkp3aGE4SmoyRFZVek9pbzdBWXlyenBoeU9HK245dFVqUEZ6c1g2UFdTcXN4SEpIU1ZKMmJ0QWNvZFg5dFZybWloNDBCbXhKdlBGQTBpVk0rMXpMYkdDanU2Y3h2SDluODNCdVUrTzQ2cDdHL1N3WFZ0TkU1UXFTQ0R3VWdXdGhDT0FCaE94WFMvcWlWQmhDaVk1cW94S3l4bHh2dDlyeVhBV093aEZCZk92RXlLM1BjV3BQYWlYenJHUUJnQkpxMFZvN1M1b3VGYzlxSGhQdmNYR1ZwT3pzUGh2WGxZNXVieTNGc082ZGhvN0g0bmcwcnZaRmhsQ1c4Mkd5ZHYxMTVJRUgxWHdGTURlQlNzdThlbWpLcC9ZdldKcEtnRjdzZHQwdm1XM2VmSG5GajVOSmJ6RDNweEdDMWtGWGo4M3poYlZ2VkQ0QnZEQ3VwcU81NmY1OUoyQnNSbTlQdHMxVDg3UGVXaklRZGtId2dMaVE0dEkrSnpQOWtFNXdNZW1Gd1F3QndDZ2N0RW5CRFZpcUZzMDFQR2crclNSU1FyRU03eGwyMDhPYVpPaXRYcWxIVENnYVFLc08wQUFXQWJMbzhZYm12RGpIWTByV2V3VFVESHovaVhxcGpqMm5FTVUrRGlxVy9PNkZiUkQ4LzRDdFlQcGFsSEw4OUN3S29KRnArcEovTDgwNnZtOGE0U0U4ajRWdytpLzYvVFhoMTQ3RVFRdVViM05hM0hTOS9sT05MWmlxaG9SeTNEVzJBWWo1YTg5blFYdUdNSEpLSUhxUWxBc1R5eDBJcklaQjlrZnArS3RjTHJFSWkvOVl4cVFaYkR4S0JRQ00yZW1WNWhCTDhOd3FlWHU0aEFmSUpzK05OK25xWjNQYmExRnhURTB0bVRQOFpPU0FLNEVSaTFGSEpiQTlWcmI3blBWOEh6NllqMDV4cWR1QnRmeFNyZEZWQUtUZWFmbzdBZXhBa1RVN3pZMENhQlJxcVlEbldvRHBwZGhYS3B3QzZPVmtIc1V4ZkZGTUoybFRMdmRYc29LRjdiYXYwdnNKSGJmL2EyNExCZStDNC9aeXo3cHpUT0hON0VmRVJpZ2l0OXY2eUk3SjBtSldQZ1RRcGlDMnRabHltTEsveGs1NE54b3pBTHRxdlFEOTg1Tm56YzErNjFzYjVKU0hXK2I4UDJBbHRrb0xEeHYzZ0hEK2hoalByMys4UzdZWGhiYVd1dFdtTStNYVNud3cxcllqY1JXNXFlZTFCenF1VHVvc0lCTzRaMERteEppU05UWXF6L3FTNTlaOXArMUE2ZHpNYjVJMWhtVnBkOU00QWtSS3FQdUhmYWJZYng4YVdRSFd4a3VlLy80Zi85bjh5RUF5L0xMSVhHS3U4ZkllSVlMTWZQTnRmcGV1RmJwTDdIZGdpNHA1WVFYZWpZdUw2KzAxZnhKUFdzVmtwb3JieGJ5Njd3S0lqQ1c5U2dlU3YrVy9naGFOSTFQYjlISEprdHVVTll3WitmUVhlM0laQTN2K3Jwb3pydm5FV2ZzTWg0YUxuUlQzTjJQc3UyZlp5YWpjQnRqQ0tWMEtJYVVwVTdWdW5KajVaR2pUc2JWaXF6d1VCbmM5ZldEUVp3dGVzdU5yazRKZ0Y5L2lKZXRsN1FBV0s4enlBNThaYlc4ZWNQQzVKczdmQklhbldWY3JSZUVtMHRiUDZvcXUrdnZIQW5KVHZadTFuRjN2Z2RaT1FYS0ZsTWRsMkhZVU92YStPTXAwQ1hqNU9nR081ajRVdDNyM05wcnJIazNtZWtLMnhJVUNoZTR6WSs1aC9FTFpQWlNXeEdhRGEyUGhiQ25oRnZibjVUTTlJeUJ3ZWczS1R4RUlMQ1pEbVFIVENNcFlsaTdVLzB5OEFIbDNLZjdoT3U3WG9zTzYzRlRmamhxakxKZjFSZHB2N3NaSzlUN1RoQW5KR0FFVXY3ZDJvK0NzcmJuVGd0b0NNZ0tUM09nNjVvYnJvdnNDSVhkK0hzQ2tXTWJLY0tEendFMTh4cy8yQ2txOUt4UUZIREpNYXJDVWJYRHRnT3BkZ2l0R1kyM2NxM3o0S0lvc0V4Q2Jua29sT2dDUkh1L2NRT3hLUjAvenFOUUFxeE1NQlZJWXgwSHI1L1dwVk82K1o5VVA2ZUJKRVRCTFcxR0FsRFVTbXpvb1lZSXRYbWJ4UFI5Mk5pNEIyV21XQ2EzbmtlNFhveHhESUd5UWpLcG5kS0FFWTNMUTN0SEhydThvKy9OYXE2amtmeHRZeVpDK2lLVUltcnN2cFZOcGJqNCtGTzh0SkovMkFBQXhWRWxFUVZUQ2JFZXUweGdGcld0TmFtSWVneWxlV1ZLSFMrZE1TQ3YvOGVPN0FlZHZaeWhpVVU2TzBiaHZPMlhWc1JOd1h3YWlYRVlzalJzb3hxS21UN3NrdFVzM1BhZHlISDNHUEpzWTBtUkVtMU94SVRWN211L1JoYStWTWRncjJNVkgxb3lEMEl3UlRCZ1liTXJOelNZNGd0ejJjTzYxdzJDcnVSYy93cENUNk5YdFFabmZHT3pkWFZuUzlPK3V6QjFkQXpxWnp1U2g1MjdjMXZNeGhLRG53Zzd1T1V3b2tCTmIxakZqUFc5aFlrbnBrRTNLZDQzUEFIVHV1QXRRdjBxWTlHeFRxOFdvcFNPMkNXM25oUWhoYUhncEl6MEI5UjdKZXpkNmo0MXV4NEZ4eExQWHV1UjZuK3NlS3V0MzBtY05CTlJvVVdDeU1WNEphKzFyVVVhU3M0QUFhOGFhOW11WFhTTDNBcldVbWwvTEl1MDBZWnFHWVJ2cVJHeVA4WHEzRFdIei9kdW1NZnVTK3R0K2ZhOXRCRDJxOE5DQkFPcEZCTXBiaHRYMWJpMVlhbS9qTEVMeDdVbHJVdkVtd3ptSXJJMmc4bDVLdXAzcmVadWJRSEdIMWVYdnFzQmVxMCtXd1hxd20yaXNRengxZk1RNjFqdXZiYmJ3dENBQVNQWkp6SzBiTk9abUt5SHpGZGxJS1p0UjEybGtGaEV3bXpDc3dPdStVTmpOMk45T0xWa20xdFVpN3JRb2FrWENqZm5Nb3lUQ29GVGcxWE1xem1YZHVESmlDVmlGU24yTjdkQjl0V1A2WUxGKzdqT3VZOEp6Mnp5T3NpVGNEc0s0U2pqdXExVzdKanlOelhXMTRmaDgrcUV4ZHN1ZS95UUd3TzI1RGFTWU13d0EyQkFVMXJBWDVsN21DaGdDVlgyWERtdGI0Z3pENWREVkJEREx6ODJXS1h0NjlId0UzaU1CQTl1UTltU3hqcDhPNEVsMnNNamlXZEwweWk0MHNRTW1HQUpRbnVlS2tTeXU2c0lpeUlEUERXdHMvTUNSbkFIUkFaM1dhZGFnNTJXMHRMQ21iTEsvNXlVTERtUHB1b2YrNTMvOVkvVkRtNm5WU01sTTcrVmFpR3VSWGJMTnhkMEpNS2YzVlhNQVhPNWk5aFBHYUozVjFRRlBiZ2xHcFlSQytZdWU3MDd5b1ZCS0VzWTRKTy9UaFRNNVVxTGdXb3FFRy9ETXRYdEtURkhXbzdwKzJLN0VCVVFNdU1xRnlKUHpHRjB5NDB5RXI4MDlsbVU5N0pqZ2RaZ3Y4YjA3bWJRK1o0NzJ1Kyt3NE9ZR0VlREYzQWZpZ0hrOVEzVDhOTjBva2FWWDIyTnpzeXBaUlFqRkV1MXhuQnEwNHNoYzVRVUhXczJFZm5ZOWRBMXlZYTZtZ0RNOW4zWlN2Y2pvMHlNdGpiaUk1a3dBcGFYc0E3R3Qvcmx0RHMrVDY5SmVJNjlpZHJwclhMYUJ2V2tZeG0zak8yUGl6QVZzNjdRTHlDQS9pYVJvejh6cFdUeVRydGROdDlLeitFRDM2OXY0bXEvQ0s0dmdxSTNpdW13TXc2Q29pL0pUVmwrcHJQOXJRTjJzU2VjdmF4Y3NqbVZiekJUNlpTMzBoOUlxV1BkSUQ5Z3N4VTRLc25iakp5M2VFOVlBWXdxMU53cVUyMFI3V0VENzgrZXIxYTgvLzl3Q0gwNC9uODExc2ExZ293eWVpU3NNMmFDQlh1bnp5aHJXaW5PWlJPekZtQ3p3UTMxOHVDMlVVSGRPaXkrVHlDVTB5UXViRU5ETkhSRGZTWUc1c1dKTnlVUUt1YkFYTTJTQ25NYUNUdnZ5dTRrekhRQXhhTTJTSnBUeFpVRmtIUVBFZDVSUTNDUmtlRm1KN0t5blk5c1g2M1lUYzVqbWNqM3YxdFpoc1pCU3hMa2dTalhNTEZCY2hETnFUcmk3N2k2bEdFR2l6SUwrVHFWcDgybUFvRkpjZVlVTW4yZWFqY0s5bDRLSUNZanhZWUFXR3N2aVMyQWJRSWo3aXJsUUJITW9zeWFlcFQrWVJ6YWY1bWVZZE8raktNQlEwSm5iN0QrTXlrR29HSnU1Smg4eVNSZ2lodVdaQUtHOWlnTHJVdWd1Ymo0QUc3YnlNSzVlYzlrNnNLRDdBUkpYeUgwMTBaT0pFMmJZYWwweEFqR1E5L1doVjJSOFZFOTRMV1IrZmZQTEZKQStlMTRBdnJ2YVdpVE9LYTQySisza0pvcGhvUTZWRHNXdXlwejJiSWx3YzRRWmxsUm9ibndlc0x4NzEvbUd6ZGZoWWNlenBZakdMRU9xOXU0d3c2SjhCYXZDMHJIcjdlMG55YTB6RlpQSjVpMk5iWGI3U2xpbWdqN0F0cGFYZ2RzWXdlNWxEaFlMMWdHbGdiK2oyNDY2UGtEOTI5OEN4cGlabUtzd3gyWGJxdlM5TjJZc0QrTktJTXNPWWtYTlQyUFJVbHcyMlB3TXowaWVKYk93Y0hWMmdHQXIwckNSUFBpY2N6ajErU0p6WkFGTFZ1TTErd3BiMy92ZWIvenUyYzJTUi9KWmVDQndZZVRwdGxiU1ZiZ2tpMElsL2IwYkwrNTk5eFovcWp4aTFyVXJ5Q0EydUI3WlJ2cjJ1cWJUSnhrYjN0R254bDVIdUVJTTFmbFZKV0J2WlVNYzVtV3p1R0JPb3Q0OVdyTitEalFXeENZa20wUGpNWXJtRXlXSUJSQnducWtXcXBHS0JyeFljc3AzWGh6bkxDRzFjZGdSVitqMVlRclRsY2Mxd3p6MkdzREI3dnJxUllEMWwrK2ZsV25RWGJNaXVQNTJGS1BRM2tQL282UERGMW5Hb3hUeUxrcGUzYzNzZWV1R2lhRVd4WnN4THMzb0NCSEZSbE9EbHNDbm1waDhCdGtUcklVTEluWmwzTDVVZTZQdzYvV0ZBVlRpR2FNRS9id1V5bHFTbnFzRlV4ZjFqVzNhRnVUbkVWb0x5NVhyM2t2bVlyMnRIN21YTGNwU2xVN2hPbmFyWnhHUXZqZEozUjZvQ2pCamhBNVUzZDJKL25kZllyQmIvSUFQTC9DclE0VXY0RG5Qa1VCaGxqYi9xam15eHd0UVhXVTVDUWV3NGU1d0FmUmVPc0FzbWhQc0JSQmdaWVNGTUJKOGUvRzBmbUhoc0JnZ0JyYkVKNjViVjRBdTNxTlkxVHlvbzlJMjEvVzZYVjhMMEhBVnVSWmNRY2VsemFFV0tmR3Z1VEpBU09EYzNEczB3VGVXSmJQRTNkcm9NNG4xdUh4RXkzVXhIOEJveng1aklIYWxNeWZYMUVackczYTFtQkg5VUIzOXRtNEdkeWtYcHFVTnp5OGxITlFtT2ZDV1FqQlFXUEw3ZDFXeTk4VjRLU2NRdUxlZlVyTkdJTlBqZHNWbUo4QW1pL3ZKbXZFeUNPZXhUUFZhWE9KdnRVUkFiZzdvYUN5a0NvQWEvNVBLT1NiVDNHdm45OG92a3RPTXNKZ25kNTZTMlY1Q3dUSFZDYVAwd2FtSksrNmxIWko0bmpER01NSGNRZ3hYRFBMMzM5K09pMlROWmFNeFlZSURGQUhlYVQzdU5lWTdLUG5od0F2WG1FeGdvclNUa2JiV2pNeFdjanhiMkpyUGgrWWEreGVMbXZocVFLSU5OcEFZV2U4R010WHgyZ0VwVEE1NWNWaXdIUkhlbzhiU3FkVU93RGdQaUJrOFgrdTl4cEE5QnBDWER3NzdNRk1JRGE4Q0swTXNJaG1CMlZreWthU2wvMjJqeTRBSElPWGtNb3g5NGl3Wmd5M1BBc2VkeHM1Z0VFRXp2M21iRy9hUTB1bVFnR1k4QkR6OFduUkM4eXdCVFNoTTRBUmZBZGQxTFY3RU1mUnYxck5vOXpFM0p0RGZ5RDE3bm5WVkpYelQ0bTF1eGtRUy9QMzF2ZFYzdFliZHIvWmxJTG5zMzhseGdkNFdWaEhqeCtJUE93ZGxSL1pmcnY3OXYzNVovZU9YTitOSy9OTlBKNnUvbENiZEFVd04rcnI5YmMxYjl4Ym9GaUFXUkd6c1RlN2FnRzBUU2hLejJ1Y0pBVW91emI1VmsvOVlhSk5SZ0xJeDdrZjd4Ui9DL3hSMFppSXdCRXdtSnBiVFRiZ2Zha3ltOEJCRDhiN283MTF6WW0rWFF5dThSOWRNOVM4c3RTQytXS0ErMmV2TkY2dm43em81Y2tQMTBXWlJaQTJ4aWRNeU9WeEVRTE5FTmhPMFdGdDJybXY3bTZCbmRWS284MWRsRHkxKyt5eUJSaUxSWEhTVWU0V1VTZzlZZFl6aG9OTjYxcnZtZW11cXNQUHVzdmhQQm9EQ0wrbjVYTXJtaXJJMUdJbmIxVzF1cGtwOURPM1RwNENlWUZESS9xYXVSMmZZeER0dzFFMml4eXdMYWh2VG5kUjdKUVJUajlRY0NBbVl6N2ZWVzluUUsyTTc1Umt0KzlKeVJEdmpqbTZuOUQzemhkN3J6ZlVjRmh0QUFJNWhCQWt6cU4ydk5xdGI5LzRHRWdEODRrZ3l2Y3ZyRHZ2Ym0zZXJkN0dPN05QcVZUR2dvOWJEYVMvMndwNldkT2dXV1dYblY5Wm1Kam05NHlZbEN4aFBxemJ6cllmV3RGZHFNbFRRYjdkR2I0cGRYVmZRekVWLzJuWDFUMlA1dGRNK1RHNUN1RUNuT1JWYWlJVmhvanF1TWg1NmVNVzVodTFlMjJMV0lOeUR6REtlaStGcXdINVdLNWoxbDZBQmloamhaUjRLaHZQTEw3OWw5SThHck00elVsTUVXdW5BNDBQVis3bGQ1R1V0OEQ3dmdFSnRsT2lYMEFGd1lIREc5UXRNTHJvbUhUZzhpZEczYnB1OUZ6dGFidzZ0c2JEUFpVREs2Sk1sYzliTDgvbGU2bjZZZGNtZlBLYkx2QXF5amMxN3B1bHZsaXlQWHFiN3lqRzJBbUFobkl1QWVrdU1NTmFFMlNtMWlEc2xSK2xsYS91UWJPMTFzNXU2aVg3Tlc3b3ExbmFZL0R6RUFCblF0WjVuclhYNm83amlwM1NFbDdBLzMwSUZvL2dKVzhPT3dJU2k2RmdQM2NBOTFMSXhPRGVxakFPTUZPUHdNR0pYQW1rVUhHczh6NHFybXJaUGk5UktOeDlGN1krbG5udXdpOHN2WlhFK3BQTWRKVFdwUzFYdWw2c3ZNWVNMTW14dlN5SC8rdS8vYnhZME90N25OemNLME85MzFGVVc4cVFIMVdkcWMvdHdHTndjNHRBQUZRRk9nVi9BSUlPRGRsK25vRHhSeW9xMTJLdkdaVEhaWWcyeVVESlZBcjdvYzI4YndSbzIyYlBJQWpxNm5GV1J4Yk80WXpVQ0RvdEpJV1k3VXNERmJmUDVxV2J1M3ZjOUMrcmNpaVNBR0ZrZ09hNkRlL1Y3Q3kzV2M5SFB2YlBYdUdNWWsxcWQyR25QSStaM1UreHBzN2dibG5UVno3WXQzZmJkaGY5OFA2cGV0ODhVUlJCWkhBdmpZazI3eVFTT0taSTRrK2QrV21aMEdnQ0tNUmhlOStkMkFTaEhqYzNjTkU3ak9hL2JnWXpzMW5xbEtPYXJNVGt3RnZNSjJzWlFUUERmdy9VdFFLOFdTajkxNlhBdXBubmk0anl0elRSV0lJaXVLNEdZSW1aN25CdHBmK09YeTgvVFl1Vks1aXdRQnZxZWViZHhQU3NPeHZVaEMzWVpmUHJ3dG5CRGF4aDcvOGZQdjYwY3lxQjI3K1M0b0haTVNIM2Z1SGV4UEFMcXNJZmYzdGpYU1pGU2xHSlV6ZzNrT2s4Z3VYVlR1UzRaWUM2eEtTNmJ6REs1SnpNVUdHQ0xXOW5xdGQxNFBsV3JkaHJqQVh4aXNYTzRTRXE1RWZMejhpaTUrZlZGempCK1gwcGVwT2V0THlicm9BY0hsOXdrdXd3bGNCOVFTNkhGbTh5ckdycFR5WUNBUUFqbG9OODNBc0t6V0dBejNiZ3pqSlVSWUZtQzYrS3BXL1h1eDZhV21HdHIxNkRNb1ZEQVJyS0NuVnRYbTZGNUp2WTVNbUJDQWx4dXowMG1KenpSc3pDYUt0STFYWVFWajVHV2VSNWpaMWlTczBTc2ZtYzhxdUtUR1k3OUVqN0tPZFlrb1hyUFhYUFFMWW81QjVMazIyY3pJRGZ0RkRqS096anF1YzZUbmV2S0pIWWprVS95aEt5OXBBMnBFMmE1THUwb0dOOFRKT3dVcno5d1QxUTNFMkF0UkFTcVVmenQzRGtlamppSVZoZVVVajhpMWdhcmFOa1RXdWxXSnhjM2NTbEc1Q1BGYWZMNjYxV09ydVpmaEZsMlN5eG1DdkYyamxmL1gxYnpQLzVlbW5lekF6d1BmMWdkUFg4b0x2RkhBcDVpOVdCbmRXcTR1Tko1SWVVT0xLQ1IvMmFEWnU3U25Ka1dLRkhXWkhCNWxoYklCSEZrTmNJUFVudC9FMXVhM3JkdWtld0tVQnBqMjdpNVQySUFGcFQvN1FGWUVrcllROC84V0NnbUFLc0RiQUFiaUNUWFhjdnZNcVJPZWE1cS9iYUFmOWZVc2ROQm91YUdvdlB4eFNsWUt1OUhrUlVXY2szSDFXM3NTL0ZsRnJOMWNScjBXZ0NZSERVVzJVYnJBMElCcmZ2N3NuckxHbzRoU2ZpeEZhNGd0MUpsUEVDZVlHb2ZGQ2UweHFIdm53V1k1bHBXcVJLQjdpRkFQL3ZsRWhxRnZlTVd0YzdtZkJTaE9STHJFU095L1FVYm1jLzNuRTlpUCtOcUZEdTV3Yks2Ump1blJ1RzFtSm1hcHNEOC9kdE8vV2tNR3I1eGdSaEpCYWQyQWZ4UTVmcGw0TFhmbkRDYy8rc2YvOVc4Vm84VzJQejJqemNkTk9wa2FZdy8xaE9BSGRhSDNsS29pNU5aUHF5b1Z3WVJZQi9iYjVmQ2lIMXlzK1p3aGdMVkRNblVHNVk1M00zNFlyVWZjM0cxNVdrQ1ppeHFpTVJOc1FRZUJrQjBITHg3ZVUyYzY2TEEvVTRaVjJ4bFRsSk90dXlQQkFJdFhiTERTeEhUNnBmb3FjTWNISTdSQldhZUpuYmNPZ093S2QyNXhYNWE2MXlpazl4UWJQcHJKT0c2RmtCS09nRFVmb3hSeGpRN0YrQUFLREZMeGEyMnpjbllwYlBOVDdmK2N4ekpCaGtJNElIM01OLys3a2JjdWFVUFdmTFhnRWNlZDJwejFQV2JsSUF0dzl6NEo3aWViRTRJcGJWaS9MY3pzbUxYZDhrOE4xaE5ZaEk5aHB4QnBoOVg2VDNHL3hoRHNsZlN2SzNScSs3dGhQZXpaT0p6R09Qc3ozMHN2UjcybjNydEtOZDZXaktsOXc4WkNDRWxubURQbHZYdkF2T1ZjRTF3dXNVVkdEL0tldW1Wc3hWMVJTY240OWNzTlc4TkszZW5LdlJ3cmJnQm9Zek9wK2lROC9Lc2xHVksrTEhGK2JYSmZ2NDhYejIzN1BCSm5SYlRRMWJOV1lSLy8vVHI2azMxVnZmN3orc2EyZ0oyYUdiUFU0QnpyN3FpTWlzYnhSSjBZdWdteTU0KzFudFJ2THZidWdIRUJKWnRCY0ZQQWdCMG5KNENnSUVFZmRieUpkNmM0R0NKdVU4SkowdHltL0kxZFgxdVdkaVdzL2RralpvTHRIWUFwQVZpL2F3c2hmUTF3RU5TK3F6UG14TUx5ckppWGdSUWpHR25vazVady9VTnJtS0FreEJobitZYjYvQ3RTQkZ6bWYyREtiOTZ1QWxvNDhXNWZvMHVUMmdSb2xVbElZTFdrbEhHcENvWmE5b0pnTWQ2QjB5c25iZ1B0MEJ3VjdadGFzQ3dubFRHL0ZDTWI4SDUrMklSUHFQSGxNMnBUc1hob3M3N1duOUtJWHU3M3hhTVVhYmtnNUM3bG1RTlk4VUljZVBNdVZLU2FVVWlhTDVsNjB3bkdIYy96RUpScFN3YlkzZVdvQUsrSFc1TGNaZXJycUhhbmtIODY0OC90dDVMN3lpdXQzS0VOTHdsM0YvOTl1NVRhMU1Jb3V0NzlxZTVIVWR0K0xYZHcrRWtnQUd6cHVCL0FFVFBGcUFCN0lOOXNTYk1OSnZIRVBSc1M0QllRTjBtNTZhOCtUZUdxUUdyN1E1RHNwZUxmVHN1Zlo5cnJic2tMYzZBTHpLeWRTZm1tY21tdU83ZjBzbmVVU211bzlOZ2RKbHdFby9ZSVVXZHNvYldrdXdCbHdmTXA4dUs0d0VvR1V1N0w1NCs2WlRvRk9iTFYvMzBNL3k1OWp5R25mM1d0dnNEVS9QOTVmT1NEWGN0OCt4YTFrc3JHZkZOalEwQjdnVEplMDZBTlF4eXdJWHM1cDVuNERRNG5PTG5aRWMvc2RmUFhzMGNhWkRZSS9aeitoRExFWE9WeFpYVkxsays4a1RlZVZSaWh0cjhDUFJqZW5QSVNXTlh1akE0bmN3eENwdXh4a2RWQUszSlY3TFhmT3pHdUJ5UWNaSyszcDMxK1Q2bklCY1R2RW5XUHNkRzZ6aWFjRGZSM0NzQlpRODZlNTd1cXQ5WjFlRHN1Q0J1ZFM4WTF0SjRLeFRNeWl1bDM5cFFCNVFBTmVISHhWRWVpbVZkWmdsdWpsekhidm44endhS09ld1dHSHp4NnZzWTAxbld0WnFZNGlidHZWOTl2VzRyeGFlekFFdVc0SEwxdkd6YkxtdDI4N1VIdGkvUTRwVVdIL1lpYzFWdFMxWk5jQjlURTB6bkl1NTV5QlQ5VSswNmVwcUV4bk1reEMwb2VGVUVLUlpnenhraGNDQ0NkREFyU0hBSXVzV1gyY0F1TUszcFc4MVM5czNsd2h3c0doZE8vQXJ0QlFnRXRpc2w3UDRlMkFkTWUyMDlNYjZwbDRvcTIxcUV2UXFNS3NyMHVXOUhINWtmN0JackcwUkllMUtINkxSc0lmMGdWREdCN2VhOFZVZjlIY0xxSGtNU1V4WVpVQUZ5MStJS1MyVW5ZZ05jQXUvWWlTQXM1andib2tjSmdVanRWUnkwbXNBUVJNeVg5Z1l4Y3kyc0RqUWJINlVHVERZNWIyYnBnUkY1R1JlbldBYzN6eUd3Ly96WG4vcU05NHRwY2J2TUE2T0lWWmlyd0xXL3lhb0o1b28zR3RQVW54Vzc4VXdhQ0lwdjJnbllZcS9ldlAzUVp4blNKV0Ira3B0Mm1KdkNaVTBydXVMaTZ0dFkvWTNSN3Bia1NWQm43Q3FvSnk2WjVzaldjcEV1TXBxQTcxbUJjekVaUlpES0ZLWmVMMk1Oc0R5ekdqOEd2R1hyZVRBcjE0ekY5T3kzeVpSMW5ocW81dWFiQ3p0R09ZVnpqWjJNNXRROE5mYW5QZmVYdi85OW5vOEN5NlpLR29nSDBqdHloQjJKS1VXemNvMDczekxkdUMvOWJ3eG5NWGFKR0EzNkV0Rkp3bHhmZjBrK3NON0FPOW5rVm5lYk9TamxXZTdadnRyRzVzajNZb0FGejVQWG5nVUQxalo4bUZWNnBxVG90dXR6bmRYZ2tTdjdVZWtBTUJ1V244NjV0N2pZMGpzcjB4Mk83T1MyT2gveElEQ1ZjU2JQeUpDMWJOVE5WNGFqdWJ5TmtmSjY0amFETzNPNlVTeUl4eU1aY0ZDRmdFeHNnbHh3djlLUVpQWk9ES3M0WHVVUUMxTlFwa0NvdzRYeDhmbmtWOWVmUW5hTEZtQjBJUWd0N2IwcU5XbnYzbjVNN0tpTnl1SW82NkVwd0xoUG1Gazd4LytzNThwZ09QdlZCZTBWUUQwOGZybDY5eG1ObGxwUGVZNWVoNlJvdUk2TWRkdzhYRi85K0d4N2RkSzk5emZ2WW1hMUVnbkFDQTAyQWwzRXFlYjNCR1d0NFB0a254STJHNTJoTzRWZk5nb0hFSUVFcFJEUUZBK1lWcjM5blZLTHkweEwxeWJKUkprRkNzWXFMNHFHU25SUHdPVS9nZ0N3ZWkvaHhtQll1TjFZbS9Fb1Nwd0VRTmxNWUQwZlRhaHRJcjVPWVFrMHk5bHRlZzVHb2d4aDEreWl2WkJzOXM5WTVJUnRkaDRrdk81SEVEYkdVcnBud05TUWdQL21aa1dkemNGRjdJYk9HdWZNUmV0Sm9aSzJlVTVDTGtVT2dMRkx6K2Z2QkhJM3BUODdiYjQyVDhlbGNUOVVYMEpnQUsvZmx6S0d3YkJSUGtMTDViVXBpdkFETFVDdGZreDg2bzlxbGh6OHVvYXBCTXBpR280YkgvQnU3c1F3dExzeEQ1TVpNM245ekdKeit5aVIrWjZzV2t6YzBXMmZZMHlLR3dYc0FjclRRTzFFQmltRlYxbXZENVk2UGZNREhMbG5ZcHRQNm9tbU8wSlhDeGlzc3psVmh3Y29NbEM1b05vT3YzeitaUFd4MkpTZEN6WUtxMmFmN3hqRFdyVk1EbElGMUExdDJCUFhucEZyQ1lkUmVSMGJkTGpKWXpJRWZPY3cwTzRCcUh5UE85NEh1S2pjTng2R0dKYzRHTmNhWUlqVENrL3ZOWGJqdkMxaE5TVTVyWU9RaHhnUmRreityTzhBUWpvbTV1VHZub25iaFdWcDRzZXpzUDYrQ1luWWxWSVk2MGJleHpPZzE3M1Z0cU9OWW1JVGErMTM3SGxBYlF6TllyQzRlUEdlNWcxSUc3TTM5dGJXU0ltSFhTL2JxdXZEMnRzYjJjUEcyZis2ODh6akhDK1dsNlg3eG1WeGdyTVlvNmFaK0Q5OWxFZ0RnbUtMVFhUZjZZVll0Y1FSWFY1WWJRTnVrbnZ1VmxFbUNXQUJoZ0p0V2Q4REJaK2wzMzFCMzY2QUVROUFFWG8rcmhZU2p3a01xN0pUZGl1blBzVldreUxGSHMxTEFGS0xqa1l2bmhQZ1BRak1CV1NmZXYrTHR1ZzhlZnA5N1RWS2c3ZGRvckxBMWZOUVdNVTdxcytTcnFjUUpvZUNUell3SVY5WWliaVR5Y2pxcFJ3bUVVMDlud2ZFZnFCNzFtbkdMTDZFWGdyQVd5NmcwZGhiM1BRb0lZZzV1bTdqVFBSUzZnUzFaOU9LRnJqNHZpdStNTFIrRkZUQU8yV2N6N1pRV1VubENQWnNpWHQ1MzIwWGRvYmlsSHkwZldKdDQzQ0VReHhGaXR1SHNUWmJib2JoeEc2bW0rTjlEQ0FEWU9VZnI2c2hhajczOTQ1bkg1cnM1c3ZPclNNMHA0R1Y1MCswSWlFeHFNYkFRazgxZm5PM1hrWVUrTEs4bUlHbjVvb2FtNkE3UVFhOGxFVU5tZGU1ckt3K0lDQ3I1b3RMTjhId0FycDMzVitIQ084bGpVREs5cGlUSjg5WHp3dSsvL3p6cjFuWDNNaHh6WUZUREh4cXY5VGlaRFdOc0xta3JEY1NGMTBEUzN0SUxtYlBXT08wVDgrMzlaUFVFQ1FYZytTaWF1Znl2Sjd3V3owZmdONzNiTDNwSW5mQmdTVFh6U0dsWlNoZnZud2FXeEd3TFRiWE9zd20vZFpPVlRxV0M3Q09qNzV2am5RckxTR1FrajRMdkpRbTZPZk9jeUFYalNLUXppM3FQa0FDMjlCei9qcTVva2hOZEdPbnhKMGpHTGhTVVd6ZGZqcjdHTG1LV3RLWXA0Zktjcll5ZE9kZDR5clhLUndkd0FjYVRWYVhFa3RhMk82VnNvV3VyWVRrTHRkOGV1anZjZG5KV1hxWVRwRDlNVFN0cHpBTW96MmRTM29tT3N6QUl4dVNaNU40U1UrOFI0bUk5Y1BxN0EyVUJmVTdscjRVN3JZMnllZnNJMjFlNlJDRDdONGpHNjBwUTJWTVpNejVvVDV2UFc4YkczbTJ6elVvQ3d3alBOekR4aUdidUpZWHR0VTY3bGNFZnQxNE10SGhpYmhxZ04rek0zU0tGaFkydUJBS3NkeW1KK0lTT0UzV0FMM240S3NFQzNTUzJTWTU0RGlzeHVWWktkWVdSb2J3UGdHNVNnaWxpV1hrbXYvQ0xSVkxKb3hURHhPOW5zSksxSFdlSVVhVkd4alBvMG94clhvZ3ZYd3hnN29xay9TWDE2K1RTT240N2grQVBYeU9TaFk4VGVaTGJhb1BTZUJEL3JSOXFHdFAxSUwzYzVPcHFETmRHNEczQjhtZU8wSFJ4MXdIOVZUZ1IzMFh5d0JrdWJFQTk3RkY0djV5VGh3dXFwK1YrSlBOdnY2alZKaUloVFBKQkpRVnFYNWpVYUwremhvUVhnQXdqTTM5K2wxZjdIRWR1d3BoMlUxeGR0cnlndUdNeFVweHZoWU1QbXZlblFuNE5kYmxNSXZJd1NpbUplY3VpV3ZwM0hsd2t2SWNsSGF2SkdTMzJwcUdQeTdOL1dOQTNuakhmVWdCeEtZSVBjRmlPWUVBOWlNbWdqbUx2Nml1RnIrWm84d3lJdmFoYlg3QlhJQ3YyRmJDRHF3cTZsTW91bE1aUlNHYTVoRTR4REs2cnZtWXpnTmxiYkFpOHdTOGdOUmhtUkp6SXV0M3FGZzNuVEIzdTRTeDExbDNzWTJXWjRUeENtdEpFR1dxS002eVRzVzQ5TEdLYlloZEdGc3FzUHBZOFNmd2RDRHNkb0dUelpUaU1IWXJNMzA2cnJaQzBTVitRZzRkZEhGYy9NbzJMNDBuYnhvN0JSNEFiKzMwZUFjV3F0bW56cTBFQmJkWGRoczdjNjhHNStHVEoyd1YzS3VwSzk1V29hbGFJNzJ4dU83bUZDUEU3RFh5dy9Zd1VYVm4yQlgyYWYwL1Z2QzZYeXhPd2ZWVkx2VkZlMTd0U2R4TFJ2d2RlK2ZaY0hQMVlCY3ZzdmRSOGZIMkgrSzV6VmRqWkhERnUvVE11aTJETjE1SG43Zm1aSkZPRzc4OXM0QmIyTVFKNWxnamwzejlDTUJ6d1hMemtvdUpDOCs2a3ZrK1YxeVFySm9YWTFmYjVubTRlV1RBdW5zZlFMSCtzOWMxR1Jod3ovRE5WNGJzUHNON1Y5QmRPWTNNTDhQZ3hKM2IzUFEwdUt3ckFFb2ZlKytFT2hwblVEcDZIL3JPUGRXZ3VRK21UaTgybmZUYnFnZFFvdmdKWkFOemt1NldhTnBEOVJRSnhJdm56eW83K0JCZ2RWcHZFL1RwUS84R1dQZFlCZGN1MTNDdmpKL3RFRkxNNTQ4VkZQWWdyS0xZMUZwdFlvRGl1Q0pObXBiRTU3MysxNzlXbTNVWU13aXRIMXJrMHpJN2p2TjZhS0xXODFtZFZIdGRVZXBtdFVZeURUYnNUdWVEeGd0YzFiVTB6MDFxeXVEZkJQeSt3SjJKd3k2MjFXbVkrR0UwdW80R3h2Mk9PUW42NGh4WXhsaDJrYTllOS9NRVR4TVc2VlFCVzYrN0pndTc3SWdudUpoYnFkYitaZW1Ib2krMm9udUw4ekVFL1gvajhubVRMbkQ2VU4zYUdBaEtHMHRnamVhYUFRV0docEVvbXRzTXJQL3BYMzVZbld5bmlPY1ZFTlpWa2lCaWJWL0t4S3BVVnUyZUtyVW1GQ1JYcjN2NHoyUVFKQ0RrQzgxWHpNb2RrMUE0anBhejJoZ1psbng1enZwRnkxTUUxaGhJVEJhdE9SRWtuOUtKbEFHMTl5VW9qOFVZSjhYd2ZnZFdIRlM1TExHQUdYRnZ1WHdOSmIxdnJsTjY4OEJDdDRqRnJVcHpaOGdjdldiUG1QZ1Jkb25GVTRqSGpJaU1GZ1B5alpIKytNT3IxY3N5ejV1VmVod2FZeklGTEQwWFZrdWhHQjY5dFhRNmNLOXJDbW1PV2srQWRsSThkdUpRZ2JkTnRXQkk1aExMdEZia1E4bUNlYkdtd2dYWWdxTGRpd3owbDg4MTNFdlpHMm95bEFKMVAvV0s2cFcyZXNheldDLzJjc25pSnI5UDlzcCs1NG83cjlLejdiVnArekhqZjFLZks2dmo0Sk1wVms1Um5VcnVldHNCYTJMWi9mdDc0eVlYUU9RMHB2T1l6K1NVOXV0cXNFNjYxbVp4NUFrMWtDVjYwMmQ0UFo1bjRteXRqMXFwMlFEZG9KZDZ1K0pNYWlqcFdzKzNKRXM0K2EwVGZRRTZYY2M2YytWOWtXVXgwS25VNzNNK3U1MmhPYWlBRjJDdGwyVHg3MlRWZXc3SkJrVGd0SVRBMWJxOW83eW1qR3pFUkcyaStrNEdRWnhzYXRXNDg0M1BsaHdaVFc0ejQySjlKTUJZRHVDNmVmRFVRWktsd0Z0d2d2K2toY0pxMXRhS2pSUXdadzM0a1JmRm1qWkR5NnV2V2RJVTlLZ2FHNVhuYzFoQUM3R2Z0WVB3RkZnZHlWU29OdkFiN1hMWDJxZjJyRzRDQ2RCdGkvMzV2U090cmhPK0g3cFg5TGp0Rld2OVhueC9sT3d4UG1oLzJQMWtFMnhHQlhZQy9RRldRT1ozakVsOUY3LzRPcGYxc0NQZWJ5NXRqOG5TRWRTS1c1dVNzY0IzMGRWcjNTSUFYY0pJVVlHU2JVR2VnY1BML1JTL0VOeW1KQUtVdmpBRTF4a3dJZEg5UW9ndEdNQWFjT3psUHRKN0dsZEtUMkdWTENpMGxIVnFHa1pwcndTWGkwT0ljYkNNRzV2SHE2ZDFxTkRtQXpQUnFkV200dlBQeFRxT2MzMVN6ck1QLzVtUTNKU3dlRjEzaG90MkZVU1pLOEpiajZaa2tQcGNZK2xaZ1B6TVN4STdBZDdHb25SaXJiR2VLNnVJR1J5VWxUdUxja3NxSEJTNzRVcU1POUI3MVo0VnF1eTFtQk5CQ296MkVyS2xXMmtXTVZuNHRxMEh5OE9HTHRlV2ZZRUE3VXVWMW83VDBuMEJTeFRneGtxTWFmNXJYTTdxczEyb3FWdHRuS1dVeFRzb3djUTBPc05Sd1AvOFBFRFBPR3pHREpSUlhOZXA0ZXppZFBYNjFjdlZqNTNLdmQ1Y2JQZDNkVlBUc3J1NVZnOG5PNDNCaWQ5b0hhUHNob3VYQXpmTVdvZFJydmZXRXgwY3FtMXFWSmpuWHM4K2g0VDJnRndTUVhQWnJhMTBnQ0hoYms1cFN1MVRiakkybjB2ZDIvdDMwL3pmdEdicmdSazNXcnZvdThJQkFINDI3ZmU1VkNyZ3dIU09BanVuR0oydGZuak5rQWRDR1J3WmNHVUlqSVI2UHdGdHo4Smo2ZU85SHJDM3IvRmhMUU1UdStkMllXK3lxN3liaDlaTC9kbU54V25XYmF0TEhKS0wzdHQxdXRpdzlBSFZCcVBFb0lFbU14SXdzUnJqbnZjSEZLMjN0ZjhHNEZQVzB0b0llekFLVGpieUdTQkV4ekV1QUVjWEdEY2xLc053MHg4MVV3LzZ2UWVXOUVvcjViMWtaS3RuZG8zSDR1SVhZY2JFUjcxR1ZtTmE0VlRQVUJKbnNLalhNMHA2bWRGbk94K01ZL1AwdkVab1BTNGZHM3ZxS2xtSjl1REZpbzdhdWY3cTlROUQxeFRQN1RTeEcxSGhPYlFpQnFPc2djL09Jb2tGblVmakg3Tis1RlF3bjh2amxKV3RXdS9hM0lpcUMrRHZGSC81Y3ByZ3RsaXlrMWhkZjA3WVdxVXM5NGN2SDN2NHFHUzBFRkFvZUFOWXdjbWdmcVBJa2pmSkxSNlU5akZiSE94WmUxS2wvVjFqRW9OS2Jkb1RsWVh1K2lxR0dWdEN0RTJ3YlYyb2h1VTJNR2FSbHFCcWYrd2VDeU9LcXByQW5tdGhXTndaN2w3cTZKNHRFQVpqMFFIRXhCRlNnTVVseTFvbkc5cnBYQU8yNWxUQnFPdk40aWJFVDA5ZTlQbGNLT0JhNjl2ekxQSmxQbitrcHNPQzlpcUlGTnkwKzc3WVJjemhZRS9zSVhjcllabURJd0s1aDRSY2RnbGdjUStOZnRvOTl6TkIwbGViZTRpQmJIVlBqR1dqNXhYVElwRDZjNDNWN0RWYlVUWmlETW5YZkVZSmdESUVHOGQxVjFqWVVaeWdhMmZYdWw3Qjd0WWRJS3ZEK2h6ekFGeDduWFlFSE13SjVpVisxZlQyN1BWTlA4SjZ0dG8yODZGL2MydXFWNUtLRnl3R2dKZ01GNFExRnhzREh1ZXhldGY1dDMvOTI4VHV6cjkrN05xTnM4ODhKcThVVEZrRks2eSs3REdsMW1GaHNwck5oM0YrQ2JpeDdLMmVFVU9ucEU1YzVpTFpwaVB1WmY0ZDNMbFJ1cjMvQ3lTcTZ4cEREcVN1NjhIVnpnS0FsRXdoQnhJcHZBRk1CbU5iVHkrbUhVOEpCV2RBK252T1dQZmtVcFdJOFR3QkVtWTZuZ3lpeWF2NVV6YkVYcnZzR0hJc2RkNmJMQXo0NXg1aVNEMXhWd3pjQXNyK1dmWVBKdCtlbXk1aFJ1SjkzSGR4STY0WVQwVHNDcGo0RVBjYmdISEJqR2xLUFZycm0yUUx1OUxRY2VTYlV2VzBRaDlUdzlmOXhQMWNoMEdadUdTeUFPakU4NEQydVBiSlhKTGNOUmJHOXQzcnVtZUVGUTF3Mmx6cndiOWZwNWI5YXVJK3ZmOHl6Nm4wSXE2U3JwaGQrcENBQlZ6Njc1SFBxU1ZNdDNieU9qWmZ4SlFhUzc4NENiallVZGJZeDZRNnQ2cEkzcW1UZ2tMT0QrM2gycENsQ3NqRWM2UldVZmVUNDRTL3lia293L0o5ZzVPQ3Q2d0szN1EyM2kzMWZuajhQTHBiRE9YaVN3K3JCQ0p3dk4xWWZlMjZqMVhwaWpPb0FYa0lkU2tSb1hMSUpJcnBzQUpVME9tOTkycVJScUVFQzJNK3JiREo4MFdoVExDRkp2UmlPcWk3T2lVVzgrdVh1aEI4MGhFQ1EwTkxvVHJsVExtN3pyVEpJVEtOay91QURydWswZ2pYWGxRRFpZZjQvUzNRbkcwbUxmSUVCeE1vNEVBWXB6anZUNS9idUZsTFdVSmxGVHZGTURBUHpPNDYxMENNNmJ3ZzVGZUhEWnoxN0FrL29EanFlSktMOC9jRFNGdVZNS1J2dGR5cGhValBKTDZFblNnYmNhMXhXL3pjZUZWRlMwQUlYbHA4bEZ1czQ2RzFVaE9telFtZzRTTDY3TDV1bisvclpMRGIzSWJtUU00enFuOHgxeFB6aUpxUGh2VFV2WlNDZDcwVWhRSHhIMEY5V21XNjA0RnVzcFJjRTBGdUFPWmFCSXdTV0NxZEpNUzcxajRzTTBxd3JRWG5qTHZ5dFBHWVEvRlNKeFFSMk85Ly9HNzFYWEZQWFRYRlk2WitqVkRIRnJ4MlhXYWFJY0NhdFE4U01CZWJ1aSt1T2twbUcweGY1clZsSy9DYjBtVW9kZ3BVUDJaWWxVRjhMZlR3VURwZEcrbmJXTkt3cGE2dit2MXJNVlY3OWVZc2d4N2k1ZXNYTVllTVlYTzcxMzNKeDdEcXhtcGRHZTdkc3NXNmNNeHhjNzFQWFpONGttZTc2Wm84aTQyVUVCdXo3Y1djWW9kd1FxeEdKbkprRHlEMnM2MURSMmZKeSt5enRDOVV2Q3lXMWN6cEZMR1cwbCtlQitRa3MvRk1MVjJnWk02QjZ0S3VTSHhTQ2NQQ3lKd09EYlJHWDNvdkQ0c01NNHFJZzZTWnNkSkh4Y003WmFadjZHUXl5ME1TczRNQjFoWURFczZZYW9LczN1Vk5NY2Z1K3lMWDNObUhqcFhyaVZjWFg5NnRQbDkrekZEWWpLNCtydnF0U2pjQTkxblh1TWdBM3pVMzI2MkRPQVdYRkpEQ0ZhZWViKzRPTlcwM2ZkYnVrMnJ5a0hhckp2bm8vMkgrS1FIOVVvQlM3NmNOdEswYS9QR3paVzBDRXNkYzllS0k4a0UzM2tsQVVkMFA3MzlmSFR6V3B6djZlUm1sUDM3eWFuVlhPdnp0SDcva3h6OFpvYUgyWjU4cVdHc0NCSUI5T2Q3cjBMNnU3bi85RlEwdHNKckZzZUhTSmxJZ3hjNXdGeGFybnlKbWNaWUFZQWlNY2lZQTNvaFNTa216MkFmRjZweWNyT3ZqYmRSK2V2Wmt3ZFppS1lpd1FMNHJvK1JBa012MzdmcEFVRXhHbTVnUmlLN0hpdkhKV1BnWlVZdERhWHlXd0prNEZjM09XelBXcWE0UEhKZjlaQ2w5ejNJUkExV3NPZlZJQWM2Y3FxSnFQTkMrVHhHNXhKamlWWHZiUHRaTzVhb1dPc2FMSFVWVUptYXphdnVEbHJycWNMQ2Fzd3A0M2M4aEd4UldiRWlRWC9vZVd3UlcyQ0Jyck9wZmxmZHVpcXdVNERvZ3VZb3g3UVMyanRqU3UweHZKNjZLK2VEeXF0NEhqRk90ZlNHK05aR1lubjBwaUhVd2JYMGJFclE2TGN5YVlyNkZBc0lYbTlDeE1TY2lkNm1tVFFEWG5zeEYwTzJKVksvRmNEcmFuYUk5clhMK3g1OSttUGpvZFIwNGJPeW1QTGV0c1IwSloyVUFNWDNWK1FMdHIxN1cyQy81ODU3enRqTk5mS1pyQXI3ajRrWmtSK2FPVWRXeVc2SHZhVVpBVUw0MzFTSWxoUzA3eCtPZzJMY1pPRnVqemdwdEtGckY1TGc2Z3RpOENNb3EwRTVXbHBnZDlvRXhjSW1XbyttNHlaNVY4RndnM2M4WXZtMDlYYkRFVEpudFArTnY0anpZcDIxZTltUGF2ck5WbGZjdThHdWRUZ054SG82U0hJbVo5WXpabDBJd1dCYkd5blhqV3Fmckk2Tmt3cm9ESmV6L1MxMWJlU0xHU3piMkN1VXdOTDFsbmszMkh0anBsT0g5bUppbDR1bVFCV3lJam1uUnJaU0k0WjdpMTU3cjB2TjRiMjdDVGk3VFhURk1wemE5ZnZHcTl5MG5oUitldk13OUR2d3pqbVNKWGlta0pROTYxTk5DbTkzbmFNQ1lHV1k1NTJKS0pqWGZtNC9GQ01TcGJuSURiOXBjckl4QkR4OXBZNmZvMms1QlNGNDhlNzE2Ly90L05oUUJYdHNDdW5SM3VhNmZ0SWIxQjJXSVdEZzA3bXNWem9lMmFJVFE2MldhL1BlMmJvLzdCMC9LRnRoam1QdFJuY1pwRGVlYTExRWdTckZYSUZBVnM0VS9qMVlUL21raTE3MVlNNHhBbHNhOUVXVE1hRkxOSGpBVWh0SUFoQkw1bnYxOFRiUUdZaHRWTHFPaXNrcUVkbm9JOVRrbml3QTdlK2pFbitKVXM1aVVaUUdzaFdsTjVxanh6RTZBUUhCaFlJdnJ3cDNzRXIwbWJnTkl5NXlVTGNTb3hJaVc3cDRDNUs3WjJBTXp5cXZ6SkRBRWNDZk5uMU42NHE2ZUxIY25nWWs1VEUra1cxdHRCRDhEbU1hZ3hjaDFsZjVpTWR4b3NRZXhFaURLWFZuYzJNb0ljdVZ1RWdhSEJuZ1dGblFwNUdNMTdRQ0lkdWR1N0JYMG5nNFQ1cmgxVjBjM093ZkVlRXFrUEZRdjQ5bFlSRW1KYlZtakhtTEpUS2JvS1Q4WHpMcHg3UnhaYncrZFdpQjcwUUE3RndMelV2ME9oTlQ5Yko5ekkySkdDVDdteC9XanBNQ1JnbEdXNTgrZlQwR3B6ckNNNFhFaGhsbWxMUEZGbTV5bDFmblJPb1hZcGlQTHB2cGRJdVFHdXdNbXpTK200NXFmWXJKaUlkak9UZ0FnK0h2ZXVIUHVBaDk3WGxPZTdxVTBSbEJlaStGZ05ZQ3U4TGozVGlzbDdMWG5wYWdZa3prWGY1UjU5TE45dDBJRlNNQWNIcHNzWG93OHhVUzZ0bVFBQmFXc3ZzeWp2WHdNRFlCUmEwYnZkT2lJNUkxc1NXcjRIWnV5UzBQR2Q2dDFVTnBnaHdtbGZ5aVdTNDhXcGtiMXlVWGpEQmlzdjNvMU12a3RrTzUzZXp4dll6WkxMQTFtYzcwVytkWmxnejV4NTVjRWs3bU90eWZEN29HMTI5VFA0MkpvdUt4MkxtRFhDWGFnNi9QdXh3amNyOTUrdEFVdmlBdFA5cnZIZmU2aHluMWJiOExmMXFMeFUrcm1SYjg2SFVndWhUeDZDZWxvZ1ZhYkwydnVyK2Z6NmJRSzRmOEtpdVdGVnYvejBDYkw3U3pCMDJmN3ErZFZ6RjZlRnJTdGk2aEp0QWRJYzdIZFN0azFVWlBwRVNjU1BIOWFtNDc5YVBsKzdXTEVSZFo2My9zUGwzMS83am92aCs1dFZCaktvbi81Mmpsc0xUWTJ0NWQxbVEyc0ZmRTVmTUZBcjFKaWxkdU9weUpRS0xCZDlYbTZzNUFFWnJJVEpLWHZiNEF4Ky9FQ0RSWGhKdXhUNVJKZm92NDZQTzZLUmFTWVRWa0NFamluR0t5R2hiWDNFRnZnY2dLVDVtZ1dlK0lHbGk4WjB5N0RXREFIRkpyMHFlYWRQWWlXTkFVUkJNRmFWUEU2d0VMUElpNlVEYVJKK1FEV3BKdHRtN0FUdjh1Y3h5RFc3OCthK3phM3RoY3grOVBWZ050VmMzZmJIRDlmN2RYU2hyVy9MZmdzNjRncExnb1RPODdLaVptZzZpaTczbFJBZ2dDcXA5bE42ZEtWaVF2bEdHU3hzbHIxRmFNQW5BdUpocnV1dTVGckpONllaQzZzTXFIWEpQQzB3TGdBTXNBU285bUxMVjEyU0VJTE9JQW1SUTI0WHJ4NGxuR1FhU3V1R1RDVE5TRUhZNW9lVDlGOFgxTDIrbFdwWEhJSUF1V2lFdU55bXpmeGxwVGlRK1VBNjRVRG5qOHY1dFh2VGgyZUxVRXBtakZxZGZLMHpLQVNENjFTdEVIQkdrNFpzVndiUUhXVXF5bitNcWNxcCtSN2daWHJZM0pyR2RHTjZuUHVra051a0U0U24wb3VQVG1PTmNiR3ozb1BVQ05iMktBT0VKZ1ZJMDFtZkFNYzhUTk1Ec05xTnJ1K0ltS3NteXprUWdHTi9sNWVyL0VYUCt6djE4bmpZNStkbU91ZnNzd0FpWXZaMjdxZTdLanhFbXlmSkVyWGtObW0yQXlzUkFNUWNoU1pESnV2Y1k5YkgwYnV5YTBXMUxsMmdaMnRPbE5uMTNqVlRFNzlaWjl4a012RGZjK2RGQUJObnM5czlrNHZwcjJSZWU0TFFETzJYRlJyZGJKYjRxYjdPNkdiQ3p1TU15WWswUk1TelNHelFOdUpQNys4cVgxMXVud1JHSzJseTg1VTNHa2RIMk93NUk5Y1dsTWVpdm0wTHFyZDZjVjBpV2x1NW04OXpkeE1TY0QwMDhZeUd0Vk9zWUE1U1pqRlRWalgxbzhLd0w4T1NGclU0aVNiS1kxVG1sSFNxZmFHdEUzYXk3STVyS2tVKzhkYWxYeDgrNzY0V0FITkFZOTZYN1VsNS9IcTZ3ak1jV25aUDZLTWxPNm5hbitrbDkvOS9sc0RWZ3R5UEl1MkZPUnhSUUVLbGlLKzBPUzE4T3U1TldOQm1raHRaaFg0WEg2TUFZcUxOR25ZbUl5T0dxK3JndktmNndjdlUwUlk5ZFdDSzNmY0NkYXE2OHRHWUNmWW1ZNmlEN1cvUUo4SkFCYjBUWkd1VzN4MCtadWJOL0daaEl0QSt5WTJ5ZFVBcVpTdDdGTXcyTHdHZUlRcUFWYTQrYXlPQXFsbmNaYmNzeFpzdmN6czNXMmJ4Ky9zcVN4Rm54c3VmdmMxdDNFNlNtWTB0bEt5czRvazd4c2JQc215VDQrWThHVlZabXRjNHNCU2JWQkRtWEVuQWlOWTJLR3hzZ1FzTVRDTjU3ZFdXZW1FZVdFTFBvY2xzcGNVbEJFVFhNKzZKY0JjUWErSjB6M3VZRmJGZVhJdEtLWE9yd0RpSk9QMTVHa2JZMVBTSGkyd3NKY05jOWE1UVlDYjAxajlVV3N1SUF6d3BNT2Rkc3ppVHIrbjVyeGhwWFJpYlp0dFVZbVJaVXpkNXlJRjRnWTMrSlNub0hPdUhzWTBpWS9XRHl1WWplWXBBQWFLaVdBWW40ci9LRHV3cHB2SjZIM3pRYmNJUWx5a2Z3b2JVUHpBUkNHcW5sSjJiMGdzR2N1eE9GMWdNZXZkeC9UT0VvTUR4bDJrc1dBaXpXUEtiNDNkazh4TWlDRVplL3JrNmJnNFh6NEdaczJmY2dnTVNad1FzL0tGNlp6RUJvR3YvdlNZc3lVelIrYk10aS8xWC9ZdUF2OEptU1QvUUVUaWhSdHJlNHRrRGlhM0ZGVEw1aklZeFRCYmIvV0ZJNGE5Vnh4VUNSRWdFMVpndUNaYzBKd2dEZU1LOWpmcnZ5WjdHWkNxSFJ2OXcxeWE3UlIrNXVUNk9rS1IwWnhUcVgwK3QxQXQzT1gxYVMxbmtvWEl3RGdLbVBmbk51WVZMckkrMmRQdUkyNjFqQTJ3N29aQmpnN2tHbThWTzlOQmw3SDYvd0dMczIvdmpGelB4Z0FBQUFCSlJVNUVya0pnZ2c9PVwiIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBU3dBQUFFc0NBWUFBQUI1Zlk1MUFBQUFBWE5TUjBJQXJzNGM2UUFBUUFCSlJFRlVlQUhNdlllMkhFbU9ZT21oSTU2a1NGR1ZYYUtyNjB6M25QN1MvWWlaMzlvKzI2TnFzMFNTU2ZsVWFMSDNBbzRYemtneXlhcVpyUmtqNDdtN0NSZ01Cc0JnTUhQejNuLytULy9YWWIxZU5yMWVyeGtNQnMxdXQydkc0ekhYZmRNMGg2YmY3MGVhNmY2MjIyMXoyUGZKTzJ6Nmc0WjhtNmJYYjVySlpOaHNWZy9OZ0grOS9xeHBldU5tczk4MWgvNk9QRnZLam9HWFFaakQ0YkJaTEJaeHJYcUZmemhrbmJ2ZHFobU5CODEyc3llTyt2b2pDdmNUdjlFNDh1MzIrNEJkT0ZKek01MU1tczFHbk1DWGZ3WmhaamlBUnovYXRLZnNlcnRwK3VCaGVmTll2eUd5SDBhMHNkK1lyOUxNSjMzTU5oejFtdlZtU1ZuekU5ZmZKeHpJTmh4T2dESm85dEF3WVNaY1lRdkRVRGdKM3lBTklIZmdMZjRUMm1HZXJDL0xCMzNJTkJ5T3dHdEhYeVF1STlyUU8yeUJJakxraFY1Nys0ajR3VUQ0UFhCcHlIOW9ScFFWdDM1ZkdwRjJBRTh1cHZkN1VCQTBlcjNFaVl5QmIrRWNmZC9TcVdobEhuRzNIYVo3YjVwWHkxWDd1dm1wamZqc285RklmSWlodkwvRDN2TFpSMVZ2WkRqNVUvVklIMFBWV1hRMVRqNnRZTHJ3ZXZ5MjhpVms4dG5mWnJPRjUwZlFrRExRMURqaEYrekFpM2JMc3hVU2x2eHEvY2xmSDdRUithQ3lEOXBmOVpsUDJNVlhCWE00UFBKSkYxYVBUdG50bEl0c1ErWHZ0bFY4L1JXdTFsWEJmUDZrZGRFNThHOXBVdmxPcjVXblcwKzFRVnprd2NKSnVOMGdyYnE0SkQ3U0d3WWptQ1kreG0vdFErV1ZlNSs3c0txK29zZFFKaE80U0hYdlJVYkdJVHBDcFJISjg1R3dKcHAzczVFb0tEUVFzVnRsaU8yV1J2UVB6UjRZZmE1V2JzVmVsOHRsMUZtZDUxVWNBakd1MWVCNHByNGtXc0t3K214VVBrZWpLTitqSXBXZ2hEaHc3ejlEd29pN1lKUTlhWW5Mc1ZNalkvMmgyT0ZnQnlRQmpRNGxTQjBCbTdUOUhyckJsQU9ZVElXNjJheWl6VUdiVUJpMkdXVUlEWGZrclhEYStSOElIdTB5ZlN4am9lUzk3MU5uQ1FUVWl4WU4rQnZ4a1lhQ3BCbDdsSnlLeWo1UVlZSmhNMER4OU1RRmZoaUN4MkNnNGtLWlJEL0FPSHRoRXc4Y0djOTJtTGtYU2k0eFBxaEVqQS9jVk1ESlVQWlAwYlVZVE5vWTUzTzFzOUpzWndXYUJYTW1IeWk0U2RQc0t3QUVET0hZUjhJcEdGV2ZjZDM3b0JONVQ0UGxLeFErOVZ4WFlhZnd3YmUwVGVISnVHUGZpM3NwbUtyYitrOWhHbGQ0bGZoMjJ5MWN5MVNmZC9QYngvSmw5WFczWE9GNmVrMGV0ZzhwQlZ4bHRPcXZ2UFhjcFdHMXI5SXFiL2NxUFBPVmJ1aW0vYTMzMWxkdDdQYk5Yd01QM1pLQ1dZVmtudlY2M1JKV0JvU2w2Y2hEZEpCY200d1hEWUsrZG1RS3JVTEU2QWlUMEU3eXF4UUFINlA0a2ZuTVg0U3FqcXRPckRTdkNxRjRqRWRUaURZS1Mwc2N0ZjRNcTlVcU90NkdSOGNScHlWWGlrN1lSWFJFbE5Uc1dEQ0o5dXhVcGkyRG1hOSswVjVIeDBNcThjQ2xIVm5OVXlFN1U0c0xLdzNobTB4bTNBdFQ1V1ZIaXljV29reWt2QWY5cE1sUmlJUjFyRmRtRng3S2pWRjdEUDViNEIxUUlNRzhWSDNRaW1vdFgxc3pGbi9xaGpoTlR6dzBqMnpmZnMwNGdTSkNlV25sallpM0R3ZURVYlBCZ2hqU0wzdnEyR2taV3NKK0luMkx3UFRvdHg3eHRxL2EyeDlKaThnWnlrWGwvYkZnMjhSVm12bXo3WUU3bVMxVGZVZGwxQW11Z0RTZi9XeVFSZ1BpVFJPVzVjVkJHRVUvODVrbWZvWktpd2YrRk00Q3R5OHQ1ODk2S2dRczBzenIvV09mY0QrMEx1QWJYOEg3NGl2bFExaldQeGltTEVTZmtibGdIWEZJWElWamZ0T0xyc0lUOTJxSCtEb0lkcXA5ekErbUg4UUx6enFxSHVFV2JOdmlyOXBXZWEycjRycmxURGRZdm9McDVxOHl4bGZaeW5ONjdaWTNyZHJaelhlczRranpnRXNtOVl2aGMvVU1yYWc2MDRZV000YVNRS2hsSUxnZElxVHBMdHlEU2dnaU92cGFKdUxDNmtDSUJrelhtakhDSmhGaExJVE1xWlZDTFd6elN3aURWcGIxKzF3TkZ1RWtPRUxMMU0rR08zMndmZ1d5bUxoR2MvUFhUemlXdFQzQ1UwQ3NjNyt6dmlLSWpJT0FObHVFTHhXcU1LM0hjdUk1blk3Sm5aMHViTk9FYXhEbm9Zd0tPUE1QUitLdUlxTUVjTW1hYlVHeDIzN05lUzJib25OMVpMVlRtS1psKzdNdHNHNVlRV0hkUU0wUjVjMlBoa0ZJaXQ1T0YxVmdBRURCREdtUGFBbGZTM05JUCt4UlhGQWt5emNNUXVSbkNNSWFXemY3L2hyQnRGMElEdmp2N1FmYVpGdUVLN1djYWdaTnBISGdlTFEweFR0dzRpcmR6ZWV6dExRdHh2bGNmYXRTeW40OUtvazlQSlB0RmxyQ2k2azg1UzFyL3VydnFzczRmN2F6eWxpSHorWTFyVUxCRnJkdU1BOHRnaStnVzBkeCtLeGlyM0xDcTJBWjgzWmhPUmc0V010bjF1L1BmUDVpQ2dmZkM2dmdlRythVi9ONnRWMWU2OTYyR0xweHlwcThaQ2c2V0w3S1dxYm8zTTFUTUx3YUxLUGMyQTVEd1NxY0lyTDlZMXJoV0huTjk2bFFkVlM2ZERLdVd5YnhUZnBVL21vRG1hT296OTB5QmMrclpZYlJjQmg4eDBoZWZwUEhRb3lxQ2h4WnNXaldrUzZ3bkxjcm1TUlJnWk4vcll1RENnNWhjenExMjBNVU9zeVJXV3RyeFpUSlVNVFNiMUNNWnJ4bEhGbXRPNWxmWlZETW1jUzJVU0pkalQxMm1oQWN6Yks4TUF4YVlkbDRDQjBXZ2lpak9OY1NFNlpIQVlSRkFjenFjR0hMaU4wcGJER2NNSVVYTUdtVGROQ1BKSStGeFlCeW9DTHV0VWh5U3R4dmxaVTRWWHRyMmpFR1ZyVWhoS0ZsUWlpQTBaUWRMcndOUGtZeEg5QlBLbTNIa0ozQ1NYNGFRQmFWOGh6bExHNzYza2FoYkp5ZTI0N0RWZ3VHZ1VMbFJCcjJRYk5CWWFHOWdDZnVNQmJUdzMwb3NFRXpSTmxLd1ZETTlPaEdaVU05SXl4UFNBUE9oUnVaZmlaSVMybG51MjFmdFRXbTI5RFBJQzJONzRiS1p4bkxHZ3FPTUt0L3E0eURrdkhDcXZ3Mm9JU204cDFlQ3ordjBsR3JNMllKYlIyUHNDZ29UdUlRZmQ4K1cwNTNuOHJKdk9MbHp6enFGK01zNTY4TDZ4U1BlamFQTUpQLzB5MlM5U2xvUHcyVjN6S25OS25jaFZQaFVqU3BkbFMrN2pYb1FVU1Y3YVo5eWIzbGd3YlNoOS8veW9CV2NkUkdRek5HcTV4azN0VktLMEtDRGNKY24wNm5iVWN4Z3NJY0Izc3BmbXBoQkJaaDZzYzBpZzZqcDFBRDBXR2tSa2V0dDFwUzJGMDROaFh3VW5nNjd2Y0lTbzVxZmVyYVJINkZ5b1pxSXFjaUF6Y0VUbE5kUmp4MmpoMkYzR0dKQ1dQWFRoTzFhSnp5Z1UxYWlGRE1rWHR2Wm9KT1YvMVB3dEVhU1Vzb1pUL1NzVEEwSXMwanZhbUZzdG1XVVV6MW1LNHlEUnRxT2JhanFQNGpjVk14U2tNTFVvUThDbTFOc1JFKzZoekozQXFxVXpud3RxMTI2NFRSVDBYZVozcW5aa2hzYVVWWVBDZ3UwdmJDQjY4UTBpZ0YvaWlzWnZzQUJKUUsrRzJoWDhNQUV6VHNZVjFJZTZiV2ZhZTV1MzR6Wm9vOUdHMmFIYjZxZm85N2xacjBvN3lvUTVMd0FmYkFiMFNmRFZsUTJkRlBBNnkyTlRpVW8xbjZpZ0lpS3RrZVE5Q1ZOaFhUbWxDQ292QktVMmtUMWhRQTdPT2dBUW55aCtYOFZUK3J1RXozYXB3d3VrRkZVbm1xbmt4UFpWaXdqWlBPUVZkNWdmOVJUOEdEdG1YaG5kWmhQbWNLeDVEOFNIVGdiMzd6R01SQjNnNEwyWGdiVEdYWnk0bUQrU0pXRW5MamZkeVFMMmtrWGVSTnJ5YWFITG55Z2I5RkgvTjdYL1ZubWJaUW05czA4ZEo2RmpkQlpmbUNhZjY4ejJxVVB5MVRzRDZwdHdYNXlZdjVpNitQbVlSZGRXWGRYYmltZklqeHNXVDNqaWxoQ3F3K0czL1pVV21LcHo4QnRtUmFOMmJGVGlIWktLZ1RHZ040TzJJZkk2VUlrazdzQ01JSUU2ZEtzeVAvQ0NZZlNIaUVZc3ZLbnpqM05CRVl6VFpZRWFQQkpWRTR5UkZRV0J4cGtWQXdFZ3JUL2cvTERZYldTa01MWlo1dzZ6dnF5UUpPY2x4UmMwUVREOHJTd2sxMGpKWUNUSXR5VlNudkVEYkpNZ29CSkk0SzdCUDBCMGlKczNVNnJSRnZSc2NkaWhaY1ZUb0hWN1hJTEk0SzlJRFZMRmZjVkl6Wk9WTEVFZG9tT3RWZ0ZSSExaSStDQ01hekRMKytRbUZWVkptMFU0SFRadUFZcEJVTHEvaVpLTGVqL0haQlhhdG12WnFUU2cwb3hnUFdLeklLL3NKQVdiRmFPWUVXV2tEYnd5TGc3QkZ1bWRUcCszQk12OUlXR2dNRS90R203UkI0NkxYQjZJejJud0VJbjlzR2hVSGpEdUErMVJvRHovRUJCNzd0WjlyVDYwMmIrV0hkTE9pN1BmMnpjakhCaGtTYnBIMWFxcmE3Um4rUktVVlRRbFdDQlNyUVVrRUdFZTVOdDF6Z3pYMEpyb0ptS0dWa1BRWERPS2M1bHJOOENXOEtqY2lCSXZsTjh4YzRDZ3ZlQzFlRnVBc1Ayc2duQm1FV1BKOUpCajNTdURFdExGSm9BdmJBTkVmV0laeXl3dm85ZVEzWS9JV2NjUlZLOGtwYWpRY3NNd1FRamtMZWdIdUE5OFRmdWczVm51VG9iSVB0dGg1L2hzQzlqVFAvYWJweGhwUnI4L3VVUEpjd3BJdnRUcHFhLzlnbTh4cU85QlorMVNHY2p3Vjl1SWtqbU11REFUTmgrR3dRbjRJVGVlUk44Q2c4amZOWHoxVVBiSmRNb2pOOXVWdzNzOWswaEVIQzkyRDZZcmFzSUoyU0NtWnEzeVB5bXhqbDhCbHh0YUpnUENSS0pMVFV0RkFDTWVvcjM1Y0tRMFl4bUdZamcxbklQeGxQbXZuaUhqZzVHa1FtaU8wcXd3RkJNVjdHY2ZxV280YU1ucDFzRjRXVjA5WWx3ZGJybkpJS3h6Wm5KN1ZUaUdEVVpGYngwTGNWREF4UnBZTWx0T0lxNkpqZGtCYXJqUzMrd1JqSlE1RS9jV0pVaTN6UVFBV0FvampBbUJtT1RPQ3psdDZPcVorMDZaRm5oZExjb1dUNktJajE4cTVaek8vQ1Y2SnkyMjJscTM0TFJRYnJqZW0ydE50RGsvSVZXYjl0MFdFK3BVODNLOXFrTmRneVgzK3l3SXJVWW1acTJMZGVGelljVkdCNjZOK01wNUhYK0NFK3ZRR2NzdXMvTkRQSW9QSmZVZFk2TndvZGJaTkdGYXpYZmpUZGUya28vd1JQOEZ4TWFKcHhQdWN2Qnd6TEJUMExJRmZoR2NwM0dRLzhFWWJCL0taNU5hOVgyeXI4cmdMdDFtMjZ6ejFvaXM2SWUvTkgyUmIzZ0syeW9ubkpNNmwwb3RLZitST3IxS0VJRWtmYjlMTUJmS2tnYUdhK29sMldzWTNLUjdZejQvS3YrQmNOeGR2d1lkbk05N20vMHJGTG00TFZMV2ZjTWMrbjI1T3lsMzNmN2N2VGUyRUxSYXpWRDRicXozajR5SitoakwwYk1CVkQ4Qnh4WEo3WGQ2U2dHZXo4WWdRcmxGbjNUaUhvUklFYjU2OGFyTFBlZTYyeHVvNGQ0VnQ0eGhWVGFEM3BHTmE1TGxOTGtLR09jQlRpRnFFY2oxaDV3NnJKMVMrVmpBMENMMHdVbGFDK290VktTMjBGbmlpYUZpOHBFRVJUYTRPYlFxNlB5ZmJaSHVzM2lJdS8zTS9sYUltUUkvVG1kMHVHOENrV1FmUlZqazZWTFdNUTMwZG00Ym5iaGRhak0xWlpjREEyYjdRbFNyWi9uSUxUbGg1cDFyMWZMYmd5R0RCQ0xSZHpmRS9Mc0xEMlhOZnJCNVRPQW5vcGhCT3N2aW5XbGwydFl0T0pEbjZZWnV2TnZGVnNPN1o0WUNsdThXZUJ3TDZIMVFQZXVkZUZnWWQ2OE5ORHFuV3p3eHJ1czArdXgvUndBaHlNNldaeVFNRXpQU09ST3VsVDhnM0cwb1M2MlRiUlp5RmpTSmxGVFBGUm9qQ2N5allHdXBZZjVBdjdYVm9Velh3dStnZE5TRFBPdkE2T3BzazdYbjJ1WUhuekc3eWEzMUI4VmVXTWUrUkhsS240Q0tmeUY0eDY5bXJad3EvU3ZSYnNjQWRvSnJXdzQrWXpmd3JlWjdKMWtvV2Y3VE5Tdk9vblp4VytoVituNENNOXpHTzlsYmViNTNQM3RyVm9YUDN4c1RMV243UTU0bnFhTC9GTzJlcmlhM3pSOUpRK01WQ0R1L0dWNXhTdXovUWwvcEF0ek9ub0c5SXA0cEJPSVdPam9TWnNCWUU1U2kvRDZrZ2kydG1QRE9sMGhRWTVvaGxVZEtVZzlJSElpRjNtaVNsWk1MUWpjSTZnNmJlU0VVVmU3NWdhdzRhbUQwY1VWVnJpUEVKNU9BMjBUcWR0SUp6Q2J3bndkbHJtTWo2aUVIaklFQkt0Qk9JRFptNFpWQi9kQ0lWd2lKWEZIRzB0Snc3Wm9Ta2t0cVBiR1U2UHpkWHQ3RkRDeEVjSGtrYUJSK1c3ZFhycWZpY0V2WWZGdU1hQ3VyOTVoNVhEUWdHS1k0MGZrWWtiaWdLZm9adHpHU0MyME5VVlRtbXpRYUc2WXFqbHd4QVMrTm5wS25Mcm8wRGVSN2xGS0xFZ01XU21LNENKTXRXWEZhdS80RWg3UmlqWUFiVFZpbUlrb3c2bmtTb2phSTBtMHhuUFUvS0dHMnVqbmw2RG1zMDZ4WUk0YVdQYnBZWDc0bHpNTWE3TGlFVzd5dSt6dkdTZVltYmo1SitnSDNCOTlyN3lWUm43MDNpRDErSzVXb1NwdE1qUXlXTTl3akxkKytKUHJ3YlR2TmZpZGwrYytVNWhGUTdpN2IzdE5IaGZRZGpWcHVpWVkxSmxpYXRsQ2tiUkttWVU4SWd6aW9xclF1SWlqc0kyN1JRL1lYWGp4RTEzalFOM3dTclpyZktXOGI3d3RieHhodXBEMHgvNWpMNzN1ZktZcjJoYWNmVnNQa1BSdzNTTkJma28vTk9rVlo3SXlCL3pHRmR0cFFVQ2NkclROaGo5SktPR3p3ZENUZHFwVUFDSGVXeWc1clBLU0VBeXBwYUVncTVGWW9lWVJ5YTFFb1BPZEoyWmRuemI5b2ozVHlncUxDT0ZUK1p3ZDdMQ1B4NWRrZ2F4cU1OVkdBVlZCYWRGUUI4Umg1Q2pVTWZES1hVbExqM3kwVHlnSnFPN1lWTmlHYlM0U2tFVlUxV25SQVpRVGFKbDV5aklqOU5idFdTMHhiUjlyRDVXKzRyQUtzaDBSZ2UwRC81WWxDNUo0c3Q4M1BmQlM2b3Y1dmZONnY0RzYrcWhXZDY5cFdGWW1tNExZVXJvN3ZYcDJOR0RBWUNmSFd1N1lTZm9BNTFVZHZyK2lOL2lmOXJ3UE5LNXpyOGUrQy9YQzY0SUg5YVVscHo5WWovR3oxVmN5dGtpbVRpVW9zcU1tT1Z5MzV6aHZMZGZ4ZlBnR3dmZ00xalBlWVpab1hlUEFXSkhuOEJBbElCV3FsZW1sNjdNQ3I4MkJzc24vb29YUGlCTSsyQi8yRGYrek9lemZWTmx2QmJURmg4ZTZaNDg5akc0eGhXTWJyb3dxdS9yWG5oVnA3T0VqVnMvV2tHUkw0YTBWZnBWdm9KWHVQbDhDclBxcm11VnFXdkZSMXVpR1NrajBxRmdVVFdoZURnZWdyN0dXbDc4L1hWRDRWMTByWHJNazJsMVBTcmdraFB6V3ZjUnByS1hDcmNMcDF1Zjk5MDBRRHdHY1REdGxIWUYvMWhYcDlCajZaL2V3TFZ0WTJWYU9raVBzdHFUcDF3YVIwQU10YXJtdE1aMHpXVG42VnBjSW1PbmltaDNWTlBTa2xsajVVZExqVHgyeG1NZ2YwM1RMT3Nxb2cweFQweFZ0MGs4WWJxTWJ3VTJQa3gwQkVsRnBzS3pVODAvUVlqY2JHbDVPOENwWnVSSEVDV2NlT2NxcFpxZHFhR0txQTMydWMvdVRWTEJqbnRPdTNLMFBMYUppbXdIcWliYWhrQVhBNHQva2JKZ2VqWGE5MTFDTlZDSEk2YktXU2lMKzNseisvNTljLy91RmNiV3N0bGhaZlZSc3FQcGxTb0hlRmlTMEhETE5NK1ZRR25wU2wyZlFjWU5wVnJFNmMvVEVtVEt5N09yaExaNWhUOVM1M3pEVkZCRnNtajdTTG9JeDJuZ2VzK3JVUUdEUVVGTGdrV1hLYjVEcDllOTBhRTUwNDhsemNualhxMGhnNGtERTVqajV5S2VkZ0NnV2FGZ2R3d2VEdy8zL0I2YTYrdnI4SVhhOUk4SmpmRVZoRitLMUx6UzAvNnJlL0UxemhCOTJTb1IwK1VWNC83YVlMbUNLK3prVWZmbDVjQW5QT0dYMGhBLzBJZ3lwM1VWL3VZMW4xZkxmZ2xlNWhFWGNSQWZ0OERJeDRiQ1Q5N1RFSkJ2elMvOFUzcFVlV0Vaek9kUE9ucXQ0RzBwbjRxVEgyVmM0Vlo1NjY1NzA4VkJZME40bndxV1A0WmpuWVZENFZSNWhHK2M1YVRibDRaaC8rQTBBR0lnSEttRXZMZENKeUV5WndMZDZnQU9wQUMrRzJKNXdWd3dzWTNWcklORUljc3FBanRlWkJScU8wOFk4WG9IU1BxdW1CYUN4Tk9IcGVYakNxTitvNlIzUG0vWUNrRE53SVF4bVlZTWVIZlB2UHNkc0xjNWZhR3BHZzlNbjdEeXFGUC9UVHI1azluRTExVW9mVHpHYStVSml5NEFSeGtCMVVNOUtpWTdYZitWcTM1YUtlNFVzQTNwYUtVSkJJbS9CMFlmUVZaaE9MWGFxVHo0OVN4UEhUWE5sUVlPQUU3cXRvek9iazNRUHZROVBkdXBBdW85L05oczM3OVVjekYxbXNjTWNhdFYyRnNHRGFXQno4dmxDdncyemRsc2dFS0JxZWtYVndSVmF0SnVKRU5qZWJwRGZjQjBVbHJHZEExbVc5SnZJM3lJRS9waDUyczVLS1ZlK0tHZ2wzQlJURHY4aUxHTDN2NEUzcDQ4U3l3cW1zZ20ybG40dE1ZakZEaHA3dmZveFlaVSt3TFkwZzRMUUJwdThYRk5zSGlIVXhSeVREdGtjUFp3V1l3bHg5dzJvOENsd2xBNFN6Q2tkUzZ3cEJWanZMOWladE1OWHJ2M3hFQnpWeG50SzVRcWd4NjlFcnlUQTAwNjlCVlVCMGZ6eEg0cmwwQUJLZFM5ZlJIK1Q4cHhOVkFMOWVTQWFEbURQQ0kvaTVOWCtVSGg5bG00NGhVOFI3NjZMNEcxdlB3SEZnR25ZRlY3OUFGbW5Ta2I1amNFdnRETGZLWEVqTE9lcXNOOHBiVEVKZnkzOEpxeWFVdFNicVVEVDlEQmdUNzl1bHF6eWw0T3BGMWVGN1loMitQTUtwK05NMDBjRW8vamZaVkpPTXBYcGxVWnI0bEw0bHR3b2x6b0F1V2RQaEpSbmpXSWJETk5pRHFEWmpxU0ZTYWQzVEhsOHBXT3lNVElpZk0zRllvVjJYQ1Jwc0ZxYm1zbmlMU2Q1OVZ4VUtDRnVQdTM4dDdjSW0rSlpFenY5RmNaS3I4TUxaRnpucTFWNVdpYmxrVVNuelQrN2NRTFpvcDNGUUdxSmVYem5zNFFSeG5mc0dOVVVtSEYvQitHeUMwSU1xS3BJRU9jU0VsZ1Z3WDFLNWtrbnRrKzB2eEhoSVRlUWlkWlRpWWNNU1Z6Rjc5WHA1NngzWU04N21rSzJQQzQ1ZHlPUWN2enlyM2JOMVJPaTl0M3plSDJMWHZIY0tZdmRiQXJMT0lOM2RsTkw0M2RNQXBhVEUveU5aY2gxaEtxT25BYXdXaHVCd2lCWVFtOTM1ZVdDcmhDbVFKR3Q0QVhQd1hLZlZsdUgyQktONSt6RFdJTVhjQjN2OVphOUwxT2xBY0RRVzhDUFhIbys2NjZiWFpxNXc3d3d4U0doNjdqdGsvMytOVlVEZ3I3YUFCZHBQbmxGQVZwUHVCQ3dBMVdsMHh4ZGphTi9WdFVBbzVCWVc3bEZ2dSs3WCtTbkZKTE0wTmRWZnlsRUlyWlRaUFBEUEtNVXpqaFJGR0tCei9GTS94RG54bmNKbUo4d3MxQkkrNGY0eXgvNU4zRUQ2WGMxaU1NOFRCWXpudlRLaTc2b1kxVEhxekxOT05MYVkzWUg2Y1MxUnExTFpYSCsxRHdFQ3R3cHc3TEdKL3djNVc2Nm5PcWJqN3pkSU40VlhtdzVONVU2WmswOVNuVFN3Yk1rUGZHcDN5YjZ4aU1GMDdCelh5SnUvS3IwZEhkY0g0c21YZFY3alErKytHbmVjVG9FVnZhRThvTG1iYnQwaVAyWWJtTUxXR05sTmhKR0ltUmpDL1lRclI3WDUxaGZ0TVRxRW9uTzdjSWFFWGQwTTB2akNwYmpuZmpxa0dXclhUallrU2dvM3BNYWNZVG5LSlljUWVFQmhSUU90a0dXdmJJSkdFQ3kwQlJOaFdydUFqTGtkNTR0Ym1iTnZPMUd5MFgwckdFbEMxMXRCYUNRaDI0T2hLckJaQklyU1VWSGFxVFhTSEVZMzBnY3JDZGxwYkswbEVOT0NoWVYrckdDakxWYlZrd2VMaDczeXpldm1tV1RLSFFZNndNYnB1RnAxMUF4d0hUdWlHS1plMldBeUJLUHFjRmJqdFJ6aFhpN2RZVEsyd0pPZlF2RGR6VkQ2SUlnMExzQ09wcEYvTWwrSmlSbGVCNHhXbW1RbWNxeS80dWNWdmhseG95clpQR0trMDNrenBkUEt4ZDVNakJZbytTY3AvUTJTUlhKdDFNT3NDUEZRcWM5bU5MQXhQRmhDVTNZQ1Erd0U5aTdwNnp5UmtuZDVCanU4SS9HVFFIVi9IRFlwUlR4Rm1CVUVHN0w2a1BiaFdLQjhTdCtDRHdCRTZseFVBS0lOdENiQlFWWHJBOU43Wk5vVWZGeU1UOHNzK0NWbXJUbndsVnIzVmJYK0hnMVZDODY3MzErK3pWbjJVclZQbkFNVkJNbzBDOENwWnByYXNxaWxXOFYvdGVYaTBsZndyZkFrV1hyTXY2cS9ZdnV3cTdhQ3FzVS93VGJ0TFgrOHdqYmttYkt2dGx0WDE1THExU0cxUDRTSWtjS2JuS29HVXRGVWdSa1VBaVZscmYreUJ3bXlrVWpPeWk1ZE9PTGpwZkhRbk01MCs0NXJPVGhGT2pVTUVXcG5HbVI4YzdtS0VjcXE3QUExeE0xMnpYdXVuaFUvRitCL01yeEw2V2trZWo2THpNWTJab2JWZzFLcDhvMi9aa0VCejYrNGErcHFjTVBxYitHTkd4N0dSKzg0UlFJa2l1T0dvQnVMdGRmNCtiVUxVRU5TSUNKRmYzTUJrQ1o2MHg2bFFvclh1N3dHcENlSnhkSERhc3E4VldEUFpib1hEZEQ2VW1FNzhsbHBDYkRsMzBpQzBPakdLMlVjSFRpaHl3VVZTODZ1VnZGYklLZTRjUExIYmhCejVnRC84N0FHeFhDaVYwMUNJRXAzWHpRQnR4S1BQUGxWVjlVMXA5SWNBb0Vtb0pQQjVQdllEbUJ2ZkZyYWdMTTdRWnNsVmkwckRobEduMW1NV1ZrVHRkY2U2SG9sT1dnV3RkYm4rWm9zVHU3KzZCaWhCcFFhcmdBQ2xVMjVFK1NCUVNaU0tCaStRb0FhZytrNmFHN25QeWxwWU9QQUVzNloxWGFVS2JIUGdBcGhWc0NDdFN3dGdoOUV5WHQweTNiRjFMRGlxdWVOZjB3c1Y3OGZUWmE5MVh2R1dOS3hnNUlKT2ZlSEUzaE94WWxuKzZVeFJRODFkOUJaTXM1ZzU0SlRNaEp5MmNMZzd5aEJTMk9SVnZhVVBpY214bnhrWks1Sy9ucXJlZXZScFhRZGdPakY0ci9vaVArS2RTcTNaYXpycUxGdWJ0aG9vdldKSFhQcWRNOFlwcHd6TTJGUzRSR2pQWVNTb1RFK3hzVitZS2dBMVhvWmtlcTBjOHl6eFdiTHpwM2l1QUNyM3d6RHViemNLWGxjeVZpcXRnbWIvZzE5VnlXaWFRT3RKS3VabFhHRG5Gd2dyZzNqajlJRmtmaEhNZWd2Tlp1aWF6Z3ArS0REbFJCUlVPVVk3eSttUVUxbnJKZWtCN25TTEpQREdWcE56SS9UZGFXd1FWU0V3YlVSQ1lSTVN6WnJuVWNrQmdxVnZlaVdrMXRQRFZtekZDcmdVbXJtdjhWQ3VtVVhzVTFZb3A0QTdMWnVPS0dta3VGSkFwT3NhcCtZN0ZoaFYrT2V2VlZ3WTJ3RWFob3dEVzBnYVVpaEhES2FxMWlZOXZENzBoWHlpaWZNRWJwTm1lNFpRdW9mdGU0b0kyTEpvcCtWWDR2Z2Jsa1RQaXJoRnlZS29ZN1dwNXduNlJYckZxQnEySERFSVlUczFoaWNPZS9Wa1dtK0JYRy9hMStJQkhmZ1Z6QU1BeGhOZmRFQW9sdUE2TEF1VEZVZnhqR2tTNzdYTVZqSFF5bTNYYVY4Wm5Xajdiei9KRDhVUll6d280bGkybG9sendCYkRsVFF4R2VGckZsQU9saExOT09vZjhpWWR0czQ1dXFPZkNvWnYyc2Z2Q005cGt1L2dGcjhxSWJURE9BQVp4TFg0M24wR2FCczlDaDI1WjI4RW9FVzB3MzJOK1lCY000NFV2SGlXVFR0Y0tyMjYrYlBlSDdiVjg1dlV1Nlo5MytkZTBUNFdDWFhWNXRkbjEzQzNYaGRPOU4wODluOElyQ2xiOE1FWkNpR2FESHkwY0NVNnRXaGNLb0oxcVdoRlNCVlVkYlVVU1NTRWZ3bEMrd3VNMUdBKzRNcGV3emVPdnkzVGVGNEdGVi9DVkFtbGtPY3NiWHcyU01SVW85YTRXanB0Y3RiWXlXb2RyRXRkK2ppTmV5TzRLaTJXc1M1aEJJUDdFOUpJUjJGVTAvVnhoY3BQZlBMNG1ZZDFsSlNxd2p0YmJOYnZ2RVJKOU42a0daU2pvaDVKaFgwRW9xcTIwbyt4YWl3Mmw1YXN0YzdZdUxCNXVtNDMrSzdZeUxPY29MWHhUNHFUU2REcFdWNVh1Q2tXb0J2R2d3R3cveXBCN2QreHZVWHppV0hUUlVsSVJoRlZCTzdjb3VnblRaWFhiQVdXazd5NThmSzBEZk1EMFZmejBCWTdIV0VvcUcvTDZXczVHQzY5OTljazZwTHZXM0pxZlZwYmlwWU9ZdCtZeHFzQUR4YmFkWU4xTjNBTFBkZ0R5YjdmNGJleW00VVVxWjJpSERpTWd6Q3BLRlJsS1htVStvUDhlQnp6b0ZRYWhXVStDZEJJWCtUQzNuMlFHMnd5RjJ0eHBWUVFMME0ybEhHVU8rU21ZSlBKbW5Wb0JBUzhUd2NsODBKSjJXNS8wcmZTcTM3UnVPSDBXUmdsWDVTdVk4WXhtSXN0ak1DMERTcmtTMmlobFFnWDh5V0RaS2tNbThUV2MxaCtSZitPZndsMWNETkxoZjJjWVBqRGlLZ2krL0lwcXdIbUs0Z2lDNHRlS0hlaWVWN1NOZlRrN2lOM0R2K0xwb2pLOGpCWXJEZ2h3RUpZNGpFRmdNRzFnMUdmM0lZN1hPVmFLMHdiMlpVRlBCVlB1bVFESEVDOEJRMmlKTEhPb0lNS1hCQjd1dnJjTGtFR3NoN1RtOURrNXNwb0dOakN2c3hRd2wzRUhNdlZSa0NscFZlQm12TldtY3ZVYTk5UnJSOFJyTzF4VnVvN3hLcVE0ajRycGoxc0t0RkIyck5pNXVxU0ZzcU84M1JkTDBNQ09hYUx0MGduSkN0NFdvVmRKYkZBOFMyRHAyM3E0ditOM0g4b3h0aVNRM3gzdHZxcWpNbkR4dy9ib3kzRUh1ZE5iK2MrZndxMVNzWDc5V0ZOOFNjdTVYaUl3UmxlUEVMenhCYTlGc1IzRG5majY5dzRvTVoyN2E5NFl3R3l5WjhNbnBoOU43YlJldVcyRjEyNm95MU1jcEsrcnFac05BdzU0VDRmbnVPanBJenNnK0VHQjJqQmw1VFJVL3NVcEVGZ3F2czZ6bWJNS2lTVTlBcStEZEtUTitwWjZyT2lxbEdJYmhsTStnRzFYOTRITEFBWG5Iakt3cFMraGtmL0FhOGQ3a3lwTy9UYXhWVWExQXd6c1RtamtxUlhjVTRmdENkcHdGNG9ldmxCNTFLcFhucnFRWlpWcGY5SG5LbTlJWUQ2ZkRTWGdkVlh3dThKdnZIbTlWcDRveUIvck5DMWcwNWVtVjluSzQ3Vmd4SlRQWjRWTW5nUVg4NGZpazg1QkwrbVJDbmNVYm83a2RmUEo5OUpVMUFNWGhZTWdqMGduNDhNdG92eVpKeXJKUEJGQjNNZUNscnE1bFlkYUZlM1N4N3A5cnZZR3JBQ1VBRTNUYnhwWXgzM1dXVEM4MXEvcUwxcCtLcjd5MVRYNmQ4K1V4NVZnR3hhcmFqS0xjMldldGE1NElNRHNkRFJrNVM3SHM1Nm1OZ3htUXliVFNUdGk2emhsRHhNS1NxY3o0emdLQ0ViRHlkeUh5Y2tjZGNmSUJ1dzF3aGxRMjA2M0FXcHcvVGR3YnVTMVArSkZaTXFLU2hDMlEzUzNZR2p5NStpVXEwSXhHcEJIQVpCc3RmcVJuWkdNS3Q1YjBtMWJIRkFIOEZpbGxPa282ellQN0N5RTNKM25NQ3FDNUN0QUx1TTdqZE5KSGljOUNBTGUyQ0xzZlZieDlwRVBKYmRHK0hpQlFHV1A2WlVLbnQzcmJsRlFNVWZBNTZVdlRBWjArMEk0R0JIMHRJaHdiR3M5TXZXMFIxd0pzKzJTeGI3UjF5VnQrbGhTK3NBMktESlhWTWtVZWQycDcra082NDN2QVRKRnA5U2VMUStpcStXOEkzM0w5Z1VYTHFTTHIwakY2MEgwM3hJcjd1cUsvVmpnTHBQb3A3SjlLNVQxR0djNzRrNWVyQ3Q5aUJJWXVNczVkYVBvUEszVW1YbHNMZ1dtVXpER3c4Y0JUcDZwRXkrY0xzSldXR3dRMzFWR0JZNzhjcG1LVjhWS1pQUmYzMEhIbFV6OWJPU1RGZ3BvdmtxbFgwL3VDR1FpdjdUd2ZMSzA1dXcvYUVVN3k4ZHBteFdVVTR2QnVGSXV3VWRDUFZGWUZVOFNlSndLc3JFL0RjTE52S2tVWkdiaHFtamtVNE11aVFnMEE1SUZYOUZhN3NGSnVTUmUvMWVrMlZUYmE3TWpHSkZ3SEhhZGZSakNBZzNheEZPV2paU2YvZ0VkUXNwVHBZcWpRZHpsQlgvSEVKaTBqN3B3dkUzRjVGM1J6YmIvdEt3NU1wanVyeHNlNHpyUnhySGFteStIUm1OaE9QZmJLTGdlWTVLb0poZ3IxL29SN29iVEFSeWhEQUt4TVpFdU15dFI1RW5oY3NUVU9tQUVwMk1NQ3FzZHJuVW13U1YvQ1hERzBRY1F4UTd5WHpYVXEvdTZZdVJ1RzJmZFJkQWdEaEJkWWpXWVYzeXp6SkhJbGlsbTFhclFJdkM1VEg1eDBhSnlWY3k2RWxlblljU1JYNlhpaUc0ZTkxNjVCOHJqZUR5N1h1bDFkN3l3TmdqN2FxNi9SWVowV292NnhxTHl0OEwvazlQTmFlQmE3WGJBc0owMkx4Z3Qyazh2OEYvSHUzMG5QcGFkTVAxeW82MzRhdjJ0dFhRY0FPaTNJWmF4L24vcnpoTXlvQ1RwQW5JVTFOY0g2dFNqTlpEdzVYd1hLbFJtKy8wRDEzUUZPRlhlb0t6TTUya0d3c3p6NE4xWlQvOGdETG9BZEMyc1dKRlUrZHZuTzA1L0dJNGNNSGd4bTVvdDd6OHQ1TFNPb1VQd0FNeXNZZ0dmT0VVQ0RUYmw5TmJxQTQ5NXBoamx0YkJSVk9BdnY4VUJoZUFjVTB0NDJMNlNqdFhmMGtoTDFGQjlHM3lWVWhYeC96dit5S2VwdUZLSWZiWlBwWS9HNzhlQytRM0pHMUl6Zzd3Y2cxeEYxQlVha2NDVGZkNVZRTWV5bGJXdTh0RUhzaVFURXF6VFlKcDBGTmUvSm9pak1BcjNxa01ZQmZzVTNtTit5dGtVVzJFUUZ0c2FGSkRjSHlJais1UGgrZ2lFcTBCYlhpNHVnbGtvUmdPWktKakZVWTdSbnIwNkJ1MHk5K2M0NHRyZW9VSVYwOHBVVE5WWUdVdi8xUUxCbGNHTmx4alc0NzArRTBmdmZxeU1pVjhxSnRQMEpmbitZSFc2aEM2aXJJR3JwVlZ4d3F4UWRVc3dtZHI2RlFDZjYyZGV5OFNyUVNpN0ZVZTZtTmZkM2RZbkljWE53Y3RqZEdRRzQxVm1LZzAzU2JwbHdmUFZuWjY1VDh3cHM1Wk9UYUZEOENHZlBDaXNxbHY4dkhjQVVRbUd2eXg4VlRLeXpLT2ljS3NDL2tFVVpyd3FvN0k0UTZGZ25TbnNic1U0V0JZRm9FVzhDb1dseGVyVURXc0p1cTE0N1ViRllmL2xZZ1ArSEt4QkR6T01VeHF3bkVhYVJLNUdvaVQ5Wi91MTByUlE3RHZ4RkhjSEJBY0kzMzhjTW5YWmNRVXorc0IybzBRSDdDUERla3JaVWZuMzJaTjFSamw0aG0wVlBjMHJGWkJjQ2Q3K0JtemEzZkdTdDFQQ29hWWFOTzRCS3l5alZxQ2xEV05xOUlmOUphL0pBOUt3ZUdYaWxMUGxHL3RObkEzeWhuMVd6MFYzMDh6ZkRlYXIwRTJyc3FZWlh6K2ZUZXZXWjV6QitHNWRHWnQvelE5SGRLTWl2M0Nycm1xYm1ZekxlSWY3WXpDUHdUUU5oSkJ0NlNleElpamYzcFFLK0xETjNUWjI2NjU3cjkwOFF1bytXKy9QNVVtY0xmVmhPWjgvbGRhRmJ6NWUya2ZBMmZ0Q1hmSGJ5UXh3bUNPeHAxNUtUSm5TcTBMblNwQU02UW1rQ24xMWpvQ1JHV0RwME5UZkF3UEJkTG5VN2xUR3FZRHZhQ1hEeTJneXZDckZlNWxEZ2tkNlM5QnF2STFSY1podW5aNytZRWhtVGFYaHN4YUhlY3h2V3RYaGM4RVN2bm5FMjAxdk50cDg1akUrRkF2V3dvSTI2S055aDNZSUxmY3FTc3ZGTG5QeVEvYndWNG03Y1BYWGJmUjVJYmpiSmRZTkZnZWdIOXNzLzN0V2tFcmZ6YUJ1VmJCZXk0cWZiWk1EblFiYUJ5N0g2eXNLRFFsRHE3QW03TEozMzlWcXprb2Y1NUxwei9FbDVsVW9KUHFEQVdJUGc2cFFIdGdnU2kvUUY3WVZpOE1kL0NCeFlDcVlML1EyemYzOW9ybGtZK2NzVmpTVGNkekNrVUp0WG5GSW1yb0txZEtxSU81TEJwMFIvclcrTytiRkVaK1lsRkdKeGdaSnA0M2dMWjQ0dWJCb1I4MTgvUjQvb0pZWTlZQmhybzdScCtCRlpUUVhlUEFoS0VOejJoUVd2MHFRWk9CbzFVVS9RaDlwNWs1OThaV0docnFLbi8xbHYxWWZSd2IrbUZiNUxHc3dYOFZaem5CYXp2aEtNNzNxRlo3Qk5HRjROYzd5VmNabjY3Q004ZEhmbERIZXVLNkZaVnpCOEZxSzFqcE04eWVoUDFSWnBocWdnd01GZEpObndreXArTGgrK0VmNDNWRDRWRnkxeCtlaWovZlZkdU1DSCtLNmJUVlBwVlY2RjFZM3JndlgrRWpqR20vZFpMZEduSlA4YURoVlJlTlZXQzdIQzBDaGxWQUtzY2hKWUJuRjExb3M1SDBlSjhNelFOMExwQS9ERFl0N1h0K1J3ZUtRUFFobm5kMEdSb2VoWUp5Q2FJa2s0Mm5xcHpMcHNicGx2Y1ZzMVdIeXBPLzZPU1VWaGlFNmxISWJjQy9oTjcveFdqVGhIQ2RmbHlpV2paM2VMWXdpa25tMDBpekwzN0FlWXJVVStLNG1hdDJzK1RrZDFJZmwxRVhlTWFpVTF6cmNtVEt2bDB5UjdsMlVjRlJ6Wk1yMlcyL2dRWms0WFZTR0lraWJDQUFMSzFKTEM0RzBleHdXNjExTnk3cFFZYWxRQWdMbTV4VFE2ZnlZNlpSOW8rUGEwMEVuV0V0dWVyVTlobUJpY3pDZ3VHZk9WMm9lTnlaU0x2cVpnY1JQZ3FsUTQwcmI3V0FWdGxhM1UxZjdKUWN3ZldaTTE3SEt0ZjcydEQwTUkwcjA0UUdQb1FsYTJwL2dzK0lsYnBWWmI0b1N0QlVNYWg3QUtCSDFHeDVpaTczMG9pd2tjZXVKbHBuYk9hQkMvRU5qaFE2M3oremZMd25WOXlFSW5RS1BkQ2ZPdmlrNm1jVzh0ck1iVjNBNklCNXZvNTJCVXc2K1A1ZTMwZ3EyTGJQZnBMUEJlUFA0ODc3dzdONmJzK0IwMnlWTDJLY0ZJd0MyZjBLQmRTSUtmc0V4S2VsYWJmaFFtWFdLUnI2cTE3cThyenE3OExwbFBuWGZ6Vjh3VC9PYUI0TUlBVVVBZFk0NkJaTXdwWlRqWlZxWVVHS1cwaEpJQ0IzdDBLTFNXUnRPYjNSSGtKcElkeXVISXhsTHdNcGxkUDlwSldtdFdkNzRXaG56dnB6WnJwSUpUMnRwb1lVQWt0MlJ5SHVuUS9wU3loR3R4WkxNaHBMa1hnWlhTZVZwb1JLOGhQWElETkdPVmtrRUlSQmVyMDczcGdqK3htT2k2WFMyYm1QSjZCUEtMUjQ3bmwwRkRNWmh5dVlVTUFTUnZWVnJmVlA0cnRZTEhOVDgxcHdkcnlQYSttTy9GWXJaT3FTVUNzTmJSeEIzZm11MU9vMTBPNFZUVXBtWEpxYWpGZlJEcVRPUVJHZVNITk0zT2lxZm9SSDR1K2ROdkVMUnEvQWNlSUFuZmtPbTZmcTRIRzBka01MU1VwbERlK3Z0bzRqY2plOWN5MWRxNGpSVmxJeGx4cHdZNGNjV3BtRUJvanpvUHdVWlR1Q0t0V2FmMGpZdE4vUlcwTW9wU2JndEdlbkZVYnhJQ3ZlQmZPYXVrRmk0SWM2TTBsMmVVV25GZ29kdkRkQUdyVnNYWnc2VUNaclRaeXJ2T0UzRUFVTitKVitBQ1lHWHVvQnM5WmowdHY3TWQ3UlVnbTVSS2kwcmIwc3B0TkhSVitiekp4enJ6LzZySEhudHdxcjZRa2JhTXVZeXoyUGZRTHZrNDl4QS9UaTRRdTl1cURybGgzVEZSTXVpZ1M1T1NMU3F4M0pWZDdwNWpnclBkcGxXdjZyanczWlZySFRJOXFhZk9oY21xbXkzclYxbGZxdzc2eWxveG5kRDk3bDczNlY5Ti82MExCS09GVUJINnd6VmtuRHZrbzVhUjJpNE9KaFpBQ29IbFlERUpTY0V4Sy9BTzJReXNsTkhtWFhZOTJnVEdKNU5qNzVVYkxsY0JWSGhNU09BNFcxd2pjNm0yeHgzbU84UUdpakZkZ0o4TXR4dllYUUZzSWl0NVdSSWl5bTVNUjJ1Q2dUQ3dLanRSMFBkdCtSSm5YcHh0UlpqUk9Ia0JYMUpCdkVYVmpqa1FVb21VbEIwQkNOcGNVOVhJOWZwNjhESVFiZ1JOY3lHSGErckNNWHAxRTdmRm5SYThqck5HcC9MNnZZZVJiV2tuVXpYOFB0cG1hUVFJNHdLbU1vUEcySHZ5OS9BMHc4amJDYXVvaFh0RkNld2dXNzZqRWdFajlpdXdhcmMybGRiVkVJcVQ2MVNtSFZObTdWV29vM2daN3VrY1FrMm1GTWVDbFBPemNIYWNOTFVzNCtER1dsTUtIdHdWU0dFRlVkK0xWWFQ2V1hxQkFkQTJHZW1Velg5ZFk1aTFxTFMrbUZhaUVKRVpjSUh0aTFYQk9OTkJONXYzTEZyUDNrR210cE9uZm5rN1IzQVE4c2E0OHBCVXo3dy9jalVjbUxPNEVtZmtCMDg0RDk0SlNnU295bVFLQ0JjZWFqTDdJQ2gvVmlCNGNOSjRWR29TN2lDNXloaktPR3JhemZOZStsb1dxWDdYTEFDQUgrcS9zcHJ2SEZWem5pZksxNmM2OTQwZi9hYk9OdVBWQmZCTmdrajhFQ0pxNXo4Wi8yd2UvWVY5Q25jQ21aczBwV2Y2UzlobUwvU0NvK0lhUDlZZndicnlydGFZWlJmb2VZai9vVlBXeUJ3ci92QzE2djFCTjZkdHB1djRxdE05M3FLVytUdFptanZoMDQvZklsVk92bGUzbUNheStkR2hMT1hSbWl4eElkQ1cyVWpPK1hxRVU1anlvWFRIZ0xwRDF2aklEVklzT3EwYkVRK08vcmJhU1ZZNXRHcU1uOGM5d0pBaWVoeitKaW93VHdGejRiVTZHUStZWHNWcGdxWHJPU0ZLWFJBWXhYSkRBTVVWZ1h6UnAxMHBQZkM4MnJIeG1rRVNJSUtVMHN3Tm1raW9JbHpXd2ZUSytOMzBHM05Zb012S252WW5nc1BTeXhDODdxdnl1bWhEQ2g4clJrdE5JTjF5NXllSjlYWHpBZ0tacnhwWVIwRlQrZnE1UUY0T3NUMWVSMFlJRVorL3hBK1VvZkt1U3JyV0psRVFHMkRMNXhYKzJ5N2RQRzVsSms0R094VHJSb3RJWldqeWdkRVNVRlpvZlNrcXovTHFxalFHcHdxQWMydzFFSmlZR1RwbllxRHZWdlFYR1ZzaURaVHpxYXBjSVVqNDN0VlFkdVdXUFdVN2loY3o0MGY4OGFGMnRCOWdQRkJET0pCTW1pbzlSaktTa0dnREJoRlBmNFJ2NFNmOWNvbitzeFUvQVpwVXZoVVBzdFVzTzgvRnN6anIzaWtCUDgwYjVXdjYybTZ6OFZqWHYwSnEvQXlYWndkaUIwOENyV0NGM2pRM0dweFBKdVhjb1diTUl5M2ZXa2RIZHRuMnFkQ2xiY2NhSUZIMW1KOHdUTStCZ0J3TmhSZXB6RE4vNm0wMDd3ZmU1WXVGWXBPd2l2M1FxWHhwZ1hMenlvc1V2UXJTTHhrWEpEajF0RThDYXpETlRzM0craTBBU1doSUlvc0pJMTBlRk1Zb1VBUU5oc1NVemVuRjR6RUlsR0NKQkxsVEMrRUFza2dmSFplUFh2MXAwRGJJT3ZvUG5zZjAwcEdoZGlEQSs0YVRackhGU3duN3VZMWlGc1NLdVBqczFqa0VmZFFkTlNoTWxiNXhZdkRsTk1TMHdKUmEvaFpNNmVIU3h6Z1RsL1RzdFRDY2xVUittQ0o2ZCtKNlpGMVNhVmdBQmtYZkdOVDRCR1B4Q1ZYRDhWVHBTbXJ5c2l4NGdqYzBSaGxpdVBkYWFmd25GcTYxK3ZBUmtIYlpUbjdLeFkwdU5yR1dvMnNOdWVlTlVkckJ3OEdBS1o4anFyaUZoc1RhYmZsU3FpOEZ3OFZKeG9yNnJWOVVDZmVGeFJ1MEJSY3RHd2NhRHk5UXY3d3U0M0NxWDRUUDh2NnZtUXFuNXkycWpEOW9vOW54R3ZaTTNxUUQ5NlNDYWtwanNrR3Y2VFJoMzBhUENzU0JQRXdUOUd5K3RzMjFNOThsVjczUG5mVHZSZG5lYUg0eGJ6ZFlKN1QrcnJwZGQrRjI0MHJ1T0tZMHpqYm1xSHdNUzFDSzg5aFRkdkd0cDJtVlZzU25qaTFtYlBrWTdxUDRsTDU3UmZMWkJzaXRTMXhoRm4xWng0NGp2eWZDcVpWVzM4dTMybDU4VG5ONzNQaUtlOGR3OUFLWXBlNkNvdHBVS2h1MDRtUDk1Rm92Rk12WDRHUnFPSmIvaGRIOWh5WklUUjBkWnJqZkZ0aFAyVVVwMlFTU092SW4vY0tsVUlwdy9sc0dmRkpaWmNLeTJlUkw0YTNFY1o1TmI5NUxhc2dSYU5KZXh5cHdNZXB6UW9IdUdjbVdVOTFnUGVPVS9FY2ZpT3RPb1V4eENPdWFhSm5wMm9WdU45cWovVzBaZlBuZ3NQcVZyd2YrSERMQnlMaXlndk5vT0hXaXFBcE9Pbmc5c1ZzcDAyMlh3Vmo4SVRVOGxPQmJ1U3ZOZ1ZlcnBKUjFqY0ViSk9iVGQyOTdqdC83blFmVEYxOXhRK0ZJS2VWaGRMQzRwUHUwclBhbUdXMUNOMXVrUU9QVnhXVys1dDhUM0lZekoyalorN3BPVEtJNWFXdHVPbHZEUCtYSzMwY0RPamJFVDJVanM0b0ZWQnNiUUZ2Mnl6TlVkZlJEK0lVNWR1K0ZUZHBmR0E2SFpZUXROK3BuSGlodW9mU2N1SEEvVjBPRXJHYm5uVHZIWDJzaDV3aHJGcmpIcHNqanRWZWVhSjRxZmpFZE92MzJnM0ZDOUxEZS9tb1FwV3BjblUxM2J3RzZ6VGVVR1hyMlRqck54aFg1WXRuQzk5Szg5bUJ6Y1dNQ3VMZ3owSFBCWjRRc0lCWGZ4SUg4MWRlNFFTTnFMcnFxRFR6R1l3WEQrUEZ1K2dnTGkzS21iSDlhejc3OUdQQnRHN3dXVGlHcXFQbzBNMVg2WjlLSzdnQmk3WWtEamtJRFlPQkdXbjlicDBTRng4MkNMK0hsZ0ZURnV1bmtCYVlCVjJLanBNdUdmVjlEZ0pveXNMUWtKanBSZnArQ2tHbkh1YlJyS3pPRG9hbVlVNUhiWjlDSWZMVmdRVlh5NndJSUR4eFZka1pqQzlHYzlWUTVhTnpPYVlhd0VxQzVXampTSzlnVzk1eUtsNXhpaW1vQ2hoQlVMREdVejUzUlZ2QythMEZ4VDgzeWJJUktFN1N2THU3NWZOL2N4VFZBd0lHckhiUGxTOU1LOHp1UG5lNktHeXRESmZrRlYwM1hLWlZvVUFsSGZXYmFiRTRLRWliVXQ3VnhobFRPeFdMaXc4NVVMREJsMzVhenQwSGhsVkVHV0Zhai9RU2Z5MnA4L1B6dUE4bGJndUFJWjNUckUrbEpkMGNoTFRNUENiR2Y0RUhkUE9zZUJXcjlFc2FKaE1tUFBPbFAxUDhWU0x5UnZncjZSTmZ3YkhOSG9EWUEvYUs2Zk1LWld1ZXFWTnNjQlNPdU1lK05lcFlMS0FCMDhUeml4bnRVaGt4eUpnTzNxYUVvS3F3ZVBwVXNQMEc4WlgyRlNxK25qOTJ6WFptR3kzcnM4R3J0RFB1RkU0OW0vNnBrSEFUMW1tK0tsOTFaWC9JcXg5WEROMDZJaS9OUGJheW0vcjVlK3RPM0pKbW55L3haVG1FVyszcTlzR1hsZjd5WENoWm5LVjJGUDg4TlVBaDluVUhSNzkxS0N3NlJRVW0rOUJCcUtTV2tSQjhrQXdyelByc1BMSkowSnJtaWJnQzVTZXlQS3U5OXZlRThGS1BscEM4bGdvck8wdXQ3N08rR0MwTEZaUnh3aXhsMVcyZUNrTGh5WGNTYzhycGtxNE9Ha2RvT3lkaFVnOUtoZ2pncEtVVnpuUHFNbWhOclhDZTIxSUZCbDBRaXN5dEREY2N0cmYybEFOeFlDVHM4OW1yeGYyNnVlY3Nxd1VLYk1HTHpIN2x4L2YvMUkzaTc0Y3lkTFNMUTkvWGxHaXJ3cXdGWVZBeDVXcFlLaDZuWkZxNkUwNzRqRmR6eU91ZXR0eDJvTktpVHlpalF0bTVheDM0UFJVWWZhVFZJZkdsanpSUEphVnk0QjFHY0RQWUJ5byt1OG40K1FNYlA5SDlXOXE5cDg5aVVZSkVSMU9WWDlGYStrVWZrTWVGaEMzMFpoNFkvYXdpajEzOE9MaWtuL0ptdSt3cnJTS1ZjRXhaVWFRTGZIejJ1ejloOUdKVExJTUlDbHZWZFBmK0hUaGdJYXFNenk2QnIxRG1vRUd5emZ0bzBGS05BU2g0S1lVbWxDbTVwYm5CNG5XZmdJaVJFS1NFb0FFNzk2Y2x2MWltZ3JTVUJsMmw0N1BsN09kUGhjcGpldldKOThiN014VE1ncFViaEUxTFdZdE04U2R4RlhjMy83b1Fvb0ZnYkxhbmlKT3dDMzRrbi95cCtuUGFtQVBhTVV2QlNjakgrTS9mRmR6UDUvenJjb2hKWVdWSnp0Ym5iZjFZb0lQcFdHVUxZbkhwWTVHNHo4ampkV1V5U3lrOGhrMTRmSW55M1RFWXpPbUxCOWpGU3FOV0RoMGkwNWZHVlVBOEd0a1JKQVVtd1BBSEFpUE02TXhnZEtjNWNjS0M2MElJbDRyR3p2WW5yQ1NLZWQwZjV2YUdGWXl0czEzSE9zenFlMnd3cWZ3ZzB5cDhNb1creFBEUm9CeE5pM1ZPTEF3ZDJrNkxuSFZZem5PdWRFVEhTOE8wQTZSUlNPL1pTN1Jxbmw5d2lCMUgvKzc0d3ZKdVRmdDRkODV2QmQ2OHZRbm51eHNoRDlLSCtsVHNXaFE5RktPNkhsWEZmVnFmU25XSWtjcURsNFBqTTJRS3B6VFRpdVduUmJhMGpkSVhCVWxYUUJHZ2NCKytIdnVEWndlWWtYbDRIdlJSZE1oUFRGdERhVEZ3OElMem1nMnM5aDB6aTVocTZZWlVNSFpzYXVVekU2cWFabzdTY0VxaTlhZkNCYldndDhySFBwRDIwbkVHRUUrQjZMZUt5a0ZOblVCUDA2d2NjSExMQ2RQV29RcWJQdVJGZWRzN2YwQ0J1a0lLT2pzVUZpOU5BVGNZRFJ6d0FkTG1IdjA1Wmxya1d3VDdNNVNvUGo1NmF3aWRQSUZDZXZwZXA3NDNSNVFoaElrQkZqdzhpeXkzUktpK3hkdEJSNHVhT3NBZEVnUlAyQmI1eWZKT3RXeWZ1K2psRDdnTXk0Nk01aVdmL0JaNTIrZEk0STl4cFd6TVkvRFplNi9DOU9wUE9NWEh5b1I1akRONDc2L3FvR1VSNzU5VUtMZ0JZQ0JzWkRJbkxKVjdiSVVCUk1oZnJENW52WmFKZ2MwTy9HU3dyVm12Q2xkTFcxbkxYL2FoK0JTT3RzR1Z4NktIWUwzM1YzZ2JKOHhTNEFXL2FPQnpGNTc1RFk5eDNNUDJvWUNscGpJVFYrK2ovcVA4RDNjY0JXSnVUWEd0SmJjRmVBUkFuTENwZnFJRG96REM0WWNIYXZVTE9OenJWMEZvc0RpOEQ2c0I1QXhWa1JhWHhBZ1JneEFpM3cweE10UDRHZ0h0VkpYUUhNdkFFZHI4d3JWeFJRRExWK2VMb05OTzAxS0FjdnBsSHNzNjNkUHByZFRuZmhZd2dZblRoNlFpbFZFaG5wcks2V3RySVN5d0N0eFhwYTlLZjgvclZ6ZlU2YzV4dGpKZ1ZiMTc4NzY1dmJtTjg3ODhFNHVOR0trVkFLUHk4MXdyOTN4TEp6ZDRhbzI2ZDB6RkpWN2hOQlVWTXZpamdkRGNWVTNQRU9POGRZVGFvMXFFWmJvMDhHdldOYldUSGtzK29lVm41eDF0ZFhhN2FWV0ZieDdidDJMTFJRdzI0Q0ZzeTR4UUpQckJFRk91N1g0MnZyaWpqMUpsNks1NEJTejdnV2Y2TEQ3VmhZWEdsbGpvVlVLZWxpdU5nVDZXc3c3ZkRyQTlLa2w0Z3pyY2ErV3E0d2hGdDdwbGlzaVdGNVhtTWhTRy9RTGZFSC96WnQ4OHViN0NDVWdjYllpdjFEQUk2bUtJRVFjMmpjMjZzQTlxS3BqYTFjU2tEU3FUZS9kbWhiQnhMMXkzbzBnTEZmMkh3bVYvazBVQmx6TnBFMzlqOEVodWwzcytIcXd2TGVpa2t6U1ZWZ1o1L1dNaCtwY0U4OXIzWGcxZFdKYTFqeXVrM0Nncmdkbkp0WXZsVVo2VXMxSkNaU0VYdko5ZVZZQlpOaFdkU3M5Y3FSaXJMWVZqRisrZnd2cXltT0I3Mm0vd3ZodWlhaUs4bWxMUFZhYnlEL2NvTE0rYTd1a1k1dFdTZUZtV0ltNU1kSVZNaFAxdDZmeVJuUVZSM1Jzamc0VHByYjZqd3czUk9KbEVqaVRZQWFWMFZHem1reERteTZDU1ZDQ0Z3UjhVZyt4b25KMXFQdS9yMlRLcHZGSmg1WlFqUjdSTmEyV1JPL0tiMTBhcWtGVElzRXJBdEh4TWJRTytlY0dYdkZRVDVjVE02YWdIMVRYblo4M3U4aktPTTc3bGRSdXRxcHQzcjl0VlFUZU1zck1kb2Jlc0J3dDZWSXc0eDZzbVJnb0xTMHNta203aVkxdFVDTUdRNENRK3BudjFaN3diTllXalQwcGhLRVozaW94WWhBOW9qZkt6aXZoWXFnSkFQK1JVREg4UWVBdkxybmRLcG9XcjA5NHB1YTlVT1NDSWc1WktLQmN0UUVDTVVGYjZxR0xxVEduenhBb2o3T1A3aERNVVNXejJwUjNWUDhGMmxGWDBaWHlWY2dpTlZnNmp2eXUzTkkvVVFDZmd4WGxhdnBmTUZMT0hndDR1bU5aVGJnQmp4VUNDRWg2aHVJWVhUemwzbWFaTkhHRG9RYjhDQkM1K1JNUDZLV0VuRTZVUE0vdGR1am4xVHN2Qjl2c2FsTlBUNUdYNVRNRXUvTTN2ejhCZGkyZzhmdlNQZldoWmd6VDIva09lL21peGlKU2VKWGlWUzM0d2RIbmM1OU44eG4wdVpOcy9yalJQeTVyWE9xbzl6a2JrRTROeGhWZkJyTHhGcTFONFgvSmNNTDRrYitXUnZvV2ozVFBNRlVMTWN6cmQ5K2JDV3FIelpaQTloOUtKdUw4NmxUTXNBOUpkdGhhUVFKekNoQUNHaGFMZjZyaXM3cjNURFMyM05Sc3FpeWtzSzl3a1FBcW9pazVMd0ZkU1ZFYVdOVVE5N1RXWlE1Z3liNDVhd2pHdkI5S1pickNNc0lYcHRHSHY1a2lZMVRqelJqcllCT08yOVlRUGlIdTNLY1NtVTZXTS9PZStzT3NvRFlQTzcvR3RZV3VvcUZZNCsrUGRRTkRjTUxWVkFUaWl6MXEvbTNoWWwwcEhrZERTcWc0UGhZS1FWdkRERkdFTmdLOVdsZ2NoVmh0c24vZllNZ2lKUWdWakdjZDBVS1VaM3doa09oWE5ZSkN4V3hvK2RDcnU2R01jMzFvQVdCb29GRmNhazBiU1Ara2t6WVdQQ2daUEZoLzRhT3FZc2xXL09MdS96aG1jb0cxUGJFRGxYdVh1TVRnMlJmckorR3VQMXNGYXQrMUxWbFluNDNQcXpQYkxWMjVpWFZvNTZRZVVzbGFWcDZNdEdCQUd3OXRRTGsvWXVqSFVVZi9BQU1Nclg3TVpmVENZMFN5bWgyRHAxTTNwdEczTTg1L29iMVJZS0JQbzQwQmt2NU5NTmVLU1NzYm5zc2p0ZzZBck9GV29Oai9TbkRyTVY4b204NmVnVzBiYVZKOUczVzJjYWNtcmFYbDZYOC9DN29aVG1LWUp5M3lCQi8ybTd5cVVOdmhZbjRORCtGcHpLQWh3eGdzcmVMckZ5MmVEYWNKU0Z1dlphNlZIWk9kUEYxYkJ0SHkxMGZ0UGhTcHJ1WUp2WE1XZmxoUERnbXRhOTk3bmdFTTdnUUJQVEJsUmNTenZEMHVFRWliR2xJYlhZb29SZmlLRXh3Sk9UVFQ5RFRLQ3JDc0F4VWprWStwQ09ib2xLcFJaWFdLWFh2cFZZbzdNdE5OT004MHl4Z1U4bFFvak1WWFFxQ1N1VEZLTlZCQzh0MXd4bStVQ0wrQkV2Tk1CckJ5RktabkREdmM1bFVqQktnSmF2Nk55RVNmaXMvS0E2d3JYL1Mycmd1QStCSzYrcnJCZ25HQmppYmlxeWtwOE04QzN0V04vMUpqem16WW9mWStWc1MyeDBBQTg4UkcyOWFpRXEvM2k3UFlJaFVrNmFBbUFFdGUwZkJEdnlHK2RvZHlBdGNVSDVPSkZydVRTc1ZxTzBNNlJFWFdKVUxNNkJ5TmJSdHJiWmkwbSt5cU90bUZBQW8wNEJVRTRXUjhFaHc2K0pSRE5SeDNFZVdRU21DRGVRU3N5UjU5d0ZmZUt6d0dCd1FNZlhncGtxeERoRmVscmNCb3BUUEh4UEMybmN2Y29hRTljVlVuNW92TVN2cHM3QUtCb3BQVWxqdmMrNTZ5ZE16MmViKzlpTUNvZTlJd3JxQmVmVDlNQk9WS1RScUN0V3JyUVVyNnozVG1JNUlCby9RYlFCLzljVEtnNDQ4VXJDTVI5OFVtMTFmU0tzNTNCODdSTFJTYTl2UllzODFWZTQrbzVlZjZZSnN5UHhWVzgxK1JQOFM3Y2xRRUhNL3FkK21FQXMzMVFYK0ZjdkZZNEtFZjJmOEh5N3VkQ3RhSHlWUHZxT1hITHArNjlNWlkxcmd1amUxOHcvdG9yMzJCZzVZdEQ5cHp5eFRsR01IKy9nZkYxVGNOSVZpcWlkb2pML1dGaFFTempIMThLUnVoY0VZdVJIaWFzRGxWNE5naHpJcCt3Wk9LdDZOOEFBRUFBU1VSQlZDQ0RNSk40M2lzRU1EVnYvZnQ2aHJBbHVrSGg3M2FBeEpiWkRDcWt3Q0ZHMGxTZXhndmJxUW1YQ0Q0N2xWSEJpcHZCT1A5MVF3Z21FWEVTNXpCWHlsUllIb1B6NGgxZnVKbmpjRWVSNXJScTFGenhXYXM0Zm1lQ0ZZV0Z0ZVNzZEQvY2JoMjJnWWJ6bkowbi9WUlk0bTk3NHNWbDRxelRiUWRlTGVMVlRhTDY4TnlpVUxUd0NCdjVFNmtTUkxRbmFHWmY2SXoyU3pqUTBiT2xOclRkM2ZicENGZEF0SHFjV29xWFUwNkZtb0VHbWtTWllHSng1UjlJUk4vU1RxOWFVTUZvdE1VdjM3aDF4RWFwdk1UUGhaZ3A5US8xZndrUFBncmxDeTRpR2tJRDRuNnB4MjhjNmpmenFHV3dhRzQzckF3Q1R2c3p0cEo0Nm9LSEJJTFAwOHNubkdLS2hTVmRPWTdHVmNWZG4xVmpMY1J6ckRvdFh0b2VYemVTSUFSUWpDQjk1UnY1TDl0U0ZubWJnVnp5a0duQkJ5MmoyTTZ3MmdKVzV1MHFJdnVtZU51S3FyelhDdDViSnZzNVp4QUZvOHAvaWVBbVAzUUUzaWFDVXRVcDN0NC9xdXEyOFphclVERHEyV3ZXblcwVHh2OU1LRnlFMGIydlordnF0clY3LzdmV08zeVlZNEtQempXYjZJd0U0N2FBQTIvYXUrcmlTazhJTmpaNDdDU25rZUhqQUJsUHkvU3JNNjZ5T1VxR3hkUnFmeGs2dmlETUhoK1pKeitrbWVhc2hCcGo4cXRVWXVvSmpVTllaQmpHVHYwUHJsaVpyM1pnR3lkZW5yT1V2aTVZZ25wek9wQUtTZXZMOXhKaldza0hQWjMrZ0JrR0VYQmcwS3JEamd6WUxaK3BEQ2I0VFVLWkFsUW5zNExuOW9jVmVXeXZQcEExRHh0VzNVSUl3Vk9yZ1NxSlE1akk0d3BaQ2t0YWtYWmltTzZNK29nemRFcXIwYXY1OUN2WmlmR0ZabWp0eWhhMVlhbjVuaUs0TTF1S0tTQVczWUhYaTlhOEkrazduUEY5Tytqc3ROV2prSjBsdXVOTFBaNHNLRUdUaHFRU3FkVmlGenN3TVBGakN3YWV0MUQybG9nK29DKzF1cVJUczJGTGhmNUxTSzNsSmwyamg4U1ZaR25UNDZjeTN6RnE3M2kxSnIvY3cxU1ovbGt6UFkyOVdmcEdQYkdCZnJQZ1ZKL2crNXVnTStTaWEzd2hteTBORDJ5NnBTMHE0QU9XYXY5d3p6VDhKUzh0OXByWjRHdU10K3M0K2NIVlVEL2dzZSsvYjZhWEhMdU5jZ1poUUdQcUJvYjVWNTVSSVR0dnBFWHhFVmxYa2EwakZEUjBMaDZ3TDB1UTVITzRPdWlSOTVTbjdYRThUL0NhRmxzT3BQWnRCT3B4UUlpYXFWSiszUHVlclhTaVR3dDJmQlZJaGcyUEtZbUU1Tythb2x1QmVFTUQrTk5GRy91R2lJRGhRQ0xPcFRBdGEvNXVzSzdDSy9pcXl0cHYzUHRUbjJVZTgyWnBRUm1xYkQ3bFgrSFV6N29MWitPa2hXVk83MC9obUc2d0dydkZtNFJwYk1ibjNhZi9SbjhBWitnMHdnbUZiOFRiQWtmbGVPL05UMDNCVUdiMC81YnBqaWJsbWhVbU8waEJwS3VESWJSMG5FcUthRFZBek16bjFNaUd5c0NtRmVIOE1vd0tSYXN1UGxvUm5Wc2Q3Q2doTEtvbVBvTU03ZEs0OWRqMEROTENQRUJET01qTC95bWp1WDNwYU9tcVdaeVhSQTZEOVJ0aTFITmFRYnVEZVZ1QmNYWE9YZHY2cHp4M0toM2RmQ1AwOGdxWUVnS0dqSTVDRldBZXJMRUtWaHhHNThrTUJVdUx5YzYwampIK25XQStsSlF2L2xxWHAzT3E0TXl6WVUrVlNpbEhaZFBkZk1vM0VLSDFrSGNIM2ZNVTVqOXlFdS91Y1ZxRVFoZ1dGN2hFT1JUQ01ON2pnNzdBMUpwUitNTmZSZjFxTkJsRnVmSmw5VkQ0OUYvNWdDU05RdUxDUlZnbHFsZmNYdWZublA3Z2VpTDBkYUVpTitDeTBFQmJ4ZjlBKzF5SmMwUG8yUmxXRTM3S1BYeVRCd2pxNTJPLzFlQ01xU3A3eitnTGhVNWU4QTJKSlJYY3NDM0VFeGsyMENXYysvUWRHMXVnS1h4Qm5YNkNiT2Fwb2ZqQXpxYlh0QldsRFYxVzhLWEtZQWhOYVJGZDNrcWVIVXNYVVZQMHZ6d3FiNnAwYkY5MHZkM1BUUWxWS1M2TFNrdjF0ZjQzUS9DeURFWHc3SHFQejFFRzdHY0Z6ckp1NllHU3daUEJpOGhTelV5Q0dZbVU1K3JWSXVOQ21RS3pLL3pCbDdRcHk0aWs5L0E4ZFVpejhNTnliM2hVQURZSWZMdWgwbEloWkdMeHZIRVdpV0tSOUdIaEtsdjV1M0NOa3g3UlpxN21sWCtOcjNMbTc5NTN5OWU5TFF1Y3JWcUN0YUZicm50L2lzdndtMTg4a1lUc2sySDZ3VGh0Wi9sWmVzUW9ScWljaXFURzN5Qk1jQWtzb3ZhWCtldzBSd2luT21UWFlvSjMwcUp5eE05R21lWVVVL1dHYW90NHk0dXVKbjM1R1dRRU8wY21BMW93aDUxV0RLSkZwa05lSyt3MDJFaE9Jd3lDNmx5T0R6MVlLd1JWblZVd24wU1E4QmxOcTdFRWFncDVOajFuaWpPTDQzdlhqT1llcVhMQWFsandBUWxmejFtekxLK2pYUnoxanozZ29IYzdnZThQMm9IKytrekg5Q0dOdEZLbzJLWDlPQTRrUm10dzV5b3Q5SGY1WVE4a0NqckFER1NXUVhkc005Q2EyTVlnQUgxUk1tNnR5RmFrb0xpNTFMUHpwVTFNL2VnREZ4WThseW90SXBrTFJUaG1CemtLUmw4YTZQT01zTk9EZVJxSFFray9pWmQwSm8rMDhXMkdJVitCZHFxcGRVcVhFRSsvcWZ4UWppb202MVZSOUZ6Ull6T3NoMERhZHlxNCs5MER6em00T0FEb0MxVnhPd0JNVUVBNy9LVTkyalpIMGQ4ejNUNWdUV2l0cjhnN2RTOGdxNEJuWnhmTjVRVjlnYzlyY25IV0RNK2ZzczBEQmNvQU5KSld0TTE5WENuOEhZVjE3R2pTNUI1N0FQR0hydmE5U3N3Qm9MWkFtR2FmR1lJMzRrNjYwRForMGtNRlZENDQyOTBWSW1IbExNQjZzcTRXeEY5OUNSd2xjYXNReEYrYy9QMmZFZ3FmdWhaZTRseS9MbjBxL2VldXdySnNoZTU5eUdrbGNCMCtmYzdJeU9lWXRpdSt1cklheENzb2k5VWRsR0tVUjlBVVpFOXhFSWkrSEFYUG5kYUNkOVN3QTlQQkxQUGtDaEtGU1RPSHlrR2ZqSjBnTThNNGpQd3gwcHBxSGdSV3BCemRTdUJ0c0kyb2hudWZRV0dTS1hMVTZlWlJCY1FHU2xMZEVHcXcvQjRCMlBHT1c1Z1h4QlVzNjdSTnZweXJOZVpIRm5KWE9mdVRjQWpyUjlLU1VLbDQ1UEdDbDQzMXYzZ2dYeXAySGV3b0tHamhFY1B5cWdLckZhS3ZLbzRDeHJxazJWQlowd2E2VWRGZVpVcHpWUElERHJkRHhTSVEwQTE4OUkyWi8rQ3VlUVlQTjM2NkdUYS9iTzJWcVJqL3hOMFJONndyNkpGMFNrRUVNc3JKdHJqZ0FUNG9xQjVmaFZiSGI2bDRpekx5Mk9MUVFpb3VyRDFYanVJWWFPQjdWTkNPN1FNanYwL0lWRzJOa2hteitUTkdmQllFQWg3OVp2K3FQRlIrdHNWZC9qRlZSVWtQb2RNUUg2Qld0MHBTaTFYZm12d1FDZ01hek01SHpjWDFlZlA2TFc4UmVNSTI1ZnBhVUh1TzZvRkhIcGlXTDVoeXpyVE1zY2EwdUxZb3l5MHJvMDRCZlQ4ejZDTFRRU3RaUkxwVS81SUlueVhma1NIaVRaUDNETVZiWGdXUjAvRlVYdmFqZVlWWEljcGFucDk4YXBwbDVTRlhqM3NNS2lvdS9nUTg4NlF5Szk0dFJVU2Z3NTdDcVZEOUp5eUhWNjhHcnhFbmdvVENLeDc4SXd4K2hhY3dDNmZIUEpIdFdGZTNIVlZQTjYvM2hadFg4OVN6YWQzbmJ2bHV2UGsrRm9MV0pGVGVnbHZYeHpMWjNIZ01QV0l6K1djWXpoZHZFRm8vSFhYZHpGaVowYy93Y0wvbnRSTTdVcXRJQnJaamhqSGl4V21maklqcmhRenAvcFprUk5BSTYwYy9UaUtRbmFzQTZmUFl3WWhEUnVMdGp2TzZpWlBCcVlGT3NGTnloYVVROTJyajdQUnU0MktyUTd4TURPUENKQjkwSUkzMEt6Q1VwSFhpSy81WVExRzNWb2lFSncvbGhCM0NMaEdZU2xtZkh5SjFXNFFqdDFQaEJlMXdDdUs1VjA1eDNCcmd0Z3pWMVJvcGRLcm9FY1JhT3JZOWZSZVl5Tnc3L1ZBeHIvRmxqRG11SjgrVXlqYVoyeW1SWGFDd083WXJqRzZvM0dMQnVnZUw5U3VVRGxEZExVNTZxRFduS1ZnVUU0V1dPbU82VGpzbXJqeUdMOGQyRTQ4RjdFeko4K2dIMEx1SFZkSkRvVWdUNWMrejNzVnBoRE05dmxsSVBTclEvSUtROTZ3eWd2dUdEd1NLbStkdGpkeXJoMkozS256dUZBaE40QjQ5bTk3RE92V1UwMGw4MzVDK0JLZUxDeTB3TExiZFBQeEhXcUp1MjlBU2s3NitBaldZRFpydnZ2Mm11WDgvYjE3ODhKNEZEUllGYU9rS1BOL2ZQdkE2MUlROWJ6algvU0lUUWpOalMwT2Y3UmFEMFRYS2diTzB3TGtIYnVHdmd1b3grSUZ2QlhtK0JCbVVnbGRNaTZtaFYvNFYvNFFna2FuNFRaNDdydTdDeHlvT3RSK2hlTlF5R2F5N3ZZMTA4Nm5NVXBFSXkybWtRWHprVDkwVUR1U3VMb3FEc01yeWk1VS84bWFjZEU1cnRsYS9mUzRjYkxQOTFZMDc0aFZWeHAvSzc0UDRWT2ptN2VZeHZXRFd0Y3AwODNWaFZYd1hacFg1MlBVVWJyZWNleG9yRk4zckdXc2RDMkgvRjZ5SVYwd0NlVTBIbjhPUVYxQm1tUGE3M1hYRGgwOFFkamNzR3ZBcG5QRWhBUVRnY01ab0RBUFBXVG5UL3hCTXpNanBlM05hVXlvNUhmWUtsOHkrNXBVV2ZSM3dOd0ZSY0NrYXZBNDRiQTMyZjdjUnhXeVpsc3prdlR2eWhXOER6V09IUng0NkR0ZDVNQVF0UWhqVDV5YWY5UkE0aVVzV3lqZzYrdk9ac2taU3luT2VlaWdJaFhMTU5Db0VFNmJ5NExpSDIvZGt3MEtpVFhkOGR2MysvaUcrTWVoVVZwejE3eHhRcEdBSlByeSswbUloanFFb3FUdW1YV29NL2xlUWZrNHpseWdyclpBTlU2UVZWdFZBNFkrcEQ2dXN3Z1N5RzN0VkJyRXlpTVUyWmFVTmt5M2E3MjUzdEMyd3RJb1o4UStlVTBZYklmT0JsVmY5WVh2Z1MyL2JBN1RzSDJqbmR3a3hxK0pUYlJzT0tQVGpJNXMxUGlVYzUyNFQ4ZE5nYTJBUGVCMXB4a29nV2hSYWVXcXB4eElOS0FlL3dBLytwSEc0eU1ENGZFYmwwTXpWWitrN2YyQzFsUTJpK3RWV1dFOEhmS0dYbDgrYTMvLzZ0ODJzZjlWOC80ZVh6UjNueS9kUVpBdVU3WnUzYjFrcFpKVVNQOXFJNldILzdpVkdQMXRNenUwdjJnTVB1SkJqSFY4UzVCWHhrMTk4ZDdaQ0tCSGFVd0xuMVVIdE1WQ0Y1VkxWSk0vNVhDSDZHRnl5WSswUCtVRitWbWxsTHZNVS9OaTBUSnErV0duWTVmTXVUTzlCSmZnOHk3YkFLbE9rcTB5VC96dlJmN2ZiTGgzK1hwVU96MmZmOHAxTmw4OFZIbDdvdlg4RFF5RW9hMWQvdEJCZ3ltdTZBeUxqWlVWb0dDVVJzdG1acjgyTW1yUEw1MHloZHBTN1E5aHVKU05XaHhZQ0kvT01GUnJLNzJCK1Z4R2RmamxOc0NNR09tZkp1MGVoaFQrR2t6UzFpT3pvN0h5WkluMElFc05PUzZzb0ZVNk5qcVlsMDlCNU9La0JUeWxnOWZDVlVJUHY2SG5DNWdpL2xDblRtZnVGRkh3TzIwTVFnN0Y4bllSODlyMldvQXNNK28vbUtLWjdYc3A5KytPcjV1N2RUVE8vdWVIakQ3enV3cTUzSU1QNFdCRXdua2NHRTBrZEtIT09mdWxqZGFibHFITFFDWXRPY04rVG95NVRHalE1U0RPS005MTVZSm85UjNqOTVOVUNIMDU4eGZwdTBWeGZYVFhubk9DS1BZT09VRGlsdlphcXJhSk5LSTZSbGhOdEV2RjlEeG9UdHliUElxeFBsQmlDSlJYMStYalZGek5GdWVtWTN6TUZubUlwaHpKakVJaXZIVGwxSmE4dmttOFdEaklJQ2JSeU1jT1RPL3lTOHlhMlMvU2JTL3ByUmp1QkZGTmlqRkg2MnpwcEk5UE9DVnNlbkFLcjNQMTZrcDhHYy9YVjZiTnVoaTFiUUlhOSsyYUdNLzJmZi8rUHpmbjRzdm0zZi9zdnpRMGZXbFhydlh6TDV0VHpUWFArbk0zdVRMM1BHUnpRNDB3WlVleWJCL0xvbm9mdTBFVnlHRkt3SFRUaEJTTkFYK1VhZ3czbDArOUZFZWl2K0tzc2tuZlNraW5Gb2lDcXRBSmVsQWNPN2JTOGVSeUlLMmhaUzlkZ00rcUZVRUZmKzd4NHRHdTVXVTZyTVAyN0xuTGtRUHFJTzlaeVdFNXFPNmUvS2xkNHhkMzdsaWtGSzQ2WlQwK2lRUG5aS0s3b1RQaVpIMGlZUjl3K0Zxd3o2elZ2dHEyZXpaOXhDZU5ZM2tvcUhPK0xkcFlQL215emlJYzQyU081b01QOVJ4RDZXSndnb3B3QTJqRDg0VVhUL09KWHYyN096c2ZOM2U0TlBoZ3NwajZNeGRSdE9MbmppaUlMMDV0QytqNGdZaDhzN3U5dWFKQytpWE0rZFBBTXhrSk53TXpMVzNZaU1hVkV2Y1JJNlNmTktRRVIweUt3QTF6aTFSTFF3dEJ2cE1MYXh5cWlvMkNyc0ZDTWRxYU1vMGxkRFhLRU10aGhIMmg0cDBQZzdRN3YzcGFYZWxHdVN4VHdBZ2V3SFhweGh0OERaKzRGMXRPRSt6NCtudmc0S003eWVOZElwa01vUGIvOTltN2V2SDc5cW5uL2lyMVhkNXgzZGZlQVpmVU9TK3RkdkVmb2F6SDZXVmFVZ2Ezam5iOVFLSnIzS0ExdENnODJuSEx2U3Blbkt1ZzdpbzJmWUtQeXV1ZTBoSWRiVG9LNFh6WnpmRFVxR2wxaHpFcWJFWmFTSDQ5MVQ5b0VINVFiUmJWbTRrWG8wQ25VUVI5b1pmV0E1WXZuNlcvVW1zVTJwbzlVYkZxUVUraThkQkVBUENSRVgyc0o0UnZ3UWpFa0N5R0lGNHFwWDB0WVg5cUFyL0Z3VWhsT2NGNWF4b2NYaHdQQ1pMQkVzK1Y0bTFCTURFWm5DTmZhSGVUUTNBK3ora0ZVQldUQTFJMDdYbVMyNzN3djFUMWdDcHg3Mk83WkxNb3FxZ3M0RGJ2NzRZc1IyMnArOGQxellDMmJmLzhmV09MclFYT0RSZmY5ajB6bFI2L1J6Uk1HeUl0bWNxWFBFU1ptdThOQlV3NGFxRVNjN3NyYStXdnZ4WmY2NVNaNXB5eng4QzA1WUxSQzR5Q29zSlVpS01FclpSTjhKOC9Sbi9LUk9zbGZCZS8xWHhsYzZER3I2SVJTYStzbzNxMHlEc3llRkxJSGo4Qkg1UVB3ZmZ2QkR2T0hnVUJQQVEyWVd2N2NSc1VaRjF0Rm9rNDUwRno4bzV3cjJZQkRhVEJVdHZmaFd5UFBhYkN0RmFyZEpWTzIvMmo5U2NXZmhrN3hTTFR2ZzY3d1hWZHBHWmZUNmc3aFRzQ2QwcWlTNHpOeDBjS01HZmJIejV2di8vczdOdW14SFdBbUFWbEczakY2WWxacGlmakZadDhBOXoyMC9sQ25POGVFb0Z6bVMvd09Hd1I2K1VlVXlqa2djYjVpMVZ3OCtZNWxiRWJuSmVlSXI5TGYwa2RSMk9FMmNJai93WmVzdGRZYzVaR2dVR0Jwd2ZFWWJBRnlOaDZvRWpJNnRUcWZUck54eHF2TVNuSEp1T0xnblBmQUJzTVhQM3pmdk9Pa2hjdXZMcHV6QzFaQ2g5U0RmMmVMTlJFSEdPQ0lIMDh1RUhvWUFFYXhvOTNwdjF5OGErNWUzSURGR1h1QkdEMlpKbTFIZmo5UVgxWk9GYVJLTkNha0FZekJ4dzJWSTNCekpIUmE2S2hyYS96RlNONCtpK1U5TDAvZjM2T3dsajMySUsyYk8xWWF0UVRSYWRIUm5tUjZqNU4vUEVHNVNBY1V1N0JuckR6NmtWU1BjdFpiaDM0SnF4VTFCN2tRRm45WUlNZ0NCdzNxSHlFdkNrdHJVS3NqaFRDVm0zSFNOMWQwcFRyS0RnWHBBSE5neTRrS3diRjd5V2ZMWEwwejk1WWpkVHhMZm95eWN0bzloajh1OERGZGdBMWs1YjFBWUZCUCtnOGRtYlBPWE0zVFQ4Y0w1Y0NLL1ZZb2N4Y0IxbGkzZDlCREh2bnEyNitiQlYvTy91RXZmK1kwQ1k2azRZejhIMTY4UkJuNzJ2VzIrUlY4ZVAzdE9WWS95aGhoMTJKZFVXZUpIZFZScC9TV3lpcHZsREo0RzdvQzhZRXdaWEw4TFNVbGIzbHY4TjcrODJkY0NYUWt0bitNeXp3cUN4UzJDMGpVWDROck4rLy83TDN3aS8vRjdXUEJlR2NNNHV0OXQrMGZ5Mjljd2ZWcUtGcklrWEJUeFAyZjhHZjQ3b0dPWGFKRUhJM1VJNHlTdHplT2dwNlh4SWpHdmg4Wlc1ZkpHUy9UWDE2Tk1kK2ZOK2ZUcDJqdzN6YnYzcjNIekhjazA1bU96d2ZuNlBYNVY5eWZOZStaUWkwWFdqNVlNNWp4bmlrbG95a2tUcVYwMk9ZVUVTWlhvelBLcXd4UVNXRWhxQWdrbkQ4WndpRHh5OFQydnZ3TlNXRHo2aFJmNGJSOTJjd3VVVHE4T3FQVGU0N1Ywa2NSTExDb3BqTkVqTG9QTGl3Zy9HT1VxQjh2SGNIOGI5NHNtZVorU3h1Zk5IOTQ5LytnVktsREp6UlROazhQamUvMFVhOGltNTJwa2dlTzJnYmNwUlZZeC9SVkM4Y3REeXBvclE5MTFocGxmL3Yrdm5uMTlyWjVjNHNZUnJ0UUdPQW9STnVFV3h6TFZwOVowc0xqVnM0d0xaemFqYkZVVkZ3ZS8rTldCOWM4M0V2bmZyQXh1T3JJbFQ2K0VHd2JJUjM0YU5VSzJ3MjdXRjFPM1JDcFpGSXNPbURyd0paMmZtbG54VkV3MHR1UGFleXdudTdpZGI4dGxpZUtsU2FPZlYyR1B2ZWJoaW9NS21xZVVmWUNmaG1BUXg3emt0TnRMVDFoNVhsYzlBTTcrRU4zNDA3QWJtUmFqRUlBVi9lZVNjZlp4VVh6eTEvOXBybDkvWnBYbC9pd0I0NzdkemQzemRtTEg4UFM4cTNENXlpdThSVU44bnVJTkV3T1RWZENDVjVFUkwzMlJoMFlTV3dHQlpvN2FWMUM3NzJoK3h5QzMxRUs1cEZtUWQrMnZHWGtEZU1maGZ4UlNWaEwxbVBaYmgzU3BLdE1xdDY2VnQ0cVY4L0NLN3dxN1dOMVZGekpqYzkvVFRpMk1mSC9YTmxIL0lLd2xGSHh0YlI3VERzQjhxbjRrMndmUEE0ZmJqbkdCYWFibmJOdGdSZE5QV0xFbDFWN3ZiTllEVnZCL0JQOFBpTytNQXo3Tmk5ZTRaTmdTdlQwK21semVmNmI1bXVjb3RzcEx3SnZYNkM0M2lJSENNTWVwelViTGMvTytMb0tlNHJjOGY2d2VNdUl5YXBiclBMWkZxYWFDSy83dmhUcWVJOExCcmFOS29oUUtIQjJMVGVMZFhRd0RCakNUVWFaeExqc2ZNZUJVbUM3NWh0V29QekE2SGJqMUxPSEFuc2RBdm5reVZNc0lxWmJiR2JjVXZhZTAwUHZibjZNMTA1NldsRk1jNjltNDJaNTg4YWVDbC9jRW1zSGZVNzdYT0Z5N05UL2hDOEdTZkdjcGlWVEh1WWYrSFRTK2V4cUdQb25sRmgreEZRQjBScllOdS9lUHpSdjN0MDJ0MHdGMTFpa0E1UlBiRWlsM1c2ZlVHd1U1QlZXenB5VldHWlh6Zk52bnVMRXhrRkxYNkNTK2FjUVltRmgxb3pZNytTVXpnK2hybGUwbno1eW82cStRZTBtN1N0ZlRoNmlhVlJJTGxxNEFWZkZwUVdTZmtOOWZQakQ2Qk10RkdrZkcxaFJKZzhzQXR3RDk5MzlISnc1REJCWXpyenZVVEJ6RHp6RW1oZ3dqUVpkcHROZllTWGFWcmRuZUNhOVZqWk9lNVNiVTYrb0QwRjFPczdLQXNvUTl3SDBIRSt3ZWxHME53eHdqb3puN0lWNzh1eXJabm1QVXFMdjNQODFucHlGRmJlNmVkc3NlUkY2eEpzU1BmeUZRMC9LcFQrN1FkMmpNTmo2c09ibzUxSUU1Z3VaZ25lNkF1TjlDYWw4SlUvNU0xNUZaRnpsNzE2RmE1cWg0dXRlWldrb1JWYjVDaGZ6VzZmWHgra1UrVTIzak1HMHV2ZTVjQkpXd2F0OGxSZXlSaHNycittZkM0V1RWK0VZaEorM243ZXd1amlDOVdjVlZyWTU2L2tjYnQzMDRXKytmbzVRdTlmR09TOE9aeVJUNWhyZ0ovQzBoZ2MrQmpxL1ErRXd2VHU3R0RSUG4zN1ZYTUwwRDd3WS9QN3RueG5sbjhEOEtDTEVXR2VxayswVnlrbW45clBudkZMQktMZ0Z6Z3dHMVFrZlg5OGhyMmMrT1EzMHk4RytSN1pqNzVGTHdlNXpXaUtvdnZxeHdWbXZOV2FuaGlNVjZ1bjM4cjRVbVFTMlkrcHEvZTVSdW1JYStEN2U5SjgwZi9yRGo2eFMzVFgvL0MrL2E1NWRYT0hvbmVFY2grRVJ0R2Rmd2RUZllFMHcvYmpqNkJnMkN1QnM5L1JMWDlnV3J1VFgvOEpxR0ZOQ0pzUFFTd3NtUjJjL1ZxcGw0QXFlNzFPNlpPMFVXcXNLektDMVUxZCtLTFFGYzlFSHJCSVZvSDZkTGRzTFBNYm13SUJ4Z0hheHo4cjZFRUlNcUtDRnh3M1RNYmxvUWI5b251aWJpUTBjdGgwRmc0N2doSWhMWU5CL2xGTXg5WVd0NVFSUDhJaXlVRUV4ZFlNMnlvSU1GZ3lwQWlTRDA5QndLcVB5UExwWkMzdk80c3NEQ3VXV0xRZTMwUElCMzVLZk9uUGc4b0RCbS9mODNtMVEraDRqemZUUXVTZ0g3dzJIYVBjQnloKzYyUmVlOUxHTXZyUXVyRTRISk9Mc00vL2RjSzZZQ3lCek51b3VYVTFrS253dVhWQkU4b1NXdUExNXhrTEVoUU1rTytTWCtGRFBjRnVFV21vVmhveHRtOXdhRUk3dzFDUEI3MTNoVm1FSnIrTEVJNk5VSE1mNGlEejU4NmdVcEgzTGR5WGdueExDaXE5NkNtUTlpNGQwY1hEOVhCQ1crYXZPeitYL1c5SzdkVkJkeU1EbjRGUWJ6UWY3eE9ENi93ZWV3OWY0Qy9TSFgxeU1tZTVONHhBMVQvNWNJcFQzQ08rVDFZeDM1V2FZOGd2MngveUFrL2hOOHkxTTgvVXpwb1dYV0M3dkY4MFByS0w5OFUvL25VMm5mMEtZT0pxRlhkSlBuMTAxLy9JdnYyK2VQMlY2ZGNrZXI1aUdNR1ZCZU4wajVCSytBOUNRZlVjalJrK25VYjZ1bzFOL05vUGhZZUFWSzFWNXRHNU9GVU5Kb0FRVU1KV1l5bFZDK1o2Zis1NTBBcmtTNFNtcGZzTnZDaDcvN1ErY1g4VWl3RC8vL2w4d0RyQndYcjlvNXV5MnZoMitZOVZwMGx3OWU4cHEyVGtXSkMvbkRxN0JBVUUvOEpMekhNV0pJdkZzcWJudnY3RkJGSlVVSTRjK21vRjd2c0FCcm8xalB2U2RxVndOdm9ZVXZoeHdjMXFuSG5jcXFpWGdsRmdMYUlTQ3VOVnN3Ni9qY1RTb0pHQUZTVUxONmY4WW9IQXV6eTlRc0NpQllCei9vS3hwMjBRSEZuNUJQeUlCeE5nM05hUWpKL3FlVU5yam1BNHE4RmhnMUlucWlEMWIzcXUwUEtvWmxhWGNocCtzNXo2MHNMNThSckVnRk1zbDF1Y2NSY1ZIUEpaK2MzREhPNFBrZDlIa3UxLytZL1B1NWN2bTVZOU1iZC8rMzgyR0FlR2Nla2YvOEJWVFRnWVZlRXJmV3JQSGdxUjFLa0dWdVh2YnREUzFtT3lyK1p4cEgrWGVvN1NpQkRUWmJlNmJ2a2Y2UUJKeG5iTWQ0b2J2UHQ2eEFQTGtpa1Vlck0wRnVQbGVZWTlGaGpnNkJpRVJub29xQmplMXNvb29MRDZWUDUxQWtGK2tyYWQycWpDNmd1YTlRdWF2MHFMUTQ1OHNFM3dYdU5IbkRoMFMwZEJlUXYxNUh6ZVJrdlhDSzRiSzcxWGp3S3VEQlUxdHkzUUtab240NngveitoTkhRMDJGNDZIN3A4WGxFYWxDcnMxVGNMcEY2cjRVY2RKQ1FOYVpxWkxVa00rUGxRVCsxZUI4YTRQK1JoNmliUzZaZmlZY0lSMHpaczNIWisrRy8vVy8vaHVyWnIzbW10TWVmL25MYjV2OUpZN29HZThMV2hsSzRJSTlXWHMrTFhXR28vTUNKdUlOTTBiN1VmUG1KaTJkeWV4cDgrMXZuamJmL09wM1RDbmZobldpaFhTQi8ranlLZE91MGJMNXkrdi94bDZiYVV3SkxvRS9nWEVsaHFjN1BNQ2M4eVVqck1LTG9EZ2E5emp5aG1xYnEydStvTEtlWU1seGRqcGJKemFzSERsZENjV0VXSS94bmJqUzUxUm1qTkRqYjQ1OVhoN0x1MEdCT01Mdk5zUG10Ly80SGRPS1ZmUDIvUXQ4UnB3R1FCM1R5VlZ6dWNLWGhiRHN6dDBrcWZYQ1gzRFlZRjBjRUlZWlF2ekFxcFpiUGZyczNOWnFXRE5sZE9LMjVhWGVzS3hnTkJ3M1lYVjVScGd2dmc1Um1MNFV2bVBaVCtIY2dwdFdxR2JUQk12Szl6WmRaWnl0R1F4WXNsK2gwV1JXSmdmUUJYQmdQa2F4UEx0bXdZQzJERkVrT3E3ZElEcnduQ2d3TUc3TTFNcVh5T05iZ2VUWFg2UXk5RHdxR2NVcG1OTmZ2NS9JT0tGNkNpV2x6MnBxZi9qa3RnV3NLbGR0dFZwdEY1TTVwdndzQ0tnb21LcUo2d2FmazV0UzZhaW85OGMvczNjUEFaeGNYT0tZNnpWLytCOC9Odi93NUEvTjlkbWhlY0tpelppRmpCbFRRanRsZElETytNSkc0SEoxOFRWMTNHSzkwMmRZdVgxZVV1OEI5MzcxUHM3SWY4WmdlTURpMzdEVnd4TnVZeThmeXVlT2xjWDNLS3h2TjgrYVM2ei95ZVY1ODlCekY3d3pBbUJBTjZkVk1jVUNUUVhLWVE0QzBKNjhobENRb0VWcWtENmx5RExHY3FtVWZLNXBqa0o2QVA5OElaLzZIQ3hpV0hFSXl5QVZIZEppNFlTSzlMK3FqS1JSelZwVWdsMWxhRnJJQVhsVnNzSTBMcFJYUExld2RSemFWOFJWL3JUT0hPRlNFVWVEZ1JQQitxTzh6NVNUT0MybTNUcHRhd1hoMWk5aEM4TnlHZXBlZWxXK1N2TWFVOW8yUXZKYXZ6TW9xTjNHZnZwaUR1WGxvNkh0cTBvYm5zTnZiOTQ0ZXVHanVIbG92djdtYTZaOVRPVVFoajFiRmxac3Bqem5YUzUzL0NpUStwek8yWHMxZVhJVkNIbU15UzNUUTNkdlMranB4VmM0NStsR3BsTk9pcTZaZ3AxeGN1UVdocHV6R25UN2tyd0lzVVR4WGJHcjUrUG0rc216R0MyWFdGN2JQVDR5QlljUmNNQTA3QktmMCt6c09jcHczN3gvNXhHN2VJQ0JIU3VOc2lTdDFRUjFwYzhwbFh6VWgxQU9zRE5XK2E3WlF6YnN6WnNIZkIvcnhSMzd3bkJvbzFCNVFDd3ZPYnFFYVJLS1NRdmpncjFEOXpldmdtbXVyaTVRbE85WVZIalRNaXJiRHZEYjZOQmZzeEhWYVo3djNEa1ZkcXVHVEtuQ2NET3BTc2hwek9PbnhWQXUrb2djajY5b3MvdllsdmgxL09BQ1J6UEk1clFWQnRkWEF6NFR6Sk1yQm9mblR5L3hBeEhQNmgvNkJEeXd6UEE5ZWVxQ1V6eDlWK2JYZW5FVlRZR1NDZDJKci9NOHRpbEFMNWxISzFSR013OElneXZDcmhJU0s1UmRXRVBBazg4dnoxbjVReUVzYWROYlA1SDI1Z0dMRWNWM3dJY0ZQNkNDNllmc3crdVptL1FHdkJPNGE3Ny84NC9OcjcrNTV2QS9wcWU4NnRWbmsvSFFuZjVoM1ZBVDliaEFNS0dmSDlZUE9POFpvRkErK3V1MGl0ZHZtUTZDQ29Zak1Pbi9zMm1zVUY3UW1RNE90MWhaRC9EUVZ6RDN1WnRKMmJ2bFVvL2RyM0xRK2YycEVNb0RudE1QV0tHVVZRbGpWNEM5cjJjVjFyRllEaW93SVdCUVUrQjVJbE1GUHNyWDFOdklVb0FGdXhSREZWQ1pHRkxaVk96ZjcxcnRsUjdpVnZoVi9OOFBrMC9YTlB6WGYvMlB6Y3VYN0xkQ2lieEZRUC80L1EvTm05ZTNuUFgwak5Valh4OVlzVWVMcVFZamZYejBBY25aNENUWHFlN214bWRQY1pCZXp5ajd0dm5EOSs5d0tEOHdsWml6YS9rR2dXbkNqL1dQdi9rbEl6WjV2LzB1bElITzFaY3ZYalIvL1BjZkVENnNNYWFqejc2Nlp2cUZXb1JZOFJrcmZCaXdvV09PL2xsR1ZiWmFYS0pzRUhTRlplRjdiaWlHN1Zhcmo5RUIvdGtQVlhqNGNUd2xBRGhUUE5aZmY2M0Z4RGNFbWRKZXNnVHZ5dFp3TU1XeGU0YjFNa09BbUtad0hoaHpOQXdnRk5MMmRmUFZOK2ZOQWYvTkQzLytVeW9wbEp1N3lQV3o2S2lYclZRektrcWY0M2hrbnZYWDVPaVQxazBQUVI3RCtCNUk1d2drQTh4NG1YZkhKNjBVd0I3V0g2akdJT0RIVE4xVzRNa0dNeFRXSmRZSDltbmp1OEJ1U0hWN1FweFN3V2ZzZTB4dGEwRHkzUGF6R1lmZFVVOEtJSU1HN2ZRbFkwZ0F2VkJ1enEwUU1GK2JRak9qR0ZHQ0FMQ01TajVHUXZ4enZqU3VBblNhSWM2Ly9NWFQ1dnVYcjltN2hsSng3eFR0ajlVZkZMTzYxdVY3M3pYVTcvajFFM1o0NHNQVDc5bWcwQTk4NUdMcHlpVldsUzg5eHd2ajVIUFdQT1QxaVEyRHg4Wmpib2h6czZ5OHBaL3ZIcXR1eXJUeEFRdkx2V1V1U015WlRsK3lkODZWMkZ0V0RPZThFblVHQXZyM1ZrejdWVUVsWENsb0VjR2ZZekJlRlpNTERmUWRHaWp6SGdVekZYclpUTEppOXRrUkNuY0FNVDREREpBNjVvTXNQZ2hmQmFTU1V1Q3R5L3RTU3FXMHFxRHBYZXZINTc5bnFQckZ5L1o1N2VMNjk4VGw1K29hL3NOM3YyVTA5V09nNitZWmZxbTNMTGQvLy8vK3FYbjdldDZjalIrQ2FXN2ZTM0JIY0N3RlJuZ3RwK2xzaGlYMkZPdm9TZk9VMzNNc3JyUHpyNWxHTUJLeXlmTE42NWVNOURBZFFueHpzMmhlL2ZnV1JUR0kvSjVrOE0wdi9nay8xNithTmN2Y1M1ajN4Nyt3QldMMWhucVlVcUZvemxtWnZFU3duMzExMVZ4ZG5WRWp3b0wwRGxpdDFCSzZlSUlGd0libnc1NGxmYzZwOGhXZy9lNDlVek9uYXZqSDRLUURBdkFNdjl6RHdFOXgrV0szcnhDeGx3ZDhYU1hiOTI5d0tOOHlvck9meTNQRHFjT1RHVWI5TTZZa0ttdjliRTRzNUVxdk1LSHpDYXdVSndQWnljUWl3R1BhNUdGM0hsSTNRS0dZcGdMUTM5VGo5U2NWbGhhV1o0b1JFMVBiQWRQY0JhdHdmbEVvRkJiVE9SWEdETUc4WUFZNVphcUVlaU0vWmNBN1hzL0Iyc0pZQTU3dk9xSWdRK0d3T09HR1Vjb3ZGemxsVVRINEl2WUJIOUlZYTZ4ZWNvWVBRNUdwNExYUW5IYVJEZXRIaDdoWGFJeEY2R0ZZdjNoK3lhc3ozOFJlTVZkUEQydXNHSzNKMXBLSkJSVVVydlZjc0IzaHUrK2VNWUE5aThFTjZsS25ORFMvNTN1aGNGVGEwRmlhdXFDeFduUHFLRk10Q0VwOVdtRDZ5S0F0aXUrQUJldEtiRmlKOUluODZUWVJYNXR5MFlLdUJWK21ua3h0R2Jmb2Z5MzgwaDZxcG8rSDZCY2Fxc1ZsT0xXeVRDK0JyWFQ5YUdYMXBDQ3JUS2pMUGhaM2dqV3FFdlVmeHBzSkhXVlhTa0Q4aEIvNWFXZE5HWDJ1ZVBPWXYxdEdmTFN1emVPdjBtTWFKajhTS3M1N1kvdzV1RWl6Y0YzWTErMkFhaDVEMVcrZFhVdlF0QS9yU1lWcmZMY2VueXNjYVUrTXpDV2puWVJQbFQzSjlyT1B1R3kyemVVMXpsMlV3dlBuejVoQ2VYamFSZlBpeGV2bXozOThoZks1bzM3M05pSEltRXgrVkdIQUNEbGxhdlgyMWR0d1NqOS8vaHhMNXB0bXpKNG5wekRQbjdHemV1d0tvQ00xUWp4QlFReHcwckpuNndXT1drMTNsWTYrSlBSRytKT3VycDdCZERMbVBYWHlSWnIzZDFnNGYyN08vdnl5dVhvNlpxcDYyWHoxTlphRXhHQ3Rib0tqZk1xSm43RWFoNURkbzJpWEtEK25ISmRuN0FOakJON0VDaVRNemI2clpvVGpIQ3RpZXNuTHdLeUlMbmE4YXVOck5reFArbTVFUkxDY2xsMnltZFFOaWUvZU1VM0dTdFJIRnI0TEdOUzZCaWdGREkxUTVNR3FLQmRYUjlQSm5kTXJHU3grS0ptUUxDd010eFBJMVFOZ1Q1emZRVCtuVnpOT1JkaTcxVU4vRFlwd3lPOEtlay9KcitLYk9FMGt2LzN2UGlyZi9XUXJmd3djNFhSM2FzZ1VVYVV3cGUxaGxaRFhLYUFLYmNmS2t3ckFxV2Z4a0ZOQWxhbnRWVWxwdmJtVFBueFVVQmYxajlKR2NiSnQ0SGUvK3BhWHZQbE81QmtER0h2cWJtUFhmL29jUjVTWDZaM2FmL1BzdXZuOVAvMmFIZXZYMEpBZXd2S3ozSUdwdXRhVjdiZDkrc3hzbzFZZHNzMHplN29ZU0h3ZHpLOC9iN1FnVVdiMm4yNkJNZjVPUFl4THJLd2J0b00wdi82TzhqamRXWms4YjZkaktoMkZRYUZUMEtTOWpkV0NyR0I2aGJBb2dYMGFTcUFzcndDV0lNZnFhU2lMNkVLS3FRNElnbWh2MjB2UzMvcE5GZ2Z1dTNWSHdpZitCTjV0V3BhMUFuNzRQZ3Nua3d0dURNcHQvci9sWXZ1Nml1bExZRmgzMWQ5VlVsM2NZOWlRSUQ4bDhaZFU4Yk41aHZQbEM1aVJYZTFvMzRzNGYyZ1dqSCtCYzl3dklmL3dGMTVLeGIrMXV1VUREUGd6SGxqaTl0dDhtdkFla1h2SnlQcnl4YXZtcStldm14bStxOHNuK0ZuMHV5aGtyS1N0TU8yMzh3T3JpaythYjU5L2hlWEFPMzR3bUF5M1pCL1AzZjFyZm5jUVRzV2x3bVBMUGVXdXJyOXBycDkrRFVQRDFUaFhYNzlpQ29oUWZ2MzFGY0tLNE14dllOQjdsQ2hLajVka243SDZ2NTAvUnlIZ3EvRUhNNSt4MUEvWE5lODVRZk1ycURnK2N4ckpEdXJkSFZiREt4UW1XeGZZVk9TQmVoUDJSRDI5ZW80ZXVlUXJMcXgrM3J3SFR4UUp3dVVXQXprek43bmFQcitFZ3lEaWtLYkx3UkZCNFovdDhreXdJVk1vdHhSb1M4V1JNZ2hIdUlrUVVvd0dZS3FRMEJRb2Z2MVRHQ0swMFpGVllXTXcwT3B4K3NhMDBkZFNkRHc3V0l5eE92Y01NT3JzV0d5Z29Dc3hJM0RVNW5QTFNDZ3ZMVVlzajRCSE5VdG83V2djdTk0aHRNcHhDRXdYR0xURW5DSTZCZlRqRXc0SXVnSmo4eWVXMFBNbkY4MS8rS2ZmTkUrZXI1dHY4VlA5NVljZkdIU1l3dUZDVURuNk1ZcW4xOCtiZi8wUHYydCsvY3ZuRENwK3NJUDNCam50b1k4UzlNZ2k2ZGhuK3RhSEoxRHQ4QlUvTE1JbGViVFkzVHF6WkFwNVlESEgzZm9nQ3g0dUlrQXZMQzJudUNydk8vYUJ2ZUoxcVYvLzduY1NqUHd3RFgyam9vb0RDOG1mZ2lNOUlKTC9nVlZDYVM4YTZJYm9yL1lwOG5odkdkc3ZETXY0TTZSem5xcENEOG9IT3RreWYrU2hqZ3dxWXkxSjYxQkpwNkl4cldDMUdUOTZ5WG9EYmNxQ0RmMlRDaUtWWHVIbHRlNWJGRDhDVDV6cWwrMDR6VlJ0bEg3Vzh5V2g2ajdObjNnbWpJRDdKY0QraGp6RE4zZmZON01OUHAwemxJTXJVYXc2WFQvRjlKNndmRHlCVWRtU2NNTm1SNDlUdWIxamZ4VStvdlhxS2h6d1dsbTVuOG9WbkQveTZ6Y3YvbUtIdStmSFRaUysxc1AyZ3VsZGZPTDlpdk9QUEJaWVFycjZkWW4vYUlOWGZMMDVad1VQSmNKTzZsZHYzemR2c2NROEdjRVZzQXVXOVZXa00xWUhCc0NURzU0OG1lTEk5eUM5MXlpTmV3UVA1a0FRenM1K2kvQSt3ZkJBU3Zkc1RIVDFqVFpkTjZ3c1BXRjFpcVg1ZXl6R3Y3ejhkOEF3RGVhMUU0OEx2ajc3VlhNK2VOYjBGbWNvci9QbURuL2NBb0hVUW5GS3RpYWZRb2NSQmd4R1g5aGRoYkZWUWVBVFFrL1JYamN4VWkrWTVPZlJZQ3FVZ1lwaWh5Q0t0MEtWZkFFRHdXbGFFanFkRDB5SG5Gd29NUHFQNG9vUyt2K1lPL01mU1pMck1FZFZaWjE5MzkxejdjNXk3NE1VZHlsYWh5MUlCZ1hiZ2d6RGdBRURCZ3o0WC9QdmxnRWZzQ1haTUdES0VIaElXRklyN25MdnVhZDcrajdycnZMM3ZlaWNhWEpKYVNrUmhIS211cXF5TWlNalhyejd2WGdoMDdPOFNnVm1WV0J1dWhEWkxkNHRHK05pWlNzdjZOT2JzajFiQVhPdWFvb2FPYU5PUHl5STN6R3hJRExkU3ZiZlF6K1pPVzZtRG1qRzFyd0E3U3VXRkdtYU1tOVRHSmlIYStSa0tPdG90L1VXZmt1dVc4V1BPTTg1dFZQVEcrYm0yK201amV2cHBlYzMwOFlxMmpUS0xLb1NtZm1XZ0VHTFpIenRKdjFDZ01oZjZwanc1aytaOE9veUthdDFuR0hHQXMzVXhhbFBrQkdCZ3pZdkE5VjNaN1VKbGxFMTNRMmEvSzRERmxPNzluSVJuOVpvZ2tZTmZ0U0pTaHBva01HcEFkTXg1b2Z2WE5mQkp4aExaR2hYelVwaU1za2ptMVA2c2RUT0dML2NpQ1BLQmZHeFpBaW15MWhrMHQvVktBd2NhSjZYeEc2QlF5WXpYdDRqTWdnOTBKNC9qczluTW5VZ1EyejJ5cm1RQ0hHUHo4bXc1dUxBcGVEQm5DdVp5QlJZMmxlZjUzR1ZVWEE2Tk5INElmN2thempMZFpsVzhyT2ZhWGw1bUY1M2lXdnhlTFZKOFRZejY2dlBLSi9yMkVxTnJEeEg1MFZyaHdtVjhPZXlqelFVYlpYWFhXMnY3S3M0WHA2UExrQURQL3NvNFpOL0xUVFhodVBINlpDRnZlUHBBUkdpNndCckJYTmdMbFV3N2RwSTlaUGpXUmhXbDN3YkI5YUNVZVM2NXpxaUUxVUNqSldaYlNCMXVBT3hKVk9PWUVEajBVa2drdEw4WUxlQjlGMkFlV25DNklkYWhEZ3d6elJISU16bEpkSXBpQXAxTUUxWE41WnBnNEo1NGF0ZzdSMGEyS05IaHpDQWNWcGJYVTViRzZ1WWlPYU5VWXNlaERwRDJ4b1RLaTlhSHhOWmV3N3p6TkE1ZllXSnlUd2EzQWZLUUlnZFVqTVcwc2JtQ2xuYnQ5TE8wUVB5ZVZqVFJ3SWtXWno0Vk16UnZzQi9keFNKa3dKVkRXYUtwaU95dVN6SFJFYTFpeDVtclJudGZSaUdDS0syNFpIbkRHUUE4L1NyQ0c2TDEzRTMveFR0dHVNTHhnU3hoQitLNVRZbE1vVHpYUE1iVTZzWllYLzZUU011Wk0wUkxobWZtaGpNTEdBSEV6RHBpU0ZPMGZocWpCWFd3QkpOTlNDWUhiQ2RvTG4ybWI4eW9kSk9HZGh3MlZGc0pncUN4ZElpd3VmV3lKSllhakFsS3ptZ002QlI1dlNES3RGVlN4YlBzWUxCTWp2dVlibkV2RzB0YjZUbFJWSXdYR05JR2tQa2dmSGNKb201TlpoNEhSaGRFQ1RwTTUrTzNmbFhtM2FPcGdSQVpKek9sa1FlQ1o5Y0UwbTdNTmFwNVpOUlN3Y0VEbFpKODlCc1BUbzZTTStiZTBjZnB3aWt2QjZWZHdabWxkUW91Y0o5TWoyMTNuQTkwQmNKeE85Uk1VTEdBc1dyUVV0eFBrK2lOUTBrKzM1a2NGeWphaXhoTXZjNWZ3dTQrTjEvektGVlR1ZzFyNWhhY0VJQkJyTjBuREg3OFZNOGd4WTV3eUJsUU5IZFowUWI5L09ySnJhUlpzMVFOZkZnckpkTmZPRk54TGo2aktjWDBHZWVYaDRsWXlpLzUvZnNJdkMzWjB6eko2L3dXLzQ5TXp3L1gzMkZOdjdGVzU1ZTh6Tisram1uZnQ0NHZuaDUwWml1NE5TZUE5OVpFOGgyU29jbmQzRzI0K3VwYjNLMVdoSm0zcHltQTVOVHNINlFESEFkM0VPMElwbVlrNlp2eDIyeFhMYmk2dXBBZU82RFhtRjJNQzJpaWc4Zkh1RFEzdzJKYkU3U1RNZXlJN3pQc1RhT0VINEw4OUxLQnRXS0RuTzBoenFSSVpoZ3ZaZ0hRZERDQm9zODd5eW1aMFNVOEhpUDhpL0haRVRQd1B3NjE2aWNvSWIySUFoM3B1VXltZlZBbUNHbXhvQUtGR3A2OUl3WFdnVit0ZVhGcjlDWGEwaHBwRHZPNzFQV1R6NSsrSUNBdzRmNHdrNFloMW5yK01oWVNEMUI4N0NtdDQ3aFFIS0V1TkUvelRzbk1CQVVBaEhzb3E3bWRSQ0N0aFZIS2ExRmRLLzE4TnFtMmt4OHMyMUpnUE1ncW81NWF5V0Z4TTRYQkJMN0JKbWtHa3lZbkRESktvUm1DZ0RUQXpuUURNeEJIMUdGenVIK0lWS25sc2wzbm0zRVRjYm8vT2hidEZLQ2ZjMFJTS0FERTR4TmRXbkp6UGNxSm1zNDVablRNYmx4Y0NBWS9BaDR6eUJnRnVoeW40QU5xd2JjZHhDWXVQdDBWamdnRnAzb1BGY2ZWREJZbnVtOHU1WXcwZzlvenFpbFM0QThURmRSZTlFVXZSd3k3WnRrekpwV2swMTVIM1JobnJnZ2pGS3JLYzkwbHNBdDFpWVNxSkFKT01mQjNXMFFYSXJvbytZK2xvQ01NMHB4dzhRMGhjZmdFQ0NoMzRRSE1QRkNHUEJkclZHNCsxSUUrVzdlbWlzeHhBUDdTTGVZSjJBVFdxTlg1U09pcnN5UkRCUFdUVjlrR280bVpvWjM2TU9INHJJby9XTE9SWG1JU3pMNy9FNzdsLzBvTlpYeXVtZnZBREdlOGV4TVBJOTJ2c3poYzhwbk1KeWZlM2lOMTNxVTkwUWZmODVqL0syODNudCtmdi85OVJjN2lqRnJ2WWExSmZ3alppZ2JXajdGOUdNcFMvV1VTVm1qaHdCZmFvQ1JtTm93SUpGelBHSWhNWlBTeEd4VWk3QkRuZllpbjEyT29kL0JHbGRNazRTazN3SnJwSCsraUtuM2hFSnRlNXhqbVUrblIxb0U2eEdKS2piSjFXbDJTREVncTl6dDJLUFVETTlVSGRmeFd1QVRhMkttcUZhRE5qeUxTSm5FeW0vOVUvS2ZDTG5QTDNiUzB1d05mR01raUo3dElGWFAwUlpYZUorQkVac0tBVEZoampicmk1UkowZHhncVJCcjFqUUozUHR1WVdZOXpiYkprU0xDZUV3L1QvY1B5SGwwcTNjUUdtWms2WSs4TGcwQTg5eXNwdWRGMFk0L0pvVUpkR3paREFEaElhS1FRdnd1by9Cdzh2M3NlNmxOZUsrb2Jadjg1NzQ4eWVVOU1qbmI5Ujc5ZXhMRGlMRTA0QklvVzhHQWJKdGVvVDNndEViekVIYjZycGdkRzQ3KytSd1JLWjRYaE9Kbm4rV2RtZUQ5YmdBQmFpUm9BUlBCeWUrOHp4RlFZWmE0MkpBSHoyYXVUSkVBakNUWXd0enB0RDQwR1k0RkJUVnpaYXBHQm4ybWZaZUpxNEhVTUFmdGc3Z3poT21aeStkWUxiOWNDK2FoR2VSNE5ZSFJWdFRFZ0lFYjNGWW5XYXUyUGxsdERxMk50QmdhaFpHNE5sRlRFRk1Udk9NV2N0Mk1DZ052MmpLU2FCK0VwV01VbnZyeTZveXRvdWtLNDVjQkU3dWtMeG1uN1JOTjhSdENnTXg4RjZITENNTnNacHdEQWdGR3Baa0J4bUt3UUNHV2NVRkJvRnRERjBqV2xHU09DbVROVDdVbyswRkhBR2o1Ymw2ZjhDM25PcDkzZnZJMXRsKytQT2RuTlQrUC9ObjJhWU14MjNKNWxOZm1lNlZMTkwzTHR2d3Q0MW5HaGZJM0dXbDVqZTM0MlNOd2tIZmJMODk1L3VweDliNmZQbi8xKzVmNS9OUFBLQ0tFek9TT3lmckdvY1FFTHVOb1hXS3g4alpMY1g0WXlBSjVnNXNrQXc3eDhZQVVsRDJBQ1pIdkJGWW9QZDBlS2s4WWdBQitScWpxTEh0aFRqQXBrWTVvTUxYbEJyNm5HY3pLblhDNG4rR3Zja09IaXpOQytFanBWb2VzYXZLelFFOFlES2tOK0M5Y3FsTlE3WFNtNCtZRnJFbWs5TWdZaHFwemRuNW1HZk5rRmp5eklnSVJxU09yTEN6anpJYWNHbGxMNjNhZmdGeUcyZWNCdE51dXMrN3Rna1JRSE96VktnWG0rQzVTejlET0JRaG5JR0JobmxJMG1IdGorbXlKRjZ5emVFM2M5b3c1eSthQUdrZ21PTTBFaVJDS0J3YjBIaUxVWjZTMnFMa2xNdnUzQkx4bW1aTU9HY2R6OHFSeGhRZ1UvMEFHZlV5Z3hOV0pGN0hVVEVTb1FGSGc3dlU2M0kwNmlyZjhCTE9DZ0pnaWVGRGtTTVZ1U0xSZDNpc2lac0kxTWdrVDRhVlpreU9RT3NNVkNoNXFSL1RTNmNZdlpnVlVhNk8xOEVtWlptRnFnbHVHdVFOMnhiNmd4VFF4MjJUUWFtcjBMTFFSMHlBOEpDU2Y4WFJNWUx3MTdDOTRIUndlWGhLbEF4QmFFcWx3UWxPRitXWm9jUjU4dThBVUhmWVhXTXQ2bWhva2trNW1DQmloZ2JtaXdhaWt2Z216OWExWjVuWmpwb2trNW5vQ296ZWgxN3I4dVhDak9YeFc3aUJ4R1ZOemxoUWFHYWJsc0dNZVJkN0x1UW9Ua3ptVG53aHo2OE1GNFFLZk1Wbiswa0dVcktiZkxqVFhZVTdQeWZEbmVtQ3JvOEYwRGwwakRvODdlSlpRenNJcjQ0YVZOcmlmTVR2WHZueUd2OG5jZkplUmVmaGJQb1RWNVd4SmVPSk0zSlA3ZW5sUjNPdjl1YjA4QjJYYjVUVXhNanQzNWNqOXVuTGk2c2ZvdzA5ZWYvWG5xNS8veG5hdVh2Z2xQaGZickFOY1pNTG1NSzNDd1N0NmtPR3V4cFNxcGhnY1lHcnQ0UU9oM01jQXg2OCtMTXhDbmI5S2UxZmNoM1NEZ0hQbU5JZ05sYnRDMy9WcWJmd3dNK1JPMVVEQXRzdHkwS3k2M1FiSU9wdE9EbkZtWTdLZEhIWXhIWW40a2ZtTWo1WGxMTm1aTFpPb0k1VXVxRzlpZmxDQ0dVMXh6SkxtbFk2YjUyU0RyN0I4Wlluc2NUTHBTUTNZZndJVHhHODJPdys1UUZnaTJqa0lIZ3VCaVZJaDhFRUlFY0dJbmpzUE14d0FqNndFVkJOU0dRNGpNZEZka3ZYbG1FUGt6c1RXTjVjcGk1UmdXeUJvU0NVK094bnhHVGdZTmJUVWNZRWZ6LzBDUmZCWUZLMDJBL0tMYUs0L3pBajN6TkZienBQbmpTN3BIQVpWbzEwUlN5WWpvNU5ZTkNVMGp5SmRBWUpUSUxTSW1rSzFNWC91NG4xTzlGWFhTdmlsWUNZaWZQalRMcEUrL0N4QlJHb2lhSjVLVXhpNmhPVTZVdmNrVEVRakM1aFFacDFxdEVUcjFQSWdhRVFWc01HNUQ4eE1WekJpckhZUVJlWG9lNWlBL0NaT201S2d1ZVdZNGhBRzlFT2lqZ3EzbExMUlRCeWdXZE0wREJKU1Z6dFIwNmJOaGxuRHdGNHp1U256NFg0WHFxdEJtcFl4aEtPU2g4K2NzSHlIeWlBamFveTVpVWFmbEpvT3pGZnRzWXNXMzFqb1JJcElVUkNjaU9rWTRnczdqSVhYN2wxd2pwYk9TR0FLUGwvR0s4UGxNNjlnbmp4TFJxYUxKRy9FZ1NERFRWRHVscFJ4QU56aWQ1ZWY2YU56ZFlDTWlpa0l2R0hxT0poYnREbDlac0pCTFRrL0V5WnIvVGh3angvOHozT3o5cFA3a0psWXhwMkFKQmZ3WHBxZDBpRk1TN3loOC9HOHk2dmlUVHdxR1ZZV0Jwa1pQcnRHaHNlOS84Q1A0cjMzM2tPcm1DVmRZQ055cVRZMldOU01yNkU2SWNSZldhTEc5Z25JdjVlT0J2dEV6akFWZXc5QjFpT0FlNG8wUVkxMGg1VXExN0hNcGFqaG5BZHdGYlN3QnZWc01laVFvR3hFUUxSUDUyV1RzUG55Q2xHOEtiNEhHTnJpSWd3RzVMTm0xaG1oN2NNai9GMmtUQXlwRWxvck5OZEVHREtmOVVHb1RtT215TGo2RU8vUlpEODlxWjZUdEhxZVZpbEZza3E3VFhLYURJOC91azhBQVVJMG9YV0JMUHdtZ1FIemxKeHMweWJjUTIvRTgwL0p5SThhNHlBM1FoUEg4QWtaOUlmcGdnQkVGK25kNVhzUDMxd1h6Y2FTeWFyeURDOFF6WG5WNUhFTExSRlI0akxZb1BucEVpWVMyb081VFBYaGlMaGNvL1RURkpXQVpVekJvUGpobVFRU0tWRWtZQmdpZmdITUlsckdaNk9Dc1RtRUJBaERINkpaOHFOdUVTSnZNSk93MXVnY0JHNmhRclUwdGFvbzcwT2ZKRzY0Y0M2WERBeVo0c2p3cDJsZzY2QzhubldEd052aWZWRVJFMVBZeGNyMlUzblI1RGRwWVV5dWxCdW02a3VxNjh6bVIwM3JFWnB2SFRlQnBxSW1uVlZYM1FSa3lMUDdVQzBqUmZzRUZzS050QXZOcHg3SnVmcXg3SzlMZktDNE9OUlJOSGZDcEtNZHRXSzF0czRzZ1JzaWh1Zmt5SjJmUENGWm1kUVZmSEZuQW83NXFSTElhVFZaMGdSVG4vYm9BM0EreG0zUUk1b3N3M2NPYXF4b3NGNllCTHhNNmt3VDRLbHQ2UmRUSXpPTlFxZTVoM1BEdEZLK0dpRU4wOVdNTDFpWGFqNWk3TXhOd25Gc0s4ZjFtcTg5SXBOUHFIYzIzOFpOQXBDYmxzREJYNmptVmpkQUFKeE5qamFLS1Z4RG1ERE9PbmpTc0d5T0pjVmgxZ29selU4REVnSkZzempjTCtJTloyVFkwVWNGc0NZZy9Rei9HSUlnZ2dPaGNUbUNQSVlTeHh5V3ZqNFpPWjlpZkhFUm56MkVpWWQ5a3drL3UwLzZ1NXljdU9Jbi81VFhlZmJxNTZ0WENYKzZSK054MGVVVDdjV1hQNHAzdnY1T0lLcm0yQ2VmZkp5ZWtOaDU4OWJOdExGK0xkUmF4VU1US2JCQVZLL0JEcndYTE5qdFVzbmc4WTRsVzBncndKL0ZqaFNZWmpoaFdmdm5HanFsZEsyTGlnM1RNUnFZUnJPMHRjUjFPU05kQUhmSTMrbmd0N0lpUUovOG5qbWFtU1ZFdnJ1N0M3TnBraWNGVWVDUHFaR0hsZk5lOUN1SU1FeTBwaGZBRk1ldExmVms3ekJ0Ym15a2pZMVpzdlZYS1FLM25BNUpUWGhJWlBINGRKS1d5ZDNxc0wyNXB1b0ZnUVZMelpqc09NdVNJL1BLZExMM3FQelo1N3krR0VQSlF4Wms2OUMxWGxZUFpoSHFPRWlocWVIaHBJQlA4UjUrQThaR2x4aWp2b0Q0d0JlUlNrTE15S2wvUndOUjA0QWJTWk5nREx4S00wMGtzYzdWRkJnS0l4K1EwUXBrWVpiVmFFUjBDVXprTWFRdjBXaUdxR0hxLzdPME1pUVpTQytUdHQ2VVJLYUQzd0tBSW8zTWVncGhpRGs1MzRjdWNvM0UwK2NlVlIyMzBzaDJKc2pOYnhNWWM1VkFpSTVtSzBJTVpZcG93RjdqS2dqTitJUnZzQVlqa2dsYW1kUVBZNGdqdHBSblRNNlg1WnpoSzl4R25Td1lxY201c1p1M0krWDVxT0wwUy8rSmF5UTVKYWVrbjE1Ykl3Qmplc1Bjd2pKSnlvMWdXaDBFWjdzd1JZT0tJR1RCRDlGdVpXTFRNVnF1cjRDcGJRRUgvZ1hob3psUDBHU2laUjdYdysvcDBUS1ZCNHRBOTRQd1lJcGlmcHZBYlV6cWhjelRRNDF3bjNXdEI4YzlybWZNNEl5MTM4S2FzQndRTjlhWjYwTnkrU2FVMyttd29Gdkh2K1d1RFY1SnRWV1lkc3h4dE1ndDBCanNJZU00NzI0dUhGRmRmdmU1T3Z2VjJFS1Q0NXpqOHZEZGwrZGxWR0tNMzUzZDhpZ1pTSGtQTFhKTitXdjU3bmd6NnlqZi9jVjcvTzc3bDJWWVpZcy8vVzdyb1FIbXgvejB6MS9xZTdGQUhwUWNkMlZsUFFhdFNhTi9hWC8vUjVHazZmNTYwQUVTYmtiUEJhdnVyYVN3UUQ3T01zdHc3b0hnZXlBQkVoOEVHQVR6c21JQlpUOHFMRFlHNFhxWVZzMDZLbklWSk9POTBaQjVVZUdVM0s4R2FRWXQvRWVOT283dldRa1JEWUEwQzdXdkdhcUJXbzFTaDZYci9WeXNld0h6NlBkWWc0Wm1sTFV2M01BNm1Da0hjLy9SWituaGsyYTYvZnp0V0RMVWdGSGVwTFNOR3g5c2I3UGtaMEpXUG83ajVXWEM3ekFxbHcrTktUdlRKbkVvdGcvRDdOdmJmVUtHL1FsNVFvVFNnVU1mYVdsWkhXZFhoRkNLU2RRaXM0Y0lJaUxwWEkySkJSRytlTWdpbVBCQUphVTdiQWZpc3owUlFTVHdKZE5TSTlJODREUUVsczFxcmtUckFlWVFrZEsyZDM0V0V0MjZVSlowcnNBc2pQWnBqdm43a0g1TDk2Nnp0Slk3M3Nib1l3V0dwVThJaXFGdEdSK3daVjdEZDBVN2tZQUtFV25HeDI0dU5PSVdZdlpOOHlVNkZXU2d6MDRObXZtQmtVZm9Id0owNlVnNGk0RkhIaGRqZGlBd05OR1U0V2NZd3ZBWWVveEJXT25IQ3RqS2pvR25iRm1DOGlXWVhkaWRzOTNSVHNIRkJvTE9aSkZaVm1OZ0dHTHlINmRGMTFLQ25RZG9TRU9FNTFpVG1DYkdVNVpkSVh4Yzg1aWQvVEJ6eml0ZytzeUJ1RzVmaGIyL213UnI1THVNMVBsYmJJZ0w3T1pyYVB6UkwrcVZ3RFI3NEpXRGNzOUhmV0wyV3B6UmJIUVoxQ3phVll2RWF6VlBoYXdKMVA2dUE5L1VrNmRSWHVBcjdvejFKYklYcUxCUjRBbkxxOHR4U2p6eHZOZjc4aWpmaFdIR1RRVGc1VFZ4d2QvaGorUDI5US94S0pTTU1nN0hMMEl2c1JaTW9MaDMzT0VSOVk2Mmp6Q3JXTmpLNzlaMm9oQXVMbmdjMlpWbDF0OXRwbEdEOVh1WWNGSEpBQ0l6VTNrMHhobWFOQm1aVkRlMG1KQXlNWHlZSnVjdEhPVWJPTXl2ODA0RVVvY1Y3VWFPQ3o2SUJudk9MVkpTcGd0VHFsT2FCUHFGMkRTOUFCNUU2ZktoTWRyYUNQWGVld3p4cTgxSkZIc0h4K25KZmplOTk2T1AwTFEyMHNycVNoQ2hHc2o2Mm5NZ3l6aytxaWRvWG5kcHA1VzJycStoWFpBeGoyK3VRVmxuVFZ0OUpGMFdSM2RxK0lLK0FBQkFBRWxFUVZSUGRDUm5oQTZFWVBMTXNoZGhKZlNTWWZsYm5sZ0c0ZnhlenJIblJTRC9xUlY1VFNDY0dNQ2xFb2puc2hUUHY0bHMzcWNHUU13SlFzVlBwRm1qVmlZejBJWkRXRFNOYk5vSUdrajREbUVBNTJnSUZzU1R3VE1GeklVdnEzbnlEb0dFRTlpc2VoM3ErRmFzZHpVbVg4cDhKQmNteHpic0xQNkdYdEVVNW9KaGxkRmZjYUgwZjRYSkFYRm1CejJFenYzNm01d2tHYkhYUlFZOEROWkljWmdwanBVUm1aRHBjMXhrcitic1lkdkN4WEZMNURVV01zTjFHYWNtaS9jSlgwMWp0QTJHM0FPbWxyTXBNSjB1YUdjQzR6eG5LZGNzK3d1NDF2RGVYWFo4d3NkYVl6N1ZUc2RFdG1XK01oM0hMdGg4WmcrZmx0dU9DWE5mc2VtdGkrc0JnSXpMTmFGbFdvbE1yZFVScjVrbnhrTEg2Q3NTd1hsQnVHZ2FtcVFac0dGTXdzQzUxemNGa01Qc2pUbGt2aDJqaDJQem85RldMb3AyUnpDeG1oTEVNN1J2SE1jOUtqMUNZTVI3WnE3Q0xQQ0w1d2c3RDgrSlZ4N2lsc0xQMzhyZnZkNXJyaDVlNTh1anZLNzh2VHovczc3SGI5eVhuNXl2OFA1b0wyYnQ2aS8waDMrL3JLUFFKTk5ma1JQblZDc2RNS1ZmWUE3MXhyVjBTSTN6N1VlYWZsUUZvSXl5M0xzeXROb0F5RDRrNFE5VHNJSlVhNGFVSlhNY0Y2amZpNExhV3ZvSjZHdU5hZ2pFOHBCZVREeFo2UHY3eDZRU2lKdW5SR253WjB5UWtQaTFqQXFxR1VEdVRDTE1FV0xNemttZjY2QmhVdXlieU9aMElJWStKZXJMby83SGpqWHNiWGQrZnArMkQ4aW5la1Q3Vm1Mb3BQdDNZRkNZVHV0VVZ0M2N2SUVKU0VXS0IzZllGUWN6a2dSU3cvVTlhemJwVU9kZHJXV0F0bVVtZHppV21lVHdKL0QwYkZiWUp4R0VkNmdvVHdiT1V4aUdDT08xVm9rUVNjT0JEa0NkV2drNm5Ma2ltTEFUNlJubjFTTTBQYzVQalpJeUIrNnFFc3E5NWhSK29aNFJVVEJkeE5BMzFjV01EU1NFcUNza3ZhcE5XRXVxUnoydkNRUWROYnQ0Zm83Y3dWVFVqR2hMNHEwUUlRVk42WWRJYlYvVTlJYVJFQ29qTFJtVjc5Rlh4cXpHVUZHRFFHTndYa3dKVTdzd3NkUUVYZS9MekUzZkkxRTV4aG5DaUhrMGdCSFZOY3hJaDNrRjB3SVUxakVUcDRMVEJvRTV6eklyK3lOMFdaTE9QVHE2WTVjaXpLTTZLUlUxZkVNOVlOeW1mQkZsT3NCUGFyZWhnVm1hSnlmWnFrVlM5d3hmcW5PVDRZMmpIQk5aVXpOTWFlYXIxSzdPemdnd1VTYko4WmJ6N2VkZ2R2Z3lLekIwTmJPUzZHVUk3ck5aeDIvYmNqa1ozWFpxYlUrR2wrTXptSWI0cHNJYVlJajVHdUFOekwxWGswOG52aEZ4Z3p4V2FnMU5FRzJabndKTzNBVXpmTVlJWlF5bHR2aVVTY2c4QW5aMDRQTHdHcG5VMWZObDM4dHJnc0dJekpkSCtkMzM4aWpQbGQ5OWozUGdzejY5OHJqYUY5Q0svN2t2Y2EwRDUzaldhbm5YTC82T2hrWEpYaVN4RE1LSk5YTWRIT0Z4YUFab1MvTUxlVUsyZHo2bmZNeEhUQ2FMcGJIWFRSNE14S0lYVm53TTZjbzk1c0NZcTRXVGdRa0drVUVnbVUyTHNyZFZxaVpVV0tZeEhKa2x6VHJDZzhlUnp0QWdaY0xzOU9tVTRvQWd1dmxMVmlZVkNQWWtGOGFUaUZUcGVTQnBGVHcxUUdMQnZDYW16QksxbzQ0UDUwZ21QU0dxZUpwMkh6MU10MjQ5bDE2NGVRUE5heS9kdWZzNUNiS1V4S0hNelV0ZmVUUFdMeDRkN0lQQjFzMXkyeTJjN2FRODRLa2xWSS9wQ2VQeGVUSXRIYkk2NVNPdmh2NkZMNE8rS1ZXTkF2cktFdG5JRVhJVFFoRW1JUmxoUU83SldBRXBIWmYrTjAwT0VUNGpScDVZaVNNam1GcVpEQjYrekR6MGdZUGFndkM0Z0xGMGcwa0NlUmhTRGYrTzk0blJSbGJIdE5sRDR4aVJxdUhlaVRydG0vaDBXbWlPNXhDR0M5MlRjNEFHWXJrZXNuMUIvcXpsQm9OQWExTURLaEc3UkhhL0I4R2o0Zm5aYXFvNnlpdHFFOEIvckZhRGxxV0c3bldtU2Npd1JDUTFMVmNzR0UwVGQyTERFdHFSYVFianBDM2JWSHZ4ZnBtZTAyNkFvOHhmMGdrOWhmbFpBZmFJcFRrdnpyK1Faa2lST2NUSDJDWjVkSDVtZzhsQmFDeWppUUVQTjY0WUN4K1cvY2hNWklqT293SkhKdEdIMlhkbTVvTlpPbTgrenpXbTU3UmRFcHJ6bzFEMk1MZHR5cW9PcnhNZlMwMUxCSXhnQTBFSUdkN1pPY0VpeHRMUnJ3akhrakdiTmhIcEhCR2RabHpBUlNadWpweDlVdnVWN3ZTdjZxcVEyVG1udm1KT2dJa3JJc3ArT1NjbEl4TFdwZVlrckd4Ym5CS2U1Zm5vY2U0NHY5TVd2MmU2c3U4eElDOTVlcC8zWHIwbWZ2d0g5TWRkblVLQ3VSZzNJbGNRazRsek1vWW1qSUU0WDJ4QWNmM1dCcE0vU1kvdVBreWYzNzBIazNNYktwYlNvT0hvY0l4TTRpQXVtQlJ3c0V4eUZhQnJkdWlIME5jQ3BVU1dzVHRMTTErMHg3UFNQcEhIZzNURzhxQnFoWFZoYUVwVDFnRU9MUk9EQ2FwMGtUblp4bERDTnhHUHliZk1TMTFUamxRSDB4MGFMUEZZVys1UURybVYyRDBRU1hxYWRoN2R4UkZiaFVIZHhQbCtTc21iL2JSTFVLRkZncWphMTlycXRYUjZzaHZtbmlWVExBNm5pV0dSdmc2bTE0NmJVNFNLcnk1a3VKeS9JZ3o5b1R2ME02T1JTR2VHdE9aMUhjUVp3cFI2N0o2TWV5MDB0aXJFeE04UkJGTm5FRTlFRmtCOCtmS3NqQjd1eVcrRzhIV2dkL0hsNlFQVVhPMVMwZUFFN1pOcU5NQXBMMmNTSmhLNHBaU3JtUFVTMWdWYmNmbXNQbHFpVHY0bTg5b0IzbWVhWXpxeVNkcVVFWGVvN0tEZnE0SUdJSUtHbVFkakExK1oyd3NDRXE3ZHpBZ2VDYUJ3ZHZPdzZEWHppbWJpMkYyVndOZ2w3Z0x0eStpYXZrd0hxQ25sUjlmNDZSZFNXM0llKzBRRlpRUW00MFlwSGhrR3hiajlWY1lmQU9DdkowSkw1WlE0ME1HSFJ4R3R0TC96R0szbDE5QjhXbWtGeHRCamc0eXhRUjZFb29KTE03R0k5dEZXWE5YQUdQek5CRkZOVW5PbUdqQ3lKbUZjbVVSMnNBTW5uT2N1L3FZWEFRL25tb25tcytmc2w1cGhabmkyS1dHSDFud0p2M2xTZ3k1Z1dBcFhmelBITUlTNGFNOVl4SS9NVElTcEt4azA5VE44WlM3Njh0QjNBd2ZFRFgrVG1XcjltTlJxQW5ZV2l2YUg5aTRaaTR6ZCs5M01WN29Jd1FkdGxOcWIxM25JL0ZTSVhMbVE1MXVodzRrcmgrYzlyakt5S3o5LzRXTjUvZFVmU3NZcUQvQUlITThmWTQ0dlAvNmQzNHFqMFR5VkFYQTRVcStvellSMTRQNW1KOE9wVW90ekJWSzVDMExwVUYrZ25NdmNjemN3bytiVDNZZVBlZDFQOXg0L0JER3pQVytVcGtWWVdTUlFKYzBPeXpwT1NzdzR6QmtSWkVCRVVDVFhGK1pHRUFWSm52MytNVDRJa2hDSExEb2ViQWRndXlDWERsaklGUUJLS0FLWGQvMWVPTzFkT3RPRVlmVjZsSU9aY3djZm9wamtlMW50ZEFERE13ZHBpS1I5dkhNWFpqcENzMXBNbSt2TEllM1BXZGQydUlmekd1VHVrTFE2d0lGNlJqVHhDTitWVE1KSTJ4UkdhMlZTZlEyYVplNkdISVlUOE5FNTdFdUV0QnFEbXBibG51Mmg1WTZiU0ZZcktnZGlHalhqSlhQUjBkdUVvYWxKaUlqV1d5OGpUNUc3aEZrbG9wM0RlRnlqZUVhUzR3Qi9oNW4rYm54eERsSmZJSlZkNmlSak1HZG5BbE9YK2JaWmg2bkFrWGxrWk03U2RrZy9yWnpneXUwQnhEV21uNWFvc1h4TkcwSjNVMWVHRzR2UkIvUW5Obi9nWFFWSmhxSHBNa3ZreTRUU0hwRklmVG1tY0RRSlZneUZCYkJ6YXpjRm5CcUQ0ZkxRU0hoWEs3VEFvYWtoc2IwWC9WUEFETkM0QmoyMEw0RXJJNE1CRnNCSHVKc2lZUHFLa1VjUDhWNmtieUU4SzBpNVk0cE5YaHdla0I2RFg1WG45dkg5SE9ORGhYK2lCUVBiRWRwOVVJbE0rZ3ptaUFZT1BzWmlkVDdyc3pONlhhbmhYTWRSYjNwSVNkUTE4SE9FYVUwM2cva3FpTlNHMVI1ZFFZVHNvR245YTVwbENBMnVkOTQ5V3FUS3FLa2JxSW1VQS9JYWN4WThRMlJjcmcyMXZSWVo4N0cwRFZxVGNTczhaQnkrYkRkLzFsUkhWU0NDN2FHdlZRMUtabVJmZmM5bW9mU1pJOFo1RE9ybFp0MnJkRUEzdklRbExmREtITVRWb1g3MldkNVRNbDlPZnVId2Q1blNWUVoyOWZQUFpGaTJ5eU15VkhqM2MvbmxDMC80eFU4VWYvUy83K0FmSUFwQ3RjOVpObExkWEo2Sk1pRzNObGNqa1E5RGhBNUFxaklBbllVd3BRYWJSRHovM0szWVN1dm9qRTBJUUtBOTBnajZFUGd4Q2FCR1VCd1kvNE13alhETndKemFUaXFTdmNPR0R3dXNSVVBPTVNEU0VPcmtmSUY0Rm5RN1BTTzZpSHBlcldDV2dlaE9vRVFkZ0dMa0VuU1B6SFpEeEJOcXJJOEdacjZmOEJ3THZPbG9aMEpSeDYxbzRFUnJlaDVnK3FtOXpPRExVaXQwVW1mWkFjaGRXb3dDbW16cDR0eHp5cGVJR0U2VXl6UU1MZGRnSE9Fd2h0a3dvcjhCd3BtUU5UdVVyanBkSlQ2SnQ0SERXODFNalFjd0JvMnFjY2hzUEJ3amxQeTBiWW5lSFdPR1JGOHZhS3ZPMGhIOUJVZGtkeC9qVytOSGlFSkNBQVlnL1loelhRZ2xEdHJYVkpESVJFWmtMZ3d2UytxcTJoZjNkUEQvTE9JN2JBS25BaGdOelRXamY1cWdIY0x2RW9Qd0ZpSDk1Nkc1TVRMS0pYeGtablJaelZxTkM3VUdtTUZzWVRxK0pFTDlsUUV1Q1ljK1dxdE1mUERHZ0JGdzlSbVpZQ0JhTk9jd3NZR0w4dEs2V2ZuUnZIc2ZKNkhEMUdWUi9aMVA3cWExYTgvUlYxSm1KSHlZcVltdjVuVmhrRWFmWktBajhxM3NONkFJRTF2R1FlRUhtc1hzTG5SOUlLRHNKNGRqdGhLdGFTc3U2bzRhWXZUSmxCcGhNQ1pYVDNob3hncmJNVnFTZVdHeFNURFBqUG5qVFRlSzE3ZlE2SVl1TDJOdTYycEhhSFNoa1FWK09UY3lBb01BV2N2aUZtQkh0QjJHS3I1SC84RzVLRDBPcHhRbkZYSytlM1M3K0lzUll1S0FFZDVzUG1jR0pFTVRyakpxaXh3NjRtZk1FYUYvT2JlQmQveGF2Z2VOOGQxN2JTUG1uekZmUGNwcnJwNzdWWDR1ZHZaTWltUnRZT2dQT0RmeGk4ekNVSjY3c1ptKytlYno2YVhuS0pWc1ZpNFRaNlJNeVc1a1RoOUJrMGxlUm5PSlNOejZPbEpUNGpZU2hHYUFEOGppZitlRTRjMXo2ZU1vTTljcjFtbUJVdTRQdUVybEJlc3R1VFNuanRRdnFyTlJBMTYvV3VOcDdTMmtDOGdvRVR1Um9BRDk4emxFYjhobUw1QzhXQUtrUExESER3N1dXQXJCaE9TbFFtU0NJK2swZDB4dk9LWDRuQ1ZyVEdWd0J4Y0pya0s5cHZOaDF2RE1YUFlaSm9ucW4zSGkxS0o4dGt3Z2lKTy9JbG9jTVptY2hjZ2sxSkNjK0dyY1pNUEltRWlzRmlUVEN1UUJ5bXBtSm5GbXhKTnAyWmh0NXRaRmtzalJFWVBSUmx5T2RIRWlROEloam1ZbDI1Uy9jVlhBMnZmTXZFUldUQkdlRmZ5UFZwV3Q3a2dUVlNFd3dZWm9TRXE4T3UyNklZUWE0QnltVUo5MEVlZk9IWUxPWVN3ekxXcjYwNDhjakJIMlBJOGJoWVBSTlFzRktqVGE1TEpaMThyOUdoMjc0eFUzY3YrY040Z1FNMW1KYStYVnFQMGZ1TUhDZGF4Si9ZUmhlZ25aSUZJbGVoWlFBZHFBQzk5cHgrM1UzSmhFVGZXelQrNms1MTk2TlQwL2o3QkRlNWZacXZsNFRTd2ZRdU0wWTk0MWhIa3hNMzFISUdwYTVYWnhlZkM3Y0Rkd0k2aWRhNHpDZUQ3TjhMdE16VDZTMXc4VE00SFdSZEFqVm5tbzFlZ1dHT0RYbW93UG1WTndFek1UVHdMWHFrMWxjN3RPWXJWbXQzTnRHU0VERkFZSFpIS1JpMGNQWkFjUlhHQnNyaHF3UkZFSUhQcGphUjgzeDNXZUZGTEJNQysxTFBGUzE0T0N3L1BpanlXRXhtaTVZN1JHditQaGlOKzBkSHg1dm1SRS9tNi92TmV4Ky8wcTQ3SVBnWXRjazJFRHJ2SXd6OFdMbmdOVmV2K3JQWXAvK3dkZlpWTHdrVUFNWnBCcmNwd2hTWThwMnZjbjMvNHcvWENsbGQ3NTZzMjB4bzdQb0FTZEpYZkYwTGFFeHN0cHprUUFWMGREVTRVMktqS2tuRzRERE52WVhFWlZSK0p6bmNRa3AzZE5sd2grenBLYmszMDJoa0FhdFZpVzA2YkcwZndDazQya2ErTzA1Mkw4TGlBYVdvSStEd2xpQU5GVmNYS2lZRVYvM0xxcnpjUktIQU1pUUdZcUYvZ0g5RGM0QVF3SGtxWTZKUnFrazdLM3U4ZG55K2FRRDlaRHE2UlNSUTB6OHZHRFJ5R3hJaDlKSnlqcS9RbkxlcFNtRVpFRVVVTE5GdS9wVVV3MGsrbVVLVGxwbXQrVmpDQTFZOVBCTEh5VS9FckpOdjRka1l0dXhtRmZNa0xrK3lSY0NkMTJOS1BnY3hBZG1nNFMyL1Z2eDJoL0Uvb1FWRVFIWkpCUGtZNGU5WkcyNXNqcHNxY1Q4VzdmOG5wR2tVMXpoV1FUR0tEK1N2MUZTbmVUU2NkUUdxdzE5Zmh1ZnBlbVpkNVF3L0E2eitRUXVXTzluTFlSa0JjS3ppTS94SGMxRkIzcVJ2Uk1TL0FhdCtFYW9pMDdNSm5XbVBudjR1ZnBjOTg1UlIzUDBBcjFIU3JnVExVd1lnYnJZMXppa0ZvbVJBZytoYm1KLzZyRkl2bU56VFVZd2pROWVmaUFKVEJzZUVFdCtRSCtPN1VybVhxQmt4MU1RMVB2SVlpWUQ5clVoOFViOEFhb3poZzRvNEIwYnMzNWsvRG9QdDlkbWlPZXRFaU9Sb3RISzJJTGxrdjh0akFoVVVkTVFSRWc1Z2xtYkE2Z0ZUKzBEUFVsNm9xd1hmMSt1a0NjWTJFakxyb0xWYVJFOEJ6OWQ4TFU4ZmxienYxeVRtVUt3dCsrMm1kZmFsTGlYL2FoeWNGbHhFMXdTempsNjJRa1Q3RXJ6b2tmR2M5a3BBYVB3Qk1WUytlZlo1ZWFXTXd0QVBJOThGcVk4Y3I5a3NGbXBnVXd3Z1NPNndSQ1FDNGVCUnh5Zi8yV283dTVYL25YWDk3ZjRpdExyR2dIRVBvNmRIVk1pMW44SEhNUTlCTHBBWVAwdzcvK1VmclRQL3ZydEVrbHlWZHZMNmMxdEtFQ0g0Y0tzVDUyaVhFS2t0cTlDamsvdEJLZHQ4S0QwZDRoaUNiUnVRWU41WWJKUjQxbUZ4NVZWU2RkNWljd1hlbHZMdGYyWXhJNk9UZXpRSmxsSnRXS2t6ckR4MGd1VlhEblo0RHFISFhIZVMvSWhPOWczbHk3dG9IYW5kSlJkeGVnR2lsRHNwUHNPcUxhYUpmckt1eWNNOC9DWnFOVk8yVHBWNnNIa1NtK1ROL242STg1WFVFa2RFcGU3SVJKU0dLckUyUmxDQ2ZJZWtuOFRIdlFvZlRLRjRsQ1ptWnlvSXVlallvMVlTNk5ndDJ6NllmWHRsSFBUWm1JUWNmODJSNk1CTVNNS0NTSW5yVTA1c0xmYVJPN2x2RzZxemFTSEphaWVBRG5nWVZJRFFMejdJQWhsNDlsRmpCcGtWYWsweHl1eWtDQmoxVXEzRWxJUDVRUnZpSHI1bzQxVTlnd3BFa0RIYlFHdCtRS3N3OUcySWZKdU5nWkhwdVBwOTJXSUhqQi9JTFlaWkswSXlQVHI2V2dVZ09LREc2dVViUHVzdW1wd2tPaDVzdDVzUzZXNi92Y3dFSVR5TGJxYURyQzBRMDJOQWM1RlpwbytBdkZUK2NRM055NnRwTFcwY3dKdm9GM09MblpUZnlDbkRQWGpib2czVExZNTJoL1EvclJKZk0rYXRRRGQzMVp6Q3o5enc1c2t6YzFwNE5CU0x5UlVXK0U5eVR3VDRZd3c0TG9VaHRpcExnTWdDbUQwSFRWUDNSS1ZIR00yWmtEQ3F5SERFYzdjTVp0NG5wQ280V21iZWpNMStMb2l3djB3S1JidFdIenVCU1E5QjV0VUdIUGZJbHJNQ0lGZThrOHhCOUdHL0QxazRmUGRPNkZ0MGRtVHBscFpDYUY5UUVPbHErUythaUppbmZsSVk3N20wZDVyWDN3YzVqSnZOdWVqTldqdk5hKzBjRTQ5NnY4UTA3bUxzaENPSlZuTjlDRlZkMlZBbk9zMDF2L3luSzZjZjNOOU41bit5UmtmcDd1UGJpZlhuM3VlbnBqQ3o4VWlPcENYcU5pRW83M1RDQ3VoQVlHcFlRRzVtcC8xOEJKNGtwUXJVN0lNeE1XQUhmQWRYTzBVSjNOMHA1bllhckhpYjZhczZQSXFUSi81NEl0dm5wVVR4Z1FJak1TTnlYU05RSFJ6VldDYmVMTGFLYjkzYU4wNDlZVzdjTXcwYWdNNFE5NkVHRWlhZ2x5RzZtU0tibStVTWJ3WkdlWFo1eWpTWjdoakY4TDVES1lvTm5nNG1qcnJHc0NoMk1kWWxSRGtYaGtDRDVWWkZIeWcxN3h6d2xVb3VvUGMzbUhNQkhwZE5hcm9lbU1yZEtSaHVQbUNDVEFzV3BiSWtobVF0bW40VDA5N3NtbWdSb08xNERjdUx3Wkc4Ky9iQk9TRG0xSUFxS0wwVDh1NHo3OEx2UlhoMnN0dEJYN2dXWnJ4UWswcUpENE1MekgrMGVwQ2RPNXVaZ1JOQWRKRkNUY3l6Z2xxQ0FIL3poWEVKOGZSZks2WTJUT3JmSGV4Tnh4amFaYUJRNHJmc2RrNXpmOWVBcEJxMkJFQkJTZ21PK21PVyswVHVTM2tLRG1rUXplZDhGVHZuZ2tqNFZRSVJiNXQ4RUNreXRYbGlqeXVMWUlWS2hqandsVmdVRllLWGRJVzBZOXhjVUZwTmNNVG5qSElQUFJGUkVJR08zbjhkbEhDVkhocExrbmRNTnBEbk4zL0hYYUxNMmhLZTRDNTFOR3c0T2R3RlNuOGkyMkF2aWJ0UjlOWFAyM29XM0F2Tlg0TDlEMEdnMlpaZFoyMU5yb0RacW5LeWtjVzlhbWNzUTU0NEw0RUxBQkFES09CdlFSa1dnQW8zWmtuend2RHBySVRHZDRaWnlLZCtBY0RBYlk2WVBURE0yd1ZOaGNDbURhOFZ4c0RJS0FpTUFSSjhUandNMXdoZVJyWmVvTzJtZkdQUXB2WVpELytPRlhkaFNQZDdjQmlHdXVNb0dwUWVqbjBXbmRZZEpXTU5PKytWb2pQYi8xY3ZyNDA3UDAwWTkzS1RFOFNqZldHbW1KUW5sTExLbkJ1QU9iWUZhWE9BSExvekdRbCtpakpXOUR4WitBVkF6TFNKUzhxNEtFTTBwa0tXSW5TSWFXZ1lFMlFwRzJEaEZKSTFUd0paaFRBNlpGMmdFTHBIV0k2aXlOZXVRQ0Y2UUx4elBhelYzU0xSYVdNRzlCQnJVV2E3dGIwcmxpSkFYaU1kZEtwRjlaVWFOYVRwL2ZleERCZ2w3L2dFMFVWbG1ucGluTDVQSlBhUmdtQ3YwM1I4MXFEUUpwd2tUTHVFUzBXQUxCeEtwbEVWWUV3WTBXRWZrRW9UelZoZm5WUVNoM1o3WTl0L2h5a21Vb0lyK09hdUV1Z2x2bVJjUVFjVjAwTE5PVVNPbDJtTXg5VTloMXZ0bzI5MXJHSnJRRG9CcU9XeGlTaDlvTW5ZbDJ1UXpXelhPNHRrWitIWVVNdUorNWFWQVhIOWhJWUF2TTBRYUNZb0pVeDZobndTNlJYbnhBMW44YVlFSVlEWk9CbU54bzdwWGxYblJEV3duVU5aOXUwMlUwZFFTQnl0QzhGbFdIMzNGY096Y1FTMFJzc1hFalI0OCtUUnczR3ZpSTdicHFjTFFaVmptMHdBR1gyWTNSc0tMOEQ2a2N0bFVEaGxPMEpwT0k1NmtXMndiSUMyZ3ZLeXgyNy9KTVRjZ0Yxa1VPSVNhZ2pmK2Z0YXpPRjR4emhyazJXMXp6U3EzRk9aUVJOTkRteEJtb2xNN1NaMkFxUEprNHN1aGxVcGp4NEo1YVRKaUZ6S0cxdG9oTjhadkNTMFJuRGpodk5yOXVDT3VsemNMRSs2UjN5SnpiYUZkR0VITStINDV4R1NlNEl5NjRjc04vbW5qMko3UWNScUxReWRwNlp1YW5weVNzOGsrNkVhZE1hNGhYYUcyMHczUGRKMVRHSyt5RHVVb1RJRldGZWNrTXh1ZGtScXN2dUFJVHowL24vS1ZRakNrVCtQUlh4cVhHbTJuUnJIM09BU2NadnVQTm1wMlR5RnpCdUtTQmduYXZIbG9iTkJYM0FhR3JQLzI5UHhkOThsaE9UdHh3SVFOSmd2SFkzdDVoVzNDcUlHeFFCWUZ0VUZabVlUNnZ6NmJyRzUzMDBXZDc2WWVmZmt5UDJYaDFwWjJ1YlZMekcrVEErMFFsVHYwUGwyYWh1b2ZTZ3ZWV1k4NHgzTHpvbElHUHFOQVFhOFJRNDJYWUV5RVVhcWZnWStLNHI0NFdZTlRQM1lGYm1GY0xNL3dHSWVmRVFMVTdBRXQvSlFvbFg1OGEzNjRmbTVBWWVJWVBUdTJyZ0xtTnh6aGhNUTh0eG1jRyt3ek80bm1jL2M5WHI2ZTc5Ky9qU3p0SWg1aXRYTWgvSGQxTUVwUHN4TnR1THNvR2ZQaXV6NlUwVXlDTlFBYjdLdElFSXR0bkpsRnRTOFNIVEVEQ1MyYkgvZDVMcnpOYytDempLNldwekV5L2pacExPTEdCZ3hxQ1dkNEVhK084RGw2bktFdkNBTlhsbjJlSUlTRjRlQ1lDQ0xRN0VaNGdsc21OOW04SmM4ZGxKWDVXZ3Vndms2REMzT0dkVG91VFFaQTZzRU9vUW16MlJhZTBXbU1QNW00L05ldUVsYkJSa0l4Z2hCY0VXd1l3SkpmcWhKbklzME1RSXRnRzFLRHZZbmIydU05OHN3WjlxQk81ZERrU0l3WkxaQzRRdC80ejVtSUtUbW5PemxGR2FHYVdvb3k0SzZva0czc2x5ZjVSMTR5Yzk5UUxOd1BDQ0UxV2s3aWdXcXpWR25TWXF6Rk5aT3A4Tnl2ZndJZHdCelRCMENwRzAraEhWRjZRNE1EbkVGVGlyNWZCK0dRMHVpdkU0eUJjdEhtMU1NMVJ2MHZjZFFJNWZWYUZER0M0Sm9SYWk5OW55OWpVU2kwdFkycEYwQVdmR1NxdGFiWTdwN3pIOCtnemtXVi84VEF2TDdSNTJsSEk5L1FCNjB2VXZNYnhYMnArVEFHYUltTUk0UWNzYWROZ2o1cXYvRm1oYXVrZ0daTC8vRzk1SWhtWWJoYVp2MlBOZ1NDZTduWGdoZGZyMjdOdkhvSHJOR2h4VFRVNWR6cVNJY2NEK1d0ZkFZcVgvdEtQNHRiMWw2bU1jQWlYUjIzbDRUa1NTSGhWZGZhRVVobWpKMndzQU5HZ09UUXBscmFHZzdyelJvZDlCVjlNZi9YQi9mVCtnLzMwMFlOaFdrU2lyR0pYcnZPN2U5UzVHNHorbk1oYllUYUdEWDFsd0l4SkZRbnpOdTdXVk1yUkNJdjVDeWduUGlZZmdLaEpPS040aFFMcDFVeURXSUdGQmRDTWlIaE5NQzZhYmVIamNNMmRTMk40ZEN3enNReU9SS1BHWldLanNGUXpVVkxOVTNybWRuVVRSM3lOWGFVcElnY1J5a3ppbVR3b0pBWEVhcVdBbUVnWnpKV1g1cUxYaENSak1pdHFZUnkyNzZUNk1NODQ1Q2c3RXdRdEU4NlNUS2tlMmhvamxFblp0a1NrUm1EYlFieTBhMS9OdGVxVG90Rkhla011Z1V3bFl2bk1aMGR1NCtsMytpQnpLMVY5NzdIdEVVR1dGWklkbDFpN3FlYmdUallGeUZ2bGk2V0E0dVdZZU1YU0dkb0kwd21HNVlMblBqQTEyUkYraGUrT0xIQUlhUUp5dTYzOWdPK3gwUzFtc0tadWFBQVFEVzYyYk5hak5ac0VyRUU4eFlIdVBwUVRpZ1M2NzJJTDRWU0RxTlRhVkFiMUxha2Q2ZU5hWGxySHQ3bEpoZUdsZERxbzQxUkhTRURNdEVCcURiWDRNVDNkc3MwTlZBeUU2RnpuQ2JUQlIrYVJqd0hqQVJGbFRWSDc1WmlFUjVoWmFwTUtQaGl1OEpKQXkvd3BHWlZDeUhJeGFodEdDS0hqcURxaWtCTS9uSEtqd3U1UUxjeWlORFB0YTJyTE5QcGNVUHI4cXJvWUZDdzhSM3lMbEFkZEtnbzNHSmZQY0s5SmY5ZE40eXFKRUY3QVRmeUsrN2gwYXY4ZEIzME5mS0E1TUFtR2x4bSs4MGRyTVJZWmlXUFZuK2JZeGRzcUNjNzYwZlFiYXZuNGpIQjdNQ0JueUNDS2tmOVkza1MvaEpOd2lWYzhpKzV6TGQxNmVtQXNQLzM4eS81QXRZWjFPbGxuYmQwVGtKQ2xDUkNOblhidk45Y01xdUVZOGo1WE1sTXF3MFcyMVdZdmJTbWh2L284VzNldEUyWitsQTdZeC9BeHp0d0dTWVl6cEVXWVhUM1BEaXNkdktPR3dhdlVpZGNrYWpKZ2Exc0JUeGlPbWxpUU5NZ013c0xrekZjS0I3SFBENVdhM0NnbXpFbVFxZW5ZSFFEa3lEZ0grSnppdkJKZnBCT0M1TURBdU5wVWhxZ1E2VFBQU2hPeFM0WjFyMjlvVncwSnhFRGpxakV1STA3cmEwc1F4SlFDZ0x0UjNjVEpjVU5TRCtHUmtSZEpMOE9Fb1FVeE9KMHdPSC96OEsrZmZYbVBoNUxWbjBPbGhwQkZFc3Z4NXQrNWh2NUtTQVlXOHJvN3ljc3g1bWRtcDNCK1hpeklWYkpDYU5uRXNpMFFKNTdwMHpLajhsNGxvd2dsay9hOHZYdUtoSEpQRHBuOEFoVVBMQS9kb25aVDNacGpFR1NkK1lxSUZKZlZtQy9QUVRHaGJRVlI4M3lqVGZxUGZKYmFrNHcrcW00Q3k0R2JlcERPTWdIUmM4SXZ6OEpja2FsSW9PNDZaUEZCMUIxZ0RwNkJKMVpNMWZUVDdMR0dsQVVUTlpPTlhzcU9ES3Fzc0tScVlYNGh6Uzl2cG5QeXZzN1BxUWpMM0xibjBSN2doTWZrbU4xOWZNcktnRDN3SzdzNHlGZ0p6Y2J4T2cvKzBXUWVrYnlzQzhKbkNDZEhJMkhQRTZsZVFZanBpbWpTRHdXblJDMGNUV2RZeFArNVRJbWJFQ3JBQWZwTnArQzhpY2dHV3RTd2RLa3c4MVN4MWNkSDhpclIzVHJWU0RMVTdRTHdZcXo2cE5TdXJYT3ZGaVF6MUJwUWt6VC9UeVlXeFF5QmlmMFRkK0Nad1REVTBiUFdTcXUyd3c4S0RwZFpPYzVJYjhEakNZVDVMaTFuRjRXNDV2T3RaMVpYU01CbFZGQnl3VXcxVWJWSUlBN0tPSGJuTGZzbHVSWllhWDA1ZGwvaXFSdkltSHdkOS9BOTQxcDBpYzkrNHgrTitmSW82U08rL0IzL0ZOLzV6bmZUMXRZV2dHaWhrVHpCUVhyS0U3RlhnVUN6b000N1pXQUVhQjJUTENaYkprTkZnenFTYkFYZndlSnp6ZlNWdGEzMFpMZWVQdHVlcE0vUXRyWko3cHRoYWM3RG85M0l2N0kyMEZ5VGNyVU1icDVpZ1lhbjlRMG9tWFNhUnRhdzc2NWwwVjhCazJ5NFZSZUVMUEtwYUlrSGFpSE9TQUZoQ0R4UmJVVFV6MDAyWFphaHoyUU1Nek9NUGROWW9yNFZEbm5zZkJkZjkwQitrZWFDcUZXZnBTZURBWm5hdkRSSFpGREwxSmNmNGlEdEVaRlUraHJkODRaeWdrcW51OVBnUkRzSkVyQ3ZQQkZPRktqRkt3aWJ5VFlodHdLeWk1aGxSblE1VDA3eUFDbXFkT3hyQ29sNHRLbDZIeFBNNTJ4NjBnZjZJd0tWYlZ1elNrVFNKK081bno1c1c2YXErZGJsMnNBbExsTHF6NkNwU1hoYjY1dmswRkU3cXUybXVHaXB3S2xPZmJMQ2ZCMjBKNUhSWkZWTFNOczN4NlFQdzdZa0hwbWlDRzF5cjh3UG9FUXh4Z09XUDdtVzAvcGJURkJHYWlTNGMyaFgra1lIQ2FDTXVZOUhCTU5zNDdUWDErVDMwRTdCdnpvK2xmQlFJV2dxMHpiQm56VTA5MlphMjlwSWgyYnRBNU1GMW9aR3YzaTJrZDdYWDl1Z09vVUNBWTFlVFFJWXdSbWl6NXBTd2tvY3J1cHZDLzhoUW9leENDOS9hK1BjWHVRWjVzM0ZPa2RnSnBGbm55TStTRFRRQmlrNFlTcGtneGxtQnRQalg4Zjl6UXhXMEs1ekl6NnFuZW1mc284S1ZBV1FDYkwrYzlhRW83L0prRXdDSFJxd1VLc0VUdlpYSEJUL1dtaXVJRUVNQlV5NHhFbnVoVjRxd0M3OGxqUW9ZMVJybDM2MFFDcG9wWFY4a3JLTG5DYkIzZUFjK2xMZ2xFd3o1OXB4dmNJVFVBVmpSTER3Mk9pVERFNGZuZjMwSllQM2tJR3BCVTdwOEJSVnVEd2Z2NkVoQTlDNDdwZjlwNWhsb3UvZGVZQ1RrTjJmcWVib2NoR2QwNEFubG1KMGNYVFhFVlh3RTVpTVN4WlExNUVjQTZUYk9aVTVXNmpJVFlCeWJhdVQ1bGNhNmRaMWN1TlB5R0tuejEySytKMmZjTjBSenZVTHBDRFJ2NGRFbFl4YW9BakZvQW9tMEMzcHpjTkNwWXRVQ0gwRmRYd0FMWnpsdHQ4Q1VTSzZ3ajBWa2x6ckxLc1FzUVdZaGV0VWw0ZVU2UTA5REdleXU1TGdvZ1JwWmhrTEppRk0wQnBPT2gwRGUvbHJRcXVtWW9ka1UzZnFhU1BwM0FQUFJOUUJEbno5TVRMRnpFQXlFMUZReUNaRlByc1AyMkxzYUpDWW1wcEpYcHUxS2pVR3RaK004R3FWVEhGSWFuTjhMTUNuN1I5RUR3SUVRdEdtbWxZOEQyd1JZVVJXY0pwK1BHTldZeVM1dUNDQlFaZEJCTjRQVDNoNnlGRE41WEczbVE3YWNraEUraVp6bGxtdHI2M2huNXhuejBueTNkaE1WdGU4ekV3R2FjWjhLL3dWMmRUd09SSzFZemVWUWlsY2liMFBFUnlPaXo0SVIwZytDS3hQbE15bFEvcXlqQmFidmhJRXl6aUdoUDBkaithZFBsNGQwRzBZWDV0MkdsdzdJbnFvSmkxRWFoQkpHNGFybTZKT2dHYUdTaUV0Z2lKTlZrc1lOUk5PSnlTOHRyeVhDaDV6ckgwY2NjK1k3L0tvV0VVZ25HaEwrRWpvZVN6QUJuaG01Z2hzWVRKNG43aEhaaU5Cd2tRUjBORm41eG1DdFU3K0dJU1ZXWVU1SnNQUnYwSDdhak9XLzlZSzhQN3c5ekFaVGZCTnB0MFhjQnhhS3R3UkdwLytSTnZQR2w3V2dHUXlROW9wQlZNd016aVhtcFNHZzdzWXlXQThkSmFYcmhiblFBRXQwNUpSZDhuWmN4MW5nekZjb0lXMldpWXRtOHliOGEwRjdCUTB0cVEyYUlGSjhUenk0T2kvWmptdHhYTjR5T1U0YlZ2Y1JEc0ZKcHFRNGJPaVkrSWd2YnVFUzc0TlVjdVp6TmpFMVFCVS91bnYvYmQ0L1pVTmlyNWR3d2V3QjBOaDd6K1lRT0ErSFNUbUVVRHM0OWtjOE9RaDVXVE9LS3luZlN3RGNLbkpHZXB3Qlg5REUvT2lRMHBEd3l4MGhDdFRtWHI0clFvMm54aXk1MStYazZQaEJya3JNaTgxSFRRTFRMTGg2SmlOT29uUXdRaWoraWlaeFZIckc3UGdHT0FNY2RDNkRreENtWnRqcDJrUU41ZnFGZEVFS0pKTWh6SDljL01JcDZJRFFrQitJVDJZUzVBR0VrQWIwWmtlU0FWeVJMUUhTYTNUMHFqU09ZUTJoQUNNYnJtMnNDYWk4ZHlLVVVtUmhRa0FOVUJJbmRQWnZCSGhXa2hTUEFEQnNKeDBHWmJFYUpJZ1Y2SjZaMmVsaEJjVHlUVlRFTVBtd1EySUhOV2RmdGsvODZaQUJhcG1ncFNSamVVWUpTb0lCOHpvQVBNQlNHS3FBQjBOQnFNejE5QzBVYnFzaWZHWm4zdjRJUHN3Y1Uyc0JuMDJ2YVRGQTJkeFJLL1BEdE5DR3o4TFM1dlVBQUFVcXdhb21BR2MyakFUeEZHWWVTNHdkdldBRkM4RGRROUJjSnNESXNXRXJ1akV4WXdmQUo4SnpQYmltR1ZPWkwxcnp1aGZxck9uWllkMEIzT1lldVlvQVM4ZFV4TnFwTFhRa2pXRFJHenJ3YnV4Q05RVFRtSGJiZUYwWGwyeUtxMmx0b25BNGtNZEFEYzF2cWtKb1FpazJvUzZXTXhSbDIzY2F1RGxGTitVUkdhSmFNMytLZXR3SkxUTXdNVVZZY2xqSU83dzI0QW5Nbk9aaGVmdFE1UHl5dDRqNDFCTDg5NndCa2k0SmEyTDMzS0F4L3RrQXY0dTg1UUJSUlRPK1lmNUQyaDd5bEl3YzlyRUNRV1UrS3E1TFQrSWRZOWM0ekdtWStaQkRtQ08wUmNoS09ObDVESTZ2Tm9oQUVzWEFMMEl4bWRtdkhJaHJBMnVrNG5OVUlXaVJVRkRVeTBjcjBHSGdldDB0UmhpWExuYXI3Vy9MSXBwM3h4dmwva0pyWloyQURNb1lWL3BDSEFwMEZwbFFYbWRKMXFwODhpWW5RWEZnYytYZ1dWWU84ZmlCKytPbUU3a2wvUWpOditzUXpqNHNMLzlLTHBNdXJXanRxaE9zTG01U2U3VFk4cTA3SEluQkFZQzZlUTlSVHNDL3lPZlJtZXJ0YW5WS3VUY3FzeVFLUnRKSEVYSFpCeE9uaEpyRmtlOEhGa1RjOEp1TjIydW44VWZNU2Jsb1FmRG1sS1d4RFZ6cXEvY0F2SEk2V1JzUkk5b0Ziemlta1NpSjh6MCtCd2YwMkhheHFrSmZ1ZG5PZUhPQ2dCWGE1R0J3dmRZYmxKTjYrVHF0SEhnRGwwcUFoRlYwQXBEMDNCQ1pDWGM2ek5OWEphWTNSUTJoNGpWQWtqV1JGS1pwYTFVQ1VUak1VNUJPTWVaSUVnTTdZVGxHaUlnMy9YaktJMWw1Q0tzT1VXeEJDZVFsZW5nM1dmS1lMZzg0Qk5aNW1pWU1hRVFDQ09URC9salJraWU2UkJGQy91aHo2Y0ZrV3V5bUYwdDR3VGorRlh6TFhBcnc0UDdqRkFLR3V1dUMrTXFCS01UR0I0Q29jdFltR0VZa1AwUHZ4cEFqVjJXYWRQYSs4NnJoZk80bVdlajZmRjdKUmdmRDJJTjZCUmtWL09yYVY2aFpacjQ2elpjRGs2aXJLSmk2eGZqMW1BUU1uTzFJZGFuSXdhTkxQRURrYmdodmsyZFFhWi9MSERQSWlzUDZ1RGpMSFhLcm0ydHdEVElhMkxjQzJ2WGNkQ2JScUVXUXR1YWZtcmxxbXlPaVFYbUppZHJ2bFU1TjFaSWNjMEZ3c2NqYTBieFVXZ3lqMnF2TWh3RlcvYjlDTWtHeEtZbVl3REZTSEhzb0FTK1Z6blB6NEVMSStEdnZacGZXZnVFbUJtYjlDRFJtbitsWUpTeHUrYlArZVYweklkQ1FIZUwxNm5WU2krYWEwSlZ3U0dqOFRmU3ZtZ2pCMXlFTTdmRU16M25zdzAycVNFSmU5dFRrUHFRSWU0UmMvWmtwdUdEb2wvUkRtMTc2R2V6cnBsbWF3Ky90SnBpQkg2Z09SbVN0R2hLamFra0tnbjYxQnJndGNLWjd0SW1mOVE2cFFjSkF0eHpmTGFiRDhRZFBNS0laNlJ5eUIzb3M4OEpPb3FCZWlYZmJPUVhQSW9mZkRwS3kyejd2a2dWemxrUWJBWFRib0dxbzJjc1FwNWdmbWxidDFrMWZvNlo1SEtUYzBMVmNsUmZUa3lvb3pGb09zVy9uc1NFYW05a2kvbUxUcW1xV3NkbUFxRWtVZys4MG5XQUVwNW1vTXhFRGFhSjlpQUNtZTJzMWtMaklZbG10cGJTWkkyMWlxZ1daeVRiblRGWnJnMHNiWHdMLzRkL2hQNGR3SGhxU09nSEQ4ZGs1eS9DSkdHQXFzamdqOHRrakhoQTYvUU42UjY1SjBDTXlaQVFUSEFjMmhhVGZzRjRyZUFaSWd3RzRydDlsSUZtSk04YndJcW9ZU0lLZkNaU1pKTTRRcU1Eb1oyZmNIWXlhVXJ0OHVDeWZLMlA5M3BQY1B6MEhHWVRJV3R3WEFuY01DZnhPVmxWUXIrYU1NOU1FTGpSUmdRdGFLUnEzaFJqTXRYQ2dudFdpWEJPV2dnbWszR05Bby9OOXVaK0JjUUZpYlZ1OXRIbnM4aVpFUXhuTUhBS3gyMzRwTlMyRUFvd3plTXU2U1BtMmtVTE9lSFMvcGtHRXVWbmFFdWlDQ1lDSTJGa25JZTNRUHlhWXoyMVl1YWtvSnoyTE16Z09vR2FtNlNhTEN6VzArdzZGV21YTjFqNFRTVUlpanZXNTFZcDJNZjZSZnhleHhZbkJJNWo0S2xyd2hwWkJtSmM4WkFkM3NJYnpjSjV3SFMxNm9XZ0RiaG1FSWRnMGtvSUZ3SGpFWStkVThlaWZJM3FJbnhUS3dKYk9BZGNSWnJMdzJ0bEdpR01PZWQzaWRJNTlMUEJHUDJ5Zmk5enVyelZheUl4RlRlR1J3NUU1SHZxRU10RUxrVi9QSXhVeWdERlgvaHV6S1dNM1hseGZNNHRVcEJ4Z3dIUWw4eEdKY0ZOVlp3LzZYTkNjTVJpaHZaVjV6b1BCQWZRU3FIQkhGaUR5cmpQSUlPSnMrNzFLYXFIMmMrN1RNOW8vZ2pOM05RVjhhWWFtZjNDR0UwUzNKZnBob0lDYWpzK1g4NTdlUWg3KzZyZjBKSlE5a0ZjQ0hMNWFXUXZiL29iM292LzkrNkhFSEdDWWRYVDJsSWozVmp2VVBTT1JhVUwxOGh2MlVjUzRtQ25sTXNjaE5MaHdXNGN3Zmg1eVlEd2k4QzVuVGlsaEd2SkduQUdzNUVGdU51Wksya01lVGNjSUFBUkdHb3d3WDFSM1JXUDJ1bjZQQ0tCanNsMlVYVVhKdE9pTGRBaWtNYXlKTzBaSkRRMHN3SlFwaXcybmVEbnNoOEVsK1BlWHA4MVpmUmhSRFJOemNJOG9LTlR0Q1VDQ1pvd1J0cGNMbUVFMUlxZGtWektjd0V6YUFualFVcUE5aUE2bEVVNHZZazZVZ01aWEtQRzhKajhER2lKc2l5MEpteGpvdFJHdVB2Wjl6eDVXYnFLbEx4QUFxbEhSUFllR2E1YmczbUlWTUxUbVhTU3k4UFBTbnl2dHlwbFEzaGlacm51YlFEYzFLeGNraE83TG5NZFhRdDR5Y3A0SW9pRkJrSGY1bGc3R2RMZEcxUkpnQnNLRHRMVE9CdytQUmpXRFBscVJvd0xzTmJjSXBlTHhQbzRHR1BoNWdvNENUUnRKOERNc3RxeHZoTnR0VWR1bSthOHhGUXdaNUZUSjJIWkE1N1RoMEN0RG5vQ2N4bzBnQ1ZiMmxmUmlHYklWN29HMDd5RmoyZ1QzOVFxRzBzc1VuT2ZqQVh1WVE3YkpJcXluS293dHdrNEdmUThJaHBZWjhuV0dGUFVZRVVzRGVNWk5RVWZZOGtFaDZsTkNvZ0VJdnd5UTNIdWZOa3JpUmpUQmtKVkkzUDhta1pObGllNXdpRkswYWc5eWIwNG5HL3p1cklta1ptVmMxak9vNExBWnppZjVYbHh1YnpmdVhYK3ZFYmNqMHE4ZkZjalY3dnhPaGRHNDdpanpJNENnam5rV3BPWVQ0NFU2dEdONkxlTVNBYWhrQnRSUVVLenpoeXA4T1VpNExOeldBdEFRWmJmM1htSm1Rd2FuVEsrV01La1JnU3pVVnMwYmNkVkl3b1M0V1A3V2dscW5sb01OQVF6TTJyS05ab2s0TG5hcFh4QWJMT3Z3aWdBeVI5NkZRek5kdXg4akljMjhrREViMm5XSTUrTHZ1WVRYL2dyUEs4ZXhULzV6VGVRbHRUZU9UK20rTjBCanN4UmV2ZjlPNnpZcjZYcmEyN2RSZmlmS0ZzVmY0anI4YVlzTEhZelZaMlFNanJYRHpZeHdaUWtQWmJDbUxDcDlOS09QajlEQXBxVEEvTkNpSEV0QTJaZ01TUnVWb0xVY0pncWhXVWdxdlVhUmdxRHloaUppbDlDcVZLRldRV1F0SmQ0Ym8xNlY2clNIaE1JUTRqVThjMTBXaXpKd1NZY0RaRVUwem5hbWNlMG8xNFNTM3VPanZkWlJuS01EdzNUVkpNRHhoWDlobWxxdm1rMmhjbURkbVpOSzllaVdicER4aGRsU3dDNFBpSWR4UkZaQkVrOUJHZ21CQmxFWml6bCtSTFcvcDVuODdMUElKMjJud2lzaEFxR3oreHJYbWh5cXZYNG02a0NxaVVpZ3doa3NNSklxS1poQlJpNzlFYitnNjVCMy9CSHlMQ1F1QW9KUDVON3lYZk5TT3FZNFdOMDUySzFCVlRMWU1SUkNaV2U2YzhCb0l5YlJibWtOUlJjSDJZZGhDQVIwU0ZnTFBMSmdJeGVtYXlvbHNCM0dFc1gzNUc3SjFrVkFsVG5YaC9zY3lSRzh2a3dFUzY0dmtmYVRDS0J1RG80U1J2ZzBJdmcxWnRFS2RlcVNIek96YUpLZENDdUM3YVJPOUdVWDNzaHpiM3dPaWh3a3M2b0pOdFp3dXkzVHpCVjg2OEs0R2hKbGhwRTZMSW5IaW9xQUZNMEFtQVhPOUZFTjdJRzZ6eklPQ0lQaHM4U1hjbDBGQXBXWVpDWnUvdU5ES2VjVzhlWU41ek41cGh6VXg1aC9qTTNIbDd2Yjc3NzB2L20zRG9ITXJYeXZQczQyaGZ2OVYxaDVqL1RHT0k3Y3h4QkdaaUhXcE40eFFURWIyVjcwU1lUNC9LMzhNY0dpa0U3OUZ1TlNkMHdNNTJzN2VTSU0wTEVnSWxhRy8vTWR6UC9EVkhOTjJBQkUvTjVydHZGd3FjT1hsWXk4aFo5NElVNGgzdkZhR2trek5MM2pKdFphWkhaT2Y0d2NSbTNLeU9FdDZhcC9iVnRuNXZueWM4WnB3RFZsejZLVnplNUZ1MHBUVGZwNkRydlNCbjRRZzlIK2k3cjg3b1h4Mm1MN2JNS1ZFR2pjbFVrZTJ5aVNtZmR4anlRZ004eVVJdVlWU2pKZTBwdDdITXFaRExldExnMHcva2lRdDNhdGwwNHV0cFgrRVZPa0JaVUdaWFpoUVpCeDMybk9UU3l6SlJBUGM1aFgvTXNRK0dHYW5seVhGTktBeWNiTkNHRndPZ2h4T3RDYWFTQm16UTA4SE9zS3FrN2JOYUF6UzREdFRUS09RemFOSXJGUmJhTmNqRTJ6RlRudFlndW8xRGJZZ1l4UTlSZStHd2ZSU0E0aE9weklQN2ZDdVpMK0RBbUdRZ05oa1pnZW9kTVJkZ1orcFpKQmVQaVhXS1hrWEJwVEszcXZmTVJSTUxNUnNJaExTbm56RnpYRHhiSUFKSDZESm1QaE9HNVFIck1YbFY5ZjFOaVdrZk1PWGJ0bm9FQjFYcXZOL2ZIVkFiTnk4ai9rU2xBbDhHa3VVOEdwa1ppUHRLSUJlM2lnamx0RjJ5UmRuaEVhV2xJcEtYNVNGc1RZQy84N2JQUk9pTm5IZUJHeVhMV0x1cllMOUt0Nm1HNmp2UDlPbTZDZVhmZ1lid3o5R3M2WGNOTVZFTXYwdmMrZnNCdnQ5TmIxK2ZUclJ1cm1DWXRtQjk3QXdDbkFxR2phVGlpaGxvOUdCYTRoN2FYelZtWURZS3NjaGtrVUFOUXFvc3YyYWt0SHRFLzJzbnBEcHgzM0RDOUtFYklmT211aURubXZPTUlQT2U4OTBoNDVWRnFDOExiNjlTQXdzSE9mVElwWWQ3QVQxZmlDK0NCZmhETTlDV25GT1QyYmNjdHdFTFFNQzhHbnJMZzRWbVdzd0VIYmJkRmNyYU15UFprekRVRWcyM3FndEQxb3EvVU9SVjlzMm1vd0dmK1JTaGVFL1l0NkJGY2trRTNXRnJsM0V2UFUrZzZra1poMkRXZnh4MTVsWUttSWlsTjRLQnpySVZrQVFINFhEQWl0ZWM2QVpJWUN3d29GQW5HSGd5WTV3b1QvY0g2ODhRTis2ZWk0aGpVY2syL0NVWW1lWHlKZ3l3bmRxQ0JHMnFmNm1SMTBvMWlkVWo2bkp1L3ppSmhzc0RaK1JsbEhDclpaOEpKQjNBOWtrNU4vdFZCQ2psMUF3ZTNkY3oxRFRWV3lVUW1TLzdnNEFqZ0hFVTRlSmJkVGlJL2h1Zm8zRDQ1WlROVzFYeE11QzdtU0pZZy9HV3dBc3FCaU9ocVpSSUdjOEQ5YUJkSVpYMWNIZzdVdElKQUlJbWM5WW9Sd2RPdTV6ZTFMeGY5Nmp5MVh3TkszdFFBdnI0YTFYU2phRWR1eUltR3NMek12b2xLQWt3bncyeXhhdzdSRllZWkV4UFJIZnFtNmRyUWJNTDVHQXQ2WlNoTWhBNy84Q053alpNVVRJVFBKYUtESHlBVnpJK0pMeG10NXNnQTRyZU92dU1MNW9IMjZKaTVrN0ZJOENJWmhJV3ZCbkR6RExRV0VOcmhTbnlSM3dYY1lRZjVtWXc3Y25HNG40WTh5L2h6eWtFSEdDaGtMTDh6d1ZTcytKMVFmY0hMTUxqRUlzTzJrcWdERnpuRDc4UTlQc0ZOUXF3M1JkRVlPa3NiRUZXWGVaemh2RGlndjJTcWFZREdURElLdmhlMENxcTkxdkFMTnRDdWl2NVJXc0U4MzRCb2xnZWt4TkFQbEhPdGJ6ZEZZa0RIUkRWM3ljR2pVbWlsbmU1K3Vwc2VISDZhVHQ5YVMxOS9lU1Z0M1Z4TXM3Z0Nxdmd2MVN6Unh6QU52WkZJZFRCSjJwSlFReHRVcWhzY3VHUWd3Q1BNRnE0RzZseFB2elJ2ME1ZRHJveFZhSVcyQ2Z5QkduRFhYRVNZWUxMSzVKMFhNOEx6MGpNWUFmREZPUkE0UjdOQnRNSFFZQjZhZldCWUJEb0thVVgwQkMrMEp1ckFQVFBRVEtXR3JXd0pyM0MwTDh5NURMeDN1WXhhdEtrc21taHFyOHlaK01HdEVyMTRvL2lTWVZtclRpWnB3VWlUUTcyR2xuZ1dvOGdjaDNQUXFlTVNSdzJoQjJzSzRncWFFMThqNFJlaElkTzNYUGdBb1JMK05HamNKVXd5TzVmc2hIK1N0dHhjSk5KSTBKN1Y4TUsvcFVDTURpaXNzNVlWMzNtdXVOdUQ3b1c3WTNJTWtIclF1ejJteS9uZzkvTGo1Um1XTFBOQW1ZOCtKUnR3TW14NFJIblpDaG50RzV0c2t3VWoyRHNhcCsyOU8zUnVtOFlsQXhrS2t3ZW1UYW0vYmhaNW83Ykl3elhyQ0dkRCtKVWw4NkFPTUEwUFdEY21OeVVxQmNOd1BkVUM2UWxnT2tTQUU1MnFDUmFPYzBJbFZOczFxZFJsQVE3Vy9nZ1F6Wm1MQy9xbHBPU2NnQ1BOTmE1Uit4R0ZnUlBEWUNCTWZqQTlDTWlLcVNLTXFxbk9ldStYR0FzUmg3NFlTZHJaUFVBYlhDUjhqcE1YNUt3akZadjB6OE0rT09sT0J2UWNVQnhqcWs2bE5JN1FrUGdZazBpZlJBNVY5MEIrRlJvUmhsZGhud08yK0IyQ3NHVytJSmJsZWkzdlN3RkRwYThSSUtVUmtnUm95THg0SkgxMlRaMEVKR054aFBiZGR5VnZkQ3pnNHNYQWd2dERBNU1ZSUdBbDdnVk1vMGxRWW9wVzIwZTZ0a0ErZUUxRTc0UVpZS2Zmd0FQenZBQXZsbGloRU5uTXdOU3lNQlk0dEpLb08wOEhycHZkZllLYmdGU1ZHbmw4ZlpqVFNFYm9QN3JVc1BRUGZxdXFPelR2UGs3ekI5dHBoUzNhRnZpdHc4dkFWaUFrWUhiZWFteFEwaGgra29aUHVtbGhjeXU5OGNJTDZmOThkenYxU1pmWTNUOU1MeDZlcGJkZWV6NHQ0ZWZxNFhvWUtPZ1lnQm9kUllqUVhvOWhzSmdpdEtwd2JMT2pUYXpORkU3QUl5Zi9Tc3lvQnpHUkdFTUNFTnlxNkViZ1BBa1pkTXI1MGhWZzRpYnpTRjVmM2hWSXduUjFCbk9HRDgybkZ0VTVCSUs0RnlBUFlSRmYrQjIyeFhQUkJFTlE4Vnp3UWlacW9jb1l0M0R5UHY3NVh5R3JLeUtBQjBOMVRhSjlxTUdzeEsweGFSY1ZValdNQ0dxK1Rrbk9ucGh6Q0xYSDdrVGdlYXhyQk1lMFNoZzhyV2ZjdFlkcTd6VUVRVUE5bUI3TWcvSHA0NVJoaW1NZXdzckQvbG9hM2Vvb01wU282WS9tT1FSV0ZreVlRRU5lcXA5Uy82WDBHMnRMV2UwZ25nZEQ1NWxhRVdwVGNZNHhSaUk2UE1TYjFRSmp4Y2dsUTVYV1pJNXgwSDFaZVlaVjdsZHh3ZEtDU0hhRG1HM1lrTEZxc29OUzAxR2xWWnU0ZWYwNWlKaGE2Q2RVUTZEMituUktCQWVIYVFXRWxEQ05BcmpKYVkyZGIrb3NpNkVuWEwrUWxocXJESTYyVUNPdHRuQ09nMWJ1Ym5Td1RxUlFBT3NJWnpRd1Erc1JaU1pscEVFcFpLa1N1aHI5VWFJRUozZUtHYXpYK3ZMd08vS2Yvc3ZZTXFQSkErYzhrMko0dGdSWTNPQWZKc2puejFOeTVYaDRsRTZQTGlDR1pWSWpyRnlLV2RITURsSGJ6Tm5POXMyZ2duNG4xVnk3N1VRem0weFlPSERWVGtvUUEybjdaKy9OOWZMUVQzV0JuekF6UVg0TDNORDhsU0dCZURBakYzUzc1S0dpNUFJSmJWY1lxSUZCQTlHZTl6bnlNSzB2bitHNFpjcEsyYndlemlFaTFVVWF6aUZaUWxQVDNKL0ZwREljUG1CZUJ2U3RpY0NTeUJFWElMVXF1NGpHdkJEWXNES0RtdURaRUNiQmUwRTB0b2xwZnNaOEhoMnpPemJ6MmVFWk92amQ3N0NBeU9vd3J3Nm1RSlZxSU0xSGo5TGMvbTVhREswR0dNaW9lQWttR1J0VEU1b1c4aU5OMmNTWElWUHNZelo5NjNkL0kvM1hUNzZUUG50dmx4eXZmcnAvTkUxM3Qzc3dyYTMwNmd2cjVPVlprdnVZL1NZUDhIdnRzdnpyQklabExoYWFDVXppckVyRkJPYk9lWmVZbnBwem1GS08xUW9MMUdOQVkxYjdweE1BdHhIekNXNmgxWnVNckw5SllyVjhqaHk5RHd5Y2EwN0YzQnF0TEFrcU5PM2c1R3JGWHFOSGo0cXNDSjdZY0JiMWJ3ckRHSTV5aVIrMWNBK3ZGUmdGL1kwRG9LalpxS0hGbWtXZVlScUh6dlU2akFyVktHdVJBcEhYa0xIcVc5VHh6bEFEdDJva0tFdnU0Y2hrYkM0QUR6eFZRREpHbVZuMm5mRmNOZW1ZRVB2amFIUXZlQTJDQkJoTjhDRTdmbkZEeHBOeDFqSGlKdUtML1orYUh4ZWQ5NitNMmtmSTBQaHNpOEU4TlJIeER5UDRaSlQydytmNC9IS09TcGhFVTdiRS9lWGhOY1V4VWl1eWZTRVVHWTlhaTBodjdYVmlNRWhTb3gwTW5ZYlhsMjRDMUZwNnNET212amdUaHlvK29yeXdPNXE0eTB5VFhYQkdveE1rQXhPaU9jT05zcEgySEJpSU05eEV3WDVQSmtCWXZzZHFmcFpkV1BIUlE0YVRpVGdQVzNWVDg2NEs4bm0rWkJoMEVXU2lYUWJpQUJ5Z2hLcnFMek1wajZzTWJleFNISUFpb3lsTnRXQndxdXJ3SGNlOHhHYXgrcmlPZG8vWnNBSy9HcytNU2FOQkowVGd5a1RGTGMvYlRrWTBPOC9rOG56N1VkNVQ5a05tWVgwczExaUdyNERKMURUUmwyYXVpdEpjZFIreTVaWDdyM21qTnFiVzRVNHZ0RXdmaGFSSXh1TjhKT09QeUN3SXBJUVNFVHhrNmg3Mnp6bWNhSEl5RitHTUQ1TkgwNEVvSE15a0E5T2lZZTVGb0lTcUFaTnl3UzM5c014dk5vT01ac28wamZheFFTN2NSQWwvanFCN3d0WldGeERvaUhrNkpxQXhUMmIySFBqU0pCMmhUcCthckRJbzloNm5XY29xTDlJOTl0SXdaa0luN1NFSHc0MnZnQTkzb3F1eW1LZVU3ZzVXMG9OSHMrbFZmSS9mL0kyWDAyZWYvdC8weWIxUjJrVUxmYnczU2g5U24rM1ZyeXlrYjd4NUs5Mjh0UXhlc3NQUmt4Nit0RzNRak1oMDdRanRUV0tTRURJeDZCcGdGTXdQR3JCY256blUzMG95RnpROUQ1NFpCUVAvUTdBQllSalZCSjhvdFJIZ1Q5eExPbzF6T2NDSEo2RXpBZkFOOEJMTmhDOHhISEhLRVpsQ0lIRkhLWEZNZkRWZ2ZWTDJwWTRUcGlyVFVpdmplZ2xlbkRFbEkvSVNnN0N6dHVLYzZuWnc3c2cwNU9XU0d0aGdNQ0NZTGU5YVIrTEdGRVprS1NVZ0hBckl5RVJjQWN6MVZyNXdOWUNhV3JaRXdIdjZQY0NFbEZHcExia2RuMlpsTUYzdUZIYlJMMkFseTFFUXVZR0cyZjdLVDJtR3EraUxZOGo5amZHQUoyS3NjUEFadnNLdHdYVStYMXpYNUpRSGVHU1lvZHhjQ3RwbjUyZ0JHZ2h4TDdqNUlYRGx3WU9kcUhFK2crUFpKVEZoZ3hKeE82bFJUVkZtQVpEZHZFSGtEeWQxNTFhcWJzMFR3WHVQaU50akptQ095U1JTaE5nY3Q3VEIzVVdGT3VtOUoweTAwdW15WTVnZ2xxK3R3ZWxkQU51QWlOM28wNFd1T3ZIS3ZDb0hJT0hyNEJXQjhqNTVxcmdpaGdTZEdaV1RYeklmQjh0dGpFb05ERjhjUkdzN2FqZkIxRUl6azZpWlZNNzVlN3hIYzdBQko1M2JPNmlpSW1lWUdpVFFaYWNwVEpZZ2djODNXVGJiNnovNURHMTIxZC9JaHhLWkE3eDVNbnlPOTV0RXF0WHRQTnZIN0ZTVmthaVpOR2dYMVJnRWlwWC9NREtaY2lBRVBoUER5YlpweHJMQk9TZmJ5R1UvM29XSDJsR0dzM0FVZnFaZFNKd1JyWU5ZaFljRVo0a1hmU0F5S1FXVnFSSVNsaHQzK1B5NjFUQmw3dHdyWWhtWnBQWG9yNnY4UjJvbElOMDVqUERlb3djZ2F5K3RBTThHMzJjb3VyaEl0RzhlSis2RVdrNDFsK2dna01EeG1Eb3FDc1dTTFllamlScGVDTjdOM0RjbHp2cGxENlkzMDM5L05KOCt4cHo3MXAyajlQTHJOOUliYnkrbEgvMll6VTUycUNwQzJQLzBmQzU5K09HbjZVZnZicWMzM3JxV1huMzdWbnJ4aGJkSmUxbWlVc0w3dUNka0RqeWJRQkdENE9FOEQvaUVGc3RNeTdoMFltdHlXNDAxeWlTalNiYXBaZC9yMGRrd0lSSFhNSm1NUTdRQk53VjhFSFUybnpUUjlQbG1aM2M4SXA2bFVKeUJNeHRGZDBvbW1HMm02ZFJDeXpJeFZkK2FoT3MxV2lqMEt4Z1crQTIraDliRDQ4Q295SWxyMWdsYVFUZjZlbHdiNnR6b1MrTmgvTXM0YllEQTFSRG1TcWtWR21SeEZVTW1jZnZHczRpOHVtWldYRmV3ZzRMNHByTHd3WlJnam5GRjVFdmpkejhHYzZPL2t6R1ZmMkY2bW9UT2tYM016Q2VhcGo4OGdUNEZoUUkrNlNFYzZ1QnUrR00xangwai9kSVZva1VuRTVjT3dsd0d4L3dzM2tvUDBuTmNMODJMaHpiTTRZaUxnNE1UQU12VzhGemtScU9HZEdQUnJwTGZuVVVBcUd1WFRsblFyRnJaSmllbVBqZWZYcno5RGFUYUhaYjFvSVk3MUJDZExsU2xQVDZiekthcU55RERqeW5FV0FBQVFBQkpSRUZVdmNmT3VWV3kydHROdHJlM0JBd0VaaVNzVGs5bWtLTDZSY3dSc3ZNU2R3OGJ1RStPaVZKZkgxZG1YblNYeDZodFJMSXBVTktFRkZqNWNGUmN3OERMWkRZSEhjd0xSRk5sTHBtaGlLTEdCaWo0UVdJV0NUSVNkY2k5TWdqUVpZRnUyWmJFTHlQM0paekNsNlVQQktZcE14SFl0aVZERU5rMVBhNGVUb1FWVDkzUU5QS1VHTHYzU0FRRlM1WjBnT2R0M0dGWVRCNmpGeFVoS3BtU1JFUGZnNEZ3VDBqZ1FDMzZESnlqRDQ1ZEFzZ1RyL1lXRElwN0duVzBaS1NueW1lZGFMQnIrNnlocjNBU0U3SzJZRHY2SmZJVzdTMHJLUEF5VmNMeTFITnNUbUdWVUt0bkZzVUNuMGs5UUROdnNpeXJQVDVMcTBqZk9VeWw0aFFOQjgyWjBtbmdBMGhOTjdHK0ZQcTBEOC9DbXBIV1FBdmd4Z3ZrRmhuVnFwaEtkSWoxOVAxSEw2Zi90VjFMMjR2TGFmWHVidnI5YS9QcGE2L2N3Q1RhVDNjZjlkTU9adWdaVEdYQTltN2YvY0g5OVBHOUorbjJKNGZwdFZkdXBXLzhHaHJYOVUzOG5CK2w0Nk5QMEo3Qk80VUpnOWZOSVRFRXNRQmZwb0JEdU5sWkJCd2RiQlJXTVRVOVFsT2RpQnhtTGVEbGN4YVN1a3ZNR2JTdW1ocVVPS01UWE5oN09LZmluSWMrU3dNaXVpWGkrVmdyRXB5ZkRWQjRuWVVhZ1h5K0I4Q3dRQ2I3NDBMVEVXREFrUGJieFJMOVJpalFmM1JzaUYwTmp1dUpzdFlLZHkybmp6elREV1NHbU4wZVJ1UEMzdGI1cnI4dC9HN09BOHdDbW5KbnF0aEhVNXprR25kMk42Y3QzRU1JSURVb21YcFZMVlJUbndkWXBob2RFUndnbUJMdE9PNDhkdkhObC9RUnVYdlJJMmxMdUlDYjRqdDhRY3RKQzhPWE9LRnBHRFJ6eWNDa3pSS093c2dnam1rVnBjVlR2UDc2cStueDQ1Mm9jNzZIbjBHa2wzbTRicS9ROFl6dnc5cnFJbk16ZkRvOEZQdTZNMHN5YVp1TWVKRFgzQ0R0YUJjUk5wcnNjd2dDamlDVTJMRUV4eXVXT010alFQNkxBenFNRnFaekhNSUpOUmlpTUR6YklTVkNrMHRtb01Sekp4Yk5GcG1YdStTNjY3TGFWdXdVd3FTSjZVb3c3ZVFnYUxRbmMzeWlEZStUS1FDc1NMUURHWFRrOHcwZ2xVQ21rOTdQSklWMkxwTHlrd3pPSFlKY2ttVGVpWTNBZzBJaUJORFYwdWlIclVVUk9DWXNTMHV1aStkbHBpR3dUVndVSVoycjBGUTB6ZWl2dVRNeW1xaWV5aUFraURBM1VaOUVDa1BNK2t2c2FnTnNOR25UNXcyVmR1YklnSEMrYWdnUzEzWDVER0dnNXVUaFU5MjJmb0FwVEM5b0IwVFhkNEdXcTlZVlFvY0luZjRkbWdqa3E0V3ZNcHZ0U3VpOGZUcHp5T0x6QWFiUlBxa0xUQTBJaVJhQUJsTmxJZnZDOFdtYXZkaEpzNVBEdEVCa3FnS3pzdkNzUGlubGwvTWorZklWcE9NZDJoYUJaV1RLSFpjSHVlM1dCT1o0aG1rMk9GNUw3OTVycE5QbURmS3dabUJRK3l4TGV5a3RzODd4OXZvZ3JhOHNwNGNuemZSd24xSkFicHhDY09EdTNTTjhXREM0ZXhmcHdhZDc2YzNYVjlJNzd6eFBVY25uV1lTL0RieGNjZ0t1TUY1eEtJQ0s3elhzVCtlSGVkQy80cXNwbkkxQ2NGNkdKWUlJaDVqM0FLME1udDlsSEpoYW9hVkZHOTd2d0RKaHhYUDBOVEFQQmVhZlRLQ0M0OW9tZ3RHQi82SFZNMGRhSTJveXpzdGdSQ1NlZVdUTmxKTUN3OHpNRHJFT3psQkpRNXdDTjFFRGVCN2ppdHd6QTBmU0lIamk4eFJFQU50dmlFSGFoU21pYlZrMlhPR3FMRFVMdjhsODZSL1R4eWw4S2xwQ01DN3BKV1FwZmVWMENIcDNhbGV3RGNuRE5LVm5Rcjk4aHY0Lys1a0ZwMHdKNjBVYzVHVlZDaGxQWmo2YXBRUUw2THN3clpodktVSndiOEJHZjIxWVQ1d0NqZ3A0Y1YrbXFkSVNyaHpvMG1jWHQxL2NTZ3VyMURxbmt1Z3BoY2VPams0b1puZWNkbzkydUZoVkU2N0poYTdWazVqbjBhN2N4TEpQSlFiVEEzVE1kdUhPNFIvZ3NhckFBeVU5Mk5xZ1U4MWlIVURQVWc2RU5BWTd6SGcwZXpSNVZHVnIxVk02ZG9rQU1MejRESk5yczFURE9sb2ROcEVZajhoK3h1enMrMEsxbGR0UE1DZW5YQzlqYVJCMm55TGxwd01kK3VZSE1RR28rR0cvQTVSWWpoTnFxVURVVE5RT0I3bkNFYW41YUVSSTZjaUVjcjgxb0dvZ3B1RnNGOUwyb2wydUF3M2MvcXNDbFF2UTRQcE1wTkpVbTk4Sm9GTWdJTyswTlVHRDB1OWdQcEM1VGZaN29IUUcwYXovRkl0MHVhSlFkYVlQZFplWHRMaUlwc3hMc3E4dEpGWXdOK1ppQkNNWkFGOEt1S1lhQ0ZybnVZaUtnQ2VXQUJieHBXbkk4MldZRWY0VytWMlFqRlFlNEY4Y2dxejZHS3NFUW5xTUJVODFZODU5REdtbU5vS2ZrV3duQkk0ckVxamVTam1oTXpSRVJBc3BCeUF0REdzZTdhVTUzRXV0N2tNV1ZCUFU0Qkc0TW9QZWRLVzRwclBLcWdTbUIrWkszM0NKcVZITlFoZEdDRkVtZ0RuSk1qRGgzU3BNNmEzZll4SHpiS3FlN3FjL2VQTjMwdmUyRDlMam5lTjA1d21sYWxyelZFZzlTdlBNNGEyYk1MYnBldnFMZHgrbnZ6emNUM3M0L1ErZjdPRnlPc2NjM0tXOFVUdTlmMmNudmYzMkcyaGRiK0JiWmI3WXUxSmlVVyt0WVY1TmdhWCtLUVdEYVFyaUVLUU96UEJkQW56WDBDcEVHQktXZ1BNcUFjbmtPTUVSNndlWmQ1T0lqUlNyVlFEeElDNjFkUk4wZFZSTEV4V0FVT04zdGFKZ0RCSXFUMUY3RjlmRktSbWMrRk9ickpIM2VJNkdDSENZMjI3WGJmRVFwTFZ0M0RJZDFsY3VCazAwTVRuMVcxbU5aTUpjZWdUNndReGtycG40WVhhTXdWVUwwa1JzZHcrM3lzeE9rWVl1eVhnY2tybDkwb0Rsc3l0UFZXS0ZhQmFzRFdBa1Bjc0x4Q3Nhak5jSUJVRXJJSVE4TFRuZUxyUlNBUStWVWpJZVN4UUpteWd4amJaV3MvSXZVV3A5aGdtODQySis1ZUpnL0RFVWtFaEJ3aWtlWlRESVorZ1BIMEtUbEpjaGttSnlJU0VhR2RZS081S2NFYWs1T2lLSENsUE5IWHZWZW55NFRtbVgyMnhUck04bE9pc3JTMFRWMkdySk1LUU5nd1JLZXJVMHdBQlRrV2dFelJ3TFVtRndjSFhRRndRMjJtVHlHbHFBR2dVWXJTcG9ORkpWTVRxSVZIRlFOWHhKbWxIdWZrek9QVXlyZ2NuR3NoQjhabFBzNlJtYUxJeENra0E0b1F5T1UrSGFzajVFT3VENWNtZzN5ekFVN2VUYnRuMTBXYytGdmc0WWlhRm1PaHNJS0RvWmJYSGlOVThMZ0tRYUwyTFpidmdQUUJZaEtsSm5uNE1US3BMVGpNRGxuMHQ2VERLdHdyUW1ScTN3cjQyZEFkcDFhWVExaHByNE1pSm5pdmRZUEEwQnVQZ1ZWTU1FeXBNWGFqSDNhQkxFVnU2cXlNQURXUVBldzF3Z0JLWFgyQ1V2dG0wbjdFdSsvWEx5YzJQT296NnVVN1RtSWRxSm12SDZTaE1OaFQwR09iZElzS0hIV3IwZXBhODdMSU95bkVzZkJueE8ya2xUeHl6OXJ6RlhmUmJIRC9ZZXBqbzdGTFhBQzNKeVdiek1DekRPektFcHdQRGtTZUFpVlJub0pzeVVhUTZsQm40SmJPa2kxKzdQcktidkRkYlQ1OTJYMHRmWDMwbGJ0OWJTUDE3YlRxOS84emZTdFk4ZXBQLzB4OTlOUDdwREhYN3c4dnFHcFhETzhETlNmMzlqT2QyKzlpb3cyMDgveExlbHNMRVU5QzRhM3g2TGpYZk9wdW5oWVVydmZuQW5mZTIxYStrYmIxeWpJaTZZdDcrZnpvNk9TZU5ZeXNUT3p1QklRbEl2OEYxSzhRbzU0Q0RPYWtLcStUaS9nQWxtNjRpY2RuMSs0Q0JhZjJnZHdMTkxwRHpLTHVzSDFLUUhyN1FFZXZqQUhnMTN1SjUydVM4MFBRa2JBSVRtRDgySTkrSVhQNGNyd2hMV3VrQTBKWjByZjFjSXVvR0tWbzVtclRzcFlmU2s2NXZzd3Q1WmpqNkpKNXFQSHJIVkd0K2pFS0FhSVJOUityM2NIeEZ3OGZLNTBpZjRCTDVwTmpJejhZTHRBUThZbHVlRGtZQmIvQk9ydU1OSDBDYmZxNlFZY1cxb2RiYkNPQUlIWVpCNWgzQTFRUVFsRmhrWlNyZytjUHVNa0dKVnJEQjI3VFlGS21BZTJwYW1hdkJCbmdsMlk0R0o4K0p4bUpBd2ZmdGRUR3NINUJ0TjBqTGlzZDFlQkRtcFBkU1pvRW10UmtaNFhxeUpRb2xmSkh3N3JNOVRpOUpVMjluZXA3ckRFY2pOT3JDMVZVTGxSc0tNSHFybVl1ZkNNRncxYnlqV1lacC9OWUlZbXFxNkFwRWlnSzdiQ28yTGQwMFA2MzFiT2NHZG4wT3RoZmlNWkFqY01odGJZcWZwWVBUNkZLUUV6VXFzY1lBblE2TzZLVXdnMXNueGZBRS9Oa01iaDYzTFNyb3M1bmFQdnYzRFV5U0NTdzFtV0twRFlVRzBEZmdCVTZQalVoeHpBdm5PbTA1RXVKRUJ0L3daVU1yRU14TUVTVXhCQURka2RwSnJFTEFUck5iRUY1ZjlvTnhHVXFZSTY3WmhOZHRqa3QxdE9CZ1dqeEFoTEthbTNhNjU0RE0wdDcxMjZJd2g3VFVydzdUbGVWd2V5TkVRM2lDWkRNdThtT3pVekNqbUdEenZxeVNDR2VaSzdiMUpjSVhrcVpCazd2cHN1WmdLS1NzVEdDenNKaGozaUlDQTVvZTFxeXpoTXFJdzQvUVlmeFdhdGN6S3c3RVRPSVNaSWlBZ0ptUWQ4S1p5QmhKQUhVREJ6YkJnZ0lrdHhsTGFXOWhJMzhjRS9QYnhhcHE1OWtwNnJzSHUzekREUlZ3Tnl6T0Q5TXIxRHRvUjJ0ZkpPTjM3cTN2cHhWdTE5UEx0dVRRUHpuU21lK25hOVlYMGIvN1YxM0ZNUDJFamtWT0NPRWp0SnBvOHp6eGovaDk4ZGpjdFZEWlM2N1diUEIwQlFYN2RLa1J5Y1BpQWFDSWFJdnRzdXNTcVJ6My9BVVVkTlhQUkw2QWZoYUtFUmtjNUpFQXJVU1FjK0RJUFQydDVTQTllWjRBbUNBbG0wU1NLSnA0WXRYWHN6Rlk0eXVkSW1oWi9MMkNtNnl6aTExY2N4STMycWRNK05CTE5LSzd2b0VEb001VXhoUkRIdW1scHJ2TlA0YXZRNmFQRkRQRWRIaDJ3eCtOcHhoSEhhRis5SnpRM2FDNXlyQlJ1SUxONVVrNjRyZ2VybklaV0NKY1VqK3hMRTVyUzl5dENnWldPSERyWEN2RXpHamgvWTZveldQaWlCZ2E4b0JFWml4a0dZcHRSelp6QzRBMzBUVVpHcy9TY3NhSnRJWWtaR3UwcTdOMWhpeS9CVkwxT294YmhDK01TZmtFblZuS1JvWUh6d3I0NE92c3hHc3djRHVGRmFwd3Z3Y1hOOVFEUjJQRGhva2ZTSjRYdUJOTGNIR1laZmlnbktXZjNXbjc0REwvVWFkakMxdkcrVUt0Z29DZHNWNitPMmlYZktMZytIVko5dGhpZjNCS2V3anY2RWhqc29sV1lKejRHL0dXSVliZXI3OExVUUJPWUFFZ0NnWUwrZEJaN240UzFXZ1VPalZwcFpFMUlPRjRKVlVhUlY4Z0R5Q0I0SnBnK21MZWxXaXpDQ0d2cmJobDlyT1BUT01kWGRrTG05UVdCaDVNVE5BVzB4amxxbkhkWUJJdFE0em5hKy9nQ2dKVE9jQnN3YTl5eG1XMXVQb2tJS3RPU3NReTRDVjAwK3RyZ0hsQ1JNWUlrTWhpY05VTkxPMk9HQ29BaHMrYXVKMDVFRkY4REdaWHMrc1dtd05zTk9LSytla2hnR1c2V2VwRlFxZ1NqN1Z6WXo0NnE4bXU2MDFmNmxUZWVFSDBNVVlod2dXcjBLMk9iZlhVekRoTUdqZnoxQ254VSt6cHllMmx0bWZRVW9zU1c1ZEVacnAreGl1Wmh5ZWdxeUhqeTRHR3FIckRpNGZ3SUt4T2tvMmtKVGRnd0RiZ0tZSE53S0ZIZnAvVjR2QmtTTWhKQjJPTnpkM1V6M1Y5Nk8rM1BMYWV2ZlAydDlMWGYvcTMwVzc5K08vMzE5LzRrL1k4L2U1ZkZ6NnRwNmRaek1DK3FoNnpQcHc4UU5uLzE0VGxsdkh2cEc2K3RzUE0zaEwxNFFXUndQZjNMZi83TjlOLys4eDh6QndOcWZMR2ZBSXVscTBTdXUxUTlmZlBHYkxwSm1ldytSU1EvSnJuMUFTV1VkNTcwMHk1SnA3WGFZVnBoVjdlVEo1K212ZnVmTWpZandhTjA4L1ltZUlyUFZ2dVdRNWlHcjQvNTJkM2REMlprZW83YXB0RzdwU1VFTmR2RDZaTlJDS3RobWRzMlJVREYzbzY0VW1ZcExpamV1OFp2eG8xcUx3V0xUQ243ZjhRbnpPOEpWWEJoaHVLQnNHdUNlMTdqWmlFdVZkTml5ZWtFQ0htaXN3b2NsUUVaZ2N4S2pjK3BsbUZHU1NHbjNnT0JMcDVDQWp4UG9YYnBHelk0d3oxNWxZT1o5REFMK21HNmtla3J1bnowWit0TGRyenhiSjlKdjZJSUplY01OTWxnMVFoRCs3eWtNL0VSeUlQN21ON1F1QUVjTzFkMU9SQ0w3QlV3S2h0cWcrRXZ4TWNhVEJMY2p1dlVESUNDSnJ0K3V3R0toWXl3Y0t2dkM3U2xJZUhvQnRLbFVWK0o5WDg2dld2c1RPS0drQUpEOHlnWVZrZ1dpQWVnTmxuZ3ZMQmsrRnhmQlZvUmc5bkJnZitESC95QWpxQVpNRUZ1VHk0aVM0QnhEd09UTVlnVWJZcXlMYTlRVW9SNjNTNFVMYkRKbStURXVPbnplUmVpSUZGVng3VEplL29BTElraU03UElYcDFyYTNCM0NWZE55UFNKWUF3aWpxSWNwaFI3eVVuY01CaG5Wd1lwaFNsSXpFMVpJbjlIcC8zWkNZb3R0Ymk2Uk1HRzJ1RFcwaktwbFQ0emRBNFpIcDl4eU1yMVM0M0xTWFJ3WTlJQjFJTFF0NGpTMkNkTWJDYXNCck9rR0F5cWgwdE5aSkprc3ZQVk9kRWVINXN4akFuQ25HQUd5RnBrV0RCV0NNZkpyTGlQb0thMi8vU2wwSmNhNXdOVGVSTTVjMFVDdm1qbTBoZWR0KzRIYU42UmpGWmYzbE9KeHkwUk5SV1pRR0pOOGlITVlFQ2FpV1dPbVdKTWZnakJUU3IxV0RHaDdUYmFBS2J3R0VFMXhORitSdDM3Z3VCTUIwUWovelFJUzJ2Sk9kWWlnYStGUDZ0RlJZWURjTFJHVXZBQ09XNW1pOVpvcTJERDIrdHZmcE9TeC84b3ZjRHFpSDFnOFBKcnQ5R20wSm9iYStsN242VzAvYWVmcEQvODF6ZlQ2c3BNK3ZXdmJxWFIyY3ZwZi83cHQ5UFpka3FIWi8yMGZUSklmN0J5TFYxZlR1a2I3N3lTSG43MlVmbytwYjRyTEhSdk5kbGlpNVVadDJGMFc1aW5aMGRuNlM4KzNFay9KdUgwQ0c1NWVrSDFEZWFxUVFSd3NkbE55ekRROWVVWDB1M05WVXppbE9hWG5GTnhSQUptUUlBQ2NFVVVkMnZyQm5EeHU0SktUUVpZbzdtcEdWaUdTZUhNbmRDSkxnWG1qdThSTlFPMmFpQWh4TURCTXJKc08wNmpqQ3pTQm9EUklkRlh0YmNaNE5haUFJR0Y5SFJoR05rTjU3dzRRbHM4amZrQk4zQmdod3REc3hGRzZ2T21UQ1JVRUxoZ3RRVTEvaWlDcWZrQXJVQzZ2Q3lJS1Q3bTc3QkhjSUM5REpBNDlCQWFZaDU1Sms4TEhKWEpHakdXRDhpZ1JrUlZSakFodFRLRnBKdm1Dck13TXhtVTVxOSt1UWtNU2hQUFNyczBCUW9qc0hFUGpRZTZHTGdRWXNqd1VLc1Z0cHFzTUZYeEUrWmF3KzNEaDVnSGFaRU5TMjZrWW9ZRmthalJmUmtYNGVOR1FYUUpzV2premtZTWdSWkVLV1FxRXF3YWdSSkJxU1lnTk9HYURNREtoSVpzemRzeUk5cVNJNDhlMytjY0RuU1hNRERCWmlCMzNjSWMrMTd6N1BQUGQzZ0dwVi9ZNmNScWljdExiR3BxWlFGOEp0WnVZbVVyQXdmellRUnkveEZtWTVoaG1ERmhMa0hvTXJUWXZ3Nkk2TUNzTjdoUFdQQ0tEM3dST0M3dWRNTUN4K1RSeEtFeXh4YjJKdUpWS0dRNHRjSURsUUdHMW1HaXJXeVRhK3VyeHBtanhtZWxGeThuV2orWGt5WFRjNkt5dlkvVWRKcEZabURTWUtMMVphazY2K3hsMFVKVWxvd0YxbXl4MW1IanhpYUk3WEluN3dzcHhtZmpPa1BNRFdIdXppZ1RUTXVDZnRydUdHYkxZOVhsZUtZVUJWeGx4Z3pNM0tEd2xmQlppV3RLQTFmRmVPMnZTQjdGRHZXTWd5eW1NTFJabkM1eE5ORlFySDVnSk5JQXlRaS9KdlFBRTZjTzJkRjU2ckwxV3gvTnBZOVBxUXFUZGxyTXJkSS9wMFRYWksyQ002MDZtMFdRbGpDL3NaVTZtOWZUM09hMXRMeDJqVTFCeU5sYnd1ZUpXVFRGajlGZ2NmMDZmVnhuM2VxM3YvTWhhUW9zVG0rOG5EN1lxYVRmN00ra3Q5NThLUzIyenRLMy91bmI2WU43SDZUMzNudE14dnRTT3Z0Z2wrREJYNmJmLzcwMzA4c3Yza3JmL0oxMzBpZWZmNWhPeU5NaXRrMWZCdWthMXNJWld0RVB2L3ZqOU9jZm5xYlQyblVjLzRzUW1WVHpKTjNjYXFhWFhub2x2ZlhjUWxxdUl3REJvYms1NE50RU9FTUh6a05za2NWY2lHK1c3NUdRUENSYTU1K0xHQk9samRDcU5MK200TDYrTFltM0IwMzBVU3NsZFBISENpRnFRZ1oxTktXa0l4Tk1UWUVSajBQNGdTZHFSMm9yTFFJTkhWS0kvQnpWVXNCZExtZUozQ0hQTXF2Y0hETjhQY3lUOUJOOWMvV0pBcEErdHRId0dFS1VaTkpFTEVnYzdjSVlCMWd3Q2p6TndteDIyaitzRUsvUktRNVR5MmxCNHJDYVBRRVZoTGZYV1BqUHcrZEYwaXh3OW5Oa3l2TzcvTkFhLzMyWDJURXU0V1RKS1FZWE1ERGkycDVqOXljRVM2TUJVNlkwdWpBV1JvU0tNNVlHdk9LV29DZnY5ZkN2L1NrYUZWYkJ3M1JjVk55b2FPSWR3bVh4YTVtc2hzUVRnRG9jZFZKWGFGUzFGUHJCbjhSZ2VBN0RoakV3cVFCT0I1b083QmJTUVc1c3RHTnVZUXZLb20ydWRYMVRxSWRCT0hCcEptQUkxcnVPc011MU92UWZQWHlBU3MzdU8zQjdLd3RBQjJsaFpZN3RuVkFqbWZRV1dsOGRiV09DaEpRTGQvdG5TRTBBd3dMYkN6U3dXSUJMQlFGM1I3WjJkcWl5WVc0cE9aRTJKcjdoZ3pOTFdITzBWUWRwR2pCUVV3RG9leDJiZllTazB3a1pOalJTSXFkZlFLQVlmQkd1cHltWm9hOWdHdHdUNjZ5UVpPRnJRRUt4ZTNyVTgyN0ExSzJvMENIaGNJekdkTXlFa0NBQTROQnE5QzBBTnR0MFhtSkNRQnduZmdUQ3ExWlB5Qkkzdk4xUTlUY0hnRjRvTTNFdndIeGROTTA4MEErMVNGcmtSaGdteU5yRTdCeWpaUTB0a1JBSUl3Smk3b1BRYW5VVFNnRk5vWUFxYzJGZGZSbWZmSHdLZ3p2RkFiWEFCaFZUVEFSY2x1bjRZSngySGxGNTlzNEJaam1LUGtHUFV4YlJHckUwaWpNYUl6WHBZM01WYlF5RzFHS0RpL3V4L0dJcFRROFhtWHZxL2ZmcmFYV2RFdGRnektyenl2emRmNHhma1UwcFd1MXgrdkR1S1d0VisrbmYvN3ZmVFQ5Ky82UFVKZy91N2E5dHBZc2psdldnOWYrSGYvR0g2VDllL0VsNi8vM1R0RTlrN1B0L1JaWjkvNFAwejc3VlRHKzg5RUo2L1pWMzBuOTU5NC9JRHh1d3Fjb21hMHpINmYyUDdxVS8vK0Y1ZXRqRlRKeW5uajJ3YXRlUDBqZGU3NlRmL3ZYbm93ckpFdWJhdWd2ZlllQVhaTzZmbnNBMHAyNVVBbXd3aFFvWWxkbzFzd2krZ3dQTWlZVXNMd0NNNWx1dFJlbGsrbnA4cUNqU3hKZnBRTFRRUXgxbTV1NDdNeEQ2R0llNWVENGxhanZsZnVmRXRBRE5zYzVNTnFDYlJPbE1yQXlma2xGNXRFNkRZVmFGMVovcER1ZHFiVjNOS081WDZDc0VOZXQwZUtqaHlJUkV6UENMOG00U2JXanhYR0UvdTN6bkFzNHA3TVFiVUZIemx3QkVCYzIxaTdCMmZiR21Yb0ZKYUNaN1JCUHRMM2lzZWVxV2M1QzB2bno2cXQrSzlxQUJzd2xtU1V4dTQwNlE2UmRJdXdHQzFtZkFOVUJ3SG9pd3RmeVRHdWNRZ1cxVjN4SGpjQk1VK3k1TmlJaGFCN1pYaTdXWUljb0Q5b1Zid090VFVvdHk5ZmJpNHZ6L1orck52dVBLcmp5OUUvTWNpTUFNRUp6SkpLbGtEc3BCcVV5VnBLcVdXaVdwVkdWM0w3c2V1dGZ5ZyswWC8xKzJsKzNWN1ZxMlhGVXRWMGtxalNtbHBHUU9aSEltUVdLZXh4Z1JpUEQzblp0d2Q2UWdnRURFdmVlZXMrZjkyM3RIS2R5QzZWdmRBeDZPUm11bEtkd2IrbWx6U1ByenBra1RZMVlteHYzaHdySHRDNHN2QXJ3Y0l0aTY3VkpZWHQ1RUNIRklDS3RUUzBTUXlKcWtrV0VnaEpFYlRKQ3RpVnM1TldVZ0h3TG1BR0tBbjR6UC91NWVGRWhyZ0FQbDdESXhqV1o5bXRqR1BOWUFUTWZkR2U4YUdrQWcraG5pWFFCZDdWSTVRQkxpN1BCZFY1SzFZb1Vwck9BcTZBbnoxS3lhZ3Bmbk5lYVdSamk1OGJBMDN3a3dzaTRMamFOcGl2WEM2dm55Y0RrY3RKU2Y4clROaEFpQjhIMStWdHRLdEwzdlM2TUVUS1duaWExbCtiZTltd1lJa0E0YWkyS291SThsQ0dERW5scVRxU2x2ZDRZMHhKZ2l4cUFscW1XbSsyc2NRTUozT25JUkFhRUdOTU9uTGpXbXBxZzZnUUJrcklpNVF0TVBmUTZ0U3BTUWJXK2pwdVk5Vml6b3N0aWp5c2t4dXFGSERBYkJWQ0FZVGZDYWE1Y1JhS00yUkZobmlBaXdrcWZyQjJGalc4dGpHb1VGY0JPVHZnUXhEMnRhR2hDYlJHWUFscjNhWERrTVhRU1IzWVZPS1pGSlpTZENybkpBSWYxMk9IZHVqall4c3lSMURpbG1Sa0F0bTdZZmhhdjNVSkJjejM1WHI3L1ZDRGV1dmhhZWZrYlI4OUU4bzhqcUJQbzN3MnNMNCtGLy9PSDN3Ly9XK1RCOERsRDBZSzhZUHJ3clRPTVpERElXWG52enZmQ1RmL2puOE9URnN6QjE1WEpZM3UrRTMzNzBKT3gxN1ZiSzZQcHFtL3JEWVhqN3pjdmh6UXRZOE95cHJhTFgxNDdEWXdSYkhocTZjdmxjeURUeTFDNnVoR2VMSzRnZjRrL1VOQkttanRhMTFtMk56cndjQlF3Tlk1S3NLZExLdVVvMnRVSlpHcHZBYnNvWktEYm9zY3oreVpoSmhZRUpINEo3MGdyUExJMUlOMXBYL01qdlBROUVIaTZjY1dTdEZvY1RXMEJlOUdjRW1kTy9DOUNwZTIyVHlTSS9wMHNxWXYrbm13OGw4RDR2aUcwZmxabS84MTdTYTQ1dW94WDQyUGNhbTR1L2Q5VzZ2aWpwdnVZeU5NRkI4MHNWbnpURisvbTFYV3VqNjRla09rVHdLbUJZZExTMDFMZ0dMdktFWld6V1dSMlRQNkEvbmdOMUdqL1BvN0lFTEV1TUI2c0Y4c1ROay9pZ2l0clFFVEZSYmlTZCt6N2xUSkZZc3VWKzhrYjBxdGkzN0ljZi9pN016bzJIY3d0emJBWnZac0VHWXl1NFNzZTlkYkk5NjJHdnRjU0h4M0FQaUZLZUVrQWthR2FNUy81TW1EeGhXbU5XQ2k4M3lVekl3cmtTZ05TdHNBVk9odHV5RUZrYXBpZFZaSXhHNGRSV2kvRVpoVHpMNFVHWTNNdUUzMEs1eVJTZUNRNEFRb0N3ZWxoK2JRSzl4clEyOXpZb3JMVUpIOEV1bUVUNFE0a00wQ25WL2dOY3VpRTFiMkpoVWxpQkh1d0FZUnpUMWxnaG1xaW5DQVUraFBrS3dWZ09vNVVENDBmVzk1QmdkTW5QQTlYMGw3QTBpWlg2L25mMk85N0NacHJWTUdiaFh2Q2ZCSW13dzZraWpvV3dRZmhFbDVBckdwRHY4MjhIRGpqc280K202V0ROV0dpc2Rra0lTS0hIcnJLSFE0U0s3cWVsSGNoRnpIeXpueHl3bWlocUk0UXZOL1p3WS9NM2lDWUNhYldzZEpNaFNpN0srdm5HVjU4SHRVMjFzVWcxcmVVVnhoTzF6ZzZPSkQ3aUZzUk1PcGpEV2ZabW40enRNZWZ6WXVtWWN5UW9uWnVMbzhtT2pUTkNKeU8wdEVtWDlzRW1keWFBNjMyNW4xWnhVcHVHNElPVzdKcVFTK0dpcldiQ0NobTlQbkNJSTVJY0tZTGphZUFxNjNjWHcvLzBQL3dORUF1WURBdG80ZkowK1BYUC9oVCtqLzl6R2Jmd1lwZzdsd0k4bWc2WDVuTGhCMzl4QlZqRFNyaS9lUkJlRU05NmhGTDhsdzhmaEc5LzhIcDQ1YTAzdytlTFQ3Q3VzbUh4NlVaWUk1R1FJK040Ymo0VHZ2UDlWOExYMzczQ09EZVljUWVsMXNsUTdyTVlmdi94STVTSU9NVFpjR096RlYzTUM1ZmZ3RkJ0eEhPdFl1R29XTElxRUNsVWdjSmhuTFU4aWwxcG9aa3VRdEY5MU5xeFY0NDk5M041aG1ud2ZDYURZblVHc2NGVGEwT2hxZGl4azRNWmtpMUxhZzhoU1dneWcvSVVlVzZJSThNOTA3cUxYRitsd3dkeFdURUtvQWs3ZFdpWnVDYXRiSWlPLy9FWnJCaTlESlhqbWFLVmZuM2xXY3RwTEsxQ2dXbGw4M3RwUWNOSHk3QkVRc3I3V0thbm51Wnh1QjRHQ004dlQydGhLVGprYzI2QllTRXVFdjR4SmN5MXROVDVDQU00d0VZU2F1QXhzZXFnK3NoanlYcmpNQlNVVTQwWkRZMW1IVGRjdHhlZ09sbGorU3FCbE9qZDBDUUFlRXlydXc5ZHVvZEpmQzRyUFArTGV5L0NTOG9nenAyYmh4Z21FVFpqM0p6NndTL054dTRKOHdWSkh3L29ZUlJHbE5iZ25xUzFxdERrcDdnRjRaUjJHYmdyYWY2V0doTElsa2w0MmhJbTdNdzBMc2JoU1ZoYVFtUENKTHFZV2xBR3huZXhvQTdBVmVWWXNKL1I4bkpoQmh3bm1pbGdFdHdIQWlneFJzd1NnVnAxbWdkUkl4bmZvVklmSzdDUEtvODlxb1JLd0J3RlV0dmVvNFgvM0NiYm9jSklVTXVKRllVa1E2aDZRcGpDV0ZvOUxBbTdwR3JtSzJnU29hcnU0Q0RZTkE4MVN2eElFTnBqYUJ2dUgvL0dkNFdBN1hzVlpDcS9LTmo0QVpKQ1FQRSszaTlFUVdIY1JjallmQTd4aHpEaUhoeThyNEdXRk8vbS8rSkw0S3NXb2NBL05wTDdzY1hzajhKTytLWXVBcnVmV0hUOFhVS0hwbmxPM2dkUllmWkJiSmpkYUN1bk9TcytuV1hvbXBPWENHS3RBY3p5amxvWlJjTHpSUUlHZ0hsNmVzRG5FZlRwZlRLcFdLL01wbXdqWFB0TVJiSThKY1ZrN3hhTVpBS2pCekN5ZzZJenZoakJ0bHhuaEVLUWVJV0hERWJnaWl6ZjRtemNremJ1a20xdDVEK1pSYmVpQU94anJEWUtGMmhsOVBUeHc1QzUzcVI3eGpEOC9xUFZjT2M1SFRUbWdEa3NOR0pjcWc4enoxK3NVWFFObUhVUlBGZ3JGVDU3dkJVcXplVnc4ODBQd3NLbjk4TkxMTUxkWFVxRnNJUnUzaG9QLys2Lys2dnd5bzFaTENIMmdGanRQdTJRN256OExQemtweCtGcFkzOU1FYXNiZWJDelZBdFRJWXRrUE9uR2VvaEFVam5xc1MxaURGaVZMR3hucm5aTnBrMUdZdW1oWkMzUHh0UGxnZmliNndQQ21BZkZWd29NNVJ3RkZqUitvU2hlVC93dDFoN2F4dWVQaFpUbXpodm43aVh5azQ4bVFJaXRnODNOQURkcU15N0NNZzJjQktWbUtEVlUrZ21DczBZKytLQ3ZGZSs4ZnBHWnN6STgrRklpL0pWSW1DZ1FLNnRIeEN6aVFnZUJaV1dzblJoVE15NGxGZy9TNHFTbnZnU3RPZm1FeWF2Tk85eElvN0I4UXA4cWZJZm9PVDhuTE1ZblRtUXdjWFhBMUtBRi9BZ0JCNDdhRlozbHQzQk1pVjh3QmNXQllvVDl4cUJKelhMLy9LUDlxRW9BQlZ6R2hCZkRNNURWeFpyWjk5Nzd4M2NON1RxbDBXekI0ejhidEVIdlZZblpsUVpwMlV0SFNEWjJBRjZxNVBlWk5ydUttVVVGRDJiZlNBYmswa1JSS1VHUzdoQkptMVEwNjZmbmdwTWdIdFV3a1djQkl6NjZPSExzSWQySFJIbml0T2pzWnlhamNrd1RubVBWT3RDZlJuc2RDM0xLK3NzbkZvMWhGa2RiSXArZHJWQ0hSdkVvbXVKUWNYdkJMeEtoR3dLOGE4dVZwaWI3V3kxTklkY0xvNFRXd0t6UFdBMklScHYrR1dsdmN6cDRXUXdUU0VKM0ZnWkR2d09na3R0RUlHd2JPeVpadkxRM1R5L2VNZ29URnlyaUdqakdoNjM3TjlIaUhyUVdZS0pmWjRkY280TXFUVWtwbVdiSUd3THdTN3FOOE0rUUhvOHQwS1EvZUpMa3ppNkNBb0ZmaXZkdVM5MjJleXp3RHd4amk1Q0swdVF0eWlSOGk3b0h1SEFHL21kWU1Vc2Jvb0kvUXo3cHZDQ1R0Z2ZMRUNZeld0SFFRdno5ZVFjWWd6V0d1cEs4bURzajk2QWNSYXNLZUlFRHNqc0UrQzFSNytXcXZpOEdTeVJWNjdmWUs5NzRUbFlweUhabndQNmp1L3VFQWltanpwV2ZCVGNKWmpVYnEvRnNUeVdNaVBnQ0RXVUNibzNDTHJ5RnZiQWFlTXdySXhJUEN2UUoydDBPaFgrOGNjUHdnZmZhb2JYM3I0VlZyZUc0ZW56N2ZCaXV4WHUzU09qVjlOeUp1WkkzZUxRNXowb29QQ1lkMGxYaU5USFQ4SUhYNzFCamV0YjRkN2RlL0daejg4M3d0LyttMitGTjI1T0VkWkFrTEpYclI2RjB5OVd3Ly8xODAvQ1M0cXJwNmJId3ZlLys3WHczdnR2aFBPejQzeXVUemVJbGJENFlvMTdkTUlOS2tHS1pEZFQ3Tk5Jb1FRTm5YRC9ETGdzWTQ0WkZUVWswUVA1YjhsV2JQVk5mQzh5UFFLc1M0eldMODgyMXFTaXRGdlFxa0Zwd3dzOWFEZnBCUWMxS0IrOEp2UWlqVXAzUmVLMldSUy9BcWtJRDR3d01FNDRJOXNsbVdDUzEzeS9icDBDVk9WakxWK1BVSS91M0grMmlLQkwvbTdJUWt0SkM4dXNvblJuSEFuTEF4S1FkendkNzg5bXNaNklxQ2U4Y1BZeWM1d2cvZjBObUV6K3kyTVZPdWxieTlDS2pRelBINFAzMERGUHc3LzVvcy9ZVUFBNEJvT1lMek9RTm83VXdqZHVKLytKN1R5a2FGNXVpUEU0MXF0MWVqWjl5L3RhbmtSR0J4ZXVXWXNMOUlNR3pQYjJxZnM3TG1IdGpIT0RTWmluZzU5UGNUUlFocFBCRFB4QkpvVGFzVzd2QUNIRzRlTCtxQjBzMWJHL1VEYmQ1S3VCMUdYS01DREFiN3ovMWJENGJKV0ZxWUYwWXp4RXNTOElGK0pUdWpXYWd4Nll3ZW5Ca01BcGdmdERoTWpXMmpZd0I0S2dNaEVQVVdaNmRKMEhOZi9WSUxOWWdCRW1SUHdDcG11REZIYWd3akU0SXhiRXhnQ1ZJQU9XaHBrMHczVkR4WFlaSkJmc09jSTlGY0d1YXlmdXBBMGp5dHdLVHRlU3JNbURWNEJoT2JMNXVvWVNZQkxQU3pSbkdnWVNUbUE3NVRiUGVFS3NvSVRBUElUQWJTbnN2TDREVEtVT2gyandYSmpIQU8xaHdOMEQxY1l5a0NvM2o5Z1RyVUlGV2RKM25YOGpUWVpvTmp0T1pNeVdvcTJjSTFoaDNWa0FpMFhLTm1wQVJmb1FvOE03OTJHTVl3Ui9uM2lFMXFqclZWajVUQkoyaHozMjNuZzhNQjdaUVd2b3VMbEtLSzJiYWZDZU5ZbUR5WUNpbjUyc2hoc1htK0hLOVlWdzljWkZFaUV6Wk9iTzR3SWlXbm52MHRMenNMTDhtRDFsUmlEUFVTTElYRVhMcXZocTRLNnF1UGRXUlRScmRoNkF5Vmh6ZWdEWUU1UzV6UkR2UG5wT3I3VThRaVNORUZrUC8vNi9meXNzekx3YkhuMnhIZTUrL0RMY2ViQVZuaXhSTGdhdElIWmhFT0lkQ0wwQno5c2xNVkhZYUlXUC8vZ3M5UGRRY3RZbG9xVGV2SGt6WEp3Ym8xY1hSSTBycGtINzZPRlcrRi8vL21maHpvdmxNTmVjQ04vKzd0dmg2KzlNaFlXcDdjQjRUQlJkazZrOXVJNHpkUVR5ODdCekFKcWZ3SHE5VE5pRE03RWx0QzIyazM1aDdCczBaaFdGSStsTk1zbjdlV0pxdXJxbnVQQ0pLOFdad3Z4NWxLdDk0VHJFZ0ZRZWVobzdUTXAyNnBQQ2FXUXNGZWIxUEpKWUZFWXNOSGZLZWRtaXFGNHBFcytDdnVqeXF1RFNpekdXcHNBeWVHLzhKeXBYM3Uvd1Y0V2NMeTFaWHdvQnJSalhFai9EejM3M013TUV0YlN1RUlzdGRsaUhNelZWaW1JUStVaDh4WWFPQ0xDWTdNRUlVTHJvUVdnaFJsR0hQQm15dGo1RFhDMjBWd21hMk1uRFR3UDVHNWxwZFFaU2o1OFJpaUlMWEN2L2lVdk00NWFhWGJUQ3hwWkZ5cE9EQXpHV0NEaXR6LzZBZ0dKOEFOdXA2TU95YUFLemVUVGhMa0hZcmFObFV2OU1DUjdUMVNPdlFWYlJQdXcrWEI0MGVqRzNoOVphaGpsZW9HVklOeU5wZTJ3TWNoUnBxL3VJQlphYkN2V3A4K0VpVnRnU3BSYTZFZ082T0dRVWdqNGdER0phVmY4L3l4T2xPSlFUTEpES2VEVk0wM045SGd2dGdQNWJ1OVE0N2pJamNZUDZzdFZUbWdoQ2dVVWtzSzdueEZndE5NbXFWTXZUZktITnlMSzE2VWN2NUlLbFl1NERkY0RGalNETmFHMGhzTXpvc0pFQy9VeEJ4OHA0VS91c1ExZFpOMHd3b01KS2JZV0VRaE5wQ1NGVVl4Q2ZnMGRnS0FTZHM1Y204MWZnZldyZUhpN1VnTVBZMHJvQmk2SWkwT0pKMnBwd1hyeGZJdkM5WGwraWthQWtWQ0VQV202Skt3cFJhbXJ4ZCtOVGFwWFlZUk1YdUFIREZmbU1BRm5qTmtja0tnNHh3WHU2YW56ZWUrWE5xR0xkNmI1REh0RlNFakFGRFVJd0VMalpSRWh0b0FzSDQ3RWM5aDVhNEo1Q1B1Ym5wckNRR3dTdGkyRUMySHFONERUU2x5bExoWEQxNm53NFBENEtOWWFQWHBxdGhzMUxGQ2V2TEJNQ1lOOEo3QnVNcnRVTlNJTXNwejlWa1hXVkVNWTFoT3NJNHJOVXEwelF1TmhZQ0QvNThPUHdMeC8vS2h6eG5Hdk11RnpmM2dNVm5nbC85bzJKOE5XYjlNVjZlaHp1UGw0Tno1ZWZrMkF3aTRkRjBxbVMyT0ZNRWN3ZGtQZmRTaXQ4NTd2dnNZY240WTkvL0hXNGNKME9zdkNzT0xuOWczVDQ2TlBWOE9PZi9qWjhmbitOeEVJNnZQdldKSDIxU3VHUXJyaWZQQ1JZdkV2bmc5SStWdjlVdUh4eGh1bFJFd2pSMWJDeTlDUnNieWFnYVNkanE3QzB3dTFzY256SzNBTVE3RnFLbnFGVkdhZERsQ1ZWRlp4WXBCdlBVU1pNNFZLTGpOK2x0RW1HMUpNd3ZHSDdjRnQ0bnhxRDRqeFZsdktDaVRBdWlZSkNITUNrRGpUR3pzT2dNQTVzK0NLSlM1blo1dTBvUm1rWStqT3dUVGlrQndCWUpaVWtzb0NyOEhOTU5NbTd3aVdnVmEvaHV0R0IwQW44clRYM3BmV2xFTXlqV0V4dFNadFJpZk1CRFJPdkE2WHdzd0pXeFE3ZFNsL1FiaDhyeXpJN1kxUHhpL1hSYUJpTGtudW9odUU3R0pIcUF2aFAvQllLK3pUR2NYa2ZuOU1ReU9GdTFrbXdXV1Z3cG16YmRnVEpGc1JjeVJUNmpqS1hrWG1jZGk0eWdWWVZBSGdNWUhCbmh5QVpZODV0YzV6Qk9qTHVrazJQd1R6RW5QQURESmFmOURiWlpJZ1ZTOGNLYnhMaVhHK05OUGxqUGpQTkpTZGlKcWh6a0VoalRXZzNtcHR4UFFGa01pOEh3ZmVFTjVIQy9DQ1RxSzBuME5aMmh6aUFvUnlQRmVFUUhMcnA1UzFxeEhiNWJ0L3ljUXJISE1NK1ZwOElIWVpOZExoUER3dk5YdXpKV0N1b09CSUgrNFlaYlBGMEJzdktqS1lhTFZvaGFLc3VBckdEdGVuWUt0N0J3YUlodE1ZNE1HdTdGRFFPMXJCemdvU3FPUjJKbHIwcEluZ1BTWkc3VDJreVRVTXlnVkVnYzZVRXU2V1EwdXpXa2tPTGNkRHgzK3hHQmdGazdNSnJuZjFPeXZKbmNXN2VwMUxIZmNHS1dXT2F6REdFM01HOVJRUkZxNHhMc1grczBZUG4raElKQzBUSWNtMCs2MmkyQ0c4UXVpSkh5MmdLU3JSK2xWUTg1Z3Q3Vnc1enN4TmhYRGdKTXNxK1VZNWVPelFGalRXUnhlcXRvVXhrc0ZPc1Y4ZU9UVFNaSDhrMTNHZGhMUW9PQjBXNDExa0VsZXJXUFRSMlpueERkeU9Qa21GSDR2dExXQkJ2LytoV3VQT0hEOFAvOGo5L0dLNWNuQXJ2ZnZWYXVFaFc3emFNZEhtaHlYeUJHUVFxRGZxSWFUNzh2QnYrNC9NN3hFR09BSmtPd2cvKzhnMHdXMS9ER205Qkp5L0RPUEhUTm03WnAvZVh3MGVmYklEekFrQzZ0RXJjTGhVdTB4Lyt3bHdWaSs1RmVMWjZISHFaOFpBZmJ6RVhzUlptNjBmaE1vTDZQSCtmSTZ0NWhYWGQvYzFIWVh1SHpxWlk3bDJFZ1NHRkpzOHJUbTZQV0t3MWdPNmorNnYxWmJGa3JLWGwrV1YyNDdmU2l6aTNWa2NzMVJEdnhVd2pqQWx3V29XWVl0OGlWaERyUTM0d0ZvdldoeDVNdkNDSXVJNnZVMHJoRklDZWR3SEcxanZ3L0tRWFh3b0Vrd1ArMjdaRldpYWNQdmVXMWhKTGU0VGxyN21qOVpRSU5aYU1RakhJYjA4MDJ6RWR3bFB5cCtWMThxVEN5VnRZOWFLUWttWmRrODhzejV5OU5CTGNBNFdpKzZORkw1M3h5SHlHQ3lUTHhBTGxtc2diM2ttMmt6VjZMOHVnZUs0UlZydHhYT054c2RRSUdaUERvczVteVFUaFRjT1VmSWg0eEpBT0NMQWJaaHdZRVRaZGJGSjVySUcxUllCOFAwSGdaZ0dWZW5GYnpJcEVGWHVWeC8xTEYrYjVuVzZpUXVRSXdVV2RGbDlwaWxaUEFPdjF1c1NZYUp1Y3BkOTc3OGdLTTZ3VE5zYUx1Ym42c202SXREMUEyeXVQdFhyY0tCbmI5MlhKUUl5eDZXSlVQTGdoakpwb01Gd2dwL1ZRcUx1N2ZSaDJOeUVJNGpsalRCSXVFU2VMNVFZSUZ3T0lub0wzMDBYVS9lS1lZRXJnRytCaER1aFcwY2JGY0dxeFl0Vk16REZCMFNpdytJMlJLUVdQOFFnMWtNSW5JZEtrMmFDTUt1TzdaazF4NDNVS0NBczlqd0JkS3B6VVZJbTI0aERSZXE1Zll0Rk45VnIrT3psVk51Sy9mTGt2dk1mVThEYmxKa053TTMxK1RtSHhEbkV6L1Z3c1dzWGx0WGJQNFFjbDRnUnF3enpQVXdIWlhNWnlybERrWEtOV3RFQjVoT2xwVWZZK0R4ZUFFTGtIYmwyYkhtWVlyMkNJVXBUck5LaTczQW1icU1pTng4L0Q4WjFuckw4Y0xsKzdIaG1NSjhmMU54Wm9HY2Rwb0VRemxqckZ1dEVTWjBaV3JyeEZnYlhNaVRBWUd6c0lWWWgrck5ZSVUyU2NaK1poYUt5VVNmNzluVzk5Sld3dGZSSCsrT0ZpZUhwM0VCNDlBSXJ3ZFlkUXpQQXNXQ09TZC81Q1lHcGJlSGozcDdpREx5bU1Mb1cvL1p0dmgyOS8vWFVzYWF3cExQRVVRbmRJd3VCbnYzeUlrRG9JajVjSUx4d1M3aURtVlVMNFhqMi93T2d3WE5FdkhvYWRZMkl0VlN5OUhaVDBkREZzVnc0WmZqRUljeHZsY0k1bWdqY3VUb1JLWXdKYzF4T3VBZFNHY2k1aEJ4MEVvK2VtYStlclNqSWlVYm9xTUlWem9zd1VGQ3BWb1NVRjlxaGNuWXdDeXoxb1lnUUk0cFFlTXlnZ0FjUUtnck9ZbzNSZ0k4SXNTalhTaVF6Q3kvZWpmamd2SVFMRzBSS0ZveUQwUzZIbGV3eTQrNlVGNTcrTlRlbmFSZ0hKZVV0L2thYjRybUJMaEl5Wlkrd240cHhkdlE4czFBZ1ZRbjVLbjFwY1VEMTdDYjFnUVBBclhqNHZsaC8zRWtOb2x0cDdLTnc4ZDc5Y3F3SkxBWm1zeGIxTDRxTmEzdUlFcGRVK1p4UnJoRlZ1L0Y3REp0Ylc2aFlxbkFEVWNIRXVodXl3T2RtQUxJcXZwRnNvcmc2UjNRYmxLazZYV1ZsOUdobDVpdEtJRWtqMHBNa2VMZy9ZcTFOcW9iTHBlZHdRSGdtTk95TGJjaktFc2pMV0I2TEZxR3J2RW9QQVlpVDF5UTNZRlBndHVnL0pKa05rYkxZYXlRZVNnWklCamg1SUVwalA0ODRWMU54VzJxdk4yYTFvNmhKcktUZFlCeWtkemVVV1pUYjdjRTc3ZUFkZkhDd0xNWWd5Rm9YQ1NpRnpKaWpjNkVSN2VDOFlIRkJjQzJ2TFRoVVpUV01zcVNJV25RTExZS2J0UnV6UDFjRmlNMEN2QmlrZzdDeHN0VkJjVFdJSEREV3FRc0RQVk90TnJtc0prd2tGWEFvc0RZV2RSR1d0cHMrYWFDaWVtZnNvOE55SC95eThQSTNrcGNEVmxldHptSWhGdnJNMkNDbExUTkh4WWNRMWlSOHgyZ3dBWjVsa1Fvbis5QkswQ09NYzhRSHhSbVZibFpnSkpnUVFUWDMyK2V5VmhTSjJHTWh4Z0lBcTBGeFJGM2oxeFRaQ3V4ZldEb2ZoQlppNFkrWk5wb0VxdkZqWFBZWXB5QUtLM3BaQVhiUGRCbXdHZDhxRVlmdEFlWFdmejc4WlJEWXpWU2JlbGdNRWZQWGF4ZkR1MTIrSHR3bVkyeHhyaXZQNzVnZTNZNW5VOW5ZMlBIcTJIRjV1TG9jNzh3QThKOURVUUFYR2E5UGhHZVUyZjd6M0NiR21YUGpySDcwVnZ2dnR0MGpPWUMyeUQ1L2UrV1BZQXZXKytuSVU3anhxQVRRdGg0TSttV2dnTFVOaWlkY1dwZ2sxbEVITy96NXM3aDZFeXpmZkNiZmZlejljdkhRQjY1QXBVUWJDZWQ0VURMdXhoTHU1K2hJTG42WUFUSkhxMGhFa3o3b0xoRTRFY21yZG1kVjJIMlhPQk8rV0tCM1AwYSs0eCt4QzdCaktIc1F5Ry9aSzJyR0xyUzlQM2xpa0lHWDNUaG81czdyeitGTzJJSklsRWpxUk5XQm0zbXZJd3Q5Snc0WnA5QkMweEJPYVNxd3NoYVZnYksrSlRJcC9jMDNTV09RRjNpOEkxZk14dWFYRjV0OTBTWVhkRFBSb3ZBWUtXTXRLNno5NkFCcUFlRUF4enN0bmZTWEZ6L0FZbjNkZFNXYlZaekZtaDF1TmdOSnlsT1JjbzNFL0I0WFVVVVVPN0ZBUktMRE0zbWZJck1YblJzaWEvY3h3emV5OURTYVVZSzNrd1hjUXRXWURZUVM2R0VZa0xKWDhFcDk0SGV2eUtpeHFlbGlQWUxzSDl4L0Z3cy9wcVJrV3hnRWhkVzAwTnFSaVZpeVd6RXUwQXNHbE5nR0ZoUW1hbytTblVDSXJSRVlsZ3dSZVA5d09lOFJkZkFBUHpBZnd3ZHhNMWgwZktuR05NQTFqbWxNRXQyUHVlUmplR3dQUmJLU2ZFeFd1QkJmelpEby9Ed0RRRWg4UnZ5MkNsRWU0dFNla3o4c0lsNElId29wankyUVBPRzZ1UWxLbTRzQ0k2OWpwVTRGa2l0cVNoTmc3aStlM0swS2VVbzVqVU5FU282T1ZaSEl4WVk0S2syQWxKcTBwTmNrWUpTcVdyZmhNczdPekJCQXR0RDdnMmdreGE3UHAvcm9HM1NWVDI3cElFaDBmajBRVUtZSC9ZNmt4d2VBMVUyQjl0dmJJVENGOGRXbkxDT1Z4cGhRMWllV1pWWldaSWdHckFYa2VyWjg4RnFmcFlqVWs0UTRzS2R4a3Jxc0ZLRFJEOTF0RDlnZ2hhanI3QlZDVW94MWlrd1JRejErNmlwV050cVgrejFGUllVUU5Lam9qalhCc2Q3RWdJYzdJSkR4N0xCM2kraW94MkpCbjBOWG5xWGdtYnNWWnF1RTVRNTU3WmUwbFNpMkFjUDhlNWc4S0NJdmwxUnVYZ2RmWTk3d1lmdldyUitFWFA3OFhQcmxMTFNzUWlTeERWd3VwUjZGMXNNZWFKc0pmL2VWYjRiM1hyK0dtYzEzZ0ZjOWV2QWgvLzQ4L3hlYXJFQ2FnejN1SHNBQUNYanhmbmtaMkY2L05oOWN2TjhQVyttT3N1cDN3ci8vVk44STN2L092dy96bE9jNVBTNXM0MFdnTUpZb0NwL1p3bHk2bmE4dGI0ZjdqSjFHeFRzOWU0TUhvV2MvMWNtai9BcnhqbHRsd2lWYUU1d3psc2tlSlZlSkVwZ1Nta0NRN0ZDeTZTUEU3bXlHdFNFZWVWWllndEJhR2ZkS2tCZW5SWW1vNGlyMHlNWlM4bjc5eUQrK0NTNGdTbHM0U0FTWk5KN1FqL1Nndy9NcURNOHRUMGVINUpLMWcyQ3ZYRU0rSzJDVTBwSUkxTm1VYzIrOVIyTUMzeHFUajZMZEk2MkltalUwSmhZQStkU2Q1ajUvM1dsNWZyTmZ4c1FLUTFjRXZsdmM1OTlQWW1JWkVoa1NUUnBIWFQ5WW9iME5IMER3Y1NGS2lnL1ZNR0tjTkFlRzlpWW1NeXAwM3hSYkwvL3VQVjRIVFk4NlN2YW1nb2FvMWc0bkVqUnIwdTVvQlJ6VXhTWllGcVVvSzB4YXNKWEFubCtoYnRGczdESXVMVDdHNG5pTzRHaHoyRkFqMEtRNUMwNVlIQTg5OVp0YWFFbzg0Si9iWnFiSlozSWtxQWQxeDRnNkg5Q1RwV3QvRTlpY2JqK1RIZDNYTWt1TzVoUDFIUmlabGFoQzV5OGIwa0dabVRXTEpERmFHaDgzLzhMODlKSVBtYkF6ZjdaT2xYNU9udHMwV09GMWEraDRkSDVLcFl5TWhyc1FWNVQwd3FzWGFNY1lFUXhzWEVFYWdNTUwyZ1lnZ0ZMN3JpblZ4TlJJTmtXZ2FnOHNLbnpMeGlEeG10d2ZxYzZoMXQ3WTIrV0xPSGdMUHp4aDNrRGo5Zm9hTmlYZ2FEcHl6WnUyc2hWZUNXSmRvRXlFdU1mZ1N3SmZEcWgxcjJESVhKWUcxV1VJQTEzaTJBdENBRXBuVFBKWkwzSzk0SFlpQ1ZIeVh1TUFXUXRKU0d2dnBkMml0azBHb1MxQ3VWK0xSTGREcWxIamFqR1ZyWUlFVnNrQk9ja2RoNGNvVUZRUW5ZWDFqQXlzQjBDZzhXYUFMd2lrUWxpTDN0a2hjd25aTlBsZFVCTHIwckZzelB6SlJYSS9NekwxSXFGQlRBU00wZ1NZUWYydVRVY3lUVWQxZHdTcDZDb2l3R2JPKytkcVFGakt2ay9VN0NmL1BUeCtqZEhKWWVqRGQ2RGhjQXBmMVgrRUczaUt3YmhHM2NaYlZ0ZjN3ZC8vM1A0VTduejBQamJtcndFaWdFV2psZEhnWXBwZ3Q5aHJQY1hFS1lqL2NSZFB2aE8vOCtUZkNPKzk4blF4aFBVeVVTT0JneFJodkd5UGVhRXVnVU0yRVdXSjQ1eTVlQ1BYNVFyajcyWjJZSkdoaW9ZSUxod0hCVUoyUW5RV3pWY1hkMXBMVlN2RjVyWCtOSFFZUW5TcGQ2ZEpNVnhUcTdIY0N3alJvalRoQzJrWTNEWUZxZkZMUXFKYXJkSVNkRXkwY0FkMWNJZ282ejB2aVVBbGs0RW1GblA5SjkxcnRsc201Sjc0dmZyR2UyRTJVenlSOXIxQ0VaZ001RFlIT3lBVVVGZGZoK3RZTitsMWxvckk1UWVHcFVBU2NXdGFXMEtKMzQ5cStVUnBWMEVEWGZ0bERqUkpJM3A5NENiNUhJV2JUUWJQd1JaSmE3bzh2bjArYXNSMjNuU24wY0pDenVQN1FEQmJmSWVEU2lObmtPVEx3bHMwQWNWc2JsQzhNbUlBQzQ0RnhHcExKNEZaOG1Ob3Z6T1p6VThOd2xiTDRHUXBVejA4YkFGYzdqMEp6aXBxeDZpczArc1AwWGlHVGNuY1o2d1dmSEdLcmowR0FOU1cxY2xNclFRd0p3Z2NOS3NIYWNkT0RxWTl4WFZyZExpMFRDTVg4OURsTTUwdjBJbjdoSUlTUlFvTlBHUlBnK3dFeG9nSitUNzFHOWhHbTgrREZvTEI5dUlwWUQ3eGZmOXVTSElOaHNrZ3NpT2F3Y2toN09KWTFBOFdnSEdWOEF0d1lHYThqZ0cwR3FXTU1RU3ROTTZDbmdQS2VuZ2dtTGFlbUNXNkpqU2F6QWsrWFQ4S1M2R1JTWTNCdGhLSkU2Y3QydXZ1TW9CcUdYU2pEZjB0azdxMnI4bG45ZjF3THJ1VTFZNFpHTGNxNk56Yldvd211UUluWDQ4MFNpUUg1TWhhRG1KenFkSTRZU0RPSjE1d1FWK0VhRmlMckx2YXdpTnRrcFBZT1ZuQlh3YmZRVjhyaTd0TlRLKzNaTDg1SzE5SkMyaVRod1haQlBDTlR6Z1NHMStuS2NIN1dqR3NGalVuWkJHZHg2NVhwTURWekhvRHhsZEJBa2Exc1VQY0pWcW5BOEFaQms3b1FsdmtZeHpOemRrRFN3UlpEQm40VjZoSkR0QnpZMDlpdEVnSVh1ZTJnemdFWncwOGZQd3lmZmY2TUVwblh3L1ViNThLTlc4QlhTUHI4NER1dkEzVTRIMzc4azQvQ2t3ZWJVV0grTi8vMUIrSFdaUlFrbHZ1SVF2a0hENWZDcjM5NUovekRUMytQaUtpRlEranFoT3hsaW10ZnVWQUwzLzNtMVRBRmNQUmcvU2tJL29Qd3hsdTNLZWU1ald0Y2pSbG9nK2twcm5NQ21OZ09teFVBbzBXQW94bmFveFp3VTI5OVpTcGN2ZnlOMEtKVmRPY0FnUWZtNzRoeWtuU2ZHQzlDVzJiTVUzU3Z4V3k1VW8rOWtKWmp6QkxhOVV4VmtBb1F6MVJob1VJMENDLzlPbm5jOFdTS0FvV1hOR2NNYkVDTVdaakFDVENVRTg3T0VFa1VHbHhBUFRZa0NhT1FsTmNTZ1lXbEk4M3lNcXNNeVVFTEtFalc1SG95aG1SZy9LNTlmN2lYWG9uOGFZVkNGRWk0NVZaOUNGS05jaEZoR0dOTFhoVysxMHBPaExKbmlyRUE3VXYvTnA0a3ZCdzlCVHVzR2pCUEJCTTdvdEZBQnQzclVMd2NhWWszeEhWb2Zib2Y2RjBJRUNFYkxjeEVHQnE2aVBBamVEWldmY2pyLy9iZkVIdzhwQThWa3ZRUTdiWFhncUh4SHcyMkRTRDREYVkzYnl3VEI0SWhiMTVzaEp2WHA4TEVyREIrVEVNcTdpYzVwSW54MmJESG9NdFZNakRQbnoySEFYU1RNZ1JYeDZLbElUak1vRitlZUJEclFXUFlxc2E2UlBzSmtmazc3b2NIRDc1QVd4bmZVYWdsTHQ0cDFvdlpMQjg4RVFxQ0l3SE5JWGVPbVlHb3ErYkFWdU52Y1dZYjEzZVRZNnNaekdxRFpRcWRQSzVGMGc0akVTcldnTzNzTUdac1l3ZWhoYmJFWk5qSHhldGhoWWoxMHVSMUlySkhxdXVrU3pWTzBOVmU2R09ZNExZdDF1ZlgvN1pnVzJFcnNReXdIaVhRNkNKRFRUV0Fyb0k1amYxSndCNk1KbkppMm5Nb0NHNHRNZmRISWxBVFM0eHFuaXBRa2owcUN5Q1hlTER1Z1UzL3NrQVU5dWh5WUVyY0dFaDliQklpNXA0d1dodkYweUpHdHN1YWR0Rk9sdDkwZThTWFlNUWgrQ3ExcE5tMURKWDc5SDJCc1NFaWlDbEhvRnJMd2w3dVJRaXF5ckNRR3ZHdXByQUdGSk0vajlNOHFqUkY1cFg3VlFqWU55ZW1jTk9BVVpBY2E1SlJMQkYva2ZBOUIyT2g3c0V1MXV3dW9NNDJiWXdQNldvNnhMSWJZcVgyMk5RdTZ4MmRzajhDZ1hNSDRkSGE4L0NFOE1CdlBtc1RkM29jWmo2L0c3Nyt0WW53dzI5OUswd1F6SjZ0Z2xmYWVrZ1R2MHI0NFkvZURWY3VFVGNDYkRxZ3NQckR6MTZFUC8zK2kvQ1FpbzNkUFlnYXBkbGozOW5XY1BQbVpQZ2VnZndGYWxVM25qOEF1OFc0T2x6ejJZVUw0Y1htYnZqdy9vdHdjQXlUVXpxVXdzMTEwS2lkUWl4UnFUZEgwRHFkUGVkSk1Neld3OVFFU1FNbTg3UUJCcjljUk1oeUhyN1AzbXFRSHA2RGpPb0VKRG8yWUgyZElNd0ZPcHU0MFZ0QVZFQkxDS2tvSEJUYVdJYWN0WEZSQlZuT0pCZUtVOFd0NVI1Yk5CRjNHd0gveWNIUnFSUkRYS0F2UXhZS3dCSEd4UW5XcDVVUkNoTS9FN054a0w3QVhIbFFhMHVsYkhzbWhhTmxicDZOc3ljVlVGbm1pTnI1MW5iZUp3cFdZcnJSdWlKN0R1bnhXUlNLR1R0ZUNsT1ZteldvOGlPcEhPNkRuSURmL1RlTUZwVlNIdDdUV3BmMzVJc0lBK0p6Z21sekpIcWlJQVpIa1JnYldsNDh1MDB1dWFVeXdwaXgxeFdzVzJXL0RGY0kyVEJlbnIzYXhBeWwzbXBFKzVnK0JEMUkxWGt6eEkrVnc1R2cwZm45Y1Nac2svcGRvM3puTjc5WlJzc3lnZmUxaTlFVmRKcUtoWmt6TXpOaFpuSW1IRis5SHVNN2EydHJZWE56RTBEaEVndkUxMGNBYUpISW9HZSt2bGFGVVBCWVhYKzhGekU4MFlxQmlleHRwVWIyQUR4VUdWbW1IWkRGRkhDcUQyMmNTS3ZOVG85cE1pa2V0c0xPdUVJUzJGU2o4VXk4Tis2RzErVEFqUjg0Wm14bmY1dHVCblJiSmZiVXdDeHZJYlNPd1JXMUNjeGFlbVFuZ2lweHNObTVTekJwTTFwaXRvNXVjVjlSdVR4WUZFSzJqdWFJMkZCc1V6U1E5OVQ4TjU1bHlycUFCajdtTXdvWjNZYkp5Y240UEhGZUhQK08reUF4STdSOExyVlZEWmZzZ0xoYmpHbEZBcGNJaHlnVTJnQ2oyWDNPTW5IQ0NmNXRvSGgzZXhkbUpWWkhock1Ia1F0ZzFTWXJjSzRLczdMQ3ZUb1JwcWRwcXd2Y3c3TlFVQnNmUUk0bUxpMy9ycFJJVG1EdGFBVjZYV01JeHV2NE1WUU5sRU9zbHQ2c0w2K0ZRN3JOeWpoWkNLcUVzTExOY3BFdmhiMkppT2xtS1J4UjhHc3NzRXNTcEVPdkxWMW5JWk1BQUVBQVNVUkJWTnREQzVzNWhjRFRuSDlqK2x4NHZMZ1dmdndmUDJMOWRvUEZCVUd3SFFLZE9HU3ZpOE9wY1B2cWJQakgvL1QzQkw2SDRRZmZmdytZUTRQblo1SVRpdlhYZi9nMC9PeVR4WEN3dlIrVFFOUHpZTko2TzJGK3BoTCs0aHZYdzFkdVhZQXVjM1NiV0NJV3grajRITmdlTXVDLy9zMmpzRXJ2cVcxcThqdkFjMGJRWEtsQW14bmFLK1ZJS0lnSEtsZnhKRGFnejdWT2VOSTRDdGV1TlFqOEk5UXdRbnREcWlnUVJobndoS2VDcHRrdk03K2VhZWRrRFFXNHhPLzVPMVVDbEx3alVJaGxxWFJnM05paUNLR2lKeUhOU09NeWZKb1NLQ2VqcCtBNTdHN0l5NWdTOWJJb3RoaWZSVURZV2xpRmFvd01pb0dlMGFobkw5ei9HSWVFVG94VkNiMndobGFoSTczNG56MnZWSXhaRk5ZSWl5MjJHcWVZWFE5RzZJbnRpWGdNVkJrOEFNOTUvaXJLU05lc01hTFdzZXE4VDU4a21oZ3Y2M3NkTWlNSVhQZlVtQnNjUjc0R2J3bER4MytJRmJSQllaYndqSUpKeko5MWp5cXdETjAzYk9qcGM3RjA1SVBoQ3E1QzJSaUowOGp6c0VDTXN6RVlCOGxMWmJubW9qUFRDcGpEdHNmZ3ZFSVR1SUladGxGOVNHYWxHZnB2ekliTjlXTXlNRXUwQUZuQ2RBL1VDZ0puSUw2VW1KdG9aNExQQ2lVRjJGa1ArTTNORFlMTk1OVHViaFJpQ2g0RmtJUmJJNVV0bm1WMmRvWkZVem9Ca2xpWExzN3hnL0cxU2p6VXhQZFgwak55aS9WWnhLekVOVXZpd2ZOWXZGY3BMQkZRZXdYaHV6RzI1Y2ppQW9sSkVrbHNCa1lWWW5xNVNIQjErNWk2T1E2d0JzN0xqSTN1d0FGdTdna1pqVHFONTV4S2ZVSURQclZ4aDNpYk9zaU0zOExGdWJpMkpHYWpPd1Fna0U2Y1lzTThhQW5ZZ0wrdE9ud3VNMGdTcGkrekxTV1kzK1o4UHBmV21pOWpXMTIrT2p5YjJVVGpNcnFjYWx3UExNYW0wTjVhbldxbk5qOC9mYkhJOVNnaXg2MDFjSjkwbXVDRzdxK0NEL2RaQVRrelIwK3F5ZWt3TzM4T2dVNXFuVGhkYkwwclVVTm9Nb0JnMlJvajUxTm92OWhLaGYwM2RwWEczWkU5T2xqZk85dDA0RGhlRGtzcmExaWZPRi9FZUVhc1l6aEdHWTlhRktWUndQejMvVVdVZ0l4NFNvdWJMbTVHaVlkUTBNZTZNK2Z0TmJ0VVFZQlhPNWdLLytHVFg0UWk3aGtHTS9FbG5vWE0zdjVPTWZ5Ly8zUTMvUExudnlEaGN4UisrSU4zQWJLeVBscnJZdmlIMy96aVh2ancwN1d3RHZoNWJud0I2NG1ZeCs0MmdGWTZrZjcxOThLdGMxZDVEcXpOelJXNlEyeFR4Z01vZFdVanZGd1praDBrWTgxNmpsQVFxUXJNVTZZL3VZRjBCSFlXaXhOYmdtZkkwRkFQM2tEakgrNmZocDBqUElzMHRNSE1nd3hlQW9uWTBDd3pKQU9sV1J4b0FkRU1FbGpOMWc3ZzJSYU5Eb21oUmxRL3gyNWlScE1kaXNYNkVGUUswM0p2MC9kRDlqbUp1ZklXWWxJV1J5czBWRzRuclBsVUZ4NnJMdzNxTzRPRkxBalk3cWpDSlN4UjhyTVJoOFh2WXZnQXE4YTRZb3Axb3dKUldub1k4QlEyZFFaZWQ1MEtLd2FKSXRDS0dBYzF1cjRZK05kbGxFWjlmbFlJM1puTWlzS09hN0tBZUo3eW5QZk0rVXk4enpoYmpDUERYOWJqaXVGU3VjWnlPUFl4dnFCbC8wc2hjR01YVWQxbUVtOGFGdGJtbW4zVnJqQzVwanVwUjZiaXp5TEVGYmdhTW9hVnNudTBuUzBTa0hUem9DM2VCS056OFFJZnl2QkZpSmJOd3BVaStHcWZtOXBsdWpsZWVqM3N3TURyYXkvWm9ENDRIWmt4WVM2QmJ6SnhOSEZoVUswWEs3SUhnd1hpS0lkeHRIZ3lYbnd2RHJwWVJmT3RyUzNGb0tWQU90M0VFYWF4TlVQbUhnM2FLYkI4ZVUyM3gxWW9KeENKZ1h6TGF3NUJ3UnMvY1lkMVNYZ25Hd2gxZURBOFQzUTFZUzY2RmNiQXRmRXpMZzdqa2k3R2JZcnVJZTVQamZhMVJpQ3pwUW11QjFxZHBvTTdPMTJJRHdBc2V4SXhZUWdGM1dXMVd4MlhWMnN4N2htYXBSSVBBY3RVTUNzSEhIRTNXakJvRWduSkw2MUZBNG1hKytvaWcvRUdLRFdmRTdBZ2d0ZzRDTFFRdFNYdjhsSDRNRS9GWGRrRGhiMEVvdUFTZTJaUnFPdUpHVU9JeUV6aHBLVXdnQ0RGSlZYd2pZcnNiWllPcm1uaWFSamhiRldkdlVQd3FRODVPNE8xR1dvMDFYaWlsWFYzRG9sSDdkRHUyaDdwNHROR1ZONmYwT2pyQ1ZDRFBYNXZVMEtOMm5xemdNS1p3cW9xazZta1BuUmNTNDZzRzhKc2pJeU8xcGFKQzJuRGwyUnU2VXpKTStZYVNEUmlRaUc4K3ZxbE1MTmdzdUk0ZlBxbnRkQUJSdkhzY0FNQWFTSDg1WGZlSXl0SVRSL0NkV3VyRTM3eDY4Vnc1OU10SUFqRWRGQTJZN1FMM1Y5Zlphck9SUGh2Ly9hSFllSENiTWdRcHprbWRyZENXK1NuTC92aENWVVcyL1QyMnQxbko2SHRCdTJnYjB5aFhJRk1YTGc0U1drT1FObkdaQXlpbTJCUjB6c0d5NDY4ajUrdmgwM0FzcjFEWW9PNHVPVVN5bVZoQ0poWmR4Q0JUSE1BRlk5VzdtRnJtMmMwOGRKa2IyMlVwNFVrMUNGNWZvNk82M0tHV0dhNlQwbGNpemd2SlQzTy91VC9RTVNqZ2lGN3oxU0x5N2JDZnRjeWtnWUU1UXJpTms3cTU3MG1xay9TUjhEQ0pRZzU3MmRNMTlGYmNBRmY4QUJaVnVrSDMwVnU0VXkwYnJndTc3RjFzZ0xEVGhScXlVUlo4aTc1UmZjVjRhZ0JNVVJRR285QzBySW1yc0Yxc0JlaFNRUld6UDdpOXVKaUdwSVplUzFlWXJ6NC8wanJlamd4eE9GejhPVTFzd2hCK1RmcFErZTliRktJeFFjc2h3dnpQOTZqZGJpMnZoVXl0T0dJVXBvSE5QT1doK250eUNBOFhwODdnNHRnUU5uWVQ1bnNFSVVJWVdLcWlwQzVSTW5DQm9MbkVBWWgxUTR4eVpCKytUcGpVaGZuenpLd0dSVmpMMXBnTXJaeElIdmhiTzlzWXFGc0F5emtIbllpNUFFVDg1Yk41L00rV09JeUpWckVqTG1kSGcyR0czUFkyZGxoSFRzY0JpY3RhMk9hMjdIUllrMUVIcjR4bXB2Z1kreU1pWUFZS3BqZ3RpWmxJc2FLOXZZeGE5VTJhQ1BrZUl6cEhRTWV0SnpHZXJVK2xwTFRkL0xVQ2Zhd3ZvNHBnY21zYjBaQk8wRUF1a2FwU2hOR1ZSaXU0dzRybEE5eEEyMUNPSTdnR0IrbmtCemhwZ1dsd05LMTdPUDYrUEw1REpvbWhHUVVBVUpGWUZpM0pXRjd3TVlqS2dpb0d0ZlFnbFg3ZXRDNmE4OWZ2SXlJY2wxSkErVVhGdWFBTmlSRWlFaU0xK0FJWVFoU3k2RGlod2lkRG4yeStzVERUckFNTzNRTXNBVGlHTENvTXlGbGxENTdheFg5SVFGMGY1WklzNlRIVzFoWnA0QjFSOFJBTENXeGRmSUJMdkVtaGN4UnE0ZVhQS2REUFJDV2xKeU1rMEdlbnBwSTZ1Q3c5bUlIQ292WGk1VFhGR3VoVEZzYlBGc0lOb1R6ODgzdzZtMlVYMmtPMTZzYWZ2YVRUNmxZcUlUdmZQY05FT2ZBUTdBK05qY093MDkvL2pEODltUEtXMUswZ09HL2l6VG5PeVhyTjAyLzQzLzdOOThKbDhqcTlVaVA3MkdHUFgrK0Z1NC8yUXdQYURlelNlbk5FTUtmbkM2RjExNmw2ZDhyVnhodU1ZbjdTTHlPaktSd0dQTGdVZXM3cWNsWWkrZVN5VFhDdTdlbnd2TFNYbGg4TG9DYXpPYkpMa3JnZ0djbDJFN25DR09BWXAzNlFEeUt1VmwrVHcwckZsR0ptSTFLUVdZM1lNNVJjMTBFZ1B3TVE1dUlzVElBQndmK0ZndUpRRUJZMmtkZGhTeXNvUU11MEU2aFdYQ05rMU5kNkt6Q0dkaVhYaHEydFRqTUhBMEZhQVZobE5LcTVXeWRxRzRHVXI1UlNjamI5R0Q2VWhBWjFJZldVSlJ4U2pZOGYwSUcyZWNsZU1TNnNMaDRPNlNIcGFTRm84VWpIL3VlQkFKazdEakhOUlVrR2hJbW5vdzF4WkZpS0d3Uit1NExUNVlvUXRhbWF5allWamMzWnZINU4rWlJ2RStzRjJTOXVzM0tCaE05V20rcWFydDlxUFN5MVhFMExZeURnQVdYb3pRRU9rQm14NzQxL01UaTJHNFdyWDlhTGxKWUNvNnFrOStqQUpuQ1ppeW9oWFBUWVkvNGdXQkRoVTBCQ0wxTFRQemV1TmE0V1dZcmtoZmFHMDJrOU14THdGaFVWY3BvSnFjYUNDOHpUQVJTOWUzWnNMalo3SmlDS3g2RXorbEYrRCt0R3ZGRHhrdlVZTloxT2ZEQlFRSFdtWW1mYWpFZHg4MHNZcHFiV3MyeE5uRkRzY09DRzhwMUhlUFZZQmpDRWRaRGl4b3RNeXV3WXJpRXRhV0E3cDNRaFpMTk80YXA3WnB3M0Nkbkd3L1VyQXpkUXhsZ2NVQ0F1OTZnMW81bnNGZTlzQVBMV0NJQ21yWHVnNzFTS0Mwc0xCQTdJNmlJUzZsYmFGcGM4OXc5amhxU1BmSzdjUUN4YjVyRldvd2lxS05RUkVqcG5DbXNGT0RSOG1STkM3UUVLbU5oYUpGT1R3SlNSWERsMFhiUkRVWUk2enJ2US9UdFZlSnpXQXNHNDNkSmRMQURDSDJZZ2VKczQxbGFDTkFiakl0Vzg3eFlXd1doWTZKZ2RYVUR1ckFFeDNpSFRJd0doekRnNmRndXhaS2xQQzYrZSsrVW5SWlc3eVlad01VTldxRTgyaVYyNG5taEtlRlV4OXVuc1BZbXA2dmgxYTl3aHNTRGlqVFlLeFQzd2hRaGdpb2RIZ3J2WGFZYVloY1hzQkRPelVrbk5BZmNISVNmL1BObnpDVGN4TDJyZzNjbVkwb1A5end6TDhjNXJ4OTkvM3U0Z3d0eHY0OUlKRDI2dHhLZVBGNE9pMHNvUXpMRDgrY213NXR2dnhwdTM1NElGL2g1RWtEdkdBS25TYjFqSG55UUFuRkFxc3VHY21hMlpEYTdJbmdtWStBVEozanZWNjZlWnc4QjdIS2VsRUtIUW1lZitDR1lMdlk0UTZ6UVJKVFZJWldDWFV6NUxPRUp6MHBteHRGQlFTQ0lxQWFRSG13RW9JdHNvMG5wZTRURnBlVXRLRmxJaElJT1BjL1pZSzNES3psb1J3R1hkRHR0UTJzVlhHMHkzSHpXZS9oWnJYVVdUck0vOWhrZTBzM1hjb2xmUE1jSWF4YTNBNXJ6dW9uckpSOE9FSEMyZ0VtZ09hNEZ0UTJ2R0Q3dzA3NGtpY1N5MTIxTVFrZnlNZFFMbi9HN0x5MGhPN0s0N3RnUytzeHpnS2RqcGhKbEZhMUx0aGZLZ2JZSkthQWhZelVnZEtVZ2NyK0x1T1pDbW5xVStFWFBBNDhuV2xrMWtOME1vZUdHaWVzbFZNQTZQUmxLM3oyeG1EUXhpUzhoN2ZkM2NRVW90VDBnbGxIRjNEZkRWUVNiTTRUZ1Z6YlhRNVdLL0tseG1uRUpFbU5qQm1TcFlqd0E2YXpRaXhxZldpVzdKOW9ieVpiSnVSajN3RWZGSkI1amN2U3g2ZkQrRGcrQzFSTVpHdWFBSVFab2Y3TWU4RXAwbVJ5bWFpYVJXV1ZVMDlPWmNtb3EvbUdmc2hYcjY4eEcyWE9vejRBSnB5UGtpd3dvSUhDYngzS1VHQnhxQWN0RjY5TFd3SDBJcVlHbXVrWDNpaXRaY0dSWWZrT3REeDcrbUYzY1k0TzNLUGcreG1WbFFoN2tTbWtSdjFjRDdkSWxRT3VqUVpCZHBQc0U4YStkMkVNTWpRTmo3eFBicUJMUUg2Zk14VkZIbHNpMFdhTW0veG1LUDdhZlpUL0xISmF3a2pKbmt5UHFxR212ZHN4aFpwT3dpKzZBeHkzMG84cjh3QmtDNlZhK1M1dG0rdUpaUVNCSHRPbzRQS2JjaUI3c1dsRUdPbzNUeE5iVG1QUW5kSmhzRXQvS2E0bENuRVg2UVRsb3RFWGF2NFFGTlk1TGMySGhZb3ozL2U3alA0UkhMeG1kVlp1aURJc1lHTzYwK0svdHJiV3d1R3BGZzExTVlUajJWV3Ixck1YTnBXR0VJblY2bEtXVGRTWmpCaVlxVGh2Q2tubEdwdmJSOG9maHE2KytGdDc3MWxzSVJ6cDhncDFxOUJwaCsraDUrTXExSWFERFFhanduQWRrUnYvaG56Nmh5eWlkTzA2cGFVVlJUZEkwYjZJOENMT05rL0RuZi83VmNPRktuUXAvR2thdXQ4TTl1b1orZG44SGVNWVNOSFFRM3Z2Z1duanYzYStFUytkbktkYk80cXFDTWhjZlJKWXZEcmZGaXVveXRxd1BRL1hhZExOZ3RxRlFEVjJjRXNOdE1SVEJwa0ZuZG03Zy9BS3hsZE1USmtreGx1d0VYTmpSSXRsaUZKNlozelMwMUlMZXRKWGJtSThLRTVXWG1lSTlpcnBQdVM1L1JFakFWTHlFR1poNDBjV3pkQ1ZMR0NHSGNMVFZ1RzUwaGV5YjA4akxWQ2xVMkhOanFDZFVvK1NFOWFDUXZiNENRZ1ZtTTBDRnlCQ0xEQktBZHZnWDU2RFNNblBuL0FBRmlabHZ1enNZSjlKU0VpaXVVRk5ZdUZhdkZYbWJ2ZEpkOHpNRzN2V1VYTFpDa3VCdkZKQmFhY2RrK0dPTU52S0QyVUhmcCtFRGp5RmJZc05DRmlTTjYyazQ2czg5cUpKVU1OUmt4bFBMUHY2U3BjVE92eGdUZGxzRlk4K3pjRk1FZlBiZ3dJd1R3aVdhZVluYjVzZGlKZ0YzSnMwbStsQzJIOUhFTkJpc0NTcld4Q20xWnRheVdaaVJEcUdtMTE4dXYwUUQwRGRwWWhvdHozVUlCSFpvUVdQd3pzNmNUcGZGcVNERHdPRVN6QzNBc0twMWgxcVluajFsZ3d0b3p0eWdFbDFGRDFCcHIyNk9ZNDVnWElQQ0NrTUQ4OFphRE1yWnRsbkFtZTVITnNmc1F6SStYZUpiTmdqekFQU0pCNkJuKzhSdFRLSGFBc2VPQVQwQ3VCWnJDbnVZaFJEZW9QWndnUVoydWUwbFdBcWkwK3BnclMzdU5RNWhuS3VleHRZdFcyUkdOb2dUYkJrd2pKWWlRMGdKa0c1aTRSMGNFTVJINHpmR2dIdmdwc2FVTXRmWTJ0cG1iZlFJdzJJUmFIaEU3N0ZEaE1rRWtBRVZoWUl1MWx4cFJ2TisvZjRZKzBBMys0cXRhMUFhWFlTZmZaUmk2UVRuY2ZIU2VRNGUyd3R6M2trMjI2eEJGOXRhTjRXMWJwNDRHR015VmF4Z2grVk9FWUJmWDk4bHFUQVdycnh5Q1kxbVhMQk1ENnI5c0xsMGhMVkpsUU4xZ0dXNlhOeThmWXZ5bHgrRlI0c0FoV254VXNSdHJqSHg2TXBseXJQS2I0WkhUeW1kb1hIZTh1b1c1d0Z4cXd5UW1vSW4wN3JlcE5SbHVEamVYWGRTc3d4bGNRcUdDUkE5Vmt3cHZQbjYxOEx6eC9mRGRzTllDeGd1Rk9JWXpLbEx0RVVEeUovLy9HNzRoQ0VVQStBWk5zMGJxNC9DVzdkb3Y0eHI5dlYzM2dwWDJRTmRxQmQwSVAzdGIrOWhXVzFoVlNrNHUrSGIzM3FEOTd5Q1VvTm1FRW9GdXVjNm91d0FmTm9tVEhVQUJySFZSUm4zc0phWXRueDhnQ05pejNzVW9jS2d5anBtcDJxMDhTYnpPWVZIQU1PVkxSQW0zUTg1UVUvenJQRXA4SjlOTEVrT2lzOVlzS3YxN0VzM1MzSGd5OUtrRkdlaEM2ZXJKdU5yTWN1b0NoWnI4VVIwbTVEUkd4Q2pWZUI2UW1rUzRDbE14Zjc2YzhRQThubWxqTitNYWJwZW9RVDZtSkFqZTQvSGdHWG1mU0xNQUtZMzdoV2I2R0hXYU9scElSbTBkMUNGYXlxajFIMTVMZHMxR3pPTFNSaG84dXozWHMvUE9na29zUllSVEx4UG9XWm1XeWlDQWp1TlFqQ21sc2E3eVNMOE5jbGR1KzZkUXRyS0M2RkVPVnBBSlNFZjZVWXNwa0JyazNrS2N5ZEhjQjlrUTdaTE03RDRrQUx3dUxtK1k2d1pnbGswd1dKQUdTRlJFQlRIdjEyb0FzdU1tbTFUTkhYZHdqWUhIYkVyTU4yVEY4dGhsWHp4SmR6RlNacWY0ZU5CS0Z3ZkFSQk5SeFlSVWVzY1RvYWU0YkV2RlJmeFFia2hSSzhrVi91QlRpZU93ai9qSWVBbzhkQ1lqTnhUcldCOHl0WVUvZmgrVEd3c0VHdTg2cUQySlpnU2ZGRVFORWtwamVQWGJiTnl3dWIxTVgySDlIOG5KODE5ZW1FT3hweEVrOUFISU15MW54RlgyWXVXbjNGRDlwbDljRzNlaXdHelBFT0QzODJRMjU3RUJWaGpuUnVzK3hCd1pOK3NDMFFxakdJZmE4MUp2UlVFZVg5SXZJWW9hZ3ZJd1NZdG84OWZPQmNGaEdQT2puR0JFOU5iQWt3RU53L0dkVGdpbnFIUHRSTDNVY0VQTUJNRkVZZmJTaWo4emZPWVdvQTBhTHZUYnNGOFdIcnJ4TllpZUJhbFVvUmdKaWJCVXVGV0dwZHA0RHBLd0EzaWJYWHdjNDhldlVBUTVtbWp3dENHZXcrQmxsRENoQ1hXUWRBV3Mrdmg4ZE9uOUtwNkVLNitjZzBveTJ1eGxjdzZHY0pPRzN6ZUJwMUFiMXdJNzMvdE5wYllkUGowMHkrdzZraDFxd3hoQ2hXZFkrWUxwUm1lcFU2V3JVTjdtSmRrMGV5MmdEQ0RmakFNS2JBMm96VU12L3JsbjhJTzhiaFhRS1RYeU56bEVlenQ5aWo4OHk4K0QzKzRnN0FpL1E3QjRNcmx3ci82MW8wd1AwN1FtMzV0NTRuWktRTWZQSHdaL3VYWGZ3b1BDWkNmeEVFaTZmQm43NzlPVWZSdG9Cb29NUG9ySFdFOUxiL2NDeHNVWkcvdHMxOGQwUE5BTC9yZ3VWcmdwdG9rQTJKdk1BU3RHVGpyL3l4MW1wL0MzUVovNkR4RHkzeUt4bmNKRGVTWU9GVEhBdXNRekQraExLMU1oVWhpQmVGV2M0Wm5MejBWbVZsdndyYlh2b1NXeUhNeVBKeU1FWUFiaHNKeGJGZ2UyckEvbWlFRWU2SWh3cUlnODNONkRjYURoWmdZOGpER0tXTkxlL0tYSHBJOTRDd2o2d05HTlZZYk00N3NuVmxmVEhYb2o4OUh3d05qZ00vN3ViUFljM1R4RkpyOG52K3hJQTBHMXNoYXBUZC9aMWdnV2tNWUVzb0RuME9wTEdEYlRycmVUeXN0L3A1dGNHMWFmdklsNWp6MGdDV09qSkVmTFNySUFLbVN2MjFDb0R3eFkyNWZ0eU5DQzBQeFl3ZzdvUnJhNy9HaWJscU1pYmcrVnNTNjRzdVVPY3NnM3FLMjRxTGMyRUN2Ny9IbEZPWVNjUHdTSTRBZDRGbGpJeGFBUUh6eGJDczhKMEE2TXpNUjVpYkd3Z3lEV2pNRUo0ZjBaVThSUTZudzhaU2JSODJYV2NtWXBXSmpUcmdHSzRuM1NWcTQ0SXB5UDQ0MS9tNkFSV1RIaHB3WkVsd3pkaDlMeWNOR29CQ0RjQk1OdUR1V3JJMVp6bDdTNmFNSUF5THhTWCszK1ZzWDg5aTRRUVVYWmdIUTJqV3Uzb1FCczdpdkpRUzNpdUNFRFhDRHVZUXVmM3h4RnZGblBmZ2Ntam1Md0pqQkhZWld3MHVFR1Job2ZHNDJHeXVESml6OHpKcDFpY2pRcVUwNndDTnM5TGF6ZmNDK0FNQWwzbVRMWGJPamlkSVFrcUh3OXl6WWRUNFBEYlAzRUJwQmZrR29jZkFGQWkyZUVlZWhKbHBhV1llWjdSU0xUK2llcUdnRWdOTFljQnlMMFk2TkVYZWx0alpqQjZFOFhWd0JoOFpuRUhUYnYvdVlyQi9CZFN5c01BVDl6NzNkMng1S3hxL1c4eGNVT20rRSs0K2VoZXRYWDRteFN5MzA1ZFZOU2p4R0JMQ0w0ZHBWVU9lakN3eDBlSUwxaDVLQjJNcFVSZFRIY3FEaUsxUkdBS2VvVFlDT3Z4bysvUEMzNGVtRGh4R3c3TG4ydXdoWWV2RnY3NnlHRDdkZTRyNmVEMTk3NTBaWUl1YjI0UjhlaDQ4L1gyVWRFbmtMUzZjZS91cjc3NFJMZ0RtenVLNHpaUGEwV3UvZVh3dy8vaysvQ0MvSTVJMklJWjJBZTNydDVuWGN3RnRZZWZTbUp3bXlSYXgxQ1JEMC9SVXl3eFJ3OThtNkRlZ3kwa2Z3SUovUVNnZ3BFUEp4aXBUZEVUaDNoNnI0TENldFBkeHJZazBvcWppY2hiOXBLVXhQTXRFSjVUZlhHSVZacWdEcThJSEN3dmhvdEZ3aUx5WDhwSlVTNFRyUVZzTDRDcHFFL3pnNExIUmRab1FEZjllOWt1N2tTN04zdWxjbmVoV2N1UUlJNG9qRE4xVDhLbTJablE5Q0YzeWhtUEJYb3hEU2RWY0NjQnUrY2I4b0w0UWtKSkFMclRWcEtSblZ4WFY1NlZacWpjVllLckhIYUJIemU5ZmxPcVZaQlZMaThYaFA0MmRKVGEvQ05jWUNWYVlJZGwvYVpSSDJaSkFlRjlETDZNRUovWEVQRGFqN095ZEl4L1pKL01PQkh3NmhnSGloZmZ1Tm9VaElzR1VueU81SjlMcE51bnNLSklWSHZKR21EYThrdnBWb0FBUGhpRFFXNjRNUUdrTGFpejBxRUU4b2djSHlkMk5ZRmwrNU9CdnVBVFQ5Nkl0bjBXOTloZGpORkl3NVNTRGJLMlJzcFl4L2F1alNDVFVqTnNHTmNWUzZWaFRpaDc4UnQ4cmlraEgzNkRDRjJub293WGgreHY1YlJjcExST3NhTi9CQkN3Z2pqMDVNa1dhc3FHMFJ3a01HWjZRSllwN1MvN3VEUUVTV2hTRVp2QVpXd0EyUXplTjdHNkdHb0lMUGRjdWRSQlRJVkNPQStkbkRkb1BaQ2owMXd3L0lDNVVEaW9xVkVEZ2ZReENPWWFYdGtJb2oyUmoyMkxkOU5zSm9YeDhUdkFYd3RvaTFVR0ZDc05tckhmb3FWU3BsU3A4b2xSa290RmdUQktRaTJDV1QxY1k5NGZ3aFZwaUdmWWphQ1dMbGtUZ0xGc1B1bkxuSktwTUR5bitjeFdkN1hudHFteDJkbkRLbHpuT3dUbU5ocHN1MTJvelQ3ZXhzRVF3bk9ZR0ZXQ1NiTmNMS1BrSWc1aEcraVFYTWc2T0ZKVUxyMm14VzJDTkkvL1RGR2dYWFBmcGVUWEJkM0lRVHBqSHYwNitiVGJsMTR5b0EyM2tLaW50aDZjVWk5MkU5ZERMbzRhTWUwekd5V2gyU0JTeUZWeTVlQ3E5ZHJZYzdmNXFuRE9jTDRBREVvU2phN2tiM0ZVd2NkTlVrRm5uSXMvd1dZZlVaVGZlZ1duNS9GTjJ4di9uaGUwelZvVjNROFhhWUpGNXFLK2c3OXgrSHYvdTdmeVljc1kvclM2d01SVFIvZmpKOHdHQUszWnNlU25LSFNvelBINjJGVHg2czBYV0M4V1BFckhSVDBoejBpSGhsaWxCRkJvRlJRempRVkJmWE9VZnloSDFFSURaSkJJd1J2aGhIOGU1U2gvaWNEZzVFMk1HUXpZWHJ1c1ZZaTYwZE96cVFCQ0N1NjJndVhaZ2svWlFJSjVsZDRhTWFkRHFPWjY2dzh2ZitiRHhMbnNyamJxZDFtWWd4cXB4OGFhMktqby9EalRsUFp3OGFQakV1VlRMOURZRW1OQlNwSDRyZzdCQVlFZjRBWFZrbkd2R0M4WDVZWkh4V25wRzJYQU1Qd3hmZk9lc29aTG10R1dENVNDL0xZblpmV2x5NmlIWnVVQVlZcDFTb3U4eWsveGJ2WjYzV0RpdXNVc2JOZU9iNDNMekp6eHV6MVNLRHRPTXphM0daTEl1TWg1TDN1NHJacktUcnoxRWpXNEdlVmZoaUxMT3pwTUgxMVhVN1lxekh6U1Bib0VUbmY3eEphNGVMRUEvcWttcU5VcGJyNno4Ylh6Q1FteWVEd24wSmNxTlpOYVBSOWxPNEF0Lzh5andwMkJxbEZrdmg5dytlZ3Y0aHlFdEF1VW1CZFlFYXNSSWFlSkxBWjFrNEs5STFqZERnWlBpQ2lOaEVNNFZLL2lwcDZ3NjFjcU1VN2dyeGtLRUpBaXd0cFM0c3lzYVJJa1Z3VlU1NE1CaFQ0ZVZoWTV5eVVMSmxDSzB4YWh0UEVJakhUSGs1N0dQbDBURmlwb3FyZExxSE1NSmRaZjNJRmovQlVYQTRFUlFYanpGcU9zNU9EekxVRlNRc2thUUZWcGlDaStmSGQ1ems3d1pqRCtuTXVZUDF0NGFBV2RQMUpHYlQ0OExPWGN3UVA2b3hUYWhGeVlxdGNXMU1PRWF2Y3lFUWFqVXpwSWNJclZRYUZES0g1d0ZMak82Ri9yM2p5QndkeHVyNDJkZ0tiWE81bnNoK0hGSXNHd2dFSzhIUjZSVmNpZ3pQb05BUzhhd3dQR1FZcW4zMXJhTnNFUXRLNGRab1NRbFd6QkRZMWJLMWg3dm4yUURMSmNBVEV1Ty9IT3RpZlZqYmg1aWNBNFU3bTJEcjV4RkM0aW05M1QvNTVIRjQ5ZVl0emhhTG96aExRSDhuWmtGRmVRdHdySmEzWU9vR2cxRno0ZElVdmJqZUpzaU9OWkl6bmpTcUEwZ0dNQXdOM3JoeW1ZUkVOZnpxRDU5UitrUEFmQURNZ1QwNEQ3RDRyLzc2QTl4RnVpOEFYQlhnU3B5QkxxUVB3My80KzkvUVdXSVhJUXIwZ1RNcVUyRDcvcnZVSDFKSzAyN3Zoc1B0RFhyRHI0ZTdUd25DdDNDVFFGeW5BQ3JtY0pFS0tKcHFmY0NnMTB5NE5qM1B0T2lrNkgrQ2VOVTQ4ekJ0TnlURVpvejRhQTNjWFhkd0xxenY4SHlHUXRCY0RTQTZFeVJRQnUxbVdGNTh4aDdLQzhTQ2lOK2xvRld0cW9TS0ZGaUtFdlkwNGY5NGh2d2l1dmdkQkwzWnRRUktKT01pOHZpby9HYkJlZzlNbVc3ZmlEUHUyc2tBSlYvS0U0K2prNnNBYktGQ2Rpcmg3ZHlIanlQMHBCUmZaZ3c3QlB4MTQzVEQ3U3hhUXNscXhTbE1wSzBzZ2lFTndKZVB3OWNLUU1RdDNzRlFkdy9GRmwvODBXbmxhRFB1NDcxNFdra1VXblNkcnM5blRSdzNyd1c5K25jT3hjeS9GcVB0a2RNeG0ybmNuUHZ5cFpWbFRMUkdSanFEVE5ETjlXODlqQk05cDdoR0Vtd200QWpMWUdheVA1cG9RaEpjY1pUR1NFcmJ4ZWlXSlA0eFRNcERKMjZqWlN5NFAvemI4Z0VscEVTc0FMT0lFMGduTVNONlljTmdieEhidURUeGFuaXdSamtMREx4R2V2d3hycUladkJOY3cybVlaWnpDNmdtSWF4Sk5XOUswc2JtOW1nZXozTTBxTVMyblN1QzREMTRLUXg3TDNjK2lFZEVRTXJSOXNpV0NvOEVlaWcrTFN5RkdPdCtKMHhHNmdKQTVabTBkL3AybDYybU9rcGZMV0NJTFpEdlRXRHljU3hSQUhwYW5yQnVwRnBRQStKaG40UCtpdFdYQ2tmTkVBL0U3UHFlUTB5WFZHeTN4Zm1mZDJUbWhUQ0M1eG9IdVlMM3NJOWtPdVBjQjF6NXAwODRaYk00ZUZ1TXVjSWNMQzllb3o2TnI1ZUY2SEZ3Wld1S2JJQllFay9haVpySmM2S0JLNHhrVkdLb0pROWY1dVliV0wydFNFMjlvOFI2MXJsaWFGTTBDMWNvOWlHUzN1eDNqWG9jZ3Uzc3RoQklFSjlndlRmQzNqNkMyMG1HS0lQdzRRbU5uMXl4bkp2ejVOOThCVjFjTmR6Ly9JMGh2QXVrSXB4cXU3QklBekM1MWtSMlNEWG53UHlrQXZDWTlqbWdrK1BUeElTanlSeWdoQXRLTWlNOHcyYmVJV1ZxRVlxdk1MeHhrZGxBMGZJWXM4TlhLVEppMDhCMExLVS82LzR2N2grRjNIMzRheit6YzdGeDQ4UG5UOE5uZDV3Z0ZoVFlUYktDTDcvM0ZHK0YxTEtzajRvdllNZEFhdzFRL2Y4VGttMzhoUzdrUERTS3NDTTcyVUd4djNiNUJoaEVJQ1ZpbFBaSWFENTl0aHk4SXd1OEIrclFXVUNUKzdNd1lrSndKdnBwaGZsWUFjSXFZR0xXdkNLY01jYjhDZ3RWK1lTbzd4OTZKZjNNNnRzelp4QVE3T056aWpJQ0R3SUFGbEh3ZHhkenB6SVNkalcxS2QxQk9TZzVjb0RaNzdBeUI2QXBDUTdvNlE2MGVDRXQ2dzdFZ3U1cWhhd2xVejNVeTBqSjhvMEZnNEZwbXhmaWtrb0U5eEp2eHNrbG5CUm9SZ0xYVGtoSHZGcE0xTUxrdjNXd3pYaHBQWGFvR1lnVUYzcE5DSUFHZnd2QmNTUGN5dW1ROGszM3ZWWVppdUt6UVVDbnpqMmhJWUJSRndSUWhEY2dJUDZPblpSc2NYVkN2NDhNb3RCU0taczY3dUc4SlpNT2tsOWhEd2tFc1NPc3BGdjl6QXgyNXNzS1d2YTFUWkQ0K1RzTS92QXZybE1XMzJlTzlpZ0ZpOEwyRjhQSWVOQjlBaXNKUUlrempneEo0RnRtdXBXT2NTT0NvVCs1WUxwdmdLYUFDR3FwQk1iQ1p3Z0d4QXFXOXdFUHIralQ1dEg0VWJFNWdHUTVvN2o4MkhjWnZBblhnVXJzVVVCOFNmRGJ3dXN2WE1mVmMrNVRIckVGUU5aaXhEaVpyYW5vY2kwaFhrWGdTOFFpWnJGSzlGa1l3ZUpiU2drQVcwRlNuWnJjZE52dTZpWmlMS1FoSzZUd2dCblNLeFlJc1FaaWhqUWdxbTJydWN6QnRySmdHakgyTkRhbjBqM2pHdUEvSlpraEJmSG5zMGE2Smg4RGpjZ2tQTUNvUTNzOE9SQmZ4UzczRHZ4SUJwbFNyWUFiWEVRS1RvTVBQYzVVV203NE1FVHhGZ3k1VExnU3ZoMFAyY0t3Sm5nZFhPbmErbUpna1JpTVVZem5leHdDbmdyOXFOaEVYdWt5QWRRekFiWW5Nbzlnc2F4eWRTR3h2ZGRKZHVOQzRkZ3BPaUtYRE9lNkNYOXFnNitvZWdybGx0VC9yVXBBcllTVTIzYTRlVGZmS1dMclhjZDMvNGx2dmgyZE1pbGxlUHdwdk05dnYyMy8yZXFTRjF1RVMycHl1c1FSQVV3U1g1eG5NY0loNzUzVGsyQ2N0TWdDYWsvNVkzUk9FU0l1SjBGZ3VURi9Gc3FlK0RneE5sbGloMXJUQTJnZFAxOEtEWnh2aHh2VXRMS1dyVkZpTUUwNEFLckszVGFKZ09WeTZkQzZzd3ZCZllJMHJmQU5GdjJOMFNuai92WnQ4Wm80WTNUWktpekJFTnhWKzlyUGZoYzgrZThCbkhSU3JoUzdTdjR0Yk9obmVmZnVOdUVkN1c0ZFlmN1NzUWFBMTZ6UGhNb05TWitmT2h5bjZ6MDhna0t0WSt4WGN1QW9XbWRuc0JtNXJDV1VJbWJKVkNCbXU2VkJiNlQrallwWUdrREJFRkNobnl5VzFwZERheGk0aGdQWjJ0SzZLZUFzT2JERndyNFZpRWJLVWFnbU8vZjdUdWtreU0xTnROQXlPcWJIY3BtcmtnR1JGRDBYanZYV1pvdXZGMzMzSm43cU1Zc1BxV0hOaldMOEtqREt4WTRlWG1rVHhaWXhaNDhLNEZyZUxncXBGYnlwZE9qdkUyczFEMTByZ3NlK05ycDIwQVQzWmg2b0lrTmZFbDY3WEhpR1RMa1pDR2hUOEtmVzd2QjJCQkw4Wi9EWjdpU0tLaUhqdXE2Q0t3dkJMZ1hYS20yMHRybFh2TThhMVFTdmlEVTJteVhPVEpIMVFtOUE1N3FQb1F2QjkxQWJ3blZndldYdkdib2VhSlVYUWdYWnAxbGdjbTBNRmpCb1pnY1hOa3JGQitxM3gvRm00eE02NytCOUxkR1V1ajl1WVZWQUk2TWV5R2Z4YVRNdUlJbW9NTlJZRi9nUVhTSnlSQUw0V2pmckdLZ2dIR0s5UTdvWnB6UEFGM2J6NU92M2V4NkptT2pqcWhXMkliNU8wK3VxREZVekVmcGlGcU1RMVdWeHRUVllCaHUwUWo4aWoyUm1qd0kwc1pvVXdBUDFGNGNobW1KbUQwdWg5aFRsTzNFcUpMclNoejZIME9jWFQvbTZZTGZmSUNMWkRYUkd2ZE9LRk84NW14SThtQWlyNU5jK1gvT0JiZVhRc0VyNzdNeS8zNmV6bGFIbzFtb2h5eVNlUGRlVWhXMU0xZytzekN6emd3Y0VvUEVhWUhaWm9pMHRjclFwMmJKOE9FZlBuWnNQMDZGSzRkLzhwek4rT3dNODY3dXBrYzV3TUZXMk4wVUk1THVaU0VnRUwwWE16dFgyUHZiWm1VOEk0UW91dUVhdlpSempTZUNNZTlsbFN3OFhhWTB6cjFUallPTzJncjlMSTd2YU5PZUpLM0FkbGxNdXVzdGRZbklNZHREWTl6OG0rUFg1d0h5UTd5UUlnTElpaG1OS3Y0MzUwaVUxWjh1U0VwVGJaTzRtY2dGNENuTlQ1SCtDYWt3RzJMZll4aXVzQUMyR1pmbFVQbjZ5RlAzNzZQRXlkdXh4ZWYrTmF1SDd0UnRpaEpjK0F3SGdMR25pK2lRWEhtUm1UYzFiQTExNi9FVzVmdjR6UURBemtQYVFuMTI2NC8zQ1JNWEM3L0p0QkpnQjFqWGltc1E2TXEzM3c3aHRZYmpib1d3NHZ5RmJERW1ReDM4VTluSU5Sa3hoZEFXeVhOYkoyczVSK1ZIeDJyaVhvRWkzbVUvYVVKWEJQRlFvTWp6VzBUVkZ5a1NKN2ljQzJNQ1pPdG5Ecm42eHRodjBXZEVVQXY4ZzUzYmc1SDRYekdQczlaSS8yQ0tPc2JqTS9rV3NvTUxURTBTbFlUQzBFbm5XbmdqZkpMREpJVk5kZUsxbzRpekFYUFpxWUNVWXBEVEVJTkJwS0tscXdYN3BpWmRaZWhnK2RtbTJRUElrTkdkL2tLT0RYQXRlMktOMVhFdHhQYURMSEF1ejZLdkViMzlJdHl4SmVNRmFxM1dmV0xvMkFzS2tmVVRMT1VnSEg3L3pDT295eEsraGRMeURpczZJNWx0d2p4cXM4QytQUXhKbFBzZHpFRk1iaEVnZ0s3MlVkYlVWQXFwa2JCR1FhVjdpUGdEY1dXc0l6Y0cyT2lCUGlaSnhiQzgyT3R3YVpzL3NudjREQm1td2M0QzM4MjFLaHdTWVo4RElveDJIeFFFcHNMYXNrbThlRk5ITkYyUExJb2xhVjZna0EwczB5MW9MbWdnRXFUazJwZ2FvR0YzUkVGcXBVb1NBV1g5V2lSeVYwQmJNN1R5QjlpR1hrZEp3TGN6V0N2eFBFSTFacHhyYkozRG9hejIzQ1JHelVPTEdlT3E1UUJwVHJLUTlnNWtSVFhmTll0OWJobktaSVJ5S0UrYmRXQ2RFV1hCQTJBb1k1cG5EWlVwTUtjYkJ6VE5XcG9WR1Fteml2Q0JlRkxJS0kyMFNoRlYwOUNJdEhWL2FoR2ZpN3g4di9jWG51elQ5NCtkMi9LN0J0MkFvOThYL0pOVGpYS05BYUhOdzBtbjhDeTJZT3R5Rk54NEJQeUVhMkIweDBvZGkzVUFWN3czMmFrM01FYkJIZUoyUXJ1V2dOMTBvc2wyMlBSWWw3N1ZUMFQ5RTRMS3hIZksrRDhOc0hISHBFWGQ4SmxrcmJWREJMNlBFQWpwOVNtK2xXb3BJNE85cXR3QkJpaXBxVXU4eUIvVnFZYm1LWmRjTDIybk5xOEY1QkkxcDN0MHF0SU9Qakw3L0tPcGo3QjFaczZlVUs3Z2xXQTVhMGpOUUF5VDlMWUx4VU1tRUFpcjVQVytGalRYL2NseTdkVkkxOXNDbmVWd3ZaMktieFNHTnlna1p0MkxpTzR0azhlc2FFbkdKWTNtRDlZSnJFTVIyTHhPWk1TMHphZWZzMVVPazNMa1JyNmU2OWwrSEpreFU2bEs2UjBhUjNQelNReGtMS0l6ekZMb2t6dTM1cEZpVDZ1WEJNaWRmNjZpcVdWSVBXTVBNSUpWUDRuaStkTFlqYmVKNk90UktRYzRJaVUxbWJiRmlsc0wrTFMyMlhEQ2MwZFJFQ1haSHBNRk9PQm9NNXNqVUdnNUVkWU4yb0djVFMzS0xaWVJ0clNWemZKUENSRTF6L09uQ0xXN2liT3lzYjFHSlNoOHA5aWlnZVc2dmtPZHN5Z2tUWEs0MzFiV1dFRUNHdHA1U1lCbWpXRUl2RjBrUHdaakVvamtzMElMQ3ZkVndvRW00QTNjL0g0NzZZTVl5SkdLL0gvaWFHQjk0TnhvWVFFQk9HWnZTZ0FHVUR2QXg5c2dHd1I2UmZNM1NXRkNrTVBURTNSNTRxNmhKRGU0NlYxMENCeXprWHY3UTgrU1pCUW1lVzRnZ01QY05xU1pzcXhpN1hCRERBbXM3V3hjMmxSdFpZSmtaYXdIUEx3SnRtM3JVV25KcGpqSzhQWHhxT0dXR1ZRNzU4QkFIRzNnbHgyTUFTelI2Zi9pd3lUeHBCTUdST1hLRnZlcHFOeldMWlVBdGw5YjFCYlhRN3krYUxuMGZnVnF3SDRqWjg1OWlSMkFaM2ZjbkV0a0JsU1RBc1FnbE5ycys2c1U2dEg1WkFEWkNZamRJc3lkR1VxWUFjRjJMUTV5dk5nUlVwSnEzZnFJQkl2Z0tUd0FnN3BMdjU3Q3JsRlZzZ2xwdkVNd2FVeTFqV1VrSGJjT1pJWkt3REJCWVJEMFVzYTJEVG92VG1zSkR1SmN6K2d1c0VLMGJJTmhCZnBaa2taajRiNGpacVhhazkvTGMvODc4WXJ6S1c1WmN2aFpmUGhyeU5CKysvZmZsMzl6V2VKWDlYK0xrVmV0WGk3eXJlZ0s5OCtqZzBJYlFSRE4raUJleVRIbjNTV1ZzTjAzaVh6RnVHRnJZT3ZrakRYQ244OWk2QnlSWk1aZG1SY2M3WTJRSEdPdVozMnhUWTdsQy9xVVhWeFVkS2NTWUtwaUh4UGxIMUVyRHhCaGVtcFdlTFd1c1paNEJSVkFqMGwzQXJLM3hsa2RJT0R0MWMyd0NYZFlsWUU0aDArdURmK1h3eFBGL3NNUTE4RTB6ZE5nRjM4VFRjeHhBQWpmbEdaQWRIbk1IOC9BVmNxNW1JUzhzUW0zS2F0QzVlR2xQZTNseVdiSFdPcUhja0J0T3hIQVhpZEdCSkZoY1NEd2dDTktTd0JJcWRPQmtZcllMYWx2WGFzK25WNnhmQ0c2OWVqb3o1K1lOSFFDR2VVR1dCUUViNGR4QWlkcUFVdWpHQWU0YjBzZkpjM24vbk5UUUt3b3oyeVpjdlhnaTFDZmFEQTdVeHBRa0lMZXdXc3pRNzIrRG1DQnBwUlIzaWtyV3doQnlwM3NiVjdJQ2xPcVorc3NmK0c0UFM0dEJhU2VGMm1tQnhXN1Y2REpMdlVlNkQ1OGdlQSswQkNWOEhxOU5rcnNDUW1yOVQxbmZsOWhzaHYvZ01xeDRtUkZrVVFmSkxSQ24ycG9LMnRJMTFsU1NObGpqOENnaFRZWXBOaUFDUThiVXVmQTJGOEVCb2x0bzROTGZDbHh5V2duOHlLSHlCcFFvckxSNi9DeThhaW5PemN5ck1uMlhkMHJUMzFqckV0SW1mZGZxVDkvSjlTZk0vaVoxbitkTGxjeHFVSEpVRnl5Vlh5RmV4eEVpcmxFV3JFR08zYk43amVwUDN3Q3NJc2hMQ1hRdFJxMDFCNjNkdWhmREVqWVZCVEVod1UyNkhGT0hiQ1lJd3JhVkEwb2hlNWloZ2hEWlNOWVhMNGk1VTJQOEdDUjNpaXZNUUVuRW8zQ3VuTnZmYkZCQjdRQW9xdElsNEpudndPTm5aWHQ1YVlnNUlUUkVUTXBOaE9ZRS9tK0Z3Yy9ndzE1Tmh5R29vQlZpSVk0T201aEI2Vk9FZnRqWWlRMHJVRm0rbUNXQm11ZllwVnNlUWhteTIvWFZDaUg4YjRGWVVzTjRhSEd4L2hsZ0h5T3lEb3gweVZmU0NwMVdOQWtZZ1hva0hpeFlKd2xBaWNFNWhBYVkzL085VUdZVkJ1Y2gxc01jbjJmUVNPNlNHSWlFV04xRnJ5Qzk1eGMzaFc1VHVMbDhoSlVGOStXaDQyYnpQMCtmOVpsRzlqa1NjWUplNER2L1cydko5ZUI3UktyUC9tZG9DV3lPOFFVRCtFTXRxaTVtUEcvMXhtQlpMRDlkd1NDWkxXNXdjSzZ1RzhUR1BCL3YwdjhjVjZYTHd2UTVsTnEwallnc0NSeEVnTUFsS2pCZm5nNnZScytnYkR1Uld4STFnSHZBclkxaFMwM1JWTmFndVV0cmFUelZ1RkdZUWh6Z2FMZWxOWEsybnk3L0VXUndMRStmT28xaUs5SXY2QTR1VytiQ2lxR1F3OEs5bFFKb0s0QzJUaVloZEdqYzhnWEVuR1FlWHd6cXZVL0FzZE1VeDVEVUdOcVF6MXhFR2JUclNydEFYYlpXRUN4Tm5hTkV5VktPbmp6anZET2NKaUJSdE80TEJ6RHJtb2JlclYrYkR6U3V6S0RyY3FRMndXWDk2Z0tVQzAzSC9Ec3hmQkJKU3crTDI1eVBjTWRuMzZ0VUxuREVXVTNlZitJaGRIUUJDRXIvc1lOMTFzVXpiWklWM2FCQ29zRy90Z0hLbjMzdVgySkQxbys1aEY4dlBXTThRVHdJSEU0V0ZTT0F3azFtUTBCamdVRnV6Z0kvQkdxVFNBSUdkdzRPNE1qMkZjRDFQSC9wekZGMHozR0poSW56MjRFRjR1Ym9XOHBjTDRjclZpMkYvN1FVOG8xSWlxdzBQRGYxaTdYb255REhPV0F5aFQ4SFAwSW50VjBZUVYyelBBcTFhNDJrbENCUUhuYkZPOEh3bUJkS3N0UUJ2RGdWbFE2aTZkeWFaeEhLZGRlcFVVTmlHMjc5SGQ0MFlsRC8zTy9DdWxoR1MwdnBHNlY0THl3THdERW96WWdDbEoraE02QUVyNHUvK215OHRkejZydGFrYnFyRGlxdEJHOHRYajcxcG5EZ3YyMmltZXdYVm8vY1c1aFZqRUE0a1hCYVg5MytQY2gvQ0ZadDhBWTZsUHE1NHNTWlVpazR5UTFKd0w5NFpleS9BM0luWU1DUWpEd0tVbHpHb0RhMElWREdDZUVPOXgyR2dmYm94TndGeVE1Skd6VWh3QmRFcDNnaUZUb1VkazNoeVk2c2g2bXA5NWNkMUNNVUd4R05wWUU5WkZBNkwyUkk2UEJuUXJzRXdGQ3dtTmIrSHRLUStCSGNUN1dBc2J3TGFUTmVsR2JFdWVCejFCbFZVdVZvam5wc002U0UyN1BISXU0SDBzcWtRVzRpWnN3OWdsbUxMTUFZMkIzYWh3Znh2SytkQmx0RThSRTNsS2Zja0dNSm91Q2hzVG85emE0dkZvVlpITWlOY3pSczNac0ErSnNOS2wwSnFEWHNna0lSQ1FjUFlEMGwzMVBjaFd0SnE3dzR2ckdjdGpDNklnNDl5d0hwS2Y4L2gvcjdMMlJ4QnZCOEhiNCtBUHV1Q0NTTkZuUmZ2eTJUWWE4QVNydFlXbDBjRWRjRDlpZlNkVzdSQUJyWUtRdk8wVzZuQ1FVOTZUb2s1U0s3ZEMrbjJDNW4velFBY21LWUNyQVh6VUJZZ3JZOE8wY3V3b1llYXZUZFoybXg1ZXo1ZnNaRURjb1hJdXZBbzBvREZ4aWE4MlRlL1d1S2J1bVZBUkxBSVVtbVVkbGpHSnlqL0UzZW1RUU5uYnFVYlhhNnlCVU1PYXN4S0JPRzFvVE0wU3FHZTAvU1VHcnVJK1BYbjBra3dpK0MvTzBJeHR4cGdTR2E0UllOVXZQcWFraTBEZ0FtN3pqU3ZuRVhnMTNNd3VDUGRIWVEyWDBiNU5BMkpLWXd6WG5acWRESnZFNmd6czZzcFBJVENud0owZEVUZnRJaGgyS0RlekNOdTIwQzNjNUFPQ3Z3Y1VmeC9qc2xvUWZ3cWtReGRVdUVXZkwyTXl0b3VHSWpnNDlnZGdzdWRvbzcwTWUyMzduU0lRZ2lhNExQRnpZM1EwSFIrM2xVNDFUTkxrYjRiR1dIV0VaUm5CWGltQzJhSXh3Qi91UEdZQThBRk5CTjhNZTRCS1Y5WldhR2FvZGNxYWo4anNTU1NjbDBJb2hlSndrbk9IcktZM1ZuRFk5RkJyeUV5aDdtRWJPSTV4UWljamE3SGtzVUpzcGxja3VhSENWR2dZeDlSb01JUmpWMW5qeThLQ25GUmpEQ2wyaTRDbmZHOTBneUhTR0J2bG1SVUFFVDZBNEpFbmhMUmsrWXBkU3ZtemxwOTA2TDI0QVc5Z0RYeGVDNHhmY0lhQWlMaUd5VFlrQ0h5aWJhcEJ3Zi81ZzdKRHFBUUJka3QxUk1UN3B4Z2psRjZJaC9KbkJDWHhPSzZ0a0ZidXFDaTBIRzMzNDNEZjdIRi9sUS9aSThuZ051UGxrZGhLUTdNRDFTb3RXZm5aVXBBQ2gzZ0NiT0EwbHBuZ3ZuR1RXSll6QXV3M2ZJSEdVRWp4SEVod1ovQmwrY29Sak0xUSttQzdqVkxtSm1ZeGxmK1l3bXFQSXYyMlBZUTJHYTJXcGdyTDEwcHpBa3dCOEo5VFNaemdZMVBCRnFiUUVLYk1Xci9GZGl3dzRITU1UVzVYQ2FXOGxwNmRCUHJnc2dZUWFJdHBNcXYwUkVjSFFVQjB5U1R6V01JcXFYQ2RTUmlQZUY1Q0dId1hFNGNYRThqb0k3UjRWcVJSRnV4Tm9NR2NUcThkRjkxbU5kd3hHeWcwd3pSMkRjRkQvemFLaEhFVFlVNk1PdHYvQkdMRlVXdHlYcVJpT1dnOFh4NHBsbHg0Mkg2Tm81M2ZwNjF3bTZuQmQ3SHlOdmFJVjlVV3NBcFZIanNRYTFKOExoRjVhQW1zeE5Wd0UwK1Zsd0pFNHZlM3RUb2RJb0JHMk9LbmFUWVJ5VldFUUUybHB5QjZEOXQ2TFVOZ3hsT084Y2UyYU1lemhpdTJUOXIvaEN3cUkyZ3A5QjRnVURiQzlEeUF5RmZPaDZQOWw4UjZqc0t0U3d2RXJjcTB2LzRFUEJuS3hFNlZQR0NpMVVIS1l3bnVIejRIcDJUanhrbXdaVFVzSzdKTTBFMEMyMmlFQ1N5aS9NMHJFYnJTNFQ2aWQ2Y1dGc0wwK2ZQaDgzdjN3K2NmZGNrT003VDBBak1BeVVpYUtQbnM0WE95bDVzd0N2RStHR1o2cGhuT1g1b0xxNHo5NmhETUg3RnVRY1lsd01YTFM4dlVEd0pUNFVuNlRQdzJMblBTZzBaUVlpWStET3FlMGxxRjB3bDlMWHUwajFhenpPYklPSWNENTBtTU9DVEJxbzFKMFBuakNQNnBKcDEwRWJxVjhRTEExZkdJZmRNYnNWemttSVRKTGlEY2UzY1hVU2pRQXBuUWN4c21JVkJDWU8ydVh3WXVrY0VTbTU0a1ZwY0tpNHNyQ0RZVUE0TlVVL0JjVkRiUWVzeThNd3V5aitXbU5TTlkwMDRGZWlvZEZITFdLTGpyNVB6c2dqTENNb1I3VWRwWWlLdzl1b1BTQ3M4cVlTdnc4dnhkdUlQNExPa24vcDZQMmNiWkdsb3RLNFdXV3RvZ3Y3Z3lod0w3cFVBN3M4aTZsSlNsa1RvS3ZJaCs1eHhpeGhMTFNybGw3TnBYdEo0VWNBZ1h5OExpMUN6K3JYQk5YRnpva0Eva0NPYTdYcnVFK0RKdUplS2RxQnEvNDNuaGM2RXBKYTR6OG94d1A2M1MwTGpYMWN4T1ZMOE9ZZGw4REpQYm0vRm1rclJjaWxJTmZPclVjQnhYNGh3WFpDb01yV1F6RkJXWGJBU0hjREt0YVh2VTJHVVFqVHM0cGVYd0FOZU9GS3FXVzRmK1BpSlhqMGNVQVBlWDhOc1JYUG01a0VkTFFjdGtxdWhKRHRqekFQZklraFhYME92dG9WWEFpT09tRm9GcHM2MFFFLzYveGJtWWw0NVd5c0dzV2tRWnBMSW1zbG1JZWgyTkRTN0ZYV3lQT1FpVUxBekJVMEdaUTFMT1U1aEw1MkRhQ2dlUzVUTmlyMmgzRllQVVdWeW5OTU5GQ3pEOFVKc2NkMVdBbkcwdmRJWHNuQm1GTXdkWndUcHdvc2NSSnIwZFA0Y3dmQTdCTVkzUFBZdUFKVndHS0ZITnhIY2UzMzNpRWxoTTdCZVgxZ1VvRUxtL2dvdTZnMFd5Q2JUajJlNVcyR2FvUmdraGJvcCtoQ2JWQXZMREZvMUxnaHdPeElveTBNVm1qWG5jcUJxanpLYUlTNDAzRVZKQUlHSTJ4djJLaE9oN2NhSFlmNjBpQjBQc0U1emZJWmk4ZzFza1lhb0Y1VnF1SEFuQzloOGJCT0JiK3hQaDR2eHNPTVF0MjkwQ0p6ZHBmNnZFMWJib1d1SzBONWhDeTU5dGwyS05tZ01wSERSYTBtcG16OGFiVTlSTzdvUXJWNjdDN0hNOG0raHhXdVRpbW9tRjBqcW9NK3loUnBYRUdJbVFWeTdQMFBpUGRrZjh0L3h5TlR4KytJanpCSFBHK2N6UE4zQ3ZwZ0NBUHNYRmZJbXJSaXFjNTlKbDJRTVFhNHNmbWZsVTNBTnJpOTBCYUR0amVZbmxYaDZHVlJIVzBKV29pMDBqMUN2UVN3M1lSS05SRFRNMElOUWlIU2ZBMjJqU3hwcFd5SG9jTlJpK1N2S2poTm1oQ3dmYlFlZlFEaDFCVmw0K0IrTzFTd2tSQWl6VGlCVVVxL0FQYnd5dnYzNDk5cFBQUUdpN1IvbndtenViWVhIRmR0d240Y1k1Z0tYQUJrWW8yUjd1OVFBWDhKUXg3RWhCOWhQRno3bXBaR3gxN2M5aXRpeFdWb2pJN0ZvN0ZrOExmVWhJQTFyeExCUUFmRSthV05xc3dPVFVtYkR5cnlwZlR4dTZod2E5bHVlblZaUzRuZkFHd29QVkpQZlNXTUdLUFNXMloyRGRLeWhja3JJZDQySEVNdVA5QUtseWpUTkJGK1dJV1dOZS9pNFJXRnlUNnczUjZKS252TzdmWEFPUEZUL3YrLzFic2g0OUx0ODRRQmtqZDNCVHJiSE1sb2R2b1FWWW9vRTFCcDRPUnBzNFkxdElzMjBFMGg0ZnRvSjhLejRBanBRK0dFVE9mRGlZUDRXR0crTG01VEtPcmlaR2tyNk05Q2JHeGQ4Y2xlWE5EY3dOSU9RQmxsa254bUVRT3JnZEJqS1AwSVRWWWhLNExaY3dpVDFBc0ZFdDZ2cGtJODFpUVd4UmFFR1luQk5FamhTRytTcVlMaG5BUnlMSWh3YnMyWXhjSkV5RG42YVlxV0dEa2V0N3VKSEx0RVZCNDVZUWZBT0lmQmRoY0F6eG5ZSnBLWkR4cXROTThBUUNQdUozUFc1aUppdVpiOGlkT1JCc1NUWWJEY2VHaXJNWkdCL0Q1WFF0NlFiWk0yRUVaTDAyS0s1dG9uRW1XU2RlSDZEVTVBQVlrTXZ6ZWhxV012RTN2bytURFhrVlJsMkNJVGJabHlNRXlkajhkR3h3dUM4UnM4WUVOSnBjdy9vL0lnYVVBQUd3bmJTRkRka294cklWWWFyWTZSSHpiZ1FSR0xEbklEa3oyQjVmZVJlRTlDYjkzZzBRMjNyWm1KNkVZNkJlVXhzU1oxbWE4MWpSdU0vemRPQXNrUWloSkpnTTNmbHdkN0JMK24yYlpBZFZDOEFzbkRna0k4UjRKWitXaVNSNi8rMlh4T1pRRVovWVRoU3JLK3ZBQ3hiRDdWZmZBQU5GUFNGdWVocWgyeWY0M1Q0a20zVmNwNGxpTnBqaGF3SWdObGh2b2ZpREI4KzRUNGZzNVlWdzg5WU5jR3Q1M0twRkxLNkhXQW5HN3pTSklYWmNaMXNWMmZUT21JNVdDeXpORjRrZDRDNWFCMk1JSnJ0U1ZNclQxRyt5Qm5yYlc5NWluYURvN2dLS3BvYkZPOG5YZE1RNW1Rbmw3eHhpSWQvRGdnWjd4Yk5GcVk2Z2NOZE1KSlhldUVLbjFZWHdmTFVUbHFrY2UwSXAydHJxTXAxSzZ1SFBYZ2ZKVDVBL1M5WENHZ1hwRDlhd2FqdnNPUi8rd2MwYm9kNmVEMDgrL1R6R2NrYXNJUkgreHBXaW54Z3phRmFiV1BPbml5ZUQrMG9FVmxLWjRyK0ZSSWlKMDlMcFkvWEwvSEh5a2ZSS0RGTGhFV05YbkpIZEhIVEhmQ1hDVEc4R2R4OWhoTnpBT0lFMmVIK1AvbmdLUmFSVHZKNzN0MHhNWVJZbklDRkFMZk95MllDV21vTG5URmk1dnRqS1JuUHd5NWUvUzF6VmhKYWxGNi9sZDlkMkpyajhMdjI0SGwvUzhDbVpVdkdLUXUyTW5WSEFqNnZBdzNyQW1kRVVZdUljdXdMQkljQk9DWXhHU3d2ejlRVGhaWC9zUGdMRm40Y0lramgzRUxlbWRicUp5U2lJYlJicmczQXplNktsNEdhYVRjaHdhTmx3aVI1UmFEbWVRM09YbFdJeDRZS3N2VVFiRXdOZ2ZIZURIbElnZlREamlURmdDbmRFMHhOUTlLVXBhMWNHWFUzQnBSSnpCdWxyOFhYZlBITThHS1NCbThmbVFzb0lHOHgwZkhoUjRVWGljdmJmMnVOWlU3aFFhVm9JNXdsR3AvbmJ2cHZQa216ZlloZFEwK0RHRFU2QVEvUXhCVzBmYThMR1h0VUROSVFwZTd0N2p0aDBvTGhJTWR4SFhKNysvaGJDQVpjT3JUVERubFB4d2M4c0RjTlB3MDJwcGVEeVBHcXNiWVpNeVN0a2p1NFRSRjNETXVrMVFTeGovaDU1d0lpUi9KZW11MFJsRDZRNlVJZEpBdllpbkswUnROaGI0bFJZS3d6dGJDR29rOVhHRnNaN1pQeTJLSWdXamE2ZEpvTGV3SFhzTVFabGV6WkRtRjJtR0Fmek5rWVdabW9DeXJBZFVCL21IY2VxdVhRdUxMNTh3VDdRd3h3TFpIVlZvdGU4VDRoVTY4K1JZNDRTazZta2N4MTNDZFFpMldNc25zVkZ3SkhiMi9UdG1vL3hueHBnV0lkZEZFZ2ZwcUdSTXNINjZhbnAyUFRQeG5XcmE4QUI2THQyN2ZxVjhQYTdyNkY0S3JITHhiUEhUM0Q3dGVvTkRFRHdEdVhrdWUzVHJ5Vml3TjVTbW5xRkpvQWtjeFJDZWU1ajlsVUFJZ1ZDTUFRdU1lNndWUURKSkJrQy9WcDd3SENRWDdUcG9kd0dZR2FkN0YwRGVwMmVkdUkwZTA2Mm9vUnlFZjFld0RQUXpTd2pBRjY3VmdVRUM5Nk1rTXJXM21tNDk4VURudnNvWEdRRVc0NFlwQXJ5N2hlcmdFdWhQN3lVQ2hiY2hibUpNR0hzbDREL3AvZWY4QXowa3VKNkNpMWhJdTZkTHBYNzV4cDlOZy80YkNhQVRDM0RLM1RjN1lpWFVsTEZmVmZoS3N5bE5LeGdNc2UrTjJtQkxoSEQzaW9zYVBoTTJVUUxpSENKZEdtQS91eGxiSytJdFd6YkpPOGpyL2tacldjdHZEUGdxSjgvcy83aXZRanQ5RW1vS0lDOGp5NmQ3MUVKRzVMdy92N2JkZnAzbjBmQkpmekMzL3ZsZFh6ZXMzLzczWDNSdm9QSVlHOGZoSXRaUXhRRE95bVlGc2FWOVhPbmxEbXdlQU14S1NSZWI3REI3NGw5Y0RDOWsyMllBQ0ZHNVR3SUd5d3MrcG5qU3l1SkhhT3VLNlZiYUh3c2hiWjNJa2toUHcwbWkzOXplK2llaG1rZzN6Y1pPRW9sdDBNVnl4UlJWOEZtQllRaG9vSFlrTDF4TUc4NWZDVzlMWGg1SWtOWFpNRFJMR1k0ZVdoVUJCcVRnK1crUnM0N1NPWVV3c1AwZlJ0ZnY0ODJMakZqc2N5MDZpR3hnMU8wYjh5K2NBaHFET05mamx4U3FuUngrWHFDSlhFNzdVQmhmeWZaZm9UcllpWkdTWFNxejRmRjBEVkl4U0VWd1NibGlQVXNvMlc3VElnNXovck1HQ3FyOE9DU2FTc1lRTkU5WkxsZ0Y4TWNjYmtMdUVVN0xSUkNpMjZob1AydHZvY2pvc0N0c1JmV1dNVnBRMXdzYTdJQm9XbWlBWHFJaHo4azNuT010Ym9NZHUyWW9QSUpnVGtlTzJwbWJzc0NPRmtKZ1dYMy9TQVd0UUhUTW94Y1JRaHFTVlQ0T1FOQ085QnFPTXRBWEhnNEJ2Q3ZYN2xHZWM1QnRORE96ODBRM0o0T0x4WVhwZDlJcEJJVDRVellBQUJBQUVsRVFWU2x4T1hFRTEwWXJRSldEMDF3V3dVN2t0cnRzdTlhRzh2WVFIQVJseXlQaFR6U0xidjNGSGUrQ2RBWHBzV0tibU1KTHk1aEVUZkdzY29RVmdqb1BuQ1VsWmNyNE1WUW9OUkdXU3RhcGk3VDF0M0dvaklBT2dWdGx2Mk8wTXBoNWN1WW9zdDNhSlBzSUJBOVJTaUg4MHdBeEN3ZldqSkFuQWdJZzlPaXVHRUYxbmFBMGhMK0lhMmxDS0tuNlUvdmZJSUcxbTBUSVRiTzl3WkNGL2VkWkZJTmE3Y0dwbWlhTnM2VDFTdDBBYVg1bzYxY29NUFZsYjN3dTk5OUZsb2JKSXBvL25mNzRzMHdOa0VNRGNIY3d4MTlJVXhFbmNlTmM5QzVRc0krWXRLZDdLMXdZQnVob1lUSi84djZQL1FaL01LNWNwWm5BVytabmlmZ2JCSlhMR0YrN2llejh6N3BXMFZsN2ZDWk1QSDhoR0tiVlZmdStkNy9YNWpoTGVXdEZ2R3FYRnMrODBzRm1zR3o4cjUrZWEyekx6ZmZkWjhKcERNQnBLZkVEblA5UkdENjNjOG1RakRKT0o2OTF6VnBOVVk1ekwxZGJ3WGxsazJhMVN2cFBFSTNUQXRBL0FrSHpNWFNkRE13L2ExRE1zTHErdjg0ZTYvdXlMSXJ6KzhBWVFBRXZQZEFBdW16TXJNTWl5eFdzN3RKc2RsRGNkaExxL1Y5OUNCOUFyMXBMVDFyTFQzb0E0ek1jTlRkYkpwbWtheXFOSlhlQUVoNEYwQUFBUVRDQVByOTlrMFVleml0QnlsSUZCSkF4TDNubnJQOS91Kzk3ZjhNVEk3RFJkSmlpWFZxZHFQcGRaeWErT0VOeWpFdWlITWxjRWVOODBPdUl0N2xCR21jQldIUHdGS2RVc1ZmeEMwc0FGTHRRaHRhV25JS2hXdmFIbEZ3ZDBMTld4ZWFMc3BRYUV2akVNVUdNUkt6SktlZ29rMVYyOTRWaVJyYTdwVDdDamdUeEtZdzhVbmEyZFFjQkduSlVKWDN0MkNPTGxMUTNSVFJ0amdFczBORmhKK2NiM1cvek8rcmswMFJXbUhXdy9nSFYyS2RCSUVScXByTHR2VTArK21HYXQyRXhZSWtxQk5UWVlrY0pKbXZ3bFRhM3lJdXVGMU44d2drQWFwQ0RlQXR5alNDbHhCMjJUOTZTQXZPMHJEd0tZSHJCb0hxdm1FeWhoQ2I5L0xMdFRYSUNMWFFsRnFPYXFsOHBOK3hCckZxak5NZGxCbnFTWEQ4RElKdklzV2IvRjNZQ0ljWFFvK0Z4dUVyU0JSTVE3aDJna2Y1Si9vS29Vek1zSjFuTVQ2R2JrTjRNUDZLS2M5YUUvM0REQkJkdklybDhEU21IazFQVCtIeUFRL1lRVkZCVFJiM09uTlBTOHM5OGVtTWE2aFlwQ1dKMktKNnRhb1R2ZFgwVlZ6ZVk0TzhmQVpjQXZTemhkVU1SZ3lCczAxN0dWdkRYTC9Pa0ZPRXQ0TkxIT1Q2OHNVUzY2T1IzdGd3V2NLSmNBVTVobWk1WXRKQXBkdEE0UmpvUCtHWld0QU0xTXg2RUVsOFkwZFprKzFiWkJwZm5CbDBZU2dqbWxQaWl2bytQRXYyQUpwbTd3c0k5aGgvUllxM0U0QnZUK21RZU5zcUpUekZOQUZJOU1yc1ZGcWdWblpxc2g4TEVjaElUNDBPSEYxcENRVCtTenFRQ2pkWWVyMmY1aGVuMDlWYnRHTW1nUG41dmNrQU1iZElTRDJtRkdxRHMrMUI4dGlKODZKRmw5MklZem5URXFzZEswa2hXaWd3RUJZM1dEY3Rzem95cHBjL2l0Q20rKzFaWEZwYy9sdUFyMkxPNTFkSkdQd08xd3phTU5ZWk1XSDRUU0N0c1VWaUNad1BSTXBuamRXRmtPVGpKZ0d5NGFjS0xLRkcwcVZXbHBaWTV0YjVzNEluWHV5ZnVFeHV3ZnZzb0lvd2c3ZjFTUGhuS0ZGSGVDa1VPMUFJSWhJY3lHcjQ0ay9DMVJpZDErYnZCbVNnRzk4dlJDci9mL3p2L3hHdE9ZSXZQb0VHR1lMaDhGOVlpQkFEWDZZeVVaNDhkaFpzOVhETkFnWnNIaVpxejlIRG1vc3AzQW9RcFMxTkRkNVlZa0tLTUQ3WGJDSEVHSHB3am1GazROeWUzdlhHSWRwMEhVYXhOWTBOMjZZQS9CSGpxYnA0NkJpbU9DUE56VjZ3d2VDL2VHQkxld3Fzeit5TStCNGZ5bW5QUFdpTkdvSEJjMXc0QlkzZ3d6WUV5emttZWExRjVvWDArZkFJMWcrQjR6T0ZBQmZOUTNRdFV0MDIwZWRNMkV6Y0djMU9lRTZrdVQyMXZPOEpDSG1PeUVXRXBCRlRjbzRsd2VtRnBqK25aYWJQZklHQWRhS0ppUEltRmxmbk9LN2Q2U3JRczBwWVdzcEd4cXlGb05KYWx5QzBhanN4K3dkUkJFVU81WlIvMjEvZEFaeXVRM2ZBZ1p3ZWZoZUFPdGlJSUMyV0kxa2pnK2d5czEraHBSQ3VXbEcrSUEzK3kvNURzQUFOSUNBSUhRVXpCRE5OYzg3V290V0lFNTZBNjNLa1ZHUVR1YUdCNkJNMCt5a3h3UnBubEdlU1VBZlpXUHZFN3dNbFdGNTZDNUYxQkwwNEU3SkZ4bEFacFdDMVZFamhKQ0ZMMUVIQWw2NU12QWRoK3o0UUszYmp3bkZURWp5ZkUrUmJyUkxUNUpySCsvUjFwK2ZWRUFETWs1TWRhS0dlVmxaRTJ0ZlM5T3g4dUtWQ1phTFEzdlBDbXVxaTc1Y2FYd0Vabzlwa0xJVTBHMmVRK0Zza3RoekRYVThJTjZqcGo3R0M2MWdQUWlCT0tlVnFZQjJXU2RMSStNNFhrUFowczhXalZWcDBsTml2MDdVQnNDOFc2ZVlLNjNwemxoNFBiYVliTitmUzNYc3pUS3BtRGVEbUh2N09TVkF3SXBuMW1ldUQ2ZjczcDFISzlGd0RYWHBNeGNlWGZ5QjBjRlJLRDE0ZG9Cekk4RktqZWUvRFNiS3lyeGxKdGgzQVRSVjIxdCtOdFFMcWpwWXRYTU85amxvK2FDN2FNVnQvQjgzaG9RVk5abkZKTEM5Q01ub05XcEhHUHkrdEdnR3NVY1NzMmN2K1NSdTVFRzZodmJoV2RuME5FalBrQ3F3T0RBbzd1RWl6WHN1ejlYb0tLdGZpUzQvSzg0L2Z3eTkyVDNHdkhhWWhCQ29RN3hJOHQ5V2s5UGJDUjd4ZmtRUlVEZmRZOUVBMlNWcFdzNUlHcUliZnNWaTdzTWc1MFpUZjJ0bWlxZGs3SktGbVhsZWFtNXVQWVFuREkzYWs3QTB6a0tRK3pNWHBzYUFtMHROT2lObExybk1CNzcranZjeERVRk1RdnpZbzM4Nm9yUHpGQ0c2T1FnZWhRbWFvUFk5Z3lWSDRYTjJtM1M5anpXRWNKNElNNmFvUlhLM2gxbURRUktaUHMxSkFZU2JBRWFOaGVabnU5U0cxUUxCZzZPbEVhSUFaZ3h0Qi9DM2NFRWVVdFhEVGNrQXAra2oxRnlCb1U3ZWF3dzRJZGFDbm15OWk5SmlNb2h1dGU1TlpBendQeEswZ3RsalV2WkZSUmZCZjRDcEs3QVlpczcreDZaeURsbDBnaDltYkZvRnZITWJVUmVacDkvVnA2c0gwR3VUOHdvaGxlL3lPTVJRYXZjQjlMR1FXQVgrR1VLeUErRFp0N0ZvdU5hZXBYK3VwRk5BeFdKWFAyQ2tqaEFMcktMSTJvczN2eitUeW13Y0RmUUFQOGVDMTJpclVkTnF6aVM2S01Hc2xySkxMcnBjS0dlOFpRcHZuT3lFQnNrc05YQ2ZKaGZHSnlUUTlNdzFZZHc5cmg0RWJwUHY3K3djaTRaR1o3WDhpWUluMjhpVkIrL1huTDZta0RhRm9odG40a1c3UUJkbTFPdWNwWXd1TjBMTGNwK2U3YTlxanRHdUlTVEdlY1pGdUhuakl1R2xNb01ZS0dlaGpTblhKcmcvUUd2ZStaRXk3cTU3anBpbXNqTGRvOGJsZjhjV2FGTzdHaXd3ekdMY001bVovanhDUVdxMjcxQXJ1VTVHd3kzQ1ZBM3ArN1NLc0xER3lES2RSbzBNckp2THVJZkd2bmZiMHJyS2VYaE1YK3lIUGRlUEtuZlQwR1QyenlCNSsvbGQzMC8yYkMyREhvRlBPckxKM2xINzN1N2ZValBLc3hIWFhzQ2FuSjdyVDR2V2JmTTJtODhOU2VsUjd5SE1vSE1oQUUrb29DQStDbnVJVVVXaVJmQWszMGV5NGxwT0NBYm8wRllEU2lRb1V6bHJyekhJZnA5d295TFVyalpIRkFCRGRkSjRWMHlET3B3M3pYd3NaNndIYWhBNzRVcEZGRzJjK2JCbVJ2MmUzNGp5NEN2U080RU5vdXE1TDEwL0xUTEM0UENiMnoweG5EdVdhZVF0aytEUjh1SWY0TXNsQ1Q2YUpNRExZSDBCZjlyVHVURXF1ei9KNE50aVFOemFVSzNZSEFZdVovMi8rL3Uvamhtb1Z0ZlVCUTBRZlBIN0V3VEJPaUZUMDdPd3NCRFJPOXFvM0M1NXBRYkdSZ2dObFd2K0hGeDBMVUFKbXdUNkpsSTFDdStkWnZObzNISFhBZWhla3FkUEZFSm15eVRUUU5ZZjFzeGxNc0wrajIzQk13SlQ0aVZxTTk1MVJHQzJqbHBsTUUraHVMbU13MHRJTll3Nk9NcElBeFFZNU9iWUFZdHo2TDNZYml3THR3UVpaajVkSHlEV3h1dks0RkYyWTBFVU96R0dkOWpyZkJvdkVCNkxwbmN4aEliR0Jid1BlTXA5Kyt5Vm1SS0YxaEdXajYxckVUTGNPeXpTNXhKZ0pENzRqalV6STF2bGNHd1hlUmR6UTh1WkdCSFFMQ24yM2p6dkNteEFqcEtiU2diak8rYUhPSVRjUjN0NDNncHBjMXpWWm8yZm5WMXNtODZ0SVowT3U3RFlhQ1FKUmdFSTJYUFhQWHdiV05mTWhHb1NlUXp3d1RuRzNHVHdCUStzT1NXeVhnaVdFaTB0RXNRaFVsUmJ5YU9vdWhGWVBRbXArZmo0OXdUVjBINlFKclJDdElvVjhQRCszTnkxLyticThyai83VEpmQ3pIYkllWmlud1BOYTd1UGFyRm52UUpnMm9GUWIrbDBRQkZaZ0c3dHkzZE96a3d5QnBlc0hYa0Fmb0ZKZEhzK21FNmJzSnBPblYyTncya1NQdUtJUVNMamp1bEV5ZWZhY2lHNzJUNkN5djNkUEZYTHhPK2pKZ2Jybm5HdU81TkVwblZocmZEbUlva3daMU9aT21RYUIyNHdOMnlhbTV6NWFZNGp3d2kzZjMyMmtBNFJLMjVjcmRNbEl0THQ1bXo3NitGcjY2WTl2MGNhR1VBRmd6VTFhMi96Mmo4dnBWMy9jSVQ1S0xLbHRsNG5XNCtrbmYza3JmWHFYR1k3Mjg2WVU3Z3E5NlpmWGxrQmhhSC9DK01UcndnMXovOExWVWppQnpWSUlKN3dIR051K1ZBYm84Vi80UWVzYU1VS3NtVWVGTnFFUmhKWThxT0tGZ3ZnQ3A0WFZaS3ZsMkJkQXB2S255a2VMeDdoelpxbGhaVUdqMWhVcWpIUzd4V1ZKa3lvQ2U4NTVwdkV6ZitPSG9FZGhSNjVQTjArbG9JRFNMYlhqaFd1U2IxVVFobHhzMFFQeFlrRG8wWmtjTVZHQUFPTnZVbEtNdW5kcjhKaDRKUGNFcTRYYXZtNklZR1I4akxka1FzRWhtc3ZMbTh4aFcwN2ZmUE1FTElyNGxNRXd5WWR0UkVlbVNxSlJJOWNRYmtyNnFBUER6RlBLYXdJYTBKWm9ZNlA0dmZXRFVXUEl3aHRnZDl6dERyUmdmemZTbklYYlhFNU1UMVRGczNHQzNzejZkQ09JN0JWK1JGbEtCYTFtMGJQZElzNnhDcHpUa2pVV2hPRXR3WUNBWUh0aURRUm1JVjUySlJEb2JuekVXR0RlR01KcWh3QVBrNDEyMDMwT1h3cm0wTlF3cmd3akErcTdhMjM1M242NmJlN3YwWElGWXUxR1piQy9DR1VJQXFMaHdTRU9OWlhDc2dUUWxJQTlxT2hqMHZ0N3hLY0dnN2drSW1TdWIrTm5MRzJJZ0RXaGJVUVZYMWllZ3FWbEpxL0J2eS9YeFJLNVA2VEd2VnczUDRiZzBxUTNRSnN6MWdHenk0UVN5K1ZMVEJkM1EwTkNSQWpxUHBEb2drNjkxcmVDbG5kNFhjOUtGOHp2YW1CUjFsb2JJZFQ1dTN0alQzZ25lRHROZW1wcUtxMnVyckp1dFNhdWM4UTN2cjB6LzNEUHNuM3p0NWRDelg4N0ZzeWhGRDZYdFcvaWtIckFvblVNMmttVzkvSk1aV0p6bnZHMWhXdDA5NXhpbEJxeEhENWdyM1dIdUpvOGFFTW8xVkZnbG54WVNsYWo3ckdEV0ppdVRJMXlCdmVuRFl0Rkt6V3lVK3dObCtROVdsaWNHZlN2WitIYWl3ajN6cnlkVjlrZjZLY09pdDNRUUdPQ3NXMDNVSjcxQmFid1ZQRklLZ3plMkdRZTVHWmFoUjVQcWFIYzJ1OU1LeHN3TnAwdWJ0MmRUei8vMlJ3RFlCMWIxNVllZmxWT2YzaFNTWS9mTVkrU050UkRmYWZweDUvZFRELzkvbzEwaFd6aUlFMEJYTXRid2lBdmFFVzlUZG5RQkJPdWdiMnlFY0Jtb0N0amhZWXRCRllhdHpKZWFyVkhaSEE0M3dhMG84dHQ1MXFGallKVTJnbGNWd2dXTFMzanhDcEpqUWd0TSt3eWhSWUN5UElnZGpMT01TYXJZd0ZybFhzOVk5WXFLU0V4VFFXYWZBRUJPNXpGL2ZXNm5xMTBveHhRT05iUC9EMDA1YjJoY3pGekNpL3BYa3ljN216SUNlT0UwTzQ1TVcrMFJSYWVZRDFORWc5aS9wd1RnZEdOamNSbjhnRGJhNWplR2RLVlJYT0RtTktCb0poQ28wNVBUQ01OMFNaaGVlbmIxNWo0dkpGZWYwUHZIelpZRFNkMjZoaEJNam8yeHJCTFVNR1RWUEdUZWRKbGtJRllMbmZUM1dKUkxGZ0VyaWFmbTJQUXV1MWN2RGlId0h0dGZHZWI1b0t4SUNTd3hDeUJHbUFmeEZYc1JtaUtGYXBSYW1IeHFiTUhzMEFrRGZLSVBSeFI5SHJNYUM0RHltYkFiTC9SZ2VYU0VLUEUvWFVUL0h5VFdGY0hhd3hzalFLYncvQTVmSVhHa0tLRDJkeG8wdGRZYVFZQVpjcHVPaXBnZ29URmQ0Zzc2OEJRRHlLbnhjSjZ6VkFhN1BXckNWTzFxTkJ2TWszNEdJdXVtOWdOWjRNVzRib2NBc1lOOFNqR29OdDczdnZnMWpWMEJiaVg5ODBJTHROaTBBQUg1eGxwTlVFb2JnNVdDRGRpdnpDWkVaUitKbjRmVDVMOXg0Qm5DQWJlNkxTYkVwTjBpNnhmWkFtWHpCU05oTVVOL1BLWFhnY2FpelBXZ21xRGlYUTdweVluMDhMQ0lwYlhRUWdUdXpiWUpWV0ZwVUNRNmYyNlhFUDJYVDM1Wit0aVRWcUlrQ3BmTWdFV0FiOXpEL3ZvMFdYeTVnU29oNExwMXZVYjdQRUltMFo5SlVNalhMT3huWE5pbjY2enptZFBZU0NoTXM0ZGNKSk5nV2ZVRlRwRkNiQ1lZQ2lWbFphV3JvclRsUVJpNmxMeEt6S1NET2pnM3lVcTFrZkFYem10M0c2NE1rdE9TNGY5NllRZXo3ais4UFZ4MFBnVDZTT0UwdjUrRlRUK2R2cm16V2IwaUs5U2N0UFBBSTIvWVBiaDhCaHVKTzd6djN5eG12N2pQeERUMml1a01rSE1IZ3BNZi9UWmJQcTdueXltcTBNVzc4TURLUDZkL1l2MHg5ZEg2US9QZ1RMUVRQRWNSUHhJQ1NCRW5SNWdoRDFpN2lIQ1F4VDVDUzZzb0ZkRE1TMHl4TDVDU0NIa085U0M3RkxFdGJDaTVPZVlXcVBnOEp6aEF5ZlZpSktYSjIyekUxYU83aWU0d0hQaXowN2wxcFdET2QyK2NNbHlZSFBDS01FWXlLWkFjU1RRYWRBWHl0VzZSd1dVZHFIeGIwNkJkUmp2eXVqSjcxYUtvNXBaajFnODNGenVyL1Z2dngzNzd2Rm9YTVBRQzJjSkRlZ0NTcnRGbEU4TEk2ZUtsS2FzVHVrc0k4Rms4b0FtR1lkK1JtWnZxRFRLNzNOcFltaWFlcW5wRUQ1SzdDTkFrdHZNSUJTSzhQTFZDN29ObENsdWZaY2FYN0JFaU1XQnFwT1RFMHlIbVFGN0ExaVB6SmV1azY0ZTVBTkJzaEN0QlFLbXRsNTJZOXdNTzBzZUg5YW9vQytqelczRllYcVdUeUNpRlU0T3BlakVSYW5ENERMTklTREdWcFBnTVFIa3ZiMTFiYzAwUHpNQmNJL01JOHh2NEYzZjJ4UzF3MHZaVDY3RmdmRnZDM1RQWURRdE9BV3ZzUm1KMXJqVXVWWHVjRVlXVUNSc0RlN0drVm1DNUJ5SDFFZXRXRlVMRFlZeXFDdW8xQzg3ZnpwK2pPTUFHYUpHUURzZ2xPdFlZcHd0Ykd2MncvOW1yenJVY014bnRoVlk3RXlYcHJnSHlwdGpZQUgza3VrRi9DbG9iVTBpWnNxV3VCSmxHY1M2cnJ3WjNNZytha3BMWWQrK0lGTE83L0psTnRaaVovY1NxbUV0RWhndi91TjM1WlhQS0xyNUhPdXFnSVdxMWxaUmFkMGU5ZEFISHd0cmVucUdhVHZQMlU5bUlvNVA4cDRXRGZpMjN0L2JiS3BpS0x1Z3hNZXV4OTcvYVcxcWJSakx0V1pMNFhuNURFd2xMU2lzdEdxRkViQWkrbVNSQlVhNjI5VFBaSU11cUhNRTZueXZvYW1QaUkrQ2tlQVpaQVRTN1RBQU9vUVdQTG9iV2dFS0pnVVczL2wzTnEyWXM0QnB0U0NFQmhoa0ZvY2xpTG9mM05jUXBUbGpkQ1VkSVFFd0NMVENxZ3cvS3oxMTg3MlhLZFBUZzEyMGJwNWdDTWVWdEVObWUybGxHMjlBaS84Z2ZmbXdtcFpBay83aWwwK0FtMlNCKzRXWm1mU3puM3lhL3QwUGlRa091eTZzTXlUbXE2MkQ5TXMvYnRHL3ZrenNiQVQ2UWpGajNZMk9NUUYwOVEzNzR0NndGZkNldmVlRG1QaWRKV3dLZnZkTVlXRXlJNndhcUNGWE5PbGxITXlRZ1FJZVdtQ3pXL1FkczRheWhWdnEyWGdtV3ZnRjl0WU1zNWpHSnNKTFRWakgvZk9NVFQ1VlNWQ1oyUEJWeDNPdzBObzI0VmxHVVhkUk9zc1Jld1lwQU04NnkxQysxZkJRc0JvKzB2aHhkSm0vQzc2WExsQzIvQmQ2dzZVbTV1eGNBcThWUmQwUmVsSmhLQUFSdGlTZThsVk9WZ0t6bFcyWGkrTUJjMmdydGM4WmRZSzJOVkhqNFUzemtjd1Y2eFUxUEUvL0tnTDBIMy9uUHE0RHZjSVpDN1cvZTB6QkxLVUtxeXNndDlsOENPVGRxOWVzRi9BWWxray96ZmhtWnFZUlJoU1FvdFVzSnhGeUh5MVVZQXl6ajUwMDE2dlNQdmk0dG94VzQxQ3h3TG82eHhCQUNCZ1pDUk5XelRmQ1FJQ1NPREdDNFBiYkdxQjVZQzlnUHl2MUhaeGdWOGNtZ2tDTkw4b2tEelJESmcxY0M0UlpvNUJXS3hGeGdLV2p1K1NBUndlWDRsWndIeHNCQ3Rld09MQ09RTS9hWENCSXVMWW1icEVNV2lmUFpWK3VtRklMVTZNblFNemJKVkdOeC91NG5yaW5BYXc1Z0RvUUFQRXhHRWx2aHVXbEU2eXJieGh0L3NwS2E1SURkdDJyQ1dHZ2w1RnhDcy9GNHd4ckUwWXFFS0IyNkVEbW9xSTRtUHhpQ3hDVElseFZXdnF6MS91Yjhkc2dXcGp6QXNHbktlOXZaRDdkQVlrMkJCYS8xWlZIVW5OZGxNcDdsN25CWGxWb2xXeXl3aUQ5NU9RMHlxb2NVN2FucHZvWnMzV1ZaMU9KbE9QK3h2eTBSdFh5cmo4WWpldUt5WkpKM0J1MXM2OU1vQ3BZRVVhNFY5YkRqZUp1ZHBTR2NYdTZlVVpXeXY1YjgzaE1MN0VxV1Z1MkZJYUIrYWl3am5iUzdLTTFwUmQ4YWViU21JZWYyUy85RDYwS2FMdmxXZkVqUE1sLzJDK1dGVVhQbUx5ZW4yVkpIWHdla1o0S05BZnNMTzZ5MTFoVUZGdFBNTkY3WXF3Zk9FZ3Yzd2VCTlJBTEZTOElxSEtRMXQ1MmhlMGlLSHhLQytjSEw5L1M2V0taZ3ZBODA0eDIwaVoxcllybis3Y20wdC85K0RiVzFRUTk0TEdFd0dFUmxVbmZBRzM0UHgvdXB0OCtMYWZxTHVlTFMzcDlvc1Q3cDlQOFNDRXR0ZGJTMHRvVHJHajRBNkdzRmFJQXRtcWt2V2dMR1MwWlhWNFI2c0JURkVic1BkdkFmbWVRaDB0TFBmWWJZWjROaCtENUVZQ0dQVlRDMGxnZzVUbUhJblcwb2dOYUVIcTRiWFJUVVlnNE5WcmFhNlBtMG02bGVWeHRQUnlWcXhhc3dsS1hrWXVHNGhQMzVYbUhnY0tDY3RTZ0FpN2l2ZkFZRHhKd0NzZ2dFZ01KZDUvMUdtczJ0aHB4TElXdzFocm5iSmtaNzB6NS8rMC9QQWVvRFo3SkFESk1PMkRHQmVMcVE2QVVxWFhUcGVxM0dSL2xDVDNnVWRwaEpyc0ZRbUVJaGN4bjdrTVREL1hQcHB2enhLYnVrY0hpOStKZFpHQmpLaFhjaHMyOUxjb3EzcVEzdjN2TnhwSTVJOE5qQUhVUTBPRHN6Q3dhamF5a2dYMFF5bjM5OUFrbjQ3ZC91TVltQU1JOFgySWRnd2czMm9aZ1NtTDVvZ0JFTll0R0J0R01lVHhGMjFzTU9BNlVnNFU0MVFEMm5DNUlxRENlV0E2N1Nyb0h3VFM2QzJ5QUI2Q1ZZaFcrRzJqOGl2L0hob2ZRZ2R4a0xSbll6bzV1cHBhVm1rY01pKzh4NkZoVThHSWhpSUlQYXZGRG1tbGM4NXo5T21ZTlE2d1B2a2FJSVRBUlVxOVBjdW1QQUNZM2FJVFhCaFRpd2d3SkZwa01LbTRteXhZcWRQa1pZbkcwdVFXaTRiWmpaVGw0dFdyNjNVQmF1QUxjODg5Zjd3V0QzR3JtcjB6VTNiMjN6YktCV29rNUNJMTdjS2hvWUJ3MWZtZmZKY0Y2Q2lnSDRPNlNuTEJMZzZQcjdWYWdaYlc5dlVmblRlSlpvOFBFczJaeERWVW9DRUpsRk51UUJicU5iVUFyN0xkTUViS1NPMlZCWGQ2a2I0ejBNQnhSb2FZVUZDN1lyeTRnSVFURmdYVEFlOFRSeUNTVGNhN3psWW9NcllEc3haclp0MTRsMUVVUTNUNXRXdXpHLzlvUk5GMllTd29zWFgxMWxXY1NEb2tNaFV2Q2NjYVoxbEZPZFFVempGZmp1KzZsNFd5TCs0V0hiRytlVWo1VkFUV1A1Y3p0SnlkQi84K05NOVpzQ3MraGovNXRvT01Kb1pSUWJCUGpBK25wNjdiMHpRTkdxTzJnZUM2cVlNYUs2VHNmTDZhLy91eGV1ams3UUZ3VlFRTzI4WmplL2crZjdhWmYvSDRwUFhqSDZEZG91b2Q0N2wvdzNwLzlOZTFxRnVBeFhLRGowVHZwNVFZTkFsRGdYZTFNSW9jT3pvNmgwUUxwZnJ5Qm91RUsvbWVUeW5EcE1VQk1QbHd3bWRvaVo1V1JYbGU0dzNvREdpajh6OUtzY0JlbGJtakRtQlJ5SDZHQml1RXNuRk5nMitnTE5xLzl2Y0F5ZG16YkpoczUycS9mdHQ0cUFlbmNleXJVemdIenlsOWV3M2l1Z3pyY1IvbEVLemdITmd2VmhZd2hUTU1aK0hHRlV3UCtESHdXZEdtbkY0TmRHakxSc0JPYU4zRWdUK1M3QjhiVEtxREZmUnJsV1k3VFRuQmNyZTFZcUI0d0pTWE01UktDcW9kdWRQMDl4QmpRTGtPRENBcktIa1pwdDlGREhaYnRWZ1F5MkxiRlZ4dU03SkJIS0lwNEFYMlNjQWxIS1VlNFRVMll1SmZ5UGdXNHBJeTNBVmV1clc2QVMva3FtT1BLbFN1VVkxeFA4M056TUJWbFFyaDZLVWRXcGJtT3hjV0MyMFZnVDZJaDZNZkZ2WXlkMkFsVGwwNzhWUTNCRTVrbnRrRlFZUFI1WjBrS21qekVJQ1BwdXRrQndSaVRRdHROQ0grZmpWSncyUUhTWGtNbmFMQVNYZUcraFJLZ2Vhd0FFRllRNlZvK3F6WUlJdkZhRUlhSEZrVEFqZXpWemk5U2d5YUR4MkRFbWh5cS9FVU1OcFdwczN4VHpxVkhoKzFwanhoWWt6aVhPOWZKSHBjZ2hCYkN6NUZQQ3BOenpHU1pYS0dZRFFmQXl1UDVZSC8yQnVaRVc4VllwTmo1Ly9mL0tFQzh4aGF1V3cyM2JvQTRueGFUQWp0ZUVoU3JDTUxtL0xSTUpUeUZUaHY3cStrdllIU2ZrV0lTa3NKeW1GNzBHeHNiN0plMWQ3UzBtWjVsRU9zeVp3a2R1ZG04RkhvS0xPL3RjMGpJd1VUdkpaZC9ZMmxCdEpJUG9nYThFeFk5Mmx0YTBTVHlmalhlWDlmaTVySUsxWFBXRXpXUmZCWUhCVXdZd3RXdWlXU2dCdGkvUWZaOVlXNFd0MjZZRENjeEd6S1FwelQzTzZXRzhlelVjQUNmUThCV3NkcU9iZWFIRWpwRVFPeFNJSDVDTGFSZVFZTnJhY25aTWFITVhFdmtBMTB1cXJSbjNrc3ZDYmpiZzJ0K1lTTE5UYUQ0aUxHMjJDZFFYY0FYdU1keGdlR3ovZWx2ZjM0ajNiczdtc1pZd3lCVHczVzducTNXbWJXNGtiNzRtdG1kREs0OVphKzdxWGI0MGZldnBQLzJ2MXBncWhER3dRWFZJMVNGSEZRcElEKzZFckdsOXR3eXpFN3BHRkFod3ovcUlqdWxxZ2pzWmdGQnNNZlFEVzV4SG92UDJKV3VzT2VvVUZOeUY4QXphZlhDb2ZFL0V6alNzTWVod2piR0YxbDlybVl3M0dzcXNQeTlybHNiSUU5N3ErazZGbkJCemVKNXBzWWJqVGRwMmVVNW03Z2ZGODJTSzhZM2NWZFJPRUJrRVZxNjRGbk1NL2lMODJzU2hqSEdqVlhDalRVRStIZUVNK3o4d3JwVXlEQlEvdWVmemFVM085VDAwU3ZiK0YwRkRKVGZtL1lMWWx5M2l6a0dObENtZmU2ck5hUjZqbVp1SEp4RERnY3R3SVVRTEY2ZEhCM0NMMmR3SjlaT0NWT25nOTNNZ3dIQ1BpVXdXRVdpcXJud3U5bVVYdnorYVNBVHVUc2Y0QnJWMDFkZmYwV3g2ek1zc0tYMDZORTNZWGw5OU5HVmRQUE9DSzRwRHcxVGR0Q0U3K1NVOGhVMDdqbUVsdWlPV2dFYmMwemxmd3Z6OHB3TjZFYVlXcXg4UW9iVHdEUTdGQnZkU2RkVHNTQXlPS2NiUkMxNFZHQmNkR0VJd2NNVzg2Y29qVUM3MnFZMmMySFlUSHdRcGI3QjNCaXh4TUZwUGl2VVEyRHh1V3dxdGo0NHo4bitoRmpoK2s1Z01lMWw2Y2daNE1SRDNJN2ZsT3ZwVmIwNzFVdERTRk1tNFhBdDNiTno0Z3RuQk5MYnlLWmljd1NCZUgwRnFRV2dUZytKckF5eGlRTFBhRHpSK2tmakEwWXFGSEJ4enU4VkI5VEdNd2JwK0UvZXowSjVtZmxySVZTR3lmbzZhVGZyQnk3ZTdMMEx4M3M4OTh1a2lwOVJrRXY0WnU3TUtnOE5qUUkySGsrYkc1dE1VS0k0Rlc0ZW8vK1ZtWjN0blUwMmdHQTZib3o5dEx4dVptMjUzNjdCdmM2K0s1QzRGUy9PQ3VWQmRKLzNZdkZnTlpXZ0plTjExdkIxNks0ajZBMTVLa1IycVpQME9ZVGZPQzBuQ0o5ek9nY0MwZ0NPd0hBZGlxczNTUmdSSVAvb2RycEMvS2dFd1BTYy9YVXdnOVVibnRVcFlRUEJqV0tkbUowQjBQYzBDcmEzY0huTEtIRTdYRVQvZXE1clQ3Z2plblR0MHhsaUd3RG94dTRKc2J5dDlOSDlhK25EKzRRNlJtQlljdThGZU9UejczMllmdlEzdDlQdHUyUUYreFVVSlZvdk45UExkN3ZwVjQ4cjZla3JzcThFMm1zMWhzTU9wL1NqejYrbnYvL2J1Mm1SQ2RNRy8yMjF0TG9GRk9KclVQT3JBNHpMbTZLL0dPRUhNb1A1dGdINGhpd2VyamVSWDJnY2tDZ0pxNGhQb3VnVUhNYVF4QVlxc054cno4QnpMakNCTzl4KzJLTkk4ODJDbGoxbkZjTWxlSjh3Q2k0UTd3K2h3ZTlDd2JEdjhrQW9aYXd6VzFPY2s4WE9rNVFJZ1NldEIvM0JWeHlvbjRuNFZvaEhGUSswS3k0UzRhRnd5eE1YMDhqUTRyTUxMWXVQV0owQzB1SnB4QzYvUnlFanpMSnlKWVFuUmtPK3Q3cVI3cUl0UHlEUXgzVXd6V0FDM3NZdVVBc0ZvMEFoWjNRQWJMSGhkVzVvdHFLRzVCTmJjVW93dEZxcHBoWFN0ZStXTjlCS1M3Z0xOSkFqUmpYVzM1bG1tSW83UUt4bmdDcDh1cGFGeE0vNlpXWHF3YUxjSEF2LzN2ZStEMUY5QWtQU1VHNTNsOTdkcjJndDhvUTR5V2E2amk4L2huVldvS1dON1dic1kxNDUza25ITkFCazhBdWJscG4vV2tVNVlrNG5FSnh3aXBicGZSNWJLSVlGc003NzR6VFlERndqbUpYSElGN0FPeEJ3dXFpK1Q4YnhTMkZqMTBkakcxYXV0NG51eHhXMVJxMk82YS9wZWxraG56RWZuMEhMZWFDNldSNFlPZ1RoRGhOeXJRdXRCUVRUTVlUMmlqNzE2NlRkTHlabTZJcEFNU3hDd0FDM0hTZHFFTm9wN29LQlJ3OHNDQVZpa21rZGFWOURZT242MlVraWFnSWhDbGZyL3hWTS85WXJCT3I3UDNnOVh5WldUZ21pYmpHS3JURk1ab3ZZb3RxdFFISkFRYTZ3OGIzRzgveXVXNldsWk1OQUV4M0crNG9JRDdPMkUyUU90Wkl6K0FmZEhxWm00cjI3ZXpzUXBVa1RoT0I3YTB1bXlWN2NJMTdaK2wyanZmN0h4NmRTSitmUWhjdHEwaVY2blhOR3V0KzI3VFZXWk1pZ2l4aHFqUmpRUHZpOGw4c01tNkFUN1FHajU4Mm1xVGdjSVJkNEhtaHAvM0FuYlcyOW95LzlmTHAvN3pxdTNId2FtckRGdCtCYlowRVNKRWIvS1N3dk9MOHJiYlI2dmpOT0pZWGc1V2JNRnBDMjE1Zm9IN2JKYkVXZ0VtS3pkbmRQK1N4Q2JSdTNEVG84d0FMTDQ2NUtEei83OTU4d2F1d1Q0clc0N2NSV1FSS250NnUxOUp2ZnYwb1AzK3lsTjd0NUJDRXpEb2hKZmdBUy9pZC9lVFY5ZW1jaVRUQzF4MjRUeCtlbDlHcjFLUDJuM3k2bmYzbENkcDdFUWc5QTJYR0s5ZnVCTCt4c1FNdlNCWW9Rd2dxM0dYbUI4Z3BxNUQvUUQwcFlZcmFuVmtham5DZEpGaHY3R2NHWEZQTDgyMzB3M0dIMmtFOUFyWm1BRXpnYWxoa1hqbjd6bktGcVVlL2lBdGtnU0Zwdm80N2xwR0F4bHBYQkd6UUVFSkRRV0NRQXRZUzVuemd2SXhmT0JqVWVsZEVFcmlEM05vNHBBTnlzb2VHSHdHNHBkemdmZkJMb3lQQ0YrODZhN1hkdGQxRTdGTWlzZkJKVHoyZEZ3c0hNdGpBeHBjalNJRmh3VVdncEE5VVhTTHR6d0ozb1lkNUxwc1pXSW9RZ0trVHl5d3d5ZUw1Y1RxL2UwbFdVTGVoSFlJMVE4RG5HZVBadUF1MU9CK25FWk5lTXBYWVVEc0trSmxqZFF3bk5FRGluR3pkdUlRaC9rRjQ4L3hxMzhRMlNtc1o3NHdnTE5TZ2JWc1M2czAydFdKSWl6TjloUFJWV1VZVUMyL0RsbGJ4Y3N3ZG9kRGMrZm8wVXVDUFZaVDVqWEdwanMyRXlRZjBFMTQvM2VGVHNPeHRORFptL0o5aWt1K0o3RmFTMmVoRlpMME80VnY3RWdjdVFXQkpvTG9rbGg5RGt0UGdkTGdxbXRrUlI1THZCeVJONitsUXA3cDY4VHNlQy9EalpJYnBTMEtiSGVKVWRJZllKenFxOXEwRDhIVTF2MEZPQzBiL250R010RHY2SVIvUDMvRTROcG5Ea20rL2dmZi9sUzdmZ1QzLzVWLzlpM1JMYlBxVXdFcHpXRkplTjlVc3dYdEg5aWxpZHJvNzNoTGpzdm5sS1daUlFsNUVSNWdzU0lMZnZ2Z0x3RUd0M2xGcS9ZZW9QclI2d3R2RWNDOXFlL1RLTjE4cGVQaysyRnI4NWZmejI3YnNJVGx4OTZzdmMvMGdzSVBEaHlIajJMaXlnVGpSNDF0c2JxaU5KWWRlREc5Zm4waDdUZGxaVzltbmdSeXNiZXYvVGZCYmxpdVVVYUg3YWs1RFJGUzIvL1BwZHVuNzFTdnI0NDd0cG5xYUUzY1pMRVg2NmlkS05hc1l6elJHc3F0bHFBMWZrZzFzelBHOGpIZExLZXZuZFJucnc2R1Y2OW1LRmlUbFZ1b2tRaGtCNVdsQjlCazZvcDNlVUxQVlErdXg3dUtLRVRMcXhYcXEwbG5uNFpDMzk1c0YyZXI1V0JVQ0tzcWdCam1WMm8xaXNuM3grTGQyY0pzUkNVWDA3WldUbGcwSjY4THFjZnZuVmFucjB0cElPNjhCNVNFUmRYYmllUHYxNE1wM3ZMeU1vbitMZXNyZVc3TmdEWGFHQ01sWklSU2dFMmpHK3ltSHlKWEd3andvY0JJVjA3SStCUkZkSThWNXBKS3doei91OWNvbmo0WDFabkZCQkY2cVhNK1E3RUJOTDg4ektHclBVOG1uVE91YjZNb1owWkVoRCtzOSt4NFhnQ1grMG1rR2FPS1dnM2ZDQ0FYbnAzQkNFdU01QTlVdXpXTUJhZUNSQ2VUYnZnd3VQNVV6SkQyWWU3bG9OaHBkZXphaW9uZkthWDJUbWNtZ0hNd0tDR3ZOSXdYWVlzS2dKeHhwY1FRZXVnb1RZUDhnZ1NxclltelQ1YTE0ZDRPSllESHdweURZb2xIMjljWnErZkwyS3RRTXdFR0UxVEhmS09VcFhGbkhqSEloUUpNVnNuWjRJWjljemdKWDJ2VTgvZ2ZnbUdJWkEzeURBZEFNSW9HT2IrL2srQW42VzlOU3BXU1MwUXRhRzUrQUpSQ2dyNGNXQWxTamJxQ3RZSVNoSGcrbmFhWlJ5MUN6ZVRDaGRueEJnTW9jTXBIQnlQSm1tcmJ2dHoxb1p1bU1DN0d3ekUwTVUwRlRSN1JJTEl0d1hEcm1LQU5YbGpSZ2ErNmYxWnFiVkxOd1IxN29ZbUtNbE1CT0QyZE1PTlBrRnowRVFqTCtIbzB3aUEwWEFYcHZsaVNvcWhLREVaOHpOK0lyWUlRLzJDT2J6K2NKYzVyN1JySTExV2NEc29jZmFlYnAvNjNVcEpQeWJKUlFHbXM4NDJ4MUtia1lveGJMVFFiZ0w3RzlBT2lBKzZWY0IwcExRakdmQnhBMlNBNVZEUnJmQmxQMWtQMGRHKzlQYU9uSEc0OFBJbkRtTjJuWXhHd1NzRlZVS2ZKWWNhMVlJK3FYbFpTRGV1TW5jL0JpSkZ1TWE5T0dpbFlYanFWcDBaWlVselA2WlZqOERBaUJqbFVvVXpLTXdlcUVqZ1pUMkpPdkhPcHNjN0VnZjNCaE03N1ltS2RSZW9UeG1HYUhxYVZ0L3lRaTVrME5jUmJCUkREVFpXTjlneE5oZGFnQVhZOFJhTDZQb2V5amZhbUJOTjJsZVZzRFM3VU9ZNWJDS0NXTlJqZEVXcnRxTmF4UHBrKy9jQmtqOU52M3pQLzB4TFlPL0tnUERPVDV1cEUzYzlLV1Z3M1RuSnVFT010WHQwT1VhNlBoZi9lNE5zU29BcGhzdFlwa0dsMC9Ud3RYQjlNUFBiNmUvL253aFRZK3h4dTVtT21TdmR4R0tqNTRkcDk4OVBFeFAzd0RYb1pIQTRHaEgrdWwzN3FTZmZiS1laa3JVeG1LbGp3SVpxdEdISDJoMGRMZ1ZNUzRWWWRjZ28xUlFuSzJ1TnBaTDlLdVMyMUgwQWxEdEpTOGRORGhZdit0dW02UTZFYzdBdVJmZ2xXZ2dBUDJwM0ZXWS9rOExXd3RJWHBIRzRoeWhIMzhueklTTGNTK0ZtZFlhWGdibmJUWXdFaTJFQVh5ZjlDeC84ZFlJSFJnL1UxRXFMQytJaCtteUN4N21CODdhRmp2UXY4cVVyQ1dzeEZOaGJBU0JZZ0c0c0pDaVlTN0MwUHFyV0ZZOFl6eThsQnRtSXdzeW9zOHpCRE5ySFZ5NkE0VThGZjRYNjBqYkhDNFd3bTZFR0EvOXMyKzJycVE5VXByN0hHeVova3pIRlN5S1RjQjJhTU5uYlBJd2pmYXV6RStnN1RwZ0Fsd05yTEFMVzUzd1pLTmpDekJyVjFwZmZRSGg4VHNlNUJUR09La3lLZ3ROMzRBSXVpa3F6V1BLbnp2YVNBTEZPdXFudDVZREhKbzhUM1R3eEEwVXU2UFo2b1lyMEdwc25sa3dCWUg0SzJORmJxQkN5aWI4Ym5ZRTRTWGM5OEpBSEpmV3BvSDY2SGpKdGJMQU1mRU44R2xEWUxUWWJvU1ArK1lqSUxRb3VUaHIwT09Md202eFJoY3dwalA5OHUxMFp1QjlhcE51R0ZNOUFPM3hlWW91d01FWkZOZWlxNU1NaVZnUG1VejMzU0I3SjBoNmU0NTFrbUsyNG4xdm54NzhhQ3VKNFYrL0pLeC82MlhXSnQ3S255MjMyQWVTTUFicU9zODVxeUVsR3M5Vm9XSU13ZVRFbVF6SFBwcVZ0T3ZXM3M1V1dFZU9kQzlYT3NOZFBHYUFoYTZLS1BnYVhUbE82U0toNERmb3F0WDViWHlEKytvaUN0THNCYmQzUnIvekdNR0ZtK3o1NmFZakh4RmNXQXJjNzhUc0tReXlzVzJEaDg2MHVBQTRHVlE4NHBOc0lHNG5JWVBldnJaQXhOKytNWmVlUGIxS1BQUU5FNm1mWTdtaWhQamZzZFlyU3VzUTYzQVR3Ylc4c2hwQ2EyRnhGdGQyakFRVFNTU0VuMmlXS29ING5XMEEwdEJDTHdtRmR1aWtEM3hXN3lnOXd5aFdYcGdaVG8vKzhDejk2cmZQMHR0TjNEWUVnZVUwM1NTaXhENDl4L1g3djMvelZYcjRkSjgxczI4Y1lTK0srcSsrZXl2OTFRK24wKzBiWTJBVUNVS2phQStPTDZMNTM3TlhtK2tOVmxXTDByV1A3Mk9sQVVQNzRNWkkrZ1NyZkxvZnR4a2xjNHJBT2pxaFMrOHVsUk5NNlJGTGQ2RnlVMUJBQjZmRXhNVE5SVWRZRHRMWW9WOEtITCs3NTlLeXdrbzZIeVk3TDQxVVdPQUZ0Qnc5MkJSOUZIMHJzSkIwNFoxRWNCMTY4RFB5U0dBQnpkeHlYZmxHdWpOcmI2eldvbWFPaXJQenZGSEMwTFlDU0Vvc0FnZnhmakhzQXBkVTBMWUM2eHdhNjJUL2MxeGJ3MExoNmdnM1ZCcldISUtQdlRYUmhtV29sUFRCWVN5RkU5YVM5WDhTckZaSTV0cG9LdklyVmlVQks4VE1ScWdsZlgvR0ZHWnVXSGlCa2dBV0NRV3hFSHhzRmdlUHB3R1lkb0JXdXhkODVkcXhmRTZKUXlBd3R1aDI0RURKZFdKTVN6Uy8wNGlOUm5JRG5RZ3ljRGhZZGQyOUMybDRZUmlodGNTbVlza1VWOEJDYmRObXh2WTFZbEwwNWN4eVpLNkhwUmtkTUxRdGNVOXdzeXkwYlFGMk0zYWppVnJnNEJWU2FvWnVBS1RuNzMvMklDMC9VUnNJVXRVMWErOFZIWTFMaElZeXhtTndIejJNUEZlc1pOYVpzUEZPdXluZ09yUUl6aFl3YmQybmxnZUJSWldaM01RQjJUT2JGbG9BR3BrUXJzTnlzTXFvV2FROHBLOG9Gb1huZ2VBY0RsSEdYWlBBZEZVRk5wSkF4UG9sM1cyZ0dZa28xc2hncVlOV3orbzlnZmJuWk5nVHorNy8yOHRZanRVQ2d3UERRV1FadURlN3Z0Y0wxeE1YVFFKMTcveDVCNmlENXpzd1JMY1BHUDZVTWZhSEZiS0lTRjFyRFkyTjdlNkpLcmRycEs0Q0QrQ0x6M0FGemhCcmluWThKL1EweTVucDRWbXFKR2hPc2VEc0pCc0NFbGVyaldlMlhiZERVNHVGN2ZSaXBabEdRWmpQMHFYMEJvcHVsTll2N1doK2hhcHA5RW1hN2cyaXFUKzZkUTFnODJMNjRnOWY0czZ0QWE4aHpvVzdXNmVkOVNuankzWnBFdmp5OVRJZFRSZlRuYnMzQUlHT3BDR3lwMk5EMUN6U3RNK3lyMmZMSzJuMTRTT3NPbHBSajlNTGk5SDJZMWlVTisvU2ozNkUrT3h3Ui9ybHY3eEVhSjJtbVNzb0lEb1AvUE9ENSttWC83VE10VS9vZDQ5aTR2d1dGNGJTRDMvd1lmcnhEKzZrMlhGd2lmVFpPaVp4OHVMWlhucng2aVM5WHFvQVB0MUlFL1JyK3dHVzEveEVYMVErak9KcGRIYVRDS0FjYXBkeGNPdUh1ZlR3RmNxbXloZ0xaaUxVcW12UU1mc0ZzTm40cVhTbk1uVXVnSUlyZUJZYVVxQW9IQ1FONFFlZVh4L25jd2pRTGVKMzBDYWNERVNFQkFZMDJCWkJjZmtmSlU3MjJ1djRPWVdMbytWdFQrTWtMWVdnZkNSZGVIRUZtZzBUdzJxU2JzSkNSaWdoN0JDcjRBeFJ1QXBPdlJVU1VtMGsxYVNIZG9SWEFlVmJwT2U3MmRnR0JvTngwb1p4WWQ0aTc4WWdYSVdOekdtbVNmeVVUS2tzREFKRnEwbi92Q1hUeHZ3N2hCaW11RXd0dGlra0xiODFlTlprZEZBYkk4dWpGdzhiY2tHbTBheVdtQjR4TVRrMHJBOVdBRVBTUVFtSzFsODNhdVNzMFkrcmhqbko3ZFJzQi9RNVgxclpUQy9mQU9iRFhaeWczTWR1bndORHQ3aCtCYk1kOUhuZlllcW1IODMrcG4yWmFLQUc0WnNxTmNDWGd4RUVmNEtMWUdYRVBkamdLb0lyczZUMCtiSFNzTFk2MEpvOEt1OHpXMk4vZURVNzBBWUVnTFZrQ291d1FEVkdrZnBtSWUzaXBJbGNZRjBPcE1EajVNczlSRE9qRFNMT2hYQXh6b1Y0eEdUQ2FtR2YyUC9ZMjA3Mk53OUd5T0pqRDFOTjRPSGFyMXFRcm1oNXo2RzNINklBVWxJaElITUNvTlNtYmloU3B2VXdUQllCWjhaUUs4MXppbW5BQktvdG8vRVovaFFyOGxIL0pMd2t1c3ZYdi82M3hLVHdNN2crZ0NiWENvMTZSZDV2RFdMUUF2Y3hmcVVnOHg0U25YdmxuaG9rSHdHNlVqbkVKWHYzanJpWXhHYXdISTJxeHVUOVd1OXE2MUJ3RUg2TGU0clRhYUFzeXpDMU5hQW5oQkRVOU1ZUlE3Z2hwSnpHSkJNbHNsc05ndEVjRzFpcGk3VEp1TGNud0F1ZXY5NUlkeWFIMGhWS1lzYXB2K3RpRUdSWDF4bnh5MXdheFRYdDY3MmVKcWVHb3U3dnk0ZFBFV0JMVkhGSXUyMkFVV2x0WGQvQ3VxeEViLzE3dCtZUUp2MWdueW93TXhZNlRMbDQ3UXFXYnpmV0d0WVBOWVNsNTJYb3NTOTk4dkUwWHNGNCtoQmwyRWt2cjBjdjkvRUdodEp2L3ZBZy9mTi9lcHhXM2haQjZLTUF5YURmdnp1ZWZ2N1RUOUt0bTFSOVlBWENxdW5KaXgyZ0RhdjBnei9CWGFRblBYUi8rL1pJK3V2djNra3o0OURQeFJyUDNRUFc3VGd0Nys2a1YrODJpV2YxTWhuSzN6RTluVmhmdi9oSmVNd3VJbmtHdVlibElnMGh0SzBXcUJERGkvSTRhTUF6VkdCSkFYb1lub3Q0UFBsVElhTTdhUnpZTUlsdXBOZnl2Y0pxVEdZcE1JelYrbG14aHVJY0N5Z2l2WUJ6QlJuS29xRUxCKzFmUUtOdFhFZnNsUHlvUnhheE00U1B5aC9XQUp4T2lBV2FVTW5rdUg4ZCtWQlRtVWpyOElxWlc0V3Z4ZkFxOFdnNHdKcnpadVVDcUNYUmNyRUdNUlROWm11dGNtVEV6Q0xFSXZrdUVRdndrOUc0QnNKSGY5VGdNa3dIWCtRQmRoWXc2VnVXOXBETmMrcE5wRDF4T2ZNNUF0ZnNRQjltWC9SOEJnL2llOGpma2NiRmNrSHl3aDZrZ0l0cHJtK0NGUE1JbzVub0JvRG1MeE9RWGw1NXgwYmwwcFdwRVdiZjBkbzRQOG9hOW5rbzJsT3dkdDNGRmhwRkFHZGVLNGcySklJVGhUelVzVWJDZEdXVFBDaGZIbDVSYzVwbmtubGxQaG1ySkNxZDY4RWhzWmtLQnZmSElMejFpd1hROUs3VWZXckJVTGFQTmM3U2haQzdJTER2YUNTdUdDNkU5OUY2VlhLMWs5NGZSVU9YeUg2eGlYeUdnS0lXRzNzaVlVUUJzUDlpSHd2Z21pNWtVT0owbUlkWVU4WVBNS3R4RDFzQVRsMWVHekVTQzhLTm4xaHBJRUVHa1hILy8rekY5UzVGMXAvLzZmSm5pZEU5eU55RnpITHpVMXJmK3JZS0R6dUtzaWdZUTR4VzVtYTRsLzV0ZjM4blRjMU1BM09nTXdVVkR3NEFjWXlibjdsOGo5ZldaZldhRnFsTHlMclVGVUlFVlZ6cEdtMWJBb2RENWt3N3pKNWs0eE0yeDF2QXRXZ0grMFJMSEZ3NmkyWTlCek5WRGJCWHRlTnRRZ3NWa2p3N1dGeUVGckJ5YnQ2Y2lmQkNFK0JtYjE4aExYUlBSZyt2K2RtWjlQRHgwL1RGSDU4U1g5dUNOb2dKc245T0RQL215VkprcU8vY21Fblg1cHFnMjZuOXhOcnV3TUlaSVV6eDBmMGJmSFl6UFgyNW5UYko5TXBjSi9YcHREQzVtT1lZdnRMV05jYmZYNmMvUFB3ajdxYkNIRGdHbzljKy8zUWgvZDIvK3doc0ljMERLR1k0d2lyNjR1dTE5T1dERFpEd0RhQVJGZmFqbW00QVJGVUF0bENjMi9TSU41YTd2N3NlY2JIbGJkeFRZc0UxNlArTXhOY29MdmlOTy9QcDB5dTBtbTZqZzhiVEY0RnRsR2F6TTRYK0VBU2RaSEUxS0RKWEhLSEJuc3JMdmhSUzBvdy82N0szRTBNeUUzNnBPTFZVWTBnSjdwUzRLcFcwUWlwNjh2TTVQMVBrMnZKZUhoNVNnVjBHMEMvSWRJdWRnelNnZlFtUUpCWjdMU3prQWlpRllOMFQ0Q1FxM2tqSVlMelVjV2NqeGt5QVhmY3g0eis5SCtPY21hZG1CNUY4QmVTejBYN2JyRHJhMmtNMlJWOG1nbytjWmdPUXBEeGNDQzBXSEhWWnVIcmlNZFRvbDJDelRxd1ltL25YR2NRZ0hNQStSd0w3OGl4WTFLeE1Xc1JpNjVKN1lieHp0SFVEbkZZUndtM0RIY2p6WFVxOTRQQmtpbjVNWnJ0ak5vbUZuYmVOcGV1TGMyaWpYWXF2TjlNR21yaWpNTTRsV1R2OTVmVTV3OTNEMG1vbnJxTjExZFdKSzZqMXdxTUxFekQ3NFFPYjNlb2ZJTTZFaExYUTJsWXpHVVNCTktxK2Y5c2dpMkROckVYdG82UlhDUG83QWE4RFhGODhrQmFtcFVSYVhscVVEajd0Qmg3aU9welNVdWUwd21MaXVXemJMQTZGL0JEN0FCTmoyUm1iYW9kUlhDR1hqb04zRnB5K3UrdnVwbkhlMUpSdVZUZU0xRTB2OVRXME1IRXFoS3FDSUFDcWJPdjJGaE9rSFNiS05kUldYSW12LzM4dmhkYWZpVHN1NVBXa1BFaUlNelJPWWI5dXdhRUtLejhqRGFVTmV0UlRONnJRZXZ1V3NWOFVvZ3RMa0c1Q3MvTSszejh6UFoxbTV4ZWpsOVJYWDlIN0NTQ2g2RzJEdVlPMFJSNWgzbCtCd3R0SlhLT1p1Y2xvaDMwS3VITnJ4a3dnclpLM0dJaEs0NzBhU0hoZEQvUklXa2ZaN09KQ3JoQnpldklpbjU2K1dFKzNFRHpYNTJscFRNYXlDeVhwdUxoQmtqWXpXRUd6QzNNRXczOVBuT3NGbHJjZXRsWWpRZ2dMNGdnaHVMTlpUYmRvOHhKbE9BaUhBU295ZW9BczNMMC9SWWZtZHZxd0w2ZmFDNm94OENZNlB4dFBQWU9qYWZtTFg2ZmYvZW94Z1hiUDJKbVlEZUpWQytuZi8vampORHRHRmhEczJzSFdhZm9QLy9EYjlKc243eGhENS94RUZBRzBNRDdrMEpRemhsWHMwWjVtbmFFbVppQlBtTFp6U29VSU5aeWcvenNBYjg4djlxYzdIeFA0Qi9kMWQ0cU1Pa3J3b3NsY1I4N201Zk0zUElPbnBRdEZWcHIrWWdva2FUUGpnL2QwNFRmT1FrWGkzK1dMc1BEaFo2MWZBYk1CY29ZR2ZaOXhzVE9RQkw1UElWVkhCbWlCbjBIWFIwejF0anV4b1pjNkU3TzEwS095Z01sWlFoZGdCWGdLcXhwYUYveHBVYit5SUZPUTBydzhwRkprSFZqa1JXTGZZc21NSGZ0K1ArY3l3dUxQSGk3bDY4WnJGQ2hCZkZoTCtvejhNVW9zRU1hQmlTRCs0OE5KbkM1YzZXK1FYb21xSzZYMjlHRTZPaWxHNWxLNkRyQWVtNEtUeENKc1ZWSUF6VjBpeHRSQnRrY2g1OFFiWmRURkJka1kvc2Uyc1ZnV3ltZHRkYUVpc01GWE5PTERac2tEWmJoL2ZTWlZLWXM0SUlpNkRFNnJpK0xzVWpjREJTb2I0Zk5hV3RGR3R0SEFjQ2ZDcDQ1MTFZOWJZTitxRE9UcDJya242OVZ5NUYvUmZUSTBEMEpTU3laYUVNT2dDbTJ6Sm1ia0RBYnJWdTRRWXl2VDJJMkVFdGZNWWx2dVY1VldHa2NuNVRRSmtQWUFJYTRZc3BqWFVkdTI4Z2gzRnlGMmRIckFqTVRzQUxXd1JJb3BJbHlMWFROT1NhMEhKb2I5c0NDZHJZYjR5VmlCTDIwckVsdGFwK2g4azVnRFRON0N6SGEwbWEyZWQzYTM5TWxEYUdYbnhQdjVuNFNzTVBUMVh3Z2pKUnpuNlo4VjNoS0ZmZDdOY3BwRThKWEJHNFIyc0I3UzZBb3M5OHB6dFlEYTRsaWY0NEtZNVJINExFdTJ4a1pHaVUyU0lWdGJKNHRML0lNOWNEVm1oaWZJYm4zdmU1K251eDkra2xZM0QyRGEvYlJKN1NrU1BlaXBoNnpqM1JzMzZXR21ld3pOUVhjdDJ3MGhpS2ZvNERxTjY3ZDNnT0RhcUVSaDhXNlpraDBVaFhXQ0RTcHg3VkI3RE1ENWdIalA2NWRIdUlsNVlBOHo2ZTd0YStBQ3FUM0Z4ZXNvOUtUdkVCTWRwM0hlQXl5YTMzM3hDRGQybTJkVmdUWFNGa3ExYmx5VkpNYnQ2N05wRGxveXB0YlJCMjRLMSsvK05UcUJkTXltUDRCVWYwTzN6K2REYTlEemFmcmxGMStuRFQ2VEowdk85cVR2ZkRTWGZ2STNuNEtkUWhoaHllK1ExZnZGUDMyUmZ2SHJMOU1tTVR2N2JwVXd1UnowcTBGUUpwNjJpUXZYeGpsMlFYdHRTR0lGeVRSN05qNUdrUDdXVkxwNmpYRmswd3dpb1VuQUlIU09UY0R6dytBSEJLZUoyZFk1VDR2dkVlWHNXWGErVVZ6TWRSVElHVFJGV0FNQ0IrSE16b1dDMUhMQ2FNYmFoei80V0FONmhBTXdYdVJ4QkREbm9QS0ozbSs4TWVnRDRxelhyUVI1RDlxRjk2dzg4UVdyUWt2S0NpaGZKY3BGTHp0RU5QRzBoRVJkV25xWGNzWDdhZ3hKcHkxaVF4b0xraWlMeHNLR2t2bTlYbEJ1NXVyMGY2OXBiSjJaUVdZSlBVeHpQeWpoY2hHeEdOeWVpM0J6TmxNQXBac2l6M3R6SmFKdWtmNU5BeUwyRDZKWkc4U2FCTmsxelM2QmxxOFI5TlJkOEN2K0RYaXVpcWtyNGV1K0NmaFV5TGlSM3N0cnlremNCRUlnaThEdCtVdnFJcjdnUGxUSkZ0WXB6TFcvZUppY3JOSmdiazFmbXZYYmlFOFhMMCs2M25JajA2UmFNUWFwbzBEVTZCN0NOSUNnYkV5azN4RkVVVkNxc0E1M2wzdGpoZkYvc3B1SHZGZmZuQmdOak91KzdHTDF2S0pLZnhmMFlKTzFybTNzZ3BDbTFlOGhCTUp6T3lRejlsc0JCUjZzM3FJbUwyMmlBWmZUM3NuTGRIRHlKaDJldnNIRldFZnd2VU53clVGY2RJR2pJeXU1UDdRU21BM3FyanFJVjBoaTF0dGRuS0VBWUJaRVltb3Z3YWgySlVESm1MM2o4ZmppRkNHV1NFa3JVRGozUytFbFlRUnhzSDUvNTNrcmxGVVlRZ1VjZUdIcGl5Ky94Um56Z2V4WFduK1pOYWVXTk5aa2lZWUMxeThENWQzVzFYRWRtL3Vkd1BnT05UR3dXc0sxbXA2ZnA3Wk9JUEE4S1BZaHpvMzRETEhLRXpKU2RxaXdhTHBLUE9tWUREQ3NrdEVER2pxQXRMaW10a0xwWVh6NXlDaVcwdlFZTGhaS0VHdGVmSnBuSWtpeXhaQ0tKbE9YanF1RnRFV01hcDFheDRQS0hrS2xEUXV1SDB2R2lVTjBMYVZVYTV3YXlPbXA2V0EwQjh0bWNVTHVSeWVERStLeHhwWE9lTTVPckYxUjR1MWtNdG1kTkl5bE5nS3FmOTIrOThBVUhqeDVscjU4dG9xTHlMbXdQOS85a0s0TVAvdVVob1BNMDBPb2xDbDkrK2N2SHFiZlAzck9NQlF5dlF3V3JqSFV0VW5MbGhiV3BTMmlEY0RiVUsrZitaZzNyczZtano2OGxuNzRGM2ZUMy83bHZmVFp4MVBwOWszcU4wZUoxU0xNRFlvZmtUaFlBK1AxbGxLaDN6OWJUOThzNzlGaXV4Z1ZLd2Zzb1FaSEJjVnUwYmo0dUFyQmRaOW5GNnR1QXd6WjJnN2xjY2VBVU9IQmZVcVJLcmpaTmR3NjYzK043MlZvY3dTTHdvL3VxQ1dLSnVWN3M5TkZBdkxXMU9ZUlloM3NmeTlEZk0wTWk0OTAva0U3OFZaT0F0WkNlUEw4dW40S3JuYkx6Z0NqaTNDSFlQbkN3bUsvZkY4SFVyNkQ3NTFZc002QTlLdkVVRnRDeGZBZXF5TE1JeVl2ditmQ0dSWVJHUUNJWE9GamhzM0FHOFpnM0VoQkYrYWpkMmNwNG1BTXpvV1ZBckViUEZPZ21WcEZBc0FBR1ZSQURXRlVPa3BIUWhOelM0U2k3cFJmTW9HTjU4UVpHU3VTd2RUMFFnMXl0RXkya1o4Q1IybXNDYXVmN0VTWk5zeGRUZnRDYzRHV1VGWHFFdmNwd3Qya1FGZ21FcWNVV3dFenFTZDRZb1N1V1lkb2RNL0dHTlMyOHdPNFByUm1ENGNMbzZNeFRMWDZIRnBIeWtsOWFuV043V0ROWGhUSlV1RTBLeHRDazdzLzYrdGxpSVNKUWNRV3RMTHN4K1Z3ekVrQWxDV1kzekZsTWZpVk5SaW9NLzdTaHV1ZHA5K1J2ZS85dGZjU2U5YkJWMWhZbkkxYU4rcStMTlBSQllmcGgvaGVQeDlNYXkrSStWUVV5bGh2bU96OXhCdXJhR2FGaThIK1U1SUJycDJqNGozWnMzeXJ5VEpaeERuOTZhVWJFRDJmY1BkMDIrS0QvTmV6Q0RjaHBGWDJRYStqRXRITjg5K0dCZFI4cnRmdlpnNHRhbmZReGRFUlpUdkVuYzVSUHYxNU1vYmJ1SGFiMzlBaXVKeUdRYlVYT29mcG9YYUxxYzNyQ0lqalZNYTF0VFhMMmg1LzM2VWVrRXp4R0tQRmhnWmdIQm9QNHZIVHhZRXVDVmpvZlRFSWdnNno5VmxLV0E2WVZMU0xLOHBBV3NxMVRxR0pkbWpuaEtualo5dTQ1NVJFN0c4K1NXczNLdW1UZTdlSWkxR1RTZ1hHWUFlRi9HQ21lbWtGUGdpSy9Pdkh6M0hUeUxhaEVLb29teFlXMDBsekkrSlZ0NjREZThES2JRQ3k3Z0tqZFFVb1Jzb3p0L0hwVzc1V1NSamhKWEMrMDFQZDZTYy9BcGc2UlpZUldNYzcrR3NEUlBXcnQyUmhqK21OZjRnUzV4eTFXbEg1K0V6MEsyZlM5SzBiczdpcVkrbk9MYkJoWTkxcEVGeGFOd0lhYXNXTGdPYXhUSTZ4QVBkb1ZiTmZ2aUJNUUl3TGxQc2VRbkp2bitETlVSZlBqVkNIM3d4Sk5NQ0hSY3R1NHFRbTBqeWZ2SUtJSzdZeGE2RURHcGVuYkZza0w5c29zQk92eHhJckxXbHBRRm93dDRjanlIdXhFUGlkb1NCcHdwa0t0am9LWEJhOGpkN0hzakplL1pjYVhnQUFRQUJKUkVGVVJtZ0ZTRklUV0lxbGIzbXVwNEF0WVBHWlVHb1FpNDNyQm0xcGFTR0FvU05XRmZRa1RXVXZubDIrMEhEZzNKVVBOdlhMS3ppYXhwQzBIUGlqMnJhQkpwSFk3WUd1MEhFUnZzTGE0US8yRStMUC9pWVl3czJJbjFpZzhhU01tRE5pOTI4U3ZsSTBHNXV0VUVLU0lwVDhMa3BkdTBrK1VkdjdhakUxSlFlV1E2M2p5NDZRWGxQQktDcmRUWEt4NDZPanJQVUdxV01tUE1Pa1IzdnZ1QUlRQThTeUF6QzdLZVhJSTN6VkZrZjB1NnBwYm5QZk9BWU9MM0FpQ0RXekgxcG82RkFFREM2eWo4dWhHWXpGcGtDdXNEKzBFdW5HRjl3bk5tTUszUlN5SU00akpybzRJS0ZTUVFnUlFMWjlORFNBSU9TNUFCTUtPMGowTUdwRE85a3BVamlFR2ljeXFSeTRpUXhUeDhhRUFwdkZQbGxuWlFaV3h2SEFXd3AxSUJ3c1B3M1I1a1RyZHZrNVJjeFlkd1dFeVRBMWQxM2MxSGlCdUxFaW1uV0xpY3NSVEdXUEpSQ2Y4VS9Fa0FteTJGeTJYTVhUd1I3Ykd5ek9tbjNtdDZGUVZCSVJVTlZuNEd5TllVbm93UUJRcVRBUTR4WUJFU0hycE5EYXcxcVJWcnJBMVZWd0U1b0FNaTFmMmRvcTgxN085L2xPeXBWZWNCWk1nU1orcW12ZkR1ekZwbTJuV0JuSGZPYVlSTUlPN1lvMnV3N0ltcDJBRVJ1aGxVc2Y4U1RPdDBRQ2gzdjMwRm1rcENaR21Tek1McVliMXlaeEYrbmErWVpPSHlZa2dFUFFEQU1ZQTlZNHpmYjJkOTRRNks2a0R6OGdCblIvRVVnQ0dWZndidE56dytublAvOHhNYUxyNlplLy9TcTllYlhPaURmT25tQS85ZEtwK1lwWmt5WTJzS2puWm13clJJdzBYeUU0MzUxZXZMVkdFRGNKTTdxUHVPdVBnQzJNRFZQQ3RBK1FGcTlpbjFtRmo1NFJySCtOWVhCbzdBZEZ6MHlEUFBGVWhkSlZrZ1NmQVVhOXRrQmlnS1lDL1l5Sk0xbFZSSnM2Ry9PRUFzZFhxOFR1S0Q5YUp4eXdWMll2cTFTV0VIdXJFRU03b0VUSnlWVlR4TWtVZEl2VDg1VE1iZU9pNzNBR25LTnVubFl1U3NOTXRoUFZEV3FYK0xlWUs4bXp3TGxTSzAwMkZCcUd0YkxRaklhSElSUUVGdCtsV2QzbWNPL2dmNXRzOGloQkI1NzFKVzE1L2dKL3ozaS9mcG1aYmpPVi90MllGV1FJTFdiR2lvaDM1NDBhdnhaajFjYjF3OGp4azlCMWxJbEJpZEx2Q2NGR0xmajhFSDUwWnZGd1FBU2d0TEJZSTh4aDR6cG13ckd4Q2hOZmx3dFRCaHJYVWVjYXlNNENzQWdkWENoVGtmYTh6b0NvUGloU2tKY0x6bExiYk1oN2k4bmZsWUFqeUx3eWdDT3ByZm9QcTRDQW9ndVZXZnc1cHIvQ0tLS3BSWDA3Q0NGSEFIeVd6ZzQySURzQVExVGVYdU5BZEl0d1B6bElTNG9NeWg3UzZHNGJLMHlrOWlDMWFtZHdma1gzQlF2SWFjaHF1endhV1pjdHAwYUFBVUlMS0RpNFhwM05iRWZDNDl0d1RhNk5CbmV5dFNEU1huQTdBbUliQlBOTi8yTHNFRGdtYmxFa01JeGJGSXlOc0kyQm5yZ2g3QVFIeHFYUWhuVTBNS0tjL1NiV1JleWpnMFpsblRCdU1ROGprMmtwa05iT1FWaTJ2NzFBZ05jZ05pZThkRTVnYWw5MHA2VVh5K21FTWUxZXc5NWlsbWpZa1ZKdG1FMldNUU1Lc1VKUWZ2M3JsK2ZESC9tc3RkbDAxQ0RXNTg4QkhvWkFzOHdTU1JUTzEyYUpuclBVcmNYckh2cnkyZnlTU0gyZi9mRDkyYlB5akhYeERZd1RBcUluT2k2enFwSXNuNW1mY3l5elk2eEVPd3NZYUJXN1ZhSjNmSlgzNUhpMkM4NmxpaERYR2k1VHhEekk2S3paR1dBQmxSTFFpd3hnYkFhcXFNK0EzYXMxUGsySnl6QUYyWXZYaHRJM0JLR2ZMKzNqUXFNc1FJUWZVOGhmMndRMndkekZIU3lubGMxdGhyUmVCZWtPYkFLM3hqanEvYnNMNEs5RzBxOS85Y2YwR05CcEZZRnpEZzJWS1ZwK1E1YVN5a0t5djhhZXFFL0Y2aGdteWRJQk01NGdQVHB4T1QrK2U0MUVTUzhkUWUwQVVRTktzUnZXMStzVk1vRUNoeFVjS0xGUzEyRzZQamVXdnYvZDJ3eGhuYUJselJEZFQ3ckI0ZmwzMWdrOXI5RW5hM09iWVJiTFFCLzI2RFZHTjlPOVBUcXg0bVpiL0EzUGgzS2FuaHBMOTI0eUhYdHhNRjJkby9rQTAwNjJOZ3MwRTZoRThrbXZnb3RDNDlBZ3lyS1QyYUxZNXRDWTdhQlJqdEFGa1NPc0dQaU5BdW84OGV6SUFQSTh4cE90QVNSU3p1ODVOeThGclVuRFVvNU5GZFZ0eGpVOTkraVJ6M3MwamZnSXRJZ3l0aGNVSDlUeUQ2RWxQMEVua0JvOHhyKzVUdERuKzUrbHY4RFRRWU4rSHJ2Q20wWjg5eFNyTFQ5UEVOdHNsblAzVEROYnk4TWRJVHJTL0FTTXM1SG51bXVZbVN6UW4vdXhjbXl5WnBNMkN4UWpoc0VOTFpWUVdFaThmbDBLSzR3STNxTmJsZ1hwWFVpTVQySWx4MWdscGtaNUI2bm5zZmgzOUdEQ3QrZERTRndzSFRlR2cvVEJEQnpXSU9ZYUFYQXpaWDJBdWVabUpxbjV1cFYyMTFjSTRrSlVhQlBiaGdBT3dYU0ZrZmp5M053a2crU1dFNGw2dHdYTUlkMEh0T0Q4Y3VCQ0R1dEp5UzRUbG5qZktkKzFLTzJsWGVPWnRES01EMWg3VmlRZW9qYnNJVDdUeDM0NXMzRUVRVG9rOUlHZ3Y0ajRJNWpxbk14akoxbWlDN1JTdElqR2pUT2hZRHhBYThyNVoxYlJKNm9DSEc1eFRyRzVBdEdDWURNckJUYlFNcEVCUG5OT1hWbUZnK3Z1SHVkYVBXbmxGZW40clowZ0pwV0ZtVTh6TjFxaUJ3eEFsUUF1aFZVSUtYWTZYaENCZ0ZaSHRtc2x1ZWNjQVF6cUptVUtSa1doeFpXTlpvTkUyWHRkd01zTWsyY2lFZnF6NSsyNSt2STgvYmZGc1k3T1ltdjRKY0lRQm1sQ0k5SUprbC9SelI0WnIwUWd5NEVtZnpoVDFDR3hFSXJSWVdBYk5sWng2UnJRU2ZuNWF1cGJvd3lNNFI3T0o1eWZKdTRHc2p6bmNGc3NITU1CT2ZhNUgyYjc5QTR3Q3hydVBYMjJrbGJXS0pTbkI5WXBrSkRqUFZMcW5KMTFiR3UweHZudWQyL1FhZUVxclpQWWMyN3RwUERobjMyZVpoRUUvMGo1emZyNklhRUFwam9mSWNTM3NMNWZiS2Nlc3BrZllPMFpXOWxjV1FMUWU1b1daOGNKOEEveWZEVXN2R09DL3R2cHpkSlcyakpPQzVpNGpWaGtCK3U2Y1gwa2ZmalJsWFQveGhVc0lvYXhFaC9yUXVuWnlOS3AzV3NiZTJtZHZ2RW1GdGFBTSt5VEVkM2o5MEo3Mks1d2g0ZEIrQy9PajRIYldxRHVsaUV4L1htU0NzU1N3SHhwVkhVUWx6c2piclcyaGdJbmJpUU14UmJFQmJwQW5JTmU3d0VoTDdnMFIzdm1vQThVVWRBSVhndTJVcHdGWWxGU2x4UkNnQVF2OHJ6NFgveUdjMEtTK0hldFVFdk1MaWpwVVVad013VUJOQU10a25GdGh5ZWt4d0xkVmdMR3c5L3RXcEpaL1VLR3VDY2VHSktENjNvdjZBUm1sYmFrUlNsRUdqdVNqekdYODEyNE9pRVVLV014S3hTcFJCaSt4QUhhWWtiNkRRS1dDRm1ROFo0OEsvVUJTOFFCTGkwZ2haYkVKOERUeFZ3eWlZdXdvNmZwYThGajZ4dnJHWUliQW8zYUk2d2RGK3pDUlhaZlpock1LdG5HV0RmUUltYmZJOUJORjZtRWE2YmZhenpzako3WEpkNDdOemROOTlQdnBsOGUvMFBFa1d3OGFKR3VmblFEcTBOY2lRbUNUV0FSRW5zL28rVVBjVGxOREhSaCtZaGt6MUQ5d2g5c3c0c0F3bFJWZVBNbkxEV0VIZ2Z2T3QyUGFFaEd3RkJnYXo5eHNDYndCMHNrdXJGV1dzUWFUTkdlVTRobXc4RXptcldoUXRQd3dCeFdreEFSTkZ5NGg5bmVYaURVMUlER25UTFlDTXlBRUdpenlSazRySUsydDZZem9KQmNiZ0JyQytnSDNTWUxDOFE2K3NiU3ErY3Ywc3VYTCtLc0xER1N1RFc3dVRuUDlKK2ZoZWZoMlNpc3hOVFpOTEdYQVNRcUU5MUtOYklOL0h4UDNiUGhXWjB5a3dsQ3JYQXNUUHk2Yml5dEJsazVoWm8wSUdGbi84NndidjdPN0oyYjVWNklaY3NiQndtREd5SEhuK3pyM1VZbGdHdVZLUDFiRFRxN3dBcHpGbUNESXR1RUJWWWF4T0prRUcrVFRyUmxGT3NoTmFSbHJLUmRBSlREb002SEp2cFJHb3lUZzFZNlNmKzdFYm96UTV6ci9adlRiSDBYT0Mzd1dnZ1BRY2EwWW9PWkhHVm1IU3FXREZPTnZ2L1pIZHE4REJFM3dwWEZ0ZXI4emkzY3pWTDZ4MTg5QkVxQmRRVVNlNThZMjVzTjJ2TFF1ZUg2dGRtMHNyUkNRZlVqcktUUjlQM3ZmWUNGMko0ZVAzdWRuajgvWUpBdWdYUXN0R1l3WHBNa1FXLzYvaWZYd1hQTk1DdUJXbG9zS2hOQUhETFdWRGtzMEYyeXdGcWkrMWgwVy9zVWsxTWRZQ2hCdCtybXRYRnFiOGZUQWpqRUJhekNxWEdVcEYxN0NRZjAwZEtteTRDcys0ZHBVOFlhMjkxaXZpU0Yxc2FsdXZUekVEYjQ1aUdvcEhWWUlRUUwvaUtmNHdjRVRKdWxMcnc4UndXWmdmTG9GY2RoR2RNMnptb1hFNmpmTFVaSTJZZk9NK2JGTi9sZXVqS3JXa05ZR1NmRzVtQU5BRlJaWEV0VG0vZjROeFdhbytxa1FlOWFoYjlDK2VFOWVXK3VIdStCMFVOd1ZRM3BjTDM4eENRMVh5R1laR3dFQUJhRkwyL1VybWJnMzVxSXJraHRLMU5uNWw5MkF4bkNHMG5nWWVJaHdYMHdmL2I5Zmpma2RHRUFIRzA1T2dSeElZaThqNjZZc1NDNXdnZUtMQjF1cFZuTEE3SlA3VmdMQ3NKMk1qMWFOVEs3M1JsS3RGc2U0TEI2b2w4UzFoUXhMK05hYzlldXB2dkVtTDcrL1c4eG5jdkVMcGlBQXpLZXVHU3FzSzQyM01SMjB1WENMS3hYTkZDNlI5dVBDakdXWGdTS280V3FkVElxYkU2SmlkUmxOSnRXZ2JWMFdwTWVsSXhrS3A4cVpmeDR4NW5uNmZkTm9CSkdyMEVRa0FJV0JmdUlzTEpvZDdoM01uVVAwdGVyMkJmdXFTNmx6NDFzdzhQS0RzYkRzWEdpZTZVclY4T2RkT0NFTFhzN2pCWHc3RXJOQXE3TE1XQmRjV0hzS2dLQTlyeGo0N2lTZzl5cks2WXpPeHhWTEU0VFU1eXR5d1FlUXV6eWZEeEhUWGpDSXdTekFiSWllSHhKbkFJRk5lV2g1Q0JBdjBmN1lFWXdPVWxGeldrWlVTY0NTTUN0MXBNdnoxWW5JVXBDVkZoWWtHYThlaWdxbnFKRXg3Rk9Xb05aRWF2eE9TeEd0RHM3RUVvcyt2Vy9COUdlczQ3T0hsek9kcHJYSFRsaTZ3d2xjNEFyUjB0cjVrOFcyMmdlQmFFZmtYZzVZV2JnQmdEVnZnM2NST0FVZmZUeUgyUllyRjBTVURzd1YwOEU1NjlkR1dCMklXUGppVzl0SUJRT2dCVWc5emhUUWdOWTRudGt6NXhVOC9rbkg2VzdWNjZrVHRZL0JXU2s5TkgxMUU5SGlsL2dJcjU4OVM0ZFg1U0FKSFNuMTl0Rk1vVHQ2ZG52SDJHSmRhUnJkeFk1MjFiNjlSZnZhR2ZNOWVtMzFVVG85Sk9Odm50OWpwWTJ3K25XclJGY1Z0enBYaHZnNVFtYVY5S3JwZTIwUlZ1Y01sMGY5c2xvN2gwQlVjSEZQOE53NklFKzcxeWJTUjlSTmpReGptSWF5S09jNkd3QjdwZ0dLbVE1RldSMC9PQTUydUNoUFVJbE81WFR0STBnWGxxbHpHMkZXQ3IwTkVpMVIwK0hsZzRDZ09jMVJHQzhVUVVsYndzN1VmbTJZWXhZYzZzZ1VtRnBOUWRYWXZGZTBEelQ5OHIzUVVlOFg0VWduMGYybFBkSDdKdnJoeWNtY2FQc3MzNWpES21oN0s2YlJwVytqSGRXK2ZuU0dzOWtDblNIbGFaUTdNTE5kbUN5eWswakJiVVByUm40MS9xRjVpMGc3V3FTRmVTbXZpeHlkSEVLckV2VFRZSGtEWlNndmtJNkluQ1V4SjNFS0JRMDNsZ3RxZ1hpMzBQcjhsQit0L3BiTjBGaHAvQ3pIYkd4SHo5dktqU0NlNWlZcHVPMUtrc2x1akp3VGVIK3VocStUOG10UkRZRGRnaWErb2hVdFQyd2JLdWhsV2lMa3Y1U0grYjJoMnorR1VMcjE1UmMwTHVKZzJxanBFYXc0d1dDcWR0SkE2eEZhN0dEbUFsaEJiSkFaTzl3RVl5M2JPMHdZcDQxNUJFYWRoelZnakxkemtmQ2d1cG9taGJIU29ManUyaGVHRUZ1S1FnYzBMR1RYdGdmbThNWkF4VEVDcUEzblVHRTIyU0w2ZzJ0SUE0WnhnLzNMQVFXbjFENzhVbGpCcWFGRlFObUpYdHhkOGRIcDRnWk9aaUFVZWZjUnZNNm1nUmlyY1k0TU5adkFmR3RXN2U1ZGtvUEgzNkRzTlk5MWFJRTh3VVJYRnE4bm1QMmIzdmlNeG9lbDVlUEJCSHlMZjR0SGJqZkVxS0NUUUkxME40QkFUVkRtWG5tQ0IzTys5c1hCQk9GMXdweXFLZUdjbWl3dnhQczd5VFpYTmRscGtvaXRtR2kyRHlMd0tVWlI3VHJ3bWR4TEFLME1IU0pka1FCTGFGOXlpbmRFemEzUzJsam81T1JjNVNubE9GUWxFWVJyVzNRdGtYQWVZdUkvdHJ4VnVyYVBtVHFEUUg0cVFHNklBeXhaZ0hSQ0FnRS9TQlc1TXg0TSszT0hETnhlU1Z0MDN6UDhNb1pETDY5YVMwY2JWdXdTS29mdDlMSE4rZXdsRGxiYXVqdTNEU2orTjMwRzdCUFh6eGVBK3NFMHpGdzR2SGpGYUE1ME4zWXRiUzhTbVlUT01zRzJMSXpyT1d1WW5kYXVEdEdBZk5DV2xnY29TODhHVW1zUEROeWV3Z3FuK01WWDV0MFp4Qm1VRDBCbEF5MG9JWVN0Qmg2Rm5mdjQzdE1rNzVLazBRd2VLUGR1SEdkRndoZDlrZGhnWUZ4Z0ZMZGhBOTJzZnBhOEZnRmlNS2VsaFU0dE0yeVRRWllHNTVJTy9SVVA5bWxiRzR2NktHQVZldFphVEJJRDEyY3N6RkhsVytMMkpreFVBUHNKb3RNSm9reU40eml5WVozd1hjVnJqUVMyV3Y0M2FTYTV4NHVJZC9yZUNqR3RZMXBlbTFwcUZoa3hpVTBvQVh2N3p4NzZVS3FVekRHMUhqQ010S2NYOGJJSGVJaWNOVnVvM2FVVUxFUkJsS1NtUkhnWTN5cG0zd2hQOW1rYkY2YmkvSEZuMlBoRW9Lb2NBV1ZES0NBMHYyU2hpVStoVlJJY2QwQ2ZtazJMbUlVZk5xZkk5N2htL25aendmdXgrQWU4dFMwcWhyYVFLaGxBdUl5TkJHMXJseWo4U3ZYYUN4TDYwei8zTXIrSFdvS2o0dUhXSENENmM0SGQzSEg2dW4xaTZlMG1DVzd3enBzODlxZ202bzRJZnQ2cVZYT3VNWTVjUksxelFuKzhjSFdKc0g3Q3N4QTIyS0VTb2RwYjJKQlZYQkJ1cWdPOU96bk0ySnRlaWo1RUpIUEhvZVpyTlpzSnl0WlJEam15WTUxOU5MeVpBN3J5bUEyTVREMzVReEV0U1Vwa1cxaDg5VmJzQzEvMS9WU3VKaVpRekdBekhkS3lTSFp2bDBFNkp2bEZZUWRvODZ4QXEvTUVwc1puMlE5Q0J1c01JbElvZTF3MFZ2RThlcGtDcCswbmxGdlpvMWxkbWJmQ2gwMHZzb2lZbER1TnAvMVBPTGNNK3JoTTBGRjMvN09ueFd1eGd0TG1PdSszNWUvOTh2UE9oSFo0S2pucUxBNll6K0ZpSXlPakNHUU1vSjJyUW9ZSkNHaVdTVmxYQ1A4RXE2QlptVi9CN0crMjhrQUZxaVRhNUVBYVpBMVZMWE9qcVUwaHRVMXgwQ0lUWkR1UzZ0bEZBdndBektNZVN4UXUyRVlkMnhRM25OTXpXZ2RXbFNZWEprbjFqcUtlMGVjMGVaMS9SUkpqOXB4WWFTSE1wcVY5T2JsQWN0Qm1mRTUzY3ZUR2pDTTZpUDJzRTZNaVVHL2pQenFiS3ZRbVVHTi93bFN0eTg5ZXJwSlZxN0ErM0VUajNKWWJUVHhBL0I1S3AzeFpIY1dyNlM3SDl5aGRUTFRkc2dXOWtFSE1yaGp5RjdoTGo0RkpmOFN5MG9GVm1ZWTYra1p6QTl0MnQ1bVpEQkhDYzlJbXBrcXBkbitVMUlGNjZuVEFTVzFyTnRIalY3dWgxaFJ1K0Q4S2xoazI5QnptZGhSRzViZkVSMGZLclJXcWlLSUd1eG5pV3FPSVNabzM3NUpaOTcxaDR6bWV4VzAxcVQ3aFVhQlFrUGVFeEFhL2R4SVNyU1F4b1lnN0ZtVG8yVnhpM2ljTVdUNVJaclIyUEM4c3hpemRBQUkvTDMxSGtUQmZ4UTJDcTVMK3ZDN2dqRXpZRGhNTEx5c2h0Yk1ZWlpkbEs5dGlXMnlTR1Vtb2tBdnhwaXNscUc4TC8wcDdFaDc4Y0Q4UVlMVDVQUGxnMFNNaGovYkY4bWZGUzVxN2REU1lkSWpuWkhLb2NsWmxNRkQ2SlNmYlNXU1dWaEtjUmZxZ2pBTHduclR1dkR2dW5xNm9HcmNqR2xZQ250Z0RNMXI1ckZzWElQeERkRWp4b2VjcWxGQ1k5akxTZUZtOThUTE5jbjhKMEFNbkpPSHA1eHUzTG9Ma1hXbUIxOS9UWlU3dFY0S0FsRFRmUVFtSFFocHNGbGZHd2NVclVoM1NZaDB2eXg0RDJ1QkRYZHREbnlvTjJpeTUxcHhjVXp4dHA5WGtQZ2NDSjl2eDN4cUo1WE5hdW5EenFicnNqSVVZM2hpS2pKSkphd2lMUW45Zm1OdnRtb084NXY5OEFtNnRMYjAzYkdTTXViVmxlYUF5Sm9aZEJlNWZFaDZYa0NmOGJiOThqRWowRmZJQUwySzlzVHo4M01JS21icWNXK3piMlpaNzN6d1FleVpSMVltNkY3RlJmVE1MckJLZFAvTUJrcDhKNWpsUHBjRW1KMHZzdVM5TU5MSzh2ZStNa0l6NW1XTU1sTnEvdDdQZUk1aGtiRm1wNlhneWJDMzl1eHFwTW1CY1k3SVRxa21QM2graVozUHFXaWlJQllyVklQZmZYWThlWTRLaUxHSjh6UTRUaU04Q3BjdHV0YUt5MXdYQkE0Q3JCK0xwM3UrRTh6VVpIcTljc0NFWkhCdk1LbWRIQ0NZc01yYWNRZDM2ZjVwNTluajA2MTBqYUR3M0J5VHhvR0Y5d0ZFVExoVUJlTStKYWJmZEc4aFFEWndQYVYvZ3Q0dy9kc1ZMSkhHUTVSTEpkMjdQWTBsNml6SFFwcWtLUHBIUC9pSWd1WXZtRWE5ampWRFZoaE0xZzVNWkUzc09GaXVleDhzcHB2WFp3T0ozb2tibHFPRHh4NHhyd3JyV1Y1ZVM4K2ZQUU93U1lOQlFoMDJUM1NZeCtRY01UamMyVjY5RHA1dm1IYktJLzAwdmFRc0xsWGE2TklBRmd3ZzZ5RnVvMS83SkIrc3Z6d0diSHVLSys2ek43Z1BWQU1nZHlSNmkwMU85aWZoRWxlbnU5TUVsUlY3OUdGYmZaYkF1MjFIcGxhRnFaS1hGNldGRUM0TmhJbDFyMlJ3RlZpUUs1NkxSa1RtVWZrZVg5S1N3czV6TjFIRmgvaWRRaVlUUUNyeEhIWENYbHZCMWszY1dicnk3OUZrZ1ppWGxwZjBvMmVWWFZOS29LODk3bUFuQmtJTzVkOFpoZ1c4am56d1hob3l3cFB5ZHBHVU5xRXBMQWlvbklYcHd4b01zM21jV3RnL3VtQ1pLWkRPM29WL2M4L3NkMndYeTQxRmllejJvVnlnWDFwVDJtMXQrbDdlaDV0bEZobUJXd29oelJqNXMwdFdDT2sydUFFT1QrVU9Mb2VmK1NEL2NNc1VuVVpNZkI5LzRZSEVjdEZmbWszcHRHOFI4Und6bC9ySzAzTUxNUHQ1ZXZyOFNkcmVNRFdQeWN1R25TQzRCaUNXSmloaHJRYTdtSjZqelpGYlhCZEJ5VTNDNVFHUVpZQlFpODhTaDBDUzQ0STRrYVVENGRsQW01eWh6UXpsTk54RWZtNGlHTXFrd05PYXoyblBhNFUrN2lOeHJsNmEzUlhSOXIxMm80UjV6dmw5Tk5oSDhFUGVISXp3Qm1KNUNrelc2Zk1YY1FOeTNMOEhCUFRVOUR4WnBudmdtVGJvSHZDQWtwSWwzRUZHVUJHTTdRR2lJWTVLeU1HOWUvZlpkMUx4Yjk3eTNhSnVCSjZEWmdrd1MwQ2o0TmM2SVlDSWpXVmI2NFBIR2ZPUCtPNFp4b0g1WDkvRGQ4L3A4aVU5cUlqOG5sVkVHTWlXa2JTdUFHMFMvM3o4NUUzRVJpUmlXNFZnWkVHOEhpaDdoNFhsOVhWdkZXQU9uTWkvMnFISEZkMDVHQnd4d25QWnhGRlh0R1U4RSt2TWxqcUNiUWZvWlBIeGZZYjJqdmVrVnpUUjIyYmtqSTBZbFVaMTZPeUNlTjR4ZTdpK3E2dTFUbnpxaVBLY0tiS0dKRy9ZUytFakk3VHd2b3RBVXFzL2ZyWkN5US85ckxqRUNSYk1XOENjNXpRUU5CNG85S0FITjdVSTBGZWhOVTA4NmVzdi9rVkp6cm1nY0xEd3hvaWR6Vkw3V0FRYXNMMzlsb1FBZStDT0lTd1BjRE1QQUhGdWJJT2JRMGpJTjQ2am41d2tpRDQ3RlNoeGRwYU1OR0JzYUtwZElzUmkzZDBpM3JZTEhBY2xkUXpkVm9tN0hST0VQOFVLcXNEd2RjSWVBd281YUw4SGNPMU5CcnZldjdkSTloQVh0SmZDY1lTK2pRUnk3RVBYMUd3YW5ibVpIcjRzQTZjaFhCQm5yZER5UEROaGs3Y2pMM3VqSld5dGFneVJ4WEtINGJHZ1BTTXBRSGN3RTJLQnJVUlJodVdGUURjMFpCeFp2S1RRaDh5UVFhRENpOUtTUXN2a2pTR1JXczIyTkhadXlkelNLS2pHaW5lWWlZWC9mdmx2SVI1c0JzVEhPcmhxRjhZTTdpR1dDMEpHdDh0RktWQmliYXd2Nm5tMEVQaUF5MVVnU3NlaGZTTTc0Ryt6QnpGVzRIVTR4M2k1U0I4bXJvdFFVdElZT05lOThQcFowQTdoOUQ3cndMN3l0OHc5OFpxYWczNUlxKyt5cU5kcktuMGp2c0dtWEpxWFlXTHk3allBZlU3T3NiallHSkFsT3JmdVVyNUIzNStuRDErbVBWdlJJR0QyOTQ5Z0NBTFZtUFpPbFJXMllFYW9Fd1R3aVExN0ZKRGN2NGJKN2ZNcXM3azZBb3Zmc1U5aWZ0ckFqNTNqSXBRWmc5TkNPem1Ea0pRcjc2ZUpHVWpvYnVKcDNhVERpOFFrRkZMaHV3czBSV09XaVRFNFVUalhaV3RxNFFTazNDSEdCdkdhSXN6ZUFlaTBSQ21PN29UbENpb1BYZU1TVEYva0xNWVo0dUd3Mm1QYTYyeHZyOVAwN1JVUUJ1clFlSTZyaTlkeGhSYnBrZjh4NnhWZDRSQlVoazVvMmZCbFdkUUt3cndmQVdmOFNDMlluYm1LU3F2SGMvQ01OTXY5NlUrdm9JSDNQMG9yYXI3c3pHQTV6dTZFZTlucXhMaVpxT3RUT3pERU1hSmljS05WQmtXRWliSENKc1hCN29sTW83THlmaGRZckdYd2NkdmdqYnFLNi9TbDZrVVlBQmJGaWh6aURBMzR0MGhPV0ZjcTNPTUt2YWttS0U1ZVJZQS9lN3ROTGQ5T25FVTlSMzBxd3YvZ3hGRlhYV1RoVGxrWE1Tb0FvaU5BSFRvaGZPT3BIUUFsSndpRUg5VkhVdk9OZmVGeDYzamtVLzcyRHJkVDY5TCs5UjkrU0gzaktNd0ZobXB0NVRsVzFoYlhoekI0Wm5GTEFueTN5U1MybXNVME00dmxOa0s4a1RWMFFRdnpjd2diWXFCbjU5TllWZktRcmp6NE9qNWV3M1hkSTBodjdhdEt0NFZnMTdLc2NsN2J1SDA3Q0xzeXRZS3BSbzB1dEZ3QjJ5VlBsZ2hIakZKSmNQdktWRnBFOEUwdFROQ255MEx2TG9SVkl3MFR5aGtrNFZDQ0htbzg2eWFsT05zblZIVDBMRkRFdlUzQ0JRdVBmYmRNS1N3ZlBRUHdXZFlJYTNySXQ5S0ZDSGpwUmpDMWdrWjZDQytNb3pRWnBZQXl2aGtXRU1KSTkxS3JTem8wTVJUeEwvbUdaOUxpc3YwVGw0eDkxZnN5K080ckxEMlVTTkFmL0tVTGJjQmRFOFd1dlVHSDBJZkExenoxNEhGejArL0lNTkN2bUhDWW1BcWZQRFBFQW91QnVTOUtOYXNCVXBod0UvNmpBRFEydzJQd044MVNYS1IyRzVabHhCeWFFd2xyQjBucjRleXRRMlNJKzJGcDRQWlk1S2dsRTIxK2tUOUJ1QWhDOFdENjBqYjRVbnQ3b0VJaVhIQzRzQ3crSGdvSktoTzZFUXJNSEM1UEo1YUlBRml0TUZPdWgweFc2VVJUTzhWNC9lMEthUGhOTWpUN2tiN3U2eDBoTUU2OFNuY1JwbEU3MkJiamxHQmppMnY2akI1UU5ubUU5V0hOR1V5M1B0TG1jcDNFV2hRcVE1UjZESTVNWUFVTnhicDB6UlN5QmxuZGROMWJuMUgzMWd5b2pHcHlvNG9XcnhJc1BjWWxZU3NJQUJPQVJjTWZnbWcrb1h1cTJaRVMyYUorR0xZTFl1anJQc0tWY2FnSGs0a1Fpc09ZenlPVWxOeTZjWjNCQkREdDgxZk14SHVRWGo5YlN0ZXZmNUJ1WGJzZktQTm5UeDhIWVNoNFJkWkxmTFo4UHNSZHM1cWhpRWJONGdpYTRPeEVLQzMyai9kcDdhcE5GV0pxVFg0Wi8vYTBmQjUrNVAyazZFMlpFMnkxdDVGdGlpek92b0NCYzlDRjE1QUpKa25KVDgrT1lJSGwwdkw2Tm1VOG1TQ3RzWjl0eHJQY2M3SmE3dkV4S2ZNak1vTWJ1elZpZDhlazlJR3VZRW1XbUVUYnk3VWFDTUFtOTZFZW1kL1ZnTHhnYmEyUUhTTUxlTVNJdHBZSklQWVpLQ3ZQVGh0bHJDdlFBN2lyQUkvYnRzbnVkbUI5NC9LVHdleEZnRTVQQUl2QXVqbXlOQWRhcjlBTjRvS3luZ2Ywd1JLSDlUSFhYOTk4blY0K2ZRUkxZNlZSUk4wNko2N0RtanVBbUN6TVQ2YkZ4VWt3Z2ROUktGOUNJYlZUVHVNVThaWmp1YUI3QS8yYlpQQjJOOWVoU3lBMVdQWU91ckF3R0RCQU1MaDBZUXVhTTVVajFvNHRYT2FIWnRJRTNrT0J3SHMvV2RCQllubEREQktPOGk5anFGWjE5QnJIaElPQlpiUkRONEp1MTNmTzZLWFZva0dnVTZtcFB1MGNBZ3JCZVJPYmFzZHF1MkIvek1iWis4MlFDZm9BZ2FKTFI2S0MrM3BtNGk0anFZWjF6Vkd6azF3Zm9abjFqdGR5VXVBZ0h3alM2MFpxUU9kNVpoTk94b0lkTjJaTmxWYVh1RVQzUkd2TW1MQkY5Rm56QktRQ2l2b01LN2tEUTBOQXVJYUY4YkdpazdkVW9OQ1FJWjc4NXVIL3hVMU13ZHNKRk1iTzJZOGE2WWlFN3NqVGQ0ci9xVVhONGpobHcySldXL29hSEZQTGlZUWxtaFVNSVE0bXoyZVZtRXBWaWR5SFUwdTFRSE9ySGJUV3poRmVmRG8yU1N4SFhJWXJLTHl5U0lsY1lFd0VKdUhxWXBQT0lhSzZUTUg2b3k4VUc4amwrRUxNZ1RCWHFwL2k2cGxBNk9LaGRYbk1XaHF6R2E3MUVRQWVTdXNRL050blQ4SElMR0ZXQS96c29rUUMxeXlINE1rQlJTaHg0RTd2YUNObTBLbUd3bUlTVktsYnA3WTFVeG5RQ2c1eWxMakRBS2I0QU1ITlFiNDcvVWZ3bjc1NWpwcW5kZ1dwaDhlZUdLUXZjS0N3UjZ5MXFMV0JVQ2lCNko0QVdwQkRFMTlBL0ZFc2h4Vnl4dk5VY1IvMlFlY3I4Q1FTZTJIYnVlQTVUZCtxTU9UVXRBM3I2SUk1UWtFdnp6czZSd3hyakE2Y2R3N1RZektGWDM3MWE2cjh4M0VaZTlMMHpEaVdHT0JTTmsvOGxDL1A3aktEYUdjSUxWNnRKQ1ZRbEY2eFBzMTR6ODh2UDh2VHhMOHZMYSt3eUZtYmJwNXI3RURvTkZFMEl0R2JBSDk3YUh4bjNha0I1VUd3VkF2MGZPcnU5Yjd0YWY0cUk4STJLK24xVzhDVkZFSGJHeDNkbHRwWW41Q05KbVVuaHAzTkVsYVlpTHhQMjZKTnh0SE5JbGl1ekEybXFYbG9rNWlQbWRJenpxbUh2dWlEZzNRaUhUMUlqNTVqVFFPMndqWmwzU1hnS2F4dTh5UTZiTjVjbUFYSzhwajVncHZBWTRhaEZkckhFRGZLb3h3ZFVmZnUzVnBhM2Q2RXhrb0JPRjVlMzByakc0eXNYd0dUOVUrL0prQnZ6WjFRZ0N4RFBFeGI2YnYzcm1EWlRtTGhNUFNFekhFN3pPK3NCR3c0ckh5c0pKVFE4cnQzQk5weDgzam1DckV5clgva01veXYyYVdGaVFJa1JDRGlQdy91YVloV3pIY3BGcCtibzA5Vy94aGo4WUNnRUg4anJ3TU44bVM0Wmowd3VXS0FvbHJxQnkwVnF3ZDA0L0NRV0JkZmUwQmdka2crSE96aUlqZjdFY3pFQUFjby9LWXJjRGMwZUk1UTQwREpKSkpVa0I0NFl5MGJYMkY1Y1E4TmtUcERXU096Qjg5QjFwQXVQQXpmYXhRMGNWRVZWdlo5RXd5dVFpd3hlRm5BTDM0MTEwRkFvYkFWZ0JhNDYzcEtUMDB3ZHAzd1hvMXV3UUVpUnk3WWtUYzY2YksyL0h2M2t2UW1RZzYraEdWczVkMzIzLzNQSFJkMU1nZVpXYzUvTWMzMGE3VTAyZ2lhdGlQaHpqRWhjMVJzdDEzUVpQb2NrN3FBbHNTZDh1RVVZbmxRMmpsd00xM3RJNmh3ZTBScDVpTk5nbUMwa0hnb3JEV1pPYm95Z0F4MkJ0OEZqQjFkL2xrbzI4QkRaMEY0WTBibkVMN1pBZ0dWZGR3MG0zOUZ2U01BVkMyLzdOQVVqTlFqb1VRREdJcVFNdTJ2Z0xRSEVnc01xMEQzaStmRkZqMVBXMnVNaFhwRFRHdHppVHRtUWVNakF0cWl3clY4bk5QWGdVYnQ2WitNdUpEMWp4NlFKcXlheHhJWXpXVk5YNjJ2ektYU0paSVJkYTNmbTdEYzBZTXhQZHVGSVBQZlB1TjdJNFVEZ3pqd0M0Unl4T0w0UTFUQTh6Qk5MVG5XR2k0SmxxT2YwNEk4QnpvaFdQUHQybVo2dnZRTzdBMHhFZHpUNmVrUjV1NkJoQWZzS3lpaVFleGxmMnVkWU85ZWVydTBTc3hySnlZMG53SzgwMFczZnN2alVSRDdNallWQWxrRm9TeDlyMmdVV0Q2UGEvZmZVWnZtYXRpUEVGWjg5M3AycldqaVR0aUlieHlsY09mMmZlaEV4VUVzQXV1dEN5NHpPNnRyYksvK0lqaThGb2grMkpOa0JpT3ZLSjlaSis2M2pudTBmYkpIc055c3Mxa2gzU2Urc0pMRWJSVUlCdmNSUEo5Z2FPa3RCazdjdmcwalQwMWd4WFVUbUFZRXFvdDFZQWZQQ29tSlpTd0xoRHNUYW5KRkN1VnhJNGVHMmdGNFhrMS84LzJiakluYllUemRLaENLQWM2N0Z5dVhCQXdCL0RJVkZGODhlcGlXY2ZHTWlRbmF2SHRuTmwyZEJmK2wxWWdRT2lNMkpjT1pCQnFleUtYaEVRVW1XVlJBbW1ZakxlY3lBMmdkNFJxdTVTWmp1YXlMUEdIL0RaUlhTT1kwWlQ2c0tONk51MDl4T0xDSDhWRkc0MUYrTk1XZ3doRVVqWml5QWZxaDlTSUFPcmkyL2VhY09DVWZsQWc1RkZEMk5RVFQxaUdBMDhOVGlzWnQ5QWM4QXVPZ1RPZk9nN05ERWdvSUpZcWt4L0VFUHJyRmxQVUJNcUhsdHdnbk1JN3dHL2tDenBBU0kvU2xsUnBzK0xkbnE5QlM2YXRBdExMRVUra2hpT2N5R1dLdHJSMDdoRUdFaDhOM1M2V01XV29kbFhBWC9WblBSVjdKRXhQdXBDckI2MG8veWdtdE00bFJFTGpDKzVUN09LaW1nRnRyTEwxVGw1dDdPZnpFK1F4dC8rUC8rbDlmR0tBMVpzU2ZXSFgyQm1nSlN3aXpzUjNCMG9ZUHpRZ2ljUkRHV3hDNy9FNnJCbVlqWnBFSGZkMkdYNTQvSDBhWUlMd1FNZ1Y4ZUdhMGg3Vm05d2F0TU5hSUZrVkVZMFhFR0IvK3lZWDV0eTZIaks1VkJyWUdBV2xCY05iZGtNQTkvbllnOENFUWgzaTZUUEVaYldRMDJpRmtrZU14NVVVQmk0VWw0N3ZSMGU0WlpzdHp5SWdQekV0dFZnaUdpUzlycTYrakdXQVZZV1VIQmNjU0dVZVF1YXpHNzJUa1dMaEFMRkgzMDVmUEd4ay9pRElMS21hSHF5Qm1nWkFlZThmeitKTEp6UWhHak13MXNma2VtZ2VsRVBUZldwd2VIay9EKzNXai9aa2dQakV4TGIwc2J1QVc2WnFoQ2RudUhKcXFTUnpra0Y3bmEvdU50RXd5WWVuZE1ocnltQmhYanRGWE5MNnpzeW1sR0hVNklKeUNEWHY1OG1WNitvUU0xZG9hVmlnbFIrQ2pyS0QzZm5HR3JNQjEyeGZwQXVJUWduSXBsTEwxY1pRUXAxYXM2Ny84dW54T0xoYWEwWXpPN2R1M2NhOW13MkozWDlXZTNZelNNc25SQWZOM1lvSG9wYlhyMXVMZTZoN0FpcmdqdldEcmNJY1lXbkdFcTdwSC8vSTlhbEwzK2RyQ01sbWpWalBtV0hLdVJXaDFzUHNpelUzM1VFZDNKWDJIaG5ZWWNSeXQ0OFlZbFlaRnRiVUYzdXI1RXYzY2x4QWVyQThQb1dlZ1FIK3B6dlNqNzE1TFAvM0pEM2hlaE9UR0t0MDFqR2NCU1VISTJ2YjY4WnZYNlI5Lzl3M1paV0pjWk40K3Vrc0hCV0psRGpacFEwRXJzRTVBc2UvdWxzUHk4K1N0MHh1aVRNaDJOeWVBT0RmTGUxaUV1SDgwNmp1bHJLZEs1dFQ5T1NkeGNJNUZJbkI1akd2T01LcHNpdk5TU0EzMDJ3SUg0WTV3N1NGRDEwRm94VUhDVFFXOWFITThEYnY1V2g5WkkzWjZmSVJRT21pa05iQmRWWVRVSG5XR08rQzVxb1FXWUYyS0kyb2tKckJJdWZZSDEwYnBOVGFVeG9xN2FRbDAvcnVWSlN4QmFBQklSRHN0YjFyRTV5NG8zZEVqeUxMekJ0L2xZNzJHeTRhTlFwSWNkbUtOSitCZCtydFpSV0pzV2xyV0NnK2pnblZtZ1hzRkdUclZjNGNIalh2WnlkZ1FoQWFOM2xIUU5ZTE9zaXB4bG1aUDBhalJNUldDUTU0Z0VMbTJKcENsZFBuT2kwL1piSDRNMVpveGpvU29hYWM4aVdaNmVSZzYwWWNKcHRnckwxT1Q5UUR1bFQxZERNUk1MeWYvWGVmQ1ZlSUMxaFVWMEhxRUI5RkUvQnMzczVnZjQ5OFFGVDg3TGFZRldKWENPREkyK09iRWtWcG5QZ1FNamFYQjh3ZHo4QVBYZGswS013K0x3eU93YmlRM1lBQUJ1TXdFaVM0SmJ3NG1EMkhCZXgyeEZTMWl0Wnh3bTF5anZuSC84QmltTVpOZXR2ZlQwc3ZsdExxNnpqMnhhTURrTkdrL1pXK3dIRFZjTW0yV09DQW9qNUNSZWMvcHhpQ2pldzh6SU9FQ3l2eG9GTy8zTGFOelVnR05VRkRoNGltd3JKSHlNdzVEa1BqWXFSQWNXbDJPZnJkemhmZFRvMFNMV1lTRGdzVnNuckU4Mjk2eWZCNkN4QUxaeXNtaEhNUStBdE1PNG1yQTFPOVcwdEticmJTeHNwdm1zRHo2QWVkYXI3aDRGZmUyZXd5bS9aZjA2dlVMWWlTazVORldsMExVTmZzOExENEVVOEJRdUUzc28xWXhYd29wQ2V6UFgvN043S3NCa0RId1lUMERreVFpNk5OT2k1aU5yWDBZMnc0WlRIZ1pvSXdHc09vRUROclBnTjNvSjA0WXdtR3pEc2kxK1Y4Ly9lU1pMY1B6dzlqOE00clhhWTU0QUFyOWF3cVp2M3p4ampZeWV3aEJPcTNTaGZOa3RaMHltM1VzcXIzMCtlYzNtVGs0akhBRUdvSHIxQSt5ZW1oSUdteGpzczByQXVrSUdZTFdhODNqOUFjRXhzejBWUHJzYzhweFdNL0c2bHA2OTNZRFpkU2JSa2hvZkdka09IWDBUNmV2SDd3Z2FENlpKbkZEdFlhaytFTUt3VGNzcGJIekJDNTZwUXBOWUNVV09hYzhKVlBHTld0QUlxcm4rMWc2QWkvSklrNzI4bmU3YkhET1dFc09GcDVrNE1Va3FOQkJnTnU5ZlIzQUdyQkc4R1lzWTlMTnpha0FzWUNjUFdEL3FoMEtyQStZZGwwRDZIcDhBQjZSK3dMRlFraUJoOFNEc1pIaEtSWkt1KzRpZTdkQXlPTHE0aXpBVjhwNVp1bE9DbFNpbDNOd0l2djA1RFFoZ2tPdUFaMFJpaWhCYzRnaEJCYTB4c1liTDI1RDRkbEtodU9GYnpsZmVDMUhQV0NSeEZTTFRyOUVBeWxRUjJDQnZyWEdWb1BpRXZpdEpWNnNHUUxDZXNUdDY0S3ZhdUxGK0ZUSGlRTjR4Y1lCRjVHbnVLZWtaOXNvREhVVWN2eUFpMHNDaHhpZWNWejBKM0ZGM2lmOS8wLy95Ly9BZldBTW1GR2h3RjE1STFxVWxRYWltNjRCeHJUQW1iTXBwR1liVzZTa242THRkbmtmS0ZiU3pLRjlNY2tVSmpYQlpseFBpMEZ6TDdNU1dEeVdsM25qTThZUXRhTk42enhRSGhkeXZPOCttekNGdTlOUDRCbFhBY0pvMHZMRHdsSXVFUnZtcHNFK01KaVdtZXRpWS9tYkRKWEZzTnhZaEFMYVNNdkhBbTREd21iYzNIdzFlaWF3c29DL2t0NDVhSVFNVWhQTnQ3cTZnVHV5aVZiZUpSTmpRMEdGRXVJRUlhRmc4VDV1c3BxaGk5NUUwWEFNN2VQaFh2cjh0b014L1N2emg3VUM4UVE0ajUwek11ZmhHQk83RklLNmlzYVpGYlQvRDFkbjJtTm5ldWIxKyt6blZOV3BmWGZaTHR2dHRudnZ6aVNkQm5xWXpKQVptQUJDUXVJRkwva0VTSHdBUGdZZ1hpREJpNUdRRUJwZ0JKTmhraUVKV1VnbjZkVkx0OXRsbDZ0Y3JuMnZzeS84ZnRmanlpQ08rM1JWbmVWNTd1VzYvOWQrWGE2OTgzSHNnb2ppYjNoWXVKWmN6amxHUlF1NGxOTlJVdlFnV2h1N2h5ZzlnQXNpWC9FNWtyMHg0ajlkMjBTYUl2SWI5WFlCWSswa0JkYUc3Tk9MN2JYMDA1Ly9FTkM2ejNwRGtPelpKVmc1UjZXK0NzQmJZczQrZk0vbkpXQkJPNzk5K1BybHcyb1dkaDY2Y3YwR1JEY0NVME1sT3BhT2xHd2xWSXluNUtycXFoNDNwSU9RZ3FvSGwwUnhBMjRyTU14cHBCOVZvQVc4WHZPVTBKa2tyTitpYlgzV1ZFZkxCWkhiaE1tbC8wTXMwNDkrZlE5MWpnWUwwSTk5SEtmR2gybHh0cFMrK2M3MTlEY28xYkpBUTlhb0NJQm04QXliMFE5LzlpRDk1QmNQa0VoZ1lNeXZScjdoZSs5ZHA4amV0OU1icjEyTi9NL1R3MGI2eXgvK21sQ1ZTcnI3OXV1VXNibVNQdnJGSituK1o3OWttbFJqTUo1SVNRT0dQRDZ4d1A1Z2RHZCtPSnpwVkU3eFBsUktEZGZqRkJpczBFOWdkSm9FYlR4M3QxWlhpSzFDWW9jbUszZ3NSL1dlb1IxRVZnTnJZTnhZSHVrcEpFMUFWWWVEc1hjblhPK0FrdHc3QkFEdnNwNm4wT2taZHJ3MnFoNUNNL3VIRnhSZ1ArV3MxS0NYY1VKdEZxZXI1RGpPcEJ2WEZ0UEtETjJFQU1OSmdtVkhheVk4ZXcrMEZjN0pPc0d1SDlNUTFseS9RaDlIRG5XMzJJWmd1b2JBQ0NZeXFFNllRYlFGSXl6UU82SFRwOHdPUlNWYlhaTEpTV0ZydzB6c1J0NEd1STN0RXJRVVNsSmZqeTRDQ1hRdk0zYXVhZzZDY0FWamV3MTF6L05RdzE3cHVhcG9odUVKTk1WNjlOR2M3SjZrVUZUaEFwNFJtNVp3R2xQdVgvLzdmOG01OCtSNDBJbEpndmdpUHdpQ05JTGE4aCtxZ1I3T1JMRjR2WDBGdkJJQzJHQkk3emlNWXB5eE9KWjJXRzRQOUg2ZzBvVzNoOUluMktKdzEzQXpNSnpGR1ZJelBqTmlRLzE5VkxCMGw0T0RZUnRQazdyMEVHNmxWSmdEYm92RTZuaGIxVnlsTHcvdEFOdEJDZUkzdHkrTDBzK2tBOGRudmFLUUdsNTY1QVFBSmF3YzRCTmxraUdZb3ZZa3BCK1JYWGVCNnFYZ1pITHZIa0Y5aDVUWHRXc3hxeC8zdFhBWXVQVVNoTEFQQUxoMnlrWitDM0ExRGt4dzdHQ28xek9tNTFOQXRQS3FSZWxHU2E4WkpmZFJ5WWt2eGZvS0RvSzYxUllOclJqSHErZ21PbDRCVUZEU3hhc3RRSFZRa1Z0MTFWUWtCMU5sRHVONHJmeXVRcVk5M1RwNHp5UVdIU2QySXI2QWUyNDhlNUUyZWJLbzJIcndZR0pzZmZ6bzgvVHBwNzlNTzZTUzZPMVVzcnlNcHhJa3h3bDNrRkdKUjVucWwvMTA3TndvcmlYbms3bnBpREUzcllNYWJ6V0pBWCszb1pVV1h1YSsrOGs0czgvaGtJRHhhWmhsZWxJd3F5ZFFJVWxJMUd4d2hmbmFjcTFHSjZWWGJpK250MTlmcGQ0VUFaV29FeHFEaDVTZEdVSVBiZFNxeloyVDlJT2YzVSsvK0hnZFR5ZDdqbDJ6VERtaU9RN3MzVmZtMHg5OTV6MEs2RTBDREVnNjdPc20wdEJmL05XdjB5OS84NWpESmczWkM3T1czcWU4ekQvNCsrK2ptbUVucW96VHF1c2kvWmNmZkl6YU1wNCsvUEJkZXY4ZHBILzNiLzlOdW5VTHU5TFZHK3hyblhVZElqblNieEhwcGc0d3R2RG9XVHh5SEJCdWtyOXFBdmxiYjc2VjdyeTZpa2VQK1pERHlIVFpTODRYak1ZVUZCbXhYbXNMVEZyN3l6WjNWZ1ExeStLSWVMQWpSS2RqMG4rT3lVZHNrRTUyaHRxbnFxdG4xekkvVGRSczEzNlVJR2c3K0N5UkFINFQ3K3ZLMGdoelVaMHNwSGthem81Qkw2cW9kblZxQVNoZ0hoSlpsMDdVYThIUXBxbnlNSnAyeUozY2hxR3pEekFzeXhFYnp5Y2RXaTVHcHFIOXNFZSticXREMjduaENSTFBHZWRTa3d4Q2h2WTRQSzNtaS9yVGhQOEIzWDBHRnVwVEsyQytubFhwT1pNY1RZWm12N0RiR1JKaGlsNFZiMEtaUEZFL1l3YUg5akNMRFhEb005cUVaQkFOT01lY1dmdmFaNFRIeFFXdVFFVVBIb2NRRDAwSlFzZ1JxdUNYbFFMNlpCSVh0VTB4SVltNjZzSGl3RVA2Y0g0K0FIZ0pVZ2pHVFBDY1FhQUc5ZW40MGNNT2htSFdjSC8xVlVYTEZnMG5YUHdpM1cvT2V4dGNVeHVXQU1YQnhYZy9ORnNmd3RhSVhpSTlvQTJZZFZpZ0FhVkNBb2c0UUtwT1NpZ1NRNUc1R1BITjRCbERwb3U3V0FYQXpCTExZblZJRmx5UHBXSE1kdVR3VmR6QmNMdHJpUDgyQmIyZ2Rma0ZWVU8xdHczZzducENGWXNGY3owclJyLzNBZVpXdERnSGlnbnFhNUlncXBUVk0wbVkrVWZaR1JKb1Y2NWNSMXFZNS9PTWlYK08xYUJXRFpqYUFvejZmZlRWVnhDMVlSdVpTM21FOGg4Q25KSEJJMnlra3FWeWloNWVKWTRPMTI4UzdhejBGMUlSWXk4aXdpdFRDd2hWVGdqaFRta1V1NFZOUHpjMk5paGN0OFlhUWJIczY4TDBJaW80NVozeHBBM2FTc1RNa2YzVG9DcEFReEhjVTRjQUw4ZURpenA2MWh1czVUMXV4WFhNWWRObTRUZ0V4VG1DUGVlWHI2VVNCSmpIT3hoVlhKRm9kT1Rva09vQnBFME9qTVgxZHZsNVNuVldhNVRodWlDTW9VVHVKN01rQ0hSbjkzSDYrc0h6ZEd0bE1yMy9qVmZUVFlDclRPQnRqMUFQQklYMENzQTA5cmZmUXlxYlRIOE9FTmxFdGcxd2FUTTdWUXBCVmZtajMzODMzY2FUT3NxaHVEby9UdG5pRzNnR2o5Sm5YMjRqQ2RFdWk0cWRIMy95aEFOZnA2QWZaWnZ4bnVXdEtsQ1p4T2EzUitqQUE2NTVDdk1vaDVvWTRUdlExdDd1QVFiOURlenZydmtCc1U3bnhHbXRwdHV2THJBVzdqRjJ1ZEowYWhLc1dvWG1xb1EwbkdOZTRPT2thZUVWQTl4dFpuSU1NQjJTRjNsOFFyMHhDZ0RxWk5GK1o1akRFYStkdDVUVXpjYUFTZ2xrdGErbWlmRlZKS2xsNHJ5V3J5d1F5VTU3TS9vWGpxRmlqaEc3Qjg0Z3dSSmQ3dWZZanhJZXVUMVZXRlRxTFNxZHZnRDRqdkVhN3UzQmNGbnZDRDh3OUlJcWhRSkVoL0Y2MWhxY1c2VmhHYXY1aE9ncmZKWXpBaTFhMHJuWFIwV1cwT0NzYW9zOW5FRjZFeUZuWWhPaEJVTVU2Q2FsVGV2U2NTUXQyVm5iR01vQm1vQnFYZ3R0S285NW84ZVpybUxYanJaN2pOc2ltNk1WNitJQm1rb0xqTU94YUI0cFdyZGMvVkhGUmN1LzRwK0NoeEh3K1ZBSEJZMU1QWkpzL1pJY1diVkhtNUxqN3JFYk5pODE1cUxQNENWK0xGb2NNR0pMZU45eU5EWEVYbFhDSWVDblpLWUUxdWJBOTZwSVlZaUFMWWlzMGRwbEVzOWhQM1Rzd2I1aDIza2xtQUhYUmNhSTM5c1k0NVZvR3RpL2JPU1k4Q0psNDJSU2lLMjYrS3VJNjFuc2g4REd1RGdRdXNtTEdCaEpIdVFBNGVIaisxWkMxQmlyMUdXMUE3bUNPVzJsTXUzUWllMVJQTTdtTG9jMGNST2RIOGt5azdJeUYyOFQ0NnRTNFlWRWhjY3lNMWhhTWxoMVNBSlcxZWF6N0d3WXVnR1dPdUx2Q0FuVHdBdlhvbUVHOXhTNFhGTkJiSTg4T1NiQUUwQm1mQUtLaHZKUktuVHFkSkFMNlNZZUlkSzVEYWllVWlnUTExUE1mWVJ5dTBXQXlTNUlBOFkvRHJkOTR3NDFremprRDcrNHo0RTdCanpJcTZOaGFodmJrMnE3S2w4bTNja2w4ZGJBRlEwS1ZPMVR5b29IeENNQkdhNmhXTmZqNExrbUhkYmNsbHUzWHJtRlpQUnExRFJUWWpTZXhoZ2YremQ2Q0RRcjJLTEw2cGNOcElRakRzSVRRaHErQWtDZWtRNWo5WUloZEpGcjB4QVd1cm9ndVgySG9OZ256NTlHaTYxdnZQczYwZW5rMUxHV1NwbmplRVMvUllLd25QLzdmL1VSS2hUcnphRTV3Vmova0h5OUVXS0J4ajU4Qis4YlhsMXNaQ3ZFeW4zN0cyOUc3dC8rQVZIek1DR0I0OUZYYTNUcjV2QVFldEN2ekZDWkFHUHkvbDU2ZEk5NjZFZTdORTBsWEdGNktkU2xGdmwyNit0UGtLZ0lISVdoS0RHOC9oNlZUbTlmWlQ5bG5vU2ZZUGkrOStWRG12NGVvZUxPWVVlREFUWUpzWURHWndsTk1EWlB0ZDBHR3J1V3lFRk5QYVc2YVJkbWV3SHpzSU9UL2YzTW9Rdm13ejJXWjRjMHM2RGo5Q0oxM2JGN1RlbzloTEZPSXIyTmNhNHNJQ0NEMFdTaGhtRlphc3Z3bkJMcnRZbTliWXRTTmR1bjJOOFlmN09GRk55a0dPSWk3Y3RRdlNlS1NJdUhuazJsWFVFQmV1WEdpaUNob2VETnRmUXhVNE8yTllEejVLYzhqcS9nRE1aOHhCaXR1NDhVQXYwaTZZc0JTR0FLQzlLNEpCU1ZkWEh1NlVBVHhBeUxxbkJ1L0V3UkJqNktCRGd5b2cwUG12VFlzVDk2R25YcVdjbUJ0MkdBQUtwR2FGZ09vaVpxRzhTWXVTZXppZ3M1Q0NNSDR2blFyZTlFNVB4ZEpLWTRmQndtQVU0a1ZhWGkvTE5nRUxyU0ROZFVuVk8xSzBDbzZ2dXFsbmxkcUtCMUQ3VXFoNHFacXdKQWdGQjFCTWxrc01hQllkTUk5MHNZK2t0NGdzSU9Sa1NPRFI1Q2ZhSFhXNUVMczdjUUlnY0FhYXVMUk9ha0txQ2pJbW96cWlCd096NVhpSkFONDh1dzhhRGVGakNzR25OV1pCTXM4MXBGRmFnVGZaanY4QnFoR2FGN0E5UTFIQVhheE96NVorVk1PK2xHK29GR1lsek1pcElDNTlpWVFJUUUwU2NKMTRBOE9JSFNhV2EvYy94TWk2ZUhYNklLQXliZmR0Tk1oclpWMk9ycTlWaEREZklSQVl4UlhEdWEzbHZWdHF3bklsSHlxQW9TaEtwaUpsYWJkMmVaSGVhQjk2MXRhZ3dWS3JKWXNld3pkdmZ0SU1VdWMxaEdLWjlTQm1RKy92aFQxc3lLc25SYTRaNkNwY0JrWkxOZGM2U3dETVQrSDhDQzlBVFFMbHh4Q0ZneHplREtKUUQwNXF1MzArMDdkN0dUbUNUTG9VREtzYVJ3RlpWRUwxUUZ0WmdkWncxUTQrSGM5YkZCV2dadzd0NThLLzNlQjk4bXZXWXZmZlNiejBoSXZwZnNNU0NSZHVXOEFPVEZKcUVLRjJ0cER5RDZtNy96Q3BIdHFNYkU2SlVBcEVsc01oOWdpenB0SEthLytpRjJWZlphODhIUmZpZDlqUG8zemZ2ZmVPYzJkaElPRlBROWd3ZHVGZFhwNkhpWHorRWd3cU8yNDRIZTJrc25lMGQ0WDJrbVFyTlVKUXFzUzZUaHpFTWI0MkhmdERLdFV0SE85bk1rRWlROVFpRldrZnplZnYwYXRqZ09Gc3QyUnBqSng1OStHWURaYXJqK3RNR0RocVpRUDk5NmczSEFTTDkrL0NWMFJXclE0alYwRUVwNzYzMG52ckNETTZxREttMmQ5RVZ5QVdlNDVoV2s0NnQ0S2RINEFFM1R1cENvVGFIQnhGSkZoZk53bDJFdVNySU45bjZIcXF6bW0yN2poREF2OG96NUhaeVJJSTBhZTBqSkd4dWExakZxdjNubkN1dTJrdDY1UTJnSmNWRDNQMTNEYzI1cGJ5dGdHUGVrNDRESWZoalRxRVVrMFhTTWk5SWg0Sm5xd3pUMEN0bzBWWnBRYXVyeVdRTys4N3huUmtJQnljMENDVDdVS0FTL0VqalFCVWVDS1lJcmVxWFo3RkFGVDRnaDA0NVZKOHpFYWkybkdDeEwvRzA5TkFzUktDejRvRUlxc3FxaVB2U28yQ2NvR1BPVTQrSzVVSEg0RzJrcjRtMzRvbjM2a09nQUxZRkd3akU2WEdsQkE3VVNBZGNRSXJtZUVkT3FtUnJ4QlQrWk13RTRjRm1lZUE0S2lKYTBnSVU0OUFyUkNScDlXNm1wM1Z0QlhWVEswZ1Vza0FxNTZzTUFnUkhncUpJVlZGVVRoMDNIVWUza3hveEplNXZlRENRYmJHM1JoVlk4NW5EaHJlYVFJWDBZbHNFR1dCcERvMTRaSXE5MkNHR3czUmp4WktNajA4Uk5rV3VYWHdSWTRkcDhyS2lrU1V4UUduRDRtN0Rqc1BtNVhrYkNjeCtrTHZldWl1VG14Q090aFkyTXZEbldRQ0RJN0ZZZWVoOThBeTVxcVJ5QlM5RHdPYURpcUliKzRYQ0t2NTAzeTRXMElXRDViRkFZc0FGakVOVDhuamxscDhRKzVYZU01YUZwQVFaTUk3NFY1MDEwUGhraVRhSFcyQW1uZ0FRNVFnakJ5c3FWaUQ5YVgzOGM0ekNlelAyVjRZU3pBY25Odlk1WU9vWXJvVjArSkUvSDdvSnFUTThEdG5PelNCY2pDK25wMDMyQXoxSWlTQ3NrTTZ1cTZzSTJTbjltQnU4ZFJEZzliZUhFeVlqV3R1aGNDYk9BMVJNbTMxbEdDcHhMRDcrK0J2RDhLbjFPWlFHTjIxM3NUY1pqTmJUSk5UWUJtcFAwelhkdllLL2hHcmo2T2I2cENOTjQrKzR0bW8vaS9mdjFPdmNkRDJaMndqcCs5Tm5YcEdYVkNiTlF2VEJ1S0ZGQlFhLzBJZXVxRklHMFFjYkNQbExuY3hxSUdLb3dwTjdXMWFVVjZsWWhqZU9vK1ByUlBjSVRkaG1EeG02a2E0Qmg1Y29pQmYvZUliTDlLbFZETFNOT1pRME8vR2RmZkoxKzlhc0hxSFF3ZHlUNWFzVm1KT1lmTGhGcVVrZEtJb0I1NnJXSXdoK25sK0g3SDh5U1RuUk9XaEZWVVFGTmpmcTI1N3ErTklsbkR3OGlVdHNFcW5BTlNhTU1MV3JiRk5DVWRCUUszTGNMRHZybTh3T2k2Rkg3Q0k0OVJPMDdSVm84QjNDczlYV0NwS1Y1WkpyZzVuZHVYMHUvOCtaY2V1ZjFKY1pVSkJmUjhJajVkTHp5QnV2OGd2UEZQYXJZcGJFMVIzaUNBTU81R1dDYkptUVYraWEyRWJvdXc2UmtlUGd6SlJEV2xyT0FKNXpWUTFWR1l1ZGNxVUw3V2Nkb2p3WXhwUXZqdk95U1pZQ3NaOW96S0FNZTBoaFlHN1dtamtybG5MTUlGdkI2RVZPUWtyd21rMUFMclU1Wnc0anRqVlVETXBHU0ltSWNDanUrcWxkRzhCaEVhbnFPbzZ1VXBwaUk5aWlrSFl6RnZxWXFwRFJRVUljVk9Ma2VNQmhFQllURjRDS2hHaFEyMlZnWkx4ZHFoaEtES2lrREdwQkFPamJPSk8vQTR6VGNLN3E3T1Z3YjQ3NHhIOEJBeHBIZ2NoMVNXNHljdmJTTGRmdkhYRWQ5VzlBbGdUVyt6NzA0K1ZIUmdQZDZBS09IaWx2elBrK3djSmcvaHlCbWVZMlN4c1l1dGFudTBIL0lnaW02Q3NKSURzVWxPTVFNd0hBVlRNUXdDTEFhMENqSGNYd2FvZzBzRFBjdURNQWFRczVMU1lYRjRKNnNDOTl3MFYxaldiSWJGWGF4K0F3djhiNlNqbUx5T2ZXT2xPQUVQeE9FbGRwVTJUc01PS1F6OWtlUTgvY0dsUU5hMklPTzRVcG5CQkdhVzJsZ1lSM3dLdkorVkVBbHZzejZYelVDSE9jV0p1SEcxTWZuZXdLU2RqV2xQL2ZjdmV4QmJQNnQ5R3lSdHN1SHdid3NHWi9KRHZ2RTJEenF4U2lxNW91b1dLRHIyWmJqU2thdUx5TUg5T2xwVjhHZHJtUTF2a1hTTCtrclNDYTNxTHF3U05tWWVsMXZMc0NtaC9CM2JxYlhhTWJ3azUvOUp2M0ZEejVDblVGaU5RVUd3RHFtYnRRWGp6RktVLzdsUTR6bHI5OVlJVnFiZFVZeUdTK05ScmNaK3h6dVlEZ3ZXOWdPMVdPRFZKalB2dHBrRkdvTzJrK1FxaG1IWTlIYnBuUmJoSU1yQWUvdDdycjhFYW5lYjlJOEE1VnRmZXZyOUhoOUxhUWZMQ3R4dmxhdnJWS3I2blhzYXZQVTNzTHdqVHJXSUxYcTRiMDFKQ3NDVlFrMzZLR2Fsb2xmWE1GTCtMZmVmeE13WGtsTE05QUxEVVl0Z0ZDWm9Ia0tCNzdUMkNhYWZTbDk4N1Z2VThBUCt4VW1rT1k1MVRXZzBXbXlCVWFSNU1zYzdBbzJTbXZEbVhjcVBXaXJPOGRRdjB1YzExTXFNS3cvTzZTU0E3Rm54S3dkR0tPRjVLNk4xVXdHTXp6dTNsb2lhRnV5Q2RnQUFFQUFTVVJCVlBRS3NWaUxCTHJhWFIxYkYrcVhkZXFhdmZsMG5sc0Z6RG5YM05jOFQvZGV4cWxHcEFxbi9Vd25FZitGZ0dKbURQb2YrOHk1NTU5blFJZEFlTlg1cnZYZnJXQWhrejJrSWNrcGM5T0dHMTV0UU10Z1V2TVlqYlgwQ3RwQW5SZGFKSVlrdEJsTVJXS09qRE1WOElJaXVjdUlYWVBpUnpTQUxMRnhXdk1GTEZVTkQ0c0pzeHA5c3dSSlBYU1VQSUg3K3I1MklXMG9HcXpkWlVGRmc3bnhSc2c1RUFDL3d4WDB6SEhPQWltVm9NejVjOVpLWVdhYkMzaXFTaDBrTWdHRnFhSUc0M25nd0ppcjFPVXpJckRxWlJGSlMzZTBKbkpUZS9xQVNkWkhEZ01pOTlmSTM4YnQ2Z0tvcmpxdXlIZGlvWWE1WTRoSTdnL1lvVjVpcU9BNkxqUXFVUk5KRXJ2SjJOUXlIR2VlZTBFVWdoQWVwaUcxa0hUbDlvZm5iTUF6N0diUDJOei9CUkVaRkRzTHFPR0pvbjFWR2U5alByL01kY2RqMDloSGZ1ZjYzRVZ3Q29BRXhPUmF2TWdNME04aHBoeFIzeUZSWlIvbmIxOUhBc1RXVjdmc01sS3dLbzdBcFpIYmxtRk4rakFLZ2dLYm9yWWNySXNScHQrYTVyQmdFOWs3emd6YkJ3QVlQdmZUUXdDS2t0RGxLbXJNT0V5QWYzVnFkaTB1MEsyWTcrdmFMa0l3WWMvakhsNDNDK3ZRTGlKd3NaWk1JRWlUL1RXSWtDUEhHckIyMktQYXVOOE42Q01JQlpVRG9rTTlWcEl4ZmNxNW1FdE9Ebm5LNFpqWXBjNzRzeGV0OU1XOXA3UjRSeVc4Y3kyOS9lN05xSUtBdGdPRUordzF0ZlNQL3Y3dmhrM3N2MzcvbDNqMk5yZ25kSU9FZUlxam9yTUozWFRYUXRWODR4cE1CTy9iQ0lCM1kyVXh2ZnZXN2ZUejVvTW84aWZEc0VUeDA4MUQ3RkRUekhjQ2VzRWZYYWY1YnMydU10cE8yUk9Bdk1EM1Q0eTcwNFpJVEpNSjhFZFB5ZnM3ZUI0SGIwaG1oYWt3cTZzMzB6dHZ2bzdIbFFxeU1sbldheE52NjY4SnMvamswMGVzUHlETit0eFlXZ1NrWGs5M0xNQTNUeEkwM2xsWGNCWUo2L0NZUnJEclZKQWdoR2JBdWk1ZnBZSUdVcWpyVzhlYnZFaldndDVTMDV3MCt4ckMweDhodjFJMWpFL1pycTdFM0dxWU9LYlpuM3h0a3Z6WkV3Q1AwSm05UnFwU3AwdmI1QWpxOFBYVnBYVG5Kc25SZUE2dnorWVNackRVUnpLMTFwd01aUitnZlVDWDdvOGVzb2RIZE4zQmNGOEU2RXBJU2FacDlkR0U4b0N2NjJidmhiTlRlZ1JZc1plOWxRWmhvWHdHK3NQdTZSNVovTThTTVVwR0RTUTdVKzNNZ3FqQVFNSlVRcmhIZnB6eFk5dVVyR3p1YWtSQkZwbWdTc3o1Uk1pUWlmYlFvZ3l0cW9FMU9yb3NyeXdHRlZkWDcwQ2dtWnFoR25JQ1VZUmJuOFc4QUEwdEU5d0JzUjIwR2RnZVJnOCtleDNHWWl0eVJ2NFRrbFdkQ0hHYkxIcGg0eXlpc3cwajA1WmhEWE9KWDhEakNuRVl2RWdieVNSYWJHRjMwbEF0c1RzSk84NUtqRDZzZFQ0TUVOVHR5b1JKbVRDR3FVT3VWREZIc2pNOE5NcGlGT2M4S1h6RDcySFU0eDBRaUY4emI2V0EzY2YrWWpxUEM2Wm8zYTlxR01mOW5NUHQzNTdrNDloY3FJcWdIcC9IZUQzSVlXUEExcUNuVk51QmpVMXR4eFVTWm83bWxaMFhTRENvekdtZWpaN0N3MEV1SmhKWkVTK0gxMVhxQ3ZVYXd6OFhZSE40U1JRQ2lGMUhPVk04OUVReU54bUhWVWQxdUlhSURoT0pNQkhHamFXS21TbnhLdTJhT0VyZEo5U3dVNWhMRjdXMlB0WkI5SjlEVXVwQlhFM3NFcVFjMGNSenNOL0VnNFQ2b0YxQ2FSQUNtRUI5bkNJT2Foc3VIejBKWVRBbXd4cHBQSVJMeWdKQ29oVm9WWTNaSjVrRjhpdnI2UUZtWE1RQTVmSCtEcEZ5OG95L3lsb1BrWjRKSklFcEFWNFkyanVBRml3Q2dScGlneXNQQUlQK1JTRjlSY3VyTFhMMlBudDBnWWR0SGs4ZG5ZMnZFKzA5Mm9oU0srKytleVZOTGY0OWJEMmZwaC85OUFIMkptUCtxdERpSk9XSmkrbm52OXJGZGpST0dXSEs1ZUM5bXUxT2tJaHVlYUVxSFpaL0FkREE0RkJoVGlqMVlyVDhHMjh1WTZqSDNOQW9wczAxaXU3dFAySWVKVW90OXpIczcrT3BJNmdUajJJYk5iMXg5QXp3UVlLRmNWbmJ5ZksrMTY1Y1F3VmNCZXlVUkNuekM3MXY3VkRqQ25YdXlScWdpc3E0UkhqRTY3ZXZwRmNBaWRtWldRSmhDZGhFWlpUUjJJcnVCY25JbTNTNlhudTZHMzBVVFFGYlBvQzVFMXdKSldEcndxQk81VnlyaldoQ21lQ3d6cWpPbzdvWm15UURiTEszTmtRNTB4eEFqZnB6bkMzbnFLa2QwNFVBbHpxMndWbEFlSXhxSG91b3d1TjFKSDBZdk9XS1R2RThucC9qZWRRY0FhRHNBNTZQaUdkN3NtM1lBVVVRU1F4ZmJGT3NFaHJYWkdSM25pNW5QK3hXN0dJT00wd0wybEZ5TWhIWnlxZUNrdUV3bm5udG1XSHVnUytQa01uZ0djVGtERFZBTStDSEFjRkRRRTI4NkhDK2E2aDdacXdZK3pna0xLZ01qYlU1MHdvOUVTZUpRRlJHV0NseGFISm9DdEUvODdYWFhnM1Z5Mk1lWFNwNFF6VkRpZENJWW8xdnBpdDBRRzJOeEtHT2NORW1ibjhsbTZaeFNZaXlndDVtZXd2Q2hmRDVKOEZxeDFEdE1VeC9naHJzaW40R2k0MWp5RFNwdUl4b1hzQ0x4ZW1EMHdsb0dYS2I3S2prNWNGVWd2Q245OVd1NGlGMkFZS25JNG1wcGhZNHZCNThaVFN2SldCcEFPVGM4VjJ1VzBTYzVGVTVsSVo1VTNtNEpDOEFGa2d6MnJOeWpOczRvWWg3WWh5NUFiWUppS09JcXFpeE1hNHFXaVBxMnlvcGxaQ09rSkE2SEZnOVZiMEJSdHYrRGg0d3l0R1NXcE1JZERSdzFkeEVEZmtXRzlUSXI1Z3VHSFl3U3R1SHowNDVoUnd0eTRoYjBxdFdMTnUyaTQzRW1hQlhqanZHWExXVGFiZHdybUFhMXlNZ0VOM2VQbmJUN1hFQXlzb1BqQWRpYWdFS2RZenhjeGphTDJoQnBncHhURjVoa3doc0hRZG15Q3VtdXdjR3Q5ckd5L1hXcVJJcXJBdm44dkJhY0ZJSVJtTjlWUUpqUGtQMmRNajRLMXluRHBFVmtaU1YwQVEycnlGbmxKQXZNQ0lmNi9RUWpKVktZUzU1UW1LRXRGUFVqWE5BZFI4MTlObmVmcnIvNWVQMDlodXJxSHAxcW5WU0o0cWs4S3MwVy9pbi8rUkRvclVYMDEvODhOTjAvLzUrU0hJZXptMDhYei83YkkxU0xyU2VYMXBPRlFDalJQV0tQLzZqOTZHeFhQclJqMzhad2FaZDZPVXhXUUMzaUhKZldDRlFlYTZVL3M0ZlVvZ1BrOEpYajdhdzhlWFRCb2IwS2NHRkFGdlZyeUtxMTRCRlZrTXdYMUIxUmMveXNjR2NBSThQNmVTVWRLRURHcWNZdTNibjlWY2pKV3FHamo0VDQwaDkxclBtd0oydzlockMxNGlrMzlnZ0xlYlpUa2h6NTRSMTVJdW04TENPT0FXR01KTHFHTlVzcnQva0xHQWo0dnpWS2NGVFJhSVp4ZDQzUU52d3RUWUFhN2tYSFNVNXdMUkZPSTNuVkdsUEJtaG9Tb0dlaWRwSUlVUWt5VHkyc0VKNnJFMlg4OW9nZHFySlowNHBkSGtBU2g4UVJkOEd5QmFua0NDSjFac0FYUGRlN0hGdHpBclFZdzUxTzFSQUpPY2NRYTVIcDhSaVNROENGTyszWVpyUnhoNlE5WndhVzFVQzFNVUFUaHBhcGN3MUF5eXBXWU84RW53Zk90RGJMUGlQczJaRzZ3dG9tR0k1RXdDb1RqcWt0bzZPTEtRTFl5bDErRkFJa3ord0o0WE95a0JNcnJSR3VoemNnMmQ0ZmdDQTJodzNWZ3J6aG5MY3l4YnozbFRMZnhPdlJCY2pwcllRRDhWdlhmVWNvaGNZRlgzRWdlQ25odWdST0Y2T2dFY1BvRlVWcmwyN2h0aU1xc1ZCQ1VNY0hFNjF3aElYVVF0SDhSZzdHY1Brd0txbTZxbkRtNmhxeXY1b1ZQZVFneVNoWHp0SmcySDFDSWs0WVZVRHdLd1lvZmRTRmRWQVR5dVlhdGpUSzZobzdscndwNHNUMXdKNklRZ3RjZHlZalZkU0xPQnBWSlF0RFJiZ0ZDUUFFeEFyZ0FtQTJzOWFKSjVhdmJIUkZNQ01KR1pEQlVKRWU0UDBPdjFETnVBWkM0STBsbHRrUE5RZ0ozNm5Rd1dIU25rV0lxREFJT3R2eUlUZ1grUitPa0VzaEtpQjMzMFJ0T0V5WEp2TWZXSnhSbG5QSHNuUmdwWWxxeHVFUkh0NGJVaXJxZEVEdHIrUEtzSUNpcjB5QVEzMTJzS01Dd3ZwRGlaanhkWExoM09WRUtPK2tVWlg5cWFQN2JDSzZuRER1a3dRRVJYNEdaT3NWTEJpeVJpZ3dheHQ5dmlROFI3YlNSbkNPOGZ6eC9GRHFnYjRHTDh4Y1YyQkN3UDdFd0luOTNjZXBQdTQ4SmR3Mzc5TEdNUGI3N3lHeERpZXZ2UEJxelJ5dUo2Ky81ZWZwMS84WW8zNE1mdEtEdFA5SnpETC8wblVQckZGYjc5M2k5Z3B2Rm9FY1A2alAzNC9UZUhkK3ZPL2ZFVE5jNXFaQWtvLytlWFRzSkY4OXdOc1NtOFI4TWtCUHp2K1ByYXFVK3EvTDlIemtIZ21KSjJzV2dLSEV6dU1BWjFiMnpTS29ObUZCUUtjbjJ1bTZVUkc3cnBmWFp4TDE2OHVBVnJhZnFnT0M0TWRJUFdBcVlRRWtnOTVZQ0wyTXd6anhGNGRVZEtIdldnaFpYRDY4VGNoelpGaGthTkg0UHdDbmNKSFp0TDl6KytsMmpUMlZLVFlPZzZnRXArcnNLaGRuQ0lEMXN4QVdNZG03YkU4RWVvZDk4cUREQzBVMkZTaHdyYnZCYVRiSEpyQU1STGNjNGFlU2ZSNDBBa2RhWEs5TTNwaW12b3pqWFI2aTNpMTEyZ0srOFkxZ1BvUSt4T05XTTEzakFhcWFBbEt4MFBPRFVGUTBBYm1HODRrckJQcEordlA0SGxIRmdrTktmQ0VrNmI5MXJQbm1ZeFFLYzlsakEwSmo5STlBNXdTUHN4RUtlSzRLckd1TGZhMHFqM2RDaTdzVDVjNW1sVGZ3SEdVSXlURDVqRzVmL2NmL3hYYWx1VkZsR29VK2xXYlBNZ2lwTjR0bGdMeFVDNGppQ2tlaHFURFFBU3NhTGJJUUJ5d29RVkRpQy9zTWl4ZUZrV2Q1ZHpwaFpJckNXemF5QVN6QytLSEdzVHhuSklzeXQxRGpkUnI1WE1TOGY2eUpvOElIb0dpM0xPaXlva09id29QUXdaME5FaGplRFlXaWUzS3BMb3N3cHBWNXJWTW90STI0OEh6b0RvM09ZU2ZWK29UTUhtTEI2ZU51WUFNQVREaERHQnpoYkhzQVZpU1IxVU13NkppTzRaSHBESTVpU0ExMUdQSmRlUThxbDZDdWc0Qmsyd2pEZ1dYY1NMZnJJTUhsR01Fc1gzRjY5cld0SWVZYUFwWXErNFdxQ0JhWFVKLzE5QVA4WktjeWxXaktvRVpBU2FxaDVmRm9iSUcxai92OUk4WXZ2WTNIUUdTcmRudkRaa3NIcXhUU3JrUTR3YTMxNU8zczdPREszODd1TERnSmNGcHN4UzByTmJhY2NONXVHYVpwTXNNQ2Y0czZra2xGS1ZldkVpdjBzWGxGZXdoNHpncHhqQ2VDcHdNSGpxS0ZaUTV3alNDajZRR2grNEV6cjVQZ3Z3dUFIWkFRNUJ6N0gxdDFaQXlIandrdHc2MG9ZUldaVytzWHJDeU1nZElZWkQrNWwzS3Q3eVNhbmdUZC9Hb1BmcHlqMGFuRDlPdlBuMU0vQjgyVmtEODl1SmtldVB0bWZUTkQxWUlXMEExUnhxNklPN28weTkyMGc5Ky9ubjYrS3N0RG51TmRKVTZzVnVyNlR2ZnZjdDQyK25QL3ZQL29MRGpROEpDYU5pd1lMRkViS1VRUTVleG1CNnpzMGZUVlVyOFdJd3d5aEJMMDBpT1RCRVRSd1ZiMWpKQnFSVHNJMWl6Z3ZQSHZiU2lnbElFU2dlTlZGSjZBVkFacUhrQmFOcVkxYmpIMFBlaHpRb21saWtrNUhuQ0YyN2RvdW5FRzIrbDMzenhSV3JBSE45KzcxdGhKOXg2dHMyNUlwL3lVSHVxS2hrTkpKQ1FXQ1lPTTU1bHpCUjZpQTNhNWdjbUNicHh3NFNNVmxkQ1ZEcXhUSGVSOFNydFMreDY4UW80QzBiNTdDS2hIa3ZrMWRJdWdINk9NRklreG52M0NjWTkzeVV0UmdRZ0ZJbjl3WHNEdlZyZ2tzcTg4bTFBVTdPRmNXUGFBZ1Z2bVp2cm9qUE5sREp4UUZ5NGpPbUxDaVY4Vm9FajYrQUQ3V0szRW04c0hSTzlVV0h1SnQvMytXa3NhSVJCb0ZscDU1WXVnVTNsRGliR29ia2tVbEV2Q0M4SUZxTFY4OGNDSzFFNElBbExnNi9lbGhnVTNOU3dlbTFDU2loS0JFNGlOaFpnMEQwOWhFRGorM0NuUzFYRDZxQmRwSkF6UENNZUZxVXluOVorMmljdFFydVZobk5CUnJEeGNCVkJkVUhMTkJYZDV0clFkblpmVU1YemlESHpIdDRITjBZUU1VcThaZzRmY1QrQ2tVNkVNb3R2dVY2bG5nQXRpQlRZWWt4NnhWUnIrSjFYVERteE9vVml0QjZTN09GVmxib3kwR01aMkRTdTdVRTE0NTJFYnVGTlF5TmZaUU41aHEwS3JnU0FHYXBleFBCSWhBeWZJM0MyOXhvQVFWNVdkd3NiQlhsYTVtcVJTTjRia3E5MXNna3dVc1lIejZRcW9nWDdhcmpzeStSaDJxc3VUd1IxUWhyRGhNcDlpTitCbzNheEF3aDhqQ2IyUVNuVnhwUmxtcElLK250SUNqcERsRUlQQ1pwMG5WVUpYVnNaZ3RKejFGQm4vTDdtSTNOTDYzVWxyZ1lwc29xbmF4RWo3aTFFL1ZtNGRCMmlJdC9YNVkySEJCcGY5V2YyRWh3YTZSc0h4aEdBdnN0YUhuQVFkdHRVT21pYkF6bER5M1dNenFnZUZ2enI5TWtLUUpWODhxU0pqV2lOMnUzN2FZTkEydmYvNWgzcWVsRnRnQURZdHlrcjg0dVBycVkvLzhFOUtvT2VwdnU0OVhlZ244ZnJSOWpDcnFYdmZQZ3VLU29qeEcwTnFCN3grK1FTcnFYLy9wZjNVZDg2NmVlZmI5RG5zSWg3ZndtaGcySitKVnE1SVo2YjhHNXZ2RDVtRDFOazlwRzh6TUpRQmNzb1JLM0R4aXlBSk9xUGt1a0lUb2oyMlJFU0pHY2tETlhHR0NGWmtsdlh3S3Q5Q3VpZG5nS0FkRm95TzRNUGNRMk55aHJROFc3aU12em0yNnNFbmk3RDVQQlFFcmYxNFFjM3lRUTRwNTQ4dlFjSldtMi9OWXVkbExQQmdXNHhGc01EdEMzM09ZdFprVTF0dnpnL1VPVlVDWlZ3OVBKVnRjTnlIcVJONDVqQ0hncEJXdmRMNGFDSzlGUEZsbFNnU3NNa2llbDZCNnZFSVI3UldpMVZzS09aa29NMFZkVUpCYjJvc2hyR1V1WnpBLzYyN3B6Y1VHWW5ZMU5ROEdFSTBnanhYTlpVczIyY2VvRHQvVmc2SHFxMk1uT2ZXZGhQQ0VKY3I4eDk4cXhyRjIrdUttc0hxVk9UekJBTnlzb1FEZVovQVZnV0JSRzU1NldFNVdsVUVsSTY4QVp5RkJlQTFZQnpvSkl4SUVuUjlsYStIN1lqM2hPY1ZNMkFsWmlBN3prUnYyZXRDK094dEx1b2RobUlxWjFxSEZmMmtGTnY0S1AyTXgrT3c5K2JkRC9oQWlITkdZQW1RQ3FWR1FmVElmWkU2VTYxUjg5RVU5Um56TGF5UG9OSXJEUXFpcnNZN3BoR2M3MllWVXFJV0RvM2JFdllLVlIvRmJScXVQdEhrT3BzK0RpR2dkV29jZyt3eWNwNmh3UUVINEl6VytldVpOZUdrOGZNQWJjOGgzSUFNUXFxTEJtSFFhTzFvaWtFWXV3WHZNSFlFdDhyVUxuQ0xpR1lGaUJhdUFqMnIyYVhNaWVrSjlHUW5DOTdIZXgzMkZrUStvTWdMOWkwTTlTUUtzUkFaU2VDSnlIeUhPa2dKQUFYR1lkU1lFaUxFS0lwRUgyK253L1IzY3dDb3VDeEVjN05FWlpoRGh0R1cxdUR1WDVuaERab241UVRaeDFMdEEvQ2tiVmZRR1U5SkM3bjVLNGpUS1lhaDNPZVBaekVhRnFIODZIUlExUXVUcmJWNHJjN0tWZ0xYcHdKeG9rOUJrZkhPQkxCREwrM2VQRVU5WEFQNThRVzY3SEQ2NGVBWHdjNzN3VmhEQzNTc3RxRU1qVHd1SjAvcFpaWDg2ZUVPR3lsNy8zZGI2YmJOeWZUeW1JeGZlK1BhUE4rK3hZNWhmZlNqMzkxajl4SXpJWkhSWm8rN05OQjZXZnBqLy9lSGRwa1VaMlRmTG5wNzcyRGwvQksrZzkvK3FPMGViS1h2dnpLVkpBVGtzVHZBOWhVbENCNHNrdkV1VjJSKzVSMWpsTFBySUdORDdKU0tEaHdrQkpsQURMYk9Cdlk4TXh1YUNCZERwU2lrZGdzT05uRkVHMjg1QkRUZ1liL1FZK3NDMDhGaTZUOXNvYk5kZ3E3bXlFblZqcWRtNlQrK25RcFN3bHpHYUhUdTh0SzFpY1VGQ1Fta0Q0QUY0UmduQkFJYW9Db2RkZTBLU2tRNUFGSEs0ZGFqSEdJeEdQT29ONjlBaDRwYmJzYU1lUzFlb0UxNGxzeGVHQTBQS0JCa0R5amdvSGluczNSTUtNRllaNmVESW5rMzA3cnRDdWJvbDUrRVRyTVEwZG1hWEJiNkV1YVlJTU5TZUwrSERPQU93cyt6aVJ4R1R6blc4a0lTVEFDeVBsT0ZrUXQ0RUZiekVITTRjQ0FKMGg4akdQQUhMb3NtcHFQN2YyT1lSclc2TmRiMjhReFlPQ3pXUURXcXdPd1JIeStKTkV4eFFBWmZsTjg4NkFhbGFzTzZzSFVkZW1oWmVpQnFDRjljRVBWUE1iSnl5NnFhQTZsdWtrQ0I0TXNjS0NScytNUTZBMnhMbmNYb205enlCRmVXZEJNa3RLR292dGU5QjBsWGlnREw0bEVid0t5R3hQVjl0UkRSRzh4QVJmSjR5R1lLUjBZMUtvOVJwQlZldERPRUdwTzI2S0MyY0dUMk03T3FPVEo5VElwd3V0bTZvaHprRk5FeUFZZ3J0ZEpLYzNXOXZOekM2Z3BWME12OXhwKzF2QU5EY3lRRU9OUUNpRm5EQ0JXeFE1Z1UreUF1RXpLTnIrd29KVEY5M0tjZklIUXpyOEZEb0liVnlSRW9wSzd5U1pEYUFRc2FuUG9ZM0ROdzNIc2Y5amwycFl0MGN1cDNlNmlSZFdNM3RPNG42cHB1VWdGQWV4Y2VTVFpjbVVCb3B5RmFMQnBjYjBDM01xeHlTa0ZabzNMKzNpVGxMckc4T1lJV21ZWTZBeW80a3RYdGJmTi9DakVQUXJCQ2J3WFVINFRUamtCMEN5eG4zVXN3QjRHdWxTeEJ1dzJ2elAxZUkxZkZTYUNyaUFmNXNmdkFqV29OOGFickJycVhDZmRwT1R2Tm1yck5tRWpUK25OZDBqdTNBbDVtbWVBOEFucFVaaHo4YjZSUXJQVlRiODVXOGU1TTBqZi9ZTTN5ZDJqd2dJWkJyZHYwRngwNmxXQ002dnB2LzNYeCtSTEVrWnhWRTc3bngrazQvem42Ui8vUGkzaDd5eWg2cHltYjk0ZFRVKytmVDM5eDcvYVRIc2I5OU92bnpmU2swZHJ3YkQwZ0lmcEE3b3gvY1BDaWpZWkNmc2RubW9zaUdIL3N1aWVFb1gwSlMxRzdCMVdPZmRLV3ZSMTExaDFwOE0xMGJ1UWttRUdxTkhHVUNtVkxlSUlXVUQ2cXlKZG1hZGJ4a0RlNmFCK3dVaHFwVW5vbFRxcjBBZVdUWUlvcVpJNlA0OGpBRWJCZkEzRVZoZFVEZFBJYm1tWUhHV2NqR2VDeUZoMXp4eTBBajAyY1E1cGFtREwyQjhrSzVrbGROdUN1VE5nS2oxQXRaeDVBNU90Zm5wc3JCc1I4VnZQTmdHSkMxVEVPdlJQekgrYjRHTXU0cnA0UHpmWVppeGhQbUpmTFM4ZWppU2tPY052ek8xVnNsS3R6bUdlMEg5dTBHZUhQTWtDMnBCLzJ3aG1TTzRneHpPTTdRM2lYblFZQ1VobkNDcUdaWmpSWVFYU0JqUk1PallGTzdReG94SjI0QVJPMFVsbyt6RG9Ld3RZekpEWk1JSzh5akZyNWNIMlllYTV4alJGVFI4ZVVpZmlhNVl6ZHFFVWVVVmhGMFNkVmlBSU5aR1BxdU8zV1FROVNSSGVMM2k4QkI4QlVUQ1FBTHkrYXB2ZzRnTEZnOG5hWGVTeS9aanZaZUtvNDNjaEpCN0ZUUWtGSXltSFRjVFBJc21Sd2dBMzM5TjQ2dXYrclJxcURjZEhwZ0xoYWNQZ2Vrd1JObzM5RnZlenFla2g3Y0pHTVRUck1qWWxSa2RCekl2N3lFV3lzYm9Vcm8vanplYXVDdTNEZFhLOHZxN3EyVVZLWVNpaFlpRFRBQlF3QjE1UC9TbXV4WG9CNmdJWTJrWndGTDhmblVUb2wyaXdhNnV6RjE3S05sMlEyNzFkTXYrTjkrRjc1RmVXaThSZUZTbXNpSGZPdlZDQ012WGhBdUlVbU15Wm5Jd3VROW0rMmg1TmhxUXdyUmUxQlJQcWU5Z1lYK3dKaUFSL3B5MDYza25Hb1lFM200a3pFNjQ5TGp6NW45RW8ycFdSOE9OM0dhb01NZDduTTVBS3dBaDN4aTZDa0p0bW1mSThuSDRiSnJPTjAyQ1h0ZHhBZ2ptVVVWRytnUUQvMUNDQnQvT0FxSFFjQnp0N2I2YnZmZmY5aE9tSWV2MUlXeC9jaFpCSDA1LysrY1AwaFBpbUpwSG1QeUhzUVVOMW90VDFtNnVFck9DV3YwdGRxQVVhVHh3K2Y0WWhIcWJGd0F3TjBRUVFlOE9NZWkrZEJ5SHhhNDZBNWlYem9RNFFmdGNCeElMRVdmQXoyWjVDMUR6Y1M5ZFFTY3dHSDlaajF4NXJJVXBORTNZMm1zRVc1N3FZM2xWaEViUXYyWDl5NytBOGpaTUpzRTlDOUNNOGluN3Y2dFdyR0lER2ljSFNXRS9sRDBCTkxhZURMY3kxdEZQNUNkVWlMSGhwZFJCdHk2cWpMYVB5MlJIWDNIQ0xQaEszMDRwem9GTUk0Tkxqci9vNmdEbDVScHZZUDgwL1BEdmVUdk40T0htSjZ5bkpBUlFBb09PTWFIVzBJK1BIUUV3MEE2OXB6VGtBaGZ1dzI1Z0dQYjltU2lCdDR2bFRJRExBVzJkVnE0dEhYU00rT0tNVEUwRS9mamNQc2MzM0ZGYWlud1BmZDI4TVdxOGlrVWJ6WFhBSi9nazlRU3pPUnFMbTh2RkZQVm9PTUVRM1hwV3JYRDRDU1BBK21LK1dTUnJvemJCUXBReUJUbkN5ZW9PY1Jud0w4T0p2eFdVTmFUQnNIaDRyZm1IVkJVRkozd09lSGVic1R2NHRoN3NFeWQrKzV6WGg4TDUzK2NqZTR4Nkt2QUNXZ2FaY21YdGh4RVZGTWdCT2NQRWhXTGx4UHB5TDEvZHZmenBQZnpmdzFDN0hxazVHSkx1eGhuYThlUEU4Tlo0U1BNZDh3MERNZ2hvYVlPckpTTFR4UWhxREhRb01KdnR5V3BpcFhBZEs1dUYzSEt2MzB2MHNnYXR1NjRMbTVkaWc0Tko4UjArc0RRRU1KZUFpY0ZjK0FPSEszVklmTmNPYVEzME04NGd3Z3hLU1YrRnJ3RXVqK1FWeGRQUm5iSzhoWHJzdnBLSmczSzVRRmJhUUk3QVZtK0VBVzVRVk1rM1Z5V05JdCtjajhnVGNqUW9TR2pZWkp5dVBxa1JkTXJnZFc1azZxQm5tNzAwQUxLTjhOd2RCK2pwbW5BQXBkOE9uR29NSFJZejJVSm5Cei9aSDNKeUhSa2xNQU9PY2tGYVRFclo3RWw4N2FaSXZVeDBsSFkyZXArZTQyU2RZazhmWW1QYVJ1RnBVd3V4aVg5bkJIbVJQdnNicFo2bUlPLzk3di84V2ljc3dFMnlVLy9BUGJsRGlKWi8rNU05K2t0WmVZSnNqbGVxamh6YmsvVG9WdjB0RlVxcHZEbW41VlNMR3lpb1JQVUp6MkhuMkFBRG5FTWpsM1ZlbHByRGpRUnVlU3crUmU0TVM2ZXo0VzFVSFdtVVNrZDNCSEtURnNCY0tVcWlSVWZzTUw2Vk1vWXFiM3lvTEl6VFgxYjVVRzRIQnN1NlJMb1VHWS9qQUZpV2RkdytlSVZHZlk0KzFKcHNWZnJXLzBkMzVpRkZpLzNKODlpbVFvcFN1ZWdCdEM0L2ZPVTRyZ3l3OVY5S3JnR1U5ZlpvdmhpckZkR0ovVmJ0azVFMDJ5Qk9ueWliWWVFNlZiQ3kwV2NEZVdSdHRwZVZWbkQ0ekJOTmlGelkyU3FPNDRLejNXTSs3RWU1TjZMUEpXWW0rQzlpOXZBWkhEN3JsV2xRQ3NUbXRGU2dpZU5RSWVneWRxck5ET0tCQnhVMjRrTEZoV1VZSUdnWWhHcHJCak5tTXNsYlFtQ3BzQWNETHBGMndHeHBCVmdORWd1aFlDc1ROZ2FBUzRNTUFvUzROakplSFdxa2tpNVdDOHBpNG5GZHZsU1VvV0JadWlCN05ZUXhqTmRkMGd6Mmdxb2lLMlVFQkVBR3ZBanFxUS9BMnBDVXAzV3Y3WFVGRVNVV3B4Ky82dDFKTUhISk9PREFHOGYvMXdmY3VQcFR1Q2dSYytqMUJ3Q0RVeTBjR25vNlhSV09SQlVPdjU5OS9MZjFrUWEyaEJnQU9Hc25kQUFFM3FuL3l1eUJqaEg0NEN4aXZZUUxHTUsydFBlR0RyZzFnRGRqWGlPeTFuTzdvQ0pVMWlUdXI0NFdTWS9xK3M4OGVjRmdNb3dJVXk0RmtvM0hXQXdSUm9ESkh5V2NrWHp1cm1KQXVzVGxId3dHVUpNMnE1MCsrNXlGRGdjaGZaODdZbEtoZE5GWW1NaHE3aXVWdlRwczBHNzE0a2M2R3o5aG5ya044R2JaTXJzRjkrWXkyTjF1STFSbW4zcGxoeGpiNUxGS3BZM0VSM0RIK0xrRThVMUROR0hzdkdQbU9BQlQwNCsrODZKaFlWcVM3N0QybjdHZUNoL0JUOVJBR1MwbGZmbnJZK1I2Q1pIelA2SlFhQjdCR2tLNk5SQ1p3Y1grRjhYcUg1MUZoQmtrQjJ3aDlCVGFlbmFUL1FSVDhrUFpYMy9ud2JyUzNzaFhZdDk2ckkwZTltZjdrVHoraVNCM1I2bmpYUHJtL25WNWJ0YUhvZWZya294K2xZOXAwV1FwSSt4TGg5NndyTkFVOVdVcUlwV0FnL0NjZ01Zbk1ycWVuamJVMmpnN0p5YjN3dlV1NkRHMkRTU3BGU1R2R0dmcDdHVVlTa2hhZ0pXQ1ZjRklZUmlCWXNWSGhSV3lkYXBSdmtiNUNtUjJPWW1OQTBqSnFvSTRtNmVDczlYWGFJZkMxVFJ6aGtOQUNxME5ZZ1ZQeHg1OWhCakZhM0hnK2dRQzY2R0pqbEFZdlZPWFF1VXl2czRLdEpobnBwd0VBaGFiRDc4N1RQZE9qdDB4WXhmTHllTHArYzRJcXE4UXRFcGJ6Ykc5TjV5RERSZXZpdkdpRzBWUG5zODM5d2FSd1NuQVZRRTBxTWFJQUFZYk1nTHhsMEFGRDE4UVVxQWpXbG5hWmg3WGJCYklSVEMxNlBrM2lIcThwK0tBS1V6OUlJVW9tNzdtM3JWMVdOMDJCaDhvT1hSczZZQlFHNi9nVW5GWWRnQTFRTWdpYkVvUXRFbnZBQlpJTVZDUktVWmNiUytDS2pIemVUV1I2Y1MwTmFBSmFlQ3JZNUQ0ckUwanRBS1ZxcVZaQ2hyRERXS21velVOaXVKUjQzTFJzVWZrc0Q2OGZJOHRXSjhCR29Nc0l5UGNkbzRmYkNiTlJzYW5rTGxFaXcrWDBjUWwrL3U1Y3NnWDEyR1IvZXo4TDZ3MElCcFdRbldmWW0xU1hFUnZHckpua1o0S3Jac0NwWkhaS1FGMkRZRnJEQnJTZm5aN3RJNUd0S3puREdWZ1RBTWQwbStucDZWQU45RzdhME1JNVNURFpPQmlEVEFOdXA5Z2NoeVBtekp6NEY3MGFtWWJHVEU5WEh2SEdVQW9vbGUrb091TUVRQjBGM2xsM0NpdVdlUkxiTlZhejhOb2VCMk1kZGVvcDVWTTRvQmRaTUMwb3haVTE3SnNHZ1dTSnA5SEtHTGE4R2lnbW9kdkpYVjFqTFJDVEJzT0dnWm5iT2haQmlPMlJIN210SVFpKy9CbGd4YnI2MnFWMDVlLzZiZUF0QVhwa1hQQUIzbWNMZkFwKzR5QlpNWCtLL1l4c0I2aDNuR1RjNTQzamRNNXI3Y0lWVkl2WjlQaEZJLzNaLy80VUlPNmtQL2c5ak9vRWZGcWU1RnZ2WEtOZS8wbjZiOS8vbkJnc0l0aXB5NzcyWkRSOWVmb2dmZlN6bjlGZWkzNkQySDBjZXdsOU5OcWdZOSt4MllUVks4WW9ZYU90eWYyUUZtUTBsaC9xY1FCRDh2UjFDWXluNTBHR3JYM1UzLzI4bjFGaUsrUGdrWEY3TUpYRXBLTVcwcStsZzVvNEdGUkZyU1hmUXRJd3BjclZQU1B0U3E5a2RubDJwYjJEOXh1Ynp1Z1NvZ2ZWUTN3anBHRVdHOXExbGxnZlljSHdGVzJidk1UcjNsOVZEbWtjNlRFcUp3aUhiSTVOYVUzN0diTTFIYlhMUmlqTFBJb3RVOVBBZ2gxL0NMT2JuQnVsdDJFMWJSMVFoZmZaT2hJTzh5VXRLcVJLUVE3UWJEUGZCalJ2T3k3M1I1cTFSSldDaWFBby9TbmJTN05SQ0lFTkY0Q2syOHdoeG5wQnYyVUlwSVFrSldEWkU3U0dDazNqSW1oSnhvOEpnNVpsOHN2bzMrQTlvUGZpZmd1ZG1wdFN0b0ZOc0lxb1BkZEVYblJJOUV4dFB4SXIvN0VnSGdTSG9VUmt0UVlIQXVDd1dGeVdnZk4vL3BkSllkS2gzalcrcUdqSXdQTGMzY3FTaXROZ1hCQ3l1V3lYMGxkbXgrSXRObG1DOFQ1eFdMZ3YzNGlORUVRMWF2b1ppZU1TZ05nalhrT0VaS0kyRDFXUDlqc1ppUEtiODN0NWpldzF3VXNBenBBOFZFR3VsMGt5M0IrVjF4a2d3OFljdGFINk1IeURsWSsxY0QyOHYyUFY1cVJheklnWkJ3RzBjRDcvYmxNNTB1SnlHdjgvLy96emRPK0xCNkVtS0FGYXgwajF3VDZHcXF3K1BTeTJXUE1BZUtva0FJRTREeU54YkpITDU4UVlVS3dQNEIxYko3RGlLQWh5WVU1K0xvSm11OXF3VUFkeFZYZXBkNzdaMlNaaSt4aldPQVZCbzA1Q0VCNjZLQXVDeXFlbnQ4VGhMS0ZHSnlLc25WTFV4c2QyVmFmN2NRM0V5YWxlT0FUWGcvKzVOUDdOVU9ORmNVNWdFckQ4ME9WblhGSklSdDlNc2lZa3QxWEcxK2tFNThkN3lMMEMrUGg5VFA2bE00ZG83OGthUUFtb1BrZkMybVZjaDRocHA3U3Rla2plM1A2UFAwdE53UDhQdi9NbVJmaUlNaWY0OC9lKzlVWjYvR0FqL2VyaFJqRGp0Y2RQcVI2NlJwMnZVcHBZV0dDOEhFNGtvUnFGRXUzSVBVSGxVQnU4R3JKVHhwdXFLaDdqaHFqYzM2eGppL3ZMdkZoc0FVRkc2Y1BpYzBYYmJBa2UwSG1MZ25zYXRnY0VrWUk5dkEvdEl2bm9FRExqd1BBSkphZ09LcTl4aXBscTVoNmk1dUYwVUFXVmh0M1VGbXFyZ2RMOS9qVENNRFlxVkhRdnFtVGkrbmJiUkxzckpRTUcyaVhkYjZ1ZzZqa2ZRN0pURGEyam11cElxYkZHZFRJQmRBS004bk9VOTNJQWdEOXQyanVCWktORHBvTDVvRXRlNHU0NmhRVW9tYVF6eHVKK0VjdkZCbnBtb2o4Z1kzZC9YUTgxbTJpUHg5L1NhMUUxV3c0RkIxSXFMSEYveCtmWmdJTFRFT2JnNnVsN2hsS3g5Mkc2WWY0bHpuUU9jNEJxb29VVDI0aHc3WUlaSWRyWnVhNy8vdVNIVDBrQmdMaFpJd0xjR2JTeEptdzgzTWFxaGRZU0FwUXpFWjh0TXphcUNZaVpjYzA5REN2akg2ak9qZjJ2aTJITkRTcHo2QVlHa2JJQmVXVCtBcThKZW4wdHNsQ2xCblZWdHdMYzFGSWNSblIzQkVaRWRBdmdGemwwZVlETmpISnozS3hBb01SakRsdU9SYk5XajZmTk1VanhCc01ObEJBeHpybWdMQ1BqWUdTeWZ3NitTTzNCVnE5V3RBOURjcnp1ZDExb0piTnNVU1Vld1ZEYlZVVEFrNS9HSitKd2E5ZFRlaE80TWdDeGZMRVNrdld0alduU2plczRXQmsrSjZFTU1Bd3ZVZTNCeHJDYno1OFRlVzVtUHJsZ0dGc1BzQk04ZnZxRXo3TVozRlBRdW5YelRycCtmWlVOWk8yTk1sWU1aZkFhSEwyK2t6RVExWHU2NkhHSXVKZEFZYmhIQjJZU3RobUoyREk2TUk2OHVZWUEyaGlCcndmcEM5U2lJNEJVT3dOdjQ0VXhQa1lIQ0V3U3NDUyt6WlFoVkFsamNab1l3dk9FVHNEblVkOVFRU0QwVUFOZExvWUFTY1FCRDA5Z2ZJYVhlVTFWenlWMTNiVS9TQjhJZEFGS01ycllFMTUyRHkxY1Fzd2xCbVkrbG0yWmxZY0FLbWdTcndQNTJta1NJcTFTQnNVdXlDZHBHWHFaVEh0ODRYLzlnT0JQNk9PN2Yvc05KQVlPSDNYamI2eGVJOEo4alZMSjVPZE5BYlpUSzJrQnlheU1KOVdVRTQzWDByQ0E1SnFhVVZIUnBTbVI4aFJNWkh3OXdGbjk0UXgxeUx4TlRRNitKeU8zaGx4VE55bjdveVJsRXJETVhVYW1aMHYxaHpjOU5RQ1VPWGlxZWpBeW5tMEJ6Z1BLQWM4REJGWXdLYkZRWTFIV0J0TTBxcU0xdkF5eElWNmQ5MUNIOE5xNW52VTZkSVZFR2JaSDdpSEF5c2p0U0Q1R0FyWFNkN21NVnc2T29EM1d1bkV1Zm8wRnJnTjJsdkRPcWxjSXp0d2Z5YmxIeU5BWnZTRTNPbForT0tjcHg3T29OOGEwaVU4RE5Ga0hZdzdONmRPQlVBRlE5SEpiTDA4SGpQWk5obUFBUDZZRDZOOC8rSHhvQWZ6VU5zaC8wQUpyeEZoc3ZPdjRsT0J4R2VOWXdWWU9mWjhUem1HTFBndFhTamdEbUtRY3psQU9hK29WdDE0UVdXMXdtSWNNeWltSGl3ZENoUVVXQ2hqZFNBN0dJUVp3WlJNL0phaXV6K0tMMW1PZzl3VFBjVHQrY0ZwR1FNb3lCNitFa2RURlZ5d2NnZU4xK3llRVc3SXdYQnVjeWpnUFAvTzRiN0h6TVJuVFhRQUZ4aTlnZVJBSEhsSTRtZllEODVYMDBCVDVzRUZyRE5VUHNrbUFneUkwZDRvS0RiSnRBRkRaVEdBeHFWZlZWSzhpWHdoQ1loa0J3VXhpYktLUHFPNDVLQThxSCtmQndQaXM1WHdka0pKS1NKWE14ODhvVmJyZ2FPYnhXWWJGOXhnNGF5Zm56WjVJYW9DRVVlTVorR0VQaE92Y2ZPVm11c1pCa3VnMXFxczZHbHQyZkhKQ0xpQ0JpbkJmaWY2TCsxK2tOVUJNeVdzZXQ3WlNsN2wvaXNTemlQSjZLSDNOcDBUdkFURzB4R2NtOVNHbU0zL25McFZJa2dZWnBoN2ZLUzlUSE82TXZuV2JwTFFRK3dUQmRLZ3gxZ093ZE8rSDFBcXgxZmk3clpxSitxZm9iTkxxREp4L2hLZHpkdmJ3bFF4OFdEZVhXSUJpaUJsWXNTVFNvOHZyVHcrYUFBVk54bmY4eWNCYzZsQXBKV1pwZzZJT3dYMEppT2NRWk85clIwRlp4ZWhNNENxWVl0VFpJK0x4am51TEVQUmkydDNNcDUvKzVHT2l6dXZVVTM4dDRxbXczZEtVQWVrVnFiS0FhbWtjV2g5SFJaWGdXNE5wWlU2RzdZUkhpM3ViOHRJbnJrcHR3RDNKd21HMEQySElSZzJqUkg1SVA2NXZwaUw3RXdaQnlnNVhpNm1FNlFUYWNLNnFQMm9yUFpnSHV3TmRDRnNlMmt4VjB4dHNCMnlOMkVydlJ2ZXZrdWF6UXI1akZ5UDZBcjhiK1cwYXpDa3FvNG5GbzZOS1QvYjJvOWtJOWJzOHI4d3FGaW5xUnhFT1V5eVNGOHE5S2pTWjlZN1NuK3VvQmhFQXl6ZDhYZHNvWWdDL2tVUVAzZVNvUWpzZ1BPYVUrWjlSa2JUSVpseS9zZ2hUTytBOVVxR2dUNjhsL0E1Z3pLUFFZSld4dTZrUjd1UW9CQ1UzR1kxTE00L1NKVHVPWFN1alJXa3l6RVJ4emhpYmE2SlpLYTdxcWVYcW5HdUJPdVlEVVptaW96UEV3Z0NSbnJkTUJKbDFwRG5kR05MUW13R1JEaEtQK21pdlF5Y0x4TkloQ2JRaXB5alo2N0J3aU05RjhybHljRnZyaEJmSTdpNnpBZVBZWkl5UXJWUXllNGdsTHNhUTBNYVJNS3FFL1d0OEhFY0Voekt3RGJDS0hQUnpCc0p5c215SW9FeE93M0NpMDJ6ZlpHUW02QUdRa0xYZk9KR3U2aWRBNWZSRWNRRXVWTXhBWUd3L1RwRFRrUE5nZVZBRUxZakdwR0hWM2h6enRIcW9Vb25nckd0WVNVaUpSR0lVZUpRUWMwZ1lxbTNoQ1ZMMTlYTmVOejdEMEJtN0FCYUx6UGpkcDB1Sml3a0ZVWVRobncxUWVqSmVSZTZyK2hnZFF4Qy96YzczSVRINTFCWm01UGtKRlJZT1NaRXcxT0xMTDc4TUVQVDNEa0JYZ1p2cW1WU05tWjJkNFJwVE5QTFVMcVp6UlBES2lDTDd5UUt3bDlvYVVicVlwM1k1b0RRL3lUNHdlSm9LdER0RTFST2dhbVdHU0JzQkRwUjR0U1BrNGI3U2cwekR6dGlUU0FJVjFsZGdFa3VrT3pKU1hBVFdWMUI1K2ZSMzN1UUg5MmN0K0lXbGh2RFl5OHZmK1RERDVaNFpvQ2xWY1VzL0h0ZnhHTXBrOFl3RHFIeUdiUitEL3NhaE5jTWg4andmQTliSGxPTnQ4bk50NHpEOTlQOThRZ1VLYkRQRXp0WExMV2lSWGdGSEpQSml6OUZNb2VmMkhBK3B6TU5Vank0SDBVT2xPaU90dVV4ZFRCVHVoYU9YcVJqR1lBSjBJMVE3MTFaanZBcUtINUZ1UE1MWlE1cTZmTmhseGlESnlHZEZ5cGQrUEtEU0xYSmRtQnp5SE1SUkpPbzZpZGNMYzNQcDVzdnl4d2RIVyt3cERvU0dESVB6YUp5ZW1RaTQvdmYzN1FVSUdPQkJkUkNTbzJFM25sZWwraUVlT2hrWGxZK1prd0NTalM2QU5tZzMweHowMkdrdkszRmRBVG1YbndhNGJDQWlnMnFrdDI3UkptNXFOdlVZZTRYZzJoS2VTa0ZMQUxjNlE0dUd0WDNtbzRTcWRCb1ZWZHhyYm1jZE84K1JERlBod3JPaHB1TDZPQjVCU2VEU3ZoVmxlbGhCMjRWbFI0dXdEUmk5NWczUENpdGxOYWg0VHp0cjhSOThoNHg5RVB3QzBEckZpSERDb1RocDRMSkUxRzAweVFablVoMFdwSXRkbzR1T3JYcGhseFFUT0wyNWlkTnhhQm5qQ3dJNm84WVZBOGdScUZpUzZCbWtmYzlFWSt2c3pFNmhsb0QrZGFvcGpzSXBLa2dKMWpRdlFWVFFNNGNCd3h1SnZ4NE0yN3ZMYWNQckNDaUk4TjR6V29BcGNzWnBRRExrUG5ZVE1ValZPREJ6cUlRTUFjNmdOWGZXaFk3eE1oN3pudHpHT05Sc2x1cU5ZUHhiTG9oMHdjVkVKUllOb21TK0lVMXdmMUhLK1dZSFFBNlZFYkhYdWlUWXNMOXhINlVmTjhzRDRPOCtsR0FjaDQ5NDN6WGtzejZVbkF5Um1KbnBwQnMzck9pQVlSWVE4M2tDc1Z4UVQrb0lJRE1OeVpaa1Q1OCtDd2xNNHBpbUpwYmZuWVB3QlVUdkl3RjQ5dkljRnJQOWh3U3ZXbVN4VFUrL0lhRVJldkprSkQzbTJvZGhkSkE0dGNQa21ML1Nhd1FCQTFKbDFnZ3RCQThoQkM1NE0zekJ4UjF3ZFdVTWdUUzhMbkJwWHZBei92UnovblRwK0lFYXhtc3ZQeWNEOWoyWEpsUkczK2R2Y0NUa0JvYWJmWlliU1FjQ1pSVndzYVpaQ3p2RkJaNnNIbWt2UFpoYkE4L2ZSNTk5bWU1Y3YwSGpVOElZc0hzZDdYOGRIdXpZUTJ4TmRoOGZBc1lkOWxyNVF6Vk1acWk1UVVibm9RdTlnRDF4ejl5WHNGZVJJK2djbGF4OGhGdUQzek42WWw0aFdic0l2TWZ2NGNIRllLeHRWcHBTN2NwS0xFSHYycGt3b0ZjSWR5aHcySzJGTmFZTms3Mi9UdUsvWjZLR2htS1BTczB0aWw5TWtXUnZPanR2UHFlSkt1V091TGY3NlhFdUVxdVdnWmFnN1Bsd0ZDd296RW5BMVNibVhESm1EQWdUVzZXSndhQk1RY3NjUTM4S1BBb1I4K1FWWGx0YVNhOFR1elpDaG9oaEVBMUFEQVdWTXd4TkVwL1lKbjVRd25hdldxNFJhcW5TajFEczZnejRuUDBtOVpLYWQzdkpQS1huY0J3NVF1aElBRmNDMVdtaDNTNENzWjB2aEtGVUhDWWcxRVdQdW52VVFUZ3FyczZRRXppRC9RVjdTWmZKdHdHbU5ydHpBWnJidVVOUkdReGo0eEVYVDZ5RGJXSW40RVo2akhvNGU4N2t1UWxvMm9IUWgxekQ4NWZuaG1Xa044c1luMkN2dVloRFFKd04zV3BOVzhtYWhTSjlqSnd5TWNSOE5rZ1ZEajVCd3dxSzBtTzByTUJXUjFBOUJUU05kelhVenhIY242Tmt3VXYwSTNBSFZUUDE5ektJWEdNUnZiWkdZVStRNXFzQmkyR2RJQlROakROeUQrc2NoZTBBemlEU2h5ckZIQ1N1REd4QWVTVTZqUHNsTmxmSnlzT2w2TXBWSUh3MkhjNW5DUktCa2F1RkZNT2w0eUZ4U015UmtzQmFXdVhDdnlXY1M3REszbGY5WmRkNVhIcVpmTjJlaFVicEN6cStyaFFWUVlSY1Z5bkxVSXE5dmIwZ1FpdDRXcEo0ZDIrWHVreFBLZW03eHVHZ1pqakVQemxKdGo4dThRWWRlcWNJQmdSQytSc0NwMXVzNlJaZDdEOEY3SE5GcEJVTm5nWHo0U1FxRTdJOUROb01GSE1JL0ZzbWptYUV2RE5WRUVHNER4SzV6NDRYV3VNNlBOa1RRVVlRQWlQajNBaUtMb3RMRlRQMUxQRTdaNWo3U1loZXkrdElNNnd4ZjBzUDhENW9LZnVPMzR2ZUpuNkcxK3U4TUZkc3A2djg3TkRhdm8xa2NONmpFdzROUnU5L3VVNU5xdFV3OU1LL1VnL0RyZVdXYldxUU1UcnRvYWp2am9tQlp1bGI3S2NIaTNWM29KRzlvRmVRdjdOd0UzVlM5elRiVjhNZG1IM01YL1ZQYzRRTXpFZElCWUM4eWNYWmhGa3NLRWZRTWhYTXN0dGoyREt0d1YraWtONUlCQ0lUc1U4U3RLM2VJbWFMY3RJZHBGNmxiVHRTZHhFa0hqMThsSjQ5MlVQcUFraTVjRFJ4NEhwRnNpRXk1cWxxQ29YQ1VHWElPZ29Ldkg5cHBwQTVxZ0hZQ2FzQWFGcDBNWXpiaG1Qd3RQSHNPSXh1QkR2WGRUb0pYWmtxcFNiZGZBNm9sTUJ4Q1hBMXhFbGdWd2l3d2F1cW4yQmtOb1pBbEowZjFwbURaeGdFaTQ0MFNCVUdZaGo5SG9zYnIvbDZxSTk4eHJBUUgybzRHYVg0TzZZTlBxOGpxS2YwQ0lIcGROSnVYZXdUcThOckhFSlZGekNkdzJXd1pRMnhZNEowQUFsU28zcVJEZXpCbVFjUVI0Y2d2dFBtUkJpTlQ5R3pML0NBbkZwSWp0QisrK0ZaV0k4emx0NTc5eHFIbm5JV2h0dmp2a1ZRZ01QanhhTlYyQW1MWWNjWGhrTlJOZHk3Wnh4NnhqSEFVMW1qK2NTYmQvRmlEWkVvVkFNeEJ1cGhDUTdJdU14SHpGckFBMVJzemlnNWYrTndpaGtBWnh5LzZDaHVXYXNsbElsOTBSNldDZTBlTEQwKzJtQXlUbFRHMkpwbjQ0QXFYaFBaT1cycWZpeGlBVjNITldldkdJZjJEOFhZN0tEWk5EVGp2bTZBSDJEOU9LMUJNTnhOYVM0NFdyd3B3TG1oR1VkMlBYMUk4SEsxckNKRUpvVmR2cWVkenQ5OWVoKy82NGFYdU1jb01WMGpJM01Ba2hVMEpWQS9pMHBCM1hEdmFTVUdwYkN0clYyNjBXekZhM3Q3T3dBV1JlNm02SDlJN0pjSHNZMjl6TkZMN0tZSEdiaG5yYkM4bm1LNFhvYzl0ZVRlQUoxc2t2ZFhLR1ZTeFVhb0UwV0FFWFZNMTVDYS9TRklDVmd5RXYvMkkveUllL2lMd09UcjhYajV2c0RsR210dndvY1FuMzk1NmZpK3RtS3JsU3B4S1RUN1dlOGhPNm9SbTdWTU1HZ0xZKzhKK1hvWGVBKzdKS0N2cmUvUURackNkaGptbTR3ZGF3N3p4UnZLUGdkcWNvTXlheWFUaTZCbURyaWdKVk1Lc0hKbjRyMlhZK1Z2RStIdHJSbTJTdjUyM1FXeUFDbXVxd2xDcVNyb2lqdUdPcTJvNldUOEh4TjNyc0UyamVsQXh3bHZvUGZCeTljaFY3REh2dVpKVXU5aWxENDgyeU9ZZEFNVjdCd2dtNkgyMTM3Ni9MUDdVWUhDT21sNjN3VDNJaEp2QVE5bEdlbkc4ajhqeFAyWjQyc3hQcG1Od09VR0dNenEyS1NWQ3VOU0xJRElNYTlBVnc0Uk1HdVJybGFpdHRzMDJvMnBZdWNJSkx2Yzl3VEdhU0ZOSFZsV094MmhGNktoSGxack9LY2Nkd3RQcGZhdVBCNFNhVmtiZG83a2RVK1ZaODk1cTJWRmREeXZDVlF5Y2dFT1N2TFdmTlpnWmZkREF1RnNJN3FGVmlXZGNBRnB5cWNCNmNVT0VsU09EeGk5cWtGUWQ2S2RNd3pzckRIaHRnUGlYeUYzSHRKRzFIQm5zSFBZcHZxVXN4MVFNY0NKR3hIZXdnRFp3RC9kNFRDTUVkRzdNSSs0Q2RHVUxDSEN3SzJXbUVNUzBudHlZcUY4Vk04MjMra1E3SFpCVElvUzJ3VTVSNVBFaEx6L3poS3BDSE9BbjZJNjE4ZVFvWkc2Q2FvZGNVMEVBV3c4UFRxYUhLWlB2dHFOVFNnVHhhMk54OWdhUFhkeWhDcWVvSmtKRGgvdkNSQWpuQUs5SmhZYVl3c0M2R3hJS3M5a05UbWdMQ1Jjb1UrTkhvMkZQY0ExSXYrVnFsaGNXOFpycUk4TkFkd0ZGdzJFWlRaSmczQWZ1NTdYMGJka1pEcFF4RnJ5T1M1dmtxcmNXWW1NQWZNM2txM0dSRVRuZUluM3l2eHVOMTNIcW50YWtTVnNTMXpBQXhLQmcyNGVYRm9pbFBDdFFxRzlRSUs4dnJwTVZRTU10czFybEpXeHp2c0plMEVvd1A1UjJsamZRcVVnVWg5cW40RG9OUFFxeGlneEdrY1RFY1dNdmNtMU9xWjd3RUh6ck1jRTlESEN2RTlCRDVoZlNENVNHcWJLeUEwMHZiZk9mREF4d09nOG1Ld0R2OHM4dVJ4QUY5UHczQVptOElOckl5R3pESG9XdVRVU1NmYWFkaTBXS0VDTWJVN3dIRUNhdldZcEZKUThxRnJsS1gzRmVOa2YxSVFkak0xN3hNMjFPUVF2RG8vVDArMzl0TFczVFFKdGhvSjZyZlNxS3NGclAxRkZOdGROMjJkbWVIZHRvUUJCaDNzS1FBSGsvTXlDSC9rZUZCSjJTOVlZVW8vUEsxbkZlSmhMaVlNVmtlQ01NZXd6MEt5TVQ3VW5EcUpuaE9UOGdjRElvcGhSWUtpQUVwQzJ6aUcwZjNKdUU5OHptbGw4VGgydHZiaTN1WFhiT3pUQklLRDBnZzQ0UUE2a2swbnNlWnV0QkdCaHJ3TzByRzZROExKVmlKVXoyMEw2ZHg0TW1lM1NLUVQ0Y2wvbm5HZkJQVnZ1aFhaZHBhVXVuWHJ5cEh6MUtDbHVsWkhEdlgzV2dqQUs4aDR0VURBNU04dUhvVzBZdXpiQVBveENHNS8yMlQ0MHEyZmZOYkRmb2JEb2U5cURwVzFJblhzb0pZRXovSzBLNkRqVWJsVDlwR2RwUldhUlI5c3ljdDVIMks2NW45ZVQxcVBxU1EvOTM4TmswcUtMWUFVR0kzWUxMUHFsanF5djJjM3oxT2ExaDJDaml0Z3Q3bEpUWkVNRWJpR2VEb2pua0F2YWZpaUh0OFBQdEFqNkc3QXBVM3hPM2R0NGtaa3A4SFdDSjk4UkJGeFZlNzExdXFUUXNMQ2phUU11eW1HQ0VBeFpnTjJuSElZVWZYUTJTY2pSaHF0RFdza2pnZ0lmc0tEbnVONlBPTUFuSjlwaEdHc2IrZUNjU0ZvQkQ3RFY4S3BqUURWUjk2eDJqU0VMTWNhbTJpR2x5TGhHa056cUxGYVZ1WlNSc0VUNkd1c3hSa2tDZm1XUk1VQVN0MUpremdQaVUwWUFScVVuZGZVSzlaWjA3eHEzb21mSHlxdVFEMU5CZllXckdqaXJhdWhXNmdHMTNLdEVJUWRSWEJjeVZUODlqSEpydnNGTTNRdDFmVjVrVFFaSXVhck1sOStSMHhzUmIwNWlScGlad1ZWaW1KZ2txSTg4dEZsRTNkV3JWNG5oZ1RrZ0RkOG5EdXlUano5Smh5OTJJdVJDbGJzQWdlVTExREpPdzFZZ1Q3TDRJV2g2UitJZlk5K3BaNFZxZGNSK2RBUks0bDlDeXVBMXpKRnBsSFdzb1NHUXk1d29QSkRJa0Frd1kybkRLTTgyQnpnSlpCSXVzNEZJK1I4MHFXUW1FRW1lNG1kbzh5OEpYS0JUU0lCY0F1RGdDd0ZzRkh1bDRCdlg5QnFtOC9EdHpjNHhzVmtZaHZGMlBYajhOSDMxK0VFNkJMQkxyanRnRWM0U2Zwb2xJZFB3RUxudWx5cDV2QUJOZUlROUhQQnk5a0VKV0sxRDZUczdRTnd4SGpwemxCeFlhdGFNWGVYdlM0blluMHJrUmVoWll6dnd4T1c5bHlESm9GbFBwWlRvYnNUUFVSQjVmd0xUQ0dFSnh6Q1U3ZTBUTkJWWGlVYW9GUGc3d0hHZ1I5dE1DOVg2SEdQeTFEcytiV0dDbFZLNHRtakx2aGkvcEtybzRUYytVTVlXQU94WllqMXRTaXp6MEFtaHVXV0VtSkVoTmR0a1VFMDhtN3NuckNpNXBkZ1NJaWJUYXJrMVRERmlyZEtSKzZHa2IzbHl5Skt4S1RGS3ExSjNwbUZrOW1iVVJMaVIwcXMwYVdxUm5LeUlXZUl5aUx6UEhEVFB5TjNjaTVCU1diOFlMNitaUnBibGV6cDNhRlBVZGJMOHpvSVFiby9lWmc4eXM2ZU5oYWhSSHpxTVlTQ2xnT1ZHNXJGMVJQU3BxTWMvZGNxK2xHaWZRYVFLUmV3T2h0d3lLSzdhcDVFUXN4d2d4dUhpOXdGU1hkaG5HTkFRa2JpbnZjaDk1S2Z4SVFKbkh5c3JGYXU0bnVQenNHZmNpR05FN3BrbFpMQk41WS9UbTFjSzZlNEthUnVNNjdoSlJVVXkrbHY4N0xUUXMxbnpNMWp6b2VWS21KOWhCaGRzZ3ZxMUhPY0VGbjdhcUtTMVE0MklETitEd29iWktCSmV3L2cxTkJJTHc0RWVSYmNYeUNwNDQrcDQyRzVmbjA2M3I1SW5obkZ6UUR1dEpxRFY0Y1RscmF5QXphRkl2YW84NG50c0ROS2RSazRCYTRBOWJZREVwZnBZd2s0bk4zZTlYRm1yT2tUaU5QZk1VbUt5dzJONVhyMmNmSkFCZWw2OEZ2dkJHWkxSQ0pnKzVOYkc3V1RWSzJ4d2tZRWZIMkxjbEREQnN4akhCNC9NMXZvNjVYSHB4MGZEMHZCZWNiQ3NWRm5FcHNXMFlUWnlNNmdiTytFNVFNWk9wZEk0elZmaFJuMUEzVEVVRWFtNklNd0plNmpvVlVKOUgyTmRxWmdUY1ZVVC9tUmZaL2c0L0NsTk1IYUxFa2t5RXIxNzRyRms2K1JIMU5yaWYweVR0ME9LeWZhRFN5TmRJVERIZkhnYkppZno0Ryt1dmN4YURVSExKeWZsZE5qQkhZL0VmM1NFZW9QcXUzTDFDbElOUmwyZW1hcksySkc2Tk9xNlZ0dytOQU4rUUE4NmpKQ3VlVDBETWUrRUk0aUVSOGd4YURDK3dCd0VNSlhOQUNqc3JKbVhPUU8vUzlXTFpnR3BRUFZkN1dVOTFrOG85TUNyaHZyYTJUa0huLzB2azhnK3d2aExkQmF5aEhRYlEva2hVbUtMRUF2VkowTWp6R1l3b05YU1I2TjBRN0psbWdHY1ZjNW1HY0FUbUxRVDdWUHZ6Tlp4T3A0OFM5cVAydXlKcGc2bGFrMEJIWnNTYzAzTFBTa0oyaTI2VGpYUFpRb1JMbEpTWnRSWUw4N3hzOTJkMUtZVXp6aDI0dzQ1aTMwRWxBNEo1cGJZOXVtaVZOUms4RkE3WjljdksxV2tYVXRQWkJadTQ5aWtsYmcvZEpwcEtIZy9sWnFnWGUxZWZzUVlTbTIzWGtlNmRRL1VNRW80aFNUOUFiOTdSb29IaHdjQWtpSVpOK0hHSVdYeFpyZ3ZRWEtMd3F0eWFPY1FzSXliME1obWdxSnVkRGRDN21MQW9xSjIxR0ptVXlPUURuS01zaFFhTjdFcE5aRUUzR1RSdGcvSDBmQ2JDOCtqdVZjTTBBMkdDNFJCTmphS3VjWkI5NVFxUFVnNUFJbUp4ZHd6SXR2Wm1DSW5UT2tNWm9NWG40MmhmSWZjUXdOamw5Q01GcTI0WGFpbXBWZEowNEcwZ21NVGJvTXFpaU1CQUQwR29NK1FRRHBJR0twcFZwbU1NaUVjbGdzN3ZtQ2Y4K1JZT3lpSE5QWms0eXc5b3FEY09IclJGSnM4T1FXWUVYTTJSU1VIY0ExT3pvWkFxQnBINVNCS25SS3Voa1A0alZRZlR6MDBibWFVNHVGMWdTZzJrczNVNEo3WnZqeXNCamg2eE54b3JzQW1GNDIwZEZqc2d3U3NzVmhDMGFOeUdWUWEyZnFBaUdPdzhvTk1iZ2FWbTFCV09Ic3hTaWFyT2pZdVVORkpZaVViazcwZy9ZajlrRE5hdjcyQmFGOG5rTGlJY1ZibW93VG9QWTFRaHNaU0E1dUpyMXRmeXlZVzFIM2dyR09MVkoxa1RDZUF5d0xqUlFoTzAvekUxZ3dBOGdTdEdGSndlL0FsMUUxdUs3NEdHUE1qRHJtNGlmL0R6TEVzemt0cTREVmhHbDdOUVR4SjF5Z3ZmSThOcFM5dTlFSmNvV1BNTUhjMTFIc3JWeUtUazVTTG1oOVpFdEFGNnlRdEdwdWt1dWlodTRERHRRRmVjL1FpZGdpVFFDVHpRZzk2VjMwNGI5ZjhVcUt3ZExDcXBWS1owODZZRDJza2M5THV5WGUwZ1FxK3NlOWVCSnJtQy94a1hHQzlUaTFiek9Xd0EzbmVtcGhGN01sWmhaNG1wOGhKaFVucVJIR1BIVWVXaksvS3p1OUUxdXNoRDg4YWpWcEhPWU9UOUg0Y1JXcFN1cEl4NjJYZUJZRHNhZGxESzZsZ29xbFFNRkZUak43eDQxQTE2UklGZmQ2ZWVBWDZvQTBac1ZqUHFHaWhpUVpGTDJqUGhxOERBMXVwN0tBRHpKQU14M1FKV1BWNnhpd0ZUUk94OVZKbUdSOHY3Y25hU0tFbnBYTXJ3TGdFNFlnU1E1aC9WQkZXZ0FybWdRU0xST29aZCszRUZ0NGdsMUE5M3k4UzF1Q1dkSmxBSCtEZ283Z1JFUk01NUVLY0VlSlc4clNJVjRYT0l6YVdFRDA5R05xTFBGZ2xjclIwK1hhWW1ERThZY1JHQjdhWG5vZFExUFJBR2hJaDBiTk4vTVRteE8rRE9NanBGcTRzQUFCQUFFbEVRVlFjS2paVG9MRGZvS053d3pNRHFlOHhLZzczT2VKWUdQSWsyV0JiR1BKWi9JNVV6THo4amg2dlBFYVN2TW5BQTNyMUVSc3k2aGpzN0tIb0NmblVjRGRaODZtRnF0TzJjek9iYVUrOXBvREZzaGluWWdUdXVTRWZZVy9UczBaeE1Ub0pRZGZZU3hwcERZZkJrTGdWQS9ia3V5UFlpeVlvcWo5TitJWnBFVXNVYTV0R0lqT1Bhd1F1cVdSb3RMUEtIWmlzaUF0eE0yWmVsNk82cGhaaXN6R0dIRER6dnZnQm1ZVkx4dHhmYnJvcWdwSkNTR21jOGlqTjhWSWFaYlg0SjRkK3VlN3VKNUtWVWRDUWNQd2NJVzV1ZnQ3NjhXVG1Fekpob09JWkJtczVaWTZ3Z1p5U0ZQczZFREg0RzRVM09HT0pkY3k2YkNNcHd5WHFoZ3N3ZTFOZlJCL0RJYVFsQ3k4ZVVWZitER2EyQTUzTk1QNEZ5TWx5TWxjNDk1UDhIUklYbitWY1lUWUFoSGhOTlZFaTFRTXRQc2lCcFJZdnlxVjErRkhCQVltTWw3U2J5ZUZHa1RhTTlWbGFYb2dhNjJYR095QklWSnF4OWJzNWI1b24xQ0trd2Jnb2F5T0ZLZC95QXA1eGdBS2JRWUFZTjQ4NEl2WklqNjJjWHdCM1RqSUZENk92dDlGbkJRSVBXWmEwRE8zZ0ZXZFhjRjRJTHU2aEI5T0pBQ0F3V1BlWjI3TG5nRGhnMmdLRVJza3pWWEF4MFhjY3dMREYvZGk0WlduS1pEOG9HUk12aWNybkFwalNOVE5ENWdTQ2hMMFczYmNHOUdsd3NlM3A5M0c2TkRDSkdIaThzTENJaC9rYTlFZU5ldFM4OWQzVGFJaGhLZTFycTRzUnkyY28wamxWTERwNGs3ZDNqdUpNVDgrc3BMUFo3WFIyc0ptdEljMW15aGpqOHhhamRBNHdKcXRQR0s0aHphcXBWZUZFZmNKbEdrWVFFT3pkQVBTc0htS3VZd0ZKMkRweGJsY3N0ei9ZQjJuRjBBWTFHeU1OSlBMQWpaZnZDN2djOGxndnY0amRrRmJRM0R3V2xJTWNWbmwwZVZtWTBwUm9MdGhJT0NkSFZ1N011SVdHUWcrTFR5VUJCejFheHBhQkhxNFJ6M3R6WE9Md0tabVZsYWpZT1FjWjNKVWQ4eDlmanpRRVVmZlNsaFV2aGh6SVdPUEI5Zml1M3cra3hWZ1NSY1Y0TDJwSjYxYmxRSXkrL0U1ZVVFQ1A5OGk2dURrVGxxbG9VR1V4bEVKOEtCa1dBTEVlNVV1TWxoYzR3OWlLRkRGTmJwVzJITUhRdzlwbWJBYlZGUUczQWNUZjYrTU1BTkFpdUJYSnB5MEg1dU5LWW1lbk5uUTRTNXQ3cC93a01CUDFzSTduMHR5dVdXS2xwc1l6WS9jMFNiWXpsQnhWb2pCZXJjUWNnR3FrRmlRcDdGK2hoZ05zY21IeHdycENxc1lWd0VxRHBHdmhVMGxYNzR3eit1c0hnL0ZFeE5QNStwNzc2S0ZoNElDV0RUaWlXQ0J2ZVJCTmg3QzdqNjI1YkJ2ZTREQVdJQmE5clRrNGZSNVJ5cXVZSldCc2pZWlhuUnRLUTR5SThCT2FTd2p5TEl3TkhnclFSOW1FWGJvbEtabWVteGhPTGY5dHVPOFlhdnN0Sk5lYjBQNFV3OFR4bEVuVkRvOTdRRDR4Y24vbmRtNWhrQVFZRlpJcWdrdW9oZElPeXhQVkRJNHVXTmRwaWhoaUQ5cDQrbldvczBXNkhXdDQxbzdWZ2xQWE1SeG5JUWhjQjFUVVBTODlxb3BBR2pBMmF0WURmbGJOQ0VHSzlaYmU0M3l3RjZyZWNjajRzRklOZjJDZkJkR2dhQUhOZ3hiU0FmTzNjMUdMdlQrbmpwVXQxNnpDb09SeEFXMjBLWGtzVXk1dzREMDdBc3VFdGNuNDIvT25xaFV4Y0RpM2JGdldJK05BYmNid25CSTBDRkVHVUdrakcyTjlyMXk3d2h5cy9NRzZjRjdQdUtleGVpZGtVT3lqWG1xT01QemwydlViNmZZN2FCeG9EdysrV0V2UHNZOEpjRXRYRnRKYnI3K0RDY1htckNjVVF0eW5sMkV0TFMvZFN1dVVLaG9RNytiUjZnSFNEY1kvWUQ5bHptMHpSUml2YzlCV3BTTkxxVlZQcFdFUG85aWNQU1BuVkV1MWdLUVI5SmRkd1MycFpQeVYyaG1UQzN0dUJJQnozU3pJMmxYbExuSXh3SjhQc1JZd2Q0blZyT2djaTIzSkRjRmY2bENGR0dxaDQwc29ORWdIcW9WeUI2aEZ3dmZDY2cwNU54eFU0bW9SaGF3YVZFWXh0bXdFdTQ4eEhxTWVSR1B3cFpQenBqNTYvSFJ5ZlE1Y253MjBHbUZYWVBUZVVHeW9OVkttRHdoRHZWdlFZbmtBRnJ3TGlPMTZNbG5ORUpPVndyZ1puM1V6R1RlQXEzM0ZGdTFaNm9BUitFaHlqTlVUNElMNy95WnpqRTRnU0hsZWpoV1dOL0k1QXRjMENESm4zYmFUY0xLaXAxTUpSU01QQnZvQlZSMHpieUNnd1R4dEoxYWt6YjNWQkd6anRMUGJTTC80ZEM4OU9lUWVOQ0xJcjU5d2VQQzJ3aGdxdEV1djQ3MGNRUzBiQXlCblo4YlRCSjF2eG5BZ3pDTUtUeXZoc0JaR21mZmdVa085ai95dGhCbHBTbm9xV1dLWmlRbm5BNGc3ZzJJWDdPVnZ6RWZwTld0WXlYb3BqamdGUDhML1pCS201ckRZRUtRU0FhSS9oOUkyVFJYdUU3MFhPVmcxd0RXenI4R2tPQkJLRC81anE3a0k5a0pVR2ZBUHprOTJBTkphSHVCV3NyUHR1amE1UHFZRlh5L1NCekVQNSswZ2RUMUQxVGhDblpsaC9FdGNaNW1oelVsT2dyTS9vRk9FTys2bGRNTC8rRVZ5Z0lUaWZUVHVzR1AxTVFIc0VzNndTUXpXRWRMUnlhUEhhVThUQVFlb1c4TkZqL1FmM2p3dUZtVmZBQ2ZwWGNuQU10aDZZNjJpRVVHT2tFOE5ZN0plVy9jK1dxVWp0UW5NMmg4aFE3WkFOVS9KaWZrSzJEQVBqZTdTVHBZckNQT0RnWnhoUWhoeVdQWGNhUTgreDl0MzRSTXZvS0VBZmxZRHVkK0xMc2pzaFY3eUZxM0VuTGRWYjYwZ1lSRThVNFVzWW1jQ2RVaDkzRnRWck1nOHlydG1UdURCbTVoR0twc0xkVzc1eW5La2Jka3J3Wmk5UThEcmdHS1ViU1RzcWNWYXVyRjZNLzN1Nzc1Tnc5MjdsSXQrU0FqRnM3VFczVW0zYnJ5YXZuSHRHMmxyNDBWNjl2Z2U1WlFKYVpsWlRLY0hTSkNjUHdVTXo2eVN2NzB5VDZobnJ5WldvL09Uak1IMWNJMGtodW9ZWjRMNEY3MnhlbTg5ZHlVRWhBcTBvclRWcGdKSGhiMVRLdFZMcjhOSk01VEFMeUN5QkZ4YnJjR1RtajJzVmxHMHhuUVJLU3VVTDZqQnRrRmV4SUVKU3BrK24za0E1Sm9lRWg4Q25XQWx4eEc0dEV1RldnQlZoUWpPZ3JiZ3FpVkE4SmkwRXE4bElUaWhTeTdsQWhnUXByY2tFamc1SkVvTnFvNE5EcVR4STZxYmdsdzJIbFJXT1J0ams1REQyd01CaFMyTWc1blZwbjlwZStGOXIrbjNva1F6MzJBZCtGdncxQWdKTWJEb2tCN0w0aWxnWUV3dURqZmdFS0VLWEpNUDhFUTZBY2xOd3BaNGpjc0p1NUh2djN6a21iZWRyMVAzSUdyNDFCR1BaNmc5dmpMekNnMFg2R2xIN2FPVE05enY5S2k3Z05PZVFyeDdCT0gyVDR6Wk1qaDNMemk5aGQwbUdmY01Sdkk2d0hFRm8rYjhCT29CMmNHVkVhUTcvdW5hTFJLSHhIRkI0dUlhL0hhQnBDZUhCNUpoR3V3TFQvUC9MSThiNWFFQjJENTcxTlBnenhva1FnRUdCZUt0bUp1a2FBVlltOXFheGlOZ1p4VTdRQTI4cEVvZEFYQ3E0cWlxWUJaN3FZcXF0T20zc1FNaWxTRjdjWGp3UE1rWUZIMllsOGQ3aEQxMHo1VUFLcVFWRFpGMld5MlVRZmFqaFRwam0vWXo0dmZrNGt3N3BDMXdPMzZ5UmN3UktZcnZOaGsyVVNZaGRZMm8xZUpVMlNjTjV4TU03dHVrc1hRSWxCd1NWN2l2VTRiOTdRbVkvQlJrWkdnNmVyaDVxSWZHNy9tM1QwSExwdzZmaVBHRCtmaTNuanpyK3F0TlRPSk5WZEpGQUU5MTNQOStEazRTZEtqeDMwTU14c1Q1VU1VYVFXMkw0RWNZdFJVSHh2UkUwQnF0Q05KT1l1dHAwSEg4QUZvNG83WE95YW5NU0xzdXhuZm9xMnBxRVVuTWRRQmVNMHdaNDkySVFhWVkzTE9ZTVpnUXROZ0VCSnFBbitmb0hLQzd1TmlNR0x3Sld1Q3NYRjlKczNPemFZVmlmRHFiam8rUDB0N3VIc0hmWjhSMDNYdXBLbDVOSC83dUI4VHVyYVlIRHo5UFR6ZWVzQitKYmtXdm9nbVVxUzd5NDFURTBKL3Z6YkdWcERpeFA2cXdKa0lEdlpRWkl1cWRFS2g2ajZoNHpwU2VXNHNBMnBsOXFETUVjTEpyVkJsN1hKRkZLbUpLcXRGNHhBVG9FYlFMay9TdGZPcWVhUHFRbmhTVUl2U0IvUTZ0U2pXU3BkWVRpdGlaaWxZM3RFQ2RCQ2tYMU5ncVNDam1lVnExMldTRjVpQnE0NmdnWjVOM2ZUL3NXM3pLdjkxZ3dVRmJscUREcnd6VWEzQmpPUkEvVlVrQ2tGNFNEaU5BekFVTUNUck5kRlVtckZvS1FQa2RpVnprZGp5WDlxOGdPcTdsL2Z6Y1h3T2E2aXMyRlRsakFJbjJNcCtDVVhhdGtPNFlpR0szeEtRRW84M3M4dG9TZzJLcHFxbjNkMTUreDN0cWQ5Q21aVFZIeCtXQ0tlbEFaM3lHUDVIOHpQVUtyd1o2T1ZBZjM1dkFxbHFuS21hZjdndW13UFRnUmgzc1plMWVNZTJkNGhYUzlzWnBQS0toNWpGdHJNSVdnZkY3Wjg5S2tucWdLSmRMUmMxeG1oWE16V0FUbXh1TDFreXpxSmhUOXFVRHVOZ0JHcFZ5c3BFT3hWZGQrREVreHd5UUNYTWVYS0dvQjhleXByYTVjMHBCb1lvelYxM1NBbDRZUGlVR2R3enB4Mm9YY3M0dzRrT1E3cU4wSVdoWktNN0Q2U0V6Rit3WTQzMnhTUGRycE1NdUFLNFUxb2RyZXBoTkY5SzRIUHZIZ3RYcVU4UjJ3YWpnd24xVWx4ZmJPMUZML0FybGVHNUFtNVMyQ3UzVlVBZEMzTUtHQlo0QXppK2xMTmJkbEpVWDdOa0QwbFZPOFdBTjhHNFZBVXBYdjhmWWxSQmpqNVdLbUc4RTZmSjk2VFJlWng5OVRScnhOVEFZSUZZdHk2TEZuWmVNV1dsdHhQSXpxR3cxa0xTTXMwTzNmcDE2K0FadUNtaEtZNW9ud3FUQy9JS09XRStsaGk0R2FPbEowSlRXbWdabEFoNENWaDhKZjRodHkyN1BaV3lla1k0Q01tb3pQbUZlRmhMQWVzWDZVVitmNEd0VFlNYkg3WUpFbjRHbEs2dzkyUi9rNXpaUnR4ck5FOWFkZURTQTdQbldKalMwZzlRRnd5T0JYcFhRdEsxajZtdHRvUXJ1N1p3Um0vZGx1bkxsU2xwZFhZM2MxSzhmZjBsWDdHM29KNlc3cjY1eXJkZlRGMS84RXJLU21XQy9oUkYwOFp6WVZ3RnVUeDh6c1lKV2ZkaldISS9IdlFhd2psRSt0b0EwejFGa1hUUUhzYys4MlZLaXNob3A1NmlBYlR6V0Zocko2cmZyRVlRYmNCNTFkR2lyVlREb3RZeXU1M2NCREpySy9mTi84YzlVOHVLUU9nNVRVc3h4RWdoMGpTb3FaNEdUYmliNVFteWVST2ZDdThtWDRPTGZibzUvKzdvaTc2V0k3T3MrUEJEQnlmaXM3NFZFd0lIdy9NZUc4dDNNTHBQWng1VHVQQ2plVDVEd3A5ZjNtWUZpWmxCMnJCNGwxVlVUTVIxekpEQWpacm9vRmd3MGtqWmVaMndaUUhIc21KOFNnbVB5L280N2U4K0Y1ZkR5bW45N1B6L2pJeFBsbFFMNVBKNE5ZNWdDSHdFR2o2Z0dVVUVUcUVYeXM0a3JhNEpiV3UxWm83aHhQVkVuRytueEhIVXppMnJuOUVHNFNvaDZnZmJSK2Zkb003aEh4NUROZysyMGpTM01MSUl6SkxJS0Vla1QyUENXSjh0cFFlTStCdjFwMGp0bTU1RUlQRkJJZVdYR3BjMVFDY3Y2M3BhaTFjT25yYXhCOVBMVzB6VUE4aUFkb2k2YzBNbTR6WUU2eDM0aGNNcTVZNTZBbnBVbHRVOHQwb0lkUVp3NFdHeVZ2Z2xGRzhlbU91cTZXa05MZytzK1lSSXNGVmtPZExLR1VKVktLMHAxcktQN1pYVUoxMWpWUE9MY0FDeTlueEpnR1U5V21mRVVOamZTSW9mdUdyZFpZTW5CT2NvemN6NEFTTHJId3gxa2FuZ21PVlRIME1QM2QwdnBQKzJOcFFQYWd4bVhWOEdUYXB2empvZmVQRFJBSWpOdkdHRExoYUFqQ3hUeTllekJ1QmhFdks2a3JUVHVmb2M2enVla0gxV1dQSTZab0VXa050TnN5Z1NKV1lTeFJOczIxeUpBRHVDU2tXc1RVN3Jub3FHTzZxVnovZ1pTMnRUVzVQYjlRM3BUY3EvYUdIWSthS0tLV2xlakVhNEhQNnZQaGFlYk9WaWpxNHB0V0pPQSs1TTNHSTF4V3IzQUlPL0o2Wm5vcWo1SmFzOE0yUThDcWdYMjl1bGpxQjNMcytlNW1aK2ZBN0FXY0FqUjV4SXdlUExrU2RwKzhTS21ydjNzbGR0WHd3YTEvbmdycmE4OXhZeFRTTGRlV1U1ZmZmVUo5cTRmYzNoZnBKRVN6alJvZktqTFcybVVFQWs5SUliQ2VMWlVZVzJ1a1NNRG9lTHZxTjBsMUZZcmlkcVd6MUxPZWdPVitNTnpncmV4MXlIaEdrWnY2V1RYMm5rNVQvZk51UTVhcHBKaGc4U1VJRzBhbk1xNjhqODJ4OE5aWmRHVk1KeW9nT1ZlWmd0RlBRVWtHSTFyUHR4VVArOWlTQWlaMUNIQ1ltQW1rZE9OODhDN1dmNzBvQ3V4dUhFKy9KNkE1Y0EwYWthVU1lOTUyR1hqR2crdGJlVjFBM3k0bjBGM0doRDFqc1ZEWXVTZjQvTWVIcUFXWXFWajVzOEFMeVUrZFVGalIvUk15Z0c5dnRjMWZvWWY4YnQvWDRLVDZpTEhJcTU1Q1dLT1Y4bE51NGUxclB5ZUVlOGFXUmtHNnhKTENNZFVyWktrV0JzQXFFalVjWFJ3Wm15ZTlqNkVIelludUdDVmlnS0s4NDVYVHEvZElzOUJtQ2IyNUJacVlKZXFDcWVVTk40ajVPQTNYMnltbjMxTXVXTTRVNWRySEFKcW4yRUlyckwyRmJqd0JEYURLWUtlekFHN01sZEk4NFJhWkhXZllDcXNxZVZqOG5CS213WFk2ODI0bGl4RlFtbFNZN0ZTTVFOaFBERUg5c0tjTHM0a3IvTStTeTZ6Z2pSWVZ5WUNNT2oxVVZRM0N0cTExM2g4Um5GQXBmWlJIQTFWSkJUQjZoTHczWDhKbTI5akttQmMzTmY0dlNFMzZTTkJWTWV2cE56TVJOcDl2cFV1YVB6YWdDNVdHQkpUQTJUNERoemNzNElwaDZKOUtUMmpMTkl6YUtTaUJFRzFnUzZ4ZDhnckFEVHhiM3pZcXExcUNONVB1aE9FcEpNbTh6UTd3M0FTSlVvbHN1eWhKTTI5R0pkSFFnblU3M2FnaHdGMEhIditrbWJNbHd0NmdVRmNNbFd2SWQxN0x3MzZZVHQ3ZVU2TWpaUEc5T2lwVFFnYU5qc042VFdrUEQzUTBvUEFSdUMyVGhBRUJOZlVLcUUxK2xMV2wraXNSRzZoelN4a2pnM0t2QndlSDFMZDloQm1kaEQ1cExNejJMSUlnVEQzMUU3cWh3Q2psVDZzL21Hdno4bkpxWkMyYnR4Y3BGTjJqYXE0TDNodkc4OWhOeTNSQ20xbFpSbUpjcGllUFgxRXk2OW5kTVJlVGMvWHZ5QXRhRHNZdEtBQ1lZZkRRSWVQVVFadFc3UlpOUU5tVzBCQzFqTXZBOU16V1dYc0VhL2wrVU5kbExubkFEZ2RQQ1U2SXcycFBlLzhrTmZpbk12VU1VbENqOUFYWEQ2UHBHYVhvRkZvMjFBSkhENVFBVHBuY0VFMk01cVFRcFhXTFMrSE9vRE5BdFFMVHNWaXV1RnVsTVR0NzI2T1NacVhRQ1JnK1pDYitqbkJ6S2NIWHJYZ1VncnpNMzVIRlBVMURlTjZEank0R2hsZFpDV25FT081bDRUa1U0QlNrdkxlMmlZVXd6TUNnS0FoRWk0WlQ0bkxneElIa0ltYjM5aG50U0xtNmVYWUpTQ2YvKzhqNDZ5Q293YS9EQmlEYTdMNHJnR25LNjVacG91S1hGVXVLS2RGV21XK0dFdERJdlNhckJGQWlWSkF3YnNNMUJ5WVVkZHluT2d5MG9Id0lBQnp6eEMyVXJmQjlSZ1BzTVZFV1E5cWZGdkgybWprK3AzcHRJQngvamtkamZlUEdpU1JHMnFoelJISmxnb0VSL3REVWxJYTZSSGdOWWtFTnNFMlROTldaZ29YWEwxT0NSTytPNFVhTTZRNXd6R1N4eGxySFFYcUFJWE1lYUlYRVVBTkppWG8rcmNxcnJZZDV3UHp3aDZqYnRhSG9DMmJvb1RhWk84S1NIOTJpY24ybVBBUWJCT2hUblA4V0lXNGxqU2dldSthbnJPL09TVFJjYVYzMXNLdU1GaXBBcEh5TTNqMmlDTnFJaTNjVzM5RTRudzN2Y0s3bUgwQVozNVI4MldkVzZ6Wk9vdmVvSGZmWEdtR3UyU2Mzb1BNQ2lNRkFCekJlS1FBbnR3M1FtbVlTb3Z2V1lYRTF3eXVsSmxlVUxUT01pdk9XNUNUdnAyMmF5T0EyeWoxa2w2MXJaaE5ZVDAzamVEQnJMaVhxeFMyWEw0Ykh1ZWdqOHg3NW5yNENMc1dOQ09ZdVY3U3pnaUFYdzBiR1hUQWUxRXBnMnZZU2ZxRUdLbHo5dG9pQXZYNkpPc3dBZERNa3ZhMmpGUTlTMmpDU2dDeFoxQkFNbExlUnJDaisvUVNvRldYOFZ2THk4dHhwcDQvZjg1UHVtYy9lcFFXRnhkNUx0QzQ0MDdhM05qQWpuV1lualRXMCtMOERQWXRna0Y3eTJsdDdSRlNlNW1BMHRXMDBWekh2clVESWlOdGtsclh3UTVyT3pxZFlEYjJ0VjU5RzJlS05penRxdEk1L0l5ZlNFM2tTcExMelJ6UkxtQ2VnUWNFdi9ZeGo1VHlWSzRvRTA3RWZubU9CU3lGb2l4RUJ3REU3cWMzVW1HbFMrNGtKYVdRY09Rb1NpdHlISURBNGx1aGo3TVRtWVNoVHAxSllSSzFOM1R6L0t5UFROb1NIRVRjRHFrRjJ5L0JSZ0NCVU5nWXY1Tnhva3dhRXlqOG51SzY3K20rTmFwZThwSUxXL1h5L3dlVWNPMUNRSDVHRU1sQTAwa0tBbkxISU0wWWgrTjNQSUtha2s2b3Qzd21wRHJlRVFoOTMzOHNiWHpYNzB0MHp0RXJPWGJIWURFM3dkY0hMM0d2REx6OExMT1A4WnMzcUhxWU5XZkZCZ2puS09NMWhETERucUk2Qmh5RkJLQnQza1RPRnFrdkpwRU9BZTA4WTdUY2Jvajh4cURoZ2FRSVZTb1IyS3BIVE5YdlczZHI2VjNXck4yYndVVU1TSjBWNlk3Y1NDOE9DS09nMjBvREc0ZEF1WCtPNTR6S0dya2RHUUxCbE9SRmxvc0hGUHB2MDZicmtPQzdSaHFEV3czQ3RxSkVsVWxYMlhvR2xjV2E4ZzZBcGJqUDNEbllKcVo3MFBTdkRobEhMQ0YvMmNqVzlSYlBNNXVpSmc0TXFqQTk0NHFVYWkrWm0rdlo0WDRuN0pucVd3RXBzWWU2VTBHMTB2NWl3RzhYdGFoLzR3b1JvSVcwK2ZuRGxDZFJmcFVoa05NdVhzWjlHeEQySG9EUlFnb2gxcHNYWVdDVVV6YVZ5d1lRcmtPZjM3VXRzYmxCWnlZSVI2b1hybkpqZmh5TGV5OU5HSEpoczFxQ1IzNUxWMHFlR3F4YlNMZ1JtOGlCTXAvVnN5S3BSWjRjbjJjcWlzNzg3NlYweG5CeVJNS1cyTnQ1QUNPb0VvbEtLY3NaR0tFK1BqV09KRVFkTXlUcEttbHdWWXBnaG5jV0tWdWh3ZXFoTWtQQnkxZ3lrODQxVUZ2L1hmQmJmL1kwUFg3NmxFSi95OFNlemVNZHBOZ2pRR09NbjFMWHp0NUIydGpZQ0FsS3dOS0dkZmZ1YTlpd0xnQ25QVXJWa05oTTY3UjRiL0VHUnYwWlB2ODB2b05MTDgwQmhtbysyNXRidkRjSkRXVGprcEVHRnJEWGJDM253dk9WYVQ4RnBPMmNBZE1lVWJoS2syaCtnM2FqS2ltaWNZc1VRQm1nSlptQjZ6Z0RBeVYxSER1MkQ1ZDVaL0daMER6L09BMFVEOFFNZ3FOR0xhcUdlZ21XWkF0dEdJQzVhckFtYmdCeFFxd21IY3VGSExpZ290RmN6dXFpR0t0eUNSSUJTaXh1YkNDZmw0dTBmVEp1aWNMajMwVlY4OUJuT1UxS0prQUZTSXBnN0tlQ0NBUTBpNE5KL0tZZ3FMSkZ6aDhIeERna04xQ0E2U0R4Y1dKNFQwTzNuSkxwK1ZtTXJvSmFFKzhrVmk1K1o3RzRUeDdpZ2U0NEdCQW8xNUNMY2huY3JDd0kxQlpkUmZpOGtvVGZNMWxaeVpPUEV0VEhGOTBRcmkrZ3ExNTI4STV3OTNocW9PeGozRFh3dGNjWW5ic1hGM3hINENJR1pXWlZWTEZ2TWE4NDJLeEhyQ2YzY20xVXNReWVVeDNPUUJmeEdSRFQzdFZuVHBremdjMGtoR09FK1EwSkVaOUI1TGd4VVU1dkwwNGhkSXluUFNMNkQ0N3BiN2ZmNGRuRmhvRW5FczlidDA5TnN3aHd0SjQ0eGxpRCtZaFJxMlBZcktDVzFiQnExL1NtTWY0Q0pWdUsxc2Z5TUxMbVRKbER4eHBoUTBCaFpRL3hjdmszK3diUEI1UlpJTmJTcU80d01ndDhQTjJYS3Z1b2tkYnV5RXA0N3VzRktrd21nVE5mUWhyT21ZZFNuS3JGa0dvTEZyelQ5allDMFJlUlBISzBhdS9meG5iM2VETjkzVHBPVndDc0JYZ2E1RWNFZGtxSGhJOTB4eFpKQjJiUEdCZXl6djhsNjh5V0pNdXlzN3g5ZG8vd21PZkl5Q2t5YStqcXBrUUxyTUhBdU1PTVorSk9UOEFGejRJd0xzQXdicENFV2toQzFkV2RsV01NR2ZQb0h1SHp3UGV0blY0dEE4K0tDZy8zYy9iWncxci9HdmZhTGl0enBpOVZMUWN0RU1sdmZ4dGtnWnZXRUpvanZqN1hVcnIxWlgrWFFjUGVsLzRHMkNrOEdKZnVCMDF3TEhpQUhUOHptbjlzK0lYK1RUQzFWbmxvWURZRXJjc3JjWUlPS1I1bWpHdHBuSnllRVB5QU5yaDJrWHBUYzZ5ZCtWUlcrdXlUMjFnQU9FekU5aWdzNTZrS1lCc1JyRUZEUmdxWGNlNDNOYkVCTTEwUzhvSEp2UThBd2dOYno5Ni8vNURldnV0alBqYlNDNEIrSFNEYzNuM0dCbXFBNit5U0xUdjNtSDBQYWU4SlphS3BaTHBBdHZySlNaMFNSVmZwM2J2MzZkbmU4N1MrdlJtQjhxT0RqK240OUpJeFQ5SUdZSGpOaVQ3dDdpV085QlZ3YkJPWVlZdzZ3Um11R0NHOUttUmpueTJscFJ4L3lSM3JZRkNGTllSY21XYzFKbWltN1lueDBEUVZXNFlrcHl1a0ttV2lqUWpvSWxxWU9hR09IMWxDQUJDY2dSYW9rUk1wVXViUnRkaHlWZDdnSkZyTmdMN2VmNTFvZ0VvL1N1YkNxQ3lRSFJMUlo5cFVOcnZNZXFmckxGQ1dOblRROWVKYTgxNDBsVXlNRXp3RXFkZ3JDQzRHZHRHb2FyYjNhZzlINlY0SXpaY0VORUtkMVd6ekZYWGpDZUViSW84OEpPNk5yUUFBRGFzZkUyVUUwd25UbDJMMjlRZy9RSTFOdjlyT1NrZ24wSFBkREVBSVRFclRJRlNlYjdJcFhCVk1scC9oNUl0UEVuc0dSL3NmbWgzYXBMNm4yTlNwU09WK21kU2E2WkVaVGJUTWJxa1pPbWMrOSs3dUdnYUZ5MkJLdGNsc29ucXJwaXcydnBva2dxQmNlb2c1QzhEbWI5TVZQT25IMGk2Q2dVNTc1OVoyV1VidU41d3VjK0JUQkVvYWNPa0x0cVRzWVZyMHR5aWp5ejYyUndpaXk4OGoxVEN1Yis0SmFWOUVwWVpMVElXVEZnWGhpUEJVY1hyZVVSaHdIczJrU3VtWU9RaW9nTHF2MEZKcnJRSWtCakdjZ3dMak1SZkpXdnlodFVKWWViZEJKbHFQZ0ZLN1VrclNUYTUxZlpoRHpIQzNmSmtGNEFuYWppRDhXRktsS2huLytiMm5ZVHMrYzdxcXBrK3dsbFBTRkNxRTV4dkxHK254L1EvcGlHb0dFeE5aWWZ3TDZKVTB0M1FQVU5XaEQzMXFQQkxBcGMrWTRWRmFDRUZtWDBMb1FjdlNuVXNITm9Sd3lrblJScUpKVTJDTWRiU0NNdFZHOUM5TjZBL2lFMEVudmFEVkl0MmxIU09EMHBXSFNhZ051TFZGYzlMN0ZVSysxTm84VVdaNWRTWHFsclVmN2xsZi9Mc1NJWFJ3ejlGZUV4SXBGWXJNQnM4M0Q0eUNBcXlEMmxhNXl2b1M5YlhLYUtOeFR4bHlURWY4UmxvVnUwK2VSSDIwZVV6RGRVNjhSZ1pDODAvRHFuSDd6ZTkvZklmL2NDRnRQM21LYWJmRmllVTc0VjdSSER6RlgzVjVkUkwrcmFkUGR4bkxBaHJWWjg0Wk9FYVk5Tkltb1BYcytZdjA4ZjFicnJ0QnMycWtEVExsLy9DSEU0QjJFd0VQenlMTmpON0ZjVjlHWWFGbC9YRFpwY1E2NDRMUW4ra3NxRTBPY2FnejdkQXZOQ1JOUUY5VDVsWi9vNkJWTndrY1RWd3RqWkV3YnVhYis2ZTRVVHhTRDdJalBVcjhRWWp4ck1KLytJLy9Ib1ZUVFFaTmg0b0RKbnA1b1p1YmN5MzBERnFxOXk2SXdPVjdRY3dGREdLbW9ZaWUwVTZXV2pRY2JlWUluMzRDdytlelZ3YXJMS24xMk14ZWYzVDhadkRTbERBa25yZXMyQS9VVVd4NU9tcnJRWUF5dnBHMk9ZQ2hSdVFpZzZSRXdNTHpYWUNFMUtLVTVScWZyYzhzK3E2R2hTUnh3Nmtpd2VRNGdTWkt0U0MzTlpWTXBqV1IxVG1TRUwzR3ZDOTlGRVVJT2JRTEZrUUdtMGR5aHBuTE01d0g1eWg4Y0xiTjN6TGs3TGVnWEtMZnpwK2Z6UUJOcHE5d0pwOEpvL1BzMy9ONzU5YTUxeG1xZXUxK1Q5V2ZTSGlGV0JTTjFTaHJMRGp3dVg0VnRBYVpzODhhS1MyQlZ2eVNpU3ptOC9RWGYvWGJkUGpoZ0tPKzJFenBXcE5MVXdUOHpDT3JvZVY1OEFjRlJDaHRYVW1iSyt6VVY0M0VCempSQWNyOE03endxeG5tVjRDVnFIOC9vQnFFWTFDajBBVVFRUnMwSFUxbDUwSC9sVGxOT3FOTmQzSHpxMERDTUhraHF3RjhmYWJMTVBXOHdHZEZDSEs2YksvRzlxY1NwWUhMcEQvVSt4enRUdERqdjcyOVRmL3BZaUhkMVo5eHVBOGdEcmdLZmlKakJXSHEzdGlxWUEvVEtPUTBzeXhHNkduTTgrdzJxT0VYdEorYXVGa0RkRXNadml5Mm9HUWZxV3ZDZkJxK0QxclQzU0ZvOHh4K0RMeElYL29pSTdGVFpPVGxHdnVhSS9Ea3ZLdGQ5Y0lVeklDcDJXK1JTeXVXOENZMEprOU9yZ0thUlNvaVZLSFIyQ2pQT3FoaEdiR3ZzNWFOTDRxQTlLRXZPSDVnMlMzcTJPOXU3NFVqM2xRSWM2M09FRTVkekg2ZCtqdmJhbHhiakxNU1p3ZDhPbmdEZ04yamJiM0F3ZjRjYTZTZkRxaGMyOEwvdExyRzJZUmJtNWlObUpNSDcza21aYVM0OS9Eb0xYUU9hQkg5UXk1QUEzYWROOUJpcEl1d3B0bVBESmN3Ti9vd1kyNFl2M01WZ2tINFIvamwwM1cwMHNRRHN3bG1QQWRBTVpkQW50T0NTZjFGK09BaUtMR096cXFSVnkwUHZzMjI4aGhpajBvSnNpZUxyNm9ySU1nc1J2NEVLeGZFazEwa1NCbkp2KzJrN3dVbHdjblBCQVNmNHNBaTF3bUVsYUJsVHErUGhRY0VQR0xiTmZZNzc1dmQ2OThpYzN3RzUrVWtVQWxJd0pLWTdEZlAwejZJZ2FNOVllYkVSSEdmQ2FDOWJnc21RS3JoTUJYMVZhbjlQbktQNko4K0JpdVZTcmhxRklKZzNxeU1sTUM1cmkrdndSd3dMUUNCWUltbUIvQ1ozVXdYQXF3bVJFWnN6NE0velhOeGpoeWJoT1ZZWXhMb3AvNEw1OFRQSW5KcVc3UXpBNlBaZHpKM2lVaVNJam4yOU5HV29PV0xyQmVlaWVtZzVrRTBjUXEzbTgwdnAxcld1TUE2c1lJQXQrTW5xeEtwMU9USHNWbTZ4STNocGMxcHVudE9DZ1JWRFE0UE9lZVByUFIrUjIyUlBXbE1MYXRId2ladkFLY3g5VnZVTkhod3pFMFl6TXlEMjNVTXhEaFdHVUdtZDFVY3QrUHc4M2k1OXZydUlES3JDWmdxSWpnVU1CbUtFTHRyd1MwaFhFWm9OMnB1MWdnelQ2ZkdIajFUQ1FZY05tR3VWdklBQnZZR0tvMkhNRmYzOUZOcWRDdnBBWEEyQTN6azVrOU5TK2tDUVNkNGxSRW9JUmg0dm1aZlJKdFpQeXNmQ0JENlU2VHRBRVVCUVhVRkVKWDJwTjE4dWd6cnJaQTBxcUo3Z2Y0SlhEVEcvZVpVNVFNcnBJM2dBY1p1S29KQkl6ZURCNTlva2lzVW9hY0s2ekFQNEd4c3NCMkhXdTU1b3pKUlZwREFYUTVWUU1Lb0xpSVJXbU9lV09OQ2VUSCt6cTZMNkJwelRDWGZHOHpsNnlIbkI3SU5obHlzblNjYitLVFcwYTZXMDlrMTJlb0hKNlF2dk1jWmY4KzJzTjFJYS9qVFh6ZlR4MDhjMElxcDZQYWhKMC8yMHRkZmY1M2V2SHRMYnRoRkNNUnRVaUQ2bTF2cC9QUXoydmwxV2xsZlN3LzR4V29Bb0tkZldiSFVFbFFtZUtycHUrNEtjM25WeUo2cFFncDBUV2Q3bTNsYmVsR2hRSUNoemMwVW5udUNCRzdYMFZVMFQ3THNmSE01dG9HVm9aR1MyakwrUmplUmgwS09INDE4TG9BQk1IR0ZOZVdzajg3UzBBbXdUcjZFd1Z3SWlkREZ6Vm9ERTR0NjZvK2ZlNDN2b1lVQUtEdG9HL29ML0M3MjVURlFCK2IxTHFMdmZibjFRSWxtdTJwVE1wZjBvcW5KclRFSjVpYVppK0VEM0Z0a1dSTWwrNUNrU2YxVWNVcXlubW51VlV2VEJKWGdyRHZVeFYvREtScGN3MlJDTkRQbTkxbHNGRWh0R1p1Sk42VHMzanB2MUJ3c1U3SEFKZ1NycUZ5QWh6bEt0ZEp2RDVPMGNpY2VPVFFGaUJCbU1BS1MweUdZeVVCVGVKNzVrZ2tqZWU3TFhQbmRiTTdvS09QUGxUR2M0eG16NjZLTDdIVEFRVEExQXVSMzFhS2J5L004cTBud1dCaVArVUFybVdBWHVrdEJEY3pEY0JsQ3JNRVlYNUh2Sm96UGpQWFM2QllUcXBWVzV2Qy83TEs3bmd6eG15dVlqajJRSGoydU9Xek5NdlBIeGlTMzVqVUQ3SkdPQS93d210NGpoSVNKZ0VaZUgzQkl6eS9CaEdoQ2FocStab0xIaUZuTU56N0JDZmVvcmJoTlJRb3I0NTlRWXhaVTNIYXlRRzF6QVFJQ2lqbWRRaGZtZDZuY3VYTmlJcE1vQktEUkVvTG4yMysya3ZwbmcvVHVrck1Lejhnbkk3L0p5aGY2bTZKV0VRd3dRQnRXVUZuT1pXd2RjdWpIQ05TVTRFU1JnSVo5ODZkYWhUN1VscGpkcUZNRzRIbGZhSURNbVJVZUt0RGpMTEtuK2VNUGwwUlVUckFLcG9SZ1hYUHJRd2xraHZPZGd3RkJDY2UrUmhMbjl1NU9XbDVmQ2FmMkltUDJNRjJGWkp4Q2hTYW9WdWYyS0lXUi9UVS9hMEx3eGtSY2FaNk9CU2o0M2tOdkh6bXE3ZTd1RXRPZW9BdEh0NTFmSFBJTWdPdlpMcmxYdSttVUFwZEhCK2NVLzNPUGF5YzlmN21TdnZycXEvQ1JIWHc2QnRBK3BsZjdYNldYK3kvVDhPM2JkSHg4ekRnTFlVNE9BWmF6ODlPMDFsZ0U1UFd4NFZyaG54cVFtbXVaOVJ0aE1odTBrNlpOeDhqSG1SRTlSa0M3MlY3LzVCd0pzWEFTbjVuaUpIMDRERTNKRXNVbXQyUHU1QjJMZTVxanFQL1NYZkJ1NTZ1d3RhSEkzL3FoRTNXOHluRmFDZzhQM3d4THhoMFF0cmExa2pvbmd3b3dTcFlaTVBsYkxTR3IxS2lERUo4TFJmZnBWdFl3N0pCYWVnQ1dxSXdHb0NiaXdra2tmTTFMZjRZRXBibVdOUktKWGFBTEp5NndxbFMwQ0o4T1VFVjluOVQrS2FjYWgwTTlHdEZFcFg0OGtzbFRhcUZabUJzcTUwMVc2VFhGTU9PWVZMY0V4Rk41dGs3WGZNS3o1cHR0ZERCelRMRXd5WS8rQW9BendCS2cxTFpDVzJTczFva0tEd2VTZXg3L2c4NyticitNa3hzSEtnL1EvSEg4em9uT1ZKUG1NdVBuZkRHSlcrSUgraGdmWmhpRTRNdTVpaHdvMUFTZC9URjNQTmNvcFVUUnA5NlR6L1UvaHFRNkZBZFB3aFdVbW5tSWlCd3pnS2xxd2liUFoxNXhCSVZtNmJZcS9RQURBSHlNTm1LMTBCWDZCZ0drMGhMU0RZZHZCOU1yQ0kvc2UvT1U0SnQ0MFZ4bUpNYXVjUmxoZCtaSTBCSk1KTTVWbk1Pei9xdkpDc0NtcWRRbFFLNXpMV3piOWRVdlZJUWdYYzhzQUprUG1GWmZpT2FSV280bXVHVzN5ekJLM2ZGaHJ1cTRWZ09zNHNPcWtjbjZjZ3ZISFRrL0ZYSkNkQlgyaVNpQjdRQUd3NGFtOGJERXZPdDdjOU04anc2R1FjV0RTcUh0OE1jQVRJQjYwZTBrM0dORkJlbEU0ZVY1bXRJT2k0UkJMYldxU2RpR1dxWXJqWVdBSnUrOFN0T3VvNzR0ZWFPQTBLekRrQjBBMnIyR1d6akNqY2l0RURWY1dpVTFBZTNLREhVUE96VVIxUVdGaTZLL2xoT09iU20wWDlUOVlMVmZ4NDEyN1hNcTBGT1RQTHVKTkVxWFI4Tk5IT3NOaWhOUUhlUG1NZjMwK3pOOFdwMjB2Yk9OU2JnSFVHN3k5eW5tNlR0S0tIRXNQZjNZM242Q3liK0swLzFkZ05iMkhwOXgvU1BtNHVmano3Z3J4cEZzK2tEMi9PMzllVnBmWkszQUFRTTNIZmh0VElEQzQ3NzAzd25lK3BsVUFueUZiNDR4R0pEUUJIZi9yY0puZm40RGtNOXVFM2xnUnQvTUtFTFhlOEVJZnhRV0pKNFdXSXQ1Tkg4VFU4bkFZdDh2Q3BVSG1GbzhxNGdaZ0x5SFVLRk9pUkhFbTJCcmU3aG1DWWRqZ2NWendiVFpUWnF6SHJwTUw5TjUwb3BjcE05Sko2VE1uVmZXaVpjc2FSSTFVVFhTNzVscG5tY1lueTdTYnV3N1U3dFJaTUcwK2xCS2ZJL2c5VS9NVXA0Sk9FUW1MSlVEUEZBeFMzRzN0ckN0UjQyS05UZnNHOUU5K3F4V05rWURrOEZWSjJVU0NkRkpjbUtzWWM2bjlNSG9JMm8raTVIOVpiSWtoRWtFUzREbHB1aTd2MTBZcXhiVWtZcXF2b0xLZ0ozc2dxdlZKRDNoVnFrY2V6TjE0T29vSmQ5STMxbHNWb1VwbFNTYXQ0N1J1YU5CMGhQY3dZL0U1elBMRkJzcDBVRXJ5RGt1TjQvYlAwdWJ4RGoxSVhLOS9YUVRlQTMxZVlwUHBRdmpaRmFudGhOOWo2UE5LZjRYMmYrMFpadGR3bXRhT05ZNDg4eEIxWHJMNE5iWVlrSUlrdkZJTXByTnhHL3B2eWNYU1hpanlNb0g4SkNpZ290TTZ4NVFUVU9QVysrUy82WHpXUERTS1N1eGFjSjRXS3VNYWEzdklBU2VwOFpUSVpTdDBISHVCYmZXdmVkZld2UVF4dGVIeHh3SnZNb2VkQ2NxdXRJbi9qWk1qdktGOEVBem9WKzdhd3Y4UVlWVjlyemRFVFc3YWNIRTVDNjVYNU5FTnNBQ0dnUm8xVllpdHlkbXlMWG0yWHdXeDN0QklKNmd3NVZjSjBBQnJFSm1hSnNLWVB2TVYxb2ZyTFdsaldtQUg1WVBFRjFDVTlwZzM5NTlpNGphL1JYak5sS0lCa1NhaGpIK0ZjNlNYRnRiQ1JPd09jOStRQXBLM2x5cHZiQTFKNTZaM1NTV2lwR1A3Rk1jclliRU1DbzREODNYM1NkSkR5TXRnT0RLSEZVcHFweDlzSUN3V1ZwYXAyTERkdHJhS1ZJWmdpMVNOKzNJcS9ydzdqMkJsbHQ4VlR0b1VYdG94eE9BcTUwT1BwNkd0dlAwMlI3YTFrc09MemtDcEE3RFBIejUvQVhaN1QvaGlML2dIbXBqYmUybWsvY0hvUWtQS05VOFl1OGpnMExqTW1CRW1nZWFiWmM2WWxwWUNpWWoyMUZ5SEdEbFB5TFFlVytwZEdtNUhTZHRCRGpMVzk2alJXWGszR2gwbEc1bTNTRmNzQWZsQnN6b1F3QnR3TENONjZLRG02Q3Mwd3VQcmMxQUJBQ08vMXczbk9FRGlGSW05a0NHK0o1UExXbFJvVUVaeFhydFNpOGRCKzcvaVUyUCtqKzRUaUxpZG41b0c4bWdIeXVIZnlVRUdCWFFrdGhIc1JkTzRzMmFsWkpMQUNqNGJJaE5nZzZ0QzNrNWU1OEwyVGwwRnBKQ1pMWW5FQm1hRC9BQU9LcWVYVWMvNkFsUzNJbUNnU0F1VFN1Mm9mTzU5ZWd6U05uSDJZOTlqOUFzbXpkOXpTU25tcEIxdDkxS01vQ29CU3dleUFMRlphRXBERUxUVTNNQzZEa0dQaXA1NGo5and3bHFNU1lrSytoWWpLNXBmaHZpTGVGTGFXRXlLSldMTEE0eWxnVjAvNVFhemg5TmJ4ZFZmNXphWG5OaEtjWmhXNDdIOXBoYzVsTkNVRVVubndqZm9ORzNDUmw3VnBmUTNMdEY0N25DVDJHR3VpQS9nakd0TzI2RldRdnZpYzlSMlpUMkxDTnRUZjhxYTIxOU0vQmZSUTV4cnBhWS85RHZzRWdWMHk1MTQ1VzhTL1RQZGZSemZrVUV0VWZlVXQzOEhCZ3VpSloyYy8xdTk0N3BXMUpyZHAwTm9raWthR3lzKzRTeTFKb2dMSElRZHg5VFQ3MVcwMnlBVnRnRk9KSExqQnUvR0VCY290SkYrQ3FoNVNJYmpSY0FvSW5tcDNUSFBYWlpYNjArMmtjaWRIMVJtL2R1V25jZU5mc0VNY0VwQkpVRDhCNWVVbitVNldiSlk4Mnh4VFgxelBCZkkzOXFtV29QQmcyT1d6ZUFrZEZEdW9KUXR4aWZwdklhSnFCK1h6SHVNMEdQSGtuSEErY3hIcUhRVWkrR050ajhyQ1VqSXpzdm1kNEpOaUNRMUtvVWREVUxLVmF3QnVZZmVTNG5QUU5tYzJ5S1g5OVFvMXFuc2dZYnRkY0JMN0wvRHc4T1NVdTRScXZ1a0t1MW01N3U3cVBacFhSOGNvUy82cFM1N3BESi9wSnRPUzlKSm4yWFBoOGRvSDA5U1U5Mjk5TDdkeC9aajNpVlZuYUp1Qk9SZk1RUi8wQnlxV2sxMlNmSk9zQmpQU0tnQTh2bFNJT3NoNmN3NmVOU2VUR1plRWkrWUk5MGhnQi9NS0hNaVZocTByNDZhUElLY2s4MUdaRXBMKzFFVWpMem9lSTBCQU04ZnJESGQwTXNHTk1weWtPeXFVc1RWR3R6c0FRZk5JTlF6U0JXaWRxcWZ6cTZ6V21CMWJoR3doSkUrTTBpdTdrMXRuN3dma2dpcEJuQlNnbE5nQ2d0d2lKYjM0YWVzQWdxdG1wWi9PalRDQUpWY2FkWlFDZkM1QXhjeHVQcFNEUDZ3dWN4RjF3VHBUWFVJaUFxWHhLU2tLVGtNOXllR1FXRzRRWVhYVlZjWU5GV2RnSXR1MHpGRDE2YXZEcGhDY2VpZW1ha3o3NDZBU0JyWVQ0dis5dlVHalR2MUk3TWwrcWczY3l1RVZUb1JoQXBVNEswTWRXQWVlS3pTSTlBQ21sNjJ0YnNwYStGRllDZ1c1UmJZVTRnYnMyQ3NjQUE4THZKUEFETE5lQytHV2k2RmNnb2tybE1tdU9hbnI2Y3Y4ekkraG9GSS8wVjV1bGtkZDMwQjQ4MXQrS21qbEMxTmN1Y3FERm0zNW4zR1VCUjR3RndBYkZaYnBzQU9ETy9sYUFUVDZjQjNKd241NldKcExkQ1E0OHFDYzZ6eDFUcGxDK2gvUlJoc2lyYVdKZnZDbWg2K210cUVLZytLLzJCenZ1TU9XZnpLWkE3VHZ2bDJndlFNcTV1Z281Yk14aHJsSXdHRkI4aGVJRSs3Q0xHVW9NT21qQzNmaER6N1NnSEc3TXpnV2JOSURkWnRPYm1SQmlteTF5WVk2WFFOQkhTRGJ6NkNpM01Gd0xTTlhJUm5WM29UYkMxYjg3OVBINmxIS25qZmZpNCtwaGJON1NCeG9RUUVGalZqczFUVzZXbXZuUGtYRm5DK0k2Tno0T3BKWS9nSi9oTjN4UU9HdFpNVUZRb1FhQ00xZnRyc2I1OERpL01CU2pTQjlxc0lPU2tnMFh5L0ZiNGZJbmNydHY3RVE3eUx0ZlYwZ2I3QzNlV3R0TTNYLzh5aXZxWnlQM3U3U2NTUlR0a3hyOE9nUHA4VWtEYk9zS2sreDFPOTErazE2L1JyQUN0dzhPUGdOYlRLSVJvbmxhVklwZmJhN3VVb1huUFB0UnJOSjBXMFY2d1FrR0hGdFRyZUtDcndrL1hCdk1DZ0JvNFVmbVJYNmJNTWFMd0N3OHpMNHpOc3hFMWVhV2hXUXFUUEc2MDMvMlY2dml6YUhlZkw3clVGUnVncWFzRmwrODZQNlRxd0EyUklqakY5OGpGc2dSSnZhQ3RpWWlob1hEQTBzaUUwUGxFNXlWaGJNMFprVlM1SjNIRm9aUktKeVpYWjZvQWw4MHNnQXJOQnpMVzRLU1RtalZxQVptNVdLMWdTSW15QUtHNk4wOHR5Vk5GVVBxNEx2c0hKS0lnSVpCWGtPQlBRQUtFa0o3QzU4UkF1ZGJUb1BVZitMMFp3bXFEL3RPVThWbUdXRFZQczVabWkwd1VreWNvekxZTzZZdklSQ3N4cTFVeFVmVE5sNXN3M2JwaGYvM09sNkNpcWV2ek5WdDRDdTgxblhpeW1NdTh5RmdTZXpDbU5Fby9QUmN3cWhuQTFPRURwSXVsRUJqOHBqOHprUFA1em5HQjludU1ZNVo1N3ozUk41alhQWVcrM0hEcW5DalpiVU16MmZMSEVvaGpDS0hBZXg1UGhOQU56emxGSlRSdFpqZzBhZ1NMQUEvTUJwTXJIVTNNbGNDa1BOdjEyZjZ0S2V2QkhlNzd0QTc1QXRzc0ZIS1FhdnhURUhtSWdldHRDUnFURm8ydTJhWjk5MGZ0SSthRjk4VUFFSVdnUXZITE5kQ0QwVmxuZGdEeFJoVlJLTTFFWUpZendFenRuUWZpdTNQOGFvV3NFejZlMEZJMEtXR2tlY3lWdWhVUmNPQUtFRVpZQTdSZ0ttdFY5ZnVXZXBiKzBFejU4ZmtHZjV4UGM2NE1Dbmgyb0NEclhQcDdDQU5ma2JOMGVYbks5ZEFmdmpMTlFIUDJsampaZXhIZjNnTkFkc3RtNUQ1bTZxTUJKRGZPTTVZSnpGbWlMenI4bTJqZ1RiWlNtWmZuMnRsdjU4VzVscVliZ3BkY3plY1lKNEFDdkFGN3FtMjJTUGZRWFdBVkNQdDBNOTlOMTRzM21IaHMzMWszVVJTbk9WcW9aMWYyM3Y2WW5qemRUYytmUDJNTkM1aCtoK245eHpmcDZaT25mTGFIT1VnTzF1VjVCQVdzcFhWMWVZbTVTMm9MTkRHQkJqeWtab3BtNW53Z3dpRlVOV1krQjJ6bHFRSTVuQXlldWFDZjBPelBKWXU0Vkt0TFY1RDg3VCt0aGg2OEV3c0grS2tFWVNneVRsd04rTHl0enZESUxnZ0RjeFBNZTgzeGNuLzZmM0MwdWNoeUZ1b2NvR1UrUkpHY3JDTGxUdDNBbUJNOUFTdHM3ekpuRWs0QkxCM1BIaWRrdVl1OFJVRnBxQllHV0RDUjFpNlB5b1Q0YUZ4OHRUUnB5dmRLMkNqb0RRbE9ZRkFSMlFXaXNlaTh6Q1ZZRlNGSUpadDdpVnlRekNSTW1HREU0a1VPRUJNbkVNamMrczRZVmlTRTZ2ZGhUWU1oTytTa2lQaVFNeDNJMGxyZzFOOGtPTTNBU09LWUVTb1h4K0w3VEQvemVZS2VrUi96VTRLWmtIUVJDVVc3ODU5UkRvUUtwTmlnenl5aTcyRWF3U0NQK3dzVDBIWWNENmFmamhsenpkejNWbVF6cjVVTVpEN2J0ejgrMTdtSlBpSUVIS05BNlU4NGQvbGVLVFZrSHRSTXd3ekY1K2QwQmxoZ2poczZWN1BwNGNRMktqbFF1MEFMYy94T2k1cTB6bU5OSVJOaEJiWHdDektTREJxQ2djOEZNcUl2MmJjQzVNSHdnQmE1OWt2a29Ma0dBeXE0WnNjMWZZWkdwQS9UWlJSdGFuODVZZ3Foc3A0NnEyY3ZoWkRYeC9sMGZGaGpUZWxJK0lzVVhpb2l1Z0EwQzZ5bDNJZDQreEM1NWF6SG5BdGcyV3U5UEdydDNCYUNDcDZKOGJtRzFTOCtJSVdwdmpzbHZ5ZGRod0FDUkNMdEl0WXBqOUYrcVczVzBXUllnVmlIQUEyZTRUYXJCblJ3ZFgyWkxzNlB5RnU2UXNDU1IwYUF3TEM5WXRDa1o0SEhOVEhqM0FvTmFzMXFEeGlMOGQwS2ZpMmQ4RnRFRGswYWJsSWp5dkkyTThCU2czYmQ4WUF5Y3RaWlV3clFWTk16QmNPOXNSN0p4amVSaWYrQWYrbVJraFl0RW9XSG5TdUFrbFBDN3pZaVVmU2JiMThTaWEybHorY242ZjJIbjFqTDV6alZ0eUxROVBiOTc5UEhnM2ZwNjlmZnBmMzk1NWlISC9pK2o0bTVCWmo5bERxY1k3QkN3bXljQUkwU0krMkVmMUdyU1Q0SE5PbEVtTUV3V3F3cjJCTSthRUZjd1NjOVFoR0FUczdSazdiSC9BaGVtZGI4RGU5eVkwR1hDTmFWZ0d6bGpjaFh4TmV1dTZMc05odExueG9pNy9kUTczZzIxekhSUEtHN2hqUlVmWHRnQUtiUnMzMEJCYW1HRm1ZQ2wvNnJLSmRDUnpUM0dqZ1VmZWdzeTdsdm1RaTZLVkRWTUFsR3BPUjc0SVdxNHBoejcyTGcrcEo0b09Eam1XbVJsc0J2RnlnSzg4RThNcWVteklETVdQMG5FZnBsQnZxazg4dEFYY3diellnS0txa2dSY01ndTRnc3pVTnNJTDlSeEFsK0plaktsdW1qQU1OWXVjNnd0SXluTkowQlJHaE5BYTVvR1poVFBrZlFVZHFwMmFsZEtDRzhUalU5OXFneHVmclJTSGdLTU5kWjdSbHRFcXJBYUM1YmFDVm9OYUV1czVSdU9lZ0Q0S0VCdWFxQzFSZUFkRkVGakJnU3o5SEVoaDUrN3FQOWpiUUprWkdYMTZxaHF2WFlsR09aNFBnMWFWSUExL0V0TS9nekpsbDB4SHpvNjFLQThLaFkrRHd2UGhOR1VHSkNvS3J4L0kreFpJMU9FOXo4UFB1bkNSVUhDT0FYMG9UQm01U0JsRm11OEhjZHYxYUhEY3gwSmE4VjI2YXM0cXIveHczMldWdkZQR1IrZktaNVhXcFhwblhvTC9XWlJqaUhPdDFoRUlrZnpJVlJXV09FUVE4VnE4L25ycEh6M0lkT0h6Ry9ZdjNvZXdRdzFBNE05TkJmTS9HSEJHcnVyTUo1UmNWTTZKVXBZLzFsZk9pZVA2UzNXQU1tMGJVT0J6aTA3bkZjdnB4WFgxZFhWNWlXMXFCeXZtSGVBSFcwU0RZZGI3QXRKN1Fkbm1PcFlyVTV0U3JOeVhWS056OTVSdHJCazdXMFFHTHVIRlVMclR2V0JCeWpoaHp0Ti9GVk9lMDVpTVBpc05aVnQ3VkF1d0ZjWEtNWnRrWlUxVUNUcFltc0JHSUF4TnJ1SGczMjJMMUpoOGNjR2RhOXhjemJTV3NiYTFRYy9UWWRmdnFjam82UDBkVGI2Zm4rVHZyVnI3NWhlODloZXZ2K3AvVGkrVDRBdHhmbGt6M0UxUU43MjlSN3IxcVhuWFZqb3VGMlZncmhKVTdsdzRxSnlMS1dLaXVSTmdJUG1PUWNDZU16Mm9JWG9vSXh3cVlJZlh1ZFZsbFVxNEFYQTE4WW80ZlY2RnYycFdXQzhjNjZ3QWNJY3lzS2w0Yzk3R2NpYUZNMEhja0JZUXZCOHo5ZXNDTWdRWTRLOVhqS1BwQzlaQlhDMGY0V2lseFVRVVBmbHlEU3BSSkFEeE1raDdHTkVna29FRFcraDJxSmFBNjdzNmZzYllOSGVRRk9tSWdlbDYxdlFhYUsxQW1hZzdSNE5nREJqQ2lGWGZpSXlvR1crbi9jaUtsS3FnWmh4bkNYQkxncXFuVUphZXRyRHJYZFJFOUdUcHRBSnNRUTBVdVl5bzlEeXFKcUdpRWRvRzdLM0RtRDI3RUFVR3huOFRndWlTVDJCa29jcUxxbVBRalVIY3I3V21YQUJiTGRLaWFQbWRabWxZZG01RVNqYllaNXlQZ0Z1ekF0bURNallab0ordUVzenIrSWx1T3g3MnBxQXNPWXNZQUJ3WHc2L3dXSzBQcVlhODFqMllwdW9VSG8yRllUZzFGWk5KbVZyMXpCK0dIb01aOTVxd3pBaUcrdEMxTjN5QTh5VWM5ZC9SNFM0UHhtRTVoN3ZRbmljSTU4UmhtdExFd2NnSXN1TW5ZQkN0T1VDelNydlZwdEUrV0ZNV0pXMGJiYWJwaEtNSDBYWUpnalc5dVVBZ1dORVMvY2x4QzNma1htQWgvTUFCZUQ1eXBhMkUyTlhVREtjQ0JEc0VacXdheW5rcmVCV1ZjR3VPNDRDWHh3M3lmUmRaeXU4TjF3YmdZMGk3bWxpY3VjdVhmU2wrNkpCdUJjcXdPbUhLVWxLTWFCdnpqREJVVHBMT1lGZ0JNbzZ2UmQzNXBXWGR6UG5KdFRKWWc1SjU1enFMTTlUQnJBd3NvSGJyRUpyUkFhY1QyYVRiUW05dDNWMkx2b3NmSjMxQnZ6WGhkSDVueENqdFRlemdhYTFUelJRelMvQnZOZnAwd1F6NTQzR3g5d1ZTTzM5cFByM2hHSWkwUzcwUktOQk1lbWMrWThhdVlEN0V2UWdXa3o4eHgrRWxvNEd2V1F1bVdQblRsTXUydjhXa1l1cjlNaGdzbXFvM3ZQbjZaWCs4L1F1T3NVOGp0Tjc5OTBxWHYxTEgzNzZwZnB6Ui9lcHBQancvVHExVDVLQUtlN1F5T3JTeHZwOXVJQWF5dHIvRlA4aHZLcEFSMWZhdXQwQVhwSGgzWU8rRnkvcHk0aHJTd0ZIdDJFak1FTDVneW00M09FR2JSa0dTdnpHQlV1OHJMN2xHY0NNN2hMMmtRSktNSVhCbjRzNDExdWxEYlRrSDFMWnUrS2VEcGIzUlJzZnlvMUdLdTRGcUhta2tmejhubW92dVRzeUNSdU1sYmpFRW4xcmVoYzlpVHBQbmxKT3NEOUNTMEFaSjVRNzMzWUI1eUdMb3BsUnJ5bkZTZjNTa1FsQ25ucEJOZjJWV0pVY082T2NENDdDYXIwRGlxeVkwVnMvclk2b2VGNmkrL0xXRk0wTms4cDlwbVBFSm1McDZRT3Z3dFJocGd3Q0NmU0NmZzlBa1FyVkZSUU11aHpLYk90eCt4eFN6Wjd6QkpaTkVGMFZsR1F1RlhYMUVxR0pCeFN6Q215dFYwcG4xMUFDM0NYZWhsd1VScm93QjVQMnZUSlBCM2FoTWtFS1BQRjlOOTRkTHAxaE5SUTFBeVZ2WFFzRnFSRVVUNDNBb2ZHd0x4R0pKUGVDQlJEd0l6aHc1eGtCclBuYWdRUkNyQXlBNDNGSERsUE1wVU1FRkZEdWk0UnFSSFJ0WmhQZ3lWOUlxZFJQQTlwNWh3cmNQUVRnUUZvZlRJelBtdlZiZ2lQcm5NdFppajlGMVJsUE1zMGQ0a0FoaWtHK05Ud0RSWDRYQnB5VFBMOHcyTXJtRW5Ob01BaEhrSlJoWE80SlBJdUpXbXN6anJYUkVPbUw1b2dKZEpveG1pa3RoMm1OQ0RIYkRGWEdZUk5FeGl3NTdHMlNuU1NOb2ZYcml0TWJjaWJxU0FveUFsSGFLc3dseWVaU3lmM29IOEZuMUdKOHlPZGJ3YUxENHNUalRpSnhtMVRnd2YyV0hJUVE1bXFGbk1BZHBOcW5qVnFVUm14NGxKU2VxeVVxbi9MREcwMFF0NHJsTUxIQnUycjBRWUQ4cXhhclpuV2w3ZnhONUdRKzhBRzlPc1cxOHRMUEI4QnRrTVcraHFub1RkWGgxUmNaU0VwenlLUHlWc3RVakhhV0RJZVZQSEFZSG9JVWc4M01ab0kzQU8yYkp1enBBM0NXbzNlTEhBamhBdTRKWlk1TDNKNUdYL1pVcE9JNUNMYUdXV0ZxQisxamdsNFQ3ckYrU1hWUEQ0RFhpZ2Z2ZTQ3Nm1ROVRmdjRxeHFBMXNlUGgrbk5ENS9UdDkvOEtuMzM5WitrMzczNVh5U1B2a3ViT05wdnFFcGFKRm01Vk45TkhmYWNqaEhXYW56Ni81d2JNamQ0cVpyNy8yd05tTjVqVlZLUDdKTTJrUVAwMzNtU2hyeFdIak1IenI4enpSV2dzeUY3S2JWMm5OdW9hTXBkV25BS1ZJVnU1RDR5MytYTDAzdDhQa2hCL0NsQnREWUtvNWxITThCa1VQTVpBeUw2Q3FwTWxrallOWXdKNHBVNHdkVUhUR0VtMWJ3aDlhV05Gc3Nnb1ZWd3JWRVBmakZZa0JJUXFLTUp5Y2h1Z216Q3VDTVdUZDhRL1NLVUNVb0NtRHBDSlVRM05XZnRCTzJQQ2NySm8yZ1QyTkNXb0ZScXE3MDVDWm9wNWZKWi9KWUIxY0JDVFlkUnl3UVVDbWlRVVdxVlNUSUh5NGhoMVhvK2JMNVVXb3k0MytPV21CUGFNYlNNeVFlUlJkVk1DTU9ET2NQdkExamw2SndhcGhOSlNKdjZVaWpBb2Fsd1J4Q2RrVFVaSi9vQ0U1b0NZblNFNmFCZkVEbk1Fb2VtOGx5bWtDa1hJdFNzWkFETWF3Qm42dllnL0MxcU9iYmpxaHQrRjJTVndoNmw1RnhyVHZJdHBwY2FzRHpKZk1TQ0M0aTB5d05rZVgrN2ZuUWd6SlorbiswL2FBaVJTc0ozUGx2Q2dyeVFnQkNIZldNYy9tM2tOYURSejJFWW00cys4VnplUnZ2K3JmOU5INC92QlV6Tmp1WGw3RElRekVQN2RxeG9vMGJPckhEaDV1TVJjOTlsSDErRG5LMG92VXlyUlJnanRCa3VOd1VpOXBveTloNWdQNkJ1c3RyR0hQc2RHeHpTMGJIZ0VzbWZSaWtITUl4alVWakZiL01NWXl5NXlPQTZwbEhra2tHczRmTEFuMm0vUGR2U2FPS0V1Yy9KdjFDc1ppblA4ZUFRejg2TUFCTzBhYnM5UVJZR1hxVm9ucHF6QXJSQ0tlVStHcDQxcVRxNEt2VEJXSVZoYldPQmNqTFFQOXVkM0dNb3c1WVJUQ2ZzUkcvakxIL2ttQzdUYjdRVzlOTzVWVW5IczVGRXEzeW9tVEJkbUlVd3NNSUhBZHVnTFU4ZmI2Q2xyYXhxaXBLemhSOXNpd05SdHpjYmJKS20xanBsWjNibktFZU41dWNCcmRkM0xVQ0s2aEZvdE5iRG9ubjZjSkxldlArSDlQVTNyOUpYL0x4OTl6dUF2NDNKdXBJT2ppNkpRamJJR1hNbkNMUmdGb0FLQ0dzdThFZ3R2aUlWaE45NVc0NVdVM1lEU0o5U2lHdXZaaVo4QldiNE9UaGdrcWlrSFRRcU9QT0htcW9DUTVlTEdmOER6SGJYVDZGZUhxRFdEbldVQWtwOHl4ZHFSWnBiZEFiQThJZ2U4eTZpNmlpZjB3N0VKWUJJZk5pdVVvTGFWUUFBUUFCSlJFRlVMSTZTUzRKcVUxTm9PS2J5QUIyVGlPMkhVcXdHUVNyY3JFL3RiOXV6VTZxTk5pZ3pLSUU4eURIT3RJTWdvQWp1MXpUVEZOSU1wVVVZbmVaZ2RvRU1RQXJHRk5rZEw4eU1xV3JkSUpsVjUyWm9hUFNrSHRVT0lITEEwUHJaNWFyMXYybUk0SUVaK1BxVFZKRWpOY0lJS2Y2MlNLakZmcG1mVzBYVG90UUgzMWM4NTQ2K3l2NzZ2SXhFSVhjWkphWUxmZEJQNHNBMU0vMGdBRmV0QlFaVEVtdEdlbWFiNDdLVXJXQmllMHBvbDVVL0FsQ0VHNTNqUGtlTkxLUWE5elB6dE1GNE9LVEE2SitWR2JVYTFjWWtJa3ZyWmw5T05pZGtkay8rdFU5d0pGb0g0SWM1NGZIbWFzVnVSOUo4TTdwajlGUVRYc2FZQnJGQkMwbzhBRXVmazJzMXBuK2hGYktJT1VOZG9lQVlESXowWUJ6Mkt3WnhhYjVCTTBOTElpdFVCQkkxWGdnT3NITzhrUVBHK3FsdEs0aHdkK0Zla0NsTnRwUXBCVmZwek5WRTY5TXZCeGhWUFIyWmVUSE03ZmNDUXEwQktNRElKUURTZGExalZwVUFOQ3NLNkkvS1RKUDd2cisvbjE3OTRpdVNQTzh4ZVc3UzFmbG5KNGRuTWdiMktGb3V1a2MydURseVp1eWJQMWREQ3NTV0pOb2NVL2JhT2I3ai9qb3F4dUxDUnVROE9RYnYxVXk4NDZBSEk3bE9QR0lLODIrWnFnZVdpNEYyY2Ezb1VMNjU3YVo3VGxIcTRGTHhwOHQ2MGxQSUh0Y0M0RDBtVjNCb1VyZW1NSW5iMlFlR0ZVTFd1NmFSSllVOWU3R0lCS3hXSHVuSEkwbWtOYW9xMU5MVzNXSzY0R2Q1RWNmNUpvVWZBYTExOHFtVzEwa3RPWjlMcCt3alBQcDhDQ0NPd3ZIZXdEUS9PUGlRM3J6OWgvVGRMNzlLTC9aZnBwL2V2Q2RIYTU5bmtic0lIelE0M2FtUEZWT0lra0RaOVNHL3VEN1MxMnlkeEFmZFBBSU9wTUhuVWpNMHJnS2hrMGxlNWp0WkhJbk52ZmtuRW5LWlYrbkxhOFhCRURZQVhaem9KTGh4VTduYnBtR0lReG1KUVFsajZVVGw2cENyR1N3RU03ZkhoUFRWZEJnMWVVOUg2RkU0cTRObzZSVGFoNXFGa0NFaWFpN3BsTFVUT3RVc2xLOC93QUplekR6UHdWL2lvK2kwVHZjZUdiTmN5dWQ4aE9NYXVJdUI4MWQwVm9scDIyVWNjSkYxelAxR0lSd1lkL0V6QTF3MU8wdXpaalN2SXNYVmxNTGpEa2dvMVgxSUJTWWlFU29tZUFTb1dickVLRndCelZKVEx2TEdDaEFWcDk3VU1XWHFBSmNSS2hkRUxTZ21uYWM2ZDdFZGlIbHlRV0pSQkN3K042amxtcmo1MWhObkJETkJ4K3owTXI0SFNkb1F1Q3ZnQ0Z4NE5VZjNNK3JYY215em53SmpyZEovZlFSNXpHcFFqdG5BaU1EQjNLQ05LVWhjRnhuVncyTWxFRFBFeHpDVVdrOXM0cWJ6UTB4TEszUjBNYW15WDA5d1k0YVpLelVLK3k5NGhST1U5VkhpMlhac0srSlpycithNEloMEJ0ZlZQczBjODVyeGFybk1RSUJqRVVKWFVFbThta2lDTjVRWXdpS1BYSEJtenUwci9aYUFGVWhxa3pxN1kvTXdjNjVKNUpqMXF3NWhmSTl4Vi9oSkkxRUdHODJrUnNhOUtRK3htUjhtRUFRRnJtM0tyWHovSjkrbkphb1NySzZ1NDdQQkQ4Ym1haXRtUWduTURhQ245c0FhUGFEdGRRREVSOERkU0xuT2NpT0d0bXN5N0loa1h3OTRNSXZkL3Jjd21SNHg1ZktweDZaVENJSWp0SzlsYWxCdDBqZm1rd1YyL2UzUDdkMFZOY3ZjcFdFT0ZpWVJXcGNDS3Z4bGdGU0J4R1VMNHNsREZjck9yS0RsV0lFaml1UXA2REM5c0ZjQmNuZ0lJZUZhWHA3ZjQrQlA2ZmE2VHFSd2x5MDV6ZlNBZysrZXBNOE5EaS9aM2FHYWFHV1ZVdFMxZEhSNFN0MHI5aGl5OXJ1N1Q5UEwxNi9UMnc4L3BIY2ZQNlg5VnkvVDZzWm1Pam85QnVTV3FQMStSUDkxeTVpV1JDN2NGNDNWOVJZcnN1dEZVeHdyalA3cVFwRVdwVXZkUk01UFZpN29wNjRqNkNLK2g1WVlNaVNuTldWV3ZQYWp1Q0FuNkt1R1g2Qkh5OUg0bWJ5Q3JySWN4Q3l6Q3lJek8xTjJNM3MzaDRtWlFHbENiZENId1pnQ2tvUVR0L0dWR29RQUpFUDV2TWhhaGY2NUNrSUE1THhIZkFBZ3pGZmk4cmpIa0xSRVBpUy9ab0syNC9nazhqcnBGV29QNW9EWmltMVdXQ0JCWlFvaERERUJCaUIrYkl4bTBEcjlBcDBadVJMZmlWSjcwSGRUcit4Z1hwRCtRQnZaTjVUOVIzRk9IMXBmTUN0UE5hUGZNZXNrRk1nbVUveHUwenNrTDVHbkh0b0NmVldxZTlSM25ZVWZvYUU1Wis0WGRESmxSaWRFaWVBYzlYRUlhWW9hMUI4aE9jMHZjYjlqR1kycmdLWTFwbTVWQXdrZXprZm1Vd2VrSjk1NEwwb0M5K21EQTF4REE2QmxHRjdUMmMvTWVyYXZZVjY2Sm5IWXBuQ2VyMU83Q0VuRlhOQmxHMk9jTERnVHFaWWwyT2hzajYwb2pGMGZvUDRIMTlFTndCN295bEp5TDcxZ2pMNTNmNkV2Mi9FNWdwZnZCUmpEOHBwTFJpQWxMZ0ZDamN1a1VhOEpUY3kxNGI1WUo4YWtWdGNoREY5RmNBaGdKcHZXRURRR00reXpnSzBtcUVNOUlvWHhiQVVPUU1mNDYxekVTcUNaY0d6V1l3R3Q2UkpBaVU2SGo2cENUcGpqdEx5THRCRG45ZEVuazZRZDUvRUJoZXBnK0hLSi9hQThOYUdCZ2xieFRCN0Y0Tkc2QkhhQ0ZFT0FzemxrRXpMamlwcis5RTNOU3czeTR1S2FjWm9JVGM4UjdEeVU4WEtXSmFjMzd6N1pSa3ZUNVVLL29ZY2J0ckpjaytMUTVsZ3VrMGJ6VVhQMEFYQnlkNEVpREV5bUlta2xiVkY5WVJYemRST1RlZ0U2b2Y0TTR5YkF3NXFZL3hRbmdBdDJqS0ZrYVNqbzZwWWFiUG9PUjIxcXVIT1NjNzlWcDlMQ0lzOWJBVlFCUHVyZnJaUE9VRU1BZno2K0FEU3ZtT2NpZ0xWRFNzUFg2ZmUvZjBNdTFsRjZ0ZjhLaC8zZk93bndFRDVuUU5TQ2xGUE9FM1FOcFFScEwveHowSi9ybC9NMjFaTDAyZWIxUkplR1Rwa1RhRXc3SW9TUjlNeExzc3dVeFpReG45bnZuYzF1TGJQd0k3b2RSNjJjdThVQVRFSWlOeXhxbUlRMjRZTGJKWHNGRXhXSVZtam9UcGhzZ2NVenlUeEhMd0RMejJVdy9sbXpoaTd5VUF2azJ6MCs1d2tTaklzVnZnMXFNaU83R0R6bURtZzh3YWREWlcvRURrekJBaGlKdEpTSGRaR0swNlphZW13Tm9ibEFkMEdCcmZiOGhWcE1tekswMmNTKzEwUUpjd1RHMGVSUXJjN2hlZ21jREh6K1ZmQmRGZENRU3BxRm1yK2U5SXVqTjg2WVExSjdFa29rdGhxOXhMaytHT0owdENJcjN4bVMxV2N4WWV2RmdFM0lwQUxTRzVZQUgxRHM3MFRyTTQ5S3V6NzdBbW5MU0E5cWZRcWdBd1NJb2hwYW41YllwbEZZd0JUZ3BCUzBOMzBuUmo4OXJ0eDVjVlpjTElsQjhGV0N1U3FhQzJBVTdXUHVZT3JwQ0RldlNYQlcwQ2p4L0lrMWNlNVppUEROQ0liODAyeTN2bGN1b1pPL0Z4RFVMUEk5Z29rTVR4b0t6QmlyaVBhaTc4WnRGdVl1NlZBWHFPWUl1eHU1OVg1VmRhT1dtbjZUQ1NZVWdLaEdiZlRLWTZ6b1V2VEZYRHFqWU82em0rQUR0VUNjL2t0VEs4elh5bExVUG1ET0d4VkN3aHBaVkxNMldxam9paVJtelBhNEJpQjE3YTBHMHFoem5EdkN4Y29JenBzWjU0c0VNTnpHcElZMlR4cUZVVTVMSE9QcFNXOStmQjhNSzNncDFPWnhXMEExYUhRa2VBSSt6b2VTWDVEeFpZcE5IK0NUdHFYcGVmcHU5VlhIYkhSVXA3eGF0RVh4MXRGT21vc0tCSUVhRFlxTzY2Sm9FZDA4cGJMRUkrQ1hJOHJPTldQZzE0UW85Q0p0UGdIZ1ZqZVdPY0pyalNvWVJBNFg1OUlxYVE5ejJKTW1idGVvbkZEQWZTSmdlWEtUcHFpbk01V29qVzZkK2RGb25ldXlKblI5U3hXTGh3RWFGM21NUXlxVHdPdFg3TFhjM0dRejloYlJ5aGRQTUtHUDJIL0pOcDBQajBRTFg2Vm5MNytpZ0I5VlIwOHUwOU5ucnlLUmRIRmhMVjFmZktTZmJqY0RqT0RMVEo5WlVJbEh6cm5LZ004MmtoNkoyZEN5a0FRVzhRTzNPRncxZHpVWHRFSS8vL25sTlRRa3VPbXo4eXR6MHNRVmZaZnlnT2NibER0RU1kemdEQ25JZmtFMEVvNFNjWUpkcldNNWNpWXNyc1drNmx3T3dHSE9kSng3WGJ4b1lrUWxCYVZhbEw2ZzQwcFNvM05xQTMwWVhiWWJrOWJnQ2NPaXExVkxqVlRaZm9ROCtTeHlMd0NVQ1k1c25zdy9RWkVWWjUvVkpMWG9Jd1JXMm1CMERoaUNJRXZjNTlTSWRFN0xFQlNTemY0THFvSU8wOGdFb0Qwd1J6cTkyZFRHUkxBWGozYkdRemJaVHZCUjZaL0NpVWxuYVFmR1pFZjVFQ1lzbHRZZ0JBaFAzdVhKZFVvY1BMWlBHUVBPV29BU25RTmdkQ0Z3cEJJVkhFL3U2Qy9QWnVHOHovMW5BNld1OWFiNE56ZXlaQTFlamNrU3pFeEdlSEU5MVFac1lrVnFHZ2hRYzZxVFMxYkIzRkY2amdqL3l3UWNPa2lLQUZvaDkwYm12cyttcjNHcUxwcFVTVWNvS1JJS0VYT256Rm1MNklxZ0ZRVEM2ckxZTXFHYWFlZmhFcERnUUZlaWZrclhPSFVJZ0IvQ3FHUEF3NVFEbFdkenlpcHV3MkMyZWdCemxiVjF6bDJyS3VaYmx6a1d5QjQxeWVqVGlDQkF6NG9TYU1BMXdFYWZaTFZ1K0IrUUIreHE3UHRVTzQ3SUtDRGtjVlJoT2pML29jbExTNWpLVENHRVlKREQ5OEEzQkt3d3N2L0FCc3lLUHdWdHdrTU1Sa2FraUFLYmxyTzh0SUtHUmRsZ3RvdDBNVlA3VktYb2tKTmtwbmVkK1h5Z2xOQ29kNEpKOWpuOStJZDN0QWZJczJKdUxGN1pvTVlianVZbVRuK0ZYeGV0U3FBMDdTR0tPaklXdXlYb3J4Q1JVM2k3Qm1ydWxoY2FvVzI4ZlAyTVdsUzdPS21KcmpNM1BJQStGTWo1OG9BSThyNnVyNmlXZ0JrSXZadXlVK1ozR2ZCdHNFYVdOZDdhSmNySXZzTlZLcFd1c04ybVFTTHFNdG51bGtmV3Npbmk3N1BjREdJQ1RRc0xBa0RFeGNtYUtveFpGL3JpanduZStrY0hlNXQ0V012cGl0SXlIOCt1T2J1UkExVnhudDh4THcrNEIzYndiMzMxMWV2MDRlMkhkRXEyZm1udUlqM1ozZ1cwWHFjM3YvK1I3VHF2Y2VvdnNJRWRZVDYvVHZRZkMwYzZoT2FtSkprck9QTXhkUUlUNjRBN0tYZ1I4RmVEalRYRHVnZ2NDTDR3ZUVIZkVCeXh1UmxocC9DVFpsWGVBM09ZczBqRzlqYy96cUdCa0V3VWFGanUzZkdmcXpHVHpxS2x4QllackRBMjZ4STNLM1RMcU8rbUJpaTVCUnNkOVRLaGtLY21KbXBLZkdvZkVTV0Q1aUtmaXMrbnFIZUdNZ05odVR4OFJQVEo1NFlUWFlMbEZSS1pQaGwxQ1VuSHZUa1oxY0ZqNWpGWmdwSVRJUmpLUkZiSG5PQWdGSmcwOGN3eGltb0FhbTJURTRoRElLT2ZPR2tuT2k0QnhVS0Zhd29jNFkxVzBHTVJTNlQvejJQdUZYSHNqakEvczlPY0NXWmNUR2YwcXdyWVRTRE9tT2o0RkkyRlNWOW9HT0xYUkZVaXErV3ArZUc3byt4d24wcU5wb0IwOE5GRllVRVNkRFV0RzNNQ29qNEt0Qkp5a0dwRVpQMWRyV0RvRUNJM1FtdlVTWCtaK1dhYTBsWVRkYytaZTYwd0xIbVdBNGFwMlhTdTA5Y3FERmFlVkxzTHRSemtpUkxFWEVrRGtZcGdYZklIQWlRZTJpcElPWGJUUEFZSUtEQXZOQ1FCMlFNazZnQ0l0YlIwSnNzZ0VxSW1MRnpEL0d1ZTQ1U2xYK2F0WldBeGZRUENaUTQwOFV4cDBCMGdLSWJ2Q1VaU1dqcEhFU2loUFpsZllsVzcwK1NhOGx4TkpKblUxRHExdUNMQU9JOFA2WUcyZXdoT05iY2Vib1JXMndCQWpmRlk1Z1hOaitQcE5iV3NIT3Ayb0E1emJZbGlDOUU1bndxNkI3U01CM3hYa0NPQ29aaWV2WGlhMW5CWWYveUptdUd1QzgvUmhIUmNtczJhbEQwaWtmci9nS3o0WHFCVlkzUW9icWZ4WkNPUDF0cll4Z1FrNjEvejdoSC9VWnZjcDJ2cWpWMWMzTEgrMElmRUhlYVQ4d2ZkNHMvZHhDbHZndWJLUm9QVUJJNU5nNVpyMURRWFNFMG9IWmd6cU1aTll1Z2RpYUdlSCtDdWtpd1lkRWxJTzJxcDVxd0JnTkNBV29wbG1oL1F4Q250bGxZQm9nZnV0ZWlmNlNoM09ONEg5dy9wK2JPWE9OZS9RU0M5SS9YaEtHams1ZFBuc1FmeXc5dTM2VG52UDZGeDFhbUd3Y0t4VHZBN2dsV2ZteHFtUEJqK1cyWkdlbmRkUXlNV0gvZ3Jud0VnNzRncEtBSFF1L3dxS0xFWThSTUtFcGppMmp1dmZ1OHJYd2ROUXV2U2h5Nk84c2s1bFFSUjAvMUF5ZUpOUERsWUFaV0dCU1QxQUFKUS9iZDhTcFdJaFNWb2RVTEs5TXhvSmtDZW9UU0huN2cyYXpsSzRpTEVHaWRud0RpZU5XYm5kSmk3QUE1SjFWN205MXFaVFMwaHNsNjFtM2wrdElFNWtQT3pJQVRRMWdpZXpNRjA4VEQrVDk5TitaZWd6V2pYcVY1QkkvUEVXaTRHbUpZZ2NCM01TRXZNVVUwZ24xbWtsdnAweWc1N2dSY3drLzM3WkM2UCtYdUVxUWhKTVg3QjBlb09GZ01rVXFVR3h6L0J6T3hpczYrSEJDMFdkV1lxUFJoVGhYUVBUVUdCSm5FNjg2aE1WVVZPeU8zMkNIVjM3aUJhOS9CNXhQZ1ovWklwS0NkRGN1UUQ5Y1JkMkhwdE9ZQktIMUNkVWlzQ1VxUTVvSEY0R2s4ZHN3QmRFTnF3MUM1bVpLd3ZHZ2Ntb2dYNzhuNHQ1b25lNk9keUUvZ0FCbmFEOGozYlNDN09PVEVGODhRazN5NUYzU3hYUEVSeUdsaHBFSW1UU1ZYNWpRSUpmdnJWWkdDV04vcm5kODZmVE1wQ0J1MUlxS2FyNkxPY3ZUZnFPS1UvTmFLeVpwZnI0N0oydVdhOGU5dEdhTkVHQi9TOVNILzZMVXd5TmVWRG45V0E1NFJtSWI3SnBKaEFpNVEzSHRKM25kaGRRRFlpUjVpTkRVK2RnUVpLYUtNb1cyUy9BK2N3OEJ4N0YzV0V0enNJSjN3N1VYWFVBMjROVXFDZHY5eC9nU20waitiQVdRSThPOUk0WUVyZUthVVJLbW9yakx0RjlyeDByVGJBbkZvTXo0eHlOL3hhdzB0ZnBPYW10ODNOcVpVTXFYWndSdFdEMDBnZTljQUlCc01ZREFab2ZTUk14MFhxWkMyeXJXa09vRUpBaEFucE91S09ZQkJEQk1rVjV6eWExZC9yeTU4d05ha1FmWGkwQkE4YXBUU3Awb2dtbmFVUG5GOUlQeFp4TFd5eUFYcVJFM2thSEIrMlNPMHdoZlVDNDNzeXY4WTZVSWFITWpoWHBGNGNmUGlBVCt0WmV2SGlPZld6eVpMbi9NSmI2TzdsczJmcDl4eDBjUS9nTG5JMjRqM2JpNlNMTGtEa2NvVHJnTUVHT05FSCtkU1g5S3VqZkVZWEJoR2tpUHpLV3JMdlo2REVwSENwZ2krSU9QRGhIMytmUWN1MmJSTzRlV0RUNXdDTlFTRHhZVW83b3p1NVE1QWVacDk1VEJLYkR0b09vRFpHeGI5bkFXVWk4MCtpVEFvcm9IUjJNNitkOEJVcXZCM21PelVoSDJqU1lVVWJGNktjQVZWY3l5QWxkcG5QamJRU2Y0QVZqYW9TQm1EUmp1RmxnY1NYZlk0UUtYZnFQNXJpeExaS3BpQlRoRW0wbzQyb2xVdmJBV0ltZlU0Z2hsSGtIbUd1RFFVbnM1Vko2RVRhS1JVbjQwZXV3VlRDYnlYakRXUUFRTWxucWwxb1pzb2tNdUdVNG5qdStpOVFGWEU0M3NBUnZ4THpWUUFVUStNQTBFeExjSVVqNzJ3T3pRbmk2c0ljSTg1WmI3VS9oemJTUi9KMnlrUkl1VTR3NzVVNUpjS244OTRFVVAwNHpwc2FremxLSmJTdU91a1dFMHBQNkZjd0lscmxaaU8zYW15NWRBNXpobVF5MHFLRzBxWjZ3elc3NzYvWlRuTFBkcEVlUnllYmNUNWlYVWRvTFdwWU1mZUFyUUpBSW5MOW9FK2hLUHFpUnF5akZiS0xhejFPeTBSaTEwdU4wc3htcnpZNDRMNUQxMW5mR3BZZm1rOTJXRWRWVXVadm1YSzRYcWVzbU5HSkFEOFlrbVlEaUUvcHQ2ZkhhRklyTEUyclVNUnB3dXAwTHZIYktnZ0QxbWJhR2FkNUltTE8xWVRySHBuUGcyTnFUbDNmQWtvVmtrem4yWWhjeGpScmtjcUFXNEhudTlkdmxUd2tTNnRvY3ZXa0F3QmY3VlBHekNhL2dLMWZDN0RsdDJBbTJIZ1V2SUxkaXBxUUlQU0JLUSt3T1RhVFVIdkQwM1IrY3BjT1AxRUpsSk9NSUJFWWtvRUdQWkwrQWJCc2NmN2ZCbUExajk5VUxUYk1jT2hja0wvamlQclRDL0t6RUpBZGZucVllQlBNM3lHSDZJNEFMTkE4NkhNT3VxQkQwSU81ZWdqTkphd0VTczlVSzNjY3JOc2kvNDFxRGlTVExsTVIxcDhtNERXM2dLK1V2TUxGRlU2TWZpRGIvUlRuL09VbnJCTnFhdTFzcHRQUFJBK1BEdExybC90b1Y3c1UrUHNFc082a3Uwc0FrZlY0VkZqSmQxQUIzTVhZTTFDNWh2S3pBQ2FmaUIveXAzOUxMTHBOdUNTd1JkcjIra2puWVMyY1F3WFcvMys5UGpKNEFpejRRb1dwUElkMGp4Y2Yra0IvWkVoTlBydGlJelpjMTQ0T0FxUlRhRW82SXgrWnpCYW1oZmVFK1FGVHdTTnhmUVk4dFNYVWVlNjNwTENFTUVjVXlZSjhlZStZWThuTW9FbW96U3RJK1V5NzZJdTNtVmtBSVk4QkN1YUFLQjJnOTg1K21DTnNCNTNBZ201V2pjTjJ0a05UbUpBV0RhM3JRNW53VzFWN3pFS3JWdmNIMTJnUmdJeGgyekZIaUhONEkzcFNiaHZEaXdib2gxb0ZqSUtXcVRwYnhaODFJVE81RExHNktKYW5UVGpTbWNYUVZBU1ByQ3BEWUJDcnp4TkFRMXFIRHd5ZkM4ZUdhMnFwb2hkSkVpMmp5Wm5SYTBGRWZWRCtNekRSUjdQUVpWSW1pbG5DVHpjdEl1MzZuaUREM0FIOGh0MjVLNE5MQUJiZ0ViL0pINXBnSXVGbnV5Zkg2SXJ3OXNVNXdRS2t0L3Y3ZXF5ZkdvNUVMM0NwN1ladkRTcUp5Q2xFeFZDREZsd1B0d3dOOFJkRkVJQitxaUhwYkJiNEJGdDZRNXRvVWZpOVlwc1JORFFQQUFxOGFrOU1CSE9kYTMvMXFLWGszd0pEMXF6ZHJvUFppN085ejFhZEV1QlFZZkZMQUl0cElJakRjSWFQVFY1a2JSeWZaV1VXT2FLOVFQMHJOYkZjRHh3VEc2M24xVGRmRTdvL3AvOXNXa2Q3dEl6TTB0SkRIR3ZWSTA5cUViTnRrN1AzN0p0QTJLTFM1dDM5RFJuNEZxU3pUejRqbXplbVZFZ2JFRW1BVXk1WXg0S0VqUUI5US8rYSsvWGVRam85b1NJQ0dzdzFqdTQyWmFjaFIrWVAra0hiYzN6dU0xeGJYMGhiUlAvVXhqMVNUek8wUnk3V2tCUURmVzkzcE96Zm8xMTVrckptdjFxOEpyVmJ4cXd0eHcyQUlsdkZGTjU4SjIycGNWYXE5MEdqSnNVdUxuWUJyRjVhYU9heGV0clBNbjZ4MWJVMlB3dWtZelFCT001R1hOMGdiZUVtZlRnNlNxdlREVUJySzdTdTQ0TVBhZjhGNlEzNDR6dzllb1V5T2UwanJTQm9DMDB6YXVVcHpSaURyNHdCbVd2bEQ2c1ZCKzBvNUpsTGxTRXZsd3l5YVNnL0NHTHlrZTRsdFZjK3l3d2ZDcEs4YlE0aW5NczlYNVNwR3BPdFl6cHJNeTZRNGZ4TXFGT29FTnpqQ1JBYVpsUkVwU0FlaVdVZU5iWkIrVktsZC9oRDBMb1NEa2JHQWlCbHRMVERNU0FXN0o1SVhXaGFQTS9CU1JEK09ORW1sZ3BnczlPRDFkekN2NFU1NTVsKzRER0RVWU1qOHh1d2xPazFTelh0UkhnWHlENFhrUDVaNWNhOFVkTlQ2a3VRU213Y3JFNmtXb2ZPVnVzbGpkZ1hWUVVKU2xQS202Z0c4Q2c4RklBVFJBakl4ZVpmOG1HSy9MQWJqMTdnZUFXMGxLdzBLU25COEhmMGd6bVJNUUFBMHdQTU5YR00rZ0YxbHB1dFhFU2xGOVJkSkVGY0JxN0dBdkY4bnVycHVHNjVVQkxMd0dhWkI3aVI2UjZaNHl6c0VKTnh4TnlTWTgxNmtKaUlWbFltVXgrT3BTZEdrUVFPMWxCekNJQU5FNDNDWndVMHp5NlN1L1Y0RGFIVEgvYWFSUWlldGdWYndVWGhaRXBLYkdhMURlY1BFSXJjR2o2M3JTNmFqUGdXT1ZROGx1NENybHlrT05CL2dUYXJ1VEVHV04xc2pRd0Y0SkNTbUk2YWdDd2hmVVVMNEZwOWJER0RySjhGRVYxenlDUk13WGtDRWtaTkxjWGJYUElVWXJRMUdKV3V4K2VxWlhhdjNjWTN5RmlIYUdNNm1jdTRLenpGcUk1UWhGallnckxJUE1QZ21IK1dnUG40OFM4Qkl3aWZpZTJ6aG9KVXMwMW1PbUR3OGNNN3RDczBXK2JDcE4wKzY2WFBUUnJXNlc2K242d1F3T1hJYU4reTNqS1YxVWJkUmRIR1JGVHJ0ZHBKdTgwMkdBUkZHVjhvWFFJWWxuQm03eEFBMEFmTG5FQUxVYU1NMy94UUxSVGd2K1BrNWh0U0hoNVFCZ2JRUVk4MjlWZE9CZ1J6MEtRdDB6UEV0WUhlQVAwaVlLRkwwMmFjWjRZVmg0bXdtTUg0MTV4M1dPUEFWRTNDSlE1dFhXSEQ5Y0xDUTFxL0p3TDVNRW1yOTRPMHRnSjRrdCsxLy9RMUd1SkNlbmYwSHZkUUVlMFBFRHMraWVKL08vamt6aTcvUVBBbDcra1ZkSHRFWXNNSERKMEVmL04vWDg2RjM2c1JTemNxSHBrUDhudDVObHRFOUpIcm5lZTRUNUVCUTNtdHJoNkJ5N2F5UDB2ZWxUcVplMmhZSHpxVGdzOENoaGRRME1Oak1ReFJRdkxjeUVORDR2cVhZR01uSVdnUzFXUStnenBsL0FlTEVDVXQ4T0NjYXVEcStyMkFhU1RCSWx3T1FtWitSS1BBOWNmZk9oQmxMaDNzK0NBQU1CMmVab0ZiRXNYQm0ybnM5OVl5OG5oeG1WaWZ5c0F0RERwajRZSXlBT1M5U21WUHRJR1c1SjFnQ2lYQ1lJUi9BalVhMnVNZUJpOFJBaVNXYkZXUGRCdUVHY3ltWHhpZGxQZWNpeWhjaHpQWkNKT1JVUm00amU5Q2xUY0s1WE4zZVV3SlI3UXp5SnVvS3UzQ1FJTFJnRHlyMEV5cE9RNmtNNDg2S2ZrY1JoRXNETmtPY0hpYmtwQzNxNmhkWW83U1RnY0hiMVFXZ0dBRjRBTGhiUHVUOVF6OFA3dzN0eXNSY1oyeUoyOUl1a1NCZ3pjMTJTMC96TEU3S0pzazZZN1FmcGxqOUJDaVl5NEVhMldpS0NEanJuZ1BxNVFSQjBUM0JLRWFwb3BtaTRFQk5heGdCQUJIeHZNRVpYMVhhaE9zR25NTGtLSnRxVWxQR1hpa01iQjJmZWEvUXpySUNHZThtNXY3Umk4eFlTdTA0MW1SVk94aXJwWFU5SjhSUlRnY2pkT2N0VVhHb0I4cEV3MENnT3NzL3hKT2U3Uk1PaDlySjBOWVgxeHdQOU4wWW42cUJDc1dNWEdHUnJKSmI5QUtXS1E2eHBPOUo1aDhOYmFoN0tSZi8vcFAwQ3dCQlB5SWxxZXhzTjBqRWRNS1d0dk4yVGw3YU4wT1JXSXQ2eW1UL0p3L3BBQVBwa0dJTUY3cGoya0swQkYzeHlRWkwyRGlsdkVKOWtrZ2xZQ3NIelZDMkZZUjhCdmtVejEvc1ozMm5yRVZ4bDBSUk16dnFJOFZmQ0J2UUN1YXIyMUE1aEdhNkREZkl3QWFtQWJzckg4Qkk5T3ZlcVhQQWJwTnREUmNBcHo4NDN4YU05Mk1mT2xiUVJjQ0E2bWltZHBGZUdEcEkrajY2WXlLRFZka3hOOWVZcmJlOUtqMXZvSURucnBaU3kzbXBrdStHRDdZeG92MDlxY1AvQ1lOaElqckthZnRWTm5TczhTQnZSMFNYWmVJanQ3aHdlOXdrRW1Wc3hPbEExTVlUUFoxRzVYNTU3b20rdERuVU0xUnN3RFRIYmFQTlZWWFVqZ3F1QlNvNHAxQUpaKzR4bDVyTHFhOHJZTmRtbksrOC9ZeTF3QkZ3Rk9Ic1hOb3dMQ2tDaWovZUMvVHFzWUpVeVVqYktDQUdvTG94MGRoaXNSMTBoY2FqdUFrNHcrUkxvWit2ZGNMN2JRYmxaZVdWTEdWV0tDcDdiTG9mWWkraDBabnRuR2ZDSjFTdHoxcXMyblU0N1RQNkp6T2FQd1BpNnZVeEhieDNlTWxlRWpvQWFjd1BDb2wvUWttWUJMYzVrTW5neEdtRnYyQ2laMFpjMWI0SWlTK2ptVFJSNkpUVmNxRXFYbUNSbUE2Qlo4ckJRVVZ3UVI2eFJ3QnNKUmVUT2lFTWZZQkhTT2t4UUlwQ2twTCtpU0lhY3JaWGgwdEkycUpzYXpkQWZzMWVVNFZvcXBSZ2JTSEE1eDFJRlNzOWdkRThSekI4dEhkK001WnVDYVVQdmdWK2RzejVrdzRGYlRDa1EweFZqR0h5a2pjS2ttUGxTSitSTEx3WFJxM2ZrRHVtQ2h0K2c0eHdNQ0VQQ2xUZTgrNExIdEQvMGsxY0d1TUJ5YVlEYTcwVmt1ZGdicG9IMEFFTTBXTklvbVJhU1dlblluSDZZTzRGR2Foc1dLVzJLOEp6Qm5Ta1lsVkVNRXV1QUQwUjBKWDlNMlhrYm9lREtzWnBqQlI1V2VSQUN6cWRqOWNwL3FDak1qV0tla0ljRFJRby9ibDVuck5mVThHNnVESWI3WGNISXhXeGh4NWNzd2p0YjY2WFRRTlRLa2U2eTREVkV2MzZmandObjN6N1dzWXV3UkFZYmF6Wm9nWnhvRW1SSXJCUmZ1QzYzQnlFN3FmeDVSMDg3OW1TamFKb1JscG45N0tGNzVjSjVBeSt0YXh2aGprOVlnUU03WEI4dzY2ckNHd0JuL2dNK0pRMFFhYmtMLzVscExGMjZzd1BFS1I3OGllU0VQS0d0K1k2c0I1aXc5b2lwcm5YZnBnOU0yMEI4dEk2eThqR2dEdmNKakVGZ2VvcnJHOVptVWViWTF0UG1nYVpaejBucHFVenpqRVVEYXk2aE1rQkdiR1hNU2hHaGdLaVVMbmdhcXFscnE1dmlDMUEyMTdSZE9ROWxwRVVWc1BuS2J6K2hYSDJWTzFnVzA1K2tycEpYbGo1MnphM2t5ZnlOVXFJeFNNbmx2SENxNWpHa1FlZVIvNjRPb0M2R2hxem9SK3lWemlnN3lwa0l1b3VkY0VlL3BkeG9Ic1oxWmp6ZURtK25ocWozbVpsbHgzTFNMNnpMem9tQ2ZxeU1RSUlEU0VNaFl0eWtRbUMwWkNLUStKRzdqR0R1aS9pRVF1TkJxWjFKZWZ5NlJoeGtUV3N0S1lRZkY5b0tlZ2dLU1BpZ0U4d25DNXpuUEw1cG9pb0ptaHhtQnpsbHk1dVQyUDAwYmNDSHJidnFhOHhXMDYvblJFWkxKSnlKZGtTelFCTTZvdHFPWkJDQjZhT3VENUE1a1ZkQW1ISHVCb3YzeDVCcDdvSEtaV2dET1RCWU1GSXpuMTNPdExCN0dNNm5wbndOVjhSQ1dWeEFGZXRTUDBHYTVEdGtRQ3FrNXZORklrdlhRc3dOVVp2K0h1VFBUNDBnQ1N3cFM4TDhadnZTL0R6WE1MQWorTHBIYkp3OElIUmZ0TktrVmErbVhNZHFDUkpYd0FwaW1hbmR0UFlNOVkvSnowS1NPUmNBbmdxNkYwWWZZZTdSdWQwZ1FwYWlKU0dTTnVvQzhkL0l6ZHRwRkpDY0R4cU5GNDJnMCtMSGpDM2ZId0tmT1ZCVmYyS2ZnM0JFSi9uVlBCMm8ydmFueStQQi9SUFhHZTNEMWxVNk41WktyNzRDSGdwNENUeWRYK3NpbWhRQXVWSDJLM0NHSXU1c2ZNd3BTUkpSM1hHdWdnWVZpZFFqT1U5dFVxMVJyUTh4bVhuMEZMb0lScjY3WXZUZnBWdHBvWXJXdHdkbUVIOCs0WVAxTE9QR2R6ZCtzaC9mM2YvUkFsZlE0T2poZ3pReUVmckVFcXdMZXZmb0Z6L0hmcDVPZ0hhSnduNEo5a05TTGFhb1EwWkc2TUZocVNLSGlGMEdZSzFMS05nSmxLMGlFQzZiWWdEL0JRZzlNaUtGVDdvYkhPTlpZQU16UURmNlFUVER3M05kKzMrK2tjd0hKRGNoY055UE1MZEZISVViRURnOEJQRXkxcWMyc1Y1L3dHV2hBbGFkYWtmNU4ybVIrRVF3MFRXQmUwNlF3eU1Fc1ZZS1V2MG0wOFBrc05zQ2pJMEw1VkVWQmtBUzYyOFZ4Y0F2b0dJYUFIUVpKMTdBeDB0cjhpMWVFMXlhT2YwaFptcE1kOEpjNVFuT084d0hibmxqRXRJWFJZNjdDd01Ja2xEZFo2Z09MaDBXME5YRHc4aXZaaXV1aURmVk5yaDNaUWV2VFhxU0VyVkVNUTBPY3NCUEwxL2ovd0NMNVUrN0xPbkxNaVBya0RRNk9TeVZUQ2Mzc0FrRjkra2FnaFZsMHNKQ1lONVVXakp4QnRBQU1OMlNIWDB0MzlYbU5IQlFqN0NmNXlCWURBNHZ2OVZQTUEzNUY3MVlMWitEM1dwNEZQVEllNlpvS1NjSjU2UWVZRXlWRFdOdEtSSzJFTUNjdmY4WFAxaFpMTWxIWlhmWlBzWWdlbWYwZkh2cWFrMFRpamEwNldsS2VQU1JDTjNCc2QyNEJrNUpxUjdDYTRPQTdINzI4MUdmdXZIOGYrU3doZVUwRTdNQ1J2YVJkVEt5d1FiM1F5b0o0NTQyS3VBL0M0MmVoZ1JFZ2d6aWh5cUtZSDhNbXNTc2RZQk9jS0psU2w5N2xrS1BBM1dsWmhoZStOWnByWWFVVURKRGlFYWNSS3dDcmhzTVk5eTdNMGYvUENKbndiYmd2cFFSaldoZGRjdHBJRnQ2YTc2M3VrdUdGNWd5QnFzbWdDY1kxZ2pXU0dzR092SHVaYW1Ed3NZbWh6VEZLZVBpVWdORUVubEtBTk5GM1RTVXlGMENrdTBKa3ZOc1kwRk5qclJMNkdSR0k5dWRwanJsd2oxOFZJYzFSQkNHMWRrZ1Y0RURKcVl4NXVPa0tic0g5RjVtcUt4TFUydS9Ra0VNWWVPL3JaSlYyZzM1WG8rUno2cVZPaVJzRHlzTThGSE1nTlNxMGNrazdRYW5YU09xZkpPTmJyeXhZUnU3TUE3REVFb0JaVFlUeHJLeHZwKzEvK3UvVGYvaXNSVkRRSit5Z3orVktEaDZOK2ZyaytNbEtBQXZRaDRLdE5jeVY5VTdDNERqclpOY3VoYTdaelNUUHpDTk0yVWI4RmhJazV1QUxweDA4WEhCRi9Rc2xpRHhITmxUY2NZeVJpcy9LUUNOdDZQR3dWM3hQYmU1cEwwN1M4aGhOOUJZRklpb0pGSVUwdm1xZE5mV0VOOXB5cHdhaXhDaUJoY21FdGhBK0l2Nk5ZcElERzl6MDB6eVhPTTl6WldZTEhxQ2RHbmZsNyt2ZElIdHZkQTZmcDBPL3Z2dmtLNS90T09qczVwZjl6b1FuT0xWRHQ0ZklNWHhaQ2dmc2FFRVpKS1NkL293MnB5REF0a1VDcnFCTDZuYStZTitpVS93QWJOYklNL0U2dVBLQWZPZ0p3dEtYZUlBK0docWlBRkZPWWQ5TTRGQUxPTVNPRTZCaUVCQ3FEeFcrbEdBdm5CTVNMcHpreFlYN1JxZzFwSXNhaTh0RDhhSzVrVW5TT0cwM3p1eGtRb013aFpmaWFRU2doZFhDcldlaE16djRmSnBsV1pBYTFIaVYwaWQrY1ZwNmFFSHNSNTZET2R2dG5KTkdvanpsaklVbG9vLzl3aTNNYmxmb0xnVUZxOU1FS2tmT281WVM3OVc4aGRhS2FwVGEzNnFkOVVldUJTZXluNXFvTUpkRm00R0pLYVMvR3liUHpXT2dYNWxNaytqajlPa0psS2hZajduRW1lQjhhRiswclVWeElTRDJJeUQ0SXlHb1V6clBsWXdRRU55TkxUQUoyRTZlc2VVbWVpRzFVRS81bjN1Z1hDWUVSUllYTnh4TkM4MlY5TldoSXJoWDlreEY2UkJ4bGVxdmtlWSs1UXYzN01sb0dFVUg4YXpKclpOUWpkalhCMVlBbExkZlpySHJuTFJpSHRaRm93cS9BWjg2RCtXQ3hmOUVJbnY0Wm1GNjEzNXlrRXJzRTNNVS9RZ08xYXFaMTI3djR6THl1YmxDQWwrTjFmSmJLVnJpVWNCUFk5MkIyYU1zMGd4cWFBeGpHQzIyTWVYVnJEbFNDNExLK0dIMEVjRWNFRFBUM3ROaG9yQ1QzQU5ZbW9OWGtsSjA2T3dSWTd2VGRQM21KQnFNWlBjQ1B0WW9XOWkxbVVDZjlqLy8rVitrdi8rZHZHUmVBZ3MveWxwcmxyL2YzMDcvNkYvOG0vWmMvLzg4QjlEbFN6Rnk0TUYvb3lSN0Z5L2xpTXZ4T1dnd0FZeTBqMENNdDBhNXBOREpldWNTQkRHalhZNXozZDFjSUhIWnB0Szc3NUQ4OXBNOEExUjIvdTZ5QmljQk1kdHc3eFltK3VEalBJUklMZ0ZNRHY1aGJodENpYXE3cEhlc243MmkrNHhORTZKcmgvZ2dndHhCR1V3VGJMT1VueWtzRGFLWm5XU2l2Umg4dGF1bHg5elVZTWRlendnckM5N2JNMWg5ZE1yZk01dzJCZ3R2cmN6YUZqem5BNHV1MGdNbmN1L1J3RHBKUzhTbVg1NVpaSG9NbjFqY2pxaXhkUStQU2gveWhNaEFwQ0YrMGNPY3BlQ0N1NFV1R3F1QlJlL2J6N01PVzcxVmFBTEl2OHkydG1DNGo3N2dsQzRaaWZQNE9MUjN0Q3VTS0xUUzJLVGh4UVRRZ1hIOTUrWmxBSTFobFozZEdTaHQzRVgwRkUwSmljYkFDbmRQNUxFUEVzMkFrUVFFMkNVS1B5QjNYMUZIRE5hSE1ubzVNVmp4M2haQlMyU0V0c2dvSVJuL2NKR3U2d0pKSnEvaHRmS3JPYVVhRFNzb0daVUF5U2ltRHlCNnUwR0VENkNQT3dvaStNVnVSTktqWkZ5Z0FZQ2doYVp4dVJOK3prNS9vSjR1ckpxQ1c1UFloOThTRnI0V3hHVm8yTVpRbjh5T3RPZEg2UFBJY3VIQ3VqRUNuU2ViY2hCbkI5UW9YUVZIVDA5SzlIa3NWZTZ0WUdOdFEweWpodTRqYVpGeHNXMG9WODcwbWJuQkZDOVdmTTJaVGR0L0lFVDRsdDZLNENidzB4WXpFWCtXV0VKTmtOZGY2bUJxOVJ4YWRUSDcrVHdTTzRBbytEVTFhZDl5SGhLTzdacWFyQVhzSWgxSVpWT0QrckhVNlJvSGZZWlV4NFNWNE9zNll1Z0dpSXdCc2p2TU1LekNWa1RkOVEycTM0Uk5qaGNDMG1BT0pVbk5aR29sdFI3U255U0tJd2Y1TUdjZG1rVmMxSkljS0hHTWUxRUtoRnhqYVZKWjdHTHpWWnF4VTB1amlzOUszVmw4QUhMbkhja0JGOHVXTW9sNWUzS2NHbXNqS01sdEp5S202d1hHOFJGTG0zclBOOUcvLzNiOEdwTTdpQkJqOVFkOSs4M1hzcWR0YW0wOUg3OC9TMy83Tlh6Tk81azZDKzM5ZXdYejAzZmt4ZU9RNnh2WW41d0thdHFoaWprRHJ4MUd6SVArTFZJSTVrakJiSElNR2I0Zm1mL2o1TWwySDlvWDJxeCtRKzZWREhjdExhSXBibUYvclJQVWdPZllQQWpZeUtmOEthUFFUTkNQU0p0TWQ0S3RMbzlXN1NUMkJYTHVQdG1abHk2dTRURWI0a1R6cno3TW9WMEJ4azZwWFNRQnRydUJPd1hHL1NBRkROV0QzV2RydkpXemxOZllhQ3FSV0tyVmM4dGJPVXpaOG8rbGZzNkdhTkpnaVBsUDBJVWhmVS9BZWZxWXphRVpRdWFRZXZ6VVhtUjNteHZwd3ZHZXVGTFFLOW1BVnJwdlJ0YlFnL3hndGRPK252cmljYzBWYjhMUXZLd2ZiZHM3elk0eUdtR09ETFpTbDVPTVBPcU5PbEJrOEZrcW00MmExSWhuTUU0VWw2Q0ErYm9tWEpoR3I0bjFSMTV3YjlJRjRwMnIvbUVtMUQxNWxXRmw3TkRyT2hGalEzZ3FUNm5PUmxNWjNoclZqZ040UmdNQnZudW0rUTgxS0J5cGhXWHJDbDN2c2xwSFNVOHdSdkdSYzZxRUlSTTU0dm52dVJIYVRHWGtVL1hDTVREUjl0SXFrNFd5enBoL2FFd2dlUm9XOXJRYWdmNnhHbTVZVk1ZUWQyaHJiYVFSZTk0czFtNlErMElhMXZQVnBtSzZRUStBOER3YjFwZlIxV3RWSUpBek5SZStYUnlQZkNFMHdmSEZJdnd4dVNCNU1DdWlQTVRBUGFCd1dDSlM1blpzKzBpNGFaT08yNHpEazd6SHNZQjJnUTQ0YmF4QnBGekJRZ3oyTDhEcm5DNks0Y05wSm1OV2dnWE5sSkF3dUNVR2dENk1oTUFNZWFzWkYvQm0rOGxZYXpHZkJDcEJYNjJIeG1VQk5PV2FXUDlXSzU1dVk4bkJZbWNUR0hsdEJQRkZaZjZHbFJ0eWtiVDB0cTJ0S0hXVVl5R2RJU3dvWDUxQWhwb3NlMUl2MGhTNWpkQXVPbjFkckM2d2ZjNERQOEpxRTE5WWoxUVY0Y0JtaDRqWW1xMzJjb2NGMFR0cnNsZE9RNXJzbStVVWIyK25KMXRQMDdxY2o4UGQ5SkVYdTdxNmw3My85TFZFdTZqdmdXM3FnbWtFcWJtS09MckFSK0ZYNjRZZS94NFFsSis4TEhRY3RBeWkrd3QvSi9Nc1BZZjR4NytIcVVHdG1idnd4SnkyRUlPTWJFZWw5ZkxoQlN5TGdSRlRQWW43dGUzUGZFQ2hFYWRWV2dXdDhyd1pmNnBGRXVnR1lORWxBbllQV3JDWTd3RHoyZVd6YVFLTWtjNzUveVROSXNNRWtrN3hRMEZoSCsrUU9GUHhLOUZYZm01RkRTeW9iVUxPRWRhMUM3UzZFeFJJNVlNMlZLbURWSkw5cW1lMDNiQW1pL0kzQXVreWVaUU42WCtIekpYN2VmVHBPZzlNSnRlazN3M1M4UnF0Vll6YnZyNktWQU44Rm1MQkdNcEpLZ056T0FqTUhmaWEvSzZ5aEkraE5YNncwckwwUkNnTnpxZ2x0RXE5NVpKcnU4ZUtHU0tWQm9CdVpGNnh0MSsxeEJ0WVlFbzN4anlmUXFFd0NkZkR5ODlDSVlFU0pTMllLWHhmdjQ1dzNRQ1JVWVFnV3hPRjIvb2JPWTZNMFV0OVdBMmhveTNiTVBnOW1ZRks1a3Mvd1VVQVlGZHF4T2tNd3VNK1dPZmtYQ2FKeWVveUQxWEhrRGg3TnhicFFTaGorakQ3YjMzaEZMUy92NWpyN3k4MUtjRDFSNVVCN0c3Tk54NE1KeU9kZEpNRTZVUmVmcjlUMFI3K0M0ZVZoRUowQW9ET1o5akNkQ214VWxpQTIyWkh2VVVscVpYWk14L3dJODBpQzlETk5VZzlsOEZ3K0sxQWdSNTBPeHMzOGhaK0d0dWlEZ2FBdURzc3h6T1o5WnJUYlJZOGhGeFdZS1ZwSFp0R0dQcndLUXFETTh5TURuUGJHZ2hZQVU2V0d1Q0R1N0QyUXhtSGRMbHFrci9wVzhIaWhPWmp5b1VibWFjVVNYd0dOVFIrV3pLaFdxVklZQlJBbFREVnExdFFJcngxeW01RGJRQVRSSWZOWElsZXFCMUgyWlJTMFBxd0xQdU03ekRjMUIrZFk4N29Ma0FuQUEweEcyelQ3M1lNcEdCM2pNMUdTYWhma0Nta0dQL0xUUUhzZEU0anA2VnRFOHpEcnZZZDVPVURUTWxteVRYaStRdGg5RHJQRTVOZlBwMWRVRzhBZHdEd084U2VPQ1RoTThhbk1uWlU0Q1lacFVDdmhQTDV6am1wLysrNHpOYUVXMDZ1WDN5R2NNTXRhNStuMGtqeWs1L3ZweVl0OU5pN3ZwRTgvZldhMjJlSWtLSDl4a2pPeXNCcjA0MGtucm1IUW8wTmc3cUZ1RnNKblFmZk1rUWN3dUdZS0J0VkZOVTczYkJvRkxOTTNFMkdsMzhVRkRxUFkzY0toN2FHc3BiVEdqM0pmZjZMbUx3U0hwVUFxalNkS1J3UVJQa0ZETmtxYXl4VUIranhUR25DZDRGU2VxbEFrRUlYV0tUM0lvNTRicWJYUW1LTU05Q3B1a3ZrK1d0d1VIeDlGSHhmdVNhQ2Rpd29UaS9qODVraFBLaUVJcHREdm03ZHZXSHI0aytvaWxrSjNQWnhiNjZ1WG1JY0M2eHNuVmFuZzBGM1gxdzMxVUErOTBCOElyY0kzeW1lRFBabjJGWWp5ZnFZUnRmMXdBMEdMQ25NVkM0Z0grdVI3YUxPTTNSKzE0UURCNE9rTU1IeEpBOTRnOE1TTHQ0RVJEdG8zLytnbGVLbUJ5S1lNZ1liNVlhWkRsZjV5cVdiUTdLWEdsdjFhQUpRVEs5aHduY05TVzlKdlFvdDhKaWpBc1B5Ri9Bb0psclVPcmhFUWFkTjIxY3g4VnY2T3hXSnk5Y2RFVmozOW5YMnVzekdjb0ppWlVTcEdSUFdwQUVHZ1BkL1BrZWZpQkhsL1pNVGJGb3RoY2x3OGgvZE9vaVZRUE9CMENERzQ5ZVBzOHdIMlBxa1hhb3Y4RzdPd2Joa1JxRXlTMUx4YW8zVHVBaWNKVldFdVE4NFdiak1hNWN6Z2pSQ2JXVXcxUlo1bmxBVkgrQUlIVjJxdWVlaXBrQ3V3Q0VMbXNra1ZncVkrSzdWRmZ4ZVJhQzZvRlNjTVFrelFhQVFtYzZ2VVd1MmJXMDZZc2hpM3pKZFZkS1FkNDRjMStSdzNBRUlqS2pzZ1FhV0J5QnduTDhvVUZmYzYwZ3hTSDAxc1laVVc2TE8rTy8xTWFCb2pHSEJJOVljSkFZUHU4REswMWhwejhZaTJZblorZ2RTTENVQTFoQUJMZ2o5bGhneDFaKzJlN3dGQmZUSzVsamR6UXI4MElkVFUydGhBSXpRM05aUUJCODhhWFZYTTNoQ0t2OFhrYjNPcWNLOExZTktuT0ozWnFoc21CS0hWamFta2ErbVpIc0NtWEgza2R3TS96S3Y5bDdUMUJnQzhZZ3ZQSVVLRlVqRnBJVDE3OGN0MGZucUErWG5KYyt5SHRDOTUwSjRUd0RyNFZycnc1ZmRoWlVpVDBJaEoxRE5UeHFvalVZbVZiVDNTOXlPWjhCNXVpM0tFWm9vbWhUbjI0dVZHMnVkQUNJTXJSYUsrN24rMS9mNk5FV0t5N3pIUHJPTDdBR281RjhTZ1dFc3I0Nm9KcXgwQVlHb3k5a3gxQzFvc1FDK1dRN0lXcnZPb0w3cldBUXg0cnh1aWNIa1hhU1BySzcyMGdzYTF4Y2JyS3lLRmE5ZnNiVndmcEoyOWJRb2NjdXJQT29JTXdmSHh3NmVZOHdwclpqREhFdWNDWW9rZnB2Ym5WOHdKL0N1Z2E5ckYzREdIOHFMbW9iK2RIMnZhaFp1RE8zVVplUWl6UHR4YzF3MjZrL2FZVDVIRktpUXFTNkdrTU9meUN1V3FWZE5VZTlGTVdCd3N2Z0FHSUlHR2xjUVpTRnczWHk1SXBEWFFrSjIwSS9xZWREanloZ2V4eUhRMHE4Nzh4UisrTnhsUmMxSW5yWTU1d2M1eXlCNFpIbjR6T3E4R051UmF2N1Bkc0l0NFp0YVpZRm9lNFZZUzIzU0h2Q0Rqd3FwQmhPK0Z2NTFEKytVejQ5a09GTVkxcjBNQ1lrWHBvZmZCeEpTOGpaM3Z0Q2Q2ZSsrVVNRMXRDaDlBQmlPMzJoaVdadEdaM0Q2Smw3T1N6UzZBdFpOY0pBMFlxMVJxanovQVNKY1hZN2FHNlBqRVg3Q3dIbjRnL1JuV2tkSlhZM1JFSXJUeWFKaDJhaTU4WnFKa21VM2Fhcm9ST2hkTURCSXdONXFWUFg1bkRWWGlaQUVoSUIzNU5TS0hSakRkenFHelhLQ3JFcnl3aEl1Uk53Rk9hY3dpUVNpbVByaXVFRFJncHFYSFd5SitKRjRTOFdyaXMxcGR3VlNpYmYxYlpVTFZBb2FhbGFiWitRM3BKdVE3dFNsZzJHaHVwSHMweVhsQXR0bkF5YjFPQUdSMGxoclF3TVFBQUJLeVRJa1NVeTJVMHB6NkVEc0N5UFVFUFBESE1lczVtVmRRUnJLaUNkUmc2QTVSNG52eWt4N1lKbU51MVNOUnZ5NTdOa2Y0dXRwVVc3aU5xQlphRldCbU1NTUJjQnZSd2lYeWhwN0gvcmNxZ1lKMzc5NXhUU0g5K3AvK1NicTl2WW44dml2cVJCbDlVak01T0RvbStzVit2OGNxKytYTzRLSmx3TlRvck1lUkNVelNEYitnd3Z6RC9MTUd2b0srNkw4MXZRUUU2U1RvbHU4aUZ4RmE5K0FScjMra3RuM1A5MTZIKzZHRXhsa2orWEo5emVqNEhNQjdTOVNWdEJiTVlmTzdycTZvcU1IV25qWUYvNENyY0d1d2d4Vk1ZczB3eDlSaXBXbjVOWGFCSUhBcWFEeGFFdk9ZMldweU91SGRscVdRZ2xSam5oNXhIenc0bHh5K2NZYXArSms5ajJ2TTJmWTJHN0YzMkJ5UHFycHhUNzRYZmoyUEtsTjR2WC96a1dva2JHQ0hYaU10aGliZDN5dklzR1F4RDg2RnZLbFduYzhUNVpvdm9PR2NDRTRUVFRvN1RIK2tlZjJjYXExd0duUUZ2WU0zK3IweTcvb1EvZ05YSVBOQUtKV2ljbVM0OHpBWkpQeFNUQ2pjR3d5U0h5UVkwVkYrZkw0ZDlQT01rbjRHWVBFM3l4cG8rR1V0djF4RFo3aEJNTEh6TW1TMG85N0xTM1ZWemNHb3hVeDl0VC94bmFvMlRHZS9zcFBmdjJYdUREeWk4cXgvZ3BiRUlsQ3A0VGg1dnZkSE5kVjdIS3lzSG0rVmlQVExCRFh0NWJDNTZXQ2VkSFU3K3NmazRXS0p6OHA2anZuVTU5aWVQaXV2YmVBY21nQTRmbGJROU9SNVBpdjZ4aDFHTWozWWNrUmxoanR5ZFN6NVp5NmF2akdyU2hUeFZUUytPTHJ6Mk5CaWVqajhhZFA1Y0ZHVjFBUEExZmVLTkxPLzFlVE01L0ljU1A3RTVFQnlzdjlSRGRDSVdwLzhOYWFOZTJnRElJeDZWeElibndsK0VZUmdmbDFMTi8xYW1yaU1EOHVhN1JVMGtOM1gzK0xqMktFZHR0aWd5dGVJOUswRFNFTzJEN1VmR1I5Z003eWRwcE9QMStrek9YSW1ycTVRS0crTDdTZGZQUWNzOXNpd0w1MWlzaDBUK0dpbkpVMGkrbVcwVmczYURjaGwrcU1rcmpQK1IzTFAxTGJVRkNHR2VPOStGazJmenhTOHF6YldPVS92Ry9icWRkT25vd1B5OU5DczhPdTR5ZHZxRXZOdTZFVVFyTE5GWm10cmsxMFNjNWpycTV6OXQ1ZisxVysyMDI5LysxdTJtNHpTdi95WHYrRTQ5by9wei8vemYwVUQxdGsvWkVQME9KMCtIT1BVaGxGWTN5bmxnNHBWbk5vQUI5aklzZ3RHMHBUVTc1eG0ydVZkdkZkN3lwbzlkTU43ci9PM1RuU1BLWlB1QmJTSDBCQVIxb3paNzBjSTBkdnJFNElDSzJsdjcybGFwbWJYTGRkNTZPb0ZwWTViOXdBTGRhd3NWelJFMC9Dd0JzMG56NENVRkZ5ek9kWjlrVWhpRXdkNkF5SG9iN2ZZTExEaFdjTWh5ak94NXM0ejdCSWFGdHhFdTMyS0Z6QjJqa3F6clBNVmdhbk82SjRrMnN2VVpvNjd3eTIrYjVCV2daOXJmVE8xTnR2cDlOTUoyajl6aEFBMTJDTllNdGlZQS9uTWwzd2VXTURmQ25zQlgvNTFUcHczL2FDdW1nUFFXc3FZb3hhRkFVbUgxUnJsUjl0UUFBaG96dUhNRlJVUnhzaTdBU2sxMlVMU3EzbUV2ZWxxNVE3Sm5DNm1BT0gxa1dzVW5XVTlZUWlaWDk5TFNINDd4Q3VEQmRESUs2SXBkTjYxVnEyelF6STI2eGJNSTNEb2hJOWJZYko0eFcvYjRqdm13eWlpMFJjNkVtYVZmZkVsVVBtS1B2SUFuL3RIb29xdm9vOFNtQlRJVk5nSlZjdG96L3RzSzBkOCtJN24yRS9WWFNlVS93RXVSdGNrU0V4YVV3MENPSmtQZ1NTdTRUN25qSHRjcUhBLzBxYmJqSmJRV2xSaDdLMENRZUkyZ21teHV3RUY1WG80WmdWQ2dkWnI5SHZsc2pKczlHWVJ6UXgzODZ0YWlKcXdQam1UZW5sU0VMTm1nQUFscU5LRkNGR2J0NmFKYmQ2V0tTQ2FqcTVUTm9Qem1scDVWZWU4eWI2bVdiaEgwdjVaZnZpdi8zQ1dicTgrb1FGWXJiUEJZWnViNmZXcjNmVHlPVWREa2J4YkJ5Zzl3TlNpYi8vekwvODYvY1gvL2pFZDM1THNPOXBQclg0MS9hS3luZjc1Yjc1UGpjNjcxUHJoTDlGZXhta056V2xNOXYwVUozU2RhTldRWTdENm1HaW1iaGdaa3ZGOWpXQktOVDFsNmlQU25veWp0UFAwVlpwYjJrcUhuNmx1VVR3UFRVK3RlWXVpZDJ0RSt4WldDamkzRjBLamFCQ3RYS3crcERYT0lkemlFSVk5YWt3OTNmcG42UTgvSGFiejR4OEIxYlgwcSsvMzArSFJHYjR0NW9pS3IvY1UyQ3RTSTAwbWlranM0aWJQeHp3YjRtaVcyWFEweHVydy9ndU5TV2Z4RTBEeVI3cHpydVVSUS9jR25TSWZEczNXS0tLdnFIaXJSb0hwZmtlTnJzT0RBelJUVEcveTJDNVBlK25ra0owZXBCSUlWQllnZEZaS3JIbmtxOUVISytBdVVubGhpYzNMQ3dpWkRTS2xUVFl4cTAzT1c0Y0xPcXJqQzZ1Z0ZVZWtGdnJPVzZKVUNxQUsxbUdheVBNamFOUHBrWFdQcit3R3pmT01TT1lObThJL25Sd3o3NC9wNWQ0ZW1qRDlKM1hpeWM2ejFPYW9zRzdYT200QUVOcjhGR0FiZVNnSGZaSXZ0TVJpNHo3elVvVy9ndjhadnlZZDlreTRWUnlMZktmWkoyYmtIUlg4aHIvMXlla0dDQXppSTJrYTdBcGU1QTZuamo5WW4xZFBtbjltOG1Ga3Fjc0hOSzZhcHBNdXBEcWYyQmwvWmtBd0F5NWE0RnMxbnF4RjhTYldOVGVmRjFGQWtCbkRkOE1YRWtWb1BIYlkreDBVUDJGbVNqQU1Oc0NJcnpSYjFCRDhDYnVXZ1FvczNoKytIZnJFTi9HZHYyZmFHUTFIRzdialQ0QVNESkFsSll3TzhQbmU1ME5idkxLRWlKM2g5Q1h5UDdqUFJNazRRMUJ0am41cGVvQ3QrSWhVNmUwZkxRQTJha0hSREgwelJZVFZZajZGRk50RmFyT2dVMHd0b3pZMWZ0enF0RUJreUxJbVRhUmtRek5JcllsN1JwZ0ZBcG8xeEh2a3dVU0JQYlo3K041dEgxMzhaNjVEZ0w3UDUxa0NVNXhtVEY1Um0reGxFMjdWOGp3eFJ6UFFTSjFhTElPSU1YaS9jK29MM1JRQXd1Y0d3eHQ5T3pwN1NCOCtQeUpocDZRQW9IMmMzYURWSEZQYzdReHd4UitDYzM2ZUxTY29CR2d6NWZUcUZVZEt2VjdBUkdNM0FzeldaMi9sSFJWV096aFduNzU0RVQ2UzI5UGpORWNhQk40bWRCcUVHMXBBRVYrV1BkQXNMUUhNUnJkY1AyWXFIT3lhdHBjQXlRQ2Z6UkQ3OFhjZkRqQ05wb0RuYzQ1UVg0ZkpBY1p2ek1yZUpIRVU3UUp6dThiNkdCandkd1BRVzZLVGEwVEJsZ21xZUlyMDMvM3Q3M0MrMzZZLy9SZS9nYm1YZUk4bWM0dlpTaDlHcElPWUUyWTZoZnYva0ZHWVRZVHUxUkxvVy9SV21wVGg2TGlhQUZNZjZ5QnZPSmhJTkZhZzhyY2IrcjNPejlTMGRSdUVPY1N6dUVzNVE2QkRHaVR5Q3poZDM3VFR3Y2RMVWdvc1BVUzBFMEZqUkM2WTNRY3hyaVhLeFd6dGtQbE82c01HeDRadGNrS081Wk1YRm9oRW92MFlqWnpuZEp0RmFLdkI4K2RvZjRHLzU3SFBGemovc2NuUFV0TURiRTFob2FJRHhRS1hsK3NVSHVUa0g3YmZQRU1nV2NXaXpRR3FQVkppRkhLNkxueXRZeDdlM2w2aWNONm5xOFBmRXlXMHFDRndKWWpJU3dpZG5MY0piY0VIUnE5alRyQkY0MUFLL2hERTVGT21NUUlMdVpJdzg4amZ1aHJjMWhmK1ZTWkh3SGZPRktJOVRHanBKT1p0ZjJ2K3ovVHFxTzVFT2dOaVdxYmtEMjUyY1RMVDgwbG9BaTVHTGtPc3phbHZLSGRVRUFHUCtWRkQ4d0VBQlF3U3ZaWkJHSUQzWmszRzVSZWs4THZZT1RvVEczcnB1YjRrK0o4WG9DUTZoMTZlKzZFalZTTElZQ1ZCK0xsdENuclplUzB6K3V4Z1N0NUhTNElJei9OZW1jSitDc3FJdTNpdlJnbW14bnRaMk9lU3ZrdGZJQmphOW5halcxeEFHNXFNM2tmL3VJbHZBK0NBRGIvbWUzTzJsQlJlWis2S0txNmdwcE5jSXRERWNDNVlQQmlreU4vSTI0aVdDbkJOaU13NlIraXhtSjRTQkNZZWttMU1kWWFCQjd3U0tldDNBU1UyOEQ3aTkxRHE5U2tKL0lpVXZPZllLdmZVdFhIdXR3RTJ1VUx6dzRHSEF1TjhBYnc5SFByNndqUTFsWEtXL0tuVlYvQVIxVWdSNEhrY2VwcFF6MHVZalhHNExxRGN1bm5BQkx6Q2w0VDVSaHVSOGU4MFFWU3J5MnZwMWJOdkFkY0NXZHpIK0xBNG1PR1dKRVFxQW14czdjVjJrbGJuTTg1bWZXcXVHVnRqaUJSNnpKaGJzZ1lEYXBsUlg2eUU3MlhBM1BlaGxmczRyT0V4dFhFbW43SlJlQUZ6NzFlLy90UDAzWGYvbFBQenZnOHdMR0NxdWhHNHh0cEUzUzFDbFVNSS93cWdPOEkzYzM0MUllY0o2YzQybk9iNkZvcHVNLzN3RHo4Um9GakJUN2VNRk5mZlNISWtRcUtJUDJscHJjSUpNb3NjM2I1UEZIZ2xhb2RaalpXSlpHMi9hTlBCY3ByVE1KQldnR3NybVhORkpQSHFMSUt1WkdJZHpOS21Ra1ptRFFKQ001eGZLSkEra09mQXZEV0w0bDJUV25QSm5IVmd6cjdYWWc1TkRTRGdTMjBBWEd1VVN2YkU2RlhtYUFIdGFZbm82N3krUzB6YmNrU1c1VXRUY05pZWhWWmVJV0lxbitoZm5tY25TQm16M0VEWnZOdVMrRDBIYUMyeVJXeU9OS0FtMzYyU3RFdHlmWHErdTVxZVB0bWtqUktwRkhtYlVadWFYdk1FVy9SQmR5bkIwejduWEVNQ0NPNlF3SnZNNlh2d0lsaWhpbDlHWTRheEdTcjBMZU5BWndLK1dyU21vY1UxTGFLWk5VYm1sc216UXV5SVhTUGNoV1VqSDhFM2dJQXVKSXVCZEtFeGxTZGFTS1g5N2ZNaFY1RUFBRUFBU1VSQlZPYWZaYTNHZXdFZkppZmpqS2lWL1VGL05Kc3k2TGgzeUpjZ3BUa1R0aXRFSEFjZzhsbldBUEJYWUxOR3doZWR3dUNJcFZaOVZPUFNDZWQxa1YvQkFva3RmaDRSQXhoTXRHYWNNZllNVEVDREFLbGF5MElJU3Rudm93TTlhMTR6MVZUaXNGLys5aGt5ck5mSDcrZzNZMlh5L1U1VEw1NkxKRlFDWmxYVnNmbDk3cGUzK3ZMWitVZ3AvMUppek1DUmZrcGtmQllhSVpNcmFBdUVBWXIyZ1dXSVB2aU92NTFUQllUUGkzNzRuaDlCWHVIMHN5M1A5V3BUT2pPckNBZFBSUzdRcmpYYWUvakZPaEQ2M1EyUytlSUNmOHdkZmducW1TUFJQY2s3SEpreVA1L2Q0dmZwb0tWNVhsNGJ2NUtaOFk5VTREUWlhVTdaSENWd1d4eFljSTZ6ZDZSSFhHSEYranYzemxXa21VQlVWMVNrUEw5RTBrSThGY0xmbGlaV2xWOG5JdnJWNitjd3Y5dGdQdWo2d2RUcWNqMHBGcTQzcG02TUd4RDJoR3pQR0lRY2VSYmpJOWVxRC9ON21LM3pxOC90N1B5YVk2aXUwdDNqS0QzWi94cW44RjVralYrZFVXN1lFNGt4b1piWDEyTkRyeVdJYi9ENUhGSFg2WmpFVEpNemowK3U4SzhCc3BneUJ4U3B3NVdZZHA0OHBkK2o5RGYvKzIrWWo0dllTR3dCeXF1cnkvVHkxWlAweTE4OEJ4U1dNWDEzMDYvUTN1NnV6akhSUGpBSGdoYTA0QnF5YnJGMnJqVnJwM1VRYnBWZ0d1aEpPdUR6ME02aGY5Y3h1eTB5RWVsdlhLQVM2UG9hOWZ3UlRKYXY3bk5OaXpwY21vQ1JLOGhuK24vQUZRQ1V3eUsyMXdBWU5TbUFGMDNLTkNEWUo5WWxjcG9RckNQV0swNktKc0RRd1pSK1FMRGNzOVozN0tWczAzWUhFMHVudVZVN1RMbzFtaGlIZktpWmtvaHRncWtsZ2R6WDJrUXp0Y2I4TWxGRXVoRm1ZUXRCMk9RZ2p4RkNzOFBjdGE0dkVPTDZnbTJQY2JOdUJ1a0VIRlIxSFBENmNFMGdsZGEvQ0hHbW9Fczl0RkF1WW96U3VqeUNXOE8rd1lNcU1tZ0pNWWY4RDlxUko0TnBRbmtvZmJXN0JHQkpuSHpLNUtzQnlTQUJCbDhBUzBaeklXUnNmOHZBL3NqUWZqYjczZzlkVkpNeU5ibENqZE52eE9lMEVBc3NxTXpVNmxoY0NOODI3Sk4vaDNyTmUxVkI3N0tlVWlUa3dhUUNaUkFMRjlzT2RKRi9leC9FempEaVpSc0NrUytmSGI0WnIrVUdZY1VKOW5tcXNaQWNrd3Y3QWJnTWgzYjAvUUN1RUdBbVNDL2tPdTUxbmdUQytJNVBJNUdOY1liL2hibXpQY0VtSW5EMmhkWE9jMk8vTlVsbmJkclhUUGl6M3pGSDlGVndjTjdNOEE0bnNLaWRtK0tCNUhocHJvZHBpUWJJbUNWY3RWSWx0YzhYck5vUXFrZFJ0UUNxTm40SkM3QnBsaGp4czR5dnliS1dJR2JhMFRRNDZNQUREekRUck40NUlOZGlURlZMaXdqU0lQM2hJclZMdEF4UEFHZjFZSUFlb0FVNElubEhiSEd4Rm4yWUdNdUZ0UDlxSFRPTGFwdmtQSTNKZ2JySGYzVU9jSFhJMVBZd2lBVURGWlNmS2JpZHh6MlIrb2NBUE0vYk02TDVRUDl1QUxuall6YTlVd3E1dWJiRkhzRzFjRUtQOGFsazg3WUlJSG0wRmxWRVcrUDB0Ly93WS9wd2VKR09NZmV1MlJmWEJrUUhNTzQ5bWU4M3JRbWdWMHNYMXg1K1N2NFJtdFlEenVXRHd4L1pwemRQaEd5TmlnWDQxS2cwKzkxM3p6QWxpVFNpeldobXpxUEYvT0YzZjhjelNkbVFjaUNRQUN6bVc5cVRpakpnWlI1d25iTExJZ2NVRk5qU3FZQTFvMXRQNzVGT1RhcGR4Q3cxUWRyOW4zY0lrUjRwSEs1NVpLanpiQk5kOS9hMjJQUEk3Z3ZtTFRZNW85R3B2ZE9GQUlzK1pwVGp2UU93YjhnM3V5U3ovNFFUYjg0NWV1eWFQYVRYTi9mVXM3b0prL09XOWJvQXhDOEErQ3ZtNlFxTjdwcUlZVitwQWYwdTRLS29NUUdlbmwwbDJYdU9QWXJ6L0YwbmNuY0xMWmtVdkFEQXRhamI5WURQeXhPanhBQWp5MW9UbGlSWDRWRFJFUU1nWVY1Z0N6emlvU0U5VW9NZzFvaDR5ZytPWGY2RHlKZ1RORVZvWCt6UlI2eXZTeUZ0YTlKZ1phYWtmUHRrNmM4RWlobHptbXJnVXNqYzdobjZ4eThqWEY0WG1oUUxvUllrOC9weUFnMzdxN3BGV0IwaUYxbXpzMWRRTUdJaW84S00zS3Q5S2hDb091dW8vdmxGK3dLTUV4aHRNWEI5Ujdhdit1MUxZUEc1R1R6Tjd4Q2wvY0pJQkJNQlVzZVkrQ2cwTFc3MktIalRFVVJySjBySkpvUFR1cmNGUU9RMnVZYXZKREJmM3YvejgvbmJNZGd2QVZrTlM2S00rNVVLemtHQVBCT01TazJyWE1lMVgvcWEyOHJBWmRzK1l3WlVhbHZ4WW5BS0hmZHVtcm9SalhzdHo0MW9KV2FsanR6UUJGMG41dEp4T0krNWpETGFHUGZGYzBOanNWdFo0Tmkrd3NGMmpWSjZPdk1HT1RkTHk5YWhxbUlTYmFGMWJBSkFTRktlNHc1OGZVcWdDWS9nUHN1dk9HNkVrQWR3bmhITjhzZTlhSjd3VXB2RG5VdUU3dHV2djRuVWhROXYzNU4zUkRrWUhMZGRBRXRIOGhMUnZBbnRFaTVoYUd4bk1hbVd0dFhnYnFrZmZrRVo0NlBqSzByM1VtdWZDaERyYUVWejlPLzc3MytaZnZPYmY1SysvZFVlUHkvUzd0NFROaENmb3hHaVJWQlA2aFNOcXNlV0Z3VmNXTHFPbVg0UHFTVFJIVkJDcFlVSGpRUE9zVUlwL1VzMGNZZWRBdlRCWW5YN3IxNEFmaTNNWXNzdUF5aG9rbk4xYXEwRFhKOE8zZ01BaHlFc1hTdGZJZHhZZEpuVmp6THZRT09NTlg4dmJlYTU5bnROR3pVdDczZm5oQWRmU1BQdWJhVXhUQzhPT3dXd3BqQjErT0M0NXRrZVFZNzlYWkk2UFpBRUtrVklTZmdHbnN4ak5BalRJdHAzZy9sN0RmRGNBRUMzQUZhTHlPSTlld3NmQVQrQnpOU1EreGJwSVFpT2h6YU9mblp6M0pCeDc4LzEvUWd6bEpwWWdOMzEvNlhyelpZYnZiSUZ2UTFpSk1CNUhuTlVwaklsbFVwVmZlcFV0Qy82b2svWWZkRVJEbmM0L0Q1NkJ6K0I3eHhoMy9qV0RydnRhRmQzbi9LcFNhcVVsSm5LbVdSeUJBZVFBSW5SMzdjMklWVTcya2hCQkg3OHc5NXJyM25hN0Uvb2J0aHVrbUhtK1NRYW5VWFZNc29aZkdlVE1Ob2pnaXlJU2JadnhFVndRbHNjV3M1SWsxMFlsOHhLMmd2NWlvWWxOanRmUythQ0tRa0ltSlUrd3N4YmhJTytiWU1ET1RkVE9ySDlrVnU1V1VIaDlUSlRlWWdDSEdSTXhVZXJVMTlMYURxY05TRzhMNUR4YVN3U1V2djI1Y1grUGlZRUYwbGkxYUhtNTNoekk1a1Z3K0x5ckFZYW1aUDIwVDFpQU41bnpHaXlCTW9QTVBuVFozcWY4VXZHb0xraEkrRW43blA3Rzk4OVR3U0ovS3U0QUFZYjUzaC9KUjhFemozVk5HSmJKYjdMcUl3MkNrd3pkQlVCYWtmNS9qQVl6aEVadlZhcDZEUDg3TnZUeDk5bE5ENURUUW9neFc5QzA2VE8ySGlDY2NOS0lIcjZWdUZmaVBOWnlmSDEvdlh0YS96WmtLMmZYVXg5UjBBTm5zMDVQSWNmV0d2bnczTzVzMzJJbEZyb2xjd3BqODBsYy82K0hKdlhCRVBrUEFXTmVVSENTaUVUVEJiQjVLNHNpekFzelF4VEpPcjRLYWFweWw5QjYxZ2dENmVLdzdaRnhBaUZFK29qTkE0bmRYelJJNHRjb0VUMWdwc2puTkY0N2hCa05tRjJBVzFvRm8zdDRTZGJhWEc1bXQ2K2ZSN21TSmNPQzEwWWw5R2dDbEV4aHNVOEdEQkUyMldqM1F1WXpTRlNlNDgwaVgxTU9JSlFhV250VGxyYzJFZ0xtRVYxdERQN20rc2d0NTV5ZTJzOVBYNjBSVkRnSVB2ZDhQM0V0bWppb0JveTYxeUMyQmFYWWNKMGNiQTA3THBENElMMGdpa1k5ZC8vL2E5aS9wYUhySzJ2NHFNcGswS3hUdzVVU3J1N1o1aU1sR3pSYWFMTi9OKytldzA0RmJqQU5YQ01OUWNrcmxmR2oxc3prZS9qZFZWTFZ0UG5VRENaN0Y1Z0hmRk5LU3pVNUs5cDgrS2N6akRaVENvdWVUL3VyRURSRkhRbkhVdDcxS2dDVDFocmUyZTFZRUMrajAvUW5tRTJGeDZEZWFsbHRXazlhb0tzRzR5b0NVY3VHeDB1TGpHdEw5Z0lvNGxmOFJTdDlLSlZRaHRGKzJ6Umc0NDVuM0cvODJCb01ETHUyMFlJNlJiUkRCVHZ5cGlOTlNMRStrbHRKOTZId1Y4Y2Z3QWZDRUFScEVCTWdJdTZiQkJ1L0l1Tk5tQjhWUVNacFR5Um1BeHpLdkJXc1FsTEFoamtOajdPRzVpR0VpRkROdXB0WGlKYW05b2F2OGxWVElJdGZyb3g4N1VFTEVCbFJuektid24xYnhpV0FKTUJCTFBodk1ndXY5VUtYQmlKM3NVQmkwTWppWlYxRUNGMHNwUFpYMTNnYlBZNVNJbFFCN1hFejdOOWo4OEJTRGxLbU8vck5USXNuNjkyTS9ZYitGZkM5T0dSMXhXLyt4MFdBaFB3L0tIVXdUdkdLR2hDWStNNkdJc01RVUFFMDJLOFNrTEhFMTBhdU5ianZnSmhZcHpNbFgvT0wrNlhSUWxqNERreVErYWJOVENaajgvMzdmMmNEOHlVZS9CZnZPTSt0K0JXdW96ZjRlRG4vcmxqUmpZcm5JdGp5dG9oYUkxVzR0dXQwL2xCNFFYaFp4K0l6RTlKN0hQRE9Rd3dZbWx1NXhHQkQyQnBlSHdlNldtdFpJUDZPeHU5S2ZXVnJsTVU0aTZ0TEZKN05rZWVGSTVncEwrbEdZNGh0RXVRV2RWZnB1azRKSks5anlmaEM1dkJoQ214dGRtVFQxZlRHaHJDbTljZmtNWVNIVFYxZENrZFVFUmJnd0VOSWN3T3BtY1RvdGsvb3lzbWpDK25aTmp3Y1ExbXM1NktSTHpPQ1REczd2YlMremVqOVByRmRkcDlRem9HVEgxemt4ckFPOXY0ckhJVTFlM0lqTFpPd1JDV3lRbmJJSUw0MWErL2lCU0xSNDgzR0R0cEpCMjJ0NEk1cnBCZlZDZmFlWVZqdVU3OW5wRzN2WStINlIvLzZTVXBEMmg2bUU2N1JFWVBUNDRnZHZybmE4WXlZOWM5YTFpQllqQkdWdEcxNVQzR2tUaExvU0wrK3kvd0FwSUdGd3pVaUxNdWlLNk9GcjRoVGNJZ1VnL3lueWFSdGF2VHBDdzBpT0NhMnFLSmRZWW1kWXpKZDNKTWwxVjhWRzdiMVNLRnhXaWQrMlBxdk1aYkR4UEkvaU1ORHpzQUR5am5ZZm5pSElKL21OMUR0Qy9xRTF1MExpZnlleWFqSWhuWFh2YlhwS1ZjY2Z5YTFpY3RpczNWVnZWcjI5M1ZvdWtLZ1JOVFhucGRBakJFRFcvSU1TeVFKd1piRGp5MG9zTU5NYXBzZE9FT1NMRkxOWXplZ0VURUtJQkx0azRVck1BazZFM0ZSRGNJNTZnVU9RMklSUHJSTnlmTkNHY1RUNHQzbGllL0Z1bkRjZVo1RWhWL1lRc1FnK2FUaEFMZ2diRUFsODF3VjRoVlRlWm5ncFlJK0JsZ2t6ZWtHc2RBbEJiYTQ5NHR5ajlDNG1TbXcwSFhob1ZTZTVMaHhTaVpEQWZEOStOeGo4RnJPQ2h4Ui9nVUFwRnhaa2JpN3hLNlptWWVpMUV3R1FJVGlmT3pQMGt0aldjZ29TSkJVYUR4cndCQkN5UkhJak1KeEhLTzNFRG1NVWEyUEZKbXp1TUV2TWxza2RuUFF1UjJJcXI4WENkajRpVGJIb2VweHAyOVNDYWpxZzFJUWcwR29QNkFOczM1ak1sL2RpTVY4SnFDT2tUVnBJUjJwR3JJamJpUFVWdThINXh0MENIUHgwSjBUZ0pkcUN2amZycWVmT3ZJWlJtbytYTFF6RVJHeXR3R2RIYVlvRzF6ZFhLQU50UmdONVZsdEMrM2c5THhidFkxUkdXdUdUeGVoL1R5OGpLbUVTWUJPUmNkZkZNRC9GK3VoNnZyT0VkS1NSREZaMG80dGgxMjlBMWc0UGJxRHg3Y2k3OXZYcjJNUGZXdXlTUS9zekNkTlpwWnBWMEpUTFpBZExMRWp1RlR5NXRwNWM3VHRQM3dGMm5yd1NPWUtFVzZzM1BwNmNOUDBxZjN2K0x6Tm83cENlb0htK21EWFRNeDZSNS85amw5eVJjdytkNmhLUkgyeDBFOVQ4aC9iaW52RkdNbSthZWZMcVdubnkybkowL1g4ZGVWVWhQLzEvRWhEbjBpaENONjk3Y3dxejRscEgrRmFmYnYvL0FLYlpGT0NCWVprMmRrc3p2OVd6SkRzUkRNQysyTkMyTzlPY2hhQk1LeE5sbG9TUi9pSXljR2MxSVJVQVBKZEdDK2tsME1NSGRJWFREclhWUFErMFl1SFQ2OTJWbnIvY2hGNHg0bWZjSzEweEh0ak4rOVA4YnNRNXVDNjF5aStkbm1HUXVZNVpjT09JM25lQS9iRkJlSjhwcmFZVUc3NXJyVkc3SFBJUkZCOGJpTW1hblpMLzZhdW1EWDFEWkp3WmZuaFhUSzNvV2EwSmRzSzlhRlBvMmlLckRjUjFHL1g1Y1VFRXVqenNranU2SDhxVStYWUJOYU5SdGpsbWhkTXAzTUw4Qnh2dGhqenp4QWNWaHROM0FTcENueFhkWStvUHdvV2s5Qlc1RS95TmhrN0pxLzVoS0c0b09RTE41ZG52NDZDaGhaQUlFY2IzNE4wNGwxQ0xWZDRvSGdmcXFWa2lQNEh3c1RoTXAzQ1RYTVFUaWJSRGJXZkxSRjNaUkM4aE01dFhNbFZzMExGOE5lN21OenlJV1hJZmdLbTVXL21qRlpVMkF4SUJEOVcwR2VURWFOU2wrWWRyQThRR2FsOU11ZFRUTlRVRE16VWlFRDg1K015ZVgxN1JubTJRaFEvVlNSMUNwekZOcThuRk9lRjlmSEZUQmtmUW1nMzlnMEZoRENJWi9yOC9tZC80TFJ4RTJ5R2Vmdm5CVDM4VzZDMExJNGo4c2N2U2dZSmVQWFRQSmNUOWZYbHJWTG5kNWVsOC8xVGo0N2lFRXB4VHlGazdEVWJ4QjlscGp6aEpLTjMwVWVpN05KZ01Ja1F3dWhjK1VLekVobVZTcXhXemVSdWlJK1M1OVpqTFFMUXVRNFcwWDRGU0tBeXd0c1lnQUR1cmc0RFFTUHJjOTB4c3N3R2I4NDFBY090dm85Mk5sUExlcmhKTWdsTmpGNC9PaFJyUGYzejMva0hQeWl0c3FCOGJxTmw3V2NaVGhyTkZ0RWs3aGhkK3hpZVlueHJPSlRJMnVlMXNEYkR4NmtlNDhYMDVQUEZ0Tm5YN0NWKzFLSnBOWEQ5R3FuUllMa1pQcnRiKytqalpUWWVuNG5MV0tTYXQ2VmF0Uzk4WnQrcWUydEJlWTZ4VzlUNlE3NVJ2Y3dBYy9QdWY3dFc4eFVTMzA2Uk8xSWtrV0QyTnZETC9lUnZTTXhxZXpMejhDSmFsSlNRNUt2WlNLZ01pc2xEb0xUQ3BkWXA3eDJvV0dMbjhCYUxGUFFDMDlmV1lBcENJMjR1aytCQVNWejVJeWtaYTNDUW5sZENITzJnWUg0RFJ6SktJNmJiY3hWOWd1RXNWcndyU2J0V29aYkkvQVY2d2RtVW1MZGRKUXY0a2MwYXJ1QzFyaTJOcGVXVjJiSXNWcWwwSG9odm0rdXovTjVQcTJ0em1CNnpxVTFHTHpYekJLQUtaTnVjOFBPUGVmazFWM1NYNjFGc0thQTlNcjk5WEVBUWkvTG1Oa3lrZE9QdTJ3VzJ3VEhFR0l3UHNBU0RNWlVJRFdjeUZ2RU42bW1LUTBDR243bk5GVkFUckZVSzFLcHdFL1RHRUtnb3RLcFdlbWlpdElkeEo4NHFCdkRzcDNpOWlJbW9VZ05zbkdGdUNkNGczaXlLWk0xS1krT3M1SFZURnlRaUdSeFdXWUdQbHl1eWtoNHlXaXlvNUhCM2pJaFRiRWM1bFMvNForbVdoQ2dWNEFNTUo0OFdHeG1pWlpuZUw5UXV6bGZKdWM1Umd0bHJJNDVjcldZZlJEK0xhTVJTMlNZTW9BdzlaaVVoSzFkTFA3b0c0cS9Bb2w3ZUsvNGhldGtKRjZYN3g5ZlBPQlE0aGxxVnVOSWtLTU9CaDlqOGRxNEswZGhVb0x6VnZMeEZKN3ZHUEtZdk00elkzeU9tWGN3T01lTmp3azh6Yi9GUEpRLzNOczU4aS9NUnVjUlkzV2hNL09YSVRrV08wM29rSFZlUEk1N2tiUUljdXRmd0RsR3dBODQ0Rk13Uk41ZzQ0UTJrYmZtcVRXajB4QTNkWFFTRkp6VUZzSU5Ja0l5dXdaT1lEdDBtdWhvNWIrdHFnMm4yNjRtUzA4bXc5cm1qSHoyVmFTa3BrbGYvcjM5WTVEK0NyTnRNMzMyK2RQMDdOdG42WVJ0eGtya1NnMm9DeHlTdjdPOXVaRysrdUorV2x4cHBPbkZSWmdZVzUrMUo5THJ0MmVrS2JUVHptRW52Zm5ZU3Z1VXJGUklnTHgvZnpFOW9HaDRjMk1ydlhxRnBuUjBtQjQrbWttZlBucE1aMVhTTmNoZjJOcmNKR1dEcmVxUjJtb1F0azh4SzM0ZXJXV0svbXVMdEhGWnBYWk93cmM4eGFUTkRrUzN0UTF6WEdmblp1YTVTc0xwSmx0eFlaVVJWRGdFRDJuRXJpTVlPS3JKdUlLdWlHdnFLM0NJdFJpL3huaVhjVEFmeit1dGJ3dTg1Mm9MODZOMXRtc0ZnV3FhV2pSdmRNeUtCbDhLNUJNWWxkRy9OZ3pVUk9Bd20zZ3NXQnI1VWtWeXUyWXdiNWNYSjlQR0dsdDVrUXc2ajVhMnVJaVdTVHVabGFnVE5JbVdMaU5MbGJRQnJCY1h5bWxyWXpiZDNaeFAyK1NlM2Q5WVNwL2NXMlN6akVhNi80Q2VYS3NrOXhJNE1qSjRoa2JuaGhad3JxaHpaTGlrZndEam81TzAvLzRkS1N5ME40STJpL29uWWNheHhSMnkwYmJQQmZJWk5Tc3RuRmNURC83QzlUTGpERVZCWWJZQndoNmFqWFpPekQ4MnNFVUk2OE4ydjBuOW81cU54YnNyUkFsWlZKM25FcUlYRzRWU1VvZUVjR0VnV0ptUElJcVhENFNST0hEUGtVRERGdlVZM3lRbWY5ZHBGczUwNlY3d3dtWEQvdWMzbVp4cEFhcXozai9mTzJ0eTNKMXJzMmttMGJ0UnFQZnpYVEg2RnUyR00xT1ZNTE5UVWdKVmU1TklkZjdKSUNCMm9DS1FOUDFraG1iaHV1QStZNHhmUHQ5L29xQmE1Tjh5RnhFeGZHNjNUR3NBMG5wTXlTREF0YStOU3ViZ0FnNWtGelpneHQwdzl6eEorSTRmRnRkeWpkZjVPZkxCSERPZlpWeEtUU1VTUTJITTJjYVgyWXJBTWpXdTRyb3dGcmxsaGx1WTQxd2ZXakFJSm1OM2JJN1JnbExQNGtIZ0c2YWttaGhIYk9CbUk4SW1oY3c3TzJjNGNJa3M0ZHRva0k5bEJyNzVjNU9VZThCaVlWYVltSlRWM0JCbXErR3dYa2REMlNTS3BlbmJhalVEVi9qQ016UnMxSWhKRGNHbmNvMEhlM2QvQjkvUVh0cWl4dkR1OW9QMDU5Ly9tUklkdFFNWUxRTnI0RlQrOWE4L1NaODgyVXpyZHpiU1BSenA5eC9odjhLOHU0R0pISnhjRWpVa0VYUTNwZmM3Rjl6M0ptMnlvY01LREdXTjk3TnZ2b0VwZHRQOWV3OGd3cm4wNGQwSDhvYzJNUi92cG84bmIrbHdnRW1IdGxSQmsyOVF3RnVIRWRmWWxhbUJqMDc4bUoxamc0WDMrMm1mMUk4TkVpYnYzcG1qaVY0MWJhMnlLUU5SdWsrZmJGRDZNcEVPOTk5ekgzWXpZZzFDaTJhbWY2dGhpZk5aYUlKM3dEaldNRlpCNE9lWDZ5MUNaQ2JuWjdETzlXYXg5RnZaaGthaTlEN1IyeDhhbEdFZHdWQnRvQmUrVVg3THV5UmJkVUNqUWpxR3p0cHppd0RKNmhJYnB6S3ZLWHlRczJTc044aG1kMXN4M3pOa3c2dDl6VGJJbUtkMHAwNHJvRm1PejZLWkxoRmdXWExUMVprU0dsZ1YzeUdDNU00cWd1RUJhNzBWMjZhNVM5SU5rUkFGWkhUOFJaTmVJbEJ6Y3JqUHJ0Q0g3SHF1V1FmUHdMZG8wclY1ZkpBYmZ5VUFvYUViaDgvZ2pDOXgwM3ZaQmRXMlNzSkVqVW9ZR0JoU3c1THVMRThMUnNWbndWbmN4b2NGaG9Ic1pxZHpNOTVqZ3BUU28vWU5JdmhQWGd4QVpnV3MrUitmK1N2ZzVVUDVZUDR1WTdCSlcrNS83Y0prMWRBbnkrQkNRK01hbnkzVEVSSFVGSmloeXhvVGxFa3h5NnhwTWNHY29TNEQ0REFMSGt5STg1MjhmcDNNdERKajlINCtVeVNUVVJrNUFnNEFnT05jNjJ1TWFINTIzdWJIK0JLQS9oYk1sTG1OemRaczZzbmU4aHlkYnlBZDVwRm1raHFrdnJZeGZEemZrSy9uQkl4NFJ0eVQ2MlgyTW8rdzlSbVgzUmU4Yys2dTZOZzlLVFAvUUhMdTVScjU1dEw4dTFqaE1lRVZhK0J6c21TV21aZHdRTnZrTFVvZmlPeTVFVUcxUmo4cEd0aTU0Y05KczR1V1JUY0dOSzFMSWtQbVFlbVhxcE1qVkNHUlVFTFNwOUJwczgwN3FyeDdSNXEzRlJYK20wUVRTWSsyYi9zVmJWQ2lwSW03NHZCaC9qSngvUkhrYkVGd0I1aUlueno2QmZDZFRLOS9mTW04N1hDQmVZT0FzSkI3Zm00ZU00NG1jM01UUkNnbjB0cEdCZVl4bmI1NGNqL040WGkyM2ZQQndTRnBERWZNcjVEdXdkdzJWekFSWUt5Ly8rTTc3bHRLbjMveGlQRVcwcmQvL3BHRVdreXVkSjYrZi9ZQ0p6cEpwSmg2QjBjNHJkR29DaVNkMnFUT0hjQm55RDlybmw2bFYyOTI4TlgwS1ZOeFR0UW1ra0Z1c3VZc0dzazZhUkJuUjl6ajNSdGdyREIwa3F3VnVPVWlCQTdkNGt2R0orQWNDSHI3RytlTTE5OHJ2VWJCNDFxSHNNVzZVRlBWN0JGZlE5aGpLa3A3N214azJvT3BPNTRmcGhKT2JXUTRqSlhzZDNLMUZtRTJEUnIwMVNGODI0NXJRdGxkd1JZMk5nTzA5dFRyNWtoWTVUUVlHY3licUYvZXlJWHlNRkk1WnRHMnA0QnpnMTErcG1qSWFESDJBdTk1L0plcm1JeXJSSk1iK01Mc0RPcm1NRmZnaWxsRzgrQ0N6UHlhSkdSaGt0OHdZTWFobFdNK2xmUVdXaWs4eHlocGRnVVI3Y1ZrZCsxbFRKSHV3WG5pdHRmNTNadzdNZHZ2dnFUdDRzWmk1V3ROdmJFSmthVnkxbTVjR1pFL0UyNG10Q0EydUdma1JuQmRNQjcrZW80RW43VUFtVkNPVW8zenJlTDMwQmhZbkZnVU5ZV3NGYWdoZUg0dXdJWVRCbEhxUEhmd01JSXdjUnlqYnlOVk1qY25JQ0k0THFNdm1wRGF6WmxwL2NTc0JGWk1XNmIyTTdQNjJTbWVKV0srenZubXVUQ0lRS0l4OC9adndFSHRKc1lSZ0FtMGxPRzRWWmJ6RXNuaUh2N0NLU2JWV1k0UTk3bTl6dC9Wc0p5RW1sWDR6TGcyYTZ0Y0JpTDhQQTZZSmNnYWMvVTVNaXNXVUFZdFkvYytmbGJGRm81bXVLc2x1c2crMHpLWEVudkpWY2tyb3VNYXo1UElORHRMaE1qZDVZVm4wVEpIallmL2lOaGRvRzJRSklpR0d6NGdHTjRWcVFDMkRsRlJOQlBhdHRGRmlLWk9IZHNNOVd5TDA4c3dOSFlCcDlHY2JZU0diT05Wb0dFZ1RacVpCOW95OTk4L0ptbVJuSituWDN3ZVd0TEIzaTVSUXZOczhJKzBLS2RoZjhFUE94L1NOZEhFeVFreXJXbkpzNGltdDdGUVRVOGVVQzZEMW1VNXo5dmQwL1FhVGN2UStNTUhuTE0wbjk0UTFmdng1WE1LdExkSnA3aURPVFRML25vdmFCM3pZempvbTgwK2pJNHRxOUFpWDNQOVNUTTdkT3VVOXFnbDJ1dit3enNTVCtsYWVra2Z0TmJGSHVaTmJzQlluOGR4alJsOHVuK1VYbnozYmNZbDFrQmMrODlwV09KSXZQbjlwODhjK3dsblJBcVpGWEFSUVhUSGlJc3VwN2xaQ2liOXZ2cTJiRjNrWmkzWEJubDBaL09iTGtPMytWcEhXS3pqbnpKRll4b0daTGxOSHhQZDNZd21LYjlSbzVHWnUxR0lFV05UUHNMOUFoSG8rRGFYVGoxa1NNMm5nVEkzRW9rSUpzOVE2NmtUN1p2Q3B6amZZSTNSeXF4SG5Jc05XUmRTWTM2QjBSUmhWRWRZRjIwaXM3UUNJdnRkTm13KzM0Q21qQW90bFlOZ1FQdzEyVG02bFpMcFAwN0FOaWdnT01SdE4xY3huU05yVmw0SXJZTERDdi9RdUhRWHdXZUtuMjQzdnJiMFFJM0xrNFdjaENlMzkyN2V6Q3BzamdZUUxIWlV3bm14NS9uMjdoNFRxR1l1Qi9QalZrcUV2REFBQ09sdWFGYkhPTFRGVzJhbjVGZlR5b1NuNzhYamJpdXVPY1VqdURNcU10Y0VrWE1lNFkvOGRvVjUyNncraUo5eHhOWmJBTXp2RWwrTVFPWm5PWXZjeXNYaWp2WVNpbnR6WDFNSUFBdkE1ZjlnZzJNSkxlMFdEcVlXY0llQVFTQ1RZK0M3NzBqSjRHcDVqL2Z6L2lLVTgyWkdJWTNHUGpuUGw3a0x4UXc3dnpOMjVtOHdJV3IyUUNKOVNDTjhLd0RHMjRXazRrZXVnMm1ONyswRGZZb2lqclZqTFlOSmFDcmtpQ1JJVDVSb2JtRXRiWC95RUhQc0FUazJPRzhoMkd2U0NzeG12NzV4L0VSOENITjNOYitaYng4ZlY1UjRkTWhRSnhxbDN5UjIvTVltSE9Cc1JhaGpRckNwUTNXV09TT3FFUndWTm4rWVE4TFAwakdnQjFHY3NYWFYwTjJSRW5zdnd0VHNqRHFrcC95UTdnQkU1VWxSR0thSFQzNUJpSjRzZkJJUGJjTnlUWExuK1hXVmJIVXk1TjkwMG85dmNIeVRqUzF1ek5EUWNIR0dIVzRvMnYwRVpqUWd3dmJzK3dOTWtSYitsenFwQ3d1MHlHblFqLzExd1BESlp5UmJycGJ4aVUyU21nQWplK0hXOGNBYUFyNmcyUjkxdmN5Ti9DTWMyYXNybUVIVHJCUzRkbnBKelIrWitSL2MwWWIwaHRjNzlNN2luQmFheEJ6bWM0LzZ6V2ZmL2lHS3pNMlRjejN6Vm0xKzhnMnQrTTVvRnRxdXgvM3VienlFYjVsUmlSK2lyNEk1Nk1QMTVIdnNGS1NnNGV1MURBdmhGd0tKbTNBVS9BVGUrS3MyTUZlM041ZlNMQnBQQXhlSmpFNDZsSFlNd0ZsTWJUS3Z6UTlQeitqK2dBQzZJTERnWDdQZHpkL2FJOWZ0RUNGeHhPZFRzdDExNkRlcEYvVTh5M2hjZDlzUWxVbFBzUHZ0OUN4dGp6Q2xKM0hNTi9DenpWa05NTDlJSGh5YUtaMTVHVGIxaFNTL1lvSzczWmRSWnJXazZOS0xnRVB0b3lPdEFsTVlzR0VJbWZ3bEJGWUZzNWJITUhiOHFPQ0NjUEdkTFJtTzg4OHV1VkFUYzBQUWZQbHcvbXVzaEVnc3RMT2tQZ3g5UmtadGJDM1N3T0ZsdE1qZU9tNXFPa1Y3MnJ3dm9GczNaU2VzWVZPZFpqSzliSC9LbUc1Vk9TU0pEeGZrT2hqZFN5NFlHcjhyU1NJeWdJUlJpeERvT2lSZFB4dnJoMGJqTXQ5S0lCZmNYdVJkTlJhUmd3ZEc3U0hRQ2VjOGlZd3lGLy9URE5Qc0NNa1VZNENaY3QvUUNHRlltbzh5WXJtOVNaa3lJelVWM3lJVUIrSnZJQlQzYzM3Qk5CbmNtRkY3TDdWVDgyU1lIdmVIMFhpdGlNalRaVmJCVE1WTjV1YThNck1Ya1oyL3BoUG5LdkY0NjZUTVJkZE9RSW5vYkdTZ1hpL0NNeHVPT1E3SGsrc1Y4Uk9pOVF5UWxFTWNsRGN3bzRXVlRmeEFuK01YK2l3dHJDNmpMUTNUeTljN2tSam83ak5GR3NadDRBaGZYSERySm5xWU14WjdZWmtCQVZsZ1F1TXpoSGxla1hoNERJVzNLYWtRbWVaUTRhZElMQzFYNmNQRnlFQWgxaFFFUmJaTkVVRmNZRnQ1ZUJUUy9CSXRDaFBTRlNCcjNFMDBNRVFnU014SG12NWRrakl3dnpqUExzUnY4SHRRR2tJeGRLR3hTajJkSFNKdW90ajV4WWNkT2tld1hkZjVGVUtsUVQ3WE1ybGJPSHZ2YnpEM3lmVGkyV3RDOExUM3BYUEQ4dFpXK3ZiYnQ5UWVXaCtJVTNtTC9senNWanpCTTM5OGZvQ2Y3Y0tSb0NHaUJlUHdSeEVCWHlyVVB1THJtaE0zaXhSSkUvMWF1WlAyM2xHSGVFQS85dXNHWTVsSVIvc1h0QnVXcUc3U1gvNUVxeHlJc21pTFh6bVJtajVYYTRxTEo0RHdsa0dKZ3VOL2Z2YkZXbkplZk1veVBqN0hjVTd3RnhPQ0ZaYmVXMU5acTBQQmF6U05KN0l1TUFJRXRrR0J6ZlVWekVDU1NoWCtySzlSWVF1bm14ZjBqbWZkeklBL3U2QVBHd21scDVqQkpveGk3WU1EdkxIZVR0akI1eHdOKzR5K1dPZVdMNW41amtDellOMlcwMGZuYkRKN1J1a09ESytOcHFjcGFCbFhIUVk1eWZnYWFFU3o3T3d6VCtUMTRwSzlGUW11REQzUFJDL1NUWnhSTU5KZ0NtalJha3ZncVMrM3JQZHczMG9LZmF6YzIzWTcrbDRGbHZNTzRhN3dSb2tTQnRLN3pLdjRhQk1mbGdBTVl1SVB2MlkvRU1BM1ZNckExQWo0SWRRekVkZHRuWHhnUk9zZ1VpVi8zcjZLMEtORmxMZVJEbFU4K3pzWjlZajZKSEo1S3J4dFB1YTJWVjZYbll6ZVBqTTJxRGNHTEROejRESXlmU2orMWZRS3JTUUtMSlZtakVXR3c5dE9uKzdLSE95R01Vbm9jbjE5TUxHcVhDc2IwUUVvay9SKzBlT0xZeUtJbXFTdjdKRG5USUhFODBQRGhDRjZqdHFRcjdHcVB6YTd2RmMyaFRNejhmZndPWGsvNEpZMUt1NEhIRFhieE51NEI3L3ppSGpKUUVPckRDMHNuK3NpeFQvR0VscW1UT1ZXUW8yREhacDNvOEkwT1VrTGtZQlpaVisrcDEvOE1qVW9aN0V4M2pudFpvN1FOUFoyanhFV1BKaFhHVUd6ZldlUnlCS2JSbEJBM1FkMlpxK3p3ajZJaFhlTXdvdkNYZkt1WWxkbEdyMHhBYkxmeVh4bTdVbzRjQ014VUpVZEFpNHk3akttQWRaSitIL0FHalFadHgwVE9SdmMwd3hva0ZRTkdzNm9SanNnVy9vYWgzbXBTaUV3NVVBRmZGNUdNOTNpM2Ezb3oyQmU3OStid0NtK3pkSUZrektpMlFKdGJlanFBSEgrNWErSENLeGl1djlnQ29JOFQzLys5alZKanpCUGNHNlRISzhpSFF2TUNaeG1uc2hpdEFMU0tDZ2Y4a3NmbkxIYnF3NTgvVGsvdnY4QVRPN1E4MzBwR053eEJkYnRNekxHOGMrMUxraUlyWkM0K3ZxSGlJZ0Zrd3J1bElVWFFBdTRodERqdm5sdC9YdjcyWFBITC9Gc2pHc2dndWY2UXNZQmMzQTU4RlU4VWZOVHk4WmNBc1lxRStMaVBFSW1aNStyV1RFcFlIOU5CTzVjRFFwdDZaaWRwQzhjTTA3eFM0SU5MVXFvU0RlamxBck51bGZqTHgxY2ljSmVvRkZhaDNsNmJtY01yeDlRM2tNbldicWNObTN1aDBaK2hhWjlSYXNnTzc3YU02eER5WTh0dUdIN21JSFFMamw3TTBRa2JlRWp6NGp6eUxvZldIb1ZBamJEb0VpcVJnK2ExRlZodFlIdUJkc25hZkthNHVBZXBCWm1tOEpoRzJiYlA3bDNaT2lzekZsNjhjMFRZVmhiazEvN01CbVZnSmR3L0N1emNIZGhuV1hCN1FMSUVwK0FsSmxRME1rbHdsdG1JNEticG1DcS9kaVA0ek5rSm1wZHFzOHlPMnZzZk12czFNeGlKeG9XdzNhNTdoNVRSNnVyODlrRnlrdXBobUdrME91MFoxa29WVlh0ZlI3dTIrZEZzaXFUMWlsdjNhSnZtWjgrSHg3SDRuSXVjM1E4enQ2MktJNVordlM4U08yQXlPSm4vZ3F1Y09oelRtQ1R4MkIwd2Z6NHJHMHVRZWZzYjUrclJ2YnpLd1A1WndZbVRMazRUcENKK1k2MGpwRFJERkF6Rlg0WTFlL0FYczFNSjd3RGNxSGpNM01HdkNIdFFuTUQzcVlHZEhyMTlKYmRmbmFwNjV0QlRaK21tUGVTRFN2YXZQVXRYZEVzejNJTGNJQTFFTk5HU0V1YzJ5QmJEYlhjOXNjZHNxNzFaOWpaMGowR1EwZ3gzY2lIQThadDBnWENmS0NPdzgxVFovQm55RFFOT3hOdmk4VEszczBwY0wvQWtVcFNLRTVmZDhqcHdDVGRNbDFrbVVEOTErbGZ3S2ZsbWhWSU9yeUJDRXJWT1FSZUZST1BYS2haVWpPNjdseURMdzdrYlVNMFo1Y1Y4cU1zNk83UVNkUk9CeVl3emxFeWM1TysvKzROK1VRVmRyMjVtNzc1eXk0NVlHejFSV3VaQVpyZkpzNXlqQUx5dCs3aFRGOGk0cmNhU2FTZmZma2xETTZ1RDRlRThyZUlvcFhUZHk5ZnNBUkZra3UzdUs1T2FnUWRKREFEajhqM2F1TlFMZ3hvVzd6L0ZrMkFEaGNpdlZKZTNMbkYwbUJTSEIvLzliZzQ4UDk5ZVNuUWlQVVhCOFlNeS9QVXRyMXpwTjJBaytLbEcxb1lDTktmS0RPVFBxYUpBRVlrbU96elBqN0FFM2FQUHFhMno4MWpJNm1VNkd5SEZzK3hJemlNUFRvaFlCSWJ3RzdUUWFGTnV4c3o3TldjV3NDMGc5WFRJdVA5bkRyRU05YWphYW9ITG9GVE11Q1BLVUEvcGhMaGloSXN6MUhvMmRYV2U3Z2JsV2tQVXlUM0xxSUJWN0RHTGhHU3RnaFg4T3QvRm45c3l0aERBY21iYTZpQW9FMGhKRTExa0tUTTE0TkhzV2I1YzdUMDlqcmUwb1RXbG00aTNTWEZ4MXUxcitWb3dsYUpJQkdwek1wY3JKOEtzeVllenNsb0dwSHV3TGs2dWJQYTVua0I1dmlidFpCYnhzRHFqRzFXbVFNcndKdm5nTHd5eEN4QlpKWkswQnpXMU5SUnE5UCt0ZjVOUm1iSFJDTWFoangxK0xxbGtnVytPdTFNbS9CNzlFc25aQzFqOHUyT0plNWphREdsYlZtTVJqaEt6NjlpOGpadW1hTE1MN1Ewbm10RUpSZ2xpR2p0a3d4U2hKSXhPWGFSUk1ibUt5ZXRtc1NYR2FPY1QzaG81amsza2RHL21YbkwwRE55Q21QUHlTYWlUQXJON1hheC9Pc0NlMDBrN29MQW1yeDJNUkJ5T2tsbE9wcTcvajZCaVpYSUduKzdlNUgyVG1HaStPK21hSTg3UXpRb2RyVm1yRzRZMEtZVVJmOUVGQVpqR3FFM1FRZ2tkVkpDTTlCcENpTnhMV3hQNHZwS1VtWWxLK0hVN0FJT3FOU1cxWndoUVU4aGR2MlBPcjROU2JObkowVFdnK2xkZ0pSdTZzbjFySEdEY1lqTUlUblpnbnBFZHdZMXJSNDVXRGJVdzl2T1hvS0V5akh4M0lUaHQzLzNJUDM5YjBodldDNm1PNlExVktsUk04SjhBZE50SWVrUGFXN1hvMFJtZTNPT29tQVRXZWZTOTM5OUZWbmF2L203TC9FenBmVGRYL1l3STJuK2h5azd0MWhKaStZZ3JkbktoVmJLVTBQS2VXYlMzLzN5MTFISDkvejc1K25wNHp0a3lEZlNEeS9mcGRldno5TDZ5aXJNRFpNWkxlN2UzUzBZL29ER2hQdXBBcnhhNTd2d2VzWXJKMUxTaVJzL3JXdis3UGY4empRaHJveGZZMlltTm5sdC9wUC8rbGtpMXpJUTR4U0lKcW9DUnRiWlF1UTZOSklGdlFMY3g5K2dtVFJ4REg0OFl0dDVvclFkWUtYdnFZc3lNU1RaVlo4bXl4ZC9nN25TU3FnNFllY0kxaC90eUExQ0xMVnBrTm93QWMyQkZOeVgwU24wZWJZcElhZmNkNWVDOUJhMWlDM3JGTkhZenZDUG5TTUV1ekN4TnVaOVc0MElkODhjZ3RKeXJoTDQ2VjZNOXFaM1R0YzQ0WE8yUEV5Tzhia2hyQXhvUUtlSlR1U1dFZndKUmdxZU03RXJ0RU8zT0ZQTE10MUszM1lJYzFDemVIKzErSFdPZG1UMVRlYmpPNXM0Tmg0RDZWVTdlQWt3anhlSktQQXRpQTNXRkovVkVDVFlZRHljRjR2bVJid3kwZW9IeWh4WDZhMzNYd210Q2FDdWt0TXFJQlVBcGRrVS9oMmVaZWF2OTFTN2thaWlsUXFMTGVNeG91bkxVTHNPY3htWGk2MFdwS1lWQ2dxTHBubmlkWkdzZHF0bHFhSEpHS05hSEdZMXpwYVhxMlVtcFFiRWMyQ01oc3hsbWpJengrTmYyeDhicmZPM3JFR2lWakFHdFZYaDVaakgwdE8vb1lHQnpFWi84bDU5MldmbEFrWjVTc0NSbmtaSUc4dDRNbEpEc0N4WUI2bWxPYXdEdXl0VHRPOVFNRWNMcTJjb0pVRmlocWxyTXoxM1FtRm5HMkJYWlIycVpMQzdNL0ErU1p5UlhrSnVrNzYyT2FUMEN1WkZGN1BNZWpWOVNqV0VnbEw0aG5LTW54clVjWjhSZVcrdTA0QXlsdUdRYlBTYkV0bmd0QmloUE1OR2hIVTRsb1JsaHYwWkZmKzJyN0hyaHdtcWs1aGJjMmg5RTFXS2JObjQweDJuSnlqUGNhdTRZWWYyMERBNE05NXJ0V0g2N1cvdXBTZHFVR3pNK3VrOUd2WTlmVUJ1MUhwb1poOXh2RFFoa290VGNKSjBoTWYzMTlJYTJkbk5vM1o2UzZuTlAvczFmanN5Mmw4K2YwYzA4Q1lkMHAxQXA2NGJwcHF5VWFSKzBSM0ZGOWtsNWo3am1VZGdoZkRvblpGQzBTQ2llSmFlZncvRGhSam5jZlJ2V2tkSmtmWVVFY2NYUDc1TVhiU1g3dlVoMnBXYjFiSTZNSFNadWE4eEk1S1A4UzEvbDlsRGZPUGZWQUprNG40UCtaNHY5UC81QmZ4UWZJT3ZaQTBMcXVBNWZyWWpxOWRuQzBXbHdRUnE2UzBoUE00akkvMGFMYWtyamNpa0pGZCtLNkdCR2JXclJ3cERuZHc3TXVCcEhCaWJ0V0plTDdMRDlDb204UVpKbyt1a1I2eXlCZG9tTU53aXRXTnpjNW1jclBrb2dyZUxxUTAyOVpWZGdrdW5PTUl1RVNLZ0toMWhLZGxDd0xvN2RKOTFkd3UzKzF2ck1DMzhrYlNoc1YrYjFwZ09jN2VxQzllT0RJaHJGYUQrTmFFVTlKVnlnemxGUVRRZ0RoeEhTZ2U0Z2JkL01RbnBPRXAyNnNoa0w0bkdxMjZqVHdOcWhuUnMxOUJjY2tzTDFWTWJzYWtoWmFmYXp4b1VsNExjckVkb1ZlRWo0bDZoU2ZBZ21aVFJNSzhOWnNWaWpoM3JZYWJ4V0YrZTUxdUc1MHRDSDVjdmhJVGhtQXZMQ2Z6bUxEa1g0cFdoNmRCWDhxajllRjBnQ2YvUHlaNXFMcmRsUENMTjdUL1BsNEN6dzF4RFVPMkgrOEgwQUVvZ2hocWJFaSsrSSszczIrTmJQMHd0bUJjOWcyQmdaaW9iL1dpUVVXM0FvczZ4R3BxRUNaam11cGc1WGtNck5IaWhtbS9tLzdndVVvMDFpc3VaaTR0citrWXdLUmlXak1EdURLcktTaWMzTWxXUURIQ01EL0RUTkdrajBtSFJHU1psRS9ORXYraUd3QnJxT3l5UU1IbktwZzg3dTN1QkFCS1V2ai9yQTBGNTdtTnJHUDJPN3BRekgyVWh6dXNhelNjMFlMTkdveHFmUmFSNE9YcVM0NVBxWWhLMGNVQzN6cy93c1lnN1JoL051Y3YrQy92RVcrRmdsd1ViQkRabUthakc5QktzUnIwbHR2N0ZNWXdFZzlMeW5Hby8vWXQvL2tsYUp3dTlTdDl5K0FtbUgxMGZIdDVMWDM3eGxPM0Z5cFRqN09QWHdwbU1iMnVXRXg1dDA4c2NUZnliNXp0cGZhNllQbnV5bmV4QytwZm56OE9FNlpPYVVNZjUvdkxsYm5yK2JDOGRIeEFCZzlBK3VZdDJ4dTdRTXVnZmZuZ1JtZUJuNFdDblk4UkgrdG1UUkFxWTBCYVdvc1RuNDg2UHFYVjR3SUJQZVY4aUdNRUhCR0p3QlRCR25QY3RPdXBDRVYvR210YVlTZjEwRWxlRjloUVFFNmZ5bTB0bGNmei81OWVZQm9KbVRBdmczZ3FkS3h6Y0V2TVZwbG5UbGpDNk54aEF1QTNBWGU5U3h5YzROenNmTFhKbTZEaHFEdFlpWnZ3U2YxY29RNXFlb2oweUxaTHRpVzhCL0JLbFN5dGt0NjhRT1YxYWF0Q0hhd0VtTmt0RndVeDZkSThXUEhmWDA1M05OZnlIdEtlbVNrSU4vd1RUczRWWnFWbm90dmQ5aTZvUktCZmdqazBCUzlEQzZUbDl5OWppVE54VXFUSEhFTW9KbkFtR0RCM0p3TVYxNlZnbEpySUc0RTdobGdyNEtrQ2xXT0Q3Y0oxYXdpSEZwL2dWakZSRk5BcjFmS0lvNFhJbmlNSUg0V1lMRlZSVHdXcHNJeVJtVVh1K3Uzbkk1Q3hlekNhU2k1TE5uUUEyaklvam5DZmgrM0IvOC9FK3o0a3dFSWczZXYwdzZBanRjekJyV1RJd0NTdWJWSWdYTklkczNzbERHQVFUTk1MSVo1eStmSXR6elVPWlFCT0VocmkzT3BhU0NnM1BTL3kvQ01jTi9Kek5WWm1DYjVQVm1Bc01RUFZjSmxYVE5PU3pKVWtqRmlaS2hiZzhjc0tDU1djWTVGMU5WTHVkQXhTcDZRV1MxV0EyU3FqUTZvQmZqZVRKR3BIRkNWUnl6VjQxeE1odmd2a1plUzNqMUs2eTJJNDdrZ21acjFwd1grMEVRV0dPaTZaYkc5dCtDUE5yd2p6NmpNdnM0aWs2TUN3c1dVUEg4eEEwcXRvdGZGUkh4OGRJTk9abjZnUjFmSnBJeHlkc0hFSHJFUjNlTTBTSE5lMW1TVk5ZaERsWWppTlJ0RUhHWE5iRC9hMDFEQnNEUnE0Z1FhSzJhR2x5dE4rQ2lkQUpnY3I5Y29tV1B3UmxncDRWR3N4Zjg5TXR4K1p4ZW0vUXVxYU8xbnFPeitVRzZWdGdseHJyQytmWVNPSWYvc1VqbUJmbXNMZ1VteTJZQjFSSnE0em55U2VMcEdtazlNT2IxL2pxNkNSd1VVQVRvTHprL214Ni83YVptanVudEU1K210WS9uY0pFT1VqdmZqeWliUXYrSHBKQVYxY1gwOXRYaDJudmJjSXBmWjFxcTJoZTIxV0kvU3o5SC8vcjgzQWFGeG5EbmZVN0pKaXlFeEMxaEVlVUswM0FkQmZueStsbzk3dDA5dkU3b0lZR0FhTFpnei8yeklOR2pJU3B5WnVrSm83WXRTUHFVOEdpRUl2Z2g4anBQbzl1TGNaQnlEVXpGZjJyNHBkbVUzeG1aZjcyRmZUSEFXbE1Kc2pKbUduNGc3aWxiWVU2K1BoTVlWQjVrS0JMckkydWp6bktjbGJYWnNOc3RyRmlFUTI1cXVsSFhlVTBiaFV6NE90MTZHaXlUL05DTzJPUWM0V1c3ZHRBekN4TWZuN09ESG5hS00vUSs1MzNJdmx3OHd1WTJJdFZ0TEFseXExVzBqeHd0Y0VmdzJQNjVuVVJGQ0lpZkk1emY0OW9JOVlpOWFBTGpBMXRDdHd0czlVYnFhM2dHUzRhK0lmRjJCTUVQZ3JBMlk2bldpdXhTUVZnZ0VzRVB6RXJ3UHd0ZHg1U3N5UktPUFUxV0JYU1hVM0dYQ3pWZWJtNW1wRHNUeVlsNTVQWmFPcjRXL2JEQ042c3pTaTFkUVRMZUVScW5lQXVtU1pTM0FkNGU1MUU0TitzU2NtSUpPd01jTzhtNE5XT3ZKOGNWcUxOUVFIdkxiRUpISzl4SVIyYkN5bFRjb3FZUzJnZ0h0Ry9JcWQyZkZnZmpFSDduM0Z4ekhrWVhJanRqemhmN2g3UFpGd1NtT0Fhc2dEK2RmNFJzUWk4NHg2Z20wZ3FvOG1PZW1ZWmVLWkd3UmlCbWM1VDU2bHZVQ1pscG5IMkJhSWRNVWJuSEdveXlaVzU4d1BTUk4wWTVNME1WRGpEc0JodkRVMnNEcExWbUo5YklWbFRGU1lvYTBMcUpreDREcE1INUNVSFNzUXhKMnFMcEVJUjNESWhmUnUyU0Q0aWZVRU5UWGdFRFRHM0x0THhpb2lTL3E2VlpYcDJHeGdCa1dSbTAyNFpCUk5Uc3d0L2dvelM1RmpoaWhCdzByZWpoUkVTSWo5RGtoSnhkQkJDTU5yVU1HNU5HbGFUNzhJR1ovbk1RbnBDSHRielZ5KzQ1Z2ltVGJvRE1McDdmeWw5OVlzN09OZ3Z3ay9Td3o5U0pVOXNobzROVmZ3dHRRYm1ISDRyVXhYZXZHaGlHdExXQk9IeThQRld3T24zLy9Rai9lTlgweWVQMlg0ZERmUDlEbTFvM3VHa0ppbnl2L3MzdnlFam5HTTAvSHUxUS83WE1VVERub3N0ZWw3OTduOS9BME9ieGZRK1RuY2VVUEt6dnNoV1lPOUppb1FCNDY5YmdtSHR2ZjlyT3RsOW4ycXM0emlBRTRtTzRTSkEyQnM1QjIrTVNJOWRBV3FwWS9lQXRKT1JCUHdLcXVCclJsc2dsVi9pdXdMOVAvZnlxTFJsU29zb25TMlFiTW5rbWp4aEN4TkFtN2NoNFFvdWdYVk1YeE5LM1JlZ3lyaHJqTkh4MStqZFhpekRhTmtSdklhcEoxT3VrTXhab3psakRldkpOc2tHdnd4bVRRUDdCbk9jUXBKTlc4NUVCSGlXOGgwQzBHbUc0dksxbVViYUpndCtnZVRoV2RKSml2U2ZIeUdFSjlENk8wUVpyekhMTzNTQUtJSTNHZ1lzTTJQUmFvSGU4S2ZWNlU5ZmpUcEJjSnpVS1gzVXVsc2lSVW9ld0p5aXdCc0ZSNStwcnFqaUp4dTFyMFd4YUhPaHlnWlRDS0J5c2c1aG5mQktlWm1abXNqWTdBdXRKUWdQQmlIeWFtRHkwdWZEY3NUM0hBVUR3RUJaN2N2ZlhDak5SYWd6UGdmUnN4Qyt4c3pIdnpJdUdZd01RRWMwSStHejBrSm1vaFlFL2ZEWmUyWHpNeE45TURlZnp5T3lqNG5TRkJ6ampzK0ZsdUFkcXZmeXIrZHJpdm1TYVFXRDVsbVFYRHpiUWZyc2dBdGprV0dGWnViY2ZRZ3Zoc0ZMSmdnVGNkeGV6OEhRRkgwSUdrYkFMa1l0YkhSU0lvRXd1WVdIOXdrbXhuRnJ5SFJnaHRZWG5JR01ZUjNsaG9vWjUxQ0JndG5xM0Vya1V3M0pjMnF6blhCYjdZbG56czlQVWY4MUQrTTI4NXlxZTdTWUZvWEFGL2dkTkltZG42cTRMZ0MxTGRmVHpURTBEZW8wdkxNdk55QUpwN2pJbzFreGcxblhSNUozWU1EREVBaGN4NHhINGdoU0QzVGlIcm1NcEsyNWduWnFmeTJHaU9yUHVuR0dwcWNhNkN3bFA5dGJEOUx2Ly9Bbjl1VERWQ2ppejZLbThUZS8rU1c3MUp5bTMvM3hSWHJ4dHBYZWtFQzY5OUdvRlZ1OVV6Wml4NEVLL3JLVmhTWDhJbVNzdjk3RENWeGlya1QvSGkyejFkaGJjSFNVUHY4VVRReXRvVGE5bUg3ODRTaDEyZFg0MTc5YVNMLzhhcHVXTWEzMFQ5LzhrSzZhMkp2c2J2RFJEUG52VHRtaTN2S2xjNGhuZ2pLY05jeDdtT0tyblhSSjlBM2xnOXlzN3lEQUk0Z05nbVBPdG5BeEtHTVF5aEtVTWpSVDFiY1pBUngvOTFqMnZRYWcvTjh0TDNMMXhIMWZZendQSVEydy92OFlsbWNydkZVQlBFZlpZWHBMMEJYcjU2MjlyKzlsQ3JiWE1XWG5LQzF5UEp5RXFjVzYrNVorUlRpRkNuaGt2UzVrRGM3QkNHOXdMMUMwM2lhSHE4UDdCbk5UbDQyK01JdWFHMmpyZGZDaGlsOVFiVzJhREhnM3dxakRwR3BWSW9WRVl4dFJ0emdaK1gweXp0bXBPZkRNQm8xaUxMUUxveG9PeU53Vnh4Q080V1lCVmhHNGdkbUdQMWtHQ2l3VkFycDJUR3FPbHVYZ1VCOE5Mdkt3akFnd0xDWUNJZ0lJSllJOGhMbUNVQ2IreVl3NG9Lck9ER1FVb1NFQlJJSHR1UksrQ3lEemtNVDlYU0llKzVJeWNjc0FzK2FrRmlMUmViMnZXRFIreTR2STBuajQxblIwa2RRNHlqajBsTmoyMlBKOHRTRVpVZGJFb0E2a2VMNGRJMkF1V1pQU2gyWDBSWVpIV2dDYVh6Qlk1dWJmaUlyeTF3dGQrRWdYZ0pDVkN0SE9KdFJ0a1JCR3pKaDRISDk4am1NVVZzeVNDM1dNbXN1VW1iUnpSTEl3WnFVdW80em5PeVkxUU1kb256R1pscS9NQkdWdytxazB4YzF0a3dFelNHN2U1YUh1cE5JQkhqZUJzQ0FUeEIrbUFkK3ZlUmI0eGJPUWdvaEJxL1F2U2VaVGV6cWxRMlRPZnlGU1EvVEZPZml5YkNPaW96RjFrZ0tSZHZQNE4zVHNobitPdFZEQ21VNnloRzlyZ1V4MlNhWkgrb1BvWUdCRXBHZEswRUZPQmhiR3BqQ1laYTEyNlVhZlUzUjJVQ3N3Wjh0ZHRtZElMcTJVWjlMLy9icy8wMDhKWENvdnM1dk9GRzFqUGsxSEJ4L1RuNTkvcEduZUJQM0dxM1FwS0tWdlh1eW5rNnNKQWdscmFSbFRwNDRadzFEVHl4OC9rSkdPS1VISjBULzdpbmJKYkxqNjdMc2ZTWTNBV1l3dlpwYVVqWXZXQ2JzV3Z3TW1wZlQwRjNjeGw0bTRrdFQ2Mm1OSTg0TmQ4cGJRcE80OWdzSGhXM3ovcmhsRjJpdnJtS21jOXg0dGNCNG1mdlR4Rld0MGppTVpzd1lBbXRhZ3dIWWh4V2ZYV0ppWmQyaTlxZzN2REFENU4vc294U3dBSDMvRW5kdEZpSlVRRDhFdmhTYnJPMzU1ZjQvN0VzZjlISTBub1RQaEtYMFo0VmI3OWpscVJFYkVEVVl0RXEyYnhsU1RUczE1dW1IZDNYamttcnBFbzN3S3VBNlI0elBNdGt0cUxzMzh2eVJ4MU1ETTRVRVRuTEhsTWhud05GUnNucEFGZjBoVWtITlA2TURoNXJaOUdnS1d5MmpmNEZzUkJoYjkvT21JTVl2ZmFnWk5pVDloUmk3aE0xdGZXMGtiMjV0cEJ0T1FvZEtLaGhRYWZGOURURHg1Z0xxTEZTTXlXN1ZUZzFsYUVNSktpMG1MVHhvTFlTdlR1NzlhK3Ryd3A3UVJHZHNnbldBS2hpTnhjRWYzV09NSVFKTklEWld6V0xjdlFTL2lqN1VVdzVBQ05zekFZRmc4aE84K1ZCOVZBQjZnUnhReUZ1NC9YYnpNZ0h4V1pqaDVsV1ZNamc4L0dvbG5Sc0RjUWRpRkQ4Ymx3c2FiazJMMHp0Wlp5TGd5Y3NtY1pDSytISSsveVZ3RW1zOTBjY05wbVgvaCt2eDhOVEdIcVdtWEdUa3NHMGJ0ZlZWZC9TdHNBRzNBTUp1Y21aR0dTZUFZK0UxdHhyL3V2V1pVaE9XNVZmRTVOOHFXdkY1QndGa3dFMlEwWmdvTWppendLMHBiTG5yVmREV1lvamU2ZmNwbFpnNFI4NHlVZ0xhK0RLU2tjc2N0eEtaUTI5dVlWbTJhei9HWVdIaUxoMjlNL2xTd01CZVdqRGxMY0xaS0ZtSHd0V0VXdURWVmFKcXV0ZjREMkpRRnRSWThyMjJzd2RSb3kwS1BwQzZNeTJDR2pSa1pkY3g5Z0JrOUlDbFVwdHkySFRGMWVlRzdFWWFNbzRoRVhxQ0xhSmQ1L2J2Lzh3LzBtOEpYTjdtWWV2aEVIMzY2UVRiN1ZOcmZmVWN0SE01OXZCMldEN1VwbDlreGlSTmYyYU43MjJ3T0FUR3cwek9QVDk5OHgwN0ZhR0JmL2ZJdVdsVWwvZUdmdm1HdDZuUlpJSU45R3J3bDJ2Zjl5emQwakJoaDdxMmx6NThzcFcyMkpQdnJYLzlLZzhCNWRxQm1LekNZMXNNbmMrbmhnenZwbTIvZUVhWjNkNTFaMXFDYjNyMzRBZldqQ1RHL0JXZmFwRFlBSlFnbE15enhnVWt4LzNDaUJ5eGhHbWdoSWt5NERXQWVFcUg0SmxFcUFNUWg4Y0pYcG9XZmhiYjRNWDY1Qm4vTDJQeHVEM1RYWFROSmpWOVhReFVCb3dEM3ZVQkI5eXc3M1dnbTJoNUlvck96Z2x1bUhiRVJ4UldUdThSbjZXN1BmcmF0Y29zY3E3TXo4cXAwbUpOaTBLSXJoS2tyOFNZWlZhWjJnY0E0SWZ2OWtMSWVOeFU1NGRqK0lmM2pTVEIxejhEc0JrQ1JJQ281YWQwcTgzVkhidE5TNmdpTGFTS1RDMFJkM1Q1c202aWtUU2ZkY0VPZVkyK3dQalF4SUYzRWxqTENMK0FKZnNxOFNqcFcxUWladjNTVEUwZVJCdTVhWVJLZzZsZVlQMHhXUXBhTFM2QW1ma21ZVVJKaUNRa013WDh5S2htVzU2cWRoTmJDdFpralNzeGNKY1h6anZOZ05yWmo4WjU1QVg5bVdDNWdaZ0QrVmVPQWlmZ2Mvdm84bVl2NVZTeGxNRHdqbEQ3QmEyTHpqUEQwZW9UeHlMQzR0UlBONXF3U1NYTlZRcFdmZXgxQVlCd2lobzMzTTZIS1RQUmJ4YWx4dldQbHgxc0V5djQ3dFVQOUdENUU1Z3RMQTI1b280eFJCRldUazNIbk9TZ0VIRFZ2SE9OcWIvRHV5UDdOSFJnWkMvVnA5cE55N0RyMlJ6aUJCNlFzWE54VXlYc2hRN2szbGE3b3pObEZ1dFhSV2hZV2xxbnJvdU1BcG1zSHFkZWhaWXRDd2p5YUdzNVZ4K2J1dWFyVkRrOEVWZEtxeGJtR2pydUdZMzJKNG1HWnNha1dWNlJFaHlZcllhR3R5dnlxVkNYb0Q1dlVQSnlaRFUxcmMzVTlwS0RGemoyaWdoS0l0WkF5V1R1b0NnOGQ5VmUwWTRtRVZPYmt0bDVGNzdHd3dsZ0c2ZmYvOFUrWW1jRU9pUlVROVZ0SzZiLzVyLytMOU5uZHhmUkx0dHR5cTYwcit2aWFrbUcvOXliYm1HM1FuZUR4dlJVQ0ZoQWtIVkovK0JIbitnZTBJalNpejU3T3A5ZHZEdGdYa1lSUnpNZUgyL2hoaU01YVh2TG5iMXRwWm1FeVBTWTZPRE5vVUxQNExqMzZuTjE5em85cDN3ekRZbWZyTDc3YzR0cDllbXp0azMrRjFvZmdmVyswOGZ3ZG8yL3lUR0FBL2hpaDF0d3JFelRSVldMNmpNeENMU3MwS3Y3cVJIY25JVTFGY1VwNHg3a3NiOFp4OEptWHErMzNqRDhaei9sLy9PYi9nbUVGb29JVjNEY0VyY3dmZkZXaENMOVYzRHN6eGtqQ1JvMEpsd1A0WitHN0cwZnNmanlBYWRrZnpOd3FYQkVrVlZ1cmFOZUZEcmxjVnpDcWFMZU1abnlKT2VnbUZuNi9RaE03WSt1M0U0U2QrVmd0em0vUysvMksyc3dtMGNCck50dTFkT29VUEhCTE1UczR0SEd1OThtcUx5QjhUWG14YXFLQXY4cGs4Um02Ujh3U1BiZEJZWnQ3SHU4M1lXcjZzZXhiVDlvRDRXTTExWUN2c0VZclR3UTJ4TlVLRE4vNUZ6L2RtdjJhRHN5QVNaOE9WSVRFQ01jN3BEQ0JjeTdQdVNqR0FBQS9OVWxFUVZTcnBrcGdKVWNtU2p0R1RxZ3hhTEtwTlFGVTdYWlIxbm9vTlpsZ1BLNkx6K1Mzb2lJV0lKdHREdnFHTDhyck9KdHo4cXJ3TXl5UmV5cUJRUGd5QkFPdDhGd1lKWVJtMkZNdHpTYitNa0Y1a3NxZXpDb1lGbmN6ZjBqbTYxTzh1Nko5V0dBN0lwUGxRTG9SNXBZRjFEMzhSME5NTW9uU0VEeDR4Wmp6dUcwWmJTR3FPUzA4a2ZGd25HdjZKdEk2UzZTYTNUVmxkbjJSaDZmSjAyUldNVytlbkprZjkrRjNROEFqbm1NVVUxM01qZ21HZ25zRjBqQmtZTFRpTGNPd0lzb1l6OEhNdy9ZZmtnRitUTmxFcis5MjlkUnlvaGl1clpEVVNNNE02OGZ6Q1JnZ25kd1F0QStCbVptaXllaEdtdnFRd2xjWXJnc2lzT3hIMXlOc28xWVZFUzdtdWs0OTJoTE85aEh6dTZTM2VZdTMwUmdkcjJwYmJxZ2hrdVJySUV5UXFJRnZ4RXpyQmRSOVRaQTJpTnJISGpVUU10YkFSeEt0RVVYK2RlbWoxV1l2dXk1RVVxZC8wc2JHRmtSeGszNy9qMzhNMk5uZ3JjQnZNNU9YNlYvOVY1K2xyNzc4bkk0THkrbmhRM0xKV1BObnozYTR2azR2cWtzS2ZidnBsNS9mUjZzZzBvZjB2Ymt1cDJjdlBoQlZ2RXgvOTlVYUJkU2o5SWYvdUU5N1puYWtmcnFBaWJMTTJDcnAzLy9qTituNDZveE03RVFSOVJ5bXpWNzY0dTRtV2tJci9UL1BhUUI0YnlGOWpoL3M0MTR2L2FCWlNlRjA1L0JkMm5uNUREUmtFMUdjVncwamd1Q2JUSW1KTWpQV21QOUpCNUViQ0F3cHBnTVBLRFZDRUhJMDhDRmF1NEFEYnM5V1VnWEdMeGwwRnNKV29TRGlpYXNRZWF5Tk9PT2JROXc3dXZpaWdSWjQrRGhGd3BJeWJoSVludk1DRGNUa3RCanBWVUp2azE5MkNkeFBhR1BzM29TV3pmUVFoRzQwYTBUWjJrUDBCclJsL0kvZzBBaExTbHJvM3JRakM5MU5jYnVYYnVtR0w1VHFoZGpRZ3F4M25lZ3QvSUpuNUxxNXpkc2xPVzVxd2NSQTBqR2JYSnpBdE01b1JYVEJlcDNoTzdXOWxEN25kdXNzSXR4WGpPTUFabGlnMCsyQVFGR2JjMnBVdkdqYThtQkFpRElEMDV2a2U0bmNQZnV2WmZpcUdERzN4MXRUWDl1OUFPZ0FPQUFJaDFCYUNFZnV3TUt3UUw0alQ0dFByRkpza2lEelVZS3dhSkpzamx5QmZBQmZiY3NsZFZIVnF2eHJ6M0s1cDM0Zk5SeFZaWitEZ2NTdjNzUFZoN253VjZkaVVkT1R0OGpCLytJYzd4Z2Fnd3dxcnlqbk1rYkdIZjRzTkJRUFo1VTdhelZlNng1NCt1bWNjRGJuMU1CQUlNYm0rSlZ3YWdualYvZ0tJQloraVVNUmN1YVpnVnZBb294cDZqeWNwMkR6clNhbHhoamo0OTQrTC94YzNFUDQvSlRuQlRLcVZaazdBN3NMUnF5S0xLSVBZYXJESWxLSy9LRlVuV2ZYNDBxNkJCbDZuRy90NWNPSGRGL1lXdVNCWEl1VFc2M0lUVWRONklzTktHRG9ROFpoYnBMU0xCUXBqbG1qcU0vVjBoYjdVekc2MkRINS92MXQ3bXNtdk1jcHM4QjhpTTA4MFh4S21HVmxLRHpXR0MxYVNKUkp2ekJEWGZxcTAvckZycVZTVFEvZmlEVmk3aExrRmxacXRVWkZDenhiQWxXYTIzbFVmOFh5OG5ZZy9UZC8raUhHRFFZQlVXQ0ZiK01YbjkrTFpNYUpFWnFlREo1MG0rZjRzSTd3bmNCdVlkaUQ5UFRKT2o0cXkxUXdZZXNMNmJ2bisybnY0RGc5ZWp5YkZpbjBmZ2tET3FGMmNvYnVtM2ZwYUVDZWJQcm0yUS9wUFJ1ek9zY1p0MnR2Rk5JRzBkVDlvMDc2NDh2alJKd2lmZlo0QXcyaVRJVHdlM1RXMDNSMitDYTFhRXlIZ29sMmlhbEhSRko4VlFNTmtjc2NzKzhGL0JMLzBDSjBsMlJOU21iRldTSU1MMUZZbk0rMEFyb0lRRlloY0pWN2VrS2d1WWprTzc3OERkN0Q3TVFoejlmbDRPdHY3eDFhR3JnWVZnNTBhYzhwQmVRSitXU1c2NWlNSEtrUDRKRWJ5OFI0d1Y4R0dRS3pFdEZuZmNRR0R5ei9zZUVmbXREOE5ENUhLaWNvZzVwQjJFeWoyWnVPMDRPcEdHRzJkNXIzUDJML1F6ZmhkU3V4S3hqWUtlWjdDNjNZNm9RTHlubWE1TTJkc2FYWUpVendnQ3FFdmRNUit5YkN0Q2dyVTFOMGh4MERLcWE5dUVHd05haGhCYkRldHBMeXMzbUxRZ1J6bklGSEI4OE10TWdyZ1Q4NUg3V2lyRG5JelRWVE9KV0xmSWhNSVpnUGl4SlNudEMyQzJoa1FTYWxkRGUzU0NDYUFtRjVSekN5VytZU0JNOURYSXJ4eStzaUNvSzBOandSN1NUNFZNYlVra0FaRWFvaDVoUVNXYTRyc1hoNWxKUEk1VUExcUI1TnpJbUtDSTZWUllGSjJHMUMvNURGbFZWajAycUhYdTVFdlJKbTZrdEdFdU9RTWNtUTBUREdoZGhHTVlURUFLbWg5ZWx2NDVmbXFZNTBhNzlFT0FrcXY0UXJKaFBQRm40eEtMVThmUjloQnNKc3FIdExMTTRBOWJtTlJPL2doK25qNTJuMU1ER3RJNk1mMFdlZmI1TW5oSCtDN2dhV3dMaU5reVpZTkRRazMwc0VqazFKR2FHUnVwc2JtdlJoaHRucnZZQjVZQ1JHS1d4VXlITWJ0Z21objVVT2NnY1dIU1B3UVExaGxzMVRFZStBUEtjaG5ROW9XMHd4dTlzekRhRTRtV3lZZnhDbjF6KzhOMDllRFltZWhMMTM5K2pscmhPSWRSQU1hcHhHaVdUV2JUNi9mM3VjL3NQdnZnR3VKSzJpTlpxRU9acWdxd1BuREtnWjNIMTltQllicndrQU1ET1k1WWc1VElLd0ZlcjRqSXA5WlBPSlYyLzIwNE1IZHpFalJ1UVpOWEM0ZjVMK3gvL2xnRFNKby9RUC8rcGVldkRwYlByOXYzdVhmdmVQQittM1g1SXBqMGI2My83cmY1NysrLy9oZjB2dlhuZlMyM3RINmQ0Y0FRRmdZNnFGeEh0Szh1VWxUTmZOSmdZaittV2RvSDJmZjBTall5YkFwaUxPaW0vQlNJU2ZIVUUxWVNDNndGbHdFMkVEOWdCSzFoWGNjVTQvQ1VoeE1TOCtlQUZlOFZsZnBnNTZVY0pTSDlnTm1oRWdnYWw2ems4dkhndjY4aXR2OE5xSXVZR3d6TEF5VGtscjRybGp5c25ScExsUXAyVEJzbTZCSVc0RUJZOFBNd29jK1ZvSVFMdDhWRWdDcmsvT0krUmNZNWdxS1NUMU9ScnJJWnlzVXFoTkxTSkVFVnd3dWlvN2ZjY080RmdmYW1jOXlyNDZhUGNXcW1zeG5MaWpEeldyQStZN2pTOXR2Sk8wUE5rRTYvbzArS1BTME1VY3g1M2F4WmRXS0syaFhSUDB1UGxBb09Na0dLUStyU3NjOHpLZlJsMm5QanRURzZKbDdpaWJJRDRQY0JFaWF4M1FtSGNUQkN3M1IydXhLWmpuQ0F3MTMreWMxbG1jSTFrNWR3bkM1Ris0aXdQeStLZ0FrSXVtMDB4aXlrVEZOUXdrTyttNUI3U2JYM0JhRjBRTmhJV1U0UFdmcVVubEJuaHFmajRUU0hGZk5aalExQ1FrQ1lOcitNT0wvekZXRnpDME1PNW5MWkxzSThMNU1LcGNGYys0dUZmT3RzMWFBUU9ONjczT2NMMWxCaUpxK05PY0IvY1VhWUo1YzY2STVibnhIQllsSjdEcTBNNWp5Z3hhcEpTQmVuMCtIbnUyUVN4a0hzQWcrWjlwRFZ3UCtvY3AyRUd6MEg4d1pCNDZLeDg5SnIvb0laR3Jkak8xRUF3UmpRTFNqbjI4TTdiUlJRWVNZN3pCS2E3VDI5S1NRUFJiV0VodldmdUVDUkE2bGt3c1NJM3g4Nk0rdmh1YzVsM0cyVVYxZjBlSGh5c1E4WDdhSWhsMU5zeFd1R3NrL0FWeG9sRlZ5emRwZVVtTmN3RW5hUUUvRU9rR3R2TU5FeDdZd2FoalRWd0g5aDk4aDU5cFlrUi9FNWgxcVBneURlQWprMnZTYVdEdjdRRTVQYmwyN2hMelExTnpBSmZ0c2I2bk9JUGY3eHppK04xSWMzYUd3SlQvL1BFS3lEeVpmdmorTVAzRHZ5UXY2LzVNK3JmL2RwaGV2SEZuR1p6dHl5bDkrWVFlOEtoUlI1ZEYrbXhkcEdtUStBWWk3d0YzVXpwRXFRNWJpVFdQZHNCdm9xb1VPNWNIdEpGQkU1THhDczlldngxNHBtOUt3YW5HWWg2Zk9PZ01NdzBobEptbitVTHVCaVUraWZQaVVCSFlxdFc3WVFNWHk5SllQeG1lMmYrc1A4Y0dQSXpMZjM1eG5lZ2Mxek9XRUFBYzhMQUNTUGVJZE90THB1VjNMYUJUTkpndTkrdmkyelFJb2pYamZmZ1dPVlptcXR1YTJyWlI5a1NyeFNZa3RNUEdTVjVHRUZUUVFIV2ZsQ3NJcFJtU1RxblFNRGZQWk9pU1ZRZzBOSVJ0c2wwYmZyektmSHlHYjJHNjQvY3lJa2tIMjJ0U0VQU0hYK1BIbEQ3TE1Ld2lDY3pDb1ZhZ3V5d3RpbTRvRzd1NUpwSU00eE9tRHRMMW1LS1JmbytXTngxd2I4RFlCNnkxcmdvWk84d1dRQUU0ZVpNRXBzb3JiUW5NeVRKOXRTRjJPeHRFNkZUZ3NWRDZpMXdnVjBydEpiUXRQdWNTRFU3aUdoTWUxWHhrZkZaeFEzNEIxTkE4QUw0YWsza3NtZzVlcjhybk5sVnlVUmRaTmRDTWNYTjZHQXpmVmNXTnNHWEdGMFRtQVBqWmNjdmtURU5nWUJ6am9NZ2l3akZoa2NLTkdDSzZ5WUxLMlBTbDViTTRuY24zek5hL2ZlbXZVcnMwc3oyZWpjbG1XeHhUTStKWVROd25DQUFaSWx4WFB4aHprSEh3UkVIUE1DQTR0QStqYlhaVmlFaGpYQUw4MUxKY0pNYktqSmsyS1Ewd3FqNE10VXYzaFFGTVk0TU9BNy84MVZPU0FVbW1LNXltSHVVcmZScXFrVnJGWERIbDhCOFovVHNqMnVVOUxINkc2d0FQRWpsSkZwMEZzVnhrL1ZCS1Z0TTc5Sjg0WHgzLytpUTFLZDNhdmtVa1NkOWpsV1RSSzV5ZnJ2Y2x6T3lLYmM5dmtORDMwUmdLSVBnVS9jQW5rSUR1cmpKQWlnOGg1QUh2U1JJSk44ai9rc0ozZHRrYUhiVSt3MGNZU3B3c0xXdnBSZ3F1eXdoR0ZRTEdOVklFd0VDRllSdm1WTUtjc0huZFRjOUlLZnYyVWZBY0xVcW9JWHo1OWowbXhpZVlKcHlPTnJCR1I5QTFzcThQZHRsMmlpNE5WV3I5cmpyQW83bWMvcS8vOEN6OW0vL3lBZVpjSzgzWEpDWTZpNzZtMndMRjE3OTZTR0tqVEFLL2lheTdmYktiVHRpK2ZySi9ScE1TTnNvZ3EzMkE0MWlzTUpBUkRCNmNNZjNCZFZNSTJqUE9zWnRuWjRaK3pzUGpWOWFtaXorTkh3S1haVGdaWDFrZWNONGNvODQxNWhkYXpBMUVqWThhMzQwVW9wQVZuMlZLd0puanZsZ3huaWVkb0JWaHR2bE1ONVAxbnVidHFWa0I1UGh1QUVibnVrbStDZ1U3ZllwaHZteU52SVI1WjF0ajZ5eGpmRHlINGZDZCtZQmJrMFJXaStSWkZVeVJZRTMwMzlWZ1pCVmduZmRJUkNERFFOeGJ3Zk5LdktVQnk2czZ1Qko2K0dOVGtScFZOSFVqaUQzbVl2ZGE5eE9vZVM0K01yUGQ0VVdwdExXZHJrOFFmVWV2VTJmM2ZWZ0FIWHlOSXlMaGtUYkRLblNvSHkweXp4ckNVRzZPUXNUTndqK2poRldWVmIwMGxKMmRYVUhrRE1oL1ZZQ3RScVowTWwzZWhaRER4NEo0UHdhbjlKZUJ5SFFrVUluWlhsVWlLS2NIWTNFd2FpZnlGazFRbVo4TEpXR1pOQ2xDaHhtR2s5dU1kU1dFT1VtT0swcEx1Tlp6c2tiR2hWd2M5M2FoR2FGYVEydyt5WEdEQWpyTmZSZy9jMDFldkxIZ0Q5YmlEekpyeHFIcXJPVEhpbUUrRUNWanRYV3p6Tlc3YXlhNjBMNk1QdVlvS1RvQzQ5WWt6Sm9xcStHRWdLdE55blJtYXI2Wm01VG5Ld3FwVDNrZlA4dWtxQk16bEkrcDFDZUZZWnI2cjkvKy9TL1lFV2FkZktWM0lEVHRoeWw5cVVBa1lXb1RCajdCZDNCR1ViQUN4UWlsekRreWc3bXJTSHlOWmxDSEtGd1BYNjZKODVOZ3F0VXBkcHhwa1h1MEMvR3c3NXdGeTR5L1NoNlhxcnpGckNNSTF0YTVlMnd4MVNJY2ZvNmEvdURCVmxxWnAzY1ZnczdrVkVERG5OVFNyWklva3pWT0V6OVNMVXJGdkdPT2RXVGVGekFpeUlDZHBvZUJCWDArREd1SVk1OERSUFRRVm5DSzkra3lNQkF4ZUYvQktMdUZjMUkzektBM0I2K1gzbjU0VHl2ai9iUTRpeS9QYmdEZFN4SVVCK2tRaC9uVndYVmFwUk9talBQZytJWmswaGZwTjE4Q1MyNVhtV2lEMDVRUjdWNUQ3SFEveGEvVG9xVEpOYklwM2F2di9waGFCd2RwRGcyaWpMK3FRY2tJTEJHTlYwYkFPV1J2U3d1Q0Vtd0F2OEJieHVneXkwanNIUWM5SVpqRVJWWWJXdUlYM2hudXJvRzBJSjVhWTZyR1hlSGNDa0lpVERQOG91Zk1KYnJ1S3FSNTZRY1RQMFJQMXk0WW1WZ1ROSmZwUmZ4VDBJaUxEa1pjTjZJNGdlQlR5d3ZsZzN1b0tDeFJGclZpa1R0TXlGcEljWnI4ZCs3SW05OGhYZTdCUWpGSFZnVDNJOVJPWHAxakRRdUxqZzBUYUd3TmR1aHB3SUFzMGJQa1NyekRHSUZQMlRaSTN5eTREWDh3b2oxQTArWXFqc0ZrY1QxTmNYdVZBU2libm1Ud2l2V3RkSE5RVEx2RFEwejJEMkZ4T0d2eDFFTDBDYTA5cnRaeEwweWhIOUwzdVRGS0pFeUJzQ0xBdDdZUVhzdUVzNDlFNXFRNnFYOUhwNnA3MitXTkZTQnVCdVFDYWZLSlo3YnRsYm5ZUGNHbEhRRVlKNnQyRWlZVUM2YzZxei9JblcramNad0x3dW1jQmxQME9oQTNiSGtteEVoRWFGWEpDZjFBSWhEM2NFbXREUXdHZ2FUTURJdURmSEN5VVJ6TW1HUVFqdDN6QXhDYXdveEZjN1dNTnVEZjRDMmNwNXBycDAzNzhPQUY0RHhPNWlMOVZyWklFWEZ0MStKOGZZc3NTamsxeEFKajBLK1c5MlR6cGhBeWRyOXpVaURZbmFBSFhCQTJURlJ0VWliT0Z4aU5IUXpVeTY2UTJwMG9DWExuNG5uMjBLTnBIVGxIRGRUdTQwTjI1cjBDWm1nSlZzb2YwTzdXelN5SE9zaEh0T0prZzlSY0FhQk9BRHZFSEhKdndNb3lFVGJtaTVoQmFvSk1TRjlyQ1M5SUZHeHpmUnVucUVFWGZWak9wUWVqczBWSVVXMkk5QU5obzZCUUEzdjU4Z050YXM3UzQ0ZGJzUUhDTkNGcVd5cmJENTRiQUNvWUh1dG5HY2RkeW9QT3p1bnFjRWduQ1p5d0kzRU1vdEQvTWdSdVEveDI3aVpjQ0liRmRlUm9WVzFlUlJEZ2hod29jNTFhK0pXYUZGY3poRmhQeloxTGNvZjI5cHJwaysxWmlJT01iTkkvZ0V4b3ZxVTZHdWx2dHRLL2ZOVkwvOVAvL09lMDg2RlB3VFRNR00zaHBnekRZcU9MRG1PNXhMZHpUck82RVEzdE40b0htQ3BGbk1HbnFZQVBwVmJKUWhMa1lrNlFNa1NpMEJ1UkV5YnVLOHpVZGtSVDhWenRpNkd5eURBSEdKeU1RQnhWMmRmWEtzNm9lWmtaRDh2aWQzNkFNOWRZZSttcG9Kc0ZKTEZzYVFSZW1IWmdmcDBSUFpPRk9SbXNCTWZBb2Q0dGJhazBkUEIxYW5Xb1BPamZtMEM3TnBVR05HUU5MSEd4YkVzbXFROUxIeWZyamhaWUpTL0tQblN3dUJDeU4yalk0azBKQnR3alhXR0lielNTaCttd0txTnM0cGNxME1iSUJnajZqNDBNVDFFNDNjQXBuNERyM0FKZExSQVNVNXk4aU5hMlFKM2lFQTF6eERybnJIcEFJODhBUmtXNmZFd05pSGdEVjdGMHFJRFYvR1B0UitjSDZlM2I3eGhYaDRBT3gyaVkyRWRvMUtGUmQxbnFJbFQ3QkVWS0JTdndBYXBSaGNqV1p0S2FHNlpkcVM3TFhPem5MWXNvTUNCRC9VYTBLanBGTVJNd0xibGVKcEcxcjd3Qmd0eUhBWGxmcmpXYUZlMWd4SDdlc2dPUndhMnJESGVIazlGRjUzd1ZHQk1QalVpcHRaamRicFFqY3JrNFJTZ3ExV1VZUWtHcEYyWWYzMk9jTEo1YWt5OVAwZVJFN3ZCTjBhakc0Rlg1TXlzWkJPbTVvWGxCVU9ZcGRkV3FlTFlPVkptU3ovS09TdFRNckVCT2lFY25kbTZkSTBLcDliRVFTQ2hINWt1NEZDRklvNHg5bWFNdzRYalVKbkxjYkhXTFdIMFBRTmcrendPOVlNejlLRWd0ZzJEV1pOb0ZZblY5RS9ETXByLys1VU42UmJIdkRqMjVvM1FLUklVdmc5VEFDa1FQTTFRNEkzVnZ5R28yTXViWVpkcEZFR0JFWjBtZDV5MXlyanBrd25NYTkzRzB3SkdCMndYU0F1dFpkbjIrdVQ0SExoSUQ0Mk50cnV3S0FSTnBrNVBqRnZRUGlUSk80UXZwNCtkVVFMam9NaTAxTG90bkc0MEZ4bDVNSDlueS9ZUitYRGRRa3c1NEJZTnJEVXYzd2J4SXJNSEgwV2hNc2U0S0owaWZ0d3pLdFIrWFBDbGNibUF5TGJwUG5QTXUwcHJtSXlIMlhVelFhL3hUci9DZlBmMzFPc3graW5TRzg5U1JTV0FXWFVLVUJnNjIxaDl5emw5QWZEb2VrR3ZVUE5oSk5RcWxyL0g1Vk1IVE1oSGFJaHBEZG1xRHorQ2E1ck1Ka1JFNVYraEEzQlo5bTBzb3ZFeHNEQmphS2lVRE12QzVqUGxqbWtwWUFjQW1vbDZzZ3NTcUZRTlNLSWR4NkR0WEZBUStCL056anRHRFB1T1B1Q1JEYzBtbEtWMFpRWU5xUXNDOUI2N3FlZ2tOakJOTUxqV3R4VjV3RmM2VjhSbklxazdpcG1FdG91SkVvY0dncFU4N2JKaGdQTGdVeC9NY3hQUHdlN2t5S2lSRnlxTElseW94VHYzS05jdCtZRllqQ3V4clUvUWRzMm1rNWlaYmpLM1F3cVkremVZWTFJeWEyMmdhakluSDZFR3NObVl3cHFLTUxDd0JlSVl1cHg2Q2IzWDlEdDBoSHRCNzdCSmVBbzBERDZzMkNyZ2RHcWJZVUVxbFQ0NnlLSFE1RXZkQzBxRmRHSFZTclZXTkQ5T0lTUUE2ZnVlNHpPQ1dhUDBjRHV2NHpzU1l2RWl0ejJxY29Na3pPUTU3OGh5Um1iL20vQVFCOFF3T3NGaE9JRit2NnVrQ1Era2VRRHBJL09nZXNXQWV5NHZIZytOYTcrMzUvdTY1TVQ0K3grSXhQc2Zpc1hDVXc0eEVNQkV3a0lEL2kyaU9UQ1FDYnZHN2pzOFNtR1EweEh1T3VKODlxU0pwVGF6aTJSemk1WHlZVmY0Q21iTDR0Mk1STGlLa0tqd2NoM3RraHVoenZEZ3pXMzVpcWpKenB3dzdZeHd5NW14bUl0QVlVTlphQi9pa3pQS0g3TklQcjQ5SWhnU0d0QXpHbGtBaU1qWW5oalk4aVpsblRwUEVwRG5Sd1MraVpxaHJ5NWRDUTgxVzVMY05qSkphODlEMnRERUlqc2g0bW1mSElDRzdMNE53MFpLWkp3ZlRVSnRpVHNkSE1BTTBybFArcnEwdFU3OW9STmkxWkxXczIyUU9MR3ZVM1MwdEVTMEN1UmZZME9HQUxjVm9md2VkMFhVQWdMdjltdkJFVVFEZVhJL0ViV0F1VldWV01Na3BDblZOenpobW0zYlhVQnhFT1dDczF4UW43OUZscDVlK2ZkNU1oeC9ZTDNFMFJ6K3JGK2tYYjVkaFJFMXVTOUFFUDQ5TjhMcmtFczAzNkN3d3Q0b2lpZ0JZTGtjdWxrNzJHdEhaaHY0WnpGUUZXdGZ4TUVZM0FqRUk1VXRhNkt0OU1BYmJ1OFQ2QVRJMUVhc09NdjV5Z0pmNHFKQzNybEhtSm43b0pybkdJZTExZmRheVNPMmROQksvODB6UFY0aXJ5V2hXdTI1RE5HYVppemhqTUNmSzUxZzRtYmg0N3c0NUNqa3U1SlhISnFOMVA0YndFeE54VnZQUHpBTC9FUXlyY3JzK0Z5UjhDbTlkRkZka25GL1F2OTFXMXJJVXRlbTRvempGelVmNE9SazRXcEthSDlhRjBWVnFMdTBvRWswdzZWMTJBc00zTisrWVJNRmp5cWRtcHp0b1pDZG9jcGpqZksrd25tcHdHcCtUd01OY1RYMjFhb1crU3hJSWYrY1dsMm5uamYvdnFoazRyWTlQQTlQQVMvU3VnK3ZCTGJLMllINkcrQU04d28ra09tbCtVQXhXWXVlSGdjNHpnY1NEZzdIQU1RV3drNHpJSHIrb2tmalNieVdSaDNuSWcwSWJBSUErVDM2VTdYbHNZQ1NCUHFmOGtzaXppdXp6WE1qUW9PRHlTb2tveHZURVcwYmxSLzFPamtWa0dFZnRQQjZNUkFTQjZVaVUzSmhSeTRoZGRNWUFva2w4TXBCNE0yK1pocyt4RFFndzRscm5xaGJtd3NtbzhvS3FWYWxkK2N6eGZDVyttRG5IUlBPTTdHcFZYS01tSlVNRk9iTy9Rd1pya2g1SUhlNHVuaGZTMkNzWkovNmdhVlJsYzFDaThCUC9pUnQ0ZktUV2E0ODJ5TzRjWTU2V0xzZzBwR1V4WThhd1J5SlJEQTBDOW9uVXVKNG1CK3JIbW1RTW9wL3dNWWZzQnFkMjlBNWpYam1Jd0dUUk1JU1BhNWJUT0FpNjBHN0VOc3RESWpmeEtOWk9JUWIwTUUvUk5Ocm5hQ3BkbXVLTllzdXBCamxPT2JvTEkrNmhBZkZjYStvcWxBbzFDSjF2M2lYU1daNUxyOTd0cFhldlNDVFVUeW9Db3lLT0lHN0RkWGpYZ3BnMG9LWW9RcDZsY0hEWWJRSnJqc0JrRjZpVFhBSTJJODZGWTBUYjNnN0p0U09jN2MzalF3cWE5OWl5ZmkvbVpVNlJWc0lOZFhIYksydXB4L256K0tzbThXZDllUGtuQ0lOT29vbitWaUFrK2k1ckJpcndMejZJSytCN21IVE9tTG03WnE2NVFqQUVKUXhDMzUvSEJIREdFM0VsQzFMK3hHKzZOK0k2OE5Sb3NJUTJJb29yZmpOWklycFhnWmNGbWlPYTV4VHBGc0N1emRySjZMaU1OMHdLZkpXQitWbTNoKzJDYk9zY0Znckh4emp2V21jekVMelJnZ0dXd3RyV1R6SWdhWEhBL2QxazVKUnVvcEVPZ2NBYnNURkhGTjA3bWZndjA2T01yYUJGcFprSS9Bb1VQSnRmTUsySmlEOHdsUzlJUjVoai8waDZyOEdzNW1rTWFHTHZETXlxVExLcEpLYndxMEV6c0pMUXlMa2g4d0ZmME56cUNONENIVXF2OEpsV0orbFFTK0tweWs2SmNaWUo5Q1FpMFNQZ3JFcGFHbUFMRDdHbjdRY2tBUWhzVlRLaldPSG9nc3ZKeGN4ZWx1UDdWbDNVMUhHSFg4MGVaNmNUM0VKWkp4cWFsMHhCWHNDQjdDelVOUEwrYUR3Z2c5TGVSRU9sbDFxV0JPUjVSaDhFZktSWTNDN0NtRG02U05BVno5RFVVbU5TU21neTVNOGlrb3NYbWhiSGVGZ3dGaDJKa2F2bDd6Sk4vc3FLbEVobXJJZm1FOHhWNW5mTGJFVmlwSlV2dFF0dXhwdlpjRnVacWt3ckpDUFA4UGxHYlhTNmk4Q3VrR04xM09IYjQzY1ptMzRzZjlOQm1wR2VSU0dhb3ovTEdzeUNFZ3dHYVczZjlEUm1EVnFJV2NscWlnUHlzaTdZVUVJbU5yQ1FUaWJNWE55OVdVVDUxUmNQZzNtZEh1OVJvdktXdkJpeW5kRW16RFJ1Z0t4NXZtcU9iQlpBMU5JcHFiSEl6TzNQMWNkM3ByL0Q5VGZWNG9yUS9zejhDZ3lPS0tBSXJna2lIcmpBdkQxUFg1OW1ZcCsxdXdReE45eDZDc2RyRFFrY2FTeEd6OUFTbGZTVGJONWFvMm5nNVB3NjV1eHVNSnpJNlFFYkxQdnFRclQybHAvR29RdDB1UTRmM0FYNVd6UUoxRDhSMEllUnJ6S21SY3lPRWhLL2cxL01yYXNHK0xJTWlxMnVzUE1PdnFqM3I5K3o1RVBNNm1tNkNreW1qeis4VEt1Ymo5STduanRacEN0RGo0VEs0L2VwVHQveklwRlhrMVJObmJGS29tQ0lIZndRVG5rTlJTTUZtRGlUMTlyMTlpVU0vQnkrTFA2T2o3dStSdm1FVTNhSS93Mk9NaS83bWZ1Ym5SSFVJckx3UTJzUnBtaDJPc0NuTUtYc1Q5VzJ2VERNN1pMRXpDRytUbDBqQnJOa09vQU9SbzA1QytPelNhUlJXUEgzR3Z5b21Wb0JVN2VuZjRWZG5pZnAvZTVZRE1ZNnRndlc2NXl5bW5PWXViNDExeDhIb3NPS2VUZ1hIc1VYZ2dQNEZYVlcxRWh2QU9SRS9Za2dvbWxOeWdOQVE4ZDQxcVNQZTQrbWZWeHZsOWE2TllJbVFHUEtWZERHaklaYTJuT0JJOTI2MStUdlBwTzV6cE4zVjhOUE5jUy8xU1BGWW9pbXFhUGQ3Z3c1bFVMR1JRUVowNVg3RTJseEd5WTRiNDhJZ0JxVVRuSXp0dTJNQUc5blFlRHNJaW1mUGU3THhjdC81WjYzakE2RVZnV1hPWGhXTUFmUFpjSGhDL0VXSXVPRlpqamNHMlJqRkRCODZRSFZEMlFYT2J6ZzlpWENnMFBCNU5UeVpHZ0MxTGVNTHlSTEFKZTc4NXNNMDJ0OGpraG5WaTRVeDczVk5ESUQ5Vmxla3AyVmFEczRvNTBqZzRZWGNCNXpWcVBURk9NeHNkZzZOVlZSK1JydllEcElIODJzdUI4L0dQSHh1RzlmTXFDSTZnQTNRN3d5eDlDMm5DT3JQWWFMR3FyM0VNcGVLa0lPV1k5cittaXIwL1FNR1pNMGFrWjQ2cE9halRTVUVadHNXcVRCM2NMeUxCbmNzK25lbHYydzV0TWVWZlk3SDNHcWs5NmdCRFVZNHJqREp3ZHNuSk03QTg5VDJTL1R1cnhDd3NFd2JHOHM0bXVTV1dkby82dWpJeloxUURBWXptWTZRUlRpaHV2cmNVUFlQZHRGa0hSNVFjNkZIU3VuYVFKbmZaanBGQ1ljRm5Da1Y5RGF3WDNtZEI0TXk1UVBZY3FYWUZZbkIyZzhtR2lkNmcxbUlUalZKMDBDNGVEQXcrekZORnJBMlR0RHVjWVZHMWdjczZQMFVmT0lXZGtyaXpwSDJzcDhlUGNtTnZnc2pJQUhoZG9LeEhickhCT0twbndmWDNQUHZYUnp1cE1HclFQbURRUFBRRWZnNDZkQzM0SXVXUWNGTWd3RU0wWmNVc1B3dXkvWFRtRXFIS1dCS3FhTXJoQ3ZDWjh0YXh6Q0NUaEZiU2dTRmt6aXM5cTJ6QTJ0bHpsbmhnQkZJU1RLcEEwd0JUUUswZ1h3NWNHRDhJWGlLRGNxeHZvMjNBK1F2U0RQck9NakVOSUxueUgzaTJmNlBKZ0hQanFtR3ZmWFAzY2RBUk9lbzZhTkptYXdJdHc2Sk1mV1VBbzZhT0VLRzdVMWVhdkNTaTFXWE5BMTR4eGtwQ1hnVWtFZzJnelQvbGpoYThRcDd1N1E1aWxPVUdMRFhoWDRKMWxHNEdDbmlBWThwRWorMVFUckg4bW8rTHBkNDRKU0JhWm9xK1E5ZXBOZDIvT01mS3dtWTUrbG9XQU5vZHdoV0RTQXVUSzdXSE5kSEdRR1F1ZW1rVEMrc2o0bHdyMnhiZ3hVN0pBbktUMk5Rc2pSMVNoNEh0d3RNelB6SzZLK0RLd1BKNnFha0pJRDNPSU1iZ0hEWThLU0NFdkpaKzZMOVBJbGt4S3kwVWVKVTMyd21lbXlra2pDQXhuMEh5ZzVXT0Y0dmdzZDVucW1aSDRUT0JLL0N3TFQ0eWw4WTZHUlRySjhWa0IvaUJMR05BbnJ1WXhXRGdVZ2p5eXBndkpQZGRxdWpUSTgrL3lFdjRiekpueU90MkVlRnZINnU4RURUVVhIejY4OG4vTVpwOUVkZXowUjF1QTN0RWllcXhrckhEUjN5c0RRYSsxM0hhYVAxeUVwQi9nNDNDRFMvTEJ3Um50bjdxOHM2K05vVkZPVDhUczNDMEF0NTNHakRWdWM5Rmd6ZHpSQ0pBY3NKY3FSVVZYdVlVUm1jM09UM1huN21IUkg2WnMvbnVGZ3grelI5d0FCeFBoTUZ5WXRZbjZKaEVvcTZEdVcxUUFiV3pGRFQwVHhNQWZ4TzYzUm5HMGVUVzhlWi9nQmZxRVQwZ2dpZFVNTWwrTTVaZ1NDMjNJSnEwTTJSRGk3SE1LMFNEV1lxWkZRU3ZyRERFeUEzKzBnVVNNdnpIN29YYVEreThjelFTcmhwR1lKMHlzeXg5Z0RrSFVwV3pJRWpFVHVBdU9WWFV3aXpMeHZYdzBUNW5KbSs1TlR0RUxtdk03VzlrUG05UExsSGhKZkJCblFPMnVHcnFyc0FBTUJOMDZPMHNHSDcwa2pPQ1lWNGl4Tll5N3EvQTNtd2xoRXFxSUNEYnh6YkpHV01KNGo0MEhQaUxHcXBZUUxoTC9XY29yV1ROMGI4RmRjUUQ5a3pEYWNreGViTEV6Zlp2Q2RkZE0waENQS29MSlE0eHlZb2VnbUkwUTI0RTZHWVNDY0lpbVZHMmhXMjJzTHJNQ3hEWWJoYnp0cWtrdW0veEpHRWNtb1BNYnM5VElwTDBhY2grUXN0VWNFT2NBaG8vVXkzUTRwQ1U1SEFWaWx5ZDRsM1JldTBGakVhTTlScTVOR1RCNmxzaXQ4aWRPVTQranlLY0s0M2FhKzVxWVZNSTNxRE92a2J0QTQzV1dxRTJ5UWF3TkpBMXdONmp6bk9jLzlCTW8wQkpRUEtDeTdLQ1lGVW53bXFlSXdVTnBsNDR0cjdudWwyV3VpTVFFVVVlV3lyeHNJQllyRTNUcDRYdVo4MHpQUXl3SmZTZ015bWl1TlRDUVdPSTl3dnBFeHdjMVpOWUFnTk0zcDRFTXNDdFFrV1FiRG1GRGw1eWR6bFNUKzBNdFZFL2tPTDR4elhFMDNWVUN1QUJnWGd2c3JDbmdyb1dNekFuNE5aN2dRNVNlSmZLQlB4NFVRRzlBMlF0dmpHcThQZnhxZkpXaWxYREJFcmpXQnNZS3FhWmplK2pYV2xJVUFzYWhoWWkxWU1KN0p3b2lVOEc4UUNrVGtPdi9KVEFiNFNOUXNaSkNrb0FBNE5VMFpGUDlZRFAxVU9yTjlheTc2YkNNN2xtVjRQMHNnd3VUbE9pV284NU1vWkpwS0xRUVc0T1BaUks0aUJRSHBpVEhJWW1xR2dRVE11NDVQcndQeTlzaTV1cUU5aTNsUkVtM3UrYTZuQ3QrVzlFaSswQWhHSmpNVUNuaUxJWHJ1SFFpS2RHUmhKZ2tYbS9Cb1ZFOHR5MlRCYkFhNnRKUlBzR3ZPTkNhY3JacU5qQ0owZzZocU1LdU5kZnBXWVhiVjZtVTJVRjFNaTVSSDdKQW00YVlIclhQOFdzQXcxcDJ4OUNid3dTanhZRHpDWUVDOVdDdmEyeERxWHBxaVFSNmRRakVORmtpaGlad2ZOalF0dWowNmpNWVVEd3VnRitjMDljaUFabDB0ZmJxbW9kd0o5V2VuOUhFeVZRUlptS1lZNnlyYW8zWkJseEQzM3Q0VnRXcmtCZEcrWlBNdW1lejRzRjY5UTFPOG9RWU9vbDJnb2R5YnQ0ZTBPMlpqMVBObjZmTG9QZEtmQUFFNDZrdDhMT3BIWTEzSEx5MkljSGtBSDRWaU1DL1doSndDMWwwM0Flc01mdWtTcU9OakF5dlFhblFLeTN6d0g0S1RvWGt5MHlGMmQyNlNxUDhMMkpNeVlLYTdQZUU3NUlCcHJ0a2h4ZlhVcWQ3QjBWNFFoMWdIM09Sb2I2UVR3REFHOWhyR1RTT3RxYUhPRVkzcndIaWl2ejhZVVFCZklnc2MvSW1xRHFLZEpuVDZMK2M4aW84UXZZS1NjZGdNMHN4eGFkb2R2QWVzelFUTVl3TE5xNEc1TjRQL3FZNVdiTk8rQ3U0Qzh4QnJGSjZiK0ZsQnU2MWdrcGRoV25VQ0xUMlFaaEtjRTBTYWZsTjErcFhSemJTT2lUcENJeCtvc1lHSDdrMVpsU1lSdE9LWjF3N2M5YW5jNERjNmtsSUVyZStxZDJrSDNlTlVaazRqNEpINks5ekh4RzlaQTNCbUNWZ0FpUnkwRHhNRnFFaHNEQlFzek92b1h6VWVWUnVKa1d0eXN6cTRLMUJVd251TndJaXdLamEyT01EWnNZQXlHRFBxTTdGazFkbm55UnhjN0xFSnBkOUFRdmNWQ1paaWl3eE1ac2gvMFlrVFNSVnRWSGlHMnBXcjJJdXhlNTdaditacVVIWUE0RFUzUTZxeEtJRjVFSGFPZ01wSWVETXUrNmxieHFKRVZzT0pOeVBYK2FpMndab0c0MUpDeWhmQy9PU1pNVXpnNFRranVadm1FaWQ0bWdsNW9mbnhSWm5xVzFYYjJ6bS9PcEx5R29tRW9ocW1weHF0dCtoenpHeGtVejJ1TWM5azRwcGF1TnBVVWdMNWhraGNGekE0c01BQk1FQVNMVWYxRzhUamFmQWU3a3RlRTVGRWM4SFVDbHdNRy9pWkU2WUpxODlET0NwQlozR1kwdHNXQW5LK25JaW1ZdGxHOWplcWZWT09nUlc2V1ROTEdzZnFLVDNaeVkreXI1SjlzYkpvTVFnQlRDSDBMZ3o2R2pPa1A2RGRNVnBaa3kyMzFqYlhLYXJsT01qWXdoL0RCRzZYaFBHd2xzdHN2MTVEWWx2UE4yUXVKU1J0azVxK05ob2JIaDNHVDlJaHUrVE1zck5Mbnh5ZGMvTEkzcnovQ0x3NzZjSDlUY3hRMnMxOC93TnpBSzBaMHdJN3ZzeldKOUtiNzUremxkaFoyai9mUndqUW53dUdGUm5YNEJhb0RPNXBCNGh6bWlJd001Sm1OWVhVZUZ4cjMyclM5c2kza2tLZm9NSzJBUkhxUDdWL1dBbjhZZ3JnT0tJYzVxcHZWL3hTeUtpSmgyOEpTb01mQk9GWjMybEw0SnRKZkhlM2hjbHFqQ0tid2xBQnI0Tzl3RUlLaXlFQ1JSeEFBY3hqWk4wMDFRcG9jMWVzclpVcTRuQVhyYTVyQTBXMjU1SlI2UmJScCtzN00xK0ZqUFNXNXhvUlFXbWE1eGJSY0dzNDBVMXFuY1R2VjFVNzRqb1oxQVRDc2NCbmNqamdDNlNld0dnaVVJSDUzZ1ZYdE1US2FQOFZVandtek5HVVpvQ2JPN1NyS1pxbVlpWjhDUUFVV2E4S1F0N2tWWEcyaEFsc0lLaXl2c0ZhczNGRzdTYTl2UHdBRTNiTUNBRUNQcnFaRFB5b3daYktKT3ZGbGs0T1dxSUtxb0lnZGRUNllBaE04MHhDMC95VDZqemZVaHFCWUFSRTVMTWpaN1M5WUxUbVJVbkpEcHBweG1zSTBuT1g4QWNvUVdGTnNmalJtSjk3am4xUFBJZ3Z2TDJldndJdElsazh4a2IxakQyMExZZHBWcTNkQTB4RFVJS1lseUt4Q2dTSGFsRzJFcFFqREpweE1XRVprYzUvS0l1L0FBWFdIZDBTV0h3SjIvczZJK2NiYU96aXlpMXVoeFcxWnp4SHhBcGtVSXZpWHBvQklvaE1WMEpuYU54RHVMSGdqSTI3Y0ZmbXhPK1RPRlFiWGZ0ZUc2Wm4zREFxUTlUbVhMbmFkZFR1MDhQOWRMbk85dXowbmkxeHN3SGFqcE9hQ045T2hpOVlFSEF5UzU0NEpQUEdrV25UUEhWZ2ZGd2xCSkVTRWlqR3N5TnBVMDJTNTRoVVJvbDAvQnBkekdVek9TbzFUOStyQ3BJdkJBa0pudFV5Q0F0emQzOUhTczh3VFdaVGl4MllXN1FmdVVReTdySHhwbGFhNnkvT2lBOEZCUjU0ME1hWmVnMXN6bG9mTVN1QnljUTBDYW1abURSREFCcElYU0NpQkpHZ0ZVVkVpblVoREFvQ1U3OUgxcjlWL1dxQlU3T29GNlFFOVBCbm5HQjJucEZhQVgyeDVUd2FIR3QweWxicmZUWkFLTUtVdDlaSW1MMmdydkh3TGNtaXh5QUxKb2FNSDV4VkdZd1NHM0dHTllteUx4Y2JTSTJKTzlhUkl4SzQzUzlNTGVrU29GSXoxWFFhUUhRaGNORlV4Qm5yVS9YbEtsdDEzR2RYaWpxNEFrd05rZk1abDlqSUo4eHVZS25BaEk3Y01MWU1VNmlvblFJLzAyTnVDSmlJMzdZdnNteE1HcWdoQ0N1c2VkOWNPWWhaVndleEZXQm1wdzNXUFpBdVAwRWMxTncwTU9TY1pFNmFhSnF4UnZBajVVWTZZNEQrN3U1T2MrQmFBNDNhOVlpZ0RITzVadjAxeUxwRThLNFJJbGY0VVd1TXQ4WWFrbjRWQ29FZFNOMTZUYTFaR0lqelJyVmRSaHNoRmxCa0ZJUzZUeXJNdVN3OHRhVlovd254bXVhSWRmWVE2S0xSRmJ2NHhGYVhxUHZjNXg3QzFmSXZKVHY0clU5UFRRbDA1QmVKQ2tMa3BpNCtOQW1DMGpXQUNXWXpDc2tlL01wTWRiVXlJTzlsQUplN3NyQzN6QTJ1S29ISWJLUjhGd1grR0l4R1RIRVJZQlY4Vk5PU2lMa09nTW5jWklBeUNqOEhWK1VaRElkN2FKOHpTUlpHbjQrSXJqb3ZBMlA0M2phWW43cEdtR1kvUlJ5ekh3dFdFTWdsVTNUaGNna1NpOEt6ZEtENkRKMmg3bXlUR1l0SWw1RTNBZ0JPbG1lSXZLQVBSRGRHVEhnTmtRK2RzODVYcHFsVWlLaG9mT1lhb0d1R3U5RlBUZ0VaVUttUk9zRkVrZVR1Mk51MkJJRUhoRDhDMkJ1T2IxL1E0b1NOSTJhWmM0TVdIeVA4V2dVMHhpcW1RWnVGR0hFZm5icjY3SHFZOVJmVTZLRTdNTTViYVlTR1ZXWXNOVlI3SysyVndqNWZqU3JtZ1Nad1NmSm9rK2ViYW5GNGVFd1VFbE1QNU5MUGNVRkd1Tm5TTW5hVE56VmpNV1JCWFBSNW50UmdPeTNoUDA4RmZobHo4YkJKcEJEdnErc1JXaXhqdkdGOFpURGZMUGNidGtmdjBYVmhBdUsxdllyT1pnV2srbWNaODJBR1psVENmMklPa2ttS0dDZjROa3lPUlNvSEViUm9QYU1sSVB4cmRBYWd4eFpKcEN2NHlUWmhUbGZrZWRuQ3hLYUFsTW9sTm5SSnh4K2VwYzdKQjlZVlJFU2FhN2E0QVMrVDVCNC9heDdpb0ZxZWF6NE9sZ1N3WENXWUJFQUk0akpvMHlOdlRwZEIxS2JLbmRBb3dHYnVyNmtJUGdGWFRVSm5wdHdXOTJRZWFxa1NoRFNtSzRJQmFObUcvODM0aVpGRm8yb3lyR3MwbDJ0U0I2NkJoZDBRZXRSVFd1WFJvZFZRRm13d0gvQkFRV3JDdG00VDhWWW1vUTh0YU5Qbmc4K3V0YjRzaGFtK00zUEMxQ1IxWlpnUnI0QVhYMWtLMmlxNzM2WWFrYXNDTTNJTjBmRDEvUTdrRDlCS2dkU0lKVXF6MW1Cd0xhb0ZXRXp1SzU0d0FxTjZCZzJBaGI1TzZ4TWxjUk9hdzhYRVBRRm8wRXFaQjdwWnNyU29QakZScGc4Yk5GSW1PYnA3dWthWjFWdE1lUGE5VEdqY3pJdnB3SUFacHhFT2kyWmxTbW9QeWdLZHdVTjhXU1hhODJvVFI1Y0VwOENnWlM0NjBYSlVnUUVDT0czN01QRmlrVExENGVTOCtOSTZpREFCOXhXQWtqQ3paOUF1c3F4TTgrRDJ4YVRqSmVQeVhnd3lkRFJXVVk3dnd0UWdEdFhkR3hCZXhKRUJPYWJvYldYU0pSZVpxQ2J4MzdEcGdOS3RUQUtiU1grR3J2MCtoUENMSUQzd0R3MUxxR3AyeWpCRkpOWUFCSldvTWtQVmJHVTZ6b2c1aUJTd0xTUnJpVGxsQnVXYzBXcUFENTh5azRjNVNnVENVd0VRck10eFl5cTVScG9MODJnVmJuVlVMSitrYy9vS1dlM2V2bXdTdlp2bjhXVzJYZDlEQXRjWWg3NGtRdFBNczZvYXpiampPZHhkU2F1eitweFd0MXllNmxDQlVqaGFBNkZXVDFHVGFOdWZnUm5qRXBoWEFub0ZqQnJsT1p0VFZORE1aRjdXalVGQk1ERmJ2a0JBZlhaZW9jZUt1VlNCM0JJck1GRFRWdXFPVElMazd5b01kWFp5aW14MnNzZnBmV1NWZlpRMzhTRFh1UWV4K1R6OU1HNzVKZG5HK2dOdk5kN1kyWnZJaytValJjeU5BbzdXRWVWaG1uZTZCdFF3R2toaS9PMmtUN0NKQWFyUzBkNHBkVzI5OU9qdUVyV04wK2tQejE5VFZzUWFRb0RFQ0Joek0zMzQvay9xYWFHWk1GQ0VoZTlNV0FvWDhkSzNyN0hKRkRodys5M2pNakNMZ0MwLzZzdTRnYUh1WFM2TTlTMndIaWFwaHZuTVBIV3JFRndPN1VjMklzaTlaNlNGaU8vZ2lQV1Qrc0tNTUFLVU1OVTkxd2ljNVdxUmFNbGEyTml1Y28wL0VpMjFZMjBuOTdrR3g4WGpNaHJuZ0RIMGNZRUFWUVFCYzJjY0ZqNHJtTjB5SytmVWFUa2dhTG5XTkFJdEk3ZTl0M2hkb2tMUEN6eVk0bGt5VUlOVkpuZGZrVTV5cVo5TUpZVlRNUUo0RGxvZXF6ZlB0bC9tL3ZXcHBBakxDSjlZRFJlREZRRThnYlUxN1FINHNHYW10WmlXb2w4OG1oMUkvN3pMYUFtd1lJN0Q4S2c5blppZzRCNWNMNkRobVlRNlQ3dm4xdUV1TkVHbFA4OTFuUElEbEJlNE1FaGpub21jVEFrbVVYdUN6Q3BIdkFSMG9Ca1g0TjBucEp5alkvN08vWUlBQklxYzJRT1pLQ0lwTUw3SjZmbmdDK2xpUkZHQ1l4eThITEwvZHlGRlpIN3g3WTJETUxrYkN5QjMxeDdXb1MvamlCWXJqSDNDNzF3blVNMENqdHBCRnM2YlI2OXlGa2FwRXczeVdPeHdoUE5kWDRaSkpHcHorWGtzS0NhazkxSnFhYXBHSVRZTFdFRWFxRjdMcEcxekF2a0ZJanBQeDhTcFBJNXJOUlc1bjQ1VHo3ZXpxWTdNbUl1L000Y2hKblJrTzBPOGZJdDdyNjNrRFV3UGFEd25Bemx2OXRsWGJpczB2cDEzNzJHNFpIeXJYWkJZT0NHeUFyZndGeXA1ZUtiek8wVkR1cjdFajREbVl5YTR1K0s0VmpYTmFHRGozRVF5d2E0MnFTTlZuNHp3T0R0cG9uVG9jOHFhbmo0YkkzQVgrS25tNkd1a3YydkdzaG5HREYwQUk4YUE5RlRZdVhoVnkxa3dkeXBzeGpsRmlMcEpmczhaNlExbThhdDVHTmlBVHZsTVNCNy9YRTdlTmYyRFF5QnVsSkhnRXhLbzlpZ1BkZ2ljN0hJcDNsRmtCQUlYY014RFlBaVA1dEZWT3ZsSXpoYUM2QTQxaS9aVk9pYjFJdG9HZ2JzYkcvT1l1K3pEQ0xKUFNvVVFqRkZTcXppaWtvT3hSTFJVdkhKZEdKb3d5YS84MTdVU056UU5aU0pRSStlSng4QU5JQ2pFcEE5a1k4QkF6VXJtSTJhcnhjcUlGZXhhRkZGeUU0eUw1OElvaXlIWVdEZk9rV0hxNUZlb2xDRGEwTWE0YVlrMjEyMjRoQnFwUGxrREttYm5LRlBFVGVzTTFXSjhCZjdCWklRclF3NEI0T2FwOXBHU1daMnd2b0cvY2xMR1pLcE9DYTFXNW11N25OZzFYVE1EL0pBdURkQ2NrWjkxR2FrcU9SRFg1MXpyR1djb3VYSzlvcDJ4MXpKWDRRQnBrQlNzUlNNL2tSeUFhK0M4Vm9uMW1Ud1hqUW9zNHhybWhIV3ZzbUtRUXY5SnVZdVFZaUlLUkx1TjJ1RmxRc1lLSG5md2d6cldIb3l4QlA1d0N1cC9UQUpmUm5CamlESlM5WUVPS204UmJzNFBNUmdUR2N0d2RiOExvQXdzZ2VxQ3NsQStGSlhXN29zTzJKQ2tDMHp1R2dTZGo4bWlORDMxQVNSYVNmamRkUmMxSlc2SnlZVWNBcUFZRDB5RWtiQklFSlNTZ1c5R00zVW9HK0Vab0xLSzVrV2M3aTU4Skc5eWxnaU1KVVNLR2RlRE1EYThEOStFR2g3WGdUdU13M0M0REU0bXhQbGNvMVkzSWlmRVp2cHFjQVlWOUxtRk9RWGdBRXJNaVFmd0g1SUdmSVl2Y1M3cU0rZHBSa1RRd0pIaXIvTTVUQ2I4U3RBTnlHNkNwb2lNV1FmaWdUNkJYUFUxSE0wZ1FaUFNoTE96UTRnVTJCQlpzMjkyNi9JRXY5QmNoaGtkT1F0S1VwNm1iMUNWZlVUa3JuTThseG9MbVBGZ1Q0RjhMWE8zME5QQlVkYU1LSTNtUFQvQXAzOUdkajBlbmxNQmlld0ZIMHdHMlBSUTd6VlBlcGlpT2xKck5TS3dxTzJ1andFTjFYbjdkTmZ3Z1dZenhJaWx5WTZHdjZmd2gxVHhLYkgxTzJxZnUvNllpcUVwSFEzY29DcXovaFBKeXFBM1BqMGRzQ1FnZHBIT3ZSTTZjTlB1Qm5oZG9zcTRIdFhpRGMwRWlUS3g2ODJJTXJLRGZYZHh1VTUzN3E4aTdXdnBtczRNKzd0SHdMUk5SOUUrSnVFaUc2YlNFcGxuVkZoVHRWblhXRitJNXErNVFRTWt2L2xNTWhtUHlYWEVUMU5qZklsL3Vnc0NIb3hkSElackFRL0d4SEY3M2xzcnFJWnJBcXl5UUJubFoza2ZqZ0JXQjM4aFRDbk1ZaEJRN1ZxR29rc2dQMU9CRDY2REZHSjRMOWFHKzBLVWFvT3phQ2wyellqOStOQ003Smx1K2tEYmR0YzhheFFDeHJHd1VLNDVlS21HVkVkcmQ5T1FLZXBCOVUycWRIUmdQcGRFaTdzQVdrdkg5Vk54VU5OeW40UTZHckwxd1c2cjFhUUx5QTA5cmVBUGpFcW1LbDF6RFZ0N3VZMmNqZjBrZ3lHS0N3Z3F4bk1kTGdMeXJLUW5hWnViczk0MEFXUXNSak43ZmZyaUZ5aFk3N0xaTGlhazg1VzUrKzREbHg3M3d1WEtaYWJ2a1BIUGRuQkRCT1VFV3VGRW03RndmOWcxSnFRMnZYd0RCdlQvZG5VdlBIRmRSd0RIbDRlQjhvaHhITDlrcCtuMy96NnBLbFcxaUZRcEJsdzNoZkJhQTgzL045ZW9VamRaQTd2MzNuUE92R2ZPekJ3YWhjYTFzMFlUUFN2WWlobTBFZUVHMllKdEhpRXFJTG1uWjBEc0NLNFFieFVZM0xXQ2I4Mjg2NW1jQ2JRMDU4U21Hb01nYzUrWEgrN0JaRlA0R3ZBZ1ZYa0lzNTJWUmtTMXN1VTY4NXhidFpHSmdVS3lad2x3SjErNmJMRVFqVEgzZFBjY0RvR2lDRmpCdmtGQ3BKcDJVSVFKb0hLMklJRkFtMDZTSVovNVBCbm8zZm9VRE9aNnNySzRVOU0yQnVNMUJrdUI1VFVMYWk3ZmhtOUlpT245YmIyKzU1NnFKZlA1d0MveUZtUGhIcjV0ZDJ2L2RxK2t5SXZpTktkVCtyQ1RKUkc5ekM3WGZxYjdEeS9MQ0U0UnlHTzZFZnRvL3V2aUhQLzYvRGtHYmNkdkJPeGlEVWoxMk02SGxCQXFjRTY0ZUJaTFZYZFVNVVlNTGU2d1dhckdoZnljaEZRVHdzcXpEckdSaTBwK29veXVpOEM1RzhGYVFiQVRsWTVMajlodlowbDhqaXV1ZDlodTJwRTdxYlJFSCsvYkNPK3gvQm9wQnFOeUVyUjdZbFV4L21FN296TFNSMUZseWV6Mm5FOEYwRy9MZnRlKzVLaWkzVmNsc2E1ekVSOGo3cE15MlhlTDhmejA1M2NqZFA3UkdZTG41eDE3SC9nL3ZEeGViVngvWHQxZmZpbVBKeGdGNjBGUk9FVHlTNzZUY3JCeXBRTDdkcXBlL2htOFNBVVpIRm85ZkNHaDFvTUd3VmhzYmlmM1JVckQxM2JpdGhxUVVtVjlvQ1VXcXlSSDhWVndZTldnNFVrOGphNG9VL3hnbDNZeERCb0FQZG1FNmpQSm1kUFdpY1hhTTRVK0hyTmF1ak00RkE2SmdSbXRseVY4WHBjaWNWMi9mS1UzYWhKRFpldjhSbFBSbkF6Ni9heGRWUnBjTGNYdUVHK2p3azRueFhOVXlvelVGMElDVDEvVjAvOVcxWUplN01FRTdYSXJXY2cyc3Q1MDN1SHpEazhWbEZjK3hDTnluTnhXU3Zhdzh5dDNTbnZRQ1JZZUc2d3hnbWR2OE51SVpxeXpCYzlQaWg3UE1GcDBJMTFxSkl2WGpRV3JjMGRKcWp2ZjFiQ3lrTUgrVVR3Wlh5YVh0aWVhbjVrSVFSNW9WMkhKY2hVc1JkVDliT0tOR2ZZaWVFSFByaCtnanlTSitOT0dFNXlrUVdPV3dYVFBnMnladTdwaXdqOGthblpQd285QTZjcXhiZ2lkZVg2Q0lPMkZ5QWdsMTZtbHMwaUxuMkxRdmlkWmdJVFpMcW1ORmpOdjVUMFFSUUM2WU16KzVzYmRwVW4xTUpLVXVwU0VKQUFRQktIYVlPSTdoRFNHMU9ya2NacUlMV3Q1Q3NSYUN3UFhnUStMc1BGY3hJNHB6TWkzVnIrc2ZkYnNiOEt5dGJ0aTJ1UzBMZ0phdzcvbHhlVTI1UVJuc0hiYytOczNyd3NpZHp6VGw4K3J6ZHFmSEtRdE45cEpFZzk3MFhIME10QnRmYS9yNHZud2tMQkFjS1ZDbkp4VWgwVVFmV09hcTNhYnRxc0IyOVZhcHJXdUNheEVocUJuZ0FvV3JSMzgrdnUvNFk4bSsxMmVsZTlpSW94RDhVeE5ZMEZodE1BZEJmczdPMmNKa0pzUy80NlAwN0FWd29yTlpNMlA1U0ViK3FnMnlpOFRWTnQ3MzljV1o2TmNxWitIOFl1ZVp1bkZvQkdzdWtudTVzekJQTEpTQkh1bEljaDgvL0QyWUhXWVlMeXZwT1BYczQ2Z0w3djkvWWVTWXhOa3A2ZS9yZjc2OTQ4Sm9LdlZxOXpYRjN1bHNuUVc0NTcwQ0dzTjZGd2NoZGxUV2hiT240VmJ0QVZuVTFnYm84K3JOYkY0SUlvU3R1R0NOaUtMRVhRc2xZQVlYNFQzM3BUd0tQWG9RY0gzbG5oakpPTTZDZ0FaaWcySCtoSFM2TUF1N3lMSUZrdm55VkFZZHk1YjI5akpwdVpPNllWMzlOd0hqSWk3M3V2Z0paV2lLcWNDOHJ1NXpmcXBsOUl3QXNZcWpGc3lzaE5vb2lNVzhFN3pZajBKZFNpUnVhcUY5azJ3Y1NEc1pyZ25VUEFYOTVYQTByYUhtZzFFdmVQTmVQNncyTkx6OEtSVjhXNkNXdFhGMTNzV202NnorQ2NEWXl1VExLdUtaYlYwdkFoT0xkNGF1WjNncWZXeU5WTDRGTVMwcytyM3pSUTJBVGt1WlhCNytlSk5MYkIvWEYyZC82M3lJU0dvU3RXRU9mamFjT1JGYU0zRE1WUUwyMkhlRFQrR1VKd1lJNGhkYmRVelNINEV2MUt3bWNVZ1dOdHNGNEhSYndMRmdEZXhIRFBzQVlRVVJuZ1NXUDV1emoxcklheXVHSTF2cURHN0NiTGVoS1BkR1hPMUJUMkNzK2NNY25CNjk0a3phRmZERFdRYmVORk50SUFVQlBjd1hTRmlkbko2RHUxdTd1YXdDS1hjcFJiY0xKYjdXNTh4UFFueUFYeEVVa095TE1EdElRM0gybWltaXhCS1VBd3o5Q1ZDY1A5azBLUGFYdjRGWit1d0hTd0ZaSzRKWGlNNG0rOU9icURkMisrTzVMMGNUMEQrVWxmUmtDNUEvcGg3dHRuOThuNjRHOHZKSXNFNlZ4UGVWQ1JrUDh6Y0JJdXJxRWlUWmhra2FOYTU4NUp5RWV0OVJIM2R1WDdhQzIwWEVyRFY3Tmd1OHlIODdWcXhwblFmRldlUnRNdWxuQndmZ2c3dVlwUzdFaHZYZC85cGJwZlRlbGVMMjcyRS9tN3hGOXYyejhybHNkTjUyWWJDZllRK01jTG01UUJXcDg3c2E5R1NoYmh1elFkZHF6dXIva2ZyeWp0ZWwzdjE3bFhQYUQyL25YZjBWcjNicFlLOGY5OUd3Y1haNnVQSDB5cjh6NHBWclN1S0ZnczViNE5CdGI5b3lmSWlOQWdBTDdBbkhHQXM0b2hSWXRadzV5ZGlsMFUvVFNqaEs5cUlyL3NlOC9hTThJOCtkc2JxaUg1U0h0enBwd29RWVFsa09kWjJ0TU95Q1pqaE1MZXBjUmVyQ3AwMFR4WjIzL21jc0JoZWlGNEpEWEhsc1VvYUdiM1NMUVE3TmEySjVtNi9YMmUxYnVVNnNmSW56bFljeWFFUWNzT2NHemxDcWVSVUhXVUpUdzB0RDNMbGpndG15NDI3YVllVm9ucW8rK3BSNlF6bVFOSGZaVG5pYzcrRFNhZ3Y3RktoYzlieW4wcTNjYXBINHFxWkpmQ3lHTVhSME10NFpHVFJDSjVsdmRiR3dwbzJVbG1FaCtWcTRaT0pENUl4V2FEdVk1RXhkQ1kxQ2kyMnh2MkRnMDUxZWxjbjJJNWZ1enhKTWJjN25yVmVHdFAvSG81cEFYVmhUa1NyaktBWVJZVHVQeDBjbHV4MmlCS1BHaG9ZeEl6TUNsbmlHalR5N0M3R1ZNMTVKcjB3STQyMVNQTVJYazJPU1VqMEROT0dmTUZQdFlYK2V5Z21SQXQ2RnZ2RTcxeS9zVmptbm1XM2JnS1RYTnVTSHdYU29aWXdIV0VVWU9hckpvdG9sMDJFbm9kZWpUK3lyYzhqeUdHa3JvSGswYlNONFRubTJrT05HS0xja0thTDJRa3F2MXZEUmxwN3cvaGRLTjNBZWx2dC9DM2dpTmlCYTJHWTRCeXpwR09XK2JST0JKcHR1VndYQVJoTDJkUXg1azhyT1hYMzMvV1V1dXc0OTQyc2pwQ1VXNWtiVlNJZjl5dGJPYzBiWXlmQXBGRnNwZkVFT3drWWJVVTJza0MvNXBadE56ZXUvTEJDT0Z6YldrelEzYmFlZGJDVERkMlNaMDNpYkppci8yZjVlN1ZQTmhkTkRqMlhHZSt3VkxFeUd0TkowemVLbUs5elIzSTN0Z2lHMnBwd2Q3L3VYYlVUZVJZRGxBM2VIT1hzYktlOW5ZMm9JUndYZy9DZi9rdFplcDVGZUwzdTlKc1hOVEg4Y3ZacGRmSkx3cTdkcG5jZjlHZXFEQ2RoOWVzL2YyL245SDcxdy9PeXJLc1JzZTIrbVVDZU1NVW9BMElCTThZcW9RTnRjem0xNEFFSTlMcTQ5elpRcElLWUwvY3doSWRnL0FBWHU3bkxLaEo4elRxMTJhSThpaElNZGVHUjFrcGhwMFQ2SWtzbWV1czVsTmRBMjcyVXBtY2p5UDk3K1Z3a1M4cU9vWVVvK3FlaCsyemVqZGx6WS9jZUh3OWw3WWVxaEdHR1JRTHh1aXhrWXlsOHZna0d5ckZPVHorRm84WnFicXdzZ2dzc25GOTRVZnhyNmtNTE55eThhSWN4SmRGYmUyUkNFaytnQVh5MG40V0Y5MUV0UWMyUXVKM00rWVJhMTNNZHdWamJvb09TOWFaTFNBSXFyRFkyM2tnWXg4Y08xZ1VmS1VyREk2MGhyRVM3QnlOdndKR3cxSHpoZWJ2b1AvNzBsMG1mMExTUklmRUg1SDZuYnY5dXdnNEFBQUFBU1VWT1JLNUNZSUk9XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFTd0FBQUVzQ0FZQUFBQjVmWTUxQUFBQUFYTlNSMElBcnM0YzZRQUFRQUJKUkVGVWVBRmMzVm16YlZsNjF2ZTUrNzQ1WFo3c3Frb1NwUUlqZ2NDSU5rQUVuUUpRQklIRERpNTg0Mi9nRzMrQnZQQTN3c0dGYllod1NBUUNOYUJDbEpCVWZWYm15Y3pUN3JQNzN2L2ZtR2NwU2xxWjY2eTE1NXB6ekRIZTVubWI4WTR4bC82UC8vTi92dC9ZMkp4dXJtNm0zYTNkNmVyOGN0cmVYcDllSEgwK3JTK3ZUT3NycTlOMGN6czlPanljWG56MTFiU3pzelBkOTkvcjE2K20yL3U3YWU5d2Y5cFkyNWl1cmk2bjlmWDE2ZmIyZHRyZTJwcldWdGVtVjY5ZVR1Kzk5OTUwYzNrK3JkYlc2NWZQcHllUEhrMnJLOHZUMmZuNXRMeThPdTBmUHBwdTc2YnA1ZHMzMDliVzluUjBkRFRkMzk5M3kvcXpzenV0ckt4TXk1Mi9zcnc4WFZ4bzUzNWFtcWF1dVptV2wvcDJmenZkMUwrTjduZDgvTFkybDZlTnpZM3A1dTUyV2wxZHJiM2oydDNxK3RXdXZ4cHRyOVRld2NHRGFhbStibXlzVDIrNzk5cmEyclM1dmpFZG43NmRicSt1cHNPRC9YSHVtemR2cHB2dThiUGYrTG5weTJmUHBvM0d1RnlmVGs5T3A3WDF0ZW11dmk3MTkrYjI5clM4dWx6ZjZ0TmRGT3E0dis2NngrYm1WbjJOak5Gb2FseDM5VzJwdnErc3JFMlhGeDNydGQ2OUwvcnUrTmJ1em5SNWN6MW9jTC9zMS90cGZXTmpXcW45dS9weTIvWCtYdC9hbWQ2OGFjeWRzYm0yTloyK1BaMU82dGVEQjQrbSs2V0l1bkkvMWRscDZUNGVkczNHV3Z5NXZobGpSY1dibTdwelh6L1dOanZ0ZnJxNnZoajBScmN1bUs2dnI4YzlsK3Y4UnZkRG8vUFQwOEZqNDF6clBPTnJzUEgvYW96aHVzKzFaR1p0WlNNK3IzZjhwdDdYaCtpL3Vyb3lyYTZ2TnNhNzZmVDBPQjVkalBzY0hCd00yYm1wUTh2MXR3c21aRnpwK3ppMnRqeGRKcGRibTV2VGZiUTlpaWNyMFdtcDh6bzdPdDFPOTdXL1hQLzA5ZnppYk54cnJmRVNrYlY0ZHBlUW5aOGxQeHRydFhFM3hyVlplN2NkZi92MnFMWjNhbW01TWQ4bC85RzZoc21kY1M3VkpscnM3ZTFOWjZmYVhvMXV0OVBsN1VXeWx1N0UwOXViTzZJNFpIRjFkUjM1YW5OcjJ0M2JhWnlYSFovZjVIWnpjMzNRODY2eFhGNWNqL0V1MVkrYnk2dkIvem95UHUvcXAvRjdrZUhyNjZ2cE9oMVlUKzR1R3FQZjhXVTFlcjk0OFhyYTNkMGI0MWhaVHE3d0laMDR1emdaWTlqZDIwNW5Ydy8rM3RiZjlXaTFzclRTT1hoME96N0o2VkpFZmYzNitYUjljelY5K09INzAvSEo4WFJ4ZVRuNCsrREJnL0ZKVDgvUHowWmJkSDU5ZlRQYUp0ZkpFamsrUGtrbW94RjVvU3RMNmFUWEhhYmlieTg0NFhWMmRwYThwb3N4NmpUWklpUFgwV0pwYVhtTS9hLysvZjk5NkxUZnZWYisvai81UzU5UVpvcXozQTJQM3g3SEJFSjFNKzNIb0kySWNYTjVFWk52NjZCRzM5Ylowd2lZOE5TRjdaMk4yQnpBUk14K0hvSzBFVUd2SXV4R0hkN2UycGkrK3ZLTDBmbWJpRWpvenVvWW9WeUtZQWE1RklGdjZ1UjY0RUZXdFkwUmhIZTVBUmp3eGNYRkVNeEhEeDhNOERwTmNHNGk2czUyZmV3NmdIQVJDTG9PUXdBSlptTXlScTdVenQ3dTdoQlFna3pJYnE0dmEvZDBPZ3lNbDBhSDdtcW5VUUdaMnNSVXlyQ2N3cXhFd09NRUcyQmR4OEN0QVlvM2czRVJidlJkRXdPTVVMYitPUGNpeHQ0RVBvVExlek53Ui96clFQWXFBUVd3ZTN1N0EyUTN0OWFIRUd6MGVabUEzMDhCVzBRRndOdmJERVVLRWVDZ2h6SGNwMUF2WDc2b24rdlJZU2N3WCt1ZVc5UFd0dmRtZ25ZeFFCTllHTjhNQU5mMWRYTjh2K2orbEpRQXhvcjZOUTFscEpDK04rVHhhVXlBQUFpZkoyQjMwVzR0ZXBJSFBDVjg5eGt2Qm1TbDh6YmpBVU4zZDlQNThZMThFV3p0WEVZN3htZUF1M3QwelZJeW9JMDdTdDg5Q08xdDlNR0h5K1RvTmo2dWR0NU5vREhvV1J2ckFSOGhvaENieVl0MmJnT0FCRFVGVG1iNmpmSjFpd0hVSVhoOFNDYUFRUDBIZkdSckJmZ2tlOHY2MnpraDMyajM3aDZ3cndiaTF3Rk1zbDYveU9CUXd2by9HbDRsLzF0cHdkMTBFVjJBbW50dnhpLzBXYS90NjR6VTJlbEp0Tkd2RkxyZklkdFZSdHg0cmhyTFplM3FwejZUVi9kRUs5OFpKNGFZenFBTFhidU1yODRuTitUdyt1cDZ5QVNkdU01QXJHWUlPMjJjNXg2N3lUMURRazhlUDNvNCtHUThoL3NIMGZOeTBKb2MwcHNCeG4wYVAxQmEzMWpOaUo4MDdwWGEyUmw5dXM2d2NWQVkvcnNBbUNPeHRiWFg5NlZ4eit2ay9UQVE0bXpvS0QwRXNtaTlFU2llbkp3TVdwSUpEaEJqaDNaNDZKclZnUGEyL25tOS80Mi9NY3RJdjNtdHNqd3I2eEU1SWFaQWlMTzF2Wllsbktabnp6NmZEdkp5TGdLb2paaEhLQW5qVVlwN2YwK2hWNGNpdTI2SndIWVB4eHA1bGp3dzJkeWU3aUltWVVSc2dOR0ZBeHczTnJhRzBGREF5NnZURlBScUtDbUM4UjZPajdQQURkUWdFSndsVysxdkhzVEowWnY0a2NDbEhKaTB0Nzg5Q0tEdGNYMlcvU3doOEdLWkFBWGlBQTVLVEdIOHZkYm5XUlprL2ZHaitqUXp5TEhWUEptcnE1aHlFV1RjWGs5cmdlNVZBTUtrMy9YM1ZkWnRPMUJnZVc5aTdFckFwcCtFekQwNk1PNTl5VkowRHFZQlRFQjMzUmhZdnBYbGhMeDczSzNlNW0zbVZkVlBBa1hKTHEvT2F5c0RFQzJBRTlwZEp1QkFqbUk1ZHA5d1VPVGRnNFEyNzRvL3Q1WjFXK1ZWZFQ5OFpXUjRmMTc2NThXcVUwbUE3cHpVZDRES2ZmMFp6azI4SXN5ZE1XaE1LTDFkVDRIV0U5ejcyd0E2bWVtRXpwMDkyWlg2QlFRSTN0MGRnYU13TXlDdkJ2akdBTUJ1b3ZObGJhL2w2YXd0WlJDNkU4OUV2OUFPQUt5R25rQmxlSlVONXZibUl1WHZ2c25ZZEZ2dlV5SmVPc2RSdjNpZTE0RWRlcUNmMzRZbkdyM3c0dXprUElYblhXMU5oeW5zemQzMThLcXVrczNyNUsrTEFnYUFFdkQxMytvcWczSVM3MmN2azRKUjZQTU1JcDRZRjFsWTNRbGkrZ1JRRE5yNWFVYW1jZk5ralFmSnI1SzM2L2k4bGt5aS9GSjlOZzU5SlFlYktmSjliZDdsMmJrR1VIdVJZOGFkZC9QZzhBRXFEWDZSVzdRa283Zkp5R1ZBdHJteE0vVGo5T1NzUHQ4RWVOSGRqWHFoSVJxNTUrN3V3WitNNmVqdDIrbjArQ1FEdDEwa1U1VFVlWUQ1N094MEFLbHJlY0xHc0JkUXVTLzU1a3k0eC83Ky92VEZGMThNbW56ODhjZmp1bzM2Y1hEd2VIcjk1dldRZ3dIeWdkRUFlZlRwKzhuWnhmQlUwWk1CWU1DOHRrVW9RNjdqUS9lNmVuUFUvZUwzbjNtdC9LMWYrZmxQS01OcUo5OEdHZ0JwUHpmMjR1eDRLTFJROEM0aTNrZmcrenI2SVBkOXVadXZSVEFXZXoyaW40ZkFoSlZWdmF4RHd4dElZbThUWHA3QXE3eUFyWVFGNFRDRjVhUVNxLzJXOWcyTEFwQzJkN2NqYkwvWFVRTVpncERDVVJnTXBIS2YvZVRIZVcyYkE4U0c5UTFBNW12bThHNDFoUUprcXdFbkFCaGcyblZYZVpBczVuWUl2NU5Id1lQYTNFeHBPb1pRWE5BNk13UkppQ3hzNElHd1ROdjFmUytDOGliUWdmQ3dHQnU1OXE1MUwxYmVkd0lIaEZsR2RCdEEyWGhaRGdEOEprWUFzYlU4QkFaOUoyRXdUdUF5eHRpeHMvUGphU1V2VjhoSmtlNmk1VlZ0N2VVcFJyNWgwUWpOZGIrdE54NENjWk5iMzhtajMwYXluUFc0aVRaRGVXdTdIK0pYNCtzOGRMeThqSjk1RTZOZlhZZjNVMTQxQmRQUHU4NEhHcFJEKytoem0vWGVTajd3ajJJUHBhdy9POUZtTGUvdXJ1dk9NeUFaM1l6WEhFN3Q3eDJrRkJ2RFEzQU5nQU1xMm1BNGxsSmlYZ21GQjRqU0N6eTFzOEkzeW9JdTU4bWl0dkdWOVFZY0RCYTU4SGsveGozTEl5OWxXTTQrdFN0RVlWRENzOEJ3dHpCNnM5K1hNaGFYOGExSW9QYUVUOFlDZE04eXpoUjFlSEtObjh5Nm43QUxyUlpnZzJkTDBaZ1MweDFHUk4rQTFmQUU2ejladUk4SFN4MWZpbGMzQVJmaWJFVFRKWXlNQnRlWGhkMUQ4dnlaM1BRR3dNWkt2dDBUbGNqU2JRQkxYdEZQMjhDRlJ6V0FvWFFIZ052YjJ4Ky9vVFg1NXdYWHlhSFg2UDNpK2ZQdU5nVlMyOE96TWI3aEVDVHpnRmhFc2J1ZnR4NW9iKzhVN25ZZnVpamFHV0RXMzFJNWdCN04zbnZ2YWUySVpLUStkcWEzT1Jvbng2Y0IxMkYweUpPa1A4Q29mdU9wNjBhRVV6dU05ekNzNlR5UUZWWmZoaGxDYXA0OFBmcm81LzcyNElGK2VxLzg2ai8raFUvMmQ3Y2k1bVUzZWpOQ3VJMHM0bHFEZkZnZTUxeXVwb0VTL09oVTd1WjRBTlJPU3N6ejRrbHRGc051Yld3SEJyeXhYT0RqczBGRWlFMzRNRkRZSVVhbXdFQnFnRkxNcEZUY2V6a1hManB2akpmMzhNSGhZQnlyeThKeGc5MGIwZmYzOTJKVTF6WmdDc0JFQTQrOUNEM25WZVFKTmtZZWFqc0ZvNmhDM2dlSEIvVXhKc1NBKys3enR2c2NQbnlZdlovNlBvT3V2Smx4WGlWSUdIS1pBajdjTzV5Q3RheGdzVDR2SmtFZnl0YlkzSHNvU1FweUVYT2k2Z0FVeXJUWm1IY0xxNEdPTWQ4aitNWks1K1c2MCtwdXRKeEFHWStjQ0VNZ2ozVmQzMWhkb1RLUGFxMGNVem9aT0cyV0h6aUpMaXZUZXg4OG5XNTVLS0VlWmJvOFR4a0NHU0h0WnZUY1NsaEg2RlkvN2dwOUwrTlZCMm92cFJzZ0lRVFMzWlNqWVN3dEVaU01DTStwdjlQQ0JMTXh4R2NoeG0zMHVNOURHcDVBbjVmbjBUL1FtMjVTcHNzOGtZc3M0MzJlNVRWZ0MyVDdkSTR3N3pidlFlampQbStQeW0vd29BaHVnbm1ab2xFVThpQ0FJN1FBZ2h5TWNDbWFvdDlLNTZJQnhhamIweTZRekZqT2tCY0dwZlk4ZXFHWU1JbGlNd2lYWktSMmwxSzQxV1RrK1p0WDAxbXlKR1NobkR0NTc4SkVIdTdhcGhBeEhvWDQ1SVBjQWoxODhUdGdrQWZyMThIL3M1T2pvVGZBVjhqbWZOZnlwQWN2NHNkMkJ2VHEvR1I0aU91MXZjR2dkdncydVJZZVh0YWUvTzR3cm5ueHdkSzBzNzliVGpTZDFJZjA0eUlaNUhYaUI1b0FJOTVmelhRL3ZON1dwZUgxMEJmZ3RsYWYzV090RHNrcHZ5M3ZKd282ek9GZ2VPUGFvRGt3a2ZQYTJkMGZzbllpZkUwRVZ0WUlSWHdMRjdia3Rydm0wYU1uUTE0Mm8vTnRSbFFhUW83NHFEVFNkaDdYU21BdEFuci95WWZkSzEwdTJLQURhRS8ybHhLd2xkV05BTEp6NHgxdlZCanZieUMyczdNM0lpWnl1MXZib3BnSEgveVY3am1EMVFDc3YvY3IzL3hFcmdhUmVSWGU1eVZFZHlobWcyWXhKVGpuY0tlOFQ3MEFDZ2NwUDRxeEFnOGZQWW9vRVRsQUdzSVlvVmtHUWtNUXhha1Nhc01iNmRvUk5uUXRJandJTUZndGJ1Uko5NUlnNWRWQTlaR1Bpdmdub1RhUGhVZUhBY0xYR2ZXekFoRmNQd2dURFdTWmhoY3orbnczY25JbjNSdGl1MzVZNlpTRU1CRG9SVTVpTVhaVUZQSU1CVW9nL0UwNVppc215VHJueUxRVEpUdVAwSFJld2lUTVF2aHhiZDk1cXdCSVgyZnZTVUw0Sk9BOUdVTFByWmEvb0lnOENHRUNFSmJBdjlObVlpVXh6OHE1WGdpem1mQmhLTzNmM2o4YzdhL20va3QwODJpM0thdHpVMHBLUHp5OWFPZUZ0aVNiWVpBbkdBTFFkK2N1TGVOWnpUWVlRSWFYWUFDYUYvV21aR2kzRXVBRW1NdTFVMGdxWDdZRU5JSFNWWFNMb0FOUWJvVy95VkYwdmdpMENLdzgybEdUQWhLOHdPZnM1S0krc0tRQldlWmc1QzI2RDlxWlNGZ1BwSG1BVWFCand1VEN0OXJER3dyTEl4dDVxQUFhWURNd0VyZ1VWdjZPZDJnU0FVQ3Y1YlZwVjE1RVNDZkhCK3g0S1F6THlMMWxPT1JzOEVIWUQvRGxiTWd4YnpwVzEwZGVSakk2dkp6Qi92R2JTQ0dTRGY3cjB4eitCdWp5UFBWdnJiWjUvbmVGb29EQ2ZVWitOcHFZbUJqMHEzOXJ5UXNGNW1Wc0JrS0x5WUx0UEplYnhtK2NOVEQwWXFIRTJpRjNkTW5iWkJZNUIySkRwdE1OTWtXSHlCQVAxbGpRWjdOSkc4Q25EN3g0NlJVZUtmcVlpQUJZd0ZxN0RKdklpUXkrTFp3RVZvOGVQaDcwVGdQUzQ4ZlRWM2x2RDV0RVcrOGVyMTQyTVJLZDlqTDJaM21XZ1BEaG84ZlJZWjRJNFdDUVpYMUJYdzdHWmVmdGxwY3pWbURMNDM3eTliL2VPVDhGV0wveTk3LzV5VW1laGxCbkx6ZFJvcHgxT2VnN1JENExNUWt4eFFZMHdyR2xHSWNJQ09xR0JFcE9oYnZuL2FERU9JRHpNbGlFQWxvVTl5UXZDY05aMWRsNkxZM0VNZUY5OVBoSkNqSFBFaDZVRUFSTVJKWjF3eXloM09oci9hS013N09KcUFnb3VUL2Y3eUxDUEJ4eHNvRkNKZmZqS3JzSDFDYXNFdFVuZVIwRUdaZ1JSS0dMOE1adkV1WUV6NmN3Q0dBQlVPY2J0Tzg4SFM5QTNORXM5UnhXNkp0alhONHhtMWg3QkgrQVIvUjVGRWpYNEdpVHBLT04reXhtSGNYd0Y0Vm93M1ZPb0NqV2FsN3M1YkIySmp0U0NqVHNmanpOblhpeWxwQnVCRzRqdE8vK1FKRVhxQit3anlJTGVSelREN2s4WWIyWEJPdFVEaXVZSHVjUVluU1R4RjhLTk5LeitwRG5NRHduTkFVUThqdnhQS0M2dTJuV3RQek5WZDh2TGdMSlc4cC9uVGQ0M3VmVmRKVEhmUll3dlFtd1B2dEplWSt6cSttTHIxN0V0N091azdSdlFpTUEwOGJxYXJPZEhkdmJ6L085bFFiSVU2cTlxenk0cTJiVXJpK0ZXUkd0LzY4Q2U0cm1PMDFHN3pwYzNxWlp0R1FOcnhqRGZocHBoOU5DS09FaGlwd2NGNXAzb1JDc0U0ZVNtSW5jSVIveGFqV0RzQlNQaElzTXRwa3Nla0d1NlFpUUF4YkNRTW84UUxYVUNrOUplOUluNk11akV2N1haSWZuOUVYTkJvYUY5OFlWZ0F1ZGVJSkVLMlNQNzBVczIrVjcwNm1iYU00TE5URmhrbW9wUHRHbllZenFEOEFsNStRVHJ4bkp3MENENFJoaEtqZW5zZEFoVHNhTFp2ZUJ0aGREeUNEc2xNTmFDYlNHdDEwYnZQaDUwaUZRN3g1YmVWUnplL2c5aDNGazh6eXYvdlhyTituV1FicFVuckYrbTZGMkxxd1lYaHVzTUxCNElPS1NmcUxEbkJMMGh3a21KZEQxcUxiZ2k0aG9xM0RVT0EvZS85TWUxdXAraER1cTQ3d3MrWjA3cm5waHdFMUVNZ1VyUHlBazlCdUZ1YSt4MnpyRUdyRFVRTVZVOEUwaGhkZ2FZQUdqMmRQQTREbTV2QnpqUnY2Z2ptTTA0S0FZRUhzOUlLR3N4MjlmeDVnNTNwYWRPQS9jZ0JHbW1ObDY4L3BsOThCNGlwVXdKQWlJY0pBbEpKZ0dPa0lQVmptODVBMzBRMHAwVVY1dWYzd0h2SzlmdkdvczF3T0llV2lzRHdBQ3J1ZmRZRDNGSjVEdTR4T1RvUDhBN1FSeEpFd0piWFFoTEppNkF1Q1dLT3Y4SHA1YkFxWmR3bzZ4bEFNNGpZUngvZUs2eTkwWjFFbUFDY0RITEcxQ3RsNllMbGR3ejlKZ2VBS3dGNGduejhOcnVJck85TlBNNkZhMDI4akxFcElBTXpBRWVBR3FrUG5rcEh4Zy9aTm5rNWVUMWxodjZ2NU40UmxoZkZENGZYNTVObWl5VVFMLzd2NjZoR3plU2NaZ0pIVHpwRmJyeTJVS3Q3WmFXRnI0REZ5K2V2NVZORDR1QlhBeWFDMVBZWDVPNllSenlBdFBWcDVDT1FQTGY5VHhuVHdnWG9IeDhZd09TajNvMjNaR2t1THhVcjcrOWEvMTk4NzBvSkI2ZnpmaERUd0I3dTF0WGxianUwdWV6TUNKckc4TFVkR0ZVdkJXeGl4VTFobi8wUGN1dWdEeUI5M25Jb0M0dXVaSjVRSDFPN3FNNi9LRUdXMjV6cTF4TEZtcURXREYyUEJXeURWNU1pRTB3S0cyS2Z4dzFUdE93WUJjdCtvUUQxdk9sTEdiODB6VFVwNVk3YXlWY2dGd3dpcmUzOHJ5UnNhbWRFQjlRcFBWd3FickszS25heG1OUnJ4REh1TEhYYVVnK2pOZmJ6TEpES2xKSkoveVlGQnY5cmhFQWVSUkdvYlJGbW5vKzJIQXRid01QSUNQUE9iYWtJTlhyMHZFVndXZ0hJWTNkYU5zSXl3Z3k3ZnhUYjZOZCt0dmVuZmFSTVpoRXdLQUQrZ0tyKy9yaTd6Z1J2SjNGamhkVnVLdzFmZkRRODdJNi9SWWVEM3IydW5wckN2MFUxcEl1WWNROUxvVXh0Mzk3QWsybUQvMVd1VUNLMThJbmNhTWcyUWdLOHdpVTBieDcrd3Vua1JJUWxJaXV0LzJEMEprbms3blEyK2dKZmxHNlFnM0svZnkxWXVVNGVGMGtXdCtHZlgzaWxHRlFJUll1K3BwRUhNN3owbXRrNmxyTHJ3WSswVmdkVkRJczlONWNocTdsQzJDNzZTMEJxUUVRcjVpTVFGd01TWU9UT3VuVUc5UEloSVFLejlVZk96VEd6QU5TeFJqSlJDdkV2N3IzaGpPdzVGdkFzN0NEUUt4WG44a1N6Y0NWSWx5UUNWZmQzNVgwamV0d1R3R25MZTVoSW1CNm1rNWlZWEY0d2JQakQwWjUxQ2EvWmdxcEh0UVV0SjVsSXBWQkRhemkxd09MTy9xck1rTGVnUDQ3d3U3Q0tMU2ovc1VjaVNMbzZlU0IyMm9vZHRxQXFGaERRSGxFWTlRSWRUV1ovZmxYcytLVmZJNWV1OTFmenhqV1hsd1Yza3VGSWNBYjY3dFRkdDVnUzlmSEUwLyt2N24wZTE4ZXZQcXpmZ1U0Z0VqUXZiaXhZc0JPQlQxNUNRaExmOGx5WXYvK3BXQWpQN004bVFHcTV4T3h1VTZqd3pma3ZGQTd6amdQQjhBU3hGZXZYbzFydjMrOXo0YkFDQ1g4YkF3NGFEWjBNZVBBK3lVOXVIRC9TWWdTdVNmSCtXcEdFdTV5M0tEeDZVeWhNTm1Vd0dWQ0NwU0o2T2xBSkxaMjd2ajZjR1Q5NGFIZGhxOTVUZlBrd004NHFGT2hjVzNnZEpWUEJIQzhiTHcyVGtNbHhud2ZPdStjMW9vZXVmRUpET3MxOUZET1UrSGg0ZDJsUmQ1bFhja0h6eEtmdXFYR2JZeGdaS3g1TkhYNGpDa3lnRkVMU3Z4NnBMSEZRQ1A1SHRBd2dCdE5EWUdkaSt2UTZqRUt4bUpiSDN1TlFEbEhURGh5eWh0Nkg3R2pEZThIZC9wMGVQSGo1T041Vkh2S0Z5N2JueFNLR2ZyS2dRWXJjNTU4cWkrcnNVWHMrR0ZyTW1YRklGSkh3NkcrMHQxU05handjdVhyd0traDQxOWRYb2QveDQ4ZkRUbmhKdVVRSi9kY3JROFNubzdMYzNwRWFDcUhHSk1paEdWM2d5WmZDVWp5eE9qRzMvMk5ZSUNoWkx5TkVJTUFxNTRjejlyWjVDczJhczhHd0NFc1pzMXloc3pNeWdST0hzYkpWZ0xNYTVDYkxrSWcyRGRSMEZxTnoxdmdLT0dLeWJKVlQxSmFBeWF3ck82dkNLZHh4eFdkWXRTMzVYSFNjQXhBRkNkdkFPeXUxdldJRzlHSDJwdk9hRTdMVlRBR0JDaXYxemgrQmV4OTBZTURaQ0VTSko3dzBJbmhZOEtHN1A5MDA4Ky83emFsQW90T3liUHRwZUM2THNFUCs5SWVFQm9oeFZ2dk9xS0FOVHFUZDVCSURET3lSVWVRaEY2dldsOEdLay9BNHlqSzBzRVFNVHE0dk82VnorNDh5bHViOS9OeWozUFkwRXpzZjlTbkRHTzVlaVpueFh0c3o3ZFQwSGZuWVJtblZMc3lVTW10aGd2ajhXMUpzQVN3WVArZWI1Q0o0V2xvMUN3Z3M2TnRjTHo4eFFqREx2S203cTdxWkIyLzhsbzk3TlBuMDNQUHY5cUFPWlpudG4zZi9DandFcnhZQ2RuN2Evak1TTUZVQm13OWJ5dnpmS1hheHQ1QWZGT3VFRk9WZ01yZlZMRHcydFpYVThpZTFFMHZ6TjhMTE5aeE5IZjJueWJWN2V6KzZEZlRMUUE3YU5BNC9YMGVlT0pZdFBISDd3M2FMZC9zRFc5OXlTdnNIemdONzd4VWYzTzg3cFBobEsyanovNk9QQXB1ZjdGaXdHT2h3L3dIQkRsQVdUOHJ1bzNEMjR0RFNGWHk4bllWYmtiZlRJeGxBZ2xneG5naU1QYUQrQ05OMFBlQjJCSm5NZkgybHhNRnZIdWVUTkdPT2ZUTGdZNGJPYlJHU1A1OGR2c0NjWE4vcDd6YzNOT2FpN2h5Tml1cFhONU5mcTNsTWRNNWs0S2xUT1Y5YnUrM3UvRjgyWVprMHRqSXE5b1IvYmt4UjRHRklBT3pkZnowbml4TEtwUWVhUkNPbGNhaHd6THhlcnhSbnFkRmRTaDZmMzNBL04wNHVUc2JZYmpiVTVKSGxOOStmS0xMNXVrT0J6UlRsQTk2RVIyZVp6a1lMOUVQcS93ODYrK25KNjg5eVRucE5uQWltV1YxSEI4T1RoZmZmWEZvTkZkeDZVVGdPWmw1VUdNbjdiVnBTMHZxYjNrTFViZlpQM2k4clJ1MWFNd0JCL2NjL1ZOMWErUEc2aGNGWGZ4L2Fmdmp3dkUrQmc0by9IcmNkeXNHZ1dXbUJ2NWdQV1VLdStEVlFSVzRsY3ZZZUVQZi9pamhLQVpnUU51Zmw1SUJOYlpqYXdNYXlWYzBBbUE1d1c0RktsUk5LSGZuQkNkRlZwY3E4cVlNbUxNMGpJUUtCSGZmU1JIZVhqUFMvaGhKQ3V3RVlBY3gwejlGNHBCZHVIZWszSms1eFdLdm1tc2xHdXpQSUZLL0FFdU1WT0lKamZrM2dobDVpZTlhL1lwOTdoK0FuQkp6YzFjV3VBNmg3OXoyMXZOVUJKY1kvVW13RUJvQnFhS0tVdHdOa2swcmp1SlNlanF4UE9BL3Y0dXdYQVJKWW91TnpGMDc5R0RBUXk4UE5iTmZSdjR5Sk1KWGN3c1h1WnRqWENMUjlWNUdJdCs2dUVvaUdsd2Y1dEpjc1NzM1hySldHQkZhQTkybjNaTCthZXo2ZnQvL09YMCs5LzV3K21Mejc4WTN0UjFsbDR5L0RxbHVjb01MeFZDWEJmQ3JQU3A2SE8xMU1pb3Bhdmw1Y0RRak9FRlFRd0Ezc29QVlNKaFNEeEhNM2k4RHpPREV1KzhDTHpqTFVpaHk5a0k5NWJ6S0ZoellSYUEzOXFhUXpHZVpjT1lmdmdUZ0w0eVBmdnFidnIwODJmaitzK2ZQWThXdTNsWmhhMnI5OU1YbjcyZVB2NzRhME5XV09PMzkvSmNKbG5rK25pM3JENVBxYktQNkxPWkhJeEpqRG9yeER4QTEyUXNwQnp5MlJBR21CbkhlRVZudk52a0VjVlFBTkdoWWNSdlUzeDByK21SNWxqS2MwTDdGV0dma0s4Y1dmT1dRMDYzS2x1NXovRHdKdFRjblo1RmswRHFLbm92NS9YS3Q2SUJ3REM3dVA2NHlhbnEwVTZQeTBGMWYwYVZZY1J6K2dod2daY1VDcEE4UEt4WU5LVlhUMGcvZU4xYk9TRjBlRWZvM1grdlhyK292T0d3YTV2ZEw5eWpVOXFWMmpIanJwRDU4ODgrRytCR1IwYTVUNUVLbzBOZXpSQzZyM1RMaTVldjYyKzV1VXFpcm9yVGw1c0pCM3c3NmRodGVtLzhVaUVuNVRMbkVGQ0YvR3I1NXNPaDI3QkExS1hkTjlWWmJ1Ymg3ZTIvTjBqKzAvKzAwaVczdFF2alZaMU44Sm5yaUxZalRPd0Z4QXlPRW0rWDcxRFJPL0pjblNoMFN0NTd6Yk5qT2k5azJDM2U1a0hwRUtVK0MwbGwvNVVVSURMM203QUk0d2l0V2k3dTltSExaYml0a3BzYmdjS29LVWtndUtIZHFkOFBwOWR2WDAxZnRVUkd2TXd6YW9RRGpGUW9TODZhWG1ORjluWm5BbzhRTk1VVytneUZEdlNFd0tjSjVkc3MwY01uajRkSFNkRGs2VXpMeXNrb2NrVzhNYjBkUUFoM2F6d0dTYnpQOUFDaVk3bERUQVpRMTdVOWtyT0RtWE4rQ0hYY2w1Q1BIRnYzRkladngrUWxRaHlkS01WSUJnZXF2Q3JUOHNvSjVHUGtOQ1RJQWROYTRNeURsYnpsT2crYm5wQUlUMGFZMG5mWDZ6Y0JuUUhVUkFENnlqbmtGZVZoTFdjTmp6SlU1M21kMy8vQmo2Zi84bnUvSHkwdXB5L0w3YW0xR2puNGQzVlVhM2w4Vi9WRHNhVmFNRzBCRjhxbU1seVlkelNTNTgzQzFqZTA1OFVxTUdVcExmM2hEZDVWTUVxQlJ2Z2RqNFFQeTJ1c1owQ1hVcUVwM3UrTXNwS0VLb0NTNjNBdjRBbE1HQjdoc2VVbUd4a2pVK1dmZnBZQ2YvRTZqMnR2S0FMKy9PVEhMd2VnUDMzL2NVQzJtMUtLQ3BLTEV2cnJtOEk4TTNYelNveElGaytsSFpxQVNWWnZVbHk1V3loMDVYNzFuVndEb3lIdmhYOUNUSG5ldDVWSWpCblh2QlFlLzJvNUtvYVJZbTlIQjdwaXRvOHVTSlVBRmlzVEtLZDdKaTRqc2hpeTFma3IwV3NwUUNVdlNnQk1Bam4vT00veDRlRmVHQ3BVUktmU0Jja0NJdzhFZ1RCakxSUTBTMy9ZdWJ4NzlIYmMvYzZMWU9TdTlFWC8zcFl2MXRkcFJ4Z3FYS2ZGOGZMVjZ3eDVNaFpkamsrZXgrT2JRRndFZ202bEg1SmRJU0JQeStTVmtwZG56NzZJSmp5MDl3Y2dTcGkvZlBWVnkvWU93cEhLbjB6SXhIL2xOa0Z3T1VLNnlXdW1kZjJkN28vcS92ckx5R2Q2WjlxUFhuVEtUNzFXZnVYdmZQMlRyUWJBQlpiNFZNZ29wcFYvTVZBSy8wRWRNVGpKVVVuSUVkYjRiSlFVeml5Qkdnb3U5RlhKZWw1S09qUUlNd0F2UWd0emVEQUVoTXMvTEQ5RmkraUFSOTREZ2VXWjVMQVFXb0tTQjhZRGRMNjM0bEpvclVodTVJNGFub1NmZ2owemk5Q2Z4MkRxSE1PUmhCV1U3NHJpM1dPZVhhUm9TL1VKWXdtdkVFWDd6aHRoYWhhVnNDWTlhRHArTjNzb01Yd1cyTEZtZ0Z3L3hlY21JVlJYRTl5eHBDbWFtakhTaEQ0UlZyVmcrMWwwQ1ZDS3JXRUtodGt2WGo0Zk9UQTVucjFjYkpNTW8zNHJGaXZHVTdGTWlVeE9BRCswVWhOR1FPVmExSW1OMVFocEFVQWNNN0NkQndnb3ZEd0p0LzNvemRuMDdkLzd6dlFiLy82M3BqLytveDlOZi9pSFAyanAxS3ZwYlNIWWJlVUlHeW0xRUpHczNGWmpOUkwvQ2Fxd0hxOEFEY0UxaTZWR3pHU0Q4TVpzR2l0c1N0NlkwWlgzUktGNFNHTW1MTm5nMlM0OFUva1Jjaklub2dQVnh1UDM0YzNXampGTEpoOVhpSWhHNk1sTFlLRWxoU1Z6MWJNSnE4bWxwRENEK2RWWHIvSWVqcWJQbjcwWVlSL1A3bTIxUXJ5VjVTWkc4SnFYMG9IUloxNjcvS2s4Smk5ZW55NENxM2xpd1BSUHBPOGZ2K21iMEdTRWdTSzZCSXljaUJpc3IrVnRDQXYxaGZ5dFJYUDA4aUl2REJ2K29SVjVJVXV1disrWTJxdEV0YmJNc0JYK1JUK3BqSjBtU0NUcTd4dnJrSjNrUjZlRWd2b0M0QWI0ZEErNkllK0pSbzc3ZS83TnZlY1ZIdk5NL1R4VDd2clpJN09VWnU3VDFrNFRORVU3WEhVZ0tMVWl2eXVkZzFjY0NKR0RjaWF5cWJaT1dNY0EzMGJmbzd6QXRWSVlkRVZZUzRmUm9tK0QvbGFQd0FvNmhKNGNHdVZSNktPZ2V5OHY5elN3NXkxKzlIUC9JSDdNTkVPbmxYLzZENy8xQ1ZmdG91STJQSFRCV2E2aEdOaVNBRmFjOEF1NTFGZFFFZ2x0d3NveWNOL1ZpUXpGS0taOThPQmdvQ1BQQ1hQTXVDanRyMmNqTVdsOWxad0tyMHFIQ1NsQ2llUFA2clI0bHdEeW9DaW51ZzEvWHdXb3B1TnBFa1VlQmFJSjRtNENqdWp1UmZtNXM3d1FoSlliNDhyemdpaUM4RWZpdWNzVGprb0pzcElzL2p4bG5IRGtXUUViYmFyS2xTVGwrUWtUaHNEVXRqVlZxcTlWQWV2clpxNzlxRWpHWEpNTDd5eTN5bmhsQnRZT0t2eFQrVzAyVDFpSlNTd2RDK1BlY2oxbTZ5Z2hLeTU4SVZ4eVZtYWJoczNwMHpmZVM2NUFubC8wak9rS1JXSHhYcFpNUXBwWGdHNm13by96cUNSTzcxZFZlQjlPMy9uREgwKy8rWisrTS8ySDNqL0tDems5SytmMnVwS0R3TXFTbDQxbTRwWVRpdVVVeVpLUnpheWdXYjgwSzU2cEE0b1h6UklDTGQ2VTVUQThyb3NzL2xVSmZMUzlURkhONkJsYnphU01RRk1UdFJ1ZkFSOEE2ZEJRVkhtWTJaTnNFS2tvRDRMQ05yQmhFS1VlQUlWMHdhQnozU0d2VmxXczE0L1YybGZVcXR3Qi9kWmJIcElmbU9Jc1Q4OWZIbVhwWDAzUFg3eWN2aWgwRkJJZnZUa0pKT1Q1QXJ2QVlkVDBKWTluVmROdk5JTzFYUGh5ZWw1WTFUMTVCQVp4VTA1bXI3eFc2akg0WTVHOHlRK2VBTStOM3BBSk1tblc4VHlRRnQ0S2RaVzZqQVhJalVlYWdpd0RRR0JPbmtmWlJOZWQ1MldTY2Irbm5obFBJZlZkT2lqU0tYZDUyWXgzbnAzWlRZdTdBUjB2bWxjR2FBY0lEcDFVdzJYdHFTaW5uR0J5U040VXAxcXVZNG5RMFp2ajVQeHcwSnVYckx5Q2dXZk02YzV5SWVoeDlDQ0hJaDI4ZXhVWVM5aGY4ckxUeVkza1ZXaDkycXFNcGM3ZjVFaWt6eWJYbkNQM0tod1VrakpNNitVdzEwc2gzWXp3dlA2a1YzS2c5RlYrR3hDUFNZMWhBQnA3UWtQK0R0Ly9XMFFwR1lqZVdZZFZxRzFaQnVHM1Bza25zSG1lSzRxeWtKUmw0a1dvNUpiQTR5SWpBczlaUTZwL29iaDQzTFVYQ2RuWldXRlYxa1lJU0lrcG1LUW53dDNHWVo2TXRzWHFZNWVGL3FhYyt5MEZHdDVMUkxJYmhQdFNiZ2s4VE13alQ4bFQwdHBaMVI1TGRjdDF6NHAzN3c0RVR2dmQvMlY5YWphejRreTVxNGZOZWtIczI1UjZGRFFtNUg2enprdXRGR0FEb3NaMjBubVU1RFF2MHdKVFU4cW13a2ZGZnhYQTYrVlJMT3N4UlJzRnVqZWhOWnVJb0NscW9IRjFYdEZ0TTBVamhBczhiK3FqU25BZ053QWxrREwyNFEwMk5rQjFuUWZHWTlPWE00QVViWVZ2Nm5qc05ESHlhekdjMEtyeHVhekdTZWlWR2czYTN3V2F1d2ZSNjZ4OFJPMWZWUk8xdWw2ZVkzbG4rcmYvMzI5UC8vNDMvblBoMjNtN09zU3JlQ2ZFTWxObUtkWm1mVmlyLzNnb2g2SjRFRzNmQm5oM2R3bFdIbHBwcXBRc2RVcTRDRDhsbGJzazZKRy9XVmNJUmRscU93QmhFUnRXZjZmMDladFJtVDJ4eG12TUtWeWt5ZHRwQ0lVTTkwMEE0RDJsQlFvOGlPRWw1SXdTNW1WVDNRbmx5SHZTK3NCdEo0Q3lhRi9lNDNTcFVvd1UyS0p3TTZob2dhNW50ZjMycU56WitRK2o0WlRpSFU0LzkvTW4wMGNmZnhBZnEzZktQMlY4MVFmdGJESXNMU01KZ0NQeENNUE5ucEV4UnRsaWUvbENwcE9DQUFVQWF0REFqenpJQXpIRWRhWnI4aVlvdm5XSzBmTXlXZzJnU1liUTdLNjJGQW1MWHM2VFNjbm56R0p0Qmk3eDQ0c3ZmcEwzaC9DRnhOMkw0UnRoRTMzcE9pVUV3bElBcFQ2TkhzNmVJTm9KNGVtWlVER0FxSi9BMU94Z2h3S0FBTmtvMGpzenhtUnNMNEM4dkFxRXV2OTJFMnpNNUUyLzVhTlA1OG5MYXZKaVo0djlvcGxQUC8xQmZSYzk1VWxuck8vU2E3T0NUMHJkdkF6Z2xONk1DYVQ2ZWQ2TXJpaUlxeXFjVmVUTTArSTkyWVJBdWdqL1RhVEJtRVJuOU5mdmRYU0FsYjZ1L05vLytZdWZVRkpDSjJFOVFvd0Uxb3lhZkF4VXd4aGhqY0VMbi80RTdlSStVSERPSFBaVXl2RHk1WWlWRVhETVV0V3BxTjMzOVhGY3prSjdoSGNrMEdzZVVMSytaTkE5dUxNQVVUME5VTU44Q1hSdFdPTTFFb2dTaVJISXZZZFFkNTJYWTJwYkNLQnJGNzg3QnpQOXJtMzl0Vk1EZEhkUDNnc0prdmg3L3J4WmtiYk5NVmJlRlN0ckdscVlnL2tVM1hjV0NFaktJY3g5MFVTVi9WbjY0MEJQNkNNbkk1U2svTzRMV0RITXkzaThLTGIrYU1NN0xVc1hnYzNzZ1FwZnZYRnhlSkxkVy83QU5aWmFtTFh0OUFFZXJPZHBKUWJLREo1OS9tTDY0c3MzMDIvLzduK2Zmdk0zZnplbFBpK0V0OGc0U2lOMkx4NHZtYmdwVDNKZnVZYWt0bVRydk1VS2oya09QUzlLbGw0Mm5xdjZ6d3NpL0JUQzdDNWc0UzJNTUR0K0VFUjBvc3crQVpOemhiSEd2dUFGWU9hUmpkbXN6aEU2U2pHb2pJZDA1d0g0ZU5WQmExSG5IUjU0Qkl4RUhHc01BSDdNVE5ibnhiWkNoRjdlVHh2S1dtenpvdGJQakJaNVZZLzBvandNNzB0cERiRFlDN1QxRDRqd3ZPV1lyS29ncjd6cTJUQytHMHVkY2k2NTVlMEEyY1g0OTFQV01ST1gxeW5uSzgwaWdTeUtJTGVNRlhyTnM0Y0JCWm53WC93REV0YmpMVUpwWHRSWTg1cW5RZTRmUDVZYXNVT0UzVFVBOFZ5VHhZdUtJb0c1c0ZpL1pvTkE5a2NFMFNkdmg4RTJMbVBoQ2JtMy9wbzkzcStFYUM4RFBqeWdlS1hQeGswWDF3ckxsWWt3dnNIVDBCZXBHNTZQM0xSeW5JUTJIWldvYjQxaTR4UFdTZllmVlhzMUNtamY4WjA4REs5cUFCR2ROSWJrdnJZVzhzR2I5c2JQL2FkL1o0aUFzWGdWdWpmSWJpQS9JY2NCMlZnSmVrTW92R2ZVYmgxUzNnOXZSM2dsMXlWTWtPK2hSRHU1ekFZbm1TYlpxdXFabTJmZ2RtTUFERUtXTlRPTElidms4RlRoMlBWTnljQUhUNFl3RFJDSWlOcmhmZ0k5U3M5TDB3Y0FSNkdWV0FBWkFPQzErRjA1aHVNOEYyVUFBeFFwVkY2ak1SbXI2eFh5K2Z2Qnc0T1N0WStuNzM3M3UzbC9kanBJc0NNVUwwTVlUSkFWRzhwNVNMQnIrN2daTU5vK2U1bTExelZlQ0Mra0VSYU1FbzNvUnBuOFRjSFBFbUJUdGZzQm9SZWhHZFgxblFONGhnSUdkb1IvMUZrVnZyRFlxNEgxUlJZdm5uYVB3cjJ1MjBZUEFwZHdubGNqUlpqUWxMZno1aWdBS1BmMHJObXk3Lzd4RDhzN25FMC8rUFJsd2xyZUprTTB3cS80TFBUVHBsQjg1TUJXYUV5NVEwcTJrWEJVRHNHSThRelA0L05sRm5SNHZuS05hVFZGSlRjRHJQSncwQmFQMFhXQWY5S00vbWptMCs5NDduUHhFaTVGd0ZFTHRDU3hINi94MUd6a1p0K1ZVdUJqK3RmeWpnQlRTRlVidXlrQ1JiWVR5R215d3VOYWFycC9MYThYS0F3UTZENFhsWk44bGRld1ZuaW1HUGkwRWdFVFN4dnROSEwrOG1SNi91cG8rdlovL2FNOGhjK212L2szZm5GNjhyQmFvWlVRYTBvZjh0WldDdmNPTzJaQjlOWHQrUUFiQ1dvVjNFSXB0VUtOY29DL2ZpbEVCY2JDUWZ0VjhVU1VucGl3QWlJTXFQZHN1SktQK0daeVJVcUF0eVRIZWRXT0N6emE5V1plWGFOeGNyVHp3UWVGN20rajRUc1pqbDJ1bCtmTGx4MnovRUprTkFiNjVJdkR3T2ppbTM2TmM3cy8rZWJwUzNuUVo5WDBacWROamdpNzc4cERqVklSZlkwWElndlhDL1g2VXVxZ2RwUDNrVy9NYzU0TjAzQjRtejBPakd2SDhqSkFKTXJhVkovWCtHNzdKM1BaOTNqRVcreFRHc2Q2V2xHWWR1REZHSGVlMkpyMWpPOWU5TVBMY3NGb2dnZ0JRSzZmbkFTSDEycHRKeEd3RWFhOEF3Y0NpZ2hEc0ZKazFzczVrdXVZaEVnUytOZE53WTV0UlpyVkFXQ0lwS1JnQVlBSWFyWDdRc2gxRmowa0RJSFZBcEFReFF1aktmaHVicXByM2Q5OU1jTng0WjIyTVFCNERFVWFscmlsQmNYUVppNzFjWEZmd0NrY1BLcUV3aUp1QUxWU1h4Vlp1b2M4ems1V1c0RXBWN3VmczI2RmpkMlBoUmc1dWl5VDhNeDk1WHhPbEZxa2hOenUrQnBOZ1hXQzBIZDlmVkxKaUw1Z3c1aU02RHFDb0svR2F5ek9ZeFVsbHdINFdJZEhyMlAxcUtMdU43eVNET2NCYkt4bmtRT290NFV0NXdIVzlzYkQ2Yk1YejZmdi9NRVBweC8rNEl1TzUxVlV1NllzNGFJd3pYS2EzZll3VS9TN2JPYXIrK0wxWHJtNDlmaXh2UlcvdHpzV0grU3FlRlhIWDFXUU9RekFQRUdBVnNETUVod0F1bUt3S1Jldmp3Y3piM01UZnh0TDNSN0tnWWRtTS9FSHZYd2Z1YkM4Q3Q1WC8zY2VReGtnNWdHdXBPam5LYkpjVWo3VmRMSlVxVUV5d0ZCc1JPT1ZlRUtFVGVUVTNKamhWYUhQd09FeHViVDMwc3ZucjVLN1ppY3JrWkRBZCt5NG5PS2JRdVBkQTk3bGNvRDFQR0QvamVtYlAvdlI5TmYreWk5T0QvSU8zcjU1SHJpVkc3UWd0eVZHbTlzUzBnd3ViNXlYWGQxUUorem1VVnkwU3NEaWZkN3pVVE9IajU5K09HVGU4Zk8yS0NwSE1Md05FWVAreS8vTkUwTTgrbzNwcmZ4VW5xWThFcEJqZk9iSkRzWTdBT2xlMWlQZUprdThkU0hnY2psSHVxRklGaitNV2FKL2JKNlkzS3pYTGlCVXZzS0RsVDg2eU9IQUg2VStQRDNHeW1TTU9qcWhPbzhXSUpxZE5TRmdva1NtVGpIMjJ5T3ptM01waFUzOTFGSWVGWWJ6cXBmcFRmSURMQm1NdzR6N0ZjT1RXTVRwM2lTK2IvMDJRREs5QTFJY0VvNElCNEpPT1VmbHdFcGxOTUxxR043N1Q3OVcvdFgvOU11ZlVBQ3VQMnZCV3pGRGlQZ0VDemhSTHNJSHVCeERLTW9scVMyL0JXeDRXSVJGekQ0MnBPdGN4SmJMMGlIZUVUQmFXQmtFMXBhUVN0aUU4QWppbU5maWZqNUhIVW5FbUk4M3JQcEd5U2swQWFBRSt1T1lkbWZQREdpOEsrNnJUZTR0dW8zekFsUWhqZG9nZWFyM0tuYmJqWGpjNGFWQ2dGR1hFNnU0L05hQ0NWMW1TOFZxRlhyMEJzS3N2L0hvTTBFRzJHSjBpNEtOUjFIa21EUklLU2lLUkNUUWN6NmFvcWV4K1J2ampHY0lYbjJRVjJCcEZrclBrOFgyZ3lxS3VkKzh5RkhHVWRIazY5Y3RtMmdweC9yS3p2U3NLZjcvNS8vKzllbDNmdnQ3OFZHSWsxZFlVdjA2SVdCemVIdEtOWUFmejNNelFYNnZuTTdqdzl6dmZlUGpqcU9WU3VUTFpueE9vMUZHb092UENIVEtRZkNFZllSS1htMElGbm5wUDRKdVJvaVhPTW9hNHNFd1JrTG5nSTFDR0ZPM0g0bzdydXE3dkpWcjBMTm1Pa2VJR0NoR0M1WWZDSTRWL3QxTk8zTlJaMG5ucmhGMjZZZmRMTVpTa295dXVqZVRRUURKekIwUFF2aTVMdVRLUUYrbnJJRFI3UUNSMG95WGxYV2NsbmUwYjVjdGhRQ3FuVFB3aEdmbTA3azhJZUdSb2xueVpHMG9Zd1ZjRlQ2UDZLRXg0T2VReGNZQURQUnhJMzR6UXZxNlhRckdUZ2Q3K3c5R3lLYjBSRWcxZzVXRS9MeFJKRnFMVmFVbmhyNGxLNnJIcnhyRHlPMzJtNWw3cnd1N1A5UlBocFZSTjM1OUpQeHljQXY5R2xYM0VkcHlMOTYvZXg0ZUpGc0JMOW9NVHpWOXdFdTVOVHFxUUJTd0xmaUtQMEpiTTRoaFUvcWdiSVFlOGNCNXMzYk9hRXpwQ2R1MUcwWUlENDNCeEFCZXo4YXF2SGgvMDJWNTBWRW5sN29Mby9lZS9GM0RHaThlMmNxdi9lb3ZmTUpGTXhnZEdBV0pFVXFzNlFRREZMSm96QTBNZmk1RUMxd1NISjdHN04yMFpxMTFTR0phaWpnemEzc2dxbG9PWUtJOXdnWVUvUzcwOHhKcTJsYkV0aFVJQzF3UXlIMFFmU2h4MSt1TGhHZGkxbmVKU211aTVxbGFmZE9lOWxVcUo0WmR4eG9HQnVXYzFEYng4bWdESWpuZUFQS3FDSzJaTGZHL0N1RFpnMUl6NVhydDY1TVpxQU5KM0pTVnd0bHZDaTBXU25yZUxLdE1OakNvNWVGK3oxNktpdi9jK3hqUG9uWDVvT01jS2xIOGtyRGRZMjZ6c2RUbVNlQStrcGtkTjE0Q0lyZklJQ3gyUGxBSGRWbWhwbnpWdzBjZkJDcTMwLy8xci8vZjZkLzhtMSt2TXJuNm9BU1FaMmdHaUlVencwdkp0R2N4OTRGRWU0V1dCNjNUTzJ5RzhlVDRlZU81bmo3KzJrZURkbkpBWnlYMVQ4dGQzUmF2bUZVVExxNlVrQmJpQWZXUjIwa0o1OFcwTXdETzlIQmZPY1RDQThvMmVvQ01hQ3I1Syt5dG5kN1dubzJaTVlCY3Uyck5LSDZZMG52dXV4MWZKWE9IUjVBeVVCcXZrZmVNMktOa3Buc01SWTNPREs4dzhENWxJb3NXOVFON2JRSjY3Y3NQQ3FsNHhJQWRuWUM2ZFpjdnZxb3NvbnFrdmIwMnp1Tk54aVBsSmdDVFJ5R0swQzR2RTkvSUNhRFdQcjU2eVduUkdic1NyQ1Y3QXp5R3JGSk00ZDdjRnIzVEo2VW53blZ5RGFoNEdzTWc1Z0NZWGViNWV3R0k4MzRIRUFhRnQvSmE1SDZSNTNTY2pMc244SkNhOGVsMy9YSlBnRFRLS1BwdUhNb29lRVBLVW00Q1dHT2lSK3JkeHNUSzBNTTVmMFUyT0FsMGxCT2lVSnRIUlE3SXZMS2x1U1FsVUUrZWNWRWY2UlI1ajJSOWo2N3hFZjJjUHlybWk1S1VVZW12a2hXOE9YanY3dzI1V2VqSHlqLzh1ei96aWNFQ0ZONE9wVFlnRFhzVEFrQ3g4QVQ4UFFoUkI0R1ZiU2dBanZWN3R2UFFHZDdVSXNSaENjOVNaa3pHRE9mUFNpcW1ENG5meGRpSzRVeG42eGhPQUIvZjljMTdEaVhtUEJRUFRwL2NZL0hXcGhmbFZ4bC9XKzdsTm1iUGVSUXpld1JFQ0NUcEhxSGlmMkEva0gwa3hmTTBnSmJacUZIekZkUG0rMGVQQk1tT0NGNW1RTWRzWkV3QTlHUGlvSEhaNlZOaEh5QWVuZ0JGU2hEcmVnS1FwOXA0NXRrdGdtTUszcDVDczhEUEZwQXlkZTh1aVBMdG01VlZiSXdFUjY3S2NSWkhHQ1prc0ZqNjlXdlY3N1lDdVpoKzZ6LyszdlFidi9HN3piS1UrOHJ5aDhVdFlNZExST0doNUxMNzJsdSticS9pd0tYN0xHaS9tWVZLcCt0VEZpeWlIQjFaSEc1dFdTdnJUK05KNitjYVdRcHBsblBlV004czcxajcyQzhNSFk4TVhWaFVOQjV5cEJQbzFOK1VraWVQcG9SMWhERXBzdVR4Q2k4MjNsQVVnbXJteTk5bSttNXFBMkM0empHMDByZEZNcG5NOE1ESXIyN3dDSUwvdWVTaCsxaTdLZlVnVFdFZkxIUzdLUDlIR1NoeG82OS9RbVpGcnhMR1F0UGJacm1PcGhjbDVmL3lMLzNWNldsN2p5bHpjVy8zTlRFamZ5dGNZa3draTRHdC9nRXkzeFZxa2dWOFEzVDlOMzYvQzFjZHR2Q2I1ODNyM1c4MzBMRU56anU1VnIwdjRhOW1pb0VSV0FtL2VaTThHcE1YMjMxMnMzcVJzUFgvTU9hTlM0RTFwNkJEQVduL2RtOFJGTjF3ZjRmb0RlTmk3YXZrOW01ZUtOQmdRQWIvK20zUVA2TGluYlNMNDFaNVNLcVRSUVBqQXpDaTVCVGZ5TFEwQWhxNHY5bkFVWG1RNFdMQVlBYUFIUHVrZFM1WkFIdytHUkI5YlFoZEswZDlOejM2OEZjRzdkQnZ5TTZ2L2VwZi9BUVlpQ0dCT0FZWURDVHY2bUVsL083WUlIYk04akp6SnpTVDQ2Rm90cnhkTEorcDdRQnVWc2pGNzArZlBvMGh3cWtTaFYzTHdpajBkQjkvSzBWQVNGM1ZudC9kMDNkZzZmdnd1UEtXS0FaaDhGNTRiczV6am1PQTZjcXNWdzB1UWpqSHZCQjlEaWNvVGgzTjRxakl0MVlNTVMxYndGam5EQzhUb1dwSGZnWUh4TjVDU1l4eHVaSU81OGV2K2pmUHJzcVpBUDJ4VVZtZURTR2dXTHcwMDdldUcyRkQvZEZ2L1dRRUtJVFEwTlR4U3FIWkFnRG1Cei9rTWZaN09qWVkvcUlhbzdYMS9ZUittbjc5MS85amhhQy9YWkk1dWxRbkpZbDZWZEsrbnRkK0h1eURscTdrVVFHWnJmaTBMUitWTjlnTWZvQUZqTmVtcDFXS2IxWUZiaVp1dXhtbHJhYnZsV1VvSmwxYVRaRnphaVJnaGZ4ams3dG9qYytVbnlLaGdVU3U4ZmliTXZqdXZaQWw4bVNjaEpOM2RGVmJybCtBa1dzSU9rS1BxZnUrRDQ4TjdoSE82RFNVSUpuaGxjRkRlUnFXR3Mwdm14bU9xMk5KRWtMWlhCSlA3YlJoMDBUZWhaQ0hkK1grSk53TTJNalZCUjZqWnF5RGJ6Syt3dCtqRXVDZmYvRnN5SlRDU0xKVno2SXZZejJId09UQk1VQXJqR2NNZVlZTTdpaE5pSmZ6bUhoT3MrRUJYRUNxSHdabzhnaHRKVVBQQmxGcjBYRFJkeGpIQnFwMmtiNE4vYWdmdGhRSDVLUE42S0kyVVFrSEQ1OGhIY0JSZStScGdPYVFCZDZ0RW80TWVYcHdtaU1ocEJUYTlpV3ZiZzdiZ1E4angwdmoxYU9WNzQ0emFHZ0tzSlJCekY1aE9KRTM1dGpJd3hVV3orbUNQS3prYlU0dlJkajZ5R2liVmVkeENWY1pMbnBpbnk1OEZLNmIwR0RrOGVYUkI0V0VkQkF4ZXEzODZqLzQ1aWVRRGNwYUEyWXZLd2xCQk9mT1VYaHh1QnRwSERFVUNycVprSkFBQWlXemE2U0pHd3pkZ1pNMkVJNlFRYzNuWHoxUHFlMzk1RUVVODRiNUJzd0ttQXJXRnFJQU1PQXpRS0g3NmNOc1FkWDl6RE9GQytWMnppSWY1QnJIV1NXemxjQUhzekJ0QVFqT2Q3OEJZSlF2eGhFeXhITHZPWWxidmlZZ1lwbk4xSm4yeFl5aFJORU44WGlHZ0ViN3dJa2lJQ2xQY2E4cFlzUzJZc0FPaTVLOXJMWVprNTFDTU9zSFhiY2wzOUUxRkYxYkJIdk1HQ2FzckJYTFpGZEtRbWlLM0dxQWk4RG9xeGR2S29ZODZuMDYvZXQvL2UrbTMvK3Yzd3VnQXVueitpRjhDeVFVRSs1VnpEZW1pRU9tUGZkS0VOS3B1cHJIa3ZXV3YxcXFHREVLNUNXM1huTy85V2dCc3lVNHo3NThrWmR4T3U0blVXL1dseWRpMXBEaW94bVprT2N5Q09Eb1AwYU54MFNZalpzQWN2Tm5RNVV4YWR6QVJ2aWdkT002cTB1bUlzaXNvQm1XVVVBWUxYZ01hRUl4ZlIrNXMvcEcwTWlmZnFqVm93Q2V0R0xYVlo2QUt1bGhCR3ByaE5lZHo1UGJpaDY4UXZjSFZFTVJvd2VsNUlIVWhmcmgvNENuZGs5N0Vvd0U5UTkrOUlOaG1PUmY1SkVZZHlHdHQ2Zmg4TEFBVi9BeTVNcFl6UXlTV2JLTXY4NGhHek9JQjN6ZGwwY2xNaUczNUVHLy9XNTh2TlpSUHBNOEQvcEVXMkg5QUxmR1B1ZkVDaFU3bi9LUFhXSHpYQURjSFBMTnhsNHRsTHphQ0VFSDM1TC83aUNIRlJHSFRJNWRYdU9qSERMWkhybTJkTTRuUFhaTWtsNmFZZVRHVE00eDRQVkdnYlp5aVU0Wjkrbmc4SGpsd1JreER0RFlXcHdyMWhqcEdkNTE2Y0FMZ0FrY0ZJMERjaDdmWEp3ZUFEYTIvY2QvY3o3WDZSRnQ1Vi84cy8vaEU0QmtRQVk3ZzB6Q1hFY2ZOQVUvdGswdWZKQ2Y4VGdzZ2o4SUdNSFZmMWdhd2ZKemxiblpZdGloM0RvUmd5d3hVUmpubUZrSDRaYzFXenBOeFUzUjkyTVdLazhrQU9IeVlwU1pPMmh1OTBoL0V4S01SeGkxUndERGExRVNZREQ2UHJ5ZGdNZDFMQWwwQjA2QTdQalU1b0N6UnlXeGZGMy9IaFEzRDhIcTk1SDNxQjNDZGxxeTJlcjN6T1ZRQWg2a1VvS1JBK2djVStkakM1dkdZR0d5Y29YakxKWk45aDFYNTZOSThPR2pKOUUxZ0VnNFZOQy9LZG1PS2NhT1FYTXl1SVJzWHQ1aW5HUEpSbFA0OXNMYVRtajJvN1BIUWFtak11UDN2UjkvTmYzNEoyK203L3orajZjZmZ2K0xMQ09McnoxR0JJMU5GOHM3eWZkWVhKMUhEQ0NhSmJ4THdPTFd0QnRmY2tYeXVQSjJDZ24zOXhTUWxxTktEdlQ3YlROakp5M0l0WEQzc3V1cXh1UUg1SUZsWEFJa2RCUitvYTNkYWlsY0o5VUhua0tlMXJ1Y0Y2L25xdllPV2pVaGxCbExVZUxoV2daT3dhYzhHNEFkZVpnVUR4L0pCcUZsSUJ3bjZNb1l0aHhMa1FsQkVGUm5oSkxBaGN3RC9LQzNjLzE5VWIvT292dEpmVGxuRkZ2bmQ1TVhRdzdsWlBDWTEyRG16bjNHanFCOVdyanI0Ulp0NXpBVUp2Y3l2bFFtQXNBTEVULys2UDFBcTVuQnE2NnJiN3pGSmN0OTJsbkEwNmJrWHhEY1JBMXdzWGQ2V0prZUpQZjF5ZEkxeTNXQXJOVUlkYnZyQzYvcG9QeWdrM3RKN0Q5dU13SExZbXczekhQaENSa2pFR0hveDQ0TWd6eU5yN3VOc29Ub294SjliT2ZTUFJnTTZRaDZDS2psNzU2MDRGOVpBaUNpa3pVMVBXeG1Iajk1WFhKWGxzQ05vdFRHZDVjQ2N6SnV5dkVCV2RGUXpRemFNZkx3QXk3Z0l5R1p2YzdTU00ySVM3UFlCbnJzSkpJODExeThOYU1JQlBQMDY1T0M5TEZGZU4vdjBuUHl0Wkt6WUJYSDN1TzUwaDFOOUhmbG4vK1RiMzFpdDRYWjNTeEVhR0NRemVPOVppOG02OWdOeklDcGs5RnhDZUN4OFg4TlNNQUpCWVZyQ3hDUmhCOUtHaEhYQ3o5R2liOU9kbjRTM2ozeW1MTFFsaUlvTUZQdlFtZ29tOEdiVmFJSVBEV0U5MTI5aGpCTk5UckZuRDJibUdiUS9XMkpCKy9KR3hHQnErKzhLMWJYZHg3QVdFMytEdVZIcUJlUkFEQkZHV3ZBRWpSZWx2UG5xZkh5Qi8yK21CbGRlSEd6Z3NKYU1YaWI3NnVSeWNvK2ZmK0RRQzJtSkpSYlRZbXo1SVJDdms1Zno2dTZsbGdHOWdOZ0duZFVHUVlENkFQUE1YdlhPUjZ2cG04RTViTjJLbmoyNWVzQXIvMm9UbSttMy85dmZ6eDk5NDgrN2Y3MUw3b3FyRHpJZzZNc3ljSmd1TG8zZkRVUjBzY1kzMFpXRWhDTzJjbzJnd3VIaDJGNldMMlJaVCsySmhuUEtpeWZJNVE5TFNkMjJkUzhQSVo4MEVnaXB4QXhjd2diY05sdW5Bd1JaV0xkeDdhL0NiU2RLeGtVY3VUTnNMRzh2S0lHUDhaTmtOR0M0dmRQZEp2UEpkQkFpQkVGYkdNTmEwYUNsU2RITTBEbGhiUGFQSE44N0sxZjQ3cGtDYzI3VTA1bjh0cHhHMCttQjBObWdTcXZlOGhGdjgxOEJXcGQxMzg4ckRvVXNBbGo1aERHd3hWcUpYQ1paNG12TW5qdktjR3ByOWQ1V2o3UlhyR2tQTmZEOW9MalhScUxmcHRWSCtGUWZVZ2RoOUxYNFFFVThuZG0xV2NROFZpc3ZMQm95ZnZUVDk2eEh0bEJoS0V6eGtFejE1Y0hRM3Q2TTFJS3d6bVk4MThpbmxGLzFiaUVyZHBYbGpCZXRlRjhZTVpRMmFLY1YwVUg1ZVBrMFBRYjcwMUNvQ2ZkSmJmb1JyWkcrL1cxRHRWa28wb0g4TnFZbVJYVjdhTkVvZlBWclMzU0NhNEh6dTVINXV2S2FJOUJzZi9ZYWFzTzZQSGhVeUhoM0YxOVgvbVh2L2FYUCtHdThyRHNUYU5EWW1tekJyd0pGcG9RV0FQR0pSMkVSc2lVK21VMVRCcTFSWXRyQUFQbE5RaXZJYWdCbFRDaUpvYndBVGh4TFcrRmhZUGtZOWVHQ0VSb3VNTGlja3h4MFV4Z1c2aTJQM3ZlQ1NZWm9BSDdSTHdSdmtZMDkvUDNuSCthejNHOWwzNGlLRXRIQUNnYUpSaTFUVjBEOEFpSU1RaDE5VVY0dzZVZFljWTdRSFF0Sm12WC9WekhUUWJNYURmVzI4VmtTMWdVYW1JQWhudXpqTHhReDF3L0EzT0FWVis0NkhoUUZ4UGxQTThBbW9TcXNYcjk4bTBlR3didWxnZytuMzc3dC85YmZTck1sVmZpOHBjdkJPVDJOTFA4YVR5SW9yNnc3amE0c3pDYlJQQlMyTy9MNnVFc2J0MnJIc3VtZXg5LzlNSDA0VWZ2RGFNZzhmcVc0QVpZejl1WCs2aUV2aTFwQUhCSU15d2dZUnlLbGp3SUU2MHF3QzhXVmlHa3dzb09ES1g2MnRlK05tYWVBUlVQZVNUVCswMS9lRGtqclVET2tvZWhtSGdTUGJ5QWtOKzlSZ2daejBjSU5JNjlrK0orUTB0THRUTElRMDRRVVY5bWVVaHRPcCtzWldXSHdhU2NsTlJPRkZJVU5aQXN6ZDdPQ0R2aVo4TFJZWjRrcjVYczVuMEZjbStPWG81U2hQMUtFUjVYemlCOEJTS1dhcEV4VmVqdVBUeTRaRVh1a29FYTZ0dy9ZMEtrOFFFQ2NvQnU4cjBVVnowY3cweXVrVUE3UEJCMFlKUUFvdFFOQUFBZWMzNnZzVVZMNDZOVDJySWJDanJONERKL0g3L1hGN0k4RXZuSnljZy9KWFZnS0pNQUFFQUFTVVJCVkd2Q1ZoNGRqMUY2YUQ1M3puMlJkVFFDcHVUVGNoMjZ1Q2hWQWF5RGI5R0w3bzFKcnU2dHZuSjR4M2pSOGJGK0ZQMEg3RWJleGpTRDNsd1k2MW92OXdCa2VNY1E3ano4NjBSdHZQQjU1Ui85eWpjK0FUQnVPbUx2aEVJbmhFTEQ2K2tHdkNHNUNvdWhFWjdsa1VEdStnRlFCa0J4ZVZsbURBM1NEY1cyWFBqTDF1RkJWc2ZtcFFvbDNRT3luUkxCT3hSS2ZGeGorcUF0Zy9GMlB0RHdNaUNXZ2hmaE4wejFkcjZCODhhOFhHUG1EaWdhS2NLT1hFQmptZ1VCWVdaTHlKTkNDMElqZk9RbEdMdThsZnZ4N3B5clgzSWNmcHNKT3hlb3pqUXdQZHdZdXBhbGw3ZmF0Vllyd0VJblFpK3NxSXNENUFtWGFWeXVPdkEzcTBaQkFmRW9RNGpBS3VLdEsxd1A4Q3pZUFhsYnRYa0xsYzh2bHFiLzhCOStiL3J1OTU4MWxwb3ZWRWl0NnU4OE02WnVUQ0dyUEIrM1doZ28velZtM2VvYnpSdUZybmxTTzRYNWg0Y0JXdDRDNzhxU0hDRzRFRTdTMmI1TTdyRWFXSG5lbkcxcDlBL2ZLS2IrenFVU3N4ZUNoNmxOTkN2RWpxNm0zcTFITkt2MFZibExZTVhiNGduSWNSRm1mRU5mWGhLNkRERHEwNHZjREprSWtNa1RJRUgvT1MvbW5LN3JITmN3a21SWDNzNTUzZ3dTWmVjRjRLMDJ5QXJ3d20raEl5T0w5a0FVWUFFQjQxSWthMUh4Q0lQam4xbFpFY01NRUhaSjdRRUw4ZWFqaWlmSExoSFJGZy9RSDZqb3AvUE5oZ0VOWHFkd2pmSzRuNFhpbmhoa2h4Ti82OWNpTDBZcDZhNVBmV1Y4ZlFvMWgyem5zWm1sMDEvOTFpZC9rd1B5UGZyUnVPbTB0dEdDbHdySWZKZDN0RW9GTCtUd2VMVG9JWWNrWk1jTGRFRmhiM1FtMitoTXY3V2hILzcyWFhTbHI5MXF2RGc1QUllT2toUFJnaWlCSG81UXNkUVNIZExHNE1kb295ZjJkQXhZRGFOZFMwUFg2dC9PdzErZUcrN2ZBVmovOUI5OTh4TWRxWitqWStON2dqbVdoVVFrSUlIcDg2RG5yVUhHdEdUbkRKZXVqa050SFhDdFJ2Mk5ZRUxOeDQvYlM2ZWxEcExick1OVzhiR1FvTk1HSTYzN3doUktqRGl1TTloQmhFNHlrQVZBQVMrV2kvQUpQd21zMzl3WHMzaGFya2ZJbW1yUVRTUlVSa0Y0MUd3aGtPU2t2ekhGMDZubHJVYm9RQmtIa2JOcVVkL3YxbGNSTmdLUFFRdlBDRkVCMklLUkJFTklPSmdjVUhsZ0JEQ2FwNmtUeURyajdRUUZnejZOajZDNFZwZ3RSMlhteUdvRE0xOWM2VnFvd3JqSzVEZnRWZlhsOGZSZnZ2MUgwMmVmdHdYdGd5ZU5zWFdkZVVQeUR2cXR3Rlcrd0hQdzFsT2Nnd1RwM1RLRzdobVlsQiswOTVrRnRSWk1iNnh6MSs5YmVwU3kyM0Vpa0VOTGdDVWtYRW9obDZLTitpQzdYcUtUM0lPM0hRblFqRmRFd0lWNmhCTmRDYWNrdVhWdXoxOCtyMkxjNDlGbk9XSzU4Y2w1YUJvQmh0eWdCZDRNQUtvUGcvZERnTkdjWnh6SjRpa2hKbWVZNjI5OStHbEZZaUlZV3V6WHI0VWNJRGpQMXZseVg1MHlqSXZmZVc3Nk5DNTFYU0NRQUZRak5vTU9zQm9QV0VHWGRHUjdlQnZDNUVBcUwrTHh3L2JjYXJZYmdBQW45eHJGbStoVlg0MWRkSUpHUEdIdG1kUWdtd2Z0LzBhK0dIdDJqWGZpL2xJUituYWFUSkZwb1NRd1ZrdjR0bkN1YnRhWGFObTVYVjRiaGFrQnR2QVREUUU5andudDZBeDlXUUMyOFNvamNKNTZNUGNYTHROQnRDVFh4akRLVGJxZXJOTm4vV0VZNE1BQXk0RFBmUUdXdG5sOW9oSEhlT0RPaTlKLzBoL0pkbVZQQ2Vob2E5Qys5bWNkbVBVQTM5RnJUTWhscVBUeDhMMXlXTzllNC9mLzdYLzllNTlRZnJFeUJhVHcvbFo2LzZZOGtFcHdDVW1nTUpoZE55Z3lvaUVtSU5Ld3hyd3czd0FSU3B1UzM4SUJBaW5NQk1XdjgwSlU5STQxWHdnMnZQNVphTFd6eUVrWTFFellFdWkxTzVnb3RHandnTXdiRVYyRGFEd2hmd01iWUlyNWhGUk1UbmhHZndxOTlHOEFaTzJyY1BleThOczUydEdlL3ByZVh6REhNY0JOQ1BRREk5Rmh6anNBNDNJRkNjQkJpZEtqZGdZWTYrU0NuTlhXaEkxcDJoUmZlSUJtcmdkb2Nod0Fpekx4WGdEV2JQVjY4a2xGaTE5OTFiNWt4KzNlK29PdnB0LzVMMzh3L2ZCSFgrVzBGVHJtOGJ4cXBqQUN6SDFKUUlDUVZlOUNYS1VUdHZFVkpsbG05TGFDWG91eHJjMVNnN1hjT2tGZ2RYcnlKby9JUm9uYmVXOW1xNWJIbzVyT1U4N3RuWU9SdlAzeStjdEJOd2xTcFNKb3J5NW80WlVNWXhadmhQRmVQQ1B5WW85eUlZcmZ5WUlSVXc0ODRJSGg2OGpEREVNdzA5UXhDb1UrcE1uNnNnZzArTHd3Ukl3bHhRSjQ1SFgyZnVmY0VDQ01uQm1NUEszNExrS1lGVUpyU2V3c29zTmdNbnpDMmJyVS9ZUjgya1hQUUZEb3JPMzYydDBiYzhwWlNHanBGbU0yeitEZFRTKy8vSEw4ZlJqUFIrN0hOa3JkZzh4QlJZWm96SDQzZXlnRVZmZGxCMUpBWVJaWjJ4TGl3a09KYmt1TEFEN3dsek9XQjJOb0tiNStrY20xZUd0cERqMURTM0lvSlNHTmdQYkhMWmN4RysxY2RDTHJrWEI0VkhSNEdQM09Nd3ZlUjdvWHJaTWZjazMyRjU0T2p4bW9tdGwwM0xWb2FkVUtQdUtWV1hqMEI3Z21pdHdISFd0dTdIeGhYellsUUtJZE9HRFZpeElpTCtlYVJOQ21sN1dUMnBVNlFjVFJKenIyK0pkSG54YjZQcEx1QmlXOEdiSHNDS0hrazJiQkdiRnFWcHN5WTRET1lZaTNRWXE1Q1JQaU9JY1ZuQWVqTXJ5dFUxLzAxT2M2NjF3RlpoY0ptdGxEbTlhN3gxeC8wY0FvV2VmNUpMUXNrZ1NvS3ViMUViZXo3bmsyRVhvQkdqNEIxQUREUHZWaHVKSXhIVWlwa1JwaGJRSzUyTFRNekovcFl6Vko5cjRLOXJwR1lseGVTNjVBdGZtY215RllRbUZLZ29nVVJDakhjd0kwMm5JTVV3bS9SeldONStNbGhKNDJzOUptZUFEb2JTSFdSUjdVcURkcE5yUkd4blVSWkFqeEtPMUl4ajFPWFIvc1dlVEJwSC8waHorYWZ2enBpK243UDN3MmZmZDdYelRiU3NIeUNCSVdRcXVmaEVLdXcrNEtTV3pYS213TTRGdlBhRlpOa2EzZE1pMjUyV3M5cFJEUXpneXJxd0Z5bnRYV1Z2dDlWY0gvL1BsbjhhVW5DUmYrcTBIYUxGeFIyYzY0bkNSb3JMK0U4MWlmTmd6Y3ZDWlFHRGp2MERsYmVzV0I0NGsrS2Rtd3Nra21ucEJRTWdPa2Ftd0lvV040NWoxQ21YaE9ZWGtxOGxIQTBXdk83N0QrYXZEbWZObXc1TkhQYXlSMUNYbC9VMkJ0Q0lPN21WdjA4cytzbEF3WnhhQllQc21PWDRHa3NJdGg0Z1dUNWZGNHJjNVIxaklVdXpFSitSWkFCc1JldFRVd2VYN3Y2Wk1SL2xMY3VUK3pNZEVQY20yVzlFaVpTK0EwODcwQkpudjZCUXlzMzN2WmxzWHVyNFRGTVVaMTl2NmFjZE9uK0dsR2JRNmZlWnB5WWhtUHZDUHliUXNsVmZKb1FQNDlJNENpencrUG1FTml1c2tESTdkMmNFQXI4b3Z2M3ZydTc5a0F6YzZJKytBaFhkY3ZQQmhHcFhiZ2dlOTJLSVlWRVgzUVNHaWRBMXIvdFptWFdUU1RwS1R2TTQySkFTQWMrbVRXTlBrSFZtU0VFd0RJeVBmT3d6LzltSytWdi8zTFR6NlpGWDcyTUhnbDlycUIvT2hwaGs4dXd0dWp2bFhFcXZWaEpWbmtCWkpqTUdJc1BtMmFSeEFoT2tMcW9Hc1d0UytJcjdPSWFSYU5JTTB4TGthUzZmWi9mamZMaEduKzlzeENBRWRCRjhlQWx2dTRMOElocURIWXVjRzkxYUNJMXowNjI2VENYTll3RjY0cXRGTmk0VHdieFlubmdaUTJkVmk3N2tPSUhQTjJqNSsrNXhDQSttWkdiWWgraFBiWStPeE5pdXc2dVJENXQ3bDB4S1NETnR4VHU2enJHSCtmbUlUUm5xRHRhVFhQdm5oZFdIVTYvZjUvLzJFRmxvbDJSYUYzS1UvL1I2QTgwYWJGRlVldTlWM3lWem1ENVVWRFllUGZRZmtrZkR1OXJDNnRzVmcxdjlaR2FuYzk2R0E3b0ZMS01JQXM2MzdobkhJM0xML25DTHJKUnVHUGtnMkx5VmxKWGh3YUFTWDhBRllzdjNXa0RFTXRqM0VGQmNNd1dSQzhlRkVBbmdsRmtWc2lOL0k2OGxuYVF0T0ZkN3ZZMFhia3BCSjZ3SUpXdkZQZkdUcUs3bzMrdkRlQW9rMWVCdnBTRkdmZ29iZmMyZUJqMyt2cXVOeDF3MEExTnNXZ3lnN2sxa2JmbWlGVHBkMVFPcCsza2dMbGdlbnI4Q1lTMHhYaDNlRDFYUXZiSzBISUlBRDJUa2wvTEs5UjdwR1NWbERzaHNiSU9JNUVmSEk4TnBDTTM4WkFtZCswY0pvY3o4bHlYbjZ6bGRGNnBGTUNjWk1GREQ1akx2eHlyakdPdFkyMXpjdENCeklrWjhpUklHZkdveS9vR1JIRzkwZzBqT1BveS9DbUFvdUF5S1FVSGJBVzB4NWF3TFZMQmszeHg1dCs0WVVYZVNCam5qNWxGdEJra1g1VS9kSXJMOTRhNG1nT0RPWE95Q3BkRzNyRFljbno1STJLTG95SndZNER3eUJyWXZmaFh4MTh3N3ZCdjMveHovN2lKNDhlUGFvRGRxOE1KQXE1SUt5YWsvRmNRaVBEdFRxeFdBSFBJeUIwQ0lDQkJ1SGx1NDRNMElwSVltK0RyOTlOcFRaVjJkL1FuMmhqbGdjUkFER0t4d1hrQ1NBdXhrSnpTSTdnWG9UT00vaUdFUFk3SVlMNmkybHpDWDZockdzVXNpb2NIY3hLQUcxZE93alVQUWp6Z3RFMkZWUkZQb05VZ2gwQi9VN29GMWFFOSttWXNRRXZmYU1NMnVQQnlSc1FJRW5taTM2WDNFUXJZRFhDdlJoaHMzNDdOd0JUaXMvOUY1SUlFUUN3a0JDTjVsbW9aa0tyR2ZxdDMvelB6UXdlVDU4OWV6bjJMYmNzSnQwWWlsQXVmNEM3YTdvNDJwaGxsTi94Wk9LbXJHdDdDRkswdDQ3eXFOQ3Z6Y0liVTBXZkxhM3hVSWFOaWtidFVxcjJhaXcxYVVjQXUya29SYmhPZ0Y0UGNNK2JRSXVVdDJFUGZxRXBUOFNhVTBsNkJiTmtBVitHWUtkNFk2K2x4cTE3UUpod24rWHhBV2EwY2h4OXgzV01YbU1RMXFEcEFuVDZNaXRKT1pVRjdQbWQvQXdldmZ2ZCtXUURDQkhWaFdBditOZXRCajlkNnlXVVhCZ2g1d0JhOHVCaS9mZEoyUUdVSnhMNXpYSXNqM3RqQ09nRVlKdG52U1RRQXhxeWQ5SHpNOVB2ZzRkV0NhU0U2b25rQWFOUkVqN0dDbWpOdUkwWjQ0REx3S1EvUmo2MS9BNkZKVi9IR2R2RnVQUVJrSXhaeHloblJ3dXZGeTlmakxCTEVmY29iaDU2YU9Kb0JqS3lSYStGamVSNUVRV1JZNjg1VjBXV0plSGx0UFJSM2FPeUlrK3NLYXJLNHlHek50aGM5T2QxbFFHaUd1MEFWTmZncjQwRFBJUVdoa2kwTDNKdUJFT3g3a3hUOVhadENaUk9PWStNbXBRQ1Z2aktzUE93T0RMb0FEQzNELy9TNk8rQ3J5di82bi81YTU4czF6RjdNNjhsNEN4RHJCdTVHS0VQQldSRklLMTlmbFRtcWlXWm1UM0gvWWpFbGRTb3ZNVnhpVzdUOUI3MWpkQVNlQUFKODdtcXN4V1lyUlZtRUdMUEpQUEk5Q0ZNQ1o1RThralVkY3hzbHhET0oySUtYU2tTd01Ka1FJV2c4Z1dJajBqeVpVYzk4aHhCSmRxZHM1T3d1RDloOC9ZRUlCYk14QUtBWkFrd0YzRGlLNC9EZVphckVBcXVPTVlQcjZoWk5BSzRFaEFoOE5pSm9YNnY1YUh3cWhEYnRzZjZLQXdRZnJKZTg2THBrdnBaSHJrSlMyWFVuN2szUTJCUHNoOS8rdVgwQjkvNTRmU2pUNytZUHEzK3lpd2pZeitVTmZZSkF3REJiWHhCTCtNR1dJVE9MaFFVenphM1hPdUxpL2k2TEltZmtVZ205dG9tNWNIQjV2VHhoNCttcjMzOHRQMzZIM1o5WXpIRytLL1dhbXhwWFpMZWxpWnJGUzVaYS9pZzJkejExa3ZlQllEV1RHNXRTdkxYM3lIL2hSTVZUcTRFWG1GbTRXaGhBSUdPZGg3M0pkR0tYMVJOdnlWNVIyZ1VYUUNOOEd3c2RSbDg1eWxtcElZc3FVR2FnVVlkRXFBaTRMTVhZNURKa0xZYU16a2I0VFNGSFRTZlEwdS91VTYwZ0Jkc0E1bmc0WlBwbXAyVnQ3Ymt2cFk3emdzYzFqemV6bDR2K1JWVnpONjI3NUxleHJSaXU1bm9JdlFidXh6RXgvMUNiTGthVS90MjlMV1ZqK2NlTUdCeW0xWTRrR0hsSVBTSjRucElLZ1FqOC9wTFJ4aEducEY4WjNxY2pET0VIUTlNbUFQaklVUHlsbFpsOEphRmxtSXhEenhXcE10elU2UkxwdW0xY1FsNTlXVk9iWFI2NDZHM3hncEF4Mnc1WFFCSTBZM2VrbnZPQVYxbklJYmVwajkxdG1zQnBkemMvSnpIU0RvQWl5ZkY4d0plZER3QjdaZjQ1ZDZObnd6Z3Y3Nk1VTE5Cb3JFM1FCeDRFV0Rwczc5OXJ0YWxNUlcvRk9KZnBEQXJiYi94b1B5U1pRNElLVzkwVTZXcnlsM0pZKzZta05Ic0c0YW9BUGViOE1BbmEvMm1XTncrUDhLVElTUXBrdStzMjBhRFhLbmpTeEVHVXA4bjBIYUF2TDdtMGpiK2dDQy9LKzRrV1lHUVBhdHVJb2JhSW93RVVLekFxQkZMZVc1UFpxdU1pRUJVckR5OHRvb3QzK1RaUEh4NEdNSGUxWm1rUUxVOGhMdEJsUk1DTklGQi9ibklzOWl2M2F0cXhoWVdnaEI0dUdicTNIbTkyNE5JU0F0OFBZWWRrRkFZKzN2YlhxYU9UKzJDWFArYWVhdi82RFdTbmpFbFV1VWhsaXNzeVoyK0JDeUpVa0ppUC9YdDdiblFGb040b3QvNXp2ZExsTjlOWHo3UHNzbFpaY1gzU29JM2ZEMXBtK2p5RHUzbnhQTUJkSEo4eG5CZERrb1NuWFJ2NzlUUHpsZDgrc0ZqVTg5Q2VCTUphd0hXOXZUMXI3VnA0bWtiKzczdU1WbHRpL3YrNC8xNDZja3Nxd0htVHhwVEJZcU5qK2U5VzZqNUtNL2g1R3hsekJnQ2hyUHpOK1hQcXFOTFJzN3l6dmFyckplcklPeGpqclQxaDgvTDcvQXVOcllhY0xTNFR1RnNKVDF5WHRIUk5pNUFPaGtlczRwREVTSU80ZVRobUppeGc0ZDFkQ3l1aVFrQTNZK0RCeFRjdFVJVUwwcnVBSjZRTGZLZ3BJVmdVWHpMZ0c2akhjV2s2TFpTTmhibkNTQjV1UFllMzAwNWI2UGJVVjRUSmVGVjhnWUJGQjdaMGtaUWV0Yk1xblpXbzlPTDZ0V21INzJZMXBML0ovSlo3VXZXaUpPOTJkQ1M2LzEyOEwyc3J4VHl0UERKTnRMV3NHN3p0dHhmK3d3N2p5UlpIYnRLTkZabEpaWjREWDRrUStmdG9MSFg0N25VU0o2MVJuSTVRMmlDaGE3S1dSNm51M2hqMitJblR4NEhGbmx0QWFQOXhhMVRIUkZGVG9wZFpKa1JjNmVQMjBaY3BDUlNJVk1Ma0xERXlsNXJhS0NzU1ZuTXFJZU1md3dSYi91aGNxY21ETWdkc0pKRDFmZnJqTjRBWDNwYm02SVFZT1ZCSitQeGRpbkZXUGo4RG1kb3ZyNWVYek0yODQ0dkM2RHlXVGNySFAyWC8rTW5GcnBTTHU0bTFHWEpoM2NTRVRBem5uVmM3VlhyemNTaFdRK2JrODJWc0lVUHIxN1cySnkwUEdvYW14ZGowRURzd1pqbHNBdmlIUDlpT01WVERlODEyc2Yyd01sanRnRFJZa2JFN3dObEU5dzVGR3MycW5ZZ3NyOTVQd0RST1Z4K0NVQ3ZrY2NhNFFjRm1vRk1tMmEzeG5SMzkwQm9naTVaS2VIcnU0U3FzVk9XdVovMkE2dDBJQUhtSGcvUGtGZlZlMHhRcE15WXpQcDQ4UnprK01UbDNQemhDZ2ZTTnFMamdlbXI3V3NRQUNnU0x2dk5uN1hmbEowUnpscTgvRHUvOCsyRTYyck1DTnBMM0wwazdNMHlzV3FzM3VCRkJtRzdSY3RDdkh1UG5XckgwSWN0R2Rub004b01qMmpMRGhRcHplWmFNenA1UkFlRmdCWTY3d2RxQitXdjFrbzB2UC8wOFhRWUwzWmJidkdnYVhaR2lHdXZMT0xERDk1dkp2T3dQajVvWjliS1V5eWRpdFlmdC92bGR1UFljRzZlbmR6T2ZtSHVWVE5iOStYSGVHWThyeHpVRkMxK2RDN1o0aTNaU0k0eDRna2F6OWpIS2VDdDhSUTRjT2xGMmVhd0RkWUVMSGhUZzd3S1BBSjQ1SVJ5REErTGdyMExKM2daTlRaazF1ZFlKeHJJQ1RYNjg1M0JtYTAxcGZRbVN6NkhKNllEOVNYek01U0dYSTE4VFR6aldmR3k5YzE5ZVhwQVROUEdaanVZNDJiV0U1OUtUMW8zR2gzSFBtdkpLZCtDUEppUUFFYThFZ1plbjJ3ZEkzUS9iWElENk1oVnVTL0Q2UGUrRHVCV3ZDdDhHdktmUHBMVjRia05NQTJNNHMzcm5tQXpkcGJ0SXFBTjFQWE5HTWt5dVhZOWdPVEpHdk9DRHZMT2ZpZlRqdk9vME0yRW5EeTBLTVp2eGsxZmZMcFdXRDFXd2dSbUl3OFZiNVZKakRLbXhnd2dYWWZudHZ4WmVObnVOWnlQN2lHeU1Tbm5tUHNzWGxzSHY5ajVESXMrUnlzRmdsd0QyS2orWmlPaThDZzg4V09PTCswUDNsN1FLYlg0Y3kyUHhSWWprYkZPSS9vOGE3TGNUcFhRY3A2ZUoyQnhyUnVQNHRIYWM3MndTTWRaVEE5dTVVWlQ0cjJ1STFqcWV5VG5WaVBrZ21nRzRBMUVDQXJreFV6VzJFQjgxNGJ2d3pvRVJINTcyNFpxMFh4NE9BVEZPWmlBb0tyRUNVMlh2Q1A0ekxTWmVYTXVxWlJSandHYmhYbUV2QkZiRzlvZXMwc1JlZXpqOVM0OGp0cFoweTVxck9obVBkZEl1TWNFd2pJNkUyVUpBRVVqZVBoaWYzVWg5bGE3UG43L0I5K1A4VmQ1VmkvSHpPQjRDRURuYkNUNEl5RStDa1huUlBkbUFNU2IzTTZ6ZWZMb29IQXZRQTRnekJJK2VmQzA0eTJuZVBGOCt2RGpoOVBUUEt5SExXcC83NzJIOVRFTG5rN2Z0YldNTUc2blJ6cU5kWUdqUUxSOFZoN3poNEdUTUo3YkxwUldWR2pNajFvZ1BkM2hoVDNHbjBTUGpGdmp0SU1uVDRtUmsxeTN4YStuVXd1UmZ2RGpIMDh2UFhBenVYcHpuS3cwZHN0OW9rcm5wV1FqZEpxRjlDd2dBblRBd0xNUWhieVg1ZDBvdG5BandnNVo4S21XRDcrMDRUbUJvSm1NekFuNjJSRGlsWmR6R0ZBeVluTGtwOEZKRy9nemVEVE9ucFBZODlLYzVLSmpDNzc3R1hpUnc3dXVHYklaRGZSSCtjL0x0bDErbThINDNkLzlUbUFWblphKzFUUDNuZ3lac2J6S0drWVRFVzhyUFpqQjIyeGtocFBHMWI5WnRvMW5ucnpnK2RqdEZBaVBSSG95ZTU4SHZKbURNWWZCUE96R3d5bzBMak9SZC9lQmpqNE5vMXIrMEJySFBERDlIdHZGQlBUbmVWRUhWZXEvYXIycmUzcWpBOE5MNzR6TE1UVHgzZFk3UXc0Q1ZMK2IvVi91QVJ0ZTQ1eDRlTTFqZktlZlByMEdtRFVXaGR3TU9Ia21IN3d4TytvQy8zbHYrTmxnZUtnTGZWNWN6NW41czYvVlY2MUdWd0t2RUpHN25KYm03bGN2VkpKVWJNdXk3ZmE3TFd0dGV3eEpUM3VFZUR4S0NSUEFubUZuc0JMUXF5c0piQjBiQ3BtaXNvaFBxalg2OUxNdlJxY2ZQWG84dkNBNW93RklOUUdGZFV4ZENBVDJRaVFkaCtCZTdtWHdYcnduT1FiWE93Y2pIUE1pb0t3QlN3STg1MWRDM3ptc3ViVlVveEMycGp4Nmk0QVBLeFN3dWFmck1jWmo2akZGMzRZVmFaeit3eHo5SUN3VTNvd2ZnSkpJOTZTWmkzSVN3bDQ1UWFHUmZJQW9SWGtBYTJuSytUSkxPbnQwQlBoMmVsVm9KWEY3bG52KzZhZWZGeUpjVFQvNjRiTVVtVGZvcmlFVzc2UEZ0bVpnS0xTbnU1ejJNSW1OdHYxVm5yRFp4bnU4cU1OMmdqallLejlWWG1vdmtOdi9oWi9OUStvQkM3djFwZnZLb2RtdzBKN3RheTN6K2VKWm9YaGhwQjB6eDR6V2N2VjNDYjB5QXMvbE96OS9QZkl2S3owOTJYNWZYLyt3cDFHM3N5bStYN2FOTW5vQXFxM0c3dlc0TU5RWWhTKzJhODdwbWQ1NzBHT2xVcnJ6ZHBsNDlrWExXazV1cGkvYkd1ZjRPRGtwejJiZkwzeVVKRjRLVEQyd2RibXErbXpGOERhSWdHcnlKR0RPTHlhVGN3cWlRKzhzUEo3SWNTbVFSWC84WVFnV01pTEhDR1FCRjVuMElyTjQ3bk1oVzc3UHYvbWRiRXUwSjhjZG41ZlNLQ2lXeDVJb051bVRQTVIvTXFPbXlHUENscFl1QzZHdUN1dC9NTDMvNVAyMjdYbmF0WldhOUR2RGxKa2ZxUUJ5ZHhlQmhLbldTdkpjZDlydW11ZTRuK3pSSnpsSWZTYTN3c2diZTZGVmg0ZitBRXFld1laN1BMSXNaQ0ZsTWtIV29zZE80Q01Da2s1STNkNk5JVjFOSUJrYWVUejlCbExvWUZiZGRUNmZQSGt5dmd2OWhPVjBtcDVKNG5OZWxLdDRrV25kR0gxTUI2L0RBakxoWExQekRDR2RvdDhER0RQNGQ5M1BGdUxqZUFhTjUyMzdja1poUkhtTngyLys5djZ6cjFXQzRpSUxQQ21OZkVxSGFzVCtTQXJ6YWp4cnJsN241cnIxYXEwL3UydlJySVNhYVYyaGpUb2U0Um5YVURXdWVneFBscFVjTnVVNk5pQ2p1QWdWODdqV3M5VXMyeEdSTVNlU2pzR1NHUU0yUUF1WUVaUTNOQXZOREk2K0k0eFBqUGNkS2lNODRpQ2crNHhGM2UvaTZGSEFGZ0cwYlM5cWZUSXJPSHNEQ1crL1VZN1I5ckRVS1ZBTTFEWUZrQUExQmN5ZEpzamNXbVVlQkx1RHdRcG16Yk04Qk5wTW1lTmpOclVaVVl6VlJ4TUEycHdWUUtoa0xlREI5RisvL1h0dDBYczBmZjk3UDZsOWhYNW1WeFBBOGtjcjVaOXVlNURIYlRrTGF3RGZPeFNlQnNEeVZQMzI5UThQVTQ3OThsTHZwUmpkTXo5bU8yL3ZvRkJ2dmJGc0JGRDJuSmNJUm9mOUhrTnVGNDZuVDkrTHIwRE03TEJGc0QyZE8vNk9UUW56V29TUGlobmxId2kvc29ueGpOVmtaV21FQkFGQTQ3VElHaUJzVm94NmV4T0FCeHl2WGxxUFdPalpSTWZMMTRVU0taczgxK3MzNTlQai9ZMCtUNmRYYjZ2WktpLzQ4bFV6bS9Ic3ZjRDFKR041bWtDUGhjb3hCTGd2VlM4MlFxam9ZcllPbnlMZ01FTENjQWNVc3ZZcmtnOGVrb0VGWUpFRlNnQU1oSEFMZ01JUHZGZ29odk1jUzlxR0RJM0VkK05tOEFDaC9LeHJ5Wm4ydTNIWEp6ZUYzVklHd3dnNzNuMCsrOG1yNmZmTFJYcUMrTGQrL3NOcHZmSExQYTNHSDkxSHovTW1KeGdsTTdaMk8xMXNKYXpTVzBrUEwxZWY5SVBjcVpKZkRyQ0dySGMvejVKMFg4bksxV1J5T0IyQjRQeHNSUG0xVWk4dEU3c3BUTWNmTDdyRXlETHFudFFzN0pOS1FRTUF0dGpJd0hIM2tjcVo2elFCb2RBVUVBb0JXOHBUR29GZUFERDFWWnAyRHQyRkIyK1RNZTJnUFMvUHRsVmthWGYzM1dSRzU1cmhkdTlaejJjSFpLRy9vOFB2L21GbzBINVZ3c3ppVmplelhteTQxSjBrNFR3UXNsaTU2WjR4VUlzODVUM1VhSTFPRkRZQ0pNQjB4dHZwZHdTVzdKVURrYlNYV0RianQ5MGF3M25HbzhZYk1FSEJlQzhoUU53WmxsYW5FTUR2Y2tFTEM3QW9Ra1JFWU1FcXUxNHVqS0RNUkxHUFBMQ3pObEtKUVZiUGMvbTYzOWc0TDhGMm50dnhIaEdCaXpvTFJZS1dnTGl2R1VFNU5lM1dzY0U0N2p4aE4vdllLYkJrQ0VRWEkyVXlLb2N3QXpKWDE4eU9lMjAycmpGeDBiVVl5ZTBBM0ZkcnpmN2swWnJpL3ZLTEZ3bjRzNmF6Rlc1aWVMTS9iU01Eck9KbHlmNDh4UHErdGh4b05FM3lVYUhkNDBlSDA0UEhublM5UG4zcnovOU14L0V2Nnh6ZzNGWVlhdlpSdGJzeFNNVExJNWdZVUdvaU5Oak5paStkR0Z0akROVDhQWjZCR05nMDFGRjBLc3poRXhDcVZVV3doU01yR2FXMUFLVG1zK3g1R0QwS0hzMFpJS0IvbHFMMVhQcnA4VUdLSEtGc3I3eTYzSzZvRXJlRkZuc1p2OE1FOW9OSFBYYnFyT2Z1UFg4OVBkZ3J4R3k3NStOMlNPV3hqQkFtSTI0dmNRK25sVU1NN3dkUTRmbHFFeEdqTUxUMkdaaEZpSjY5Zm1lMDN1V3N1Z1kvUjg2azgwQzVXZG9oK1BHR0xPRVJXZkpKY2Z6R2I3cExVUmRlbWNYalFGMExjb3A0cjgzUXZGQ29FS2ZqUEM4R1c0WDliY3VyVEJaOSs5dmZqYlJMcFE2YW5TNEU4b2cwYTJybHRwenI4ejc1V0NtOFVyTEQ2M1RlUWpjc21qNkpidmFMMzkwOUhPQjlRMzdVOUNXcjJZMlJ0Tit0TktYbTRrTkdOVjdVb2VTYVY1UCtkVng2SjVFYll6UG1oanZMZDd5L2VHbmZ0L2xaRHRiajRxWDdveXVhckpSem1xTWFOV2R5akNrUHVzWjdFY3BTRVJrRGF5Wjk5Ulp0ekZiU1A3bHZCbVEyK25STS9oVXdteDFFYTdZZWdBSm4vZUk4ZWMzbkx2UnZIUHFUZnlLZnRVL1ZtWVRlMXEreGFJZ25zWHRUQ0tpbTVMZ04rdGZ2NWh3QTc4SVU5RWFFVlgxclZtbDBNa0c2VFRsTVlYTGhnUlRRaUhaMWNGN3VZeEJQUDJ6Lzhlb3dvUG5nZk9mcXZOeVZ1TjUyTTRUVXVkQmVzdHdBb0R6WGRDTnczUzNFdVdnR1owYjYrZHpGNG1lZW4xSU01UmtFbjNkMFdSeC9tY0piQ095ODhmdTdNVXIyWVF3cmRqOUFlcWFOUG5rVDVudjdRUVZnV0lXWjhtQnlVUDJSWU1hdHhtQTJ6MndoZ1J6YTFkbk9NWDVqMWM1ZW9MQmFqUldRTnp2RmFoNzNFSUx2ZmU5SDArZWZmOWxETTE5SGs1Q2dlOVdsYUZDZFYzbURuWTF5WEIzKzhNbk85RXUvOE0zcEd4OS9QQUJwelo1WExWcCsrclRacCtneE5peU1qbHZXdHVYbEt1aDh0UFZ3aEZtVVR3SG9wYnpqZVFBZS81WWtYWk9SNVdhcFZxSVZ3RjZMMzZzQnBGS0xyWlhkUVJ0TEtpSmZQRTFvQXpGSmR2djBxN0puemRlTDMveG0rbjZBYkxLZ1pFVFJvSFYwbXdIcHhYSmhRdXNXcDRCczZiNjhUSS9sc25MaS9xWStMTzlPWDc3d0hNZUFOZ0I4MWN5cHRZaEtZNENrdFhmREE4NkxHdFBqS2NXWWFZelFaRUNTZm1ocG5wNFFucnlncmQ4b0dJQlJRc0JnekFBM3k5UUN1Q2lwY3hlS01zSkFiWGVkYTYwbGJMVGhzSFFIalpucjhuaFM3c3ZBbmI3TDg1bTB1cFU2Q1lCZmxOUDY3My93L1l4THM3RE5IRzRIMVBLR0J5MDZ2NGwrUy9IRTNtTWVZb3JBcThtRS9wTVhmZVdsKzdTRmtLcjN5L3YwVU5sQ2ZlTEJtSUF3SHVId2JQUXp3RjFyYVk3WmJMTnVTNFh5WXhZNW5lcXk2SmpIR3IxT3FyUGJ5Z2lSWFhKT3R4WXZkR0hvMEVOLzZCQ3c0anlRNDdFdGVybHMzeGRGeEFCZE82NlRid1J5TjdjbTF0NTVxL1hUOVZmUmtNT3oyMlNjbEFyQW9sa0FTNlJudk03VDFnTDBGdjN5dVhwYnJzSjZOOXVpdkcycTNMNUt2S0tWTk9Tb0dRZURWc1BCOVgyYkJ5V1VNQkNoelN3WUNROTNQT2Faa1ZOUFlpYnZwa0d5Zk51ZFM3akc0NGNTWkV0cnZPVlRGb0FnSWNvdE0xQUxSRSs3bndFZ29yYXRwMXE0bGdvd2dSaEdlVU5ubnl5dkFWSWM3VzYwUGNvODRGblllVUJtb2RieTlCRGtibGlhOG1RcGx1dHJNV0xQc1RtQmxPc2FiWFpNZTZ0NWx2SUZZMllyd282SFhnWmNpLzJyeDJSRllHTUh4VG5IVm9sQkZsVDc0N0hpS2ZuSXJTU2d3enJISkhtUUY4OWZUWjkvOWl4YTk1aTBRb1I1VTBDVzBuUTNDMVZ5dnhEcUY3L1ZGakJQRHFZUDN6dG8wOEU4b0FBczdFdlpBNE96bG9lVVYzejY1T3REK05kNFpvVjNwdC9OVCttVEpLZGxUcHZiSVU4Q2lXN0JhNGJuWUFqWHZDVnpFeUx4eWs0R0k4OUJZM3VseXNQSWVKTE1mZnowWHJmOEozcU9tcG04aUlzTWlocTQzZkl3TndtbFJkanlaVHVsRlZhVHA5dFNDaDZ0eHFQWVhHM3grczNiNmVSMWN0RmU4UXpVN2RYcnZQSXE3cnZub3dlRkVZSEFXWWJpdExac3lRSk03ekthNnExR2tycDdVaVpqR0hzc3NTbE1kcndqSDZ3RytSeUd4ZEdHQW9oOG1iMnV3RG42ZUMwOGl0bWo3cFI0Tk05TWRuNjAwaDVBSTArTGw3YmwyV0t3cm5VYUh6RHdTVGFrT1VaZ0VvL2ZIQUd0UDVwKy91ZC9adm9MMy9xNGU1YUVqbFkzaGZMMzFjZnB2N3l4NjAwOERRL25YYjgwRDJBODNXZHNHWlRjU2t2d2loVnhTOVNQRFFJN2NUMjUzOW9wdjFVZmVmQkg1VGxOUmp4cVFrYWtwTy9HdXdCMHN1ZzFnREUrQWhoQXVmQ3dqSmVlMEEyZU5oMXdqcHpiMW8xMEJZK3V4KzdGYzdtdTQ1THVETDhmenMvblVwQlJsL1hPV0x0V3FaUG9heVdabGY4aS8yaXZKTU5yVkJja280QlFmNzNIN0dEam13UHBBTXNlU1Z3eFQzMUJTQVdhYW1WV2VwK2ROOU5XMGFDbmp1aDhOT2hDUlpSejZLZ3Eralp3QWpodWdvQVBBb1F4TTlqZmlzYmNrQUxZWmZOeE5TR2VyakZidnRISDhZK0JMamZiU0RCTTdjcWhjTDI3V1VRWEw4OHpNd05ZK3R2VHBRM0dZTjBYTVZXM0Ewb01rTThneW05NnF1K1dQRnhBSTJkMTBiVkEwSmF0STVub09ZbXBqSUxWbFFqS2VnTkkzb2prdmZ0eGw0MXJPU3ZMbmdJeWVxelVZQkMwUG94NnRSUnNhWG1lUUdBNXhncjkraldtcHFNWnI0eEFxTHV5TnMzMk1UNi85OTBmVHMrZWZUa1M4TEZ5ZUlZRThqWWxKdlVmZlhBdy9mSXYvYm5wei8vczA0VHhkRHJjYVZ1WWNsZGI4YzBEVFRjU1V1dlkzaHp4SnVVWWVzQnQxN09TbHI3c2pzbUhhSmlGNUdVTXhZb25IaEhsTVdUb1RLbUJ6M0VWOFFvWFZVOC9mbVJqdWxqUXVac2pWeEdJUlpQVDJnSEFZMElpV1VFN2ZMUGVrTERpeDJWeVJIVE5BRW9ZazVIeEdQSjJPTGk3NTYyWkpHaVh5enlOaTh1ODV4THk3eGZtSHJYRDZYcWg4R2wxT0hKWmtTLzY1ZkcxZXlrd1lVNEFzSHNBcnRoUS93TU9kRTZwS1RQVFE3N012akZBbE1JZVhReXBNSXhNQ1dVV3lyTHdKUENhYkpERnNXaTN6d1lmRFFyQmtuMzBHZW1EamprK3ZMUHVhN2JTa2hUWFNhMFk1M1hqc1lzcnVsNjNuNWt0clgvclAvM25sa3F0VFI5OWRERDRzQm5mTHQ5NWFHYmZqY25ESXhnVmZTUXJ3a3cxV0FCSC9vMDd2RkhmVjVlcVVRcXc3YTB1T3RxcTlNU1dSRytQN0czZk9yeDRTbCszdG5wT1FoUmI1SUR4Y3BIeTRSaGN0d1cwd2xkOXAwdWNBa0NNRmtESVVCbGZPalYwTEw0UHNFeFhURFRaMkJIUHg1clBRVmVUWGhZeG00RVhRc3NEejdPc29oMTgydGpnNmFhZGpkZTRMRm1MWFFNVWQvY2s2QUdlM1Y0Y2QzME4vTlJyNVIvLzZzOS9ZaStlc3l6NmcxelhuZXB6amlzb2ZGQ080YndIUEQ2b3FKQ3lmOVZtL0xaTTVpbXBsK0toTEVVd01mcCt0Vms2elMwMVFJeTFHSElBZ0p0R1pOWjNZeFNVbFd5TXdjSVRJZU5jRDlVcTg1UmxRMkkva050dW55elBYWHZkem8zQUFnTUpHd3RwY2tDaVc1ek1tL0tiTmdqdWVCSnZmd3RMN2FwNUhxQnVSbGpFd1d4QXkzVzlTWUZxSk9abi9mdDdiT1VTRFlBRU1FT2lSeTFzdHZqVjQ1L2twTUtyQVZacDBOeW5HRXhwdFFQRU5nT0dOKzJKYjZ6czhGSnQzK2VWZXU0Y2E2aktmdFJSOVFSaElkWmxlN0J2cnUxUC8vYmYvZWIwN0NmTnhwWG5zWTd2K1l1WFE5aWZISzVOUC9QKy92UkxmLzZqNlZ2Zk9KeWU5c3pBZzgxbVZQSzZWcm9uNytXd0oxZXJheUxqbTlFdUh6S0JWZDJzTE9DbXBIYlB2Q3ZwU3FoZUI5NTJIa1YzZVJ4Z0pJbk9jN3h0WW1XdkdpN2grRUY4VW40aXY4THlFWHhHVFNCa1ducjNvT005ck1LRE01ZHpNVXk1QStXZDJqYWpUSkF0OWwyeHYxYUFlemFBc1BBaitnaWZXWGt6cVB5MnRDV3dpdVlWNjlvS05Qd2Vpak1xcHpNYTFqOENldDdmbFRBclFYYVo1SWNaTjJFMTRKSmZwSFJqSmsxWWtaRWFDdDZwWklOWHdjdW5BTHhuU3NEWStIdnhkcjJ4enVkd25HWlFWekhlalFaZlBXVENvOGs4eEFJQm0xZ2ZnT1hSWndvbGxXQ01VTFh6NzFMWXU5SXNseTFpQnd6cXpjaWhXZHVsd016T0Y4Qm1QN29CRzZVRGNxQ0tubjJYSzkzdFNUcGpDVnZIektLajJ6WVpqbmM4THFFNFEyMUpGVHJKVGVxM1ZNQjRnbk55SXRlbjlNUXpFSlV4UEgzMGRDeU1sNzdZeWJoSjhjeXJHMHJGcEJkQVcrcGtYazJSckNYUDBrSldoS1FJMGJrWnorVCt0TUp4aWZZNURkVEMrdVRIVTY1bkw5Tk1NUStPbHlZTWIwejFsNDZpUDBmRzZ6cStTejJnaFVoQ3FRN0FONkZrTW8rSGVQamUzeGpuTHY1WnRSMnBUcHB0RzQrcWFwcjhwZzMzMHZqZUh2QlF4eXBOc01MLzdEamxpQkVuclZlemtaNGRHK1dIL01Zak0yTWpwa1U0QTdVR3ljczArV1g1bUp0bW9naUZ3WTBrVzR3NmFacmJ1alJFQnFhdWU5M3M0SGFFRms0Qkt2Vmh3amtXNks1QkpJS2RteEFsR051RmZvakJ5aHNENzBwSWU5VmVVUUNSc2lLWW5SS1EwTXAyaTZ4WjFqRWRIQlBNenRnbjZrelN0ejRRTE42YVpUS2FTTzc2SjJHb2J4Q1NBRVNsSWR6YVNRVmFJWkNWN0Q2WjU3d1hBaVczVTFWNXdIZVhxMzhVZzdkVC9KUG9ReWtlUDM1Lyt0My85SjJVTUV0VFNQRDI3VnlYcG54a3E5elVlNFZGZitIUGZUUjk3ZjJXZWR5M2lEYVBiQ3JwdnJWZDJVRkFUV2w0QW96RDY1NVNuQk9kSVdqQmM3eXlOYk0yN1FOK1U1L001Q2szRUZwVEVNK1BQT21KMEtzdHBqWnJTRURRVDFwZ3RWbkRwYVhLRUZJUW52TUkxeHMxcnpPc3psTTdpMDdORU5jSGdpM0pySkFZbmErU21mTm1ncnpHWHYzUjdINnAwSGdLQ0t2N2tZK2lkS3JuS2VsYW9BamNOeTRyZUt3Uyt5WSsyek4rNnNHd1orMER0bHkxdkhxdXUvcWxDSGFwSFNua2hpd1ZRMXY3dVFzUThaTXk4QVI0QjBKdWdEUW5oWGtNeVZCeTBVL0pBQjZtVnZVZFNQRUU4TVA1Wk1yZjNFUGVhZDJKejdOczhUQUFGeURrblEwdnIvYmNiK1M0bXBqeW0vTm1MMlhjWmdCYVRaZlB1MnZqeFI5UGYrNmJUNVAvOXd1RUE3WGs0ajcrS2E0K2JWemtuWUZtOUczdTkrYTFTdnZDNmp6YmVwYU96Yk9ZbXdFSW9ESkpvdkNTVi9YL3MzVWZUWkpsV1dMZlBVTkhaS1RPTE5HNmU2YUJnUkZqQkdBRXpFZ3V1Q0JYTk9PYUczNFlmRFlhQVpJd2pnQnMwSmhwV2FKTHBCYVJrYUVqK2YrZGw5N2RVNFpYNVJrUjdzL3Z1L2ZjbzlVOVRpT0R6M0J6Y0xXMXdQL2JkN1VKU25OUDY5M045Zk8yazRCSTM3MGM4YUZwYyttdzMvQmFIZXhaOS9NZDN1MDdrK1FhUG5FbjBMN1ljblBxVXM4TFlQa3grVzhYdjlia0MyYmlIaDBUUGtzeU41b0NJN0JvS2dOZjBVZ01ielRHMmFkOGl5eUpZTXlpNFRjWFNXUVJnYkVyS3AvLzVvLytxZFFyZVJ5Z3AwOVMyL08ya0QrLzhkdVN5M3I2cUtiUGtnN0M2WG9yQ2EwSGx5U2JSREdiSi8zZVJpV2QrdDVaekdzMEdxalVKbUlVYXJUZWxpaEtWWFN2VFlZazB2Qm5neUZjMHhxVlBFVGtBS2VDMDVSRUZqSHUvaDhBMk15TnZuZE9tZ1ZnRGU5b0xHeGtpS3I5U2NKNlFjWWdSYlVtR1dnM3pxWGJDYkVCUmdqWXFLVHZ3dnlXN3ArQWJGM1VjUVRHSkp3QVJPOURldldVTnNCOFVEQ2YwMFRQU01YOFFkN0RWREhhczdTZERXdE5vbUQwc3RuenJCVEp1N1g2SmlmN2YvN0YzMDhwamdDQkJvQUdsY3R6djlLWm4vN2dreEExQW0veEluOFBPdEhtc2x3cy9oN3BHcjV6c3o1TUI1MWZSNjNIOU8rR1dMZEtFTDFaUkluZncwUkZLRG5nRC9KVlRwaTg5Zk8vcVNlekJnUkpLMFFzYmNFUUdDU2xOU0xvTVlsYms0aVYvYnAvNjBFSURJa1dBaHFYUUhEbitOYW1lYUt2clIxUllhemJmWmMvekY3T0VlanR1OFRqMllQMkpiUlBtaGUxakZIcWVucDBuQThyTFU3dnFmSVpLc0ptY3ZMcHhaTFRwREpnUnJpSTJHSlVHMFhOYUQ1Y0IveVV0SHdSM2xiWjMvQU5FNEpkeTFwdEc5eHpMY1RFRlpIVWowZ0lIeHJnRU9qYzBaYjBHZnp3bldGb3JhZkI1MzFSTDV2bXV6NTNML2VGY2NHdVA4YzB0aGR2NmdlL3YxOGk3V2UvTDRIWGllQU9iV2hQbTRyNTBXSlBjMEJ6b1d6azQxbWJxaCttTVQvNEhmZkRpUzMwMGZxdmFXM2RmeXRCcmhiWUJxcW9pTUpHNDNVR0l4UHdMTnJEMUc2bTZYUFhhS1VOTjdpQzVOdGRsOU5IRTMzWUNlandBazNEUjdUbWZRR3hwaGhENUJOY0ZCbUhya2c3MnVMSXMvWVlGbG8rYTZ3MVhOSFMyc3hlM0RjVUNGcjBBbk80d25rek5ZVUpIKzJWVHFyNkdETy9mWENwWUlCdDYydnJSOS8vZFBYNUY1K1hGZjFrb25JVHlvMFJiTGJSVHFkcGhrbFJ3eTRoODR5NVZNZ1MyMUxQbFJsQWJCc0ZxUkNDUEpsc3hXRmNUcjVnUTc4dmdqYW1RdmVTREV3azBvaVVWcDRpNzhSR1EzTCtBaEVYaTc1VnlzSit5QUNKK0h6Q3k2SU0xSmVlNFRuOUxWcWlSUTM3RzNENGJDQ3NkaUdJMExpV3UvaDFtRzlMc0VBZGxyeXBNUm5hUEFpdlZPRXNNOWdtajNiWGhwSUlOSWd0MGJ1ZXgrRjhRYkwzR1djdjB4VEMwY2pNVGZzUFVsS2tadkVITFZHMTlpaGliTzJDQWZrNC91OS8veDlxbHZlaWVTM2FIR1E3S0JsVDdkbmRXMlgvVnpud0lHZjc3ZndlN3lQd3g0K2ZaSWFIZEsyUHFmQWdmK0JPUHFoOU1FbzdwWm5PcWN3aEdVbDcydnB1aDhoTWxNMk4xUFhXY1JITWJmNWtRcmRtSmdtVEFiSHQxaHNKNDJWV01TbHZ0QVoxbGhndlFyV21ZVzZwbTZRNE5CS2d1ZGhLV3dydUdCdWhBV21Yb2xsYUQzK0xJRVQrcys0QlN4S1UxckJYMU9COURHaHZoNiswcUZIbVFEcFJqS3Jjb2ZEcjA0L1RPa3ZBcEVPOVRqc1p5b2RhemZFc0llVWNRc3hvOE11YXJDL1l3OGtwYjJrKzlsMUVlNHFENFdoNGpNQmhwVFdiSDl6eXNrYU1aOEhsNVhQdnJmOUdmTzRmcG1Yc1BpUFVNS1kxTS9QZWVpdy9oNG1GcnJTM3RqbGYxdHZWWC8vTlA2eis3TTkra25rZTB5QVF5NnQ2K3V4bGRZWUpnZy9qb3NIMWM5SEIyb2RMcStaN1RJcm5QbG1hQlVvNjFSR0NWZzJINVVCcXE3MFJUc0JqT01nUzRVNHhwK215Z2Z2MFBZbXY1ci8yUVUrdnJZQjJtSVoxY0swOU9NWGxaVXlVNVFFV01kSTBZMjEzcm1KaWV0QVRBMHVYbFFVKzQwS0lodUdDNzRqdWc4UGlSeE9Jd1lnaXBIYkhDVUxtWVpTR1NlZzU1UGV3L2MwSEhBL3cvZTllbS8vTC8vU0RmOXQ2a3VZNU5sdXNsaG8yNTE2cW9vRkpxZHY1bEo1ODgwMXFaSFo5REtDZGI3Q1FYSWkxUVlVOGh3SEVqUmRrcFo3bmc4aCtwY0ZJWXpCRnA5bGlkRlJPNy91ZVo1a1hSSGNQUnNZT2x5bkxsMkd4dzZsRGF2NktXVVRJaHpuNW5sUUk0WHlPWW81Q2dMSlJUQlVtRUwvTUhORFFCcjU4OVR3ZjNGSVR5UjhpYkQ0K2tvaDlxODFEQUJJNUVlMjlEN1ZUVTJETWVaeVRjamx1ZmtGbWpOWDlaTGtLK3BOOFV2S3FTSDRSVUQyVGFGZzBXSnJnNitxMHFNNzc1WVY5OGRtM3E3Lzd1MSt0ZnE4VFE2VXVuTFBhRjh0STEyRHZuLzcwMDVKQnkvY3EvSC95NW1sQ0lBMHB6ZXRlY0ZPaytsRW44OXdwdU5Ia3AxQ1cyVW15OGhOaE9zd1pRWTZiTVRQd28vSkRXTFZhR0JzTUFXdjFhNUpjRVlmczlNM0dHOTlnaEdGTm5MU0lvRUZuanBnWHBQWGxSV3RKU2ljWWFNNE5HVUhIOENJUUpoamlwdTB3M1h5QlZJVVRVNElWM29oTzg2RWRwRldOaHQ1bjhBb0JJWEFIS1d6ME4ySVNJUG0wSk5lNzdTVUJ4Ym5PcjhodlJMdmkwTlZyQ1ZIUXNJM2grZkRHbkplNU1FVXd2TlFqNis4UDkyRUlmbDlyQmZETEM5ejhYSDltclBYdkNOOTM0YS9mZmRmbDgvWDMxdThMcklDaGNqQUVMcjhSby9pazA2VGhpUkEvQVRMOTFJSTVyY1lZWHVick9RdXVMd0o4Tk9kb1o4bVVidzN0R1RxeEp3UVZpNEpwekl3RUs4d0tJK1pyNHBmU3VHQWFHd3p6U3hNT3R0UG1PQncxenEyU3dERkk0L0E3eTJ6WFBwdUZRdk5CMzdJQjhBVndIMU02R0IrR2F3UUJPS0hsTmJ4OFB2dlEya2I0dCtkQktRU0svdHVyQmNhYUdHTEE4TFE5NlRtaFVyRFlXdDE5OU4rM1hiQnJ1YmFvMFJZSEFLOWVrVlR5c1VLZTdyRVJpTzM5OWRLRTcxN1JpRysrL21vbVRFcU9iNHEvS3lrNGlONzNYcjU2RW1GMlBIalR3bzJuUktaSnNKM1hHN3lXWkxneHUzYU9CV3NlK21QeEU5a2tDNlVXV3hDT3pqSE9DUnlmSE1jL1h4UUVjZERvaFloZGhITmJFWGZTVi8veE94MnM0UHVlQmJEVWFReDU5K0g5MWlaaXhOWW1NU0ZaaEpHZmhBYkNIT1ZvNXlBZXRUemdVYi9mcDkzd1MrSDhJbkhTSzZielo0aUNlSmc5anZEaVYxSWJTUXU4MENjOTZhY3pwUXIydG1QMS9NbUwxZTkrODJXcWI3NitQQmxIOVV1SDdvSURoNzN1M3MycFhYbkg4ODdCKy9qaDNkSVlIcTd1RkJtOG5mL21abEpaNENKS1R0TkxFaGE5QzJOeitFZXNJUkFObDdicXdOQjdOTi91dVlENHdYRDJzN1VnanFuREszcWxxeWhUWkV6ZGtmWnBEdDNEaHpDMWhPM25ac21BcnNBU0xnU2Ixam9kRkJJWUVoVXhKYjZ2elh4UEV3VHBlWHdueHRRT1pTdEd5NVJzaEduVlREQW9FRDQ1eVRUcCtXVXFqQW44TG0yRkx6UVpQc2ZNZzI4V1lXTVVUQ0hWeXpON1g5TGhqV3VIY3lTNGNqZHdVMmhvYUQzSENTdXdsMGlMWVpMVzhHWlNWV3FmZzNHS3lvRUZwclVtcXJYV05Hc2NKdEZDdStDZ0N3MzRIUU9CRDNCMnpReU40VE40T0V3aFBLRjVyeG1YKzV6YmlSQ2xXbDJFVjgya210RnZWLy9OWDFhMDNyWjg3d2VQSXRERmZFU2dCQ1BHQys4MVR6VGVNS2MyZ0ZBMjk4Z2crSlhFM1Y3Q1hjeEQvaGR0L1RBYUVBZzU3blB6VFg5TURtQXk3WHRqdlNqQ1BuVFRPcmdYTUNiTWxZWGdSUkFOUG9jL1RTSnQvdFljZ2tJQm9HUlFkZWY3NlBFRFhId2Z6b0RSTWxaYWQzdmhjcThYelE3ZDNjZzlvcFdVcmlTVUpEamx4WTBqQ3g3K2JoZEFFcVFDZys5ZW0vL2IvL29YL3hZaklYa05UTzJreHZuOTRZUDdhVlNwOGdGK25KcE56TitpYlI3WS9FWkNZRHFrYTlDTVc4djdhSUxzNnFKVU1ybjNZMkRPTmJQQk5wRUVzREFUOHA2RktoWHdQZk9ndlFpQldyUnlDUDZQZG5ybWdkT3JLc2Rrbnp5Sk9VYkF6bVZiSkRFSFpPWkZEQU1qVmo1QTR4SGw1SGdjRFNlbVFCdkU5WjNvUWhPQ2xKRkN6d3Z4WWk2WXoySk84Yk10RVNDYjR6bkxoamFkMWtvcTBMSmcza2pKRDJNNkNVanZhK3I1T0h6VEFxUEVOSzd6MWRlMVBQN2xQL3d1TStBb3lZdGhGaldMYVdCdTIyV3hDMzNmUGJ5eCtpYy9mUlN6ZXBCV2RUaWFCVk4yd3M3QmJTTjQ3QWZucldBUUNyUTJ6Sk5HMU0rSWRTL0pLSVhCSEdFQ1JDUGxtWGdUL1JwMVBrVDJYdnRCbTVwdUVscTVES0l0ZmgrbWlmVU9DYmRYN29XejNxZUp3Z3YrU3VORHRzbVo2WGtJVDlDRzcyTnhGRE1KblExSkMwWEFNYldJQmRRWGY1aDVaR0sxWDRpc0o0V0RmSTh4L2NaL0hSS0xVaUdrS1pidERvUXJxREM5eER3UFUyak42MnpwdGFiL3B3aS9yQ09ZdEJhNDV6VjczN2hyNGxnMG03bHpQbHQvZi8wKzNIVXZyV2NSdklzRnNOWWtScHNOTG10YzkzMTdOTFRWbkVYTkR0czMvY28rK3VUUjBtUnY5aVAvYTR3WmJFZFF0bmVDRTc3bm1SaVpNYVdVZ0pONXc2L3pJdTRUQUduS3JJVTE0NlJBSUhmbThKSjluL2tkWGZWT1FzLzVEUDVMT1lqeCtNM1ljSHdKVktFMU1PM2UzbGZZN0hlUldmVEozZUh6Q2FERTVKamk4TXY4elJkc2pPY0ZMbWdlL05TekhzY1R6RmQwVWk3bmdtTnAyam56elErOXFDZmxFK3VScTV0My83WGRCc2E1dHFRZmlBaGQ5K2tpaWVYZGRHeFZEeGxIY01qSW4vR3VnbUJlZ2UxeVRSRGFYbTE4bVV0TU1xYkRrdU5SUXFQaXk3N0xkNkIvejFLaG5yK29NZVJXdUo4REhuQ1dHaVV0TUNLWW5rK2w1WDlZSk1OaUp0b1kvbytSRW4zZjRaVXV3RUFNaU1pMUZCclRFQmNmemxGUk40QzYyWHlXdmxHTjMzY1FSaTYySklmaTB4cm81OGU1V2Yxa1lycFJFQ1NUYVVHV0FYeU1RbFFNd2NRRFkzS0Y1eUZZOTlFazM1ZDlMTkt4M2Z4OUZURkswYkJCVE00dnYvZ3lwMmJSdmZKcHloWmNmZlhsTjVYaWtIS2MrUWkvSk51a2srOXAzZk5SR3VDOXU1QUNvMjQrMFJlR2hnRmVVSFBBdTQzZTdRTU14dzBZMFU3TUNnR0hadTFGQ05IR013T283dzVWd0ZjRFdGb1h4cHpwVlZxQ282d01xZjFONGlPSGE0VGJlUFlHczVpOG85Nm51Zzk2RzZOSCtnNUJ0SmVwZkc2Q1NYbThrVVlEeVNBWTVySUlBa0dNOWl4TmxzQTRyM2o2c0xVNUtmaW9UckNpbDFlaW9NR2ZQK29nNS92cFdiaFltUW9FM2dtUmoyUDJSemxqTjNyd1lRWGVlY3BXRzZVS0hKZFllaEZzZDlMR0ZGRlB4bmh6aFJmZzN6TEw1dTZ6bUM2Y2d0OGlrWFlhWVdFOEJKZkw3OTd6V2pPbjlmdHJiV0ZOZUw2RE1WaXJlMTNXNnZQMW1Bc3pvNUhHRkRIV2lOcitYVnlocS9QVmYvNjdYNjkrOE1OUFYvLzBMMzRlM0tLSmtqTzVNNHl4dFBLbXlSYTRhQzhXQVorV2x4YWFSVFZwUWRjeGpya2FYekJNS1E1L0V4eVlsalB0YzdkT0Nnd21wTE11N1VYNnlUQ1g4RzY3L0RaTWg1YUZrY29uQkJ4QzNMckFMVWdhcFhuRWhQc2NmRFFReExEZzJkUlFwdlVTN0RHUm1TdFkrUDRhdG11dGEyQVRYempOeCtZOUFtNEVWSUFjR2pzdkQ5Q21aWjNjYUN5NENPWCs5TW90RTllTjBnQ3FMY3p4WFRFeEpBOGVyME9vOEw3Q1NyNkF4bW5DVjAzMmRTRm8zeHZuY2pZeFU4NzNkU3gxbi9JWit3aXBTV2kyaVd4bFV0OEd5TjN5Y3llSEswbGdZYlFYaUFUS1VpMEFobjAramRkaVdISy9JQ0xHUmF1U3dJWXJMemxVbWE1dHVuNUJIUGY3amZrNklrSTZKSzBzN08wS2ZpSEFqWUlEMDVlbmhmbU1UMlUwa0ppSi84eDVqWVNqTmRyNENCMTI4c1Z0RnRtaGtXQU1WSGZyZGNrRzVpK2hDVTBKVEFoTkd6eE1NdDZvcThLTEp5OVh2L3ZsNTNWSWVESU0rK3A5R2YxdG5BTXFPRFVmbGNidzZjY2ZGLzQvclBlVW5KYVlkTzlMUGJBZjZzMUU4NVRRWEFlN3ErYURvYllwdzBqTkVXck5RUis5ejh5Z0RXL0hCS2VjQlhIRmNUR1NwVFZMYUJqU0lMcTk5MHNKalBjaEhrVGlnS1hkS0xOaWt2R0ZiSFEvN2JjTlM4dk9xZG9UQ1F4alNINmNoTUgrUU9DWTZiTFhTOUFDNnRIa3UzUGdKdmRHcXhWNWQ2UXNvaUtFcnJJUitXbWNObzVKaTFoZFR1NGFqVFNmWFU1cXJaYmI4T2tiUG1STGlqY0dFMk1JaXNSdnJUUXVHanFHVC9wYkN3WWlIV0tFWkxnNVdsOHdjZG4zdFVhQTZGekdRMmd1NjJGaTB0ejlqbDY0VE9DWnkzMitad3hqelF0dDlTTHNHRWxNWEhXVnlyUCswMy84dTlXLytGZi9yTGxIb0JHLzc4TnIyZU53RlFyejI3cVh4amx1amVCR3ExTEliby9uWUpQbThycXVLMUovMWhxdHZMdnBBQkV0SGxXeEFnNXo0dk9OVHNGS1VIWGo1R09obTlHMGU1NVVCZmVxT1ozU3V1QW5aM0t2TWZpZmhzWXlOd2ttUjhweENleEcxMUlTT01xMU5ySUdjOGV3TVNQTUZtOUE0OHh5akh0TTRHQkdJUHJzOElPLyt1eHE2YUJDSUV2SFdUTzhBZTZIZjdaMGFGalU2d0NRcEZKUnpsbDg3OTVodHJNMnc2OCthRUw4VWdDZnVoYVJhUFZxUXhTaVNwSWs1VEU3WnFDTkpDMmEvWXk5MHlMZmxXLzA3T25qeVV2aURLZEdNbkZ3S2ZWMDFGbWJQZG13eldPL05BbWFrYXpwY1JpSE9EcVRNdm1naCt4NVd0WGJtQnZIOFR5L1p5NU01SDJoNDQrSGlaRHN0K3IwZURzelRkVHl0RVErRmZNUWc4UDJJc0NjOTRyeGg1em9QMG5HTklSd1BXbUpObEovMHc1eVJFQnRrc2dhNWI3Z3NQTFJidGpFR1BGT1R1U05Odm9pMzU1Y0kzV1VSeTlqbUNXR25wUnpkdndXVVFRUFNEaU9lb21POHE1dTEzSGhiaWtNSGN4Ukw2WE5OczhwemphVGY0WnpkSy9uQ2p0WG5sRGVWNlp3TldiVWV2NExoSkRGbFNWR1U2REtKM1ZYK1VEU1FQaFAyb29RdW5TTDlvNlBUclFOQStQRDIyNk83ZVpvVW1vWkllczR6SU1GQWxpVnNPcmlDcmhSeWdaRUl4eG9ocU1YOVdDZFRla3UvSXh5Y1pSd1NNbzlTMUlLQkN6SFE4V0FRMXFNVGFmYXE2dldFUlBqYzVRSHhKUzhDQ2FZR2kzc1RBMW5URTNQcnJPTE5JSDRuWFdleGlRNHNHa3Vrak5wN0tMVTJsVkxvOUJKZGc1K3RaK3RaWkNzZFdJY0FqS2JITDl0ZHJmRkVjUWgyMytFMjUvVzRETkV6SjNRRzQwYlBNQ2g5L2xCTVN5NEMwNXhtKzZsVGNhODRIdi9ZZmpENkJwUFdndHorYno3QkJMZXgzUnBlZ1RSTDM3eCtlckxqbTU3K0ZGSjFqR3R1M2QwS2FVODhHV2xXWWJiNlhLaGNOcE9MZzNKd1dDcEY1VVVFTlpBS05lYzNzVm9YazVPMVNFYWFONG5wUWpzMzExNlhka1BqU3JCbFZVeGJvendSSTh1M1RXMFVyck1UWEwwZXVtZ3VwMjJ2cC93MEdvR293SS9qbnJDaWcvMUlzYUVUbzd6QzlQVzlzdTh2d3JuSmV5T3RqNCt5NzVtTmNFSUE4ZklwTDRFam9FbEJvdytDQlBDa05hdjVwSG1oVmx0bEhhRTZYMzNLayt3L2xFMm9aNUYxRHhIRVlubU9OaHpNODFvUHc2Nkc1Qm9MVGJyVHZrWDBGY1RmTnpWTm84NTJHWWNOWW45cEFOT0hzM0V3T1I5MUdibUpyK1VTY21MZWgxenNnZ21FNG1ZblJwUktxS1ZoWTZya3RhNWM5bzZ5S2tITnZPUHY2UkV1UEtNcUxDY2dhcm9oYkh2RlJLV3BLcnQ3TDBTSjZlell0Smk4bHFDZHpRelVsV2pPZUZZV2VJMGlPMDBuL2Z1aTRDdTJuek1EYUZ1dFA2TnhuWUdYQmcyUkIxVTA2clk2YVQ1aDY0UWhlTGxuMW5zdE85dGZqUlFTQkg2RGxHZEp3RGtsaHk5dU1nY2ZGVjZnbjViTjFiUFhyNk9PY2ZrWSthM0Rzc3VxN2ZnQUFCQUFFbEVRVlROdXAzLzc2RFhmc2c1VWNHMG1lWWkyN3NiSi90OHNxN2J6TkUrbWd0RlFXM2VSZ2dHaVU5THFEeDVtM2FWQUcyWnRYTXBXVGFDdjA0U1FvYkx0QmZGNnBGT2txNDVSL3kwd25DdW44TFNSY3d4RHM5c1k4WjVIVXdrbDBMWXF4QTh0aGNNT0lNNTNJT1grL3dYbklOYzR4QW1hUVVSd0hYTWIrQVpRdktqY0MzUVNNNWlvb2hONHVOR3pCWUQ0TitnOFcySEZ3cUM0eVROcCs4a1pLN2ZsdzRTYk9UNEtSaStLbm82cVNVOUQvRVRMaHZOVzc2YkNXQ3lORTFSVS9oNTNGd3U3RW1mQjQ3d2NuRlFhNGxNNEtqVVFFQlNCc1k1endTR2l3QmpKbkNpRi96SGlMaExhRFBuL1U3VElyam52bjU2dHUrSjBJM2wwVHowd3RxSnNiNnZIY3pyRHNVZEJTZE44YXowbGwvODRzdlYvL3k5L3pHdEpCaGVkRS9qMldmNGZIUmM1VVR6eHdpMjg1ZnV4aWdXWDNOQmc1Z3VGOHZUVHRXZWhnRFJtbzZ2V001R3pQQm1MaHNIbkppYmlQZFpiZzNLaGxRY3FUc0NKNWdzK0dKK1BXWndabXFFdzRWWHo1N09XdTdrTEgveDR0bFlPN1RobDY5ajF0SDRkZCtUUmpObWR2dnRsUEx0Y0hDam1pdVcwYnZhSWUyZzJZRk1WbGU4aFd2QjgrRVZYeWFWWUNLOTNTTXl2NWttZHhKZHRvVG14RHJETFAveHRRVzRFNG9Pb1E3S1FGYzRLVGRLOTcrTGtCU2oyZzFKRkN5elk5M3ZKZVRwU0c5YUVBa1RWZjlCRmNUNGhFWXhINXlWMnMxQktQUXM5OGxrWkhRUDl3MDVjZFdSZUZUSzVrZU5KTDJZQnM1b014N0FMeXJ6QjlPaHNabUxtSjF4Zk1iWjdpYy9tTVZ5aW1NY0dCR3AwME9HOFNHYTBTNENzUHF2cUtCWFkvUzNZK2JicjNIcXEzekhKUFYza25ORDRrcGthL0JoWERjaUtPcnpjWEN5Q1ZyZFRuU3MzNlZsdE93NStYaXIzS3N2ZnY4UHExOS85a1ZSVkNvKzZSM01QaERaUVV6clpnemxkdjZaMVhYSmVHbGovRi8yaGRrSE1VbmQ4K1p5YlVQN0tnM2dIQUVtWXQxamI2VkhUTlN6dlhTYU02MTFXbG4zdlJ2bmVZamlZdStGNVNKZUJFaXJ3bXpNMmQ0cTJVbDJMdkFNVnFPNmg0eWpOZUZtVE5TZXM2TXN4MDQxaDc0Y2dxYmxSWURNOVNIWW1tYlpNOFRzdnZFYk5rRzl4N1RKc2RlSXVTbjhZZTlvUXFLSzltcXJEeTR0S0NOcXRMRTByd1pxem9pRUJrS0REL2Z5QjJGTThnVUpLWVhiZ2tNNE5ndUFaSitNZGZ0dXZ1WWVycm5HVVJ5OGxsd2k4MGhUN250ajZuVS9nUXBHTGpnVnlBZC8xbit2ZjZJRkRCNnVqOGJsdG5tMXhqNkRtN29xY0kyNGg0K0cxbjU1L2ladDVYcjEvL3lIdjE3OXkzLzFseDBJY2orTnFrQkVhMk05cU9jVi9PSC9henFnMkV0eXBUYmdMSVQyZExWa2lVOXB6MVRDNThiSklycHp0L015NFdVVktSdmw0RTI1VzJrOWVxWERoK21DMGRMMmVzOUoxdTZsRUp5ZWhMODlENE1tMkhmN25CblBiZU4zZ3VHczk3bFNhUG5LMlBqQWFJN25XVUswSkFneUxvdzBON21BYUoxbWRwVkZkWmlWbzNaMFhCbXRBcDJqazlIbzIyL3ZVM2FXdm1QZDhGKzV0akNXdS9YRTh2Qkp1SXM1RFFNSU9FUDBFY3QxMnBiN0xKUVpoYXY2MjRUWXcrNG5KU0VpeG9JQjJUYjNKS2dDMUhJNnJCd1QycFhhcDJta0gzT3drZE1qdnMyaU92T3gyQlNiYlFITXh5ay9LUlR1cE9UNzkrdC9GY01oRWZsY0ZwSkw3Vzd4a0Y2Ukw1VzhhUTREOVh4TXAzOUhJNHRzVW84RGV2UERORGkvUTZ1WTliM21UZXBzNTd6czZLOU0zWDJOL3BOYU5OQkUzMmdBS3VzM0tuSFlPK3pabVZhRjdDWjBqNEc4ejNrY0ZxVjFrUG94aDhaWFN2TGkrWnZWMy8vNnM5WFhqeXMvcWJnWFVDU2dMczd2aUNWR29DQjRWV2ZQblJCVnZ0dVNjcEVFYkNGeTNzWngzZm9Xd21iRTlCeXFWSi9UZU5TVnphRzBEWU13QkRzZ1loeXEvY0VrRUVFcU9nblhKSzh5b1doWDl0ajRtUEYxd3NQZk5BR2ZqYTh2SnBDaDI1amREeUhyTmtBNjZsd3hJN1Z1Qnh0Z0xBUUJQeWN0Z0M5TTNTazg4TnpGQ1c4ZTVlZ2xnZTNBOVRTZ280V0Y1SjZicE5EU0NNRW13aHQvSVZ4bFh3aDl6S0RtN3dEWXJjdkd5TFNXY2lKTUxudWJiL1VrTS9JYWMwaWE4NHRoYUFUdVZjeFlMeWI0S1JBaEFNQjN4anB3cEpWMTk0V0JIUmVKUDRkUmhZL3dlbjNOZmYxaG5MV3ZaZ1J6WDhEZXhrdzIveTdmeDdqQjNuNis3M2RDYU5iYnZtRUVYLy8rYWIzUXZsNTl2MU9NNEpBY005VkpCK1hrdFN2ak01czk2VDNtWVA4YWVkNW4wbzN6T2p4WXpGSlBOYThsUmVjNFBILy92b2d5VTYzb1lxeXd0Uy9hbVRIQVcxYjlXYmIyUXJQK1JoZkJJWHk4YUg4dU1pMHhuS0g5Nk9CZHZBQk55Y2VjV3RvRWd4UUtPTUZ0QWxLTEk1M3dqa0czWHNLRGdOcE9FUkpWWmtxdXUvK2k4ZU53YVNtTVR2UHRmckRGVDhiL2JVbC9jb0ZBQ0ZZa0lpU2E5SUgrdGhDcEN1TzBDeEdxM3kvRklZRDIzOHNPZStTN0NTMVc5eDgrU0VvczJwSFdOQ1EyeDZsV0tRODc2djVleGJsOFJSeUVTeCtxdlduL2lpRnN6U0dlSE5SNnh0ZGFoV084RFVhUXBCMnBKSkpuUEpFazJleTZJQ2d3Umt5UzNXaFhvaXNhbEFFNFc5Z0pKcUFtOG1rK2JBQUlLdnlOZm13WVJPWTRKOUYxd3VRanVKUGFyalh2VWFVZ3NvOWpiL0dtSkFOa3ppWWZMZEw5bWJWTkp3QkxVRzFEZW05Ymg0UUovV0krRmZ4V1UzV1NpYTFlUzAzZmYveFBmN1A2NWErL0RGMUNrcGoycHB5WW1IYmJtSGF3MTRrMVJXdlNPTjhkUFU4dHJ1SytDTmhwNWh5RUpuRnRJTjhQcDd1VFhoVEVpZ0srYlc3OGQ2RklBY2pXU0FrcUJIcnJ0bDVFU2w3eUwzYXZOUm5EZkJHaWEzeEtFU0lpdTg1VVFMaVRaWnpaQlprUkhtMFNzOEc0YmpSV1F3UmpEQkFDTGhvbDNPR0F2V3FlL3J2bysvM2FBekJ3V3JIUmdzdUhCNCt2YUJpVC9MNFlZTDlyUlRNL1EzcCtSb1NWL3RoUFdrc0NvVFdCejA3TThyS0lWS1RRaUFna2YxQU8rU25UU3R2U1ZWV0UrbTFFSmZkck04S3paalBnNStOMDU4ZkRuREZBR2d5bUpXc2VVNEI3bUl6L3hyRnZHUjhZbHA4K2M4MDkvVDZNeXBqQlN1MGR3WXJaeW1Pa3FTRSsrRTlMbVZ5MTVuUTlQc1p3THh4VmlvSXAvZnYvNi8rcks4ZkQxY2VmVkZLVjBEQjNQYmJlbHF0R0dlQllOMzlXeXV3QnpHNHZyaW9VRHNINnZhRFV2cE9SNnVoYXlnOFRVQm5hdXpxdzNLcGx0a3RMYnhvcUxXZndQeGk4ci9qNHF0T3FsaWc4MzJVSjBNMlZaa3J6RkJnQnU2MlNtNzFuUFpqcW5qSzhZRXV4QUJHNE5VcE8rTWx5R2MwMm5JS3p5d0ViYUxHeFkzSXlBeVNvUGdoZWtCSDlCdVFQY0E5UFdpOXRuejhUREw5N2JkRmdSaW9FZUQ5TlNzdmovUnkvVVhXTHpqbVdnM2o2UjdYNU5vdGFmYXVzNi8xNk1ldkxEZGttb3p6bVltUFB6Nm0veTFnWWk5LzcybXp3dXlhbzdjdmR0Q1ZTMjNoOFp0czFjVnVyNEpnVTV4NDFsYW92NmUxK2pzRnY2aGlCU1kwbTJNS1VlZHp2U0RMbUtZYnk5T256a1hwT29tRU9raXF5ZEkwbmZRQUJRVlErcUoyQWhmQXZGTmZHVks2U0pyUUdOWVk2SElnbWVYODd4dkg4ZWZaOHBxd1E3dTB5ek9VN01RTXZRNWlUekZaYVVSYlhTQ3BtSGVlOEpMNlRWUExmL3U2TDFhOSs4MFgraUFpbjcwOVJjdkM3a3BCWmdxaVRieDdWT2ZTd3NweWRSS3NUbVdlZm1pdHB5WXdESTRpQzlqRHJTZkFMcWFkUGUyTXlGNGVKMUhpUEppYnNmeFV5SHI5ZGZCYVRaeGU4SUlHeDhBNkVpdWp0U3lQbjExb2lRMWZCSEp4MHJ0elVYNGwwYkE3TVJ2dTRuOTl2aVFZaVhGTU1wc05FTUtWZzF0ajJVYkRBejJHVWZaY21hRnpqV0F2bU1mN1BoakFmaGJWWTFXYlJVUm9oSm5xbHRXOU1TU2RWUkpCMVVmZlZTc2FLK0Y1Y3g4eTN5bndQL29wdWo1cnZYc1FKaC9sckhBYmJzb1lZVzNoYUMyMlRWcE93Q0pBMEg3QkFGUGNLeWhqL09DSm5LaUk2ZUl5SitkeG50Szd4N1RWZmpHck55T0NXUzBEQ2V6UUl6L0JkMm9QQWtPZXBMNlZKQzBaRVRNRm1ZZWhLbEg3MXE5K3RQdi9zOTdVczFpR2svY3UxQVhlTlFXaUpYRnVuQXluNC9oQTBmRVFiVEVYbGJuUElSWE9YbmpDQmxFd3pTY0hNeFpzbDArcWJwZVoydGl3YXNBL1NRVmhXeWFQdVcwN1VHYUMxTTh1WkNOdy9QVGM2bTk1cTdadTFnYU1JdUVhZnRNemI4UkEwclFjWCtEdWNCY3d3SDhYWmhCWEI0ZUNaZ1ZYZkFSdm1Pa1ZEQUFQVFoxWEJGK2twY01YdkdPYWZYcG1QaTIzdDV1NlltOXdvazFhVVI3M1pXUk0rakFGTVBoQWk2a0ZVdjJubkVnTFpKUDRTbTJjek1SVUxJMTJvZFJEd2orcWRTSm9peWFXcW4rUGVvbXRKc0RxcE9KajZ5WlZoQVcvZVplZkhWQ0N0emVJbzNDekM5Nm9DN2Fhd0lGY0FuYVpwTFZCb0h3T1cvQmdQSFVucVB0TEpaOXJXMGhqMkFoQ25NSlBLUnZISjJId2Q4VGlLdGZkZ0hyMnJ1OFM3NEhBVnN0KytyVTJMejRvSUp2VWRQMzZqUm5UVWlmTUl5NjV6S252V25aSm1IV2YwMVpPdlZuL3oxLyt4RXB6U1E0S2xZdGZ6dEJiT1hkclZYbjVDVG5kdHB4MU1LaHEydDhlVUkxbnNSUWdlSERBa05ZRmJOTWtRRW96MzB6NDNhTG94cHVndUptQWZiREROSkw5Ym11VFFiR013UFlXZWgzRTMzdEpuYWRFa0lJUzlnZmp1ZzJpTjFudE1oeGhzeklnUU01K1dNSE9DckRTL2xLRUZuUWF4Mm9mdWcxNlFsbEFiaG1Vdk1ZNCtjNmFkOStBTzVzWjNjZG1nWXpaNTZtZ011aE9vVW1ndTFoNXNuRUJ6WHRSVktzVmxsUUdUeW1MZlcvdG1IU3lrcW5EUW45ZEpRa1ZGd3phL0dFbDdlRkdmTmV0ZVlMa3dTOWdybWRtNk1aUWxuODRlcEJFMzd0c1lIbTFselpRd05oZVlySDh1eE5SYUIxNXA5TzNGdkJmQ3JSbmFZbVpaTGNFVEkwd0xuaHluNEl4aDdVMmtUN1R0TEtiMStlcS8rOWYvN2V3WnFJNDJFNFBEN0Rqd3VUeWNySFFhc3h0ZlVmaWphNmk1WXhDYzVhSjZHSzdPSUpqYVVZWE9hSk5MWkk3bjZ4N3JZZ1h3ZmI2ZHhPNnRrbGRMRUcrVDdOOXg3WmhkUzJsZDlKd3Zqd3RHNU01WUdLVjl4RkFtd3RjNHN2azN3bGtydmFqYVl6VFZmamUrb0F6YTQ3NmgyYkxpTnNNWERJczJqQjdCYnNxTCtoMC9ZbGtOVGlQZTcxeGI2L283RG1ZYnduUURjQy9xSTNYL0JnZGtuMDFHZTV3YlI0UUUyeHp6SWMwczZBT2lMd1JHbWkrU2dCYUZJVkcvbDgwOVRZTXBNVFhDbHBjMW05a203QUJFUUNGWmJOQjJFdFFjQUpnUGpMOEowcjNJbDhWRWd3eWN3aHg4NnBob0VYY0tDNXZYbTNKSnJvckFqSXJlZDZtZHNzL2xqb2trS2E4NXlXY211dEtrQ1ArUitvQTNMVnhUMVoyQ0FsNkltNnRLQkM0d1ROVDBadU84UnlEZHNCTXgzWmlJVzlwSHp2bnp4dDZOc2J3cUwrYmYvWi8vcnBTRWQ1blRkOUwrMHZaSTcrQm5zN2FTdVB2MVdyK1psb3JBaEk4eGRzeVpTUXdXVEhOYWtYbDViNjFwZ1RFdGEwemRkbll4a1JCM0NJQnBqVTlzMlh4RUpCb0x5WStMT2hFbUMwRkV6TUdmcGlYK0Nma1VNL1BaRGRMUWtDSzBOZE5qTmk4bE5qRWJ6QzFtd0hCcjZoSEFJa0ZKNHlZKy9vb0p4YmN3enlmbGxWTEpUeFBFMFFOcmZCUjltOThMOHJlOHdZWEFNQWkrYUFOSjhYY3ZWdkdjMlIrblVPOTAwSVcrVTYydVBTenFXM1F4RUdYT2NzSzNzdTdsYjhFY0hLQ0ErY0liTEdlQ0IrMFpNckJHTDBTRU9jeDhnc1c4aDRrbG9PR2Z2WUpUZm9lLzZBQStXNWQ5OEtLRnVjOTNmWTc0TUdhRXl3d2JwdEZlMmluYXBjbGcwbkxGYU9zRXplY0ZaQngyK2lpejhQbXo1MmxaUlMvclJRZjMwY2xWZ29PSW9YMHdEZGRuQ3BvM1hFQ1RuczNCemx6Ymkrak5iYUU5R2xyNDFLTXZNNWZ0SFhvUkpLRzlUVUNpZldQaThjVFJwcVlGVU91VnBvQ3BNOTl2dEliTGZMSmI2Sm5tMmY2UE1PaW5EY1FzSFVuWGl0dVR0TnJ3UXNJcS81UjIyZWJ6UG1JYWdkZGNsNkFRZ1d0M3VycWZhVTNaV2RZbGIrOGZYMXMyeXcyQWpRbVlBR1N4ZUM4YjQ5Z2hVVUovdThlQy9JNHoza2dDL3ZGZWtqd20wR1dEWGU1bmw3c0hxaHR2ZG16UVp2RnhVSWUyNjMya3p6aEgvWFZBUVh3M0kxN0lmbGdaaXNqUEZDODMzcjBrZ2lRNlFKaERLTHJIT2l4Yys0eXhuY044VmV5a0JqTUpRcEVNZ3dSdDZKdWtFUk9IdjhGcHU0ajM2a1pNSkNrbUttZXVUVGJtbXNrc0doZ3hyNHF5Mkt6TmZqZm1TUnV3blZZbW9YS0tkUnYzN1dtbktTZWwvdmF2L3FwbFhkZnU5MkdFRlFPOXFwVnpTTUUwMWE5cnY5T1FhVmNNSTYyRE9Uc2xVdTducTh0Q1RzTnJEMFlpQnErSWJJaWxEVVVjaTdraUdzcTVHaklWOWNPbm9vRVpSL2dmdkRmMTdPN0NsREFGenllSm0yemowZUQ2anI5YkswU0N5SWlNRUlIMHd1dWpKZlZkcVJyVG5TQVkyMFBxdkIxZE5HY3NJS1RMSGh5dHBMLzhIQVliSHNBRjJwb3lFVm8zd1hjNWpJYVRkdEdNKzZnUkZrMkNUK1U2UVVqYjN1clpPN2tkVGs5TEhFMERRK2lZakRNalZRTG9ZOGFIV1hmcFVqS2t5SlJxbytaVHg5TDJaUUlycmR0YzRCU2Yyd1NPZXQ0YVI0Mkg2THQ1NEl2WXdBOHR6QnFhM0FMejRhcC9ZRXpnNEgzMDQrZUM2MHpaQmZkcGtKaVNCR0NmVDA1RksvWStBYlRzUjh3dnFmQzB3emkwSFByeHo3NmZWbC9HZXZlTS8ydmdKYUVTakR2TnZMUWpOTEcvdjhCVlhsa3I2VzhKc3NxOE1PcDh2bW5jZktpWXRBQU03UkU4bUp6dzhqSUJMQ2hpSHZ6SStzTHpONzBtclBmQnErbnFiQm9NMGhXR2ZtNW5xanBrNUxydmNRa2xmZ2VlYW5Bdkd2ZGRmbHluV0E4c3c1L0JFeTZObm9FbXdmUmMzbVF6OXZ2a2F2WnpFbEg3WEVYR21Kcm0yTDZESS9qLzZWWEt4T0ozbXVUUkFkS1N3T2ZNTktEd1VJbDRmRXFUdEpoMk16WjU3OWtFMmdta0ZRV3hjY0tZdnVNOUtSS0lYMFRQQkRDejlXYml0allBQVpxOEhCR2FoTjg1MmEvZkl1aEtPR0lZSE1zMkFXSEpuYUg2M3N2c212WW1qUVBndDNKTU9rK1FORUFjdWhXWTM5alBFVG9FOFBuZTJaS2JJcHphUkh0KzhxVTEwR1J1MXJibGRTVWhtQnpIdWNqRzdRcSthWGs2TldBUTdVMCtreHo5a0xRWjZTaTZWM0h5RFJISE5zd0JEYi80NVg5WnZhNTI4cC84MmMvTHV6cEtlcVlseEF5WWtwRTdxRGF2MXQyRDFXbHRiOTJlOEM0SEtRbXp1am9PVmdyU1N5OEpBYnhFbGhEclJOakEzZC9CYXpwcGd1Ukl3TVZKM3NRamtzWDNjcGFLemplbjBIZy94K3dWQ2RlcnBYZlJDSmJjS0hvSHMwWENMbWFzSm5HNzN5VVUwb0lrMjRLbjc0MS9ENGNFQVBnQXNTSWNzTEhQVGFaMWdtdmExcGd3RVVSSUMvY0lscVk5eUNyS2FsLzJDbklZZzZEMDg3d2NIbzdtV0VIRVcwNWZQc0syYVFoOXA3eEJlTGphdUIyc3JQZW9OajJ2dzRzSWNQZlc2bFo3LzdZa1pZUklZNVgrNERrMEcvNUFzT1Fqd2pUNVUzWDVkRlFhUE5FZEZZSFFTbWdrYUFOUkVZNld1aFlXdzN6Nm14OElybHVUOXdnVjgvZWVlNjF0N1lNRUxFRWgxTW9IeTJVQWhKT1JuOWEwbmNEODRvdmZyLzdONWIrSWI5S3Era2J6NHNPaW1kRmVYK1ZRUDQyaGhBYnpISFBpTzdPSG1CdUc2WDY0MW9UNmRQa2gzYVhCK3J6SWFvelpYczhKTytFSlFjMzU3NzF4YjRUem16dUxXNGZHQStjSlpPTnhHNm1adFlIV3lCK25GUlNHSlgrUFprbXJ1bWp0Mmt6QjVaT1R2dGRhZFdxZDhyckdNeFlGWXFNOWtOZllHeE0xTkxhS2tmR3ZCU1A3OE4xcjgvLzQzLytIZjRzUVNCL2NiWkVXRVZTYkRmajdFYmFJbEJ5TUFod2pXVGNEa3RyRGtYUnQ5TlN1QlgyTUJXeVlVN1FEYUd1SGJCNHB6eXhjT3hNbGVFSnVDR0ljcCtGaWRoaElXNTVXZDYrYXE3aHhtcFZETWh5Q2NiUHVCTXdreEltQUVkSXdsZVlvTXhmM1Q0ZXJaVWxhWUkrVy9hejk3MDVFMVRSYkQ3T05ORlRQeEhRTG1RTW1LVVhONXZnRkE3MlY5RTdTbk94bXJYVWl4NUZzVVU2L3haeVRYTlJ6ZmRXM3UyZGFkL1R6SUFMNjRqZS9YUDM2di96bmtqYjNPenIrYmdqU3M1SndPbXJxeGVTRUdwMUo1Vjd0UllqM2k1YmV5elRrZE4rUEtaem5QN2x1enBKREo1T1pCaFJpMnlPd3RDZkRuRUppQkRIekNUYVRpSmxwSjNxbll2K2k1ekt6cFJGc3ZDOGFWcjk1ODlmd3pzOFdOV3VZSENJbWY2TnJiaWlwRm53NDF2bVpSZ0xId0V3Q1FTNDcyaEROdzNmTVphRzh2aGZNK0FrNWU2ZUZkcDlEVnNRSnp2d2h5anZPcVVMQm5QbnRjLzVER2grL0ZUcWp3ZE84WWdIOTYwRFh6Qjc5dzV1WE9XbmE2RlRvb1RHclNQczdOY2VpWFB5cUNLazd1cjExTk82YzdNTi8xUGNrbkNvVGs1bDlXc3VYdG1DWWxZV05iNVhaRHRlSGtPRE1Zakt1dFMwQ0ZkejlsRElCci8yVXRqRVE3WGZDZjk1dnYwVmFaZkpQeExVNXFCQ0lkYlhXbUhoMGdXQVJ1a1J0TFlMLytULy95MWs3TXhhOVNBeldrZUpWL3QxMDN1bmN5OG10aGJqMlFKTnpTUEQxT3hqUG5qV0h1OW9qaFdkVHE5bSswY0taWUUrZmZETk1sQThaLzdUV295d1YwV2NIU1dBK0J3VTF0cUtoTS83UkNHazNWNGY1bkhIdjVGb1JNVDdLZFdBK0k3QXdvRXhXT0tKWHZhd0E3cGpSWkh1WGVTbHhsQlhpNUhGYXJyUVNESnppZ3RGeWlSQm9Fbkl4VDUrTkVuSG4zelRDSDYveGxPRm8ycURnZW53Y0dJd3ZpMGhabGFSTFdldHI2Y0ZVVUw3Q0tHQUR5N25aRFBCOEJ4ekV2cjlJSFJ0SjVSTks1aXpNSnViYzdsbzZRbERCTTZkdzhBQ0NKc2ZYRWdCMzkyNnRIdFVEYWFmT2pJNDV3aFJ0TWlsQjdXL2dObEhQK1hLNUd1OXRqa2FxTG9lM0l0RHdkRlJrU1pLa0tlM05oZ0U4WjY3TnZ1aHZqRm1CdEJPQnJuTHN5dGk5RXhNNUZxMnlObk1xellCcFJKVlhHN2p1WHpWMitiWFFiLzZqTnZYTDMvNHFVL0QvclM2d1BsemxkRjNsZkFtc1E4U0l6WVlPVEJ2TGY1Q2VnSmpUZGRwMGFqbmtuaFNUTXBWcGdUc2lSR21WL0J4TUlxSDdnWEg3czVFSkpsTVkwZ1dPWU5TT0ZDRHczM1U1T2s1bUVTMDlRbnk5VHlNempuVjBTN1ZrK1lBNk1YcjhLdWFXU1NvWjFUeEZhSmtQVzVtUENKUXYwdjZMS3ZrKzFvM1pjYUVqa21GSUdFcmY1bWlsSlFqT0RBZnFya25FZEhlbUNwUEJHSnpyNXU2RUl5ZGluMjYwUG1aeXozNzUrbkgzQ2t4QTdPQlVTc04xYlk3T0NzTmprS2R3cVpPQ0NJU05CTmM5Ujc4MUt6N0thU1JaMkJZTStCcjN6TFBuWGFlRjBWUW1aU0ZZNzhocmFsdTBwZEhXaUhhaUFnS2VMbFB2M242M2Z2T2xSWUdCZlJ0YWFIbGo2bGh2OTFrelhPNldvTEs4V0JvdFk5YU5xU2tMSWpnYnBPOW0wb2VMRy8xRXlDODZVUGJ4NC9xdTF3c05MY1h2aWpKL1hxdWtoODBmRTIvUEd1TUc0WnhnZVBicTVlb0gzL3VrUGNGa3ExdU5SakhsYjE4K2F5L2I0cEJQdWhDNlNKcFcrbkF6M0paY2pUSEEyNFJGc0h2ZjJwUTdZVWJGdm1KYU1hQ3NFV01TSEFPay9sVXNyMFBwalJTQXkxd1k0MXNOYm9ROVA3YS9OWk8wcDJkcDFxODdIbENYMHg0M2dra3dDZXpBU1RETmQ4eVJreDA4M1lmT3dOdmx2ZTllVzlJT0JtZzliTDBadEI2RWROcWlBQnhUSVQwVzg5RVFKcnNRRzVNUEFLYjFSRUJGVERRV0pndFYxUWFlQkZ3cUsyYjQ0RUduc2NUTk9mMDgxOUhlaDgxQmQ5SG5UNS8wbVo1UWRkRk1sUi9uT09lRTZOd3dMSTdDcEhJNU4yT21oSWptd2Q5aWtaaWdxeWMzMS9KeHFzSGp2TFA1YlBnNHd0d3IzZUJOdFZlYTZNdnY0dmpXenhxQ0tJblF3Y0xjWlB4dk5FNzI1UkJrLzZRK0x5MXphQUgxbHc3b0lxSHZWNjhyVmZxN3YvMnJXc1BVY2FHR2VxL3pTYXhLMnNNOGRGYU1Gd3hjVURSdGFUcUJ4b2paNzNNU2RldSs2cUNKdlNUblpuVkpOaDhqY1pRU0FtTUdRYUMxVFkveFFqcWFyNGxQbG5oN05NN1gvaDZoMGRqN2g4MGdOV0pKUUkyeHhNQkorYzJZSFcxMmJkN1FpbVJYMDhpR1lLbGc3Yk55RkV4OVRMbis1ZzRZeEdvTjVqS21hcys3aUNpTVJYb3l5Mm5iTkdmQ0VPTXpKbFBkZmpGM0VaK0M5em1CSjlOQnhRUzhNQ2E4Vy9ZM0V4b09CYnozYVU4MzhzbU5wZ20vZWhadG1Pa2hUNUR2Uk1KdVdhV1pzMm8vK3p5dGE4emZHRDFkTkFVMHB6Tkhja1RYRExaS3FBeHdyVEh0QUNQNDRNY1NST0JQUkhqVzVFV1lvd2xyZ1d1ejltQ3cvbXpXM3Z0KytzelBJVGh6VFhyNkd5MXRGTlVFQzJPN3ZJL3h5M3Y2dGg1b3YvdnNzeGpXWDdiTzhDRk4yejdhQjBKWElYSVJudFd6U21WZWxtcWo2dUhqL0xrRTluVWE0M2tsUzc3bm1IcWErdlMxYXcrNFF1N0ZySjU4KzNYUFdxd0lBUkFDY2JmbjJ1blhtV0ljOWF3Y2ZGeXI0OG9ieDdsdTdTeXdIZVZFL1I1ME03L1Yrc2FZb211cFR3SWN6RlAxbkxMcHdVaGp6Y1AyZUVPY0oveVFXakU5M05YUTlsYUFhdjNOTDFjQWVVNmhzTWI5elhoS3VHQnZ2bnR0TFZvUlFJc21MUjU2WFFZaHM4Vnpnak0zMk1BbWd5RmhOampoOVBudVBuNGx0ampKS1U4SGtObWY4amRJZEMxbitHdWtKYmd3TDV2dlFuak1zNHRhaWl6Y05RbWNlb3lJVDVPSUI3VitnZVJVeEg0a29aaDBrRnNkbnZZcytaa0F1dWVaS3h2ZGZSalBOTTB2WUVDMU5DY3BDdTlpQUJEQnlSOWdJbjBEZ2pFN1ZQeDd6cW43Sm9vWTByVFp0dzd1dGxuTjgvaE42NlBpeGtSaVdIdHBWUTRlUlpSL1ZmckNXUTcvUC92eGo4b09wbTdYTXFOVURENGtURURCS2Mwc0VtN3VMVHhFQlh1TUZiTlFzMFY0T05rbUNJd1VVdnlLT1pqN1RzUTFKblp2ckluaHVnVWdnblorMUcvYUtTa09KalFDbWdsNE5KWDJ3V2VjMnEweGRLRzlNSTlKdXptcHBIY3hUOW9TRFJwUlJiY0ppTDdYL1RRcUFtc0Viczl3WVdMakl5U1ZlMDUzejc3d2l6RDM2T0ErMTJZSUF5SjF3ZVVnelFxODE0bUVXOXNDSTZKdFlKcndTSXB2NXdhWXlITGE0VTZsU3FmbnJ4c2ZzOGdrYWM1OGhyZUN5VDVwTDhFeFpIZktOaUZ5RE9ZeDJRY2wwQjQzNWRPSWJ4aEVvTnBPZzROUHRCSnJ4TWhvU2FUOWFmdkdGNGRoMGVEQTJacmR0Mll5UTZRUkxaelp6M2RKSU04NHdkdFA2MENzZzdQZHM2VFROTllINHV1VytlNzY4M0dhQno4UWRXRHNrNWpXY2FrYmI0OWZGSUZlSE5OTEo1QWJWWG5jclY3MzllcDVYVlNPc3k1KzhNbkh3MEQzMDhKdlJrL01aSzRUcDY2L0RsZnQ1NTBpOHJmcSsvYTI2RHFhM2szei8vYkp0NDEvdlBybzArL25tNjdOVXJoQWVNZ2RQTDBvNmZ0aGg4NUVvK2ljMzRyalhyVFNua1hPRTNnS2JJTmZOSHhDYkNvUjBoS2xHQ1Y3eHIvOHZzTnlkWEV3RHlrV1o1ZjNoaThnVU44Ym1vdkhMT2tyMGVqUTZRTEhlZTR3NndEekoxZmRHalFBZzl5TEZFVWNpRXN5R3NiaU15L3Z1MnpVZWdOcFBqaWpVQ3UvanNSSzNRTWhxWnlqclZSOFlWYk1pOGF3RHFkU045WWJQZU1GQlk1Q1VZeWw1SVphcUE5UXFuSXZlNzJ2WUxXRVZBY3ErQTdpZnRYRzBTZ21ZcGovYWlLVWtLVG4zOHNzSTRGSERXK2pxSjRZMTBIalVFR2ZQWHM2WTF2TE9QeERaZ3hzcDF5b1cvbXRQRC9sZlpCMnEvbFNnOCtTWU50cElUdE9YTzUrMmg0QVBQMzJxOVh6cjMrLytuNlovKzE2UmF5dHI1SWRTUFhtVGQwdllyeGVWMG4raWJ5RkFIS0grS21tNjBEUGhVejhFT2VuVHR2cDd4NUFXd0VUT2lQSE9TYzRMakxhWXZjdi9qRE1kamxzd1A0Z01pbzZIeUt0ZFlyWUczOE8wbWl0Q25jeDJERVBReHIrSDZlM1hNbkF6bFFoU2R1cW1ROEdoNG5FQXVkdlk3dkFGS083RG9reElEV25UTVg5bUdFVEdNYThGRERud0k0aGszY0JwbGNNdE85QThLQWRjaWRjZXA3eG1IR2pTL1M3M21ITVk0U0VYUjQ0WDY4NlJQZ213ZmNpYld1N2ZRclV3U09ONFAyOUFyaHBkbzA1MnRoMTJnV1RvKzhjSkVCZmxiUjduRmwvVlY3ZGJtUFI0bCtmdnB4T0h5SmxXZ2M3OXNvOHpGOWhyMnVoaGVYM29aSFd1azRlSFliVFBmQ0hvUFM1OXdoaW10V2FjWUZmNENUdjU4STQzZXR5bnpYeTk0U2FiZTNtNnV0dm4wd0M5T1VxUVhtbnNUTHJLUVlQSGoyYXFEakZRam9IYTBXRVhIV0kwaU9uS20wbkdQaUtKa2dXWEVYTU54b2ZyVnluM1pJMlgzNzUyWlRpS2F1Umo0Z0JzWWFZZmdxUThRSENtcUN6L3FpcCtVWUpQZGVhcG9sbGYvdGRvMGhhSHB5ZXdFNGJQZTZTMW9IZVpkc3owUlhQVDVLMUtvZ1dDcStaNWtxQzdwZTBpeUVuWnhaR0R1Y1RFdUMwMWtJSFdCLysyYklvaEU2YUF1RGl4MHAxUzJXMHNUYkIrOGVpRXdGNm04OGpqVUhDR21DVHNxSkwzVFpJdmVTV0xJUkR3cWZ4VFRJZnUzM05BQmRUeEQwUkNRVHBKdW4rVG9iMW5wd25PeXhxNFBrNHZhWm10QW1MNmNjZ2luRm1jUkVQTG00c1pUN09XVHNweW5kQnBXNER0VXloQWJTM1NacWMydDIvSFlKYjEzUllUWEl3UFdRSm82N1JCcFBFZ0w5YnlnSDFtc04vczVZbmh0T1A2enhnWDVaTDlmZS8rTVhxYi8vMmJ6dVYrZmJxYnRwZ05ENjVLNjlmSGFYZWY3VjY4cUlUY1RveFJZM2RRVnJEWlREZHpWdzUzRW9yYkNNUE94UTFEaGRzTUw4U1dFUEc3VFFEQ2JVMlZwMGVUV09JbXE0ZUFwbXJVZzhoK3pkdkpRa3VYV0x2bHZWUEVHQzJQaFB0Yk5DK0N4bVhsQk43d0lTRkRKSk94L1FNL3JScXBUeUJ0TG5rWjR4Slkzd2NyanBCS0lpRkV3c1N6eXp5ZDhXWW02UEdlakxYN2Nkb2NoSEJZU2YzTU1lNTg4ZHNURE8yZitvdE9iU2xUOUNLTi9JejliQ1p6OXNTS00zZFBrNFVOS2F0M25CYS9JU2dZQUkzNW5EY0NxeXZXd3NwdytmNExxME8xYmNscS9NY01RaGtMMmJHZER5THdWMW0rdlNOdEMxRWs4a2RLSzBkTS9ETUhqckNWMmovSkx3NG9FMTJJVXd3dFc3TWFZa2dMaG9YRFdGeXJmb09QUFc1bitqRTkxd0x6VWp0NGY1WThCM2V1YzhlZ0FrQjhqWXppWnZwcTIrK1hYMys1ZGVkRlAyOTJRTVovelFQOWJmMnptbFdVemplL042VTRsQ3NaM0RxZ09YUmZweEZtN3VaZjIzNmFFYm1pQ0dnSWFiOW8wcm1yRVVOcGtOUnpzSUx4TStQbFg4aE0zR0p6RmtYZXBSQSt2TDU4NXo0OThadEVwaTZmZkZEbnFja1lMWjZqZGxEYTZYb3FDSzV5SlVqMk5Gand0R2k5NjN4amMrMEYwODROSlU2a0hTWVRWb3RJZHJtcFBWMWNsUmpPN1ZjVXV4LzdjcHlXTFNub3hCMkFlQUN5S2RQbnc0bnRqZ2JacVA4WkV2ajFDYnUvc1hYbE5vWVVIRnB4YlVjN01mSHFaQVF0bnZ5TTg1bGN5Q0g5eTQxLzRvWS9UMlJIUXdudTVobTV0eERPU29iazczTVhLQ3lLbEZRamlQRXZHVE1Mc3dzTGJERkM2RkNkSXhMOGl2R3MzV1I1QWxpbTBrZXB4QTdaSlFUMm5zVFBVbDMxY3Y5Wmc1YkVuL3E4dG84bTZ0cDJwMGlsVXlUNjFyRTdKQzZJZjVGK1VDdlU4c3hXQWUxL3ZZZmZyRTZTSHU3WFJMcTZSdmRGUzVXWDM3MjllckZ5K01RSWtiYmQwVUpjOEEwUHNJQXQrVmszWXNML1g4Y0ZTK2ZhRW5JM1kxSU1XMTFqWUlkNTIzOCt3aVBkc2hQZGNYUm5qWmtYMDVyRXdKWlNHYm0vRWpLWUNzM1RzUUxuTzN2UWZkT0RkZFVGOUFrU0VoK0hHaUdvU1NzY05ybUZxdG92SDdwRW9GQ1pNWnhMK1kvZnpldjhSZENncGloRmpqTUtBM2NKTTdTQXJRcUprWDlybGplZnN3NGNZck5xR3pHQ3h6YjJ6cTQ1aHZNaitFMlRJUTV1eEV1bUkwRVlIRGJhNS9NVmtDQ2l3SU1ockcxZHI1U0oyQmZ0YTd6VTdDcFZDczhLbWQzR05SdThCQmpzNGVJWnJ1NU1YRUpLTXgrSFBFMGpkWXp3cUMxbkh5b3hQQ01OU09hK1RkSmZ6TlpJck0vWE9DeWhoVWhpbGI4RFpKK1gwem44T2NENC9KRjR3RGhCSzB3VkVTYmR2UFYxOSt1ZnZLelQyUElwUmVrN2NzZmZKVUFCQ0JPOUFkRjJFOWlBbWViSldFWE1keVBXWG05ZS8xMjlmSzRRM256czZZemorWXRROTR6S1NXRW52YmF6aDUwQk5qdCs5cnZNQU1YVTFiQk5kOFVVLzE5Yzd0dS85ZXVBUDVId2lFNU9PT1pMRmNCRFZqS0VRdUd1OEg5dEc0K1Y3WEk1d21XcStwLzM2VU8rNVNwN2NnNzdpWXVKUFI2dCs0U09wRmNGVUF4SGdVSVhDaEUzNzAyMXR5ZUZMUTVDTUhHYUlDSFNURTNaTU9QMDdVSFFTanZjNUNOL3lWdFl6QTluVzU1d0lLa2kxTVoxLzBnZVVOZTJ0ZjRtZUxLb24yUUJSSWlVTWx0Yy9hY3lGck92ZW52SlB4ZGRFc1VTUVJuZkJweGFzL0hvREJBek1lOEVTelZsMGxqVEZHdWk2UXh3dEYvS2JwSmUwa1NOSjY4bkxkaHMrcDlXdVR0MjlVanBqRmk4NGZsS3UzcDA5Ui9iUGNXTmVZVEIvZCs1czN0VEpIcmtQbThyUEZ2dnZoTnF2ako2aS8rL0dmVG92ajA2R0wxYmRYM3Y2N1ErWXRPeERrdUg2Z3MwNklyK29ZMTFCQmtjRTdDSUVwT2ZYNGswUk0rQTM0TzY1ano2bG82ODJldjNDS0YxdTlMUzdnUjg5VDQ3YXgxdlZWWDF0eW5mNzA1Qmt2dzU0OVorMFhzN1RDTW5qN0Z6a25yNVhMLzRpQ21SYWtWNUhybEFPVnJnZ3VJalNEQXpNYXZGZndJRVVTMnZ0WitTUDRJNzBNMFdqVUdhcS9CVnM2V1k3d0lIYi9iUTFVT3RGZVJML2x0OEkzL1RXZkx0VCtVZTJFNzJPMzMzczF5c21pYlRUSTh3TGpnV2laTDZMT1piL0c5L2xpWG1zbUpmSlZXVVNmYlIvZHU1V2hPYSsrZWZjbk5tU2JNcDBQT2VjOERid1RYM0tXWlRNSnM4ejZMZUxGVE9MV21CN0JBOU1Pb2dxbHJUUFhlZDQvUDF5OS9MM0JmM2djejY4TXMvQ1JrM2ZQSHNYcE83Mk5HeElLNnlNOCsvM0lZbFBRTnRFZnc4L01jRmYwV3BUN01GNHpvSlhQck5Hbzg1aHd0eHBxT0VxU1lDTnhYM1hHelhNYXpjQzc5TC8vVnN3WHVrbTFqVEsrS3JtTThIUENhUktKTGVWbUJ1alYvNkxJUzdNMFhNOEo4UmZvOWozK2FhMEJ3aFUxSDBBbmN5RDJiUUVaajJPdjlyQk8rc3ExZ0Q3NEJlOHhSdU82MXpnM2pwQS8xaHRmUUp2R2M3MTViRUJvVHdlV1pEdk43eU13KzVodWlkYXdsRWNCQVFoZWlJTDBoT2Faa0F5R1RqWE9melpsREVRSzB4dk8wRmt3SG9YaGhmTjViL0VmNVpYTEVUcGxDa3A2VFZnNUhiL1NkcGNuZitML1NYbVFoYTk3WFIwMGkrNzduOG12SlhFZXNpQWpRUmVnNEx6azlTVzhhaC9jbGJHcm1SbHZSbFpOcHhmOTJXVWNBNXdWS2ZKUE9jTGNjS2lVMkVFQnI1TE1jOFRzbDNNODVld0hWMzArKy9xcjdDaWdFdC9OOEpDeXByNzk2bGcvaVRkcDFMQytWV3FHMWhQT0wvQ2Z1UzE4ZHduUEFCeWZxWVlkTzNEcklWMVRyTmZDK21aUnlhTVpVOGdlam00ZjMyaE1hbW5ZNXFkTUZQc2JzaXVuS2ErSHJnbGhERk8wSjJHTVdDRnBYU0Y4RUs5b1NZY1EwbHg1aXJ6QXh5TlV3U2ZPUVBpUVBUMklxcWZKcG4vYVdaamZhWFVqSm1jN3ZSRmdSR2xxNklDUUhlcDZVRWdLSnFmY0lmaEZJQzZMTFFZTHdMdG9TWWJLUlE1Wm1veHVHMGhOUlp0bnpFa1pGNHVDS0tKY21nNEl2MWhRNXRBN045NUxHNGRlZGlHekIzL0FvaHJpVjMrcnl2QlFKYzB3NzN3Z0d1L3hkcmY4d3dYQiszc2JGQk4ra3haenlXVFVmQng2WTY3VDhibTVTSEVRczRiRnJ3WEVGL1V1NkF4aXVOU2pFQjk2WWtHdk5qT3lGOTJjdnd0R0JTT041dnpkbjdqNWJXemNqVkdndU1XMEUvL1Q1eXc0cGViRzYrK0FIODl6OTRFMm9ESlBkck1hMmczUUZCOUNDK2ZMSFBycjNJRVlVcnNkc2pvUGZka2NPZ1JjbWFLK2NsM25hNXJJc05yWlRQWnV6TnNwOGg2d0p3b1BtQ1FjSnZ0MEVKUkFNdzIxdGFGVVNLYmd6Q1RGZ2dZcFhtYWp5TkE4U3VtalozcXBkcEN3MFVNL05qTTJ5T2NtRnNsbHFpa0dacnV5eDNYZ0xlSUFiUDFuRU5UQzd6cHhmK01leUJ3UGNELy9rSXBGZlJScktoK0RJZnJuYUw3dWJ0R3kwQ0tha3pCWnNVSnNGMlhFL24rMlc2T2IzQ1VmSFhmbWlhQ1llQmtGeFR4S2FFVGVxZmhPU0lFYTdrTi9qdXpacktkc0krQTNMdHlRUFpKTHRBb0tUWnBoWkNJN2swaFdDYWJMMGZWOFE2a2JJelVTUm1NbS9kQnh3SEFIUFBLY3h2TTAwMjZLbEpPRWR3bmthWTJLaWVkRytidHdvNnRkOEVjLzdTbk1BbFpsQk04QmNPZUhialVLOHREWVIwb3RPN1BreVpNa0ozMFlmQmJQUVloRHQ4ZVBucWJmQlByaHFSL3cyWkZnZitnbm1halkzOCtOc2xGTjBHV0pwdGs5YVVwZTFxQW1IVnRzUEhvM1BUTThzVVIra1NvUFNicG1tTWttSTdaZHNaZG9nWW12U1RYdlJtbWdMRUlzdlRwRzNsakFRWXhoRXlNUXZRdFBVeWtVL2VjUXpaaUExUEJqYlIzdTQ3T3VpUGRCbVBXZGE3WFFQNXFJMmNrN0I2ZmZaYUVaU2UrTkVHRm94cEg3ZmZLV0FOTnhJVXNYbTlsOXVYZXhpeHNTa1JPMlkreEJlb3VFdzNiYklXaTdyRThaSkxKZXJqY2pjeUp3WWZ4cVozek9EenpVRzJIOUtXTnJLZkNOMTY0elpNVXQyU3hQWnI5QjRPMjJNLzRUdnNBa2twS1JRcEJVR1c0S05adG5PNFdJai9KRExNSG13YkMrOFhONWpmcSt2TlhOYmExbnJlNGNPTUxXZVE1QjZodmV1RWd4d3VROUdpdzM2ZmtVbFBZT3BpSEhvTkpKN2cyTTkrYXZuMUtlZmZHKzFuU0ErQ2tsZVBJL1p4RmgrK1AzdkQ2emVEWjJjNXpOOWxqYmVNWGU1UlpobWtsRG9qRmxtcTV1WmorK2VQY3NadnFRaTBOQzN1bGNlR0VIQTN5WEoyb2xVRWtiUnhFRzREOVlFL1kxZ2llRlpqem1ISmNHdk9zWUV4NjJpOGVnbWhBaStUVGpjQ2dHaXl4ejRDYVBORDZWM2xCdi9YWVgzQjUxd2ZsemRMNjBjTXp5dWVCMmVjVk5JeUNZWXYzdFZHbmVZZHRLWGR0bWVLcVhySkJvenVieXNRME9sSXVPcmFDS2sybEZPVWFyN3RJTWgvU0tJeTZUMEJTblZmNU80R1A1TXhMR05rdlhNZWJZVndlelg0a0tqdVBQVGFnQWI2OEdEQjczZlFwTGd2cGVJN0g2THpkeUxDTFhUc0dDcTdhdTBKM1dHbU5WWlBqVHFQV0o0bThOTzR1cGU2dVpPeUtsUHVJM3JpekdtRUNJbU5jVzhyYkZZYlBlR3dHM0dkWTM0ZC9xT3Z1RjhSOVlvdXVtY3ZwMVJpL25xQ25HVEZqMW5ONjY3bWJhbGFabGNxT2N2dmwzOThwZC9VMWo1aDZ0dk83YnIza2YzVmsvck9mWDN2LzNONmszejNXNERiN1JCTnVta2ZLK1QvRkEyRWROeHRwdytUYnV0K1ZGT3h6dEZIQTl5d20rMGdZK0NDVVpzNC9VcngyUXYwNlJJUDEwazNxUXh5aG9uQkFnbm10dG1mZEdQODVQUmlCRks3Q2ZrUWxRYUpiYUc3dFc1QWNISUtuZjZFUUZrSDBoc1poSmlrWWhJeTk0dGlvcDB4a3doUFBwTzJ6Q3F2REYyWWtoYnRjQWhjWlZzbktRNU1nYzJhWk14QVFTSnFmQ2x3NmNUVEMwWWt1UWJyZk1nK0NKc1hRRzAwSjE4cmI3Q2p6TGliaGJXSEdJS1owM3NSZ0puV3d2ZmNPZVZkdHVqWlVaODVjNFJSdU56YW4zNzdlOExiYWVEd1VYUEc3UUhxK2JoY0lwdjBrTGtBMjdWa21adnVBS1VZOG9tTkNPbytFQjQzMk1MdGhEaXpYcG9CWE82Yms4bmlna2ZXcCtDNERXVG91RzcvRnliZ3JReGY0OFdsZEFsQkhSRDlaMHAzTSs4dnk2Tmg4TmZZVHF6ZkNLbXdkdDN1Q3hPM3ZYek12OVRIVHIxcGRyYXZOVm51MVBySnlIenNnaW9TUFR1ZnEyUVlsd25DYUR0RWo4dmNzUS9mUGp4NnVNT05ISHExUm1OT2tGNDFKeS95bm5Pa3BHYjlqcUIvcjFQdjlmWXJhVzlzVzN3QS82RWVLTjFZYkJiUlFMT1l6SWJ0TFNZMFVXTW1tSkFpR0t3dTVtbk4xTjA5TkIzQXJnV01nL0NSWXhyOGc5YjA2MGFZYjRxMkhXamhDeE5QN1VnMTZYalhYdCtsbkE4eTJkOWQ3dDlpU1lKZHhyaGZpM1YvZnp1dFNWQ01kR2YvQ09pT21OaXRJbVFGb2YxZ3B5dnlxcWQ4QzB0NHlySFozendmZGhnc2tzTFhCdE1Fb1dZSWNUa3kwQzRWVm5rMmRuSFRWZ2JERnphNFFwTWg1UEdIcTB0aVdyQk10alB3M1Fid0tmMHNrYUFUc2JCckd3ME0rWThRQ1BHOEhlZWJaNll5NlF3TklQOUdCSnBvZnVrZWR5dFE2bU5jRURFYUdFQlNDN091N1F1eUNlM3pCeEkrMkdvSVFja3B2Mk5YeWhrMjQzYk03dld4NTYvZXRIR1I2QTBCZlYrQ1A0M3YvbmRkR1BFYU01amZ0VGpHMFVwUVdYQzVpRzdsQTBNYjYrMTNJNnBPZEpLZXhTTSswSEpwcDkyRGlIelZYMGJMWWRnb0owb0o4RkErQ1FPZzVIS0FmdWtSZlA0b0Vockt3aWVNc2tYYWQ0KzlUY1QwRHJIcjlEK012WFFxeEtNdFlNN0dobFl0VmtSQlhPU1NjT2s3NDB1eEFlVzRNUmZNZEZMQk5oN3lrdDRYOVlsSWZ4RENxbkwyZ2cvN01mU1JjQkJHdTk2dnUrUXlMZ3FSNjB5bXF5MjlqMDRKT2tKQ0QzSGh0aURMMThJVTVwR296RWRqVW9rMjl4MWV4Ni9XZDlaOWlJQlcwckR6WnNSVC8zR05tci9RenUrZU10OHNzY0puMkNheFRIYTlQSjN2cHlZNm1pa3pUMkF6Yk04ZitEWlQ3K2JOd2N4MlBKbmVRODhNQ253OFFJMzF3Z09jR3IrUGg4NDlYM2ZtWktWZmk2d0R0ZGJHeHp4WGFiL1FlZFFxbTE4OC9vNDRaWW0xdWNIdDhCWTg4emF4MlFSa09Vdlg3MVpmVnlxdzB1bjNBUzN3MXM3ZFRKSnEwd29IaVRZdit5azlqZmxYbkZqdzhWSi91eStXNDJsZ1BvNERlNTB5b0gyNXI3VEdLdTBGQ1U2ZkZ2MjFPRVVzZ091b3gzYU9VWTlMWktiN3h3ajEzdVlDdTJJWUdQcXpka0JyWm1na0xQR1N0bU9tZEtZV1djU3RBK2lZNXF6NTRDUEVqZk5PUVVJNEIxWXVzejV1OWVXSk1vN2QzTCtSb0RIK2s4MWNROUhDRlREM2J1Rk5jdDMwc2x3RWcyVFNzd2lFb0dHeFdFOC9xOFF6MlFnQVNTeWFWT3YxMkkrZnZSdzlhSXNkaEp4b2cxdDJLbVFhcHJCN3UxOFRwazk5bEFHTWdtZ1RhNnlsL0c3TkQ2VlFwS2xrS21lejN2N1paSzNHWWRwS0hZZVlTRU1HYmV2emw1RkVHMTZXaDFHK2paSmZsUVM2cWVTN002S0VNVjhJUFJWeitBWEtHd1M0MHZ0N2RrWThvNStXSTJxZ3dLWVlISmFFS3R1Ync5SGlqakFsVlIra1MvaHVwYkhqcWwvOHVSbEc1SUtYSmNBdmVIQllpT1ZkclNxNE1WOEl4eHNrT3g1N1g1cE9ETG5EMXJmK1FIR1c5NU1STTcvZE5XNFZIRjVMcnRwRmVCTTBtdC8rNjUwQkFtdm0zRktNaEZqUWtSZUNJSS8wVUVBb3hyUlVrT2EzVUxGQzJOR2t4akFJbEU1YXBuWUNINllVci9UbWpkRGJnZzRPVk9OUmZTNGRMSGN2a3hDaG56R0VHMWNtRUZTdDAxa2hyaFZGd2xsSXRJZElPQnVtc1M5ZnVyWERTYXltM2RLVnNSWXpKdmZSZFhCRUhkemNlakZlY1JDdUxWUlNlazdyVjJYakhBc3ZFUGd6SWVyNWtLajU1ZmFvcWxtOW1GdTJ2S2UwT1lGS0k0eGNlMXp3cUcranpIWTY4VXowRHE3MTNqMkJwT3lBSm9IQnVQeVRMLzczRnI4ZFBucE0rK3RtWmYzamJFdzFULzY3cTdhV0hocUhEL1h2Ni9IWWltSUJtSWtSekVZZTRFUnZlOUFFdVBMZFlwN1pTcm1PMzMyWlBhTDBQbnN5ODlYUC9yUmorc1QxcnBqTmc4TGx2M3lWNzhhMzlHdE5LNWJIUnRIYUZFR05CTjRuckRscytVbGtGeTlXbVZWdEw5S3IyN2V2TWRTVGtpOEc5Y0t1c09DUTRNRXl4SlpCOWQ1UDhZQzErNzJIWmMxcXpxUWtIemFQUWZCZXF2WGpZbVNaeEYxRHo3eElrWjhNN3JZY0w1a09GSFJTbjdnRHJZSlg2UWtnWXYxZ3IvWGQ2OTAwTFNQaUJOK24wWndHcWJ4OVJ4RlpDOWZQZzl3aXkxN3AwRmxlQU00cEtSbUg0ZTh1bkU2Q1paalh0N0ZmcG5mNTZtN2kvZS8va2R4WUZFeEZ5MWh5aWxDTk9ZQ3A2Rm9FQzJIRTU4MVlIeWNsNmtxR2UxR0xWMWtxUFB0aEllalhtT0VtS21GNlVjdlF4ZGpzY2tVVlJxWVp5MXRaU0J5a2o1dDVpaEpxMVVzNS82ZEpGa1BhNE1XaDk4Y2tGQlVUbzRTem9SWjNibVQrZGo5UXNpVHlCaWV2cXBGOUduTWxDT1VmYjZkZXYvdGs2ZVRYYjFaYnBXbzZzM2FIc3ZHZGt6YUtpbi9zbkR6Y2tLTG9XWHA2OFFvT3BqV2txYjAwY2YzeXlVS0tUTkVySW5Ba0E4RDJaejBvNXhCTzVYTEdCV21qYmtFbHRrYjJmbld5eTlqckFtQ3RHZlNDNlo2UG5PSjlnT2hFS1VYUnRqWEkrN01qV0M1ZGVCWXFkSUNmQTR4TWU3MjhnOHFlU0R4M3ZnUkk2cStOZ2htcjJhOEdHa29NZkQwdlR4VTRSRXpydnU2QnlIcFBPQ2hTLy92R0ZsekZaQ1FMNllpNGY2OWo1YjdvNDVvWVQ3YjczTU8vNHRneWhYaEJYYWVOWVNWejBOS2pIbVE1SUU4SE1raTZGRzAzcHZoN09WeEF1OEQwVEEvelU5YjdQMzlZSktwRGthWTEyNkY2NWpPZWsxRGdMTW9hMjFPUGNPRlFXRXkvallYUDcwbm11ZW45M3pYNVROaklrS1huMnNHNVcrZmUza2Y3dlpQUkNwUXBDUktqeXZuL2Nrd3oyU3NGZlJoK05DSFF4ZjNQNnIzVzh4YzU1QnZuajRlRjR0RTRXLzcvVFJCN0h4TzVpM2ErWDFNamFDWXd2UDhZdE93TUJlS3JyQVk2MTYwRVJ2b1hxZFJLWi9Kd2pua1JHL2V3VXhONkhtQ1dIRzZyZ3NUOUdpVFJBbXROOFNkZFVsR1BrbHJ1MHJvN2VYcU9JL3hvbnptOE5CeWUrNENUNUhQL2F3NmxndnRDbzY2Q0RPK05IUXdpZUR6N2gvL0tYTGZrRDBjTWVqcGZKWlVjcmdueCtmZFZFSUE1VmN4SU8wSTA5SXgweDdJRW9hUVRFWVRaK2E5em1jRCtLT3lOekVsTmd4STQ5enUwTlVsZlVMaTJib3hHc2xsMHZsMTJQTXRHRGZmYjR5VDVxQXJoQlNHMFE1cW1IOVpuZzJrczNGTUNJekthU04rTWpWSXBla1cwSWEveVRabVhqcFZoUjhBb0lheDVyVGxHK1BVdzN3aENkVjg4ZDJsaHZlZDZZRWRiTjZWYzhXYzJndTRVN0lSQWlEa25kYTZtZFRhMnJ5eit2enp6OXJZdEJDNVFtbFhwNmY1RkhyK2Joc3ZmWUx6RkZJR0FqZzU5VmxqUXFVQktoRWlBWm1iRnpueDB3WFNIbW1TZFZpOStRSUZMc1d2TnhTVmx1eDM5REptclJzR3FlWjdFVWZqWW1TWTlhTEY4Ujh1dFc4YzRNZnRXUWtCc3dlekw4R1hHbThPMXgza1lOenB1dEN6eHRIWlJLbm1rM2phdkkycEZVc2R5OEtCZkR6QnpXTHN1MFJMMzZmdDlBc09GWklHeThhWGVUMWREOWp2elExOG5mcUwrUmxUaUY2RUNwSXlyZVgreWNzelI0S01CRDV0RDMxT0d5WFVhRXIyMy95V0tLWThyZ2lqdVR1emtEdmdLaW1PMkxDWWlUWTNucnJTNnlKbjQ2VnBIRGpLdE4ySVVzZlIyenJoeHlMVkYrSlpNeGU0N2ZkaEtvM3A1NXI1TExqZXBuYTV6L3ZybjJ1RzVPZWFjV0ZtNisvOGdWSDFYYy8xZkVJaGxBZ1d6NFlKYnBVRXEyUW8vOEpFOWI1NS9HM25KWHc4dUk5eFlHb3ZVaXp1UG5nd3VWVmZmZjFOQXZEUnVGOU8wbUsvL3ZyM0EycysxS05hOVRqSVJZODJrWEJqTWRzZVBMalgvVkpIbHJianpMK2h4K2gyTXkxWmdiU2NLVHM3aGUyRVIzdStkc3lEelFqeE5Db00xaDd5VDcwdTRxZzI4SDI0b1RjZFFibUdEeUZ4RW03SzkySXFjdGxRZkVRcEpiTkxVUUtyK3dQWlAvNlROWUJUNHVMNVc1cUVUT0EzMmNKN21SQ09ERUtzRUdieVBacXdNOUw0ZHpoMEpTM2VLcUlvdDBaaW5MQzNUcDczODhjNFVKVzlMeHRYMUU5MnJ2UUFXaFVHTTUwT2N5YnJHanJScTdqeHRHbU5jRFhVeDd6ZWx5eW5zK0poZm9qbHFQaVlWV09LVUNGMG5VUUJRQXVhOFk5QnBGNThYb0doOHB5NytVMmNGdExWUDhwMWxPV0liTkdVUHNvSHNCVGloc1pKQzJiYitCVDZuTGJoZEIyYlJEdVR6dENqNXRndVJIbFFEcFZES0k5VHhaODhmWkhmcXJNYWc1ZXo5cWpRbXNwaCtxL3l3MDBLU01pd0VGQVNxdzFtY3U5c1BXemVSVmpxTHJudm1IaU8xS1RROW9PMDFVd2dlU3VPSWRNODhLQU5ISE13UjZxc1oyYVJWaDZuYVFrWUYyU0Q4RjYwVzg4UVFEbkt6Si9zWTVwYkRNWWF3TXozSVFycFNxdWlraUJjWmlCQnhFeGFBT2Qrd29nMlRBc3NLVFhDekZzMlpqMy9uSXZHT3hIR2tObTZMN0k1NUxFWlQwYjhGS0ZuMGpIN0hqNThtTVNXbXlWRmdybTVhQzUrcHoyREU0MFBqQkE3NW9ZSVNHTHY4Y3VJZ05vdkdoaUJFUDlLUTFpRUEzZzRxUFlzYzdQSDlCenBFdFV2cHBhZVpVVUFndndocHV5MjNLK2NRdkJteldCb1NxS3hHQ2ZtNDhKazFvekg1MnZDVytiSERMV0s1ZnJUN3lBNmU3Sm1mdXQ3L08wN3hqS0dueEp2UlhDVmNhbnNRSk9maExQbkNUQ01oY2wwTjlxNkZheGJRQ2Z1ZkpsVnMxMUgyNC9Tb3I3TXgzZHY5ZWMvLy9rSWwraC82UHJQZi9hekVVemZ4c2prL2FFQldpbUVKYkR1bGc3Qlgvb3lQL01ubjN3eWdoL3NNVFFPY0E3NGMzd2hYTEZSeXJBY3RZYjVQSHpVY1dMaGxiWFlNNHBNQ3ZQZzdmdnc1UVpmYkJZR0dPQUZjQXdzUnZub1hqRGRENjl2UmEvTmRrQUREc3FPakV2WitlNjFkVnlScFMrNmdWTllKcnZRc2dlOGV2Vjg3aWZwMko4STVkUDdudzZ4TTBOZUpiWGtaWEhNdmJxSUsrWW9OeFlFRXVsNDNWZ0tYVG1aWHhTaFVBYkFLVGc5ZFRJYkpxTTdqZWlpK3hFbUcvcDhXNzZJRG9tSG1VUnloRGpMVDFhUFBucVUxdkVtcnIyVUk1Q2tObnFaVzc5SFlQcE91MTQ4ZjVIemtITzRVMjNUNnZoYnJHOUpZaVgxcnlhcXhxNTNGTlpXTFk0eEZab0NVeXlZaGVDTHYwVEw0ZmVZYVhPOHl1RlB3d2gxaHhDLy9mWkZNQ2tLVW12bVp6Rm1qbjY5MzlYSE1YbWxUM0NDSTdiSmNtOXV2RTV5dmM1aU5JNDdPaTU2K3JMbmJoWUIwc0FQb2puWUl6RE9YRVRCMm83ZURPbWJoMUlaclpnaHoxNit1SU44QWZ5TENzR2xIWHpiUVIzOFNuc2hIUTJFcmo4bVpNeUJSc0hQd0drdklpdGZaay82UWUrTmFkNDhhYW9RekRXTXI5L1hoSVhoblo2V2FKaUcyUXdycW8yaEVrQWxPNTVHVkdnVzdrd2ZydTZZWThKNkw3b0lOMks4UFgrcUd2S1IwRlo3Y0h6emczTS8rQjltaG90eklnQXBKTytVYXJUSHQwTm9NS1NKWWxpbkNUeElmWEhPMUJhNVRXT0tPS3gxbUhjRnZqc0pBTjdJZDQ5ZkI4dE8wTTRwL2U2NVluSjR0NWd5bk01TWZldnpnay93ZDNsOU1IZUNnL2w0enoxRG5OMEhadjcyMHd1VFFvakdBRDh2Ny9uZSt2S1plMTErLzlPL0pWanFmTnZUWStLTjJlZjhWUmVYK3BzM3Q5YjQ4TUhEMFdETW1Ybk1WL2NvYmV2eDQyK2l6KzNWajMvMHM5Vm5YL3d1LzFHMEc3MHgzVVh0Z0JvVG9sQzh5Qjh0b0tXOGFTTkJhTTRVaGFYY1ptbDNmcU44TlRsOGIvSng3YVQ1YlNjQXBYOVFVcmdkME1GUmUwTWd3aWw3Nm43MHJlVG5YZVBkRGtlZkZkMC9Tdm5SQW9wZmxCLzR1UGtjWlNGc1p5MlZ3Ylc2SVcwcXJSbXVnaTJ0bmZZMUdsakM2N3RYaWxxYkZIZHpKUHc0T2tVbTBuSTBxaitOVWNpazFqZGJpd28rajdQVXpKTTBHK29iQUdCTW9la2c0OXVhakpHU0Z6ZlR4TnFBNDB3Y05yQVdMSTRQbXI0L0lUUlRUcklnaVg3V0pPZTAxMmtaVTlGcTBzUEUzOFlFSjJXLzc0VXliUkNmVkhsWVNjb3NpeFlrNHJRZ3hDQkdiL0lidGM5dFF2UHBZQWtNMThhMjIyMlNVME8wT1ZrSW1JcEw5UlFlaDBTUVdNSWEzNW5UV2pBSHhiKzhrMHhodmFJZWYvbE5KZ3lIWkw2RG1CUE5rei9nNUt6U2c4YWp0VkNUQlE4ODFoRmdxdGZsVWtXK3dUWFZ0em1EbUVUSmhYZ2lxbFQrdHlVRTZsbk8zTkxRUHhFNjgrYUg0MmNpdmF5TENRdEJwSUpvTUtnV0V0T2dVYlh0dzJUY1kvOTBUTkJubTdsQjRFanJRTkNRd3I0dmhkV0xkb09PSElyd3A0UzNFRlhMYXNJWS9qalhlOWJtTUpsRjZ4ak5MR0tTaFMwZFlFcUNXaHZFSFI5WSsyRSszQVY4bVJmd3kxekRFMmFBWThFbU90U0s1YWdwb2g0Q3pRbDhFYXo1U1k1aTZJaURKdTh6L2lxT0VtS25xd0FBUUFCSlJFRlU4K1hrYW1Na1lXSVFDcVRmRnpRaDVUVytJN0FRSWhNZmc2YUJYUmRhaHdQOGhLUGRkTE85aHpqbTVmSU1jTEIrNzYyWkdEeFozK016VE1tOVh1djdmTi85QlA2YU9mbmM1U2M0cmk5anVEd0wwL1VuUnRYV3RNY2Zna0JvNVVJUTV5UkJuR0NLMkUrYisrTnZ2eDB0U3dSY2I3cTNsWXg5OC9YWHRXaDZ0dHF2UjliZDRNVTYrcnJDZkpxVlFURVgvZFVPYy9XODBhdEtVbkxQNGNUL2wvL3FYM1ErNGxkak5kSHNkZXoxMlZacEMyZ1JEQ2tZdUI5cnh6UkZyYTJSdGFUUHZweXNyU3lNODk1REQwOVNIQlRXMys0VUx2bVU3NnFwdmVvUVlTNkJUYWtxWGVOdWFGOG9BaTZ1QVJiQm9sVXY5OHdISC83WnV1eEJ6U0lFVUQrWEZ0RUdJdWE5a0FDWWhaNFJ5cE5hVW1CUzV5MVdVelhBcGpWb09jdEpaZ1hxOUFEYkNUY1gyekdrbk50TU9raDhHSkZJSm56TGdacTVxRTVQYU5OejlYTGUyeTZFV2kzZVFjU05jSmlVcnpzVys4NjkyMlBhUGM5T3h5QzFJeWFGTStsbmt5RUJ4SEdjVUZzK1FCYjFDN1VpbU00TFRIV1Z3YzIvQmVuSHpBZzVNSzg1WFRkR3h3eFVBOGsvd3NkRlJZWmpDSnkyZ3BHQkRYT1p0bmEvMnFmSFo4OEtsNStWa2Z5MEl1ZmY1eWZDbkpJU2JTekEyVVNuVml2b1BZOVk0T2xVc2tlay9GTVE5SGJIaVczVktIQ3YvaiswUDlyWTFNVUYzenRKcGY1b3Jhbk5hVkhNUW1hWGFNN0pNUzIyMWpXdGl5bHp1ekEyNUdKMjN5LzBEeDRJQ0hPeUg5YkNOeUlySGFNWHVVUElUQjVFUzdOazlqSFIrRVg0R1NFaUFUV21mdStORHdhTGJidzVOU1VhMTgzenZIcEdmaW9kUnVWZXpRbkE0UUlmbnR3dzJoYkdvVVp0dWtrMkx6VjdrbVlkYm1xT21DZm5xNzMwbWV6dGR4K1lxdTlpc0M5Zjh0ZUpWUEhQWVRZeXZ4TStFZlF3aTNCeE9wb1dPRkh1UXpOMjlCVEpyMDFQTW5ZdURNSDlJcWRjQ2N0em1mdUx0b1I1K0wzYmdrOHo2NWVaVisrNWZOZDc2L2YvbExITkRmM2ovalZqTXNZZnZtK3MvbDZQc2Q0bitHTHVVNW1RWUpwYTBmeW4zMVFJL2ZOLzhzUG9vTlNGbk5qMjZrRVJjaHB6QlRhREgwKy9mVnl5OS9QV25PVVF6TC8zeWZjclNTb2w2UG1UWnBKL0tueXdHUHN0QllXbXBJY1Z4dGRHejVpaXhHOXlYWmliTkNXbS9ad0FGVzFqU3U4U0lzcG1wZ1ZQZURaSjVnSkt3WWhHN1gzdGFweFdkYi82eEFhSytzSTVabUFXakZZM2NJWWtrWWVISDdTRVllcXpwODJiTzJyeFN5N3dadXFEMjNldkxWWGVOQTBudkVLQWs4S3E3UHRpSGxGZEVyMGVONDl6enBHdTkyTllJaXQ4U00rWVhVWElOalNxaitnQlhGaWZuK0htelNUR21DTExaZ0VZLzRjSk5KMnhjUlZnWGw0NE1aYlBLb0xseDNWa1U1eElCdjFCdVY1U0ZhYmhXRnJHSFZHMWU2SWFoZjdUVnBoZTA1Qy94YW8xSXprbzFOb3plOVpwa3BzYUxaUzkyem9jVjBicTdTWUI5SVMveGVRVTZnM2hPVzJCWnJzejRnNzJDckVtc1NTOUlsclowalJJbTQ4VFFVUUVZOTFnb3NzQmFYVG1ST2MyVDQ2TXpnejlNeWVJMExnV3gzZ2FRRVBKWHptc3dFMW5SaWtDZDh1TmM5VDc3V3o1MjJsN21BaG1OeEVhY0JOWnlhZDI5T3BwaGNENXJwb1RKb3I1U0MzUjd1YjJ6UWZqUE1hd3J3UVhRampGekFoajhzV2E4MlVPVjVyT2JuczErV3pCbjBub2NGWi9RK2krM2ZNaTNCQ3ZIU3lsSWlKS0U5cEkyelNXTkFIbEc1UFc0dm50QzBrSUdTWGV2ZysyQ3lPSTRUVzJFNEpPbW05OGVIV1ZKdXF6SmIrTXdHdTNZb2dJSDlMNnlheVpSTmErSS9vMWhCK001UjRSVnJReUxnTE45VTQvWkVWMzB6RFpDbjVhUytPMmhzdE1mR1U0S1dqNTJjTEwyaXRQKytXRTNMblRaOUpPTVduNWJmMVBTWnk5YmRPQ1VYNjY5c2crREw0MnIvVzFabFRydnpFak9BSTI4TUw4WEd2TnkzdDhvZDUzMzVwQkxaMURGdWJjd3daZkp6V2x1Uk1JckErNVNwdk5wYTNvdTRzeW9QenNtN1Q4MGFDakFlNE1QaitCakkrcmg0VzNUSy9mL1BwM1V6SUduanZCUkZJVUUrdG1KcmVNZGI2cjNTS0k4UFQxbTh2VnZZZDM2N2o3WnZYOUgvNWc5YUo4eThVS2labHhXeVFzTHNQcjk2TE90Tjl3K0g0Q2toSWpMV1ZUL21hOEE4UFNUYldkYm8rWWRsbHM0U0poNU9Rb2ZqZFpCSUljQWxyVGlUaTQ0VWw4NW80OUkrd3h4aGFjZGQ5ZTlOenZYbHM2TUw1NFV2cENnR1A2N0xhNGp4OStGQUdlclQ3Nzl2YzFFYVBpRmZHSzJHL0dIYW1sY294ZXB5bmR2RnNtZWNpa3FIZ3BtNURCckEyTlJEQmFUUXd0aEx2T3hDS05JUUpIYVRBYjFVKytGZHVWaGdhQlpaN0xwVkdpTVZucGJVamtFM0dLb0ZSRDFYMHZpNUtwdGJ2WGZEbnJkZ0lZMC9BNEUwMDBJbFl6U0lLUStEZGsxVEt6dkpnYzJ2TENVajRtRmgrdDVpclZBUElCVUk4SjRSdWx5bkdNYkh3eU1jR21rcnI5ZERMNlNlVzNUb2hldFFtS2syTXF4eUhMbEM3MFhGb0pGVmVpcEpiRDdINGFuMmVZRjRla3piV2g4Y1dhOXNjS3I1a3FhUlpSMmQ1VlVxcDVZNGlFRk5YK0xJUjZINE9ZUkwzRzJjL1hKdmZyS0ExNU93S1VUNlZxZ0JrbzNEM1J2dGFwbDFma0dYTVUzZnpRMFNMRUc2YlUvWmdiRFNicUdMK1h4TXFUTkYzNG9QUmpNeGpvMVg2cDREdHo3ckpBZ3lPN3RPNDV5UXlCYUpJN2FXNjc5YkZTdUI0SDZybUlMMGFENHByQmpZNXQ2NkU5cjFkNDF2Q3htT0FVWVNKNGdzNGF6SmJwaDRsTVRWL1pvYlN6ZHlldlcxL3ZkZStZM0JoQllscW5Vd0pVMEVUdzVsMHBETXpuazFKck52TmRqVkFNK1IxUzhpN1RYZUFuNUdvdm1LQXg3TWFJeFlVSDdZSEMrSDdDRFVKa09ucjBQQmRtNWJLSGY4cTRNQ0tYbjJONk43YkxYdEsrdkR5TXFTdmFMZktxWW9MSlBwOTlFS3JqOGdqZW8xVUVNb0dDWjNXdFBTb2xodmJyOFNKb0w1NlZVL2p4SnlPd2ozUkJhRThTbzlIQVZscG9qVGZqS01xc2FGS0hLU05TZUNaM0xwZ2JSOXFDbkw0M2pYWHZ3ZDNWcDk4clB6SDZPZ3RtWDlmdjNhbnVjNXBPbkdSeTZCbzMwVE5aODVnTHYyWmlmTFNwalo2UlpCbVkwZjRkRmpKdWtaN1BySk1MU1pIWXpneFhsNnRNQ2w3b0JIdVpJdkFtWm9reHd5Zjd3ZjBpc1hrM21NVVB3Mzl2L3VOcnl4bG8zM3oxVlJHQ1QwT2VjamNhVkJUblY3LzkrL0N1NXJPWkhqWklZcDhTa0dseGd2dE5MZGppajNyYjJYR09wMmRLTUQxSXgxZXZYNnkrLzROUFdsaUUyZ0pyZWg3M2oydkhJRTVhNU5JeVJmN1Y0cytnanRwMENhUEthL2pBbmo1L05zNWFUZmNjdjNWMlViSlo1cEh2a0JqSnFCYkZZY3hma0Y4bmlVMktIOVlQaU9NZm9kaHBHNzI1NmV4QzVrNSt1WUE3R2w1TU5LaTJGcVp0REtLTnRGWkVwdm1ZNzE1RWtJQU04UEpoOXRLTUlEUy9TVy9GZUVtT29ucTFPK0YwSkoydWEyTjdtTGszSi9jMEN5bzh4dUNpOWRFb09GUTNiNVMwRjd3M3E0TjdOLzJPaXFMbWUzTVl3WTA0NXdVejNiT2IyMTFSU1dQd0gvVERNVlpLbUpocS9JL0N6RHRwcFRxRTNvaDROVzV6Uk5Zd25XQzdIN05xc1FNNzkyS3FoQkI0TFQ0RmhDWjRnZUZpZERRWDdUOFd4aTlSOWJUOXYxSGtEZXlkWm5QYUM0NGdkb1RjaDJsVkpUL201M1N3YVNyUFBOUGUwbVo2WjJFd0JCVG1rajhqNUJnaXBUSHFVUytZZ29IS2pHY094azFpUG05RzBHRm00Q1lESEVGTVZETzFkUkpoQ1pRY3lxLzczczVlVWVwT1A3cDhueG1hd05nSThkYytFVnE0aUJ1LzJTNXRxMDA4UzVOMDBLMzZTZ3hqek4vK2RPSTBGSExCaTNtL3orRXBaclBXcE5hZjJ4LzNFQ3FZbDcvQjJIZFRLY1laZnRMdkp6U0h4bEdUSjl6UFo3bHhubWJYbmw0bmZQajdtUHNZc0txSDNjNy9sSmFBY2UvRGc4anA2MXcwM0IyRTJrbjc1Q0NKcGh4RHFoOThPQ1ZKZEtMdkxVQmVGV0crMnhxaHZBTTRIT3p5dW14NVNkYjh6TFJPS1NaT294cmE2WDRCcUpNWTJZMmVJK2dCRDZVYk5HMmtNZVlrR0l4L05QUDZqQUxTbk1GWTVRSTRxVGR0ZGJOL3VxTHFzWFVlZnR5VUNkQjQrcjlwSE1rMVJYTzI5L2R6aDB5VGdvVGxkNjh0dm9aSnVXL2d4bzlSNUp6T0NXei9jRTJoUllXcU1vM1Z4R243Z3NCcFprZHBVNy82N1cvR1dmZm5mLzd6RmlBOVFoRnlHOTJDdFVWNW5iL21mdVV4QngzUDlQdXZIcThlVjdUcGVXK3FRYnNWc1RORVBucmtsQTRSc3NXMDFDWVlSN2JwRXRWb2RHZEhhWEZwYXRvUzMrN3pqVHVkOGxIYXcrUEhqMk9NUHh5VlhEVjZBemFIVk5HSWprcHVESUNtbG90UThBTWN4SFMybXV0dXpJSGpmRFFyOVJxUjFKU0hCQWdtaU1RMTBiTTNMNDhxMGp4SzRqMWYzVCtzM2k4aVIramJFUU5HZERObStxS0lpczFEVkd5L21YdUV1cGdGVEpDWVI3dnMxQnI5dHk5aXloZHBaZEh4U0gyUm5mM2FvZHlNT1NzUXZraWw1aVNsbTRrZ2tzck1sQ25RRGQ5SlA4aGd3V281VVJhbU1Ob1NwaG5DWXhRMyt1NWxFUm1tR0Y4VEUzeGE4OWpnc0Rjd2xRU3JkVTNqSkp6QWo4bmhKQ0JIZkdGc01wKzFoMWFRdTVHMDFMN2t6WnZub3kxQlhnWGNtTVpGek95Z09rTTVQRXo3emUwbFA4ODZMaU1PT1RtWU5WTmt6SnJxeFFnZkwyQkRGSnN4RDdCN1dqWEJuY3oraXlKbXp3WUgwOW96eFFrZElmZjNDWVhwZnhVc21VekxhY1pwM1BVV2M2cnphUUxrS3JPUWI1Tndva1ZZTW0yWG4wNlhCbk8zWjhKT21Bby9pc2pibUlSQkZQUEJpT0VNUnVabGJwaVZmZlVkMzNlNXozc1kxUHAzOTA2MVIvTzEzclZ3Z0kvejhMNEhMNFp4ZlRCQm0xS2trMEJNRUVnMVVCLzU4ZmZ2eG9qZjVpOTlQdTRQYVFZeTN4MUxkaDJ1MzN0NHIyZ3huMUxCcGFwV1h1UlhoZU15M2ZuejFLTGVMcExON0pmamVETmZzM3pGYWEvVTNCeXlvdldQQm9tM2J0MXIzZUZhYTlOcDRWMjQ2Q2d2ZTRoT01HRldsUTJMTDA5YUVGT09SU1U2THAxbmFuQUhKejdBTjRhNEl5Q1RUMHdWQjErWFlBcGNsbkJMUzAvWFNOQXN0SWhPMzJ0L25UYjMzV3ZyWFFXMVAvclJ6d2NwSGF2MXljZUxBL2RPM1NzZko3SHVWa2o1WGxQL0NubkhoQm9TMHVDc1RPNElsVFA3YnZsT0NpMXBNaml3OTdhMmNpaW5BZWp2YzhaY2FuS2ZmLzJraFMycWNlSWlvRXRhbEFWTE02RnhnQU45TENaYTFLdzFESklMMlVPMEErcHNFb2tQU21rTTgyZXZ0QURBSTlVUkFtUWlUYU9pQUp3UG80Mm5JdHNnekduTUlrOUlBMk9IajBPenNYVTdWSlowbzM3V2lON25DakNGbSsvZTJWNDlmNXhqa3lrWHczNzFzb1E3VEtGNWN1dy9mUGhnOWF2UEs5ZEpRdk1qWVFxUVZUdFoycFdjbGZIWk5LRU1nWjV1Ymx1VlNaUUVHcEgrczU4OXFuNnU1OXpUNGFET2pFWGNuT1NqanRJSnU1THIzdVJBMXFGUnkya09aK3Q0V2p0ZG5RNFFDR1QwVEd1U015V3RJK0JXTTVmR0VCT1JiNVRoMWx0RklqSGgvQWFuRVJHaWJITDQxTUNwYnpYLzF0QXpUL094WVhJdkswSFNOWElZMFZaQ0tRYndOcitkTmtCTVpreTRrUnE3TXdHcjBkUXlXL3FGemhoeDB5QWlBM3d4RDBjTHlSeEdBQm9qMHNwY0dTQlQ5blRPOU11bDhLNCs3SnUxTmthUWJ4T1VwamxSVHJ3dGZOSGFqQy9tWFVtNitrWWx3ajJxNzhuQXl3RWNnejVLS3p3K1dhS0RteFhYTWxtWXplOWpjalRVOXdWYStGMzVHZk8wb2Zmd3RIK2FzUURKMmdrOFdvUjlDRTRZRE1ia1BXdFpYMzczdWIzd2NoR1NlK0dQZ3V4TlFabHdmN1RaR0piN0JRQ01oNGxnaHF3S0dtNi9ObFlRN2UrcHhReUhYci9NaElzV1ZRcDg4ZFhYYWR6dE96T3ZkZTZFSy9jbUoycG4zQll2d2hYQk10MG85aWtpN1pQaVl3ekJ2RmtDYys0andSbys4ZThKUExXaHRVZjZkaGdGM0tOcEtmSFNJZGRuMXNWMGJkb3pmN2xpWTlhMlZzNTVrWGphbW5NTWRJR1EwcVJkdUNnM0RNT0lIR2VuYWdhTkRpNjBOdVB5aSs3bEV4Y1lPNjFjRFl6dnB1MkI2WjllVzVqRnJYeEhKQ1JCSjZjbXVkSDJGV2FQNFNCSW1oVnV2MWQ3azUwaWZjYzBEQVRkU1B3MGp2OGhkVTMrb0FpZFBqdWZmUHBwU0M2UEpNZHZ3SDJhay83ekw3OHFhdkZvZGZXT24ybWpaMVZtMHQ1YTZPMmE1Y3ZNUFR3b3NTM3RRK2I5bzRlUFdvalNtbXp2a2tkMUdJQ3N0TGkzK2F4RTRlNFdiYlR4RmpxOXBTTmF3SENNbDd3ZDBRYVg2Q0JFbkhRQ3BrYUE1USt4RWJvODdGeUdYR2szaWpjbHJlNktST0Y3K1FDaXljeU5NdDdUeFJXZEtrTGRQOGpKV1NMQmVaS2NCRWFBQjdWUFFKNE9uOEM4YVVEZzJsc0Iza2JIMFBvVEVqeC84YXB1RGZlU3JrVUFrM2lPQ1ZzNlRXRG9CNDBmY3dvNWRncDZRQndSV1V5T2xxT3RyT0x0Y0s5blFQYUZRVXFtZkdmdEVhUUVXYVlKZ21qbzhWRmdzaERBVVZGVHlKdjBiU09HMmVtdk5IbFRmWit2enhtRk5GWDdMb0ZRcDQ1MzRjSDc5aHFUbCtZaVYwNnlvN01NOVNUYnF1Mk95SkMyMHFlbHVOeklkR3VCelFNamx1UER2QzJ4bGtNMkJyT1Y2WXV3d0FqejA4UVJma1dtN1VFZFE4T3o4VWVWcXVDSXJteW1ZVTZJdzltR2NnQ25oNW9ON3A2alNWdUoybnUrb21wNHMxa1hrcHVGMVM4TGl1eTBWemRpWUtOeE45eFpzQkdkcGNYRFIvNHdCRDJhclBjakpQQkNQSEFiTERFaDc2MFpsTjh4R3hjODhEZTR1NSsyTlNaMXpIRWRkUElabkh2dlhsL3F1MVBQR2Y1TUlteHJpdnhqR2pHdmlCenNCSktlMUIvck9CT2NQd25lOGprSjFNaXZDc1N6OW52M2NoR0V2NGNJUGFSbDVtNW11WEFacU8xODJsNmFIN2ZQelpLaWIyWTFjUU9kNXE4OXpTVWg0ZnM0TGZpa2s2Y0ZDOVFOemdIQnpZaElXdWhTZHYxQlF2clI2cXV2Zmw4dnJ1YzErM3dVL0F1RkpXaTJvcGV6Z21rMFlZZlBYQkZVNGNITEY2OVhEMzd5dzlhQ0JoZDNCeGlBZFY5ZTVoVU04QVJkSC9peWRIMHRWdjZQcmdSc1psdWNVbjZSQjN6KzVaZHh3TklUa255Y2VXOXkrcjNxZGYvMmc1eGhhVmxOak1PT0tmT3NoRVg5Y3ZTZzJnMFFiM0lDaWpMSWwzcmVCRG10WmV2dTNhcjF5ai84L1VpTTcvK3cvSzJZQ1ltOW0yUHphZjE3dnYvcEp4MXg5TzBzWktORkk5UmJkU24wR1pQa3BycW9Gc0czdENPTTBnSXhJa3dBWS9LTytjZ0pneENPR2VMTWgwalQwNm1mZkFKTVZyMnNicGNhZ2RFZHZYczFjd245QW5MbVM5MU9SVXhiL0J6a2VoeVJudGpNZ0loSjd4ZktmWmEyb1RVTnN4WURneFRPZEpzYXF3alNKa3ZFdXd3Qk5yZGlLakdveVo2ZmFmY1BCQTArZW5ocjhyZGJMc3p6cEI4MSs1T1A3MHhUZm11VzlTNVI5cVMwQVJxVlJUNTVYdFo2c0djdVgrWkhWTHY0dkxQc0lPR1lWU0V6cGtYRG1URDV2YlNZdnJoRnl3b1owaC9IM0VCTW5MTno4R2t3d1VSb1pueGZjdSs4ZjV6bXdtUTl5VVI3OFVveHVqbGZyNTYvL3NxSUNacUNCQlVWbjc0ck42ajVLSXcvYno5MmV5bUtUYXdNTVdCR0p6RlZaVmFjdmh1YnVvTXlwUnNsdkdFK3FDZGtFa3g3b1hqb1Z2NnZHMm4xRjVjSmdMVGpsOGV2Z21tYVIwK21lV2c5ZEZUUXczMThOa3VGUWt3ZGcra1pLaXN1Mm4rMWJJU1lEZ1J6ZWxEYUxGL2VaWXh2cDNza01zYkNnMW5PL3dsVUlFcitsT1lYVENkNjJuNjUxc3dMckwzOERiLzg3dkk3R0dOcU5GMU1qcS9QMFdNMGJ2aXU4NEk1VGpRVUUreDlPTzB3anhzZkJLdHg3SjNnQk1iMExCZks1OS84TGlFUmpWWlBlS2RzZG5sVkxKYkordS81ckpxVEJNYnVPOUhsY01HOGdpc2w0VFRocGIyNHNxZWJDZldiZlZlNng2czNUMWMvL2VuZFduc242S05wT0NuYWVCMVRsM2ZGeEpOYTh5N2M1RE1MK0sxNTZRMm5xb1RtaDNHaEs0RzJKdFQ2TTMzSGlrbXBTZkZCbzgrZnZFakxiOTFwMEo1eFdSTy9xN1FwUVorREdIRVREajV3TnUyenNlQW1PTUZuK1Y3ZnZlcldnSWg2emFRelBmTFYySU5IaFRyM1U5R0VOZFVXN3UrVWJQWk9yZGVpVGVtVDB4K2pZWkdHQUhrdFNoQXZwdm04akhsTllsOVRQWThoQ21QcU92QWlMajlTTFZLeWlHZlBIdmVkdWl3K2ZUTDVWaGdYamU2ajFGKzVXRC8rOFE5QktvYVM1cEhFMnFzNCsrdzRUYTduYzN4amloQkF0amRHc3B6Q1FwTmdkaTNjbTgrQ2MxSVpEc2NxZFo5VGo0bDROU0ZXODQ0NFF6QXZhNkE5TUYvMURucVJOdlJGcFEzN0lmejlSNDlXVHgrL0hHYTkxUkh6blBJMHpMdWQvdkhrZVMxVVlpZ1lCalRtQUE5RGh5QnN1TXRtTENkcGR4WmNURkNmTGtsM2gybVlsODBOZzRTc3BKbnJNa0kvaVlrZ1RCVUI3MklhYi9zZWdpSEZKdGVvZFNJeUdjTTZQamhWZDNwZTVVZmdVNnIxNlJTNmpwTTZSSURzZkZkWGszZlgzKzNwVlVlS253VUxac3R1REF5Qk1lZFBPN2owUmRHY04vazVYcjRXZEhnNDVWYW5sZnhNOHpjckxZMkZodWxnMDROOXVXaHBScG40SXFVY3ZvaFhKRzhTRENNc1dreDAxRnFaVHBtdzdldCtSNm05djQ2SU95WjlNM2VBL0t5SktEZkdhUkV6L2hacEVLS1JtQ0RjdXNvZmNwS1BoVGtzZGVTd2dNd0l5ZG9sWC9QYjliNGN2eHZCS1Q0MnBpdVRteWFFc1REWEo4TFludENZNEFZQnQ1ajJyY043WGU2M0J0ZWZNaTRNQ29QeHVYdHBWRjYwYSs4aFFJblh1ekZEUksvS0FCNEtUR0dJdEV3NDRtekpxVlVOdjh6TGV0REd5N1Q2WC8vbWQ2dnYvZWpSNnM5Ky9oZXJ4MCsvaXZuSHVNSVJCd1lyZkw4WDNubW1XdGtYdVJqR0ZkSGZSd0l4d2VUYi9LNzZ5QjBrYkYrWFh2RGtXUUttK1hENXZNaGFHUDkwMnZpRGU1amFrL2E5SSs2YTk4MlVFNEpCanlxTVg1QURDT0NPOGp2QkQ0b0YxOFJvVTBPUDlZcExFK1NuZlBuaXpaVEwwWno1THRWRFBzbFBldmlUaHdOSEFSVldrY044THo5RTZkRXNkd0N3UndYRDNPZm1QL2tuMzdQTVU4V3hWTFdsRzRNYVFzbWhwYk9zVHFuV09kMm4vR1B5WEtyeWprdGZoMGliRWNhYjdFM01aS002TFJHSFpSTnJJMUdJRlRLeXd6R0gyd0hvVHAwVk9EWkpMcWJna2gwdFVsV0pSWXp4aTk5WEQzWDNRUkpma2xwTzJ6WVg1eGJsOFJKQnNRa1lIazQ4SiszRWhEaGhkM1k2TGJxTlFzQjhWZzhmM1czaE9WUkQwSTBXQXVGRVRzNHpMWlNmTlBBd0Q2b3Z0WjJrNUhUV21qZTRwUzFxNjF6SlVNRUNCd004end6OCtVOSsybHF2V3R2TFZPMllRKzkvazROVHhCUER5dUFaV0loY1VyTkpTSkZMekdwYUFLZm1UbThuTzUrbXlMZjNKdE51TzEvSzRkMUgrV1V5TzR0MklqNlNmcVJObXovTzBYS0paSGUvNitja0NnWWJwZ0F6bnNvTmhnNms5YjMyUDJMT0NaeWdXZDJvNU9ra29SRzhNR2lTekI1QjdORzBZbnhneXRRV1VUdUxJZWhuOVM2em5VVjNWdnVXNjVySG5kVFE4WFdCa3NkcHZUMDJBZFl4YWpGKzJtd2tHOUtWUHhUOEJ1a0lGYzd6a1pvNVptK2xXYldQRGxBZ1pRTjVqTGVlVGkrbEtEQVRxK3ZiYXgvcW9uZDRPeVlUZU1ENUtMTlM4Zks3OHc1Z2FFMjZqc0lmR3JySUZPYTFuV2tqY1haS2VXTG9VaUV1MDBTeVRGcTdkQUFNdXl6K2NQV2lRMGsyajlLUWt1aXpLZURYWnRNd2xxanpZblpqU3RPcmZIQU5FMXZNUVRpaXFKdkdoQ0d0dFN1ZnIxOFkxMXJ6TW83VUNIQ0F5NElLQktyTFNkbVNrSmxhZklwOGhlWVFhc2YwaXdqbW4zTEl5TXY4dFg5MjhKTzA3UUkvRWZlNktlUCt2b3FBeFU4R3RzWmdRb3NtMG43azF6R3ZidVc3dkJOdXdwTjN1VlJpQ2NGRDJVME1KLy9kZGhhV1h2cjNndUg3QjhHbHNVVENtZFB5ck01enpjQVZEQXB6dERhSjVhUDF0emRyd1VrYkN6eWwreHdQdzA2bWpITENoWUVtdDl1TFF6NnRiaHBZTjZGeEN3UzdveExFd1kwamZ0eEU0WTgrK3dJajVnUGZYTDZiRDR0cEVvTEV0UGdqRGpMRllNY3dnUWJiNlFTU3cycjhmdnZyWDY4T1AwckxLaHJtcU93WHI1NmwwbmYwOWYzN3N4R3ZkSHNNaWU0cHBxUnVqMW9iMGZiTWpRaVlRL0g1azhmaisvakpUMzhVd1crVlR2RkZZZFREMWE5Lzlhc2tZZjZJTnZWWmp2N2J0eGJWbjFPdlBWLzk1S2MvRHVrTHR3Wnc1UnJ5c0taTFpBUS9DWVl3c29YRmNwTUltYWZaLzhMV3J3S0VOaXQ5Rk1Fb1NTbW5KZVRVaEVkalBKTHZyRjVYTkttTkpESi9tNlMzQkZ3SUlxdTllZFRnK1hXYUhpMU9JLzluM3p5T2dMS3h1L2Y5UnMzcFFneE0vOGszWCtYYlF1d3kyQjNCcmpnODUyUE1pR1BhU0tOM2hleUlTcEgwalpEeW0ycSt6dW91bVdHVWxMMnFVMlNIWmFiK3E2Mjh5TE1zeW9UeFBVOTc0M2duZ1FrVUJPQjNUTXpuZDI0WDlla0pjcDAwV1JPNU9ZbXdMeTlqM0FtVCt4ZjNwbEwvLytmcVRuZnJUTlAxdmkrSzh5U09tcVVhdTd1NjIyMDdqaE1nUmhEa1MzSUtRUTVuSDB5QW5FTVE1Sk0zQXVTRHZlUEF2ZmQyZDFlcFNqT3BnUkpKaVJTbi9IL1BFcmM3V1NyV0l0Znd2czl3ajljOVBOZk1oRUJZbkt6UWdSdTBVZFlwczJTNDhjZmQyOGsvei9lTFRoMVV2dkZXV2t0bVVWWUl0MUdVa2lwMHZpTExiNllJSnd5TW03S1lWcFhGdjEwWEFCbjZXOXU3Q1pzNkwyUXRpa0RyTHNCTjNEb29tL3ZsMFZqcnZmM3FVZXV5c0xBQ0UxV09FazMybWZtWTl5eUxqVHUvdE9SRXBCSVZjMWVuaDcrR2s5UW01dlBCVVMyQlUzeFpwUTQzaGZmcDh5YXZCNk02S2t5cWdFNmtTcTRJYUpGdWtVWHVMNnNYRkNIamU3alR2V2FkL0hBWFdXMWpiV0pJcmt4YkdSTng5YWFNUlZoaFhFS01NdkJqZmE4VkErVUxNaEYxZHoxNWE2N0RzV0Z4Q1I0Z09tVld4TmtBcUFIVndUSThFcmxqQkFlZWNsMEZ6RzlTbEt6by9XaGZjclZvTmVCYW1aWldMb0lMRGlGbVJIVHJoQjJNdWVvTHhlNjl3S3FWa3NKYTVaYStLd2dER3g3UnZvSWlBSDNDc3FVYzQ3ckc1YlNnNGY2THZnb21XUnUwemVWWEEzeVFrbnloMERvQktCanpyQUNCc3dkdTNibmRHbE9ZV1U2dE95c1RyTEtKVjlLOGdsdkszQTZLQ090R1lrMnQvd2dHdENZZS9wNTdXOGllNWpyT0loQmVQR2xoRmhJbXN6M0RFWUNkMmhhM0pjTVBGaVpkQjZhRjVTdzdVNCt3Uy9QT1ptVXN6dVp5VmZkMDBDSi9lS2NPTWJBelRYdnJ6bGExVDgraW44K1R1d0dnZWltc04rQWZ2djg2VFY1dFloUGY2WFV0ajNVUFhRdU10b0FFMzdOY3hLVXd0WVZ5UWl3OHdyaHFVNDRUWGpRMllTQWFzZEpoRUovYlVJdldia3crUnNTWld0MHA0UlJ4TFJlNTlIMEhoa3B3bEFKeEFLK1J5OVExRndKcVY2S2dwWVRkZnYydDVMek1CM2lyR1pRN3NyVjlLeUdkeTlmbDUycExlNk1tMldkRnNuUWRVSno5MWIydmMxY1BSK2paT1gxQWF3dzhhakc3NzZlWStpem1sdXlZT2RQOVdHTlplMTFqdTAzNzZaZTNyY0ZLVnNYYkJOYjdoRXVSb1RwS2ZDaFJsa1V4WDZtVFF0YU56aXhrdGNGdk5pTmM3WElsNTVyUG13UTB3U3VqZVNibUpjS1BVakNFSHJPY3h0emEzR2dkNHVLc1VFRHJXcEhlcUdMc0k2SDh0bDdvc0xuVHJOSU15SUlOUnhWMmQ4akhZZCtweFkzQTN2SEhCRk11UXZEbFpHc3RZaXYxWUhFNU55V1g3TTd0TzVQdnZuK1Fscll2S1ptRS91TFNSZ0syL0xVdnpIUllBVHRyNFVNbFJuY3JUaVljMzd3OW12emQvLzJuSUlJS3d0OEJYVm1FSmJvbXRNN2JHd1hNeHZBMnVJQXlGVWxhN3dBUGgzbWU1Qll1SmlpM3N1U3V0T2pwQUYrbjVSRG02SE94Y2JQTVdETkxTN0twRXlnSjN0TVVGL2Qzb0h0RnRVYUt5NHl1SlgyWnBPdEI2S2lkOUR4QzhhMDl1blFJYVZkdkR3dEVSRmpjUDFZOFJpTVFNUmNCTmc1blNSQVNidWNpazEwV2cvdVBnQlFsWjRGUk5DTlFBQVRQcStFeUxTL1hqaWttRjdIKzl2dHZKMnR2VTNCN2o0ZG40clJ6ZVZOT2RKYVdRaGhPTzRSbzRGaVdQSytrT2NLUEJFMlNaMVBoMGx4ME05bU9EaDYvZnpKNVZuSjRVNC9uVmd0T3hDUGx2QzFyTlpQN2RyRTROUURRMy9IckFQQmdJa2Q1TFNiMEtCNUM1akNhTkk3amZIeHVhRG8waTN3eGVPUm9zcE5YdFY0R1BteVVCM0lVemF4RWI2TEpPam04alVlUFAzWjRUS1ZwSDhPVDU4dFlVSHFsLzVaQTAyWnVLb3p4eTMvdFhtdkdoQlBoVzhneTJXd1NKUGk3Y215V2EwSjMvT0Z0aVp0WlZUR3FDSk1rTjJGYVdJajhwTGxNUzRKTTlmaFpndTFUeEhJY3pyR2Yzd3lJM1greFR4WEZaTFZHemhyU0pRQk9jcGkxY3hxeHppWVFFQUlMUWFZelA5bFkxa3M4QlVJeml4SEhreWZQTXZzM1NtNjluZFZ4VmNPOHZaRkt3Ti9lTE5VQjhRREZSZkpveXNVRUpSZVVlL014Z2JQV0JvMmpzckorUkY5OHh2bG9Palp5TFdBR1Nocm1hYjgwUUZPZFduQXQ5Q2hsaUdoZ1NyUTg5NWgxSkJkR1l6M1Jxc1ZjWlpxUk1GcExPd2ladzIrY0toT2x0cVl3czdSZ2duR1V3L1Rad3pabnBTaVo1bjVPeW9sYVc2cXdrTHBlbkRiL04zdkhvOGo4b0lqYzZ0cnM1UGUvZlRSWnZmK3c2dnlkNXFNbFRjR09CUFdoZmx1MFpPdjBNYUgwbHovOU1VSkZ5QjJNa1ZCZFhjWWVYRjV1SHJlNWV6V21VV2ZvT3lYU3NoWm8rbEZDMU84RTZYR0M0VFRmOHBQa3p1SjJsNUlzWXpEWjFMUjU4alpycCtERTVzTGtkaFVQOSsvZW10d3EzKzdCdlRzUnFUTUNNNUZhRmJUZzNNWFZCTzFwTHFmejhFUkR6OFBYQ091cjFuTytuSnUxallYSncyKytMakg0cUhQNTNrVE11UmJ0WHd1WHpJbktldVlhWC9RYUJTTzloUkN3eDFWVVJXK2lsUVVRNENUaGZaSVNwYjk4RGllN0lhWGpORUdTa04vZWpEYktTWHIyTWlEL0kzaGlPVVVaRHRiMVJkNVVWYkJTa2poRENORnlzSzRSQ09sM2lvWWdBZ3JEZW54dVJQNmE3UkJ1ZlpiZ29saTVQdGJxS3JvQnBJdm1vZ1BDaUZVQnJwQ3dPYTdkZkhJRVJ3U1prQUU0YzcxdTNPZ1FpdmlBUUh6NjVNbms0YU03dVZ4WjJ5bDBwUzZzUkkzNTFPeUNIZFpIM1dtZEVncCsxZTV6Wk1Uem1rQWM4dnVXV2l3OElPa1VaV2c5THJqMU5zVjQvOEg5emlOSWVPUjFrTWE4bnBPc05zSlUwd0ZyYXQ0cVVWYnlyZ2duUXZkQ2k2clc3OVgrNjNGUTYvNWU1eHhzYURHVlJ4UWRQY3k2WW5VOXZGOUw1NkFWV0xRakFtSGF5cnVzMjJvV3VmUVNVVXN5NmRQSEFpcGxGeVN1d092allieHpLMm1vMmZLUGhLa2xZZTVXbHJPemM2Y0paY2FXRFF1VVp3WSsrdXJySVJCZXYzNmQyNlpYZE1JbXlUcWlVVU9yQUVManV4Z2VjSHRyNTlia2x4OGZ4MnpyZzNGUFAyYjFoQzIwTDJtREpQejJSdUJ4QlpjTjhtMExKdmtSb05mK0R5QlBDMkh0WWxYbUs2YldXRi9qc1ZIOEdxR3FaZFJhQmpBNG1vWWxSSVJwalF2SVRzRG9GUVVIQVE3RGRtQllhODVvRytGenlhTWlqMWtlelIvUXZmL21mUVNzVkFDQndSZ0FzMjFTQW15L3paQlV1MXl0NFVYUlJNY3BjZVMyV3l0VzJFRUFadGxxdFZ3cERKMFB2bmF6Z3lsYUp6MnkxQ011Um5RT2tOQUNCK2FBK1JiRHgrU3NpSGdoaXJjRklLNHlzVThTeERQTndWcDk4ODNkeWIvNWIvNzE1RmRab3pMUTF5cDNvc1ZadlVkWkptY1hZVzFwTzBtQ0d6WmNJWFduelB6ODUvOHdlZi9tZWVja0JxRFd6WFJ6QTlnOXRicmdNekNJQmU1V2d0dDRNT1k0K0xabllYYk1LTktqU0h3bXB2bVVSYVBTWVhxd2FjS1pxOUI0YnFTQVZySUV0dFBLRzFuSkx2WG1kZEZOQ3FIdzl0Tm5XZHRIN2UvRjQ4bEJVZGUzQ1JIV0lLdlFZWnRTU0hSbUZYQll6ckwrWnV0ZUZ5OEMrYlREYUYvcnBRYmJtQW9CQzBMcGlUelByeWRrV1VXdHAxT2F0eXY0dmJsR2tCRUFnZHN4MTBKYS9XUEJoSXMwdWdhRUVvMG5DNTBNbFlYSGZad3J0L0J6QW5sMHJZanhyY1VRSHMwQkxSSk9Ib1NGMzRmbFJPbkVxUmhKcXNJSW92UTlPTTl3Tlh1ZmRVVm9qYi83b0hyVjlGY1BnTDVuU29Ed1lnT25MRnR2dER5MFh1K3cyQVplMHhxOUNUSjQrdXhwZTZqbitsSnRZOTZOZGVabXFmMTFoc0ZJbEc0c0VyWjFwRmdLaG5BY0hMZE41di9QVDU2T013TUVkZ2pJazNLNXRFcStkZmVyaklEN2sxK2UvREo1OE5XajRYNGw4MUltZVE3UnltcURic1RETXFVa3J3TUNGQVVvZ2NVSk16Tlc3dlo2N3FjU3ZKdmxCa29DaHlXakJ3MENsaE9Neld3Y1NRWXlFYlhkcnBIQ3gzQzIrVHl6MVZLcmtoNURPSE54Rnl2MjV2bEpYcVZNN0FzbE1NZG50SWFhdzVIb0NwMUZtZVRJQ0FHL3IwV0xVb2pxQjRhd1FDd1B2cnBYaDRLZkJxN3o2djJyTm9hbXlzcG9rVWg1Ry9PMk1LcWp6ekdTS25KMWFFZmN2TnJ4bmpsYS9LTk9EV21BM0JvU1YwMlh3d0JrbXB1bHdtWUErUlFMSzZRZVV6dWZ6cTV1SnJqZXAwRUlKNERlY2t3dm1xRXRCaE5WMUdzYzlkNW41WDBOa0RUaGN6V3NCTUJsd3F4N0tjV1I1OVBLRGcwdXlBMEl0T2pxeW15TTl5VFd2Uzk5SUNNMFJzMDNyL0I1cmdpcVZoNzdlL1dRNzk2RTBoVWhFS01BZzEvM0hzdFI0TlNjWUdZU1hTV2VFa1RjeGRtdXdaMThlVlpYZ1JoVFpqa1hraFd5bk9YeDdiZVBKci81N2ErYTUxSUNPbGM1N2ZrcTZ4SVJ3NFBlSDllYU4zQWNaaUZrcmRIZ2NtVWNkN2RYeW8zNUpvYXVKOW5CWHVNdnlwTkNZc0YrT093ekVZS0NjM2pmV044WU1QSWFtdC91TWNsRmFxMmxsaTFPdjFheitUNE1NTFFnUnE4QXRsNy90N2FYT2c5dmVmTGd3ZTB3cTRJMHA0ZVRaMitmeHlTMU5kazdqQ2srOW5NeGVmazZiS1AyMUIrT3UyN2VqNGhaQm5vQ2kwWXR3VEN0RGsvYlRsa3VoRk54dGRZVGZuTDhycmgxM1JBUjg2Zld5cFU3SlpDeVZwYkQvSGF6M0hZN05QWE9UczNwT2g5QVNkQ251cFJpRk1FUTRQWnhGdTlTMXZ4eWc1K0pwdDlsbFU1cjRqcFFvdmZoTm9RRzNJK0wxcWlhcnpyT3FnUVNSZ1RXd0ZOYXArdm5JWGxpb0d2aGdwbDgzdk0xSUE5bkpGaFliTEFyZk1KS0h3S1BGb3dHMEtiWDNVTTZna2dLTDhldjlzMXhlQUpnM0M3dUt3dWVoU2twbEZXc05sRnFpTFFHaWhyZXBXb0VMb3VPUkwybFBYRHhkQTVlQ3pwaG5abkgrM2hNMnNPdE9wVGVxbm5mMjl6TGsraEVuaUNZNWsxR2daUEliN1FtMXVzcTRTNTUxNXl2MjBPWk0wenFNSWdJVHExOEM3MjdoNDZ5QkJPOG13djZqLytwclBhc2Y4R0dyUUp3WnhrdXN2eFpmK01FcmZaTzEyTjByZzZadFNVWGExUkFEQnBJUVVsTUU4cWxRWmlyRm1BNVUrMjR3dGJQRWNzMEM3YlFkcTdBcytkcHlwank3UHlYNFdLbHo3SXEwakpKMnRWd0llYTFoU2ZnWGp4NUZpRS9TSU9tRmJMS3puTlh6bHE4WGhqSmFNZmxPemw4azZCa1lpNXkyN0p1dEwxWWJZSDNLdnhVMEFsMFU0SngxRUk0NEdFdGdkZVdacjQrcWlUb3lkZ3NtZlZ5ZVd6c1Zya2RPaThDMjVYWGpHVExObUl6cVovZWFRUFR6bjNtS2pUeHFxTytMek05M3pHZjI0UnA5aTJyb1UwaXF5SWVETzA0cGJsK1dGR1R6aFBrYzc5b0xUNGxNSnpFTEJLVmRaOFZNejJoV0daMlM1cFZ3YmRzeW0wcUllNTNlVElVTEpoa2xEajBrWXV4YWROVGZySlBKMGU1U3B1WjBiY2YvcENwdlR6NXkrT1hrMy80L0ZQanEyUWxSZkRxNWVzSXN3Wm9NYi8rNUVNRFpacHprKzdjV3A3OC92dTdrMTk5dmR2eFk5KzI2YTFkV0lWazF1T2p3UG9tdHR5QkhLdHI0VW9wQ1NmdldCZk5CRVZsV0Jtc1ZvVDg0dFhCcU9aZldoWFNicStiMUh5ZjUxVnUxUkR2enEyTnllMmQ2S2N5bWZjSEwxSlNyOEl1SzRadGJROC95UldEMHpsZFdDcEdtRks0MkZscm1uWW9NTkQ4NjlZNjJ6eTRtWW16eVdaQzdtYnRoQWhTdVdHaXdhMU9WcU9uaEZldWlxcUg5ZlhFYTR5KzBubURkM2ZXSncvdjdVUi9YYXR4d0hOU1Y2MHR0ek5CbkpDN2lQbHVadWxmVmtpOWwrSWpyTS9yNHVENHVOa3NMaFkyckt5TERub1pPRlNDeFRQaFFRajVIYU42RURnc0tpNStidzdlNGRZUUFqN3ZQWTloa2NXOGFtaW5URDU5M1h2U0s2NGNGamdzcmU2VDBISU9KUnpOV25NWHRlY3BUei9sTklWTGRuYTJKMGNIcnladlluRDkyL0VHWEJDSVArYmE3NnZSb0VESHdtTHVjY3RIYVhMamxOamQ3ZWd2bmhTZWczZEI5ZGFEV2hnYmozTTNSV1M1WHp3TVV4WHgxUkxxSWh4U3pWK0VFbS9WakMvUEJDeEV1REpROEJuQlRQaHUxSTc4VFZZZ1pTKzNUeW5kK3YzN0l5aEZLSDJWUyt0N2NqN0JQK1BRNEN4ZTVWTXJRUWVLNFhWK1lNeUFZKzdmNGo0WHNJb3UxU0dYUDVoRzZJYkNyOERwaFZ3cnVSTmNGWU81bVZuTlJCU3hzMTNLYmQ0WHpibDVVemlTd0NtVklVeUlkV1dEZEQ5d3ZlRnZ0dkRjUTRNQ1JNT0l0bkxKWUQyTGxkUmNaaDFnWmoxN0ZnUDliaVJJM2hVRWtPSmc4eEhCMU9jdHdiREYwbnBDL3lpNUs2d0YyQUw4U3JZdjdNa0N3MnI0OVVPak5ZNzJvRWNMMjJMeXgwOXlNemMyMDB6TlRjVEkyNjROSjlEOVVvMGZsL1g0ZzhTM2NKREdJK1NzbEdIdjFjOWhldUZlcmRrNm4zc0F0SVdJY3duUGMxMDNFclNJaTRrK0YyNHlDTGFMczdwRXZCQ3R0ZTNPWFJOZXBkaDBMVCsvd0VOb1Bzc1dacGVlbWF6djN1c2drUFBKazcvL1UyVkJUOXN3a2JMVDBkMTBabWt6YXpWQVB2by9UMWllbG9TYVk0ejI2MmdobXRlR0I1NSs5M1VsUDRHY2k2ZFRERVIvZXRqQitmbjJtTHMxSG01TkNtZjhUa2hrdFp3VmNPRm1zejQxV3BNMmNDdkJjQnlvWDNKQ3g1SDE5M1lZMm1LYTlpUnJMMWR2Sm9FQ0U5ck00bG12SyszQzJ0ZUYweDlNZmk2WThMLzhyLy9iWUNoU1hCQ0hnT1VVY1hGWTF6cEpXTE1qV0dtSzdlWlcxbUwwTVJPT28zdkl5angzcTdrSHFsODJ0dDFLcFZaaXVOMHl1eC9lWHB2c0pEeFhLL200S1BWQzU0eFQ1MysxanNjbDNzcnhBYmdmbHhmNHFlVFh6K0ZEVjJXOXcyUGs4bW1QekxWeERzREg5b0I3aks0aTQwR2I5Z3dkb2dXRjd2NGU3aUZCTUpoNkVOaWdMeGdoT2lQZ1BBZzUxemJ2Y2NwMjlNYTFHWnFyRmZEWjhia1lPN0lkaE9qNnZzZEtBMCtJN3ZHQ05ySmtNYTRvZEhLMWZNbWk4b0lvS1I2SG9Nem5YdCtxckk2QWVsM1RBQzJRV0tWY3R3K0hCMk11SW5ldXQ3SjhjMWprNytMamQxbFJkT2xDdExjeWNnRnI3Vk9naHVVSmw1NExXOVR1YWE5T0Rvd1o0NmRJM3I3VzBUUTZEV2NhVmw2UzdtYlhsWkZ2TW9UWHN5Yy9aMGwxVEgwV1BTUGlNdm9kVlJ0UksxaUFVWkd0RW0xM2ZrU0h3bGlxSVJVYkVOZFZYdGlESDZ4ajkyejlMZGNjNjBMeUYxTVA3ck8rRzlORlBGc2I5ZDFPQU1HUFJucC9MdFZHT1ZMd0JxVWhLSTRwZXhIT1FmS0t2R0JRTFltQnVMZXpFRWhsb2RjeGtrWkRZV29uWVNFSkJTMVNGbnVHTit6bGVoNk8xSWhBUDY1QUF4YitseHg0bGhXaC94SHJBMmdkWlRaWnJsczRSTUlxYWhqM21ZZnJ4TEN3R2szeFI0ZlBKb3NZWlYvVFFnaDBJZlBaQWt4VEcyVHZKMEs4UDRCUldnTUFubFdRV2JzZnJyZTFjV3Z5emRkZlRYNzh5ODh0cEZOOEVHWldSRm5BQkRpUU4wTnQ4cGNmZnh6bXNCN213dmFzRk9jVU10TmxqUStRdjdrU2VNdXRnUkQ5VEhoVDVKbkxrb1dZc0RndDkrWm1lSXg1LyszZi9tMWRHbzl5ZCtZblh6M28zTUo3djVsODk2dmZUcDdXMk8xLy96LytOcE1sYXlpdXNUNUFhZWZaaWNydHZ6bWQvTWQvZU5wOERpWi8rRlhtL3EzMjhpUThMUXNHSnNjVkpxQkVrdUFNT0E4enZzL3FWVGxnL1FINDBTT0pHTzZYdTU4UzBIZCtJeGYvaDE5LzFYWHFoWFgrT2hjZ0VMNTczcm05T25uMHc2UEovVHRmVGVZclc1cFo2bFNYQmJrNTVjU1ZjZS84eGNNRUJvRjhrVnN3bHlEODZ0RzlDUDkxM0ZLUWdzSnVLQTZHbWJ1cXRDT3JlQ1ByY0s1Kzk1Rkk2MXl5WTlIaTNheTY5VklZZGhyVFpyakhiRUpBMEdKNUZSNlhPOTVhWDhTa29sQUVoM3dpM1M4SXhkR2hnYjlaaTV6TGZwakZBZzNERFJ5dWI4b0VqVVFMRkIvbGc2WmR4eno4L0pPN2wxRGhxc0Q3ZklidzhiNTF2WDc0bmFYQjZwcjJTUWZrVHhOZnUvbjRQTVg2MTkrekJ0NGpJRjF6Wk85M2pZR3RSWlVEaU0rU3dsZnZFbVM5TlFCeDF0Nm5lRkUwL1BQbkFncFpYZk5oZ2JwL2JDN2U3UDZya3ovLytVOURrYytLL3JjT1d2R3NKVkJFRlY5RVUzZG03clpIYUNRWW9MblZXNmpnVDRYVVFRME5KWHFSSEZ5MmZWWVVZYVZXVnBhN3NodWxlc1lyZXJtMzM2RVlLZSt6b3RCTnBmVlBHQWIwVTBaNjBMa0dJNEJoOHpaRnNwMndBcXM0ekhMQUtQRSs5OUs2Q3o2Z3ZSYWlkWW9PVkxZcit0VWk1ZU5sRWFzRUVyZnZmWllJS2Vzb3ByV2t1Rk9IQWV5UzdQaXMzREJBK2JzMHZjWHNuZUZEUC83bGNZdWRkaVFvc29obzBQaXdqUEFzamF3TEZwZDJvZElJRnZOVnVhRUlhb1JHRXpaYmRiUkRLRFo3bUs1UnNpemV3Nk8zTVZKbitKVW54ZFRWMTF4NUNDR29nV0NPWXd1UXhNNWNwc1A4MEtMTTE0Tk84dGxzRVc3bU55OTNQd2VwQXZPNFdNTkZhMDVjUlVXYWV2WWdNUGQyZ01KV0xvcTJ4bmR2M3g1Z3AxT0I1aXVrcFVVUXI0TmYvWXl5SDdpSEtFdlZBa0RMdUV4YTAvRG5SWVZrVmRzMHJaQVhHczlDWlFvYjNhZFV0MTVqbVUzblBWdnB5TXRuLzVnZ081bDg4MkIyOGkvLzhQM2tuLy91aDRIekVJRHYzOVZKY2lPQldUckpWWW1rMXA0Y2I2a0RuOFB0TnExMXVGR3BBcTllbkV4dWZiZWRDLzFONi81ait6bFZOTndFMFZHbXZSN3lweEVSdkVQS2dDemo5d25yVDEyYlpYZ2k0VEJ3bjlENTVxdXYwcVQ2VTRVZEpsQTJpbHJlNzhpcG5hMWJFZDZ0MWk4aWpoQXZMN09XZWw1WlBKMzg1cnVidWJYN1dXbUttdVZXcldRTjNJbXVWaWQvUEsvdGRQNWg1RExvNE9GRDdxcU05ZWJXR0tWZ2JOZTNpYnZOVWxYM21xTStXV3ZkYmlSd2d0WVQrb1RDTktEQXlyWVhRMEVFU3NOY3p3UGRZU1dnQ3dySGM2UTdyRytDWWE0NWpsWTY3WHMzSGZqUGRROStIZ0Q4NXRwNlltM1pkMG9OZERHVFlKRFpqbWE4ZHkzY0lyL3hNQjdYSG01bjQvUzNQU0FBbUhFRUVwZDh0SG51ZDFHOHFlV1ZNNWhyOURFRmRubzZCYnpCQWJBMi9PWk1UUHNsY0lGUFI1Rnl1STlBMTYxNzFlREs2NGpHUW1malcxSGRxVVlRc1Y5SStEOS84aXFyS21qanNMYks1VDZ1RmdRRDU1aExOMEVrazN1M2JwY2g4RzV5a0xDZkJnaGF2L1pBcldta2tlRlFFbk8wTGlEbDRCZzVYd3J2RmV3VDRyZmI0NkN6aEZxdGdMamIwYW5VR1ZGdlVmM1JwYmExOU5uUkN5MGlYa2tZRStEVzBkbzc4b3o3ckVpZEVvbFVJOWFZVmI4bjJhcmFQUkE0MFVuTXpuK2ZIZVVCSlBtbyt6b1B4Mm1nRzlYQURmZWwxNEh6Z0d4NUpMZHFMb1laTEthRFJNK1BhdXVhZTdRUW9henQ3aGJLWDB4dzVQNVZBYzRONlBiL3VWVnVEQVJvYlB6ZE4xY25TMGlwQ1phY21YVkN4OHhrbzBWWjZITUVrVU5HSmN0SmdOT255ekZiNmhwSFNZZzBDYUJ4WTFKVUxXZEp0MHBDVlA2SVBDRHdMb0lSVVVHRUZ1NnF4V2FkVVYwU0luZnkyYzhxVDZHTi9zVWYvakQ1aDMvNHFjMnZ4T2h0TlZZUkg2WjY4eVlyTEV4aE9RYmtvaTdGcUlwR3VaM3lyL1Nma29GbnM3Z2EzQm9oN3NVS2MzLy91Kzlxa1Z4KzBkdjlrV1QzT3BQNkt1YlRQZkxPMW8zSnI3KzlQZm5YLyt5cndPNkVlWUNwVnJpZjcyOU1uajJzeml1TmVuZTN0ajhKZ2FNVXlwMjcxWmxsa1Z4ZHZKbGtoSVR2bE5aUUJybFlsTWpONTkyN0NldUUreGNRVlMyWWZVM3oxQmswb2hwV2c0MkdiV1dCUmZPcldVS0tXZlZqdjVVVkpaQWk0dlhnd2IwMGNVMEJ3MHJrMnpsS1RiWTVuR3V1WExCYUhBNGh4THI2emZlM3NueHlSOE5HMmE3Y2w1dTVkZnV2ZjRrcEZOTTZFYWl5cCtDSDdkWmJBaktJUWpSTHkrcWQzQWtGdGtCeEZRLzJOUFlyWlNXTFF2UXVKVWdvTUo0b09oWlNNcXM3OWRrVy9MUjlGZFE1SzFJOFgvMmxzd3RIaVU1MDB6SjMzYVJIek1DNjZ1dkRDckZYbUlZUTRnSVNTQmpwK3VFNytDWTJHcC9qU3JKQWZPNnZyYXplYnIwSjBRUndzK2VpeFZMUld0WW1zb2d2aG9EcXZzYm9mdWpRT05RQWZxN01pR0laeGYwQWF5VkgzV041ZFdaeXB3WURoQlhBWFprT1FVR3c0NEdUYUE4b1QzRVRSQ3lYMngxWUVjdjN1WlhKMTQ4Mko4OWZQSWwzRjJ0VWNIL3k0bTNCbkx5Y1FnQlp4RHU5dmpMWnEvMHl6Tk5KV1RycnlwbDBWbVlYR2RkU0NtUWVqSktSWVo4aStwQkh3R016SndHeE83dWQ4bE5sakM0VXg3bW01STBnd0l2a0RCNW0yVnZmS2QvWDlETkRaSlRoMWRWeXBJc2tyTVppZE04dU9abGptZ0hHYUpHYlJacWVQMzgyWE1IVFhKS0RoTVhTVlJoVkZ4VGVGcmJVaTkwMzEwUDlqL05yUnh2ajhiNEMzanA2TmdBYjh6bEEvVTZ0ZTA5ekg5OW5IWjJGcSt6bUtoQTZyS3NiUFE5d01qZUd3TlB5K0ZNNVI2SmZWMjJNQlpOcUVPZ3hMRUJZeG13bUkwRktnMzdLRk9VN0swa1lsZThSeHRCVmJSU1FWYW5LejcvODJIaHpTMklpZ3VOemRWU2JtY05MNFIzS1lqUWxOTTdWTm0zZ0dCRUk1dFplV1VIcVpacFhrenlWN2xod3U4WGYzSHpmcGlqcWxqa2ZFYmNXTko2b3pFeHVzK09sUmwxSTJrM0ZPVUxoT3FUVXg3aUhJSWhTYWF6dGNJbXZ2NnFvUExENC9wM0Z5WU03bmMzMzZzMVVXMGVZRCs1c0plamJ4SGxOQnhQR0N3bnAvdDFjdlpwOCszQnI4aVF3L2lLWGNqZVhjVFpoOHUzM0NaR3U5Ync4cHR1N2E1TnZ2OWtjeVp6cnVVekQvVzFOblZQWWlMUHZrMGF0WFJOSXdJallsU2licFhOU01oKzhhTFg3SFpRd0dqc25yQkkrTUlvQlhBdUdwRGh5azdrelN5V05yb2RMam96cUpxbUZDL2RNTWZsWkpUWFNEZjY3Zi9PSG9vbExDZmJjeDRTaExHdnUrWjF3dXAzZDMwZDdVN3lQQmZVNjNFSTZ4RnpsT29UbGJ0bnlDSHJtSXMwZlBlaG9hbjlnbUFTUzVGQ0M0eklwd0dwR3p3UWJBTHVGRDFSdkNqRVYxeDBXa3NnYVREb09HKzN3MUpFTGhoTlltcjN2dTMwNzY4MytKV2dTSHJNczZhNU5LRkxTMXdLSm9CZ1drbnYxZVovMUlDVEdJNm5Uc2cwR0gra3MwYkIwRGdKTDl4ODdNYjdmZHdVWnFKYUxGRFlsTERyb1ZIQlJUcmlWclBHZVJyc2tjTXA4WlV6YXhHZ21LYWxadnR1YlNzYkFLNVR4UWdxQTRTRFAwT0hHaWROZ2dUeUtyajJiSldhVW9wS2ZDeER0RmNReDZ6dmJ1NU9kMjFXcXRNNnFLdkQyT0w2K1ZUczluVVpOdVkrRWJ4TXVRVnhxMGVyQU9Bbk1tVkpLenVQZElXQlRycU1rcTFsWkhuczRWeE5OWFhaSFlucDBLRTNvc3ZsK3loalFnR0doL2U1L2pVeDZRNVkwVElMazd1SC8rS3hES0dMRW5YelhRTHczUlhtMkpGeHk5UnJNWEJPVnEzTVJVYWdmMUhwbE05TlJHUEpUaktMZkVLRXhJakpOUXR2Y042LzNFbHBGNjRTbEUxU3dwbHRKN0lPTGtrSS90YUJsR24vYS96RGFzMnJYZXBxMmRGcVBBMGVkdml3bnh0SHljbXYwT0w5WkdjOWltOHg5dUVvZzFsWXpxNnMyRzFrVlhEWUM3cnlOb0tWejBzSTBoa3BMSXdSS0g3MGI0TjZvL3lzNk5CdFErMzB0amVmS28zb25tcFgwRnFrNFhkU2dyc3pjd3VQNlRRK1h0Y1hUaWVIb1V4WmxWTDhjWm5KVVZOQTE1RjJkRmZFYTNTc3lXVVhnNG9NMkpoOGZzU1VCRElObTQ2ZlA4c2ZEVXFLZjVwZzdUR05tK3QrNVZRdVpzelk5Yk9qZTd1cms3dWFkeWIyU01PWElySmYxL3VqK2JrRDNxNkk3QWhzeHhPZU9YU3FxZGJ2UEx2M0wzNHcrMlFmdlRuTDN0ck5ZeW1YSnJQcnc0ZlhraCsvbXducXEyMHk2dzMwQTR2REFQTmNSOFZ4ZTI0ekIyOWVJUFM2TlZHTnl6RXd3dHlZei9hemtOcTg3SFRuWGFUTUJwSy9SYXVQOEhHNTEwRjZ0dGl4M2IrOE9GdzFBL3k1bEExcVlMY3RjTGdlaWxqeThWQ1J2T1RkMTgxLzhhc0FNSDhxTFd3NWlBT2dmcFN4dzk4Q0tHdU5oQXZLcVp5QXNBUUJrUHZsWTg3bTEyK1h2ZEs1QTZ5ajFRM2kvUU9vQWM0ZjFFalkyWCtzajVVSW56V0UyT2lYRUFzT0c4T0VPRm00ZHdtamdvY21WZ3dUelRFSnN2TlY4NFl2S3JFU2JyN0l1V2NMR01QRFU5a3RYVDFZNGZHZTRmVmpJSGtmLzF5NE1hd3RER3hPK1lpMHBrWUVWYXRjdDZneFFueXNLUFpmUUxqdW1xL1RaMXMvWUtRV0tiTGIzbkNqa2tPUDAzamhRUTJlRHRUeWdkeFgrV3hjWUVnV0EvdWZpejlVTWlJMnNLMUNKZkt6VE1OL256OHZmeW9BUVBlYldpK3JMaXlURUpXeHV4SmZHWWM4WCs5a3RLLzJxb0lTT0h4UzNCRmVBdlZwWG5zYkhjaWtKYTlVTWFOdThtMDV6VThaV0FHNDJoUkcyS1FuOEpPQ2VWYy9DZ09scUlzQW9ZckFRYkZKWkZodkk2Nnc0U2FlYWdTN211dS9rN1h6S21QZ1FSUEVoWStmN0s5WWF1NndSZGI4NW9kRnA3NlpjS3dOb3dyU3NoRkxoZjhySGgwMFVzUGFpcnFINnZXOTFndXhXK1ZEUG56N0p4U3ZmSXA3ZGpPR0JhMGVWZHdDbURSYVhTdFowY09sQlFLclNsenQzZG9iMjJ3dlFVNlM1RXo1RWU1MUVoUUEyR0JuY0NZajhiWmpKdmR3QndQbkFwQkp3Q0FJekRwYzB0MVdwamNTMlVjK1VnRnpLNUczSXcrVjhWdE5BM25QVTIwYk8xMmovdXc2MDZJVFpGb2gvTEdQL2ZlMmNGeUtPb2NtVE5EZnFPQkRQOFJLRzFEK3YxeExCUTV2SXZUcElreTB1Wm1FV0hVTzhpQkJoaU9yTWQzK042NEN0MTRSc2swZG90dlcxSHIzYmVCSzI1UXQ5T0tpZGNnTG9uQWs4aEdHYUxSTWNBV2hCREtTMER0dFp0anBsbU1OY1F2ZldyWmxBNjI4R1RqUXN1ZHdiWlQwRW0xNzNad0huZ0hnSmswRDlrV1hkT0JHTlBKbFJyZUM1MTA0SDJKN2lTQmlNUjJ1TGdiWTFGSXg0NXJOcVRpdkt4a3hyUVFFT01FQVRROXEwdHRNdzlQUytyQmdhVmRDQVNYQVl4akV0NzhxZGJhMUYveTRTU3ZMZFhHOFU5QTRRTmgwZmt6dENUc25Rd0VUS3pZSWZLZ01SRUpwaXFPRTJPOU5vS21hZHBqODRUekczdGJIb2dXWisyc2ZJMUNjUVJvMGdvRGxyM1JhTVZqWE56d1p6NGF5QkNMWldOSkxFV0Qwand0ZUhyMEZ6K3d6djhtTmYvVU1qYUladzh1QXBlSDlBSGYwOUdEckxneUNYRTRkdVBkQUQxM0FJdjZBQmRHenRXVUVMY3NmNm5IS2NMalVzMFlPaXB3STN1M2Myc29MblJpNGVpeEhzb281MW11U3FPU1hlazR3Tlczb3p4c0xLY3Y0aTRZbldkWjdWckpKbGVsUFp6QkNLbDFuemQzUDVNeXppQlhXZkN5VnVDdjY4ZVBGMDh1THAwOVlwb1pad1kybkM4OHh6WjJkbnpOMWFaUUoyemZJSU15d0VPRUFVTXZFbFRMTjhKYzhxM05hdXlQeEhsNVgyVm52b2NYSlM2MkZjMXBrcjZJQU5rTkNJZG5Zdjg3Qk9jM0FNd2dVdzVxVGt0d21LdzN6VlhWaFVCQ0FqK3pUM1N0YTVGakhjUkl5OGxKQlFGc0U5Y3d3NGh1WDNJeGE1SkVmbFZwamc3WjNiZ3lqR2tkVU5WSzZWbWpZUEJFYkR5N0Y2bDVDOGlERStuQjExdlU1OHpjcmJxb3hpb3lpR283Y1hzbERnSTNGQzk3UUpiVEExMklicFlZVVcrTk1PS1BqUWdqMXRvWC84NmFjMHhNY3NrSytITUhtU3NQM3BwOGVUQnpHU3hEYW02VnhVOStyVlh1NkpIS29XWGxaMW13c1hzVWxNcDVuR2hVbi84dXJIc29LZlJGamxwdlNlWWxITWdHZ3g0SHFwR2FPSllPVTJRNmkyd0RiQVFvOS9NY3M0T0RRbE1iQzhQazlRcm1kSnprYTRlOVZiT3VKTTZQbitnMXU1WllzSjExd0lwVXluMm5rRW5oYnhrU2VsZElZUTFrenZWYTQ1QWM2VlU1RXZYSThoYUZ3cElQcCtjZUhYQWFvaFkyc0FBRUFBU1VSQlZLNnR2K3NRbWFTNkpGc0VOQ0pEN1J2QzV1ckJOTTltd2hEVG5sSWJLSVJ4ZU1INy9XRnRDeENvK3h3V2R1UFZnTkh4VkpTTjhwK1pmcGRjQ09OajNUbEFveDFxMzVUOFJQVFJEbzYwajlJUDRDTUU0R0hWQVlxQWxYMmQ1NksrT2F5UEUzQTcycE0rSTR6TzlWZU8wa3RkVWNUWVdralJFUDNMV2lFMG13TXJaR1JidHdlRXl0Z0h4TnNEM3NUeUhpRjUxNHV1UmdwRTd3Mmg5c1Z5R2gvKzhqOEN5Rm9SY2g1RDJMVm05dGp2OXR6dkdIZ0l2UDUyZldTcitIcFlYRDBUekVxQWxBSXRaUDEweWJFZnZrOEkrZHcwSnlyQjFqems4emtmUVBUdFZYanBRZ29OdjZrelpMa3dPSFJUSUxCVW90eklndUY2d1k1RXpGbDNSMkhKcytHb0d3a3BRVFRGK1IrTzMwMXVyVVZuS2JGczU4bVRwejltTkFRL0ZOZ1FVTlAxUW83a3NNcWFaNHNaRFJTVmI0OVZuQ2dncDVTNHNqbzVmSzRjQzZhbThIMG92OWFmZkZuYnZSVitsU2VURXRiOTlpd0w3cXE5VXQ3V0JBZW1TWWx6Zi9IelluUmhENEhzYi9PMkhNRjNyU3ptWkVpYmxCNU5XcWJRU0YvZitTNVhLVDg0Z1hQLy92M0o4em1NL3FURkVmR29KVVlEUGRXYXRvdjdQbXZoZGdMdU9NdEs2eFU1SndRWDRucnR6RFJhc21qTjdhSkpHcXhwZ3NmWFZramQ3bVRhZG1weUFtdnpkcDBGWWpxMVJHdTVsYmR2M1J2WEFNSWlhTUNkbXJFQllDWUU0RmZUM2M1OU0vNFdZVDZ6OGlBdDgvejV5KzQ3M3diVk1TQnRKTG9wb1BEamozL0pWZFJWOGFSeW8wZU4zR2treHdsV0dleFRsNkFQUjFBUllBdm91QzJ1MWxsV3pzK1BmLzZpVVJGcjVTV1o3WVFWNGhmUllVVXg3eEdRcUNBQ0JLVEN4K0FGZ0ZsV0R4UDdacEd3TllSeW9hWXRyR2QzZTNMcjE5KzA1a1hPL3ZqL3RHa3hWWkcrYVUxWklmbjgvd01KcmpNeGRGRWU3V09BeVRvM0hIMHBrQ1pBV0Zpek14c1JkRUIyNjhzNk8ydXRoWTFYeThPaGpSRWV4b092UldHTkNZR2thQ0xHeTh1cUVXS2txMmhpR1hHbVczUTBzTmVFdHdxQzBSMDA3QUU5Z01OMHhNeFU3bTh5U0lCaUtweTA3WEUvQ09CcEdjdkdKNnRjYjI5QXJvenNUd203aTNMTXJQVVlXb1I3YzYyaTJaaUtSV1pOcmVHMVVMQkhjbm1tUXNFOUUvNHhCU0V1RFFmejYxTExHOERNRkFWc1NTc2dmOE9wS0ZtbFZiUzlOSkRRaFF5cjNMYm1hWjh1c3BCSDdWOHp0bWVFa2ZXeW4zNGY3bERYSFluTlEvT3prcVp1SU92RFo5RUZDM0NNUHlGMkxlZ0lQYUM1MXdmK21TTHNVdEZYYTluM2lGTzhNWUlGclpVY3FJK1ZZTDE4c2RkNFMvZEkwS3pIZndRd1JlMjA4ZTI4SFFycWxUTUt3U2xycmUzZ2syZ3hYaGpkWmVObCtZN29lai9ZWmtTSDdWMkJINTB2Q0NBUXpVeTl5R2JDVCswNUwyUUVoNklqMVJVS21EWHZROStBYzNONldUcUVRTk44bnRQN0ZBL1hHZzdJT2pLdi9ZSEpkZTF3U3MwWUw4SllrOUpkMzVxbCt0Rmt2QXYvSmpPczdVVUFuNHg1OUxKWUhxR2NMR3NqMTNJTzgydmhNUk5CQVJsRm9kNGtVR1N0MjRUblQ1OU5udnpTNFJFdmEyUVI3dEUzSTN4Sm9vbXBiaWhEVlVMblhtQXA3YllUU0RvOWVMVEp0bEZNeUJPZ1pRczFUb3J0Q2g4elVYY1RadnRoTlljeCtuSmcvdXhZbEhxWlp4MndISUJ1YTlVR09wYUxwbjVYUkFKMnBTTUFRSFErQmh2Um5TUTgzSUFtK0ZCZUZORDdxREVSZWpUMnprNFJxc3hmK1dhSHZVYVFuV1ZGc1FLN1RCYktVY1NyN1VtTjhnTFN4MUh1a2dzVENEQTFES0pFNE5telorTVllQ2NLQWJWbDc4R2pNQTZOU0h1UE5JZm1PL0NUaERRQktyTEtvcmlNSWR6UE9ZSkxtYnM3V1k3M3dvQ1d1LzY3L1ovTCtuNFRRZDJLUUFQUEs4bHBleUpzVmt4NFhWWlRNanVHdEluVjEyWDFFaklmK3M1Um11c2tESWZaYnd4M0F1cEhjQ1RDWWlrcVdWb3BzUkxqc2dpWisxeURnZFUwbnBhdi9lcTUvdzFYSjBITE5Xa0JHbXNXU25QSFlFdWx2eEFhWjVYZmNHOEE4QVFpaTIxNUNmRzJadjBRR2s3WWdTY0NqKzAvNHBVTVRGQVFiZ0Q1eXpMTjVaQzlqTW4wM2hyZE1yckhnOXpjdGRVc3dhNk5xYmdPTUZMRnZZc3BSMnZvNlBPTGpuQ25QSFhFSmRSVEJZUEpXT0dZZHpIYXRPYUxGWDg3dXNvK0RJSFlITlJoTGk2R1NhVjBQdWE2RXNaNnJWa0RRUkUzc1hZWTBvTndJS2pjai9Dekh0MndOUW4vNlR2NEJBMTRtSy92V1NzY1MyQURpMWtNWHZjKzVUcG9oc0Izb1Q1RDZCSWFQak9pamIxMUpYRFIyT3pMM3VzM3BjeWtIQk53TUZSNDNvaWk5WG5XMU90M2V5bXJJb1VKeXZlNWtDc3BXZTZ4Y1NoaWxuVStUcmVKN28rTzM1VFQ5L1Ywdi9xdTE2ZGxRTTBsUzkzdjlsVlpqSk9yRmtvZitwQUJNOU4zMWZiQzdWaFZvb09iNFdCcklvZE5kem1aY2RGYXcwTHhqRjd6V21jL2I0L3YzYm1YNVpkeFFDQzFoM01wdUpzQ1l0R0VKbjVYUmVKWjR2dFppTW5yRVRqakJrdXRZZDNiQXdwMmpoYll5ZVVTUnJaMjhxS21nSnFrclVEMC9mZE52THlyQ0grOUtuZXVvVll5a1Axb2FoRFF0Sm84bnpYOGkwa29DNWV4RHErNkdYRTVHWGEyUmZ1UWNKTDFlcFpHbFRBcURXRWprRmtmckpXVi9PeE9YUkdwRktGd1pod3RBL1Q5K2NjZjI0UzNhWUJDc0xlMmN4dnFySmhXU0p5VWNSMytsWUJSa3dlc2Z2N2lSWDV4RVpjMkhDSENucnJSZERQYlpOMFNXVnFMcFZvNDVraXRwTmJLdEs4NlArYjZTZTdYUm9MeVBBdkh3YW9LcVAvZHYvdjNnN0dGZGUvVVgrbVhuMStNUlNTa0VLMzhHSXlGZUFrcTd2Tm9IMklua1dXRWhmRGlwWmFad0kySSszczVsK0JtSFE2VXVkQXdRR0dIQmJndURGSEU3S1NBd2V1d3JyNDJtQjJtdzEwL1BxN1BkL1Y1MFUrRW1oQXBNck9UUU5VK1JLUUc4ZGtETHJqREMydzZwcHZ0UGhnY0R1S1lxL1JibDBhc01WajNVTGk2SU5VRHB0VWVJSFptT2h4aHZwRDVhcHBZNk54OERJcTVUa2g4bG8zZlBVWlNMc3ZTeEdQT2k0anhJbVppR2VwVlA5cmRCQzNvb2I1V292SG1kaEhRMWxzQ3JncUM0UklST0gzM2MxMFdCREhRR1B5TjhGUGkwU0NMbENtTFNUUWVZeEJXWjVaMjJlcXMyeEY5YTgzUjlLZ3R6UlVSRUdFQnlac3pjclJPS0JKeWF2UDY0bGdEWHhvRjBZWnZUYjdzWFo4WTlPRnZnb0M3ZHRWWUtDMS8yM3VQZi9yOGwrOE5CbTk5dk83aGM0bThsb2JGRnE4M0Jneis4YVJlYzMyR1c4Z05rdXNvaXMzQzBMWGo3dG1keWFOdkhtYnQ3S2RnYXd3UWJxZkw3NGlNSnB3SVBYc3hPeCtOM3QzdGM2L0czbGs3dGJjWW42TEd0RHFOY0MybDNDeEhaNFkyc0xCNHhIdmNPa2V1dmFzUG03VjlGQitMZHF1VHRiNWdoUnZsZWwzRkkyOUxIRjBOM3RBNDRUSUJOL041dGhTSjBuTmExNVhtdFJVV0tUcXFUSXRSNGRDUTNaVHpTZnRQdVZPTXlvbXllSklhVmNNVUZFcGlKWlBxSWxFOTZ2djM4THpnbSs0Lzl6QlErODNiL1FUUlVhRGI3UWlHSm1VVkpPMnJkYnE0cUx0bUdNNTVvVzJONWRybUlqRnBwbHk4NVhvZTlkRitPZ21qcE15WFlUQXdDNVpQZTVrZytLSjlXckRON2QxaC9qc3BaN0VrTXd4SHk2OW1YYTEwei8waVJGclR2SzRPNldNSmtUZEVwaHcra0JCNzlmSnRrNnlYMXUzN2phVkY2aDhOTERkSWg0bkRla0p4TXlTTklqWUNsN1hoTTZReWF3UitjeWVyNlZQVzFqaGxwVG04RGhNNFNHREJ5MmdsQmIvcDRZRHM1cDJsR1R2MC9xZkovL1h2L203MHlQb3YvOVYvMVhmZXR6R0t3bVh4bHBFL2lKU3dDQU5EdERHM2NoZUYzQ3pCd1RCUmcvRWdma0F6QW5ONEpMZHJNMWQwTTBKam12ZG1naUpyemZjU0dKTDk1aGNLT0NoVEdZeGZMV1Z6eHZEOCs4UGpsY245TnRJOFdSQUtsUUcvdXJ4eUNWbVhtK0dBN3c4N0tCY1cxVDRnVU13NnJMNnVZWllVZ3cwelBwWUVlV0FPanBOZktCQkFBRG44a2pSYnl0MkFuelRVeHRaNDAvaEEzdGxjd1lVRS9telJPanh4V2hlTStRVE00a1ZBY1VvQzlnRkQ4UmthSEhhbGhrMjVDTUVFQTdTdnJBWUNYNEl4SEdTQmhkc1l3QkFqd3RUM0ZmRzZCdVptMmQzZzlqWS9XTmFvMFV2QldrTUpxY2RGZGgzK1NpR2g2ZE1DT3l4c2k0QkJNVGo4WkNxWTREWnNoLzh2Sm1WTkNLVnJRWVMrczVlR0FpQ2l2RDYxc2tXdHArMnIvWDF0YlJIMDBtcmN3K3VZandVM3ZlN1U4cksyRklFNlhBS3RyNVRDTUZVa0RBRnI1ZWRsTFp0RTR3V01XSU9pOENMNFpiOE1RY1FBV1U5eERjdXFqVmpLZTVJN1IwbFNaSkpJTlZha1lBNXpLVGUyZDNyUFdFUkJwd0dJR3hra09wSVNkTGZLM1pMdk4rb2FqYXNmaGVvRUZ3TkJSajNvQng4QzErVWk2b3NGaXRrc3N2aWlOQ21KdllyNktSNDQ0YXVDUS9abHU0d0VkWjJ0WURUWSt1VFd2My9aTlhPQlY3TVVQMVhxZFRNY0ZuMVlxNDhKN3prM1pWTFRLQTRtT00xdkhZZG90aVVHK2VUaWVZdVNWRVhVaU50R2U2OUZXbHdwR2JST2w2U3p4TFk3WmJhcWozTk1sWE1CejVLNnRMb0s4YVdhcU5INDhXM2ZyNzdwQzg1ekpVSVU0K3p2TjRtMEkyMXlveTRHQy9OTlBNdm1iZmpXcDQ1N0ltU2VQWFd3YXRHby9PZkhQejZlZlAzdzY4bWZmL3hUa3hGWnlQek15bm4zcm5LUm1QcEdMdVZxMFVsUmh2T1NJamZxeitNendydUVIa3VBTmZhMmNMbE9BMXcxN1dqMFVEOUY1T0ZLbXR2OWg3LzdqNVBIUHoyZWZQUHQ5M1hIZko1d0srM2l3MVJUSTFUWE1TUDFWYXlzNndqVDFaY3lBNHhEV0dFSzgrWU82TmwwdDNLWnpaaDFzMXF0aTA5dGRudXdWdkpsYWlRaGtQdVR1eUZ3UVNGc2JqM3FPMWxmRVlRam8yZ2wrL0MydmVNK0lFNWpVWlV3RWpjVFdDdGhCdHo2azVpZWErQjlFWnZGQkFDTGtLdmgyZEh3eGp4Q3h6MXpEMWpUQ3dtZXEvQWRhK1g2bzE5WWhEK09vSSs0MTZvQXdBQXd1V241Q3pDZjFaYlF6QkpldXNpVmpDNWdsamNENExXOVpzSGVZRG1scU9CRVhJUlJCOXE4WUJoQVdVbkFyQXNaOTQ0cWt3ODNEbGlOK1REOE5GRlkxY1VVUTZQcDI1VHVuYUljZ21VcUNFVFpZQ0NISGFoNitsbG1mdXVXQUZPb1B2WWp4aVAwZW9vbXAvc0lhK1M2QWV0SDdsUHpubUpsYlVLUGE4R0ZWd2h4UWg0Zzd2VWhaREIwK3p2TjE1cGlXbHdyZ25INm1DcHdkR0JOcDBLU3N2QjNNTUZ1alNzTE9oQjBMR3dMT0JLbzh4TG1BOXA0REtvMEhKa0dLdGk1dlpVUS9qUndwWlhvY0h3Mm9iMGRWaldTUFBFb3JMRGJpeVIvS0VyUGJSVDVSRGVnRjdtRVdpeUJDVUxDZTJaQlY2WlZXb0tUaUw3LzdvZGNPR3RzbURNMVFIZzJCSjBVRUFvSUprakR1ZmZBZmJzMm9UdzZpS1RZV05DRTZoUXErRnk5Yloxb3QvQmYzaytYM2R1SHlVYWJ6Vit2TW9vTjNSSmtKMkdNY3l4VHlyakF6M3pqbVhQWWdNWjR3dGdpUlFmaFZ5cTRSY0hHSVErdW11bE5RamFVQnQyWDJ3QVcxWHdkQ2VPQlFVU2FwZWxhZUhMU0pqZGcrSTQ2SXd5OXRGTEVMVUdHMFVRc2FCaXYzM3Y0MWJqWCsxeEZKckg4RGFVQXR0ZkJvb0Q5dlZjZCtKQlY0M3BNNEZ1N0pjclZYRkEyTGF6Tk5lRTN3dDZZMUhWZ1BmNldUWTBJbzZFMllTMndmOXBpWlNkQUYzQ3MyeUZyUjVJcWkwWEdPNUR6TE1FWnQyU0tmZ3F2Mml1NTg5dDJLNnN6LzMyN3JHdjluZ0NVUjBmaE5Xa1RwcXJyRUppRXpiVVF1VDVHblh2R2ZRWFNqOEVrYk9UbVhNWjB4akVFZVJwR09aQTJ6UEppSEVvNmNuVktZK2hEZ3pGWVIweDZqZlFBQWV0aEFEMzFtRm9tOXN1OW1lN2pNMzFQZ2kyTEFNRUkzWXRrc281bEppTXNhU1dFNFVpMjdEb3NCd0tNU3o5S0xMb25LNVUyRi8wai9DN0MxZ2dWVWNrbHpRc0hZMlBBYVRSSGp5YUpqYkJMbHVKU1VWQjkxUnp1UUVxSjVpbkhHajNrR3hjclJaZUJxeU9GdHlrTmxsWDNrbHpNN2NyL2I0cXdNY2VuQ1gwVElKSjNBK3d4U1Bmd0dNR2oxbEhhQXRlWGUwK3dHeGNoeGFvSnF1eHoveG1UY2t5YkExcWI0V0M2a2VLUU1ISTZNcUhpaDBBYXdySnJqdEtTR05FYWpkTjVlbzl3OGI0SFllVGhleGpjWDZ4dzJKTFhyaCtDQllRY0FlcFRCQzVZdzNWR3BIQzRtZEZObHV1SElJSFYrbit4TXFYM2pEWHNkY0wrdzFIM2FaL3g2N0RPWWxmN1phMTRSaXpYdzVTQkpXTTEyeXZCaGVuSXVtWThyUkJmdFlJYVFaVUVnNWZDSmRIejAyZmFIZXZvVWd1YnJvbmVXY0hTbXZBajRGL1FhalFBYUU0Q0tTeDJscjREYlFiTzJiaXQvU2cxS3VDbFdhT0RtZEdIaWhmVzMrdDY0cWxRdVJWL2pRaHZjTkZNQ3E0RlNYWTAzcUVZNHdsRms4OHo1d0NKV2xhTWRoUDFjSjh0dldCdnI5VDdPR0lJMFJhRlpCNGdmUVN1QThQTHZhZEowTFI1RzBnS0gxUXFvWi9XWnVhZ2hiY0ppeVU2cWgvanUxb3dwaVNoQVB4OVZlTGJpTTQzQmtjdW9WejVOL05GT1BUMVhzdU5jM0RvaTlkN1k5T1ZiL3psTDVQSjczNzliUkhDVHBKKy9OTW9nVkZReldLVHVTN2FxZFh5UmNlVVN3NWNMZHkrSE1NTTRpLzZzUkhEcnZkNVJaY0R2Ty8zL1FCOUpRRi8rdW1YeWErKy9TWnJKd0tOUVgvOHk0OGxyVFAzcDVFbERDNFpid3JZSTZ3eXNpT2NJVXhqQWlEeXRERmNacmplK0dsNXA0VndJTGlDTm9KN3NGRFNLSzNpWkJrdThFWWRJQVFiMXJOYWJtUjVIRWE0TnJFZG16SmE2NDNBQ0FjUnZMbGNwTTlaY0hyQ243ZWVIczR5VktPRmVVWlVjb1NZWTRpdWNSRlRES1pxWHAvYnR6aEhpbTJKcEFtMy9zRXZWUXNzY2tPenpyZ0NFaTBkUXlZUlYvTGpFSmF0MVV6RVk3OWhrVkZUWTBsUTJiaVVtb2FFMXVaR0IxOThUdk5yUTd5MFVPZUZOTDFETkNtN3l4UWd0NFJiQStpVzNNbWkrRkJ2SnRpbUxIWUY5QTdyYUpYNlRneFdEaGpyNjdKeGFoaTRXaDRhaE16VXpWdEgxOCs5UDF2U291OWxIdlUzZ0p4bHQ1SG9UYUFKQlZJU1dTZUpzK2locTVlbEw3WEFQREN5eUNBQmFFMTZhczFrMWw5YlZ6RmpyamZoaGZ0bDZoTXNoTklRL0QxN1hMdU9YdWR1a21NTUZMUWhoY0c2VVh3S2dHRk9ON0lhN08xSmVVdG5IVks3bHRYTjVhZkUrdXI0bVZWM214S1k2WG9pK1N5dHRSS3psOExsREk4UXQ3YjM3OTVMa1dTOU5LZmRuZDFvc1U0UDBrVFNiOFlsVllXVnUxc1RnOHYyZGpuZU1QYUZQQlo0MXVncUV2U2lsVEdCaW5ibXVyZTZVa3FQZCtERUhkZHl1aFZzVHNCdDdVYkoySGxFOE9LVE5NSkorN2hjL3VDN0VyYzNLbXhtOVpNaEZOVmkvS2Rwd1drNWhuSzJXTnlNSGZ5UkNCK25kQkhJNENkNG8vUWl3WnowMVRnV2JVNElXczJXNkkySWlvTVUxdFkxaksvZUxsOVNDd3NER1lTWi96a1hyc0xNQmZ5UnREYVFabkFPbk53bWZkV0RYUXVpMGRZd3JtbVR1QnNCcnNEUHRjeStnMXdaUGR2MTV6bnMxQk5NTENvM0FQSTJDUUZ5VVVRZTVYb0ozeU1vWjYzSjErclBDTEpvWU8weENCMWFEOUdmZEZpQncwdDFTdEEzQ1cySmtzMDJadHBZVTMrZE1jZUJCQkhieTl6Qmp6R094bmZKbGNtekY2L3JyZlIxVm9mb2p3Uzd3OGxYSFRNR2wzQklCeUVNR0Y1ZTFpbVJCaTVDMTMxSGlrZHpiWEZpa2hhM3pSbmg4RFE3YzVaMVJmalFmSXNScld2TFMrTk95WmxhU1dDZDVKLy8vT1J4cmFsM1J4Qmk2T3ErdzJMQ1U2d0NBajlETTBzbmdkaTlnSmp5dnBTMk9EU0ExVFNPWmNwU1JlbGNWT2IxVEh1WnM5a0x6dktiN3Nsc0x0cFZBdkJHd284aWtuclNVM2dEZDR4YkZRUG1rdEh3VG9xNUJNREhGRXU1eVlJRDFtS01Jd0ltVkZoMUlsY09OcFdQZFJadU5ETDgwNVJDMU9oTTMzR01ySHhuWUdTSlRVWGkvZ2FpTzRSemEvY1c4Vkl2Y2poTlZrbkVPbHNuaXo3VlI3TFMycStXY0RDcTRJQi9INlZNZkt5cW9XZnRkdlNrYjRrYm8yUHB5MVlQRTcxTU1FaDE2R0x0VS9mck03Tmw0ZDhvTTU4YmFIOElPeTdkU0R0b0RPYllnSzFjcjdzL0swd1pWbVBybVdVeUVuRy84SUg5blRMMjlIdldHbk5iV04xY3VhblNhYWJwSm9KYktaY3NUM3pFU25SZitVckRxc3pOTWhhV25IdEp6aFZGdk1weVZUSnpXTURGd2JGY2NNWGltOUVOeSthd0ExUFF5bW10ZHFRWG9ZbGgyWGR0ZmQwZTNQc3E0MEN5ZUVxeFpTQVladXZSdjVBUkFkYzh5Uk5xNlliQXR5WlpOSTI5Nkh3V3NJNnpCL1hqNnNJREF1STYrbDFOclJJNExpSGxkVlhya3JjcDRxWENmZS9yZFNaaFZDSW9vY1RhTlA3WmFQTkRLUml3YzVZYW1pUEE5NHVHM3N5WVdZN1dQZmFDYllaYjNUeTVvV1c2SjkwTGl5c0ZFRzA3ZlA4NjZYeXZpRjVNbWlZMFNBeTdGQ09LckNGU1djeUljaU0zNjI2ZEN2Y3k1NDVMME94U2czQlpVWkhBY0Z1MEt3SHNxZTJURUtxREp2ZGdMNnRPNjVwUE4yQVdCbHMwTGkyRGVFU0NUanRBa3JYQ3JDVDRnTWhPelhGWWdjTWxOYmFYUERtUDBOdW9sVEt3VHhLQ0VnWEh5VGt4NUxYMlF6VERiWWtwdVVOYUZkTkljQlVIV215WE1Ldkg5WEtIU3NJNTlKZDZuMUNWS1kzWW1idE0zOU8wTlB3TURrRFljRXNkMzQ2WWFiWDVCTVBRbHEyWEpFY20vMkRRQ0hiYUxwYnBMM0xaZFNNMldvelp5NEtiaTZHaW56Ri9wci95RXd5QjZGa2tjYzc0TitvU0UrZzJmcVhTaHhzSlRNQWtsOVFCSEhoUGM4SVJxZXo2STNsU3RMT1VnYXVPdWFJaHo2c0p1V3dPSGd4eSswSG9jS0VJMCtzSFhtMXF6U05tcFd3Q1Y1Y0xEaWplbHFEcnN4aks4MUx3Z0FaczVxTGZHU3Z0cUZRVDM5M2EzV2w5alMyOHJmMXk2bzQ1ellYSFNIZ2xNTUVFSkwwekE0UzV4N2g3blp0bmxDeUI2SDBBdUpRazk1ZHdKcHk0OGpQaG5oZU9xU01RRTFwdGRXUHFmTXhvN0xqOVZIQXRKNDFyTXFjSGVXT21WUHBpejYxbnowTTRkRGRyQVNnbXNOd0wvVnk3YzF3N0FzR3p5S202UHZ6Qkd2QTViclI5SDQrZWpjZm5mWitBOVlEOXRXaEQ4TEY4dmFmUkpTVmh6Unl6WlMvQUpob0tOSmhoSVkrMncrMlg5V09jN3NaWHQ2c2FlZkhpZVlHcDUxbkhLOEVWYnljQ2FUUEJLY3E0SkYvRHM1d3ZBSnQ4OHZPVHdVc3dLNVVtRkI3Mys3aGcxT3VTeHZIclVoYjBxSGxrNlNRSFB0Y3hnblhGRW1MOW9pMzdNUUpPalFPdHJwUTMrYXBjc1RkRkNTVzl5c2NDeUV2OUlCeUIvSnNaQzRReW9jcXRKMHRXbzB1Q0RwUWllRVNneS9PYWo5WUVaTjRGKzR5MVk0QTBocm0zdVdVanNUUEJKQkxJRDM3MnJMQnBDNnB6WkxSY0c0cE0vVFpJMjlTMUdzNXg3d3dZVnZRNlMwdUZObTBPcE9mblhqT3AxOTUvU0NpSllLQzJCTS9SZXdlRGZtNGhPOTY2aHhhcVMyMnFQVDZMK1dlYWhDUExkVXg0OC9xZ1l1Q1hDVG9tcnpCNzc4ZG5Ud1BmUTlKYW1NRHB4Z1VnM014TjBPTmMzZEpTL3ZkQzFnTXNpTVcxRWpQWUlFQ3ZmS3U4LzZGNWpVZTBUc1FQdytnZFh2K01hT2xHMFpnT1QraWF1bnVPTnRLdGcxWWxKeDFrdXI3T2RVRHJQczh5Q1M5SmFONUlrRmdYaDZubVVRM1hBVThZQnl1TFNSdzlETUxHbk54dFd2OGtCcElySThKQ1E1OW1iZWtIUlBzS3hTdFg0cTU4N2pxd0FacWU2N0tRdFhOeUhyN1grNWovTElZbGJ1QXdGMmtQcnVpMHRDRmNMU2JHaUhLNCtqWGlFTFZyRmJzdWl4WlREWTFPZ0JHSXpSZnlKazBGNDdpbUpvMzJITkV0Zk1HakpIVnlJMFVndVZra3hRQ0hFOFRPbU94TDdYZGRSK3QxSmlJODhyZFlmZDNnNDVuVGtLZUNBdzBPUmRCOS9jN1IxTEJRUWltc2owSVJ5VnBJbUJNc3JBbDB4dEpteTA5Qi9Tek8xdFY3bmxucHhoS2hETnJwMHExNVNZMHBRdEUwNXcrQUxTaXYvdGU3emJ2ditCMkRXY3hyZ2RXYlF4RDUrMXFRc2V3SkthOFJVbjYzVnNibGFrTnM5VHFHUXhld1FxOFBCZFQ4dlM1UjFYZW5xVVRUYThCaW5UODV1b0UwQ0lYY2dIN2YxWmVlVi8rNzMvMG1ZVkFIMWYwWEl3RjVxMzc0b3FtckNXbllWcnM0OWttalBkN0JtMWNKSjB2UldraFphUVdLZk85TmRzS3ZiOS9lbmRKUDVqdWVWU004aXZrVFBOeFRsQ1NKK0dxTlpWd3hkZU1ERFoyMHI5TlRxTFZiVnRKVExXREJKSjdXaDJxUnRWaSs5K0Rlc0x5dG1aTzlLU0NkZ2NmZXhlY210WjNnSmF3QTkrdnFEeHNIOTV1U0VkeVFpeWY0UXFuTS91SDNELy9HUkptbmdHYTljaHdjK2ptbWxSU0tVRzlXMXNIM2pyU0hTeWloakNSMk5EMGYxZ1ZwN3U5Ky9WMFRtV3BTakVJTE9zaUFsQmxFaEJnaUxrTER3Z2w5aXN6ZExKckhnakpCRDYxY2ZOZkdZaDRUZ1lGSXJKUVVDWE9SNGVzZWVyTzdQdERVeWJibkVhcjhMaTRIRTVJV0pZeVkyZnV2Sk1TV1JwRTE5L3g1NlJEbGxDbXdkTnBPQTJxT2tsTFRjcm1hajMvOHBhNElaYjkvWWNDYmpaV0E4N094dVR1ZXRZOHhCbG9CMCtqQk5OeXB0QXNCWXpPc24yZE14dHFRcmI5ZXQ0aEhkelltais1dEZyNWw0N0JXV0JJTkE3RzdaOHlrU1p1SW1zMWxXZlZHaE45bTl6c0JvY3lKWmRmUXUxSHo3bjFSRnRxUjFZS3crbnFDeUtwUFFXZkNWeFBEOVlUSndGZ2E2M0dhOVZRanZ2WVJBd3VXeElQTlM3UXFvbktENXVEa0lyOWpQb1JsVEpoMnVLVHR3Y2hNTjk3R1FoaFBhd3lGK1hNeE1YVFBjcC9pMG1FaHFKV2svYWVCa1RDaGxKU21pZlpBeEZwU0lmZmQyRmx4dy9LT0puMmZvSDlYdnQ2bkFpNlVCZ1hnUk9UeklzWk8rc0VMaDBXWFAxWG9ydmJ5WTFZV0VqL05NNEJ4RXFKd3FDSFFHcE1wbW50UFkveUFiQUxGMmw4TEkvdmpkeTRjQnFSc1JRUjl4bXNlWHJjK1F4ajFXWDhUWkw2SG5uRUFnZTgxMzdOUGZuZHZOWFdpdE5xRWk5eFQvaXhXK1gxMjBJbEUzenk2Rjk2NmtGWDFTL2ZYWjZyMGh3UU0vamhOb2FwejVVM3MxRU1NM3ZucTVZdHhUOTF3cGYyd3RHN3RsUEhlR0NSc2IvZjdZdmd0Nk9WRExiU0hCUnhjd1lLVTFTNTNpOVd1L0k0WUpuVGZsdlgrdnZ1WXB5ejYxL3V2NDZYZTczTk5xYmxtcWFlSXJnTUxhSVJTc3laYjVUR3lUQ21zalF3Y2pRS05seUQwdXpaRm8xZzg1V1Rndi83dXYwOFJkdUVtYW0vbVNGM3RRUWdXYlpGbms4NmlMQWVIcjBmVVlEbVRUZzJaSk1LZHlrY2NNY1FkWWlMZXZYYzNBVmJaUjRzcU4rUHBNODNBM3VRcVpzN2xwaWd4a0hLQVdDUmpPaTFEQ1k1b29oQTlTNHFiK2NIWmVoR3pyR1VGemlOS0VCRzl6eDBjVGR1NjlranVIR0h6b2x5bEhieCs5VDVHMFRwamNmTG8wU05VRm9IdXQxQ3NnOXJvMW5KbFUzL3dtSHFjazlpMTNoUWxYSm92SXRMcHdnNjFtQlUrN2I3T3FrTWN0TEk2cTA5WDVaeGxOUjdmek9wa0VpWElDZG1ORW1kSDBYUWE2a1VhaXhrRkk1cWRxMDVLTkxVbDVSNXdCeE5QZUtpMWxGSXdYUytFQ3NPNjFxejlFak1wbzRnNVNxUkJwSTRJcDVtNVZOT29rYnlYYVpZNUFXR2RCcUhIMUxRZ29VdXczU3lOWTdRTGdTTzBOd1QyVlo4L0wxY00yS3Jkc0RNT2dlSTE4dTh6TVZidlR6c2pUTTEzUkR1RWF1OE5OekFpTWdaNVhlWkZrR25qYkYrNXdxc0ZNd2h3c0lIcndWamtDdEdLUUhySnNXS0F0S3BhVURURUhwTHJ4cDNnRGptWVk2T29MK0xYeXVTME1jR3ZUcmh4ZmM1M1JTWnBkUE1mdmErS0JGSmt5b2t1azBJalliWDhLakFGZDNEZ1NBSDIxb0VRUFV0b1VaQXNJYTVXcXgyNUpFU2ljL2RObEE0Rnc5TGkzbUEyUXNRRE5tcS9yZ1dRdFNmb1BidFdWeHJDbDRzMjBrYmF0K0hLOWIzaHpydG5QNE81RTBwK0o3UUlWL2V3Ymg3cUFDL3FZc3ZLVlc0Rjh3RlcrNnh1SllJaVJ5V1BIbjJvREtrYVAvZ1JmbnJ6cGhLMEdIb2thUGVaaGJscEFmTmN3UVg1V2Q5MWRGbzNpYjZhWS9PVkRySmMwSWNsMVpMa3hqMU5HS1RjYWpselhrQkQ3dDltUWtYMndMTm5QMGRIclVsN3QxTS9PVmdtRjgzZmlhN2dvM2VqU2QvRHJDaXVKWmhnV0owRmxGangwaXNvVDU0WFNiYjNNbThwNzhPNldBODBCYmZ5ZkswVVdQcVUwd0RrVzNlSjVjNEdzRXdFZDk5dDQrSzF6ZktVNENvSnh5YTBPam5JakdTR0R2T1ZkbUM2TjB4dXhEZ0pwRW1UaXByUy82Yy8vU210a0RidlFpd2wrUy95V0JZaUtQbFpwNTIyb3FoWFlocVFjcmgyTVRHdE1qYXorOEFoQUhkTTQyN2FOZ1hBYnUwT2R4QjJKQ2d3bjQvKzhtVkpwQWkvMDR4UFd2ekwzTUtmS3gzU3JuV21BeHNPUzRzZ3NSR3RIWUVITmZUbUVsTjNERlJyMHpWcmo1S1BMT0tpUE1pNWJTeEVZM2hmd3R5eng0OGpKamhWRE5JWENBbFcxS3U5bnlmMzduL1YrV3R2eHZVd3F2SUJENXVwL01qejhNVmpkRkV3QkNuaVkweTBwY1JhekFpL1kwbCtMRGx1UGxmdlpoRSttSldUclZrSDYxSXlXcCtSRndUM2FSeUVJNEl3TGtKOXZremp4RUZqQ1UrSjJjOWp6SnlmMXBRK2J2cldwL3RkUlVEeXhHQnRPS0N2cGl5NlhvS0w5VUpMWTI1S0JNT3pwQVFTVHV0bjcrZzB6SDFWMjJJNEpYTmVoRWtHL2JRclorVWFCU2RvNUpzVnpRNEJrZFdyUlJGd2xYQlFVTXRDbDJQSHpXTWQyaFR1N1NpVWpwalJGamRiRkpIRU5uNXJwcnlHd1Bkd1RKc1B5UjFDTzF4VXJWUFEwNGlNeHZBRW1jTnllM3RFNWx3SkxnbXJwWWhGRG9rSUFnaDlvQk8wN1hPc1A0SUljM3ZHUkg3TXpUN2lGVCtZeXQrVUF2cjFPd2IwT2RmMTNmNkx1YUtmUHNzS3ZuNXRQRGNBMy9IWjJZUU5tamVPeTFCd0F0SWVhVzk4TXhwVjVrUVppaW9UOHZDZjdaS056L0p5VklUZ1VWME9XRHpiZVNDTWpvY1A3emIvMGhuS2gyeGJXeHNkVFpZN2lJVnloUm1seElxWUgwY0Qzenk4SDhiWWdid3BzK2ZoWUN1alYxMTVsUVdpTkdRY0Fabm12UGRxYjhBdjBvTWEzckM0bE9hd2duVWd2V29lemtoWWlHKzBsL3BZMUZiSENFR3FnNm8wQ09LTldpYTFJRU51VUp6amJNeGVINTFYd3U5c1BQcEk5WXp2c1Y1ZGk3Vk9tU3gxME1nY0FaTCtHQk95c1VjdHlHeFdpR2dGclFpUTB3a1NNOXJnOHpRYU40NEVKSzBoL1RTTkJOUzJZRnhZdlpIRFJZL1QyRFNiVFpZblFrUHVGZ1Y2WFpvQ1A1dUd0WUVZVHBoM05jRnhkVFU5SkpMQUlFaFpONXEyY2IwQTRJZFZuZHVBdWRJYUxyUUw2VDN0bkZlQlcybktoUTdGZ0VzaFRxNlFqR256eTJkc3dXdDFtekRGR0tNV3J6bTYvL1g0TUtiamh4NmYvU2tpNm1pczVxRVZyUnlWRzExL2UvdDJZeXhmWmV2VzVNMWlMWFNlUEJ2elpWVm9DektYWUUxRWpXdmFWWXd4TFdTTkdQc0xreTBtT0FEazNKSkRRdXZUdENNRFFZU29uQ1YzMlh3K0Zxcm1IaTRuaEM4akJCcFhZYkg4cHhZcHJLN1htaS8zZ0VBbEFFWWIyb1FDekF5aElnRUF1REg1ZzZsdFZBUUJhNDU3S3NIM1JsRTYvSXZoV0NuYTlGQVNFdjZjMk14VUJIRExjU01RN01WVnZiTFFDMkhDMWNPQTNOZXo3ZzB1SUVqUHFoam96YjRUd2NJSGUwM1hoWmE1MTNMYlJJOWlDdTF5allzd0gxaE5ZNVUrTVpnOUJqWWZnbGVlSHZ5Skc0ZXhrMU5EWVNobVA2LzhSd1k3ZDFkYlorVHFzMmRad2JMWDJYV1NXQWZRM2xwWkh3SURYZ2JiSlBBb0FqbDVvVDhqdldLOG55QWl0RHpRQ1hweGIydkYvWGRrMVppN2J5a2FUdWhRNUk3MllzVzBFd244cVJDekNUNDdCR1BYTXo5RU91N0Rhb1hUTmJEMVBBcmZIM2x2TWUxWjdiT3REMlh4N1ZkMUh1bDR0T1dWeXJudWJiVXZyWEgzL1BPZi9qek9HS1NzVkRaOC9lMTNvOWY2aTZjdjZvMTJ1K2ozZzdybC9uRW9xN3NkZWl0Lzhhc2FQRHJoL05Xclo3WGNycDczeHUyK2V6QzV1YkJkRlBwR3pSYzdxRGVGRFArOVhlQkVHb1Axc3g0NmxYS0RLVG41a0k2OVk3QlFoQ3c3NTQ3ZXViTTlCTlV3VXBySGdFbmFPMnExNlRTUHJNVmtBSzlxUkdxdGU4THZ2RFNXejZWTERXdnNpenNvWDVIblVwNVhVbklRandNcUFXd09DZFhtbEFCSWt3WFNOc2J4dXRJSE54L1JMUVRRcS9DazdWdEZBU05lR3ppaVNXbG92WjArd1pTR05nUlVCM1EzT1NITTY0cDJqSWpnYlp6SkFqb0JzMU5MTDhtZHNFRXJJa3lzczVsT3NsV0FQZkMyUHJzc3hKNWc1UGVyMXA5bUM5L3BzSVdYamQzcHloMnFFRU1BTWQvWC9YSWhMSU5RRUhLWDE4T2xXcTNCM1JRcm1HMk02MkZiTHdaUjZSQ0owYi81NXB1RThuRUFaVm5sdVF1YXo5M2Z2alA1K2VmbkF6ZXdGbXF1UnUrbDVqSmNsNGlOcWN1c0hocVZhZDhpSnFwNmJpMzduendoTFgxT1ltcHI5NkhzK2RVc3BuRzhVUUo4SllXQTRKbjdjcG9JY3preFF6TjNQWGdUSnA0eWVIWlZjeG52ZGYwQlZDdVhpUmtSL1VtQ2tzamtkZ2d0Uys2N2pBaUhBQk13RVBVcnAyd3djK3RtRG9UL1lrS3FJVVNVU2xheUJITU5GWXNyeDdGZks1VlBzUjZubG1ObEZTa0E3cWx4QW1rdnhNMWJROWFCSkZOU0FyN0JSVE4ram9WL0dMeW42TEIxeWRxNDBhWmZVRFF4dDdISTBoN2hjcG8yNXFlRktUdENkU1RHeGdTWGhmdG5pOUk2RzVLaTR0TEN0Z2dyRnBQMUhubFczV05xMlUrRk9uaURoU21xUmNOYlEwcEdUeWUvYTVFMEJjVGxlazNkUTY5aldvR1JpOGJPeFJrcERkRXg0Y01OWW5GaFp1UG84bzBwYWpML0ZIZ2Y2cFZyNFNWZ2tNdmVOUWhFMTNJTkNaL1d5SGVuSHNNVXovc21nY1ZTMFduMlU0ZE52TXlqMktvUG5VaTNkWHhUS3RERzluTDBXb1ZLU3ZkM3YvdjFxUEU3em5QNFo3Ly83VWdDSFZVRkNhekxyR2tld2NxakI5UkwxOGtDdXZHZ1VybU8yWHV0OCszVk9NREVJY2FhZHFKWEQ2NGV6MmwvZjMvdzduZmZmNWRRemVxS2hzYis4eVJTekdqS3ozVnQ2MUd3ekhMNVdsb0hrUnV1Z2JiQVBsSkZqTis2WFphZXRMVWRmRlJVOHV6U3VhbVVYRUl0dnBvRFBqTFBkRTJRVG85UlRtc0JySmFINVRBbERybFdDaGYzQmw0MHdzbHRqaDQ5Mjd1YjNTd05FQk1pQ0FZM1RYdWE5WVBsSFc4L1A4RDJhcG15SG9ZMTAyWmpXbTRjU1QrWVBnc0RZVEQ3UjVTazhSQitFaVJoQmxvb2owTlRNVVNFb21ac0ViYVRzR3JZQXp2YjNkbUorQkswV1dVREV5dWFxWmxkUER0QTFxdVpLVDduSER4ZE14ZUd5MUp0WkJ0N1AvQVJVV2w5ODY2RlJkUmMyOHNFOXFzWHI5Sm9hK0VHMGdjdUp2Lys3LzU5V3FsY3NwSWR1U2RjUUdjbktpWm1RdnRobVZwWEZJZTV1SWVFbGVzNmhVckhDaGJXK1ZtYXJYRXhma1ppWHhzdFhjRkpSVDRMRDdxS2lBZmczT2JLZ2RJK2hJdUhtQWw4MTJXT3MyS0IxTnFGWElUM3NjWjgva2F2UzlhYnpRS0E4Y1hWalExNGI3ZTZNUUdJQ2RzLzRJTnVCbDIxcXhmdUx0WEVFZlB5WmR4eGhNRS9jejlaUFFHeWVjU1VuamE4aEpFR2ZVRFN6KzAvWVdCTzJWK05EUWFsZWlHd3U5OEpDZTdVYWRqcHVHN01QRkljRWpEOWdzUDkxM3VOcjgreXFtTHAxbFliYXRGQTlCYmczRGhtS3Z0aVZWMkdYYXJoOUx1Z1VjdlgvdlIrU3U2cW9BWUxYOEh0TkdqUmJSSlFrV3ByTnhWVUxIZGRQN0p6dXliQjFucTIvbjRucFB4Z0tEL0d6dFViMGRNKzg5bmZDVXR1b2lPczV2dXNvdjhocVBDQmFhR042R0QwbU8vM1lZbEZ6MFl5RGhOVjg5ZTlwcEhHeHA0QmdWOEVkd2h6TWxWMDJHZGY3VDhKZDhwQWlKWmVSSjhDU3lQOXB2ZHVidDBOYkg4MStlcXJieWVQZi81bDhtLy83Zjg1K1MvKzViL0tyWHVaUUptZmZQZmQxd2tTRlJEaHQ4MGZoalZNcjhiTTJxVG90Z0svcmIwVG5RbnZ5R3pNYitSRVJUY3k0aVc1T2hKczVCUm02WXZZNjZubk9EMUtheGdwWjUyeTFmZlI2M3lDTUQ4aDRGKzF4ZlF3Mi9QbXZKN2dZazAxK2VITnlhZFRLeW5GNVdwbW1vR2d2cGVWTlh2My9zYmZYQ2J4SkR4K1RITWRsdXUwd0lwcWdWa2dzQjA2UXY3U1p1bjRSajYwQmszZEJkZUxuam5SUXM2THFKSnpEUkVnYzA4N0Y2QXpRZVVVRkQrSTJHTWFoYkhnaW55Wms4NWFjOHhVVk5oQ0FUL1g4MzhId2ZXS2hSRENIZ1dXV1dHT09GOEw4MXF2RTZkbmpNaXRZbUtLZEVneUZDYm4xOXRzSUtjU25zTUVsWTJnMFJSaG43UkJCUFZXQWt1a1ExNk53eWMrQnNvelFRbWtJN2tvVVQ4QkpXcW1BeVNyeUNHV3RDYWlRb3lEQUNNYzJoZEJqMGZyUmN0akNuNjQ2SWl4TGVhRzNkdlptSHhWV1BsbWVDQWdjeTJMUnFTRVd6S2I0RjNJM1lVSldVdGxES0t4TlA3STlZbFpFSy9JR200NEx5bjB0QVEvZFdGTnVIR0ZvU1NzMnJ6ZXkzVk9JMmRzRHBmdElvSzhrV0tRcmtJQXFER1RhWDFhQjFXNEVNTGc3a2t6K2F6c0tVVWkzZVZqNzh1cE9ha2R6SG5XelZrcEhvNnVWeXpyZStyL1dKdXE5SSsxTFlFeHRZWlhDUTM5OFoyb0V1c054aDg5cmhxL3RBcVd0V2NIZDF5bEVPWmFwK3VhTjRLS1lKQmVZZitrbHVnUDFYSUVFZ3Q1eDFTd3Exdy9iWitEY0hJcHNyZ0RoVDhGeEg5cWYrRldueTFJZEg2UzI2aDJGUzdFZ2tEYkhrTVF0WS8rWWkwMWlPYUYxcWZLbFNEeEdRKy9ENEdWUU9QQ0szVmhjUTQ2NkFKb1d5a0pxOVpySHVNNnZlN3ZVWURlNXloMExWVjhYMjZUOTlDSmZjTVgvVHBvYkVUQkd4Smw4ZjVETFptS3JLNVVHaVpmaXpXbkgvOW1xUUZPVVorMmlwR2N1Vkh2dDZmUnFmMnQ3My85ODdVdVl0MDVDa3d4TmxUYW1xd0dpanY5NXJqQTBzZDRYbDRlNHdPdmdYWDIzKzMzK1RETWNpbm5xamJCdzNoWk9jMWhyNTFHWCtiUEkyQ2djRzBKZDY5ZGRCK3RuenYzUTkxQ2QrU2NzOThMVU9WdHFXV0ZFNnVSWGVnbkJoN0JBUml2dEo3dnZ2NnYrMWIwZ1ozYU8zZFAya2FRQ1N0TjlUR2c5aVphUkRETmdNMERSRzhBY2xkWU9SamszcjM3NDRockV0ZnBHYUtFODVWR2ZBZ0RHMjVSaXkvWGh4bU40RDJBYk53dnI1bFFaMVMxa0x1OW5sQklNNmhCUXhRMG0xd09sZ2xwRCs4YW4rOGFqazgvelBKNThOWERzZkJxNFdndEpVVXp6VW9XdmNWUVFJMzRSanBGeTZTdWo0WWkxQUNhcDIzUXU0REt4TTdRQmdjSm8vTXl4eDM0U3FnZFpJV2RWTmVtNlJuZ0Y4TjAyWkdzU25pWnQyUFVsMHMrTlQ3TVJFTVlwL25DdzJpT3FiQktsd2RpK3o3ejNyV0Uzai9tWW92eUhRZUdLdnowZlJxWjFUUUE5MHpscWZXUk1Hdzl1ZHcwdmdmY2o5K1A3Qnk2Y1I1QmpYN25DUTBXSmtIRXJRS01FOEJPbWhudGFHTmdMaHlsdzdyeTdIVGZGU2ZhZE1oRml4bXhVaHFHeXpMNjRqcEYyRFN0dkRaYmQzS2NRRGdPdXl1WUlwSjRldHFCRjl0Rmc1cTNTS2U5TkViTWJUNHNvcEVpTWE0YzdTVVVuSHFFdVZrMmtpS0h4ZEttR2Z2SS8rcDl3Q3VtbmpKUmMrMDlsaExGTmxVS2ZTODZtY2xpWkxvQ202V1g5RjhNbmdCcXZVRUlpWXBoc1ExbEVpR3dZdEFkRmhwcndWM3Iyb09sV2xkS3p0aTVaOWRDWnpCaFkvWHNCNjBPeTlSYW0wTjc1QUhySWZSOGwrWGpzMmo2K25yY1ByOFA2MjNNbjlDZXdnYlgxeDdyMW11U2svMyt2bjNTWGZieHo5VlpKalF5bXlkLy80OHZVdFNmSnc4ZjNhdERMYXZxWlVxMWcxYkNZYm1aNzFPNlBBSlluZ05PZi9QRHI5dVRyTitVRzBHbGw1Vm8rUDUrcDVoSEs0U2RISzNSREpHQ1RDYmNDRHR0QVBGWEtUamxZUm1Ma2lTVkxYNjBsU0ZjS1hadG9zQXlCT2pJNldzUGZGZjFoSWpuaUZ6YjI4SFhDVEg3MDc2enpOQzczMEZDQkNVRGhzRDdXSDBwS0FKUDgxSm12L24rOXQ5dzZWaFNoTVJhNlFoYlNldFliNWlOekh5TEtkOUtTb05OWVFGdzV5U0t5ZXVSQlU1RElBeWJickZJYUVSS3dJbDJ3SFM0Zm9qZGhtN1dXb0l3c3RGZVUwQkoweEpvSmlRRUt4T1dNTkJSRWVQd2FSdkFFSzdyWmMySzdqeDkvcVRrMVRkaklXMjJTR1B6S21nZ3J5alhMS2FCaFdtUndVMFVtWHUxLzNZc0NDdU5LVDlxRjF0UXJ1eGhQYkljU09sNDdxVkErZ2YzSDlYNlJudWJEb25ObW52N3R0eWZoRGpoTjYxL2JCUFRJT2JXRmd3MzJvUXdKeXpFNDFwVEc1LzNZcDNNM1VtbmxOUy82bWFkUnpQdE4rcHdNRnRkWGV3N3JDaWJTYmdTeUFnYlU5bHcyZzFBalB2bVVoeVhXVlR5Y2ZTSEo3aFllcDl6MzUyR2t1YzNyRVNXUkpRekFQaFVmeEhkOHVxV081WXJ3WDNaNTg2ejBxNFNSSWhtcEMrMEY0SXNSK1c2RVVhK0kwcHJmVDYyUDBvK2pLV2J0YTVLTHpxTXBQMW1jVHFvaEdDbFJBZ1dMb1lINGlPSWhoQnNEY3hCKzJick1iQ2hDTnZZMFYyWGJiNGlnWVFTMTVQUVJPandMNi81VG01Zis2dmVVVVhFNTJBSGhlT1NRVTk2WGFYL3A1U0Vlc1krT3ViZ05YbDY0eTdqZXIzZm5LMk54MWh6OC9vaVBLK0ZoMmM4Y1Azc3MxTzZuYjZPaWYyTjlvZEE3SGVmWlEzakYvVDgxd0xMOTMzT1o2NmZ2ZVk2N25QOUdJcXYxMXhqdkpmbjRGRGJhUUY3VWNMeUlIdGp1RmU2S0x3cm41QVZ4UnRpUGVuZTBaSU1XcFc5cnQ3MlZkbnRXc2JvbHZvc1Z4S21ocTRKQy91TVprWDh1YnJUNjB4ZFdLTGN1bEZJOCszeFNMdEpjUEVBckJjRkFmbWhhRmpQOW9qUVpoSDdvUWhrOCtPNUlhUVNham81VUJxRThnaVNvZkhoYlRYbzVqb1ZvRDhFUjJUb1pCQ3d0dWYwN09aek1qZDFCekJReEdKNHlta2F6V0QwclFUWlJUZkU5QVNJeDdQeXJpU2R0ZTVsaHIrSWlDS21Oa0orQ0NGQnE5RkNoQlk4aWpCaWlVMGxic1JkeUZJVXppWXBMMEdwTm9ad2sxekcyb041UEh2MmRBREcwdmVCc2dxY3BSTkVpd05IbzRVQjVpdTVrSmg4dnhEc2FhMXBWbkxRdVRDcXhBbEVKOTdJaGlleDV4TzZTSFdqNk1qVVRVM2pkWDNoM2RPaWtUdU9zV29IWHRhZlIwUlBCRWxpS2l5UHUwb1l3OXVRdWdOREpUdUtHUGtiOEdqRHVJZ3NyR0VkRFNaSWM3UldUbjdHd0JqcGtrWkxteC9rUHMva1d0MWNsY1EzVFdGQTVGeGNwMFFQVjZHOUFhNWJWL2RSVnplalRDckw1eUsvWDVSTlh0Tm4wY3FPWTc4TUIxQS9Oc3BTSWhoTWJ6K3Zza1RtaWo1MnlOMXc3YmlDWnpHOXZhSnNManRRbHhDWjVzZGd5b1JQWXhER0JwREtpUnQ5dDRiQ2laZ1NhcC9QQzNRMHg0R1p0UWMzYS9Vc1RhU0JSQ014YmxFOE9OejBNVVkvMXREOEVMTjFRaGR4Uk4rYkNnQkt3QnFJbGhyNmNBOWJORUpMd3ZCNWJpQ1pGNTBuNWxPRUJGeGpjQm5XR2lyVy9zVzRSaEpzU2lqYnVQbjNCZnZRbnFMellhSEZyTjFtclBQQStib2VZWUllUFFnWFA5YklhNTdIMkhydDJyTHlQc0dGbnE4Rm5HdGZYK2Y2V3RmUDE1OXhmWi94OTErL1IrQmQzM2ZzU3hxSU8rc3dYWUxvOXQxSFE0QzllUGxrR0FFT2pWRC9xd25BU29FTjBBRUxjeUZNOUZWSDNObEhVZEhMbVI4YnM2QVZPdVVOSEU1ZUZLaFNseWdRYzFQWEJuSXpXQUs4b3RFQndIMm11c3RZYytDRTA2aHRjc082MmE4VWdiVzJMdjhFWDBSTGxELzg4MTJmMlc3UGJ1ZXhVREJMSFhMQk5WYjNPMXZIQm5wdHJNRndTN3RYOStYRjNLem52Q0RkeDVLTUtiOXc0U0lpc21PNzBZUDc5MXFnY29CRTZsZ0JEWlRna1ZCb3dDUWhOMlFhT2NtZHliSmFXYjB6Tmc1b2hxQUE5VFNWa0tmRVVNODNpNnk5SHdDMThMWk5UUkFsZUdodjEyWENDb1VlZFQxRTREMHBFNjdQWGJpMXV6UCt0bm11dDVDcEt2dzdoT0s0bDdhN1o1TzMzVVBaQ3MwQTNKT1RjcGhaakVtN2JIUGpUb1JyN2Q1dWtlY21UOHM3bVduUk1KbmNMQzEwaE44UDNuMks0ZW90SHRCK0ZGNXdFVlppTGxvV3I5YlBSNjdRUVc2d1NLaStQYlFFaTlBRzBDTE0ydmNCL3R4Y0dnelc1S0c4Q2VPcGFUdnBHb2NSRjh6RnBuMDRLdXBXTFo1Y01ocG91QTB4cjl3Y1RNREM4enBCSjVxbi9zM3BNbzdGWW1FNWFrbElXZmIxVmExcGxCQXR6bXVjVjAraW9xbEMwem9rNkc5L1E1Tzk4REVnKzNIalZPNXhtdENMcHNZRGo5b0grNjFwM2lqb0hvdzV6V28vYjMvVWdLRVBMdTZidDN1WjdoMVp2bkRRUG02RnBaUlBsK1YyMGhIMGtVdkNwVFZ1dmFQK3htOGRFeUlJclljbmxyYjIydFlSUTduL0FOWDduRWhYdkRBRXQzU0thOEUxU25CYTI5RnV1UzlvREtsbkYyWEdaY2ZRckFJNVBMcS9qZ01udWkweGRwS0ZUTWxSUXFNc3AzRllXMlBwNitOeExaU3VoWSsvQ1hGNzRYY0NCSFA2MjgvMXczdlhQOWZDeW51WUVmMWVQLzc2YjJ2dE94NWU5N3RyNDdOcmZ2QWUzR2kyRGhQcHgyaHladkxMMDVkaFZDVmlCeW1JZ3Y3d3UyK2pvZFU4aUhyQ05kYVgwYmRJSEU4RlhxUW4rOXU4bE1NTUIzZTdlKzkyeWlhNmovZDRMODRWb0N6T1U5UVVwSlNUVDhFa0dnVDRBZ1c4dWo2RmM4WSs5cHAxeHE4Mld0OThtZkgrTnRhUmhEdVV3MVI1aTZTL1Znd2QzK01idElQR2xBQW1pb1pWem1JKzd3ZXZhZ3pKdTFBMHo2SWJsUUFQSHo0WW1iV3JmVkdyVk5yUVFKODlxVmxlN1NkdTFzWmlZQkdKQUpJUmdieCsvZnFmaU00Qzg4RXNybU9VYkxBSGx5SGVTbUNVVGlEYzNGN0JTZUJnSGtkaE54NGpDN2JueHovOTNIZW13dERHS3JKVWZ3WUhjZytDMVRIeUJ3azRqQ1U4ajREZ1pVcERFRDBzVFRtTkpGaU42aVRXc1Y0dzE4bDhFYUFJVlFlQlo2VXVJR0JIbWVsWkRTeGVHRDNrWTdURG1DYWcrS0NreWF2T0h0UXZteHZKVkZiNXI0SGRTcGFWbEFwNVNreGcwVUIrUGVJaXRBeFFTeGFXcTUyR0Q5andZUWxZTGo1cnowZVp1Y2NKd3RQejFrcDBFOTdFdGlhbytqQXRLRzFCNEFJR1FFQXdzekd6M3ZPamVWeUUra1VlanZ0VEJvRDlneW9PdHJaRWVtdnExelZrak91V2NZTjEyZmgxTFNEMHVNMDVEd3loaEtkK1U3WGQ3ZHFEa05vUHRZY3RWZ0lqaDZBNURHR1pwY2VpWFczZFJSTVI2bWxsSGUrckpOallTRHNxNUc3ZFlTR0xnZElzbHNINHJkT00xeU5HUWwrNndXeW5Cckd5RUs4MGx5RmdNRUt2b1JuS2o3WEVCYngyQ1dHdXJDdjNIYVZmMGUzbnNSNXA2cjdqUnhQSDBUSzVlemhjWXo0dEx0cDVUdWdRK2wyWEVCZE1JRmlzK1hpMHRwY0lyTW15bkl4NzZwSlBBZlJyZ1lWRzBaK0gxM1JodFc0K2p3Nysrbm53U0ovelBIQ3JydTM3L3JZL1B1c2Exd0xONjVoZUN0R3dXTkNaTldvOG9yaC8vdk12cmYvUzVFRUpvbzdVdzl6SDBkby8vUEhIa1Nid3BIS2MzLzdoOTZQOFNzUEQ0NFRFWnA2RTVvQzhISUVsOC8rUGYvekhNT1JLdFBJMmRPRVF0V1pWMzJ5L2w0T0FIUHFnNTVkMlJvVG9ZWkFSdmhWUVlMZ2NCa01ZKzVoWGhvUjh2TVVVNG9kZ0ZYUTQ2UlJ5dGJCVHJ5MDh2QURBZXRGa0Z1NnIwYml2dk13aSt3Rmw3ZU0welVFcktoMWZwUGQwS09pWXMrdlBwb1JoeVhOY2dkdGhWZ0RvZG5JdzM4MlJSRVo0VEhPZUJsQWNnWEZWUnRsTWZiUlpaTlZQdHJDMGVvUVc0N0orN25SNkR1Mmp0c2xpWStiWDVYUnNCTnA5eWhxQWdXeHY3eWI1VndkenNMSXNIcHhMdTFzYmFyT2VQbnZhUWt4eEVBT0dvVGthU3ZhdFVnWFdpd2pKcDl3MUM2QzFjSVpMZFhIVkdNYVk3ekpkdE5KMUp0emV5dzUzVFRpeHJtQWNyWGlnOEZKaDM2OWpIcTd0aTVMdTZ1R1ZkVFhhTFpkUmo1QlhPN1NWeFRoL0dxTlI4ekhuVEg3b2FDWGJ2T1pLNENQNGFCa0Zxbno0QTFaaG54VFNwcVZZVjE0ZlVkRVcvSVpvVmhyTFo5N1ZFbnIvN1lmSjdRM0hMeVUwaHNDQzgzQ0JJbjdDcnkvMzlTRjB4Z2dRZXZ1RWdPRXpWMjAyUXI4cURFTVFPV2VPUzZndDBHYm10ME5GZ05ZZnlrYVhlZDdXalpTSk5yQ3JKbEJTVU1lTjNSN3JYREhGakRCbjFtQzN0Kzc2NzU0RjhqcWNWdVcrY3dxNXRhTVVKV0d4RkdoL1hITGpHd29pM2wvS3F0T2FXZjZORHBtSmthN2JHKzBSQ3hpREVWZ2p4d3FqMnBJaG5CcFQ2eVUzWjhBTC9PZlczVGhHSFdMNzl5bDZaYlZhSTFieVhQT0VXWjIyWHAvNzdpaENIMnNTay9jM0pjVzlJQWhoam1odDFySExRMEIxZmI4MUYzOFBLNmRyZTlnZjYrbzFQMzczdWYvLzN3UVZEUGRhU0JFOGZ2eDkvWDNQSHI1Ly9UUDJ0Nys5ZC8yKzcxMWJiVDdQNmlIUXJnWG1DTzdFUDNJSkhjN3k1RW1nZTVDQTVHMksvMmtWSDMvNHd4OXFUYzM2TGZmd1MrZGZFSXNTTUJabHkxUUxsM2NqTjJ1aHo4eWxxTkc4OHlFM3FobVdlUDBtQVRkWEdaYjlaWW1tejFMY0RoUTU3VDc2Y09YbFJDc1p0TU5pbGQ4M0FqMnQ4VjZIMWJnSlpVQ0JuVVlRaTZ5cCtKcUNBZkpUdkhCZ0Z0amNmTGxhMFN0RnlCSUhXM0JMNWVxeDl0YktQNFNOSHhlZ3d3aHpyOE43cFB2elg0R2dpbWNQSXp5QU9vRmxZVWZHYmU2UTU2MGlDelE4cmUxMGpLa3djVnoxelh6T1V2SXpNYjJtR2VDckJJVldNOXdRZUFFTERiTVRjZ1pESUJGdUJKMmFQNkQvWE1DekRiUnhheEc4dkpnN1ZZQmpVQ0gvMGN1NlJaOVA2TGlIN0YvUkU4YzJMZlkrRUhVdWdiT1VRQndkRDJJVTdwcTZSUGpiYXFBOGk1R2I4K3JWNjhaQ081Ym9HdVlpWGNIbWJlYkNYb3JEWXU0MlJqRFZPWGdpUW5wRWZVcmdjTmxFZ0xLcEJqQnV3K1pHcDRmbTF5WUJ5ekhwWmN3aVFERkFaQXpZMkpFdmsvNWpCMjI4cVlILzBSM1Y3eDNPWVczQ0dRaHM0a1NFRC91Yzk5cUlwSFIvYXpzRzFrVkdSOFkrWVIwSnJQaTB2OUxFaldXNy92dzdkMjVYdnBQU2FaL3NaMXcvY0IzUkhLQW00V0FzT3AxZW51ZkttM0xyS28rTDJ6WnkyaUlrWTJlVnVMZTltNWN3MnU4aVFXTVBXODlsMXZPbmR5bUpyTkdzT0IwbEZ5dmZhVEJqcnNucThLV0VSc1FIRnZEQS9CUWcvTlQ5N0Rzb3dPL1hqTzgrckVyN1NwaHlDd2FHeFNyS3RVVkhHdFdkTkJlRnphY0I2MUZWd2gvUkI3eG4zV0pVSFRqNmNQZjBPZ0hhM0ZNR1lBejNhQ2pUTVNXNFlHWU5iSXpCR0QwSUlHTzZwazFDaEREeGc0YTk1enBlWndtNWg4ZVkwNWZ2WFF1K01hZXVkMzN0NisvNnJQZXVNVEhDN2ZwNmZtY1VDQjdkS1hOOWQvdTJpK2NCclU0NjEycDg3OEhkaDJHV2k5TWVWL0VxUlg2bnRCazVpeDlUOFBCZm1nRmZLR2NTb1FaeGNOZlhPNjhRbGl2WDhEQkZMMjBIL1FtMjZBVEt4VCtxcThsRlF1Vm15bWpzVjNLZkZZaWZwRU9BZDZTazNMdDdOenBJT0FVVDJZZmp1by9JSlpTa092SW5VM0JTb3A0bmUrUnlqbVQwZUpUcjUzZUNtVWRBQmxBNnNNaTVyRUM4TTBlYjBWZFlBekd0ZHdyeFhrZkppeEl6ZVMzaUZCZ05hMG40TENYaEVTUWkyZ3lybUN1c0RWUW5pWld5V0VSWUVGZkdaZ0xveHdrNDdidS90VlptZmRFZXNDc0R0QkVJbjdhaWZRazlBdXhUdjJ2RnFzTWxRcFZlSVRMQ0dtUXRyRVpzQk5aRkRmQm9hQXN2UjJVKzkycXh4RFdGMWZxbmN4ZUhrR3hobzRjMkxud2w4L1N3ZnZGVHJYT2o1THU5QVVBTG4zc0FsNmRaK2RQQUF5MC91RHU2dHlidUQwZURIY3kxRm42bmFjYXhWQzIyUEpkQmtER0xLM0tEZEFjUUxqZk95OXdUU3A0RlFMUEFXUkNKM3ZLMDBFd0U3ZlJpcDlRUVF4NllodEJrRFZFWWlrMjVwSVBwK3Y0OFRDM3R5OGxia2xHY0lPSk9DVFlzTWNXNzczd3VzeHBLcVFzNmVNWWlnNGcxV1VNUnRKOGoxcnB6bXR0Wmd0T0FoWFFWbUNKaHVyU2dLaUxYdkgrT1UwTW5yWEw3bk5XWXhVaTRjNnRadE0yNjY4WnNRMEF3NHFmQ1lWZ2FMTHErcVQwUG9KYkNQQ09zR3ljRk9vNEpHOEpGdE9uNjlPZXAxWDNWNTlDY0pGRkNWdHFLVGcwdFdVeVNaUlNET0JLZE5UMEY3d25uYUxsNVR3VVBnZFIrK0VJUGUycS8vQXlCa1pZZjY5MW5DQkUvaEt1RVNVSUVNM2tmZGt0Z1hWL0R2RnhqckVuUHJ1dkhOYjEzL2ZmMXMrdGVQNjc2UHRWSEFBQkFBRWxFUVZTdEs1OTE3VUUvdlRtVWRmY2Nua1JyK2t2Sm9PdmxZWWtXN2tXM2FkZlJjT0J0bHBPVDJiZnZsNjRRZnprVFlLK01keWRkM2IyOUdXNFVQMlRWU0VuaTJnbUs3Ty9IUy9IZzZldTlrU2xRL0hDc1dmSzZ0YlEzZ20rZDlKNUFrMWNuSWZwbW1mYXM0M2RkUTB0ekdRWmFjS3RCSHQxT3N0Q3MrNGpRdzNaWlRyelptdHFvbmVTRldNUHRqQitXMVRoQXBnN0hiMkRwR1MzR00xejIrUFdxOVFZakhUVUdrTW5jVXRweXBVcHRIVUwxY2RyZmZ6bE9nblZrRkdMOStlVXZrMDhSTVp4SW5QeFRhUDFHYlNkRXpqeUV2cldIQWQ0NVFYbXpFS21vMlU4dmZ1b0dDWTJzcDZOQVlacit2Qk9NNFNUNU9pVjhsaVZiU1B3c1VFKzNDUDJPVm1ONG9kbDdhUkNiOXJLdzYrYUR6Y25QUC82VUJsZ2ZOVkd3SWtta1hEV0haU2pFN28raFBlUWhhYzV2c1hVSytGaSt5WWNQaGJ4aktPMW9GR0k2b3c3SVBseUt4ajhLY3JNYWJPWmlCSFVpVEYreE5veG9kS0JNS0dxMmo4RlpncXdORzBFZ2E1OXlBVVBxT2l3L3doWXdlZExyT2dHd2FCeElxYzJIS0JqTEZGaE00QXppWjdtVk5YNVd6dHRGdFEwaW56cWxma3B3eFhxVHhZamxabk1UNlhHaUNIeU1nTzNDamJ2L0oxUk5WcHNadFlFc1B1TlNvRTdnVHN0VzBsenFMc00rRUtqUFhtVXQ2M0xRd2lRRkUzcHdodmJmQVJBYUk0cldUVnY0T0tpemxpOTF4OUJ5Nk0zYk90TWEwM0lDcEVUVHl4b0N2cTlzaWJXb3BZLys2RTRZbG13Nm0vWGlIdWV5NnhNZ3JCWkt6dGdpaXlHd2h5QnAvYWE5L3BXeDVFSlRYbGwvMW0vMHhNZlEzWE9rTWlRSXBTYkEzN2dwRko5MjBuTlp4MnBYaHp2WThoeW5qTVo2eDN3RFAwbEpqUDNzMldiTlZ4OUpZUEJwcG1rN1djY0pBdVBUeXZpR2NWclh4dXB6TEhUQ1F6Mm5DeWhRTnd6bEovYm1SdEZXdEVISXlPR2JXa1BSUldNbmhLNGZhTnBybm4yZTRQVFo2OCs1MTdWUTh6MC8zbk5kdjN0L3UyWURsTWJQajM4WlZTWmRxdXVGN1piR2N6dUwyalZYaWhZK1MxQnBXYjIrc1R4NWUyTnY0TFZqRHUyL1h2cHFmelg4MjZvRENVdjVOOS8vdXJYVkJiZXh0WmJvU1ZvQnEzOTZzbmF6YUo5Qk82d2ZHTzZ0blduaHRyUUlpcEZTTys1SG5RNzNzbHpvSWVTdW9tc2VDYXRxT1NGcm5YWCswSG1WY280cUo1YzFBYmhzVWFVcXJkWlcyeHJGcElPK2w0TnpUcHY3cTcxcUZsZktsZ1dTTGNUNHR6cWZjSng1MXdJNVZYbGhQU0E3UzBMa2k2QVFOaVU1V1RrSVNNOTFWNVhkUHI4dUtpY0ttTnRBR3JhaGNDSldoUmJGNXdHcWM2VkFDSkV1VnhpcDM1TUV0dk44OE9QQU94YmVVZ1N3M3YxKys4TnYyNURIdlRLVHhxNjdhQUpETXphUk90UXVOY0ltd3E5dXJFYmMvZTVrV2VIVDlWeEJSZHNyQ1VpUzJUZ2ROMFJRRFFzeEVGZ3g4MGlBYlJHNHZSWVRJNDNyaFFGRmtrMHJnUldSd0VrSWl5RWdFa0FFMXVqUk5MaHVHaVltZ0hSY2hGTTE1Q0hJUnMrZlBxL2xDcnlHYno0RVR4OUFoT1lHeUQ3dUlJdUR6bDQ3ZmJnMTNCYnJmRkg0K01aTTFxYnJ0cmtpWjZLRWhCWDN1aVZ1RzFxck5wS1FWR29DckZkdnhYVTBIZ1hnbHlVVkV0WXIzS0ZVSEszMU9RYWZtU21pMkgydTJxZVpGSWplVTh4eGgxWmVaZnBMQVhpYmNISWk5N3NPNG5Ba0UyR1U4VHJjVHNMMXRJQ0VMZ3p2cTRGY2FqM2wzYlVOZmJkejZ0TDBOTzk4K3oxYkN5REpoMUk5VGdhRWtDWFYvQkYva0dXL1R5MmRnZlVsTEZpYTNIV1d2NEFBNjNIZ0p3bXkweWIrdWYyazNaM2EzRXREU01VdGc3QUh6dWdhck9IbXhHcWZsaEMxUnUzdjZQalpheFNINi9hbFhINldZUHZjNTlIVWlQUm0rZlZMMTI5Q01RMmRTQkdObzliNkRIZG83R1VDa0JEUjFCQytZMStuQW9kUWNuOENrWFUyRlVSKzkyQXgrUndCNG9lUStlc0haalVXRCsvNVljWEJvanhjaHhWeUs4WHVLRFRCQ29uZnIvWnJXMTZYaGUwN3U1UGYvKzZmUnhldFdhZEZvMGw2RGkyd2hKUkFFUUxyNWVNWmtudjkvUi8vc1d2bTRtYVY4MlkyRXpqb1FyWERoNFR3OHNYaWlDYnlpaDQvL2lsZTUwRmtiYzZHNFhWRUg0WmZ6RVZmMlhHMndHb0pyRzhIaisxVVFhSTI5RFJCcG51SWhGM3JQOWFLUjVCN2VCSE56R1FkYjYwSC9UVEdjOEdvREErdTZFejdFUFVteE1ybVY5cnptOTgrL0J2WURuTlRMeWdFcEQ1STViK0x5NytCWGFrWEFxSWlMTXpMdmNPZ3dIZDVVa3g5a2xwbUxTbk1OUkxlWjdiN1hHUHNtdE5HWjVwMHliK3lNVjZ6b1pnU0lXcHR3Z1Y4OHVUcCtBNHdrT0JnbXVvQ29HV3NpTjBnRkJzUVlTTUFUZmRaZVJMUGVuTzRpallYb2RJYTdyVzlXemZFSkRvQmhmbkhvUlVSdzJDQXNBRmF6T2NhNmhBb21BYXh6TFFtTmhXUmpiOTdSa0JlTXc2K3VWNWhBRW5mQlNnS0x5UFBLVVlTay9UUEJsdHIyanR1blA2a3JWWUQ3eDhFK205MlpOcDVCTmFLZktubG1sb0lGcHpGZ0FreGd2bHdnV2w4TGdwQkpaSURqTDArU2w2YUJxSXlGbnNyeWloM1NoU0lvSGlmVU5sNzlxemp6SHEvZVpTaU5EbEt1TzRGbEQ2cjIrcFBqMTltNFJiNWUxZFkrN0M4SnljMUI0UVM4UE1MMVZUV28rak5PeWtmQ21oWFJrUEV0NldEckNTZzd0M2Jydk5rblRmQzNpeklaUzJhV1h6R3dPMWp5ZUdVVVpEYzM1U0FPYUtGNGFxaXBWNGZlRlhQbENRaFJ2Z0xja2dpMUpmc01pRk1VTU9wUGl2UmFVa2xBaU54RVZHZis1andGUUcxM3pBdEFzOWF1bWRiOTJWUHZnaTNYck92TUJUcmk2N1FOR0ZsbjBFWEk1emY3eFJGbHhwMGlXWUdIV1RkY25XdWhRMWhOQlJjRmpuYTh2Q2E2M3I4RTczMTJqVjl1WTRJckdlZkJaT2dPei91dzFwM0R3SlNWanVNMXlFUmhDdit1TVBLYW16N2IvWktxQTRqU29sUEQwclJZV0dhb0FtenhhUDNIenhLUUUzNTJQSDFlRm1RNWtNZEd3RHJ4MkZaK1ByKy9iQ3g1RURER1RtTkFtZHRianhjV2xQbGJZNEdJNEFFelY0WGRXZVpzU0ROejQvVGVKVFo4UWhHMTlEbVFaQlJCaFQzNE1lc2Y1WTlPVk9yam1qWGdhdm5rLy94di8yZmg0VnJENzAvZStmZXh0LzQydWo1M1l0Y0xZdjhwc25DRFRUdnMzdVN1SmhyekxuZFc3Y1NLakxqeTNDUE1EQXgvOVdEOVhQbjlwMHdvWmZqZFQycUZWVGJhRjBxRFc1c2JwcnRWdGZCN0lDM3BaNS84OE52eXJMdmRPa1dTc3FCdEFBQXE0VWt0VGM3QW9nR0hCc1hFOUtNbUhmZ2NBazhDem1JcFpWbHljRXhXQ3pLZVVTZEZEa0xNRVFLTVJIaFdUcEVpMnZPVXlDU1d4SmhKcWdRQmVZUmV1ZVhteU9pOFRCK0RHV1QvRmo1RVlGcnJaanI3MWlzRWFreWxpbG0wN2IwM1M0OTdqME1NZVB2TDkxaTFqb0FZSGRuTGN1UElDNDZtWlp6ekJtR2tIL0NqVFBQY2E4eDdpK2xTaEVtclhsVVNIaEV3ZnFDN0diV0ZHeEpNYXhnaEt4L1FvdVZvek9IOUJEdG5OWDQwWDVIcFhEc0IvNC9mdjU2OHVOUFR5YS9QSDdWL3VVS0hqYS84OWJ4U242YTNLM3l1WmJySTErdjhOTXY3VndFT0xnQ1AvMjAxL3BVeVYvRi8rMWJXNU90MjJGbzNjZUpMeTFnTTUyNldhd1VtS2lEY2EyakgwcHdnUHF0NlhETFVuYm02b0FLYTlpZk1XUFdRZ0VTT1RyU0ZlVEdPZUJFZStpUk41VGdsRlFKMHh2dG9WTXlTcC9JK1gvSzJXci9DYXcweHJqdlZPR3dQcjVZV0lSWXUybHZyYXZmQ1kzSVpTcThlaDh3UFFUVTJQWDJ0WDN4TUkrcGdKclN4UFhmM3NNajB5QlRRdTRMM1hqL1doRDUzdlhmZnNmZ0JLY1VCQTlqY1UvN2g0SjhkcU82UWNuV1RpS2ZpWWhZSmlMdjh4a1hEalJXWG5ldkJwc2licHJ1eVgxYWkvOUNQN3NPckhobThzYy8vbjNyekpLN1NpamQ3L2Zjc2E2eFZiNldzaHhDa0NjRVBCY1FlNTluTlhnSDdTU3d0RHFIbnhGZW53cDhqQk9xc3Z5NDlZY2FDR1JjeUFJWWZCcHg3TzIvYmkyenloSmM4dlkrU0Z2S2FyUm5iMHFWT25CYWRQU3hOUTZLU1RqRktQL0RmL2MvUmJ0WnFvTVhXOHRIWCszK2piUUVPVXlrNGJUNW5OWWE0UkF4SUZ6a1poZWcyWWxZRVMrZ3VFNmpJbStBY0pGRERBN1liaTJIMExEWUZ0L2dMSWk4SGtsbE5na3hBcmVuZ0hzZ2FBUHVvOTJmaWM3WFRkbzJXTUtHbGNkYUE3NWpXdHBFOHppQ2pFWGxXdkExeEFmOHM3aXVZVk10cmp3d1JkeENxLzZXM25Ecjl0M0dsREJJRURDUlI0cEU0MklkdXU0VVdIYVAzRmpoMnpab2pMRXhYUk9YKzdxbno3RGlXQTljTGxhVWU3b1h2OTQ0TUtIMzRGWVNRVEZDQSs5dlBuNXIweEp0MTFseDNXblhtZmVyYVRlZ1BHSGxtSEJyYWsyNnlKaXZUY1gwWERLVisyL2JlSmFHN3E3cldjbUx6Ukh3L2VLNWZ2aWxlZVRMVGZPYUVyU04yWmw3RHN6OTFIYy9FbW9KOUlOU0xKNDgyU3YvYmkrclNwcEtwRjJ6dDdtbDdZaGZjQ1VHMmIyYjBpZzZWU1JLc3ArajUxL1gxdnFYWDE2a1pBckNiQWhETDFkSVhqK2svNWVzTy8yeDdFcjN2SDR5STZlSW5PZE1wMTBleXE2cVcxWDNkbFAwdmJjUjl6WTBxRVhUQWw2MGhJUVEvQy8rVitBdlFFZ0lYdkFHSVdpQldqMWV1cXZzc3N0MkRzNTVqb3pNak1nTXZwOW41Nmx5d2JaUG5oUG43TDMyMm1zOXorOFoxN011RlhqSlBDSHdhSUVxdDVwajkrY3pZeFlDVVErSFVRZ0hZeVVTYU01OWoxR0Z0RitXb3NLNS9pcm1VVHhRMHExbEppOUg0NnF2VERNMlQ5b3I3Y25sQkJRTks1SFEzMmdCY0M3Z1pnYTBQYmxDVFFWaFFzQVFWbkxlOU0xY0FRbnpyVS9lMGJIWE1vOTk3aHpBb2kwSE1QSU1hSHdKSkJGbTJPYVA2UWF2K0k2VjRuejB0cjdPK1dpSy85ZzUydEl1V2x1VzBMM2I2RFNuT3I2NGxCdUhNZ0FjYURWUFdzaCswTUp0bXZmd1VGcFNyb2ZMbDY4R2hPZkcwZjNkZDkvVmZzblJnZDNDOHdJc1R4clBKWHF2L0F6ZjdwTDRMSGx6c1NiNEdpV0FNMzIweFlLeVNGNTFEMWIwVk02dHZ3OWFLa2VUSit6VmZGZjhqK0JCd3dKbUlvaGNPT1BzYit5MlcvTEhmVFRLVVcwL2ZIQjd5dU1vYy9VUC8rUC91bkZxdkpJTGhNV2gyK1ZOR01EWktEVmlzQU96NURxYUQxdVhCQkhhWjRxTldTS1EzK0FwOEdlQWxpSnVPV2tES3lCRm1uQ0dNck9haTBIcm5aeDVsODVmbUYwNkVDUGdBUTRQSDFFakdVREx1c1diZDdMdHAwaGRhLzR5MGNMVkZ0U2VucDFBbnVibk9uZjA3RENzblVHUUR2TlJMZ2VDbWUzYkF4c093SzBBemM3VXdFZDJlYmc4eExpVnI4VkNULzRyUzJ6a0RTblhUQUtJaEZCQmdZR096NEEzK0o3cGFFNWVnOFdYSWoxakxSbU5BMEpqdWtpdDhHeUxDaS9KVnY0UFNSN0J4aXdBQzNITEpadkV4WDREWlBIaG1HSVBpOGp0dkRvYldKWEExOUlnVG1KVkdwYWxRRGx2dTliVzhJaVpCb0FGMWR0NkV1Z2NTV0xhZElNd2taWkNmVDVlVk9kWXVUcC84eS8vK2VyeHZSdHBQUmVhOFRUcDJuelQzQURnM1lqMlZSTHdaWFA1OEY2cjhTczcvU3F3U2xaTm4vY0NBRXhmTUwwS2ttbEluV2MwMGNkdXo4RnRZUG1XTllnbkt6dTlsWVlvekw3VnRsT3pyMTZNTkpwRjR6T2Jwb295QjJEbTNKWlNIT3ZBd0xNTVUvWmNDNGJscDBxN3dxQkFmNVVtUlpMemQrNUcwTFFxK2lsTlN1N2FzakVHWVZEZ0tDRW1RWEUzRURza281OHpIdTJtY1ZGWmxkeVpTRzNDMmR3QUtXQzVteG1pcnl3QXdtam1ybjRDMVc3VG5DV0NhbitXOHlRUWc3TG1ZZ0VrVEk4bTBBSmE5STZPUEF0L29yODluM1BXSU9nNzkvRytwcWVHZG41Zm42dGRvSVkvelR0YUJDd085RTh6dkgzM0Rod2UyaUtvRmNoOG13OVVJVUhwSTg5Ym9uYTJkYnNzb0NkcC90dUhYa1NyajJ2dlRVWCtQaXduNi83cTQwOCtXaDFwbko4WDNidi93QUwzbC9td0xHUnZIaXpkZVhXd3Y4K3N6aDQ0Ty96VG5SdUx6TzdlOFI4ZWVsckVVTEkxYXdkZmVFNEhQdVptc2tvQjZxQlQydHZ3UitNckhlcmloU29MUjh0NFUvRHJ4RloxNXEvMkhJMFpnS054enBaeFBXODEzUXN6Vm1lZFk5dEN4a2VaQnZZNTJ3czU3ZVdIWUZRbFZLTjlPNlpXWitmOWF6OWFRQ3prVmxoTzV3MHNOS1U1Y2J3YjlKTWxneHAwV2FxSVR5b0QrNXdQYTdLamt5eDhVM3hVekwzam9hd0toN1FyMjN2TmhFWVRRTXlpV25sZmNxK1dpWHVhNm5zbk5iZUl3anVpQUFEUjFOanR0QnhFUmdNa3BXbEs4c1JtWFdDTVNKTTBDY3FEeU1vWFVjTjRnT1hKZ1JJZ3UwYktoUElvaHpGRld0b2lqZjRRd3RZLzRDTXgwNDM1Rll3RnlZMEpJdjhJc3Y3WFB4RGdzM2ZuaUpxeDUyUFo4b2ZlRnVYWjZmVnlkVnBKMkhrZWtyWjJaZWU2TnJEZ0cxaWN1UTFLMTcrSVNDUVF2dmYraDgzUGhkSVZhSkZwRjQzMWtZRHBULy9PcjBxT2ZXLzFULzYzLzNuMXIvN0ZQODFwdmRzbUJwOEVNbW1tdEpXZWlYUGNidC9iRDNOa2wrVmZmWVUyRGlxQnR0SXNDUHZoZGhwQTN4R2hnaDRIVy9LVDhKN1hWcnUyYkZZNTRIUVI1YTJXTXAwNXM5VXVLZWRYRi9QSEtZdzR2c3ZHQjFBVFMwcVZCSldOUjMrRkFud3RUSmxoOEo3SE9MMXMzQkE4L3haQllCY2tRQUVhMXN0dW1CQk1lcnYwaUh3cVVFaWFxNFFyV3h1WUNZRjNtK2h1Q2J6d2ZZMHBXVU9ZZnkxc2FuYm96SGR5NTRDcC9nd3R2ZnM4TktxeEJNL2tudFZ2NTlITTBMbVhhMzRJUm41dmxxZnY3dUVjOU9JYzU2Ni84OWx2RHAvWHYzblhSOWNNSC9RM29hbitHN2VJQUpKOEtHYmJSS1dUVXBISWpQbDdIMXhPVVRoVDFQNWVnR1ZseU9FcFRJa2YrWTRBd0tYeTlHelNvbTBnVDNEZ0IxbzdnU05GeDVaZDQxOU9DUUVjeWc3NTIvcGJmR1h6Q1dBbHVMTi9ZQW53YUp2bTlOVlhYNjllOVozQVYxMlA5OW9LTE5QUm5GS0d1SWR1M2JvNUFPLzVBYjIrMEJUbFh5cElnT2Y4cG4vSjRWTDY0aWdnZGVUd1lxSUp5VTZFcHNtZGZLSjhCcHRiSW1BVjRVb2o2WmxpYnFISTdjS3I5cG9ySVN5bVkzS1JLQmpmcHBpTHByVWdMSkRDMEZMd3ZhaUZwQlkxR0lnQksrYWlaU2ozMnhySWhHcEgwaUdKSUhYZ3d6TFNMN1FWMGZWVTJaR1NhVGtBMVA1c0FKQlV4QlJRbTYyT1ViWlNWd0dEZ1htYXhzZFBoZkV4eWhCZUF4Rk5UVjkzMnFoQjZKYXEvOEg3SDBSb3FhWDNIMFRZdmdza1NOYjZTWHZTUC9jeHVPNDVnLzFPWTZHbGNYVDdiWHhXUFdka1BlRGkzc3lFK2RNL0haTXdXWC9Ba24zaG5sUzNhUHRVRHVva0cyMFdZL2FwZTh1bFVsZGU1QVF6TWp0emVPYklmTy9hQnpuOEw5VldLUktrZW9EQTFHMmdHdWZNdEFvcy91b3YvKzVzWEhzL2FieGRTQjZnOG11OWFrNkIyMDc5ZjUwSkNoU1cvbUdzeFIrMWVhWjBpMHJoSEd6OCtNUDJBbFVKdWlKS0NIdXpnTUhSOHAzVXBEOWI5WW1UWjZST0xCb0dacUlwSFN1aFZycEZqb1loZENyK21QMHgyWnVZRURBRGZqc2lJMXhnNzlvQjliNS9uVjl2bmZqWnFBeGFXdEJOaTFMR2gwUGRvbWZaM0tkYVRtYlRWT1dGSHJYRkhMK2xaVTlNUGFPakJMVDVXWU1EWmdKSVFIR1psUVU0MXZPRWxtWU9aMmlBYWtPRWNEcTBzMjRMdUtDRjVlLzVlZjV4N2c5QmFxMU5lZmZiK3ByMU9mcmxNLzVZMDVjMnRZOCt1VFk0eXRWdXc2UDR4TVlSdEV3Z3hieW1WS2hnb25MSm1UTVhGcjVzY2tkdzFIVk9lQm55ajlLbXVFaG9WSElPVHpSMnlzVThmRmlkcStoalN1TkVSMERNanRHSDAwNVpWVFMreHdtNkE2V3N2QzVJOVBUWnZSU0hyVklaWktXL3loWHgvV2gzc1U3UHdnZE95OHc5MUhXRUxyLzJpN0JHb00zT09hN1JyamxuM2xJMG5vWXhoSm14V0w5R0EyYkxzdC9KQSthSEN4SEFWcEVnMUhzZ0NRYW9GTlJDV1BLcWFDelcxNUZlYXQ5d0JrSkJVa3FVaXJhRnVURUdBdHdLa0t3N0l6VmRZOUd5YzYweEUvNDM4TlJNV01KcCtDeS95dmxNeUVzdHpuemI0SDl6L2J0WldrSkxtaEkzU1ZNb1hwZFRJKy9ONTNFbzE1NUlwZ2wyTHdkTkNuRVlCTmZyRjVDK0UvTXlTMlpsdW9hYVVQazJ0MjdkR3QrWVFZeS9HbFMrdGpMMUF5elB4ZlJVL2NGRUdFamZJenJtb09jbE8wMktlOUFJVEpRdkY4bUpNUmFDbDI1Qkt4RElzRjZQdzFoSTMzcEZhN2g2aE5wODU0U3VmWkpIVHRlTGZGejNLNE83bVJENTlMT2Z2MHUrTTNhQXJEeW8rbGNCemhsSGF3cVo5U2R5MFA3RlgvM1Y2b3RmLzl2Q3hIV2crYnYvNkg2VlZDTzZPcmViTm1WWmszVTcvSmFpU1NkVDNmbXE3Tk5vTTAwcS85RTJVWDJkYzF2cUJHZnY1dEY4T0gyM0ZXaWRDNnpPbnQrTVNWb1EzYnE5QWN5ZUJ3T05qekNCWk5VRDV5MUdHTWExdHFOVGFRczdqYWtnVDdqUk5VeVJkMzRqM1FXeXRXVW9wWFBNL29XTkI5T1dVR0lLR24rNVlCaDZPK0IvMFZ6dUpuQ1pMUTFDZEJ3NGpBa0g0TGllbDNrVHhRVWNheENxNDkxa3VyWGNiNW13WmY3NkhtOHd4ZFpBc3dZWWMwLzcrdjhkNk83ZGw4NUZtNjc5NGYzV256RzAyOUh5MFphL1JXVzdiQTdQUUlzSC9oSnJ0V1A1bVlvS2gwdmdwaHdRc2x3NEhPY1N0Z1ZqRGxZZ2N1cmI4eU9tVUNnUDlLRG83OU1BL1doT2I1cHExRnVwcHBzNTg5dnRLa0E3bjhiT1lwSldSSmdyMEtqL0ZCTThEZURsZUZsbGNLcDMvTXpWNHYxUi92RExWNjZPYXdpZlNIa1JBUmE1WnBKYnN3d1RoS3NwRWdmU3hLeTJrUEFMSFBuSGFXS2QvUHRuZDgvaldSQ0htSGVZM2lKU0U0bEpNQ2JISTZaVDhlQzc2N2Vtd2VmUGxnV1p4eklETUJSbnQ0ZlFPTVkxd014QklXeTI3RXo3UEtReUwyMmJsYWF6cEVrY3pjbTdyTDg2c0puVVRaZTEwcDdqMm9ReTAyZ3h0b3FubFV5NW1RSEJ6TC9zWVlCbWNxUXluR2xwZ1ZwQXN1eFZsY0JzSk1tcEpBZlFVaVhVZ2w0QUcrMU01R1NjNUUycWlhV2RQV2xTcEJzb2k2T1FINGxLU3dIaWxocFlGOWhVVFJTU3Fja1BOY0FlczdnWEZmZE5mcE01dWtja01oTWt3eDROSSthRjdtc3hycU5aelFEMlpmU1VTUWljTWwvS0xiSkg0bXZTTHI4VUFuVnM1Sk40RTZGdVB5K1I4MGtsbkIvZlcvMzhsNzhxVGVOaXp5QVZJdjlMNlFUTzUvUTJIM0xoRUJWaXhzUlhxc1JCVXg3bmUyTjZ1YisvK3ZLMzc1WnNxQmRtblNmQ0JGaFcrSmR6VjdUUnVFMDVuQUQ4VU9Cek9GT1Byd3d4Mjd5aWFVOHE1N3NTTk9oMXZDem9vK1hBalpldGZoQkdPeEd4UnhIY3NUeUxXVTZpUzFZVlFMSHJpdjN0OUo5VVJhVzBMSXhMSTBhVFRKWU12LzVHYjB0dWxwTFVXL1ZESXZCMnpDa0hETjFxWjJwb05YWTAzWFhPa1BIZ1BrQ2p3QVVPOEtjNjV0MGtkWFNMWHN0OEFoTTBEbUFobWJuTU9PMDcydGJDTDMwNTlFRURtSXMxMHJrT2pEcnZuYXNkN1kyMjFOOEQycjJQaTZEZmpMMCt1Yi9QRkFRS0JZdkVuQkxHdEg4K1JNK2xMYzVxOWNpa3RJendqSTlPeUplc2pWTlZ6bEFDaVFDOWVWTndLazIzaVBUangzZkhaMzI2ZTB5YVRQMitrSll1OVdEN1JadXJOT2RXUERESkxsdzRuL3RnbGRiMWVCU1ZjOVdQaHc4blRoNk5YcDVHaXlXUVYrSWJiK05Wem4yL0x5YTlaVzlTZmNyeExHZHN3UWZtZmo3eTZIYXovbHNpcE5Jd2paRXloTzgzQXpIUE01bjJhZFRTVjJac1M0ODV4UG5HVWY1NnQvSXhOV0taUk1OVEk1YWtVRThieFB4Y0Z2MCtlUUs5ajQzcUo3RUxZRW51bzVuSW5US1luSFJwcUtHcGJjcVhyZDBmbHczOXVvNUxSTnRKVTZ0ZnE0czVBb1hkOTJQMDB6R0krYldEcytRK2VUQnM2TU5KMWQzRHIxYy8rOW5QaHNCcFN5OUxkbnQrOGtXVkY3L0ppZjlnSmwwQ3E4R2VJbWExT2RwUy9lTGZ1bGlJZldQalFZT1Z2NmMrTGtzOGRtYWZOU2J3czN4Mi9GZVFIcWc2T0Z4emp3NVF2bXp5T0hjUkFFQlU0em9LS0ZLVnRtbGlJdXczRFR6VFdBb0RvbkU2SDY4SkluR21VRjEwamlsUzJCcXpDTElUZ0tEN0NQVS95SS80NUhsQkJJdFJDeDlmT0svNFcrZjEyMkhxejBZbVcyTkZldTJsNVp6SXFZNmczKzR6NHpNWms1NThkTUNWcjIrb3ZuNlIxSHdWNnFtZnVCQVJOTkJNZ3NNbEJoNUxtajZ1anRuOTcyOU51d2RMTkhUKzJZQUhReXNicy8ycUZJMEV5TGxMeXJKRWFQMGVTVFRlZ1QxdHJOK094eUFuenhVVkRPUVQvNDFQUzdDS0hOUHUxcWFGTXNDdlF1ZERwVVE4THJKNCs3YVNOZ1FNNGt4cnEwK2s3R3pOM2hnTG1STmViMHRoT1BoMmNUemJLVWlKSERzRnpTNU9TZjNkVFBEdENONVc5Y2Q3ZnBvQUUybS94ZGd2cTVoNzZFQW1VL1Q4TW0zTHRaenZBM3JOQjRFTUxNd2JUUVR0QVNKak1JR1JRR0hvSWR0bURUU0U4VGpxQXlsZ3RGWC9Kd2pTdks3OVhxNmhpUzFnMWYwQ3VkR29BNGFHdGUvZi9kYTlwQTI0bjM2L3FQUTA3YlZ1ZFBpTzRGT0FNTDVMZXdTV2VPeG92c1AyMWNxa2Y3SDY1T1AzODcxZG5CMmdhYjNLa1hNTHpQMUhVK04rZWRIV1gxZjdyclNqSXRHblRzZm5uWFAzM29NRTVKMjA1Yk1qUkpDMnRaakhhOE5pWlg1ajdwMmNOcXZMUllqVldxK3IwZldTYWtISW5DNHFEVXcyVHJFT0Vxek5rZkc5MGhyR2gvSFc3RUxVMkJybjI2MHR0cDd4UklyQjNidjNpeUlmWGIzM3diWE9EMHZLSTZRMGJEOS9GSC9ZcW05Ly9HYUZzMUxFcXJOdjk2ajZuSUxSZ0lSNGtOb09MZWFJaElKMEVQWkVqam9vYWJBZ3FBR1dqQ2dxS1BRNks4RkRjUFdZK0l2azE1Q2tzckRsYVkyVVJCQXhGUWFHeE5xYVhLQW1uQ1RkYUpKTXFtMjIrYlZ1WGFmUkhWNzk0cGUvSE1mY3pYeFhKQXFVM3kxMHI3TEQzQXR6TmtqV0pMSGYzWU1wUjVLbFhFY0FtUmpkZ3dsS0l5UFJNQUVRbHZQeE1xbk1YOFlQZGlVVmxvcXRCQWZnR3VrWklPanIwY0wzSmdXQm1BeGExVWpMMnZPNzcvUVBnVGJuUThEci9Ddm5yUStmNVVGRnNzdjV5NmV1V2Z4bk5odEllU2czNVdRMmZNdDA2dHNwQkloUmUwN1JGWUVBTy9lY1A3OXMxZlJpcCtLSXROdUlxdzdVbjdRWkRBQTR1eC8vb1FEQzhSeXFrbW9YUXpsY3FkMGpiVUo3TUROUXpvNWRWMFJESFdmemZXQmc5MVVaSStvTmgwU0VBcGFXK2FnYVNXcHZxaXVlU1hIbWZDVjVFekxBMHZlQVN6NFBNL2JSMHlvODVHcEFzTklMYVBJUEh6ek9ITDJYVTdlTmJRT3JVNmRLaFdpWGxMT1RlSXNtK1BwNkJ0elJNekFoNTNraVdNTE0yRnBycXI0U001T1FvRDB6STBsMk5DSkt4cjRVcmVRWEdiZkRLRWswbE1YVTV2OWlXdWtiRTNZQnlIZWFWL09KZHRZdlk0a21hdFFRZGRERDNXTFJta2cwM3ppSEJyKytidHBPMkUvRWZTNU5heGUxNkJpelo2NEpFS01KZTJmT1ViOUhHS1VvekgzZXRlYzNQR2dydmxuVEdEQVR3UHpHTkVJMDhxWlNSUy95SzdFZTFodk00SW1yVjY4MlB4YUM4enNGQXhXcWxBWjBwTGJQRmZDeUN6Umhabkh5d1Y3TWJkZUpORXBKQVNaOHBQeWlVeU8vM3ljSUVMQU9EemRYWjlJQXJTTGhNdEp2UUk0SFlRWlgwYktzU0JwUTlOZjhTY25aKy9iYit0cE82RC82b0t5QkJ5TUFsYUN4WkkvYlorZmx3d1J3ZkhXd1NxV3R6dDg0dm5Ya2N4bXlrczVJRlFPUElRRUlhVFBFRUlGSTVqd1N3UjdQNUhCRFNDNk5YL0V3NXBFT1V2TkVEOVN4c2pVMXdrUVV4eUp3YlNKQTJvQkpOZkFtWlh4RnBpc1FBUnhBUTZqelVzbW45KzdmR3hPTjQ5MWkyOGM1NGJWbDdhSU1YK2RyODg2ZE80SFp3L3JBSDVKVXJYMXBHb0RZV3FVaC9KN0xBTkN5K0FVQXFYQ3JSRmRxc2JDdi9CR1RTYXJvSXdMdXNrZ0pNQm1iZUJjVGRkQ3V4aXpzUEwrQnBRRXNuQk1SZXlGYVA2enpqWVplK3g1cE8yMk9QbVQ0eElEdEE1YzVwYmI3WlZuaWUyMFJGdUZnVExYcUZ5THYzTXdmeWJYbk13ZjVId2dQQ2JiOFFOSXVocW1HU1psUk1XOUV5c2RqS2NaVWtPZzNtaS9DVTc1bXJ5ak9GREhNTVgzeWFLV3NFeHByQmUxb0RIVEV1cnVJMXJJbDVpU2ZuM0UvVmpSVHdUZWxxZ2s2OWQ2Qnc4bE1ScEo4MTNLUjFwQUNDc09BSVlXMjc5NTVzTHIrN1kzbXpOSU5ZeUZIajBZZDg4UmthTXc0VGdBbkJ1RVFIZ2M4K1ZySEp2K3ZUR3k2NlpsQUc1QjVkbVlqR3FMOXFCeWdJaWtCQVBob3lPTmo3TjFHc2FabkFaWUZsTWJjcUlkcmtGbUV6SHFDYXFMKytPNkh2L3ViQzJQOW5ibGNDMmR0dThkY2t4RHh2V05wZDNrZjJqSXEvVFo5b1ZGRlc3TXlaQWdsd2RmOGFKOVdSOWpYN0lBRERabFNJZDhLZ0Z1US9QNEg3MGVUaDlPYTJ1WXI0V1FKalhIOTZLT1BsbnZrR25qV3VGbkdjeWlnMCs3Vks5Zml0Yk50ekhxaE9VekUxNmIxeEp6aWVJUy8xbkluZVpaMktxSk1qQmJkZWVadHN1UnJSNUkzM3lMZU0ycDhWckx3WjBWSzM2aGZWa05qaGFFaHY5bHJrci9LUGRITUZBa3RYMUR1bGJwNG5vdWcrdE0vKzNrdFJOY0JyZTNpTmo3NDhPcm5xdjhCSDF2dmRQOUJhdHFWeVFkWUJtczkrQTEzVW8wWnNqaktsZzBOMGpJQ09DQ0VOTWQvaFRqaWQwNTVBd0RJSkpyS2ZKWFV4N3hqVWpMRmFDbVMwZ3pDUkI4aU1zNUZBTUtHTnZqQ3NCOTkrRkhmdTRkVWpLcUxOc0dqOVNIV1p0UGtRL3VwN3BDcFN4dmhoSFFPRTRmVG5YVEc1RDd6bzkyN2UyL0F4M2MwTkgwQ1FLUVZ6WXkvNUZBcXZPOU1zdkh3Mi9xejcybWpEVmE5YXZDaVZIM2hHL041OG5oNlI0TWtNRC9LZkhwSHhFekVReTJjSnRVMmM1eWVLdkoydk0weGoxWndFS2ljQ0pTMm1qejVTeHFoUnA4TU5PVEhBVzhBNXY2MEdRUHVIWEM0ejRFYUozbWxBRmdXSWNoZy9nQkNjRnhPUytmVWYvdi9iYVk1SFl5WlJkWDRzeDRYeHViN203SEEvQ05vSlBWeUVlVG5UQ3NUak9DZ3Radks0elNwK0xkN1JqODlpMEtQNnpTUEVVN05HMy9vblVwTzN3KzB0aXZMekhmSFYzRTZwcUUxejlveGJienJJMjNkUVpJN2VybzBwOGF3OFQyY3hING9ueTZhcFRHaks0R1ZCcjh4NlBtWlVEM2xzcUV1VndWTnVEWm9Pek1QQ1kyK01GZUxFT3FjNXRYempqbjQ3cDdtMlF2QW1Ic0hYaGgrcUtVRmVLUW1MUFBxOXdXNC9PMno5cGZydE8wNjdXaHpmYUE3TTJLdStPRE1NNTZiWk8xM2JUakhvbU56akZkZHJ0YlltZklVQVJBNmYxelNxRUNXRlNSTGxRMEE4R0oxNi9zYi9hNnlSd0d3RkE1S2h6N1l1WHpLR3lYVUxZYVcwMFhqZlAvYWUwTjNkVDBhYUtGMy9HTVZDYTJPWDVsV0RiaG83OXc0K2thWXVLZTVwbFZTTWd6NHVDTzRKTG9mM0FDeStnOFFhZUdHaHFaNSs4NzNRMHNzcFNtRDAydzcvdVNYbGhwVlkrNkE4bEJWRXI3Mi9vWFBkZElrMDBiV0N5eG45WG9kbWNoYVdvaUJmMTduTFBJMUlOUklqczNaWTY3ZmFGUTJiY0Rrd3Z0RFFKa0FUZGtRZ2xrd1lTYkNPVjdzYzVLVVJtTmpDamxXSnRlOVRLajFUclFrRWhZUnVFWWlJL1YweWJKZDFGYmdaN0MwQS95WW5kcDFUSlR3SGJEUkdEbDdEYkNrVTFxWTNCTW1ZUE04aElzQUVTNFFHTUN1UDhxZElEVFhJVzc5ODdkakpxdm5HdkliWWx0QWJXMDJEZ0YyM3Byd2gwNTdicE9xandDQXZiN2ZQV2xaWndvdG4yaEQxZk5ua2pBUkNDZTZvb1h3cmJ0Tzl2aUp4b2xraWpZV00wOVcvR2kvRnNjdUJMMFpVUUFtQUVXejBsOEFSSmpzQnM3UDhvVTl6WmYwNU43OWVkK3h3RG5NczlaU3RGZ1U4dktWOTNPaXRwWDUrVXZOZTFMNzdJVlpOb0hnakI4TnczaU11UlZJQWhZbXlrU3FtcE9sQnBxZGxsb1JVWFVIMjNQZHYvTTRNQ3hMZmFmTzUzY0NQR2hpM0JIMWxiTjMxbHJXbmlFMmY5b2ZKM2dNeFB6MnQwSitnaC95c1Bpem5oUUd4NncrOHkrS21nWU5jOTRVV1J4dHk3eUpTbk9hTC9QM0J4Q3E3ZVp2YUsreHBYV1pzelV0T245OWJvTTZ2MDBIKzR3MmwrYVc4NWZ6aGlKR2MvRzd0aFp3VytqRDM1aGIrODRuMk5DdXNhQ04rRzZtYjlvSDJNQTFaby9SalhrVU02YVUvZitzODVQZWNDeXJ4elhBNHB0dnZoa042MlE1VThBS3I4SmdXdmpUK1BqbWpac0puRklLNGkvYUZVdmpiRHhOSzFNUWNQSVlHMHY3SENCcllBL3NiRHFqTCtmSzU4S1hpWUh4MlM3K3R2aWhzU2ZrV1czam1xaXZsQm1tNXUzcXhsdHo2L251OUZtMFVqQ0YwQU5lUzNwU21RRDVjR2xYZU9nbnYyaXpta01DTWdtVDhyMXl1bGMyT0taa25rRjBBSFUwQnhkaXA5b3BMOXo4NWp3TERTOFVoYks3UzUwQURxUFNkZk85VnM0ZWlNbVVkNUVvcGkwbFJtaFMwQmh4czFQWjlzdkV0NjRwUHczTmkwbG80dlNCOXNQY3dGaStlMU9GVW9RSzZGNVduL3pDK1lzTm1DMmxGdW50WGxjcUZ1WUFIRlJuQkdCU0ZxQkFGRWt2QkZpZjVZRkJjNFNoWGFEQk1RK1lmSGJ0YlBmVk5VQmNRQUpodWI5alRPWDZpS2kwNitWNW5LTTZveEk5MmxpLzVLSGtacGx6bXVNbWpmUmtYcERpWFRmRW1ycGZsQ1UzWnVNWmN4YzArUENEVnRHblRSaHpqbUZndFZsb2V2VTJZa1dndEp5STcybjFqcFR6RlQyaW5VeXVXVzBoNFBTMkNHV0p4b1M0ODh6SDhrV3A0eTVwZEtNNU84SWt6aG0vWXZiMXNoVG4xS256U2MrY3JJM3I2Y1liS29ienExczNid1V5dVFYNEVYb3VrVTRDUkg4a3BESVh0b3RXa2JnUHEvS2dHcXF5UVNwU0tEL05UL25vd2ZNQXhKSVpHbThNcVRJb1pnL3VDUk0rRkRDQ0JuM0FCRFJtd0FlUVg2VWhjQTBzWnFiY3JwNDFFNVlQY09wOTVSeCtsSC9IVXAybkx3cmdISzY4ZHhtSEw2SkxTME5vVjRkYiszaW8rWGNBR1hNM3ZwcVptZ1ZrMEJGbUhHRG9KUFB2ODNKTlFORm4xMWxpSk5QYlorWEIwU3phUUV2eUN1ZThuZ2w5clFFTjNmMnhacmYwWVdpcmZ0RmFhTWNFWnMyK2F5OFRPZnFpMVdwM05zM3RYcFFNSjlHMnYvN21kNjN4UFRlbUdXMzFzODkrVXIvM01yOGV0QlR0UXVQNGVoWkVuMzJuQkREek9NU3RoamlYRmZNOFFXNHVYMWpHMVpqYjEwSDBubVhERW5uMU9pMG4ycWVvT0ZoTUl0QVVIRW9GemU5WWZpYm5qWXVsNzQzYjB5TGJmR25XUFg3d284eldoTjNETENlbVB2eDQvOXJWbVZ2UHo2ckwvOUNjVVZvb0NOd1Z1UndTYkluczNDUUpOa2pLMXVRRG9NSkxDaDB0NTEybk1MY2JUeFo3eVdZY3NhOEg1SmlPMERIVk1xbmFNNDR6azNiQ3Y4UHZjZWhJZG1wcTROWkdvYzBZVENla0pCajh4VlkvbUdQKzJZRGZUMy8yczVFU3YvdjZkODBCQWhhR1pjZUt0RlhHK2VLVlljanRGOVVCWWxOejVybHBoeXhjUUdSdzFkV3lsZmFYWDM2NTJrZ0M2OHRJcllqL1lZNTJrUXozOTB5dlU0bEZxUURxdlNJbVFKZ3ZoWjlMK3pRNURrTjF0NENRWXpTKzdtdUFGMEovSnhYN0RUQ3VpZG5rWXI0Wmk2aFZYd0VGeXBWSHM1OW1ZR3hOWmtJLzUyY0ptZ1VCSHFhTkdKTUxiZitsQlg2QmpVTFJFeTJySDU1bGlhWUZlaEdxelRjMllrYWhZR2FKOVpyU0tTUVo3dE55OGk4MTY3VzBtTXdiY3F0aTNOV0p4bzdKZFM3L1FtMjhQU0FmcDcwUkUxcWMzc0ZVcVJybGZkVVh3SHFpMmtySDZ2TzVjbTVBeS9UcmJNL1FlWWd5S3BpTlgvZlNuRjZYT05vZTdwTVBKWTFCaHJ4MWpnb0NXbmIwZWhZdjE0MjZ4a3c1MEgzNXBvNldtakcrRkE3ei9xY05HaU5KaXh5K0pQZFdXa0hzbklsU0xsLzkzRzlKVGJQVDgwWlR3NzljR0RGM3RNZlFzdDdRZGVibGJYMlFKYjZtR3lEaVphNzZmdzYwQndjY2FNUzgwM2FXY3dpNWhSYTgwd2pNaC9QMGM2R1JwWGdmclFyaittMEVWZTBSYmw1REcvT1o0UFIzZ0JnakF4KzhSeUI0OXJXdzFoZm5BQ29ETXd2S0d3VWxoTkMrdW5KeDlBaVp4MDhxNGxma2wvYis0c1d6MWJVUHJ0UnNpNHNmM1J0VDhGZi83cThtZ24vOStzMDAzYXJyNXIreUtjZk5temVpQWY3ams4TnZ4a3dCekNjRnpvQU5FQmZJc0RXY1FBZCtDMWJHSlBlTXlqb1JMbmhWelhnRkRkWWdURFBqUCtaQ2dBY0NmSmV2WEp3MlpPdnpsVFdVOWJreERTTUlYTmhpYkk2c2Z0UkttUVIxeWs0anFGaG1rOUNQQnBpRUZoSGszYmQ4Z3dxNlZsc0JrWHlQdDBsNVdZWVlnWVMxRk1kNndyZHZVOC83ajJsR2UySTZta3o1VVJqWEpKbDRrd3FWT2NreFAzQng3NGtvYm5QRzd5VWRQcHNKZ3VMVVdmMXlyYVJPMHRmK2Q2UTNqZTJycjc2ZTltaERBd0FSTWpOQmdUR0JnY1hwcnZEWitWbXJKSGRuSVVDU1BLYXF2eHp0bGkxWXNXNmdtSWlpaFFhY2YrOTE0V2FUNHZBY2p2WGY4MGYvQU1KY1VXa3FuSkg4VUNYR3ZUc0FZYnd6VE9QNUVxRDFVUnU5YWsvMDdIRFJ1dmd2MEZRc3IwVEp0MmxEY1RTR08xaXF5S2tpZWhQeXJoMTZBRkJTdzBxSm5PZHBFd1BNQVpURndiT0N2ckdSRUt4UDVZNUUzT1l2ZjBSbGpOOUtxQXpjNUhlcTNLbTh6RWJwQnE5M2s0YTAzaGhCS1JmRXgyRXFaY09jamNUT2I0SXVyQTlWTTE2dE15YUc3ZGt4emR2V25TR3dTS1dEMDd5ZGh4T0NLa3BzQjFZMjNaaGRVaHI3alVNeFgzUTArMExPZTVvTGZOWGwva1dINnFBeDc0emhwTklvT0ZmZnpiY2Nua21vYlp3c0xmT29pdmhOc2NERzlFbHorN3pjTEZFdDk0U1EvSGpvYmcxRVEvOEJSZi9QM0M3QUZJRDBYQVA2TVkyNVhvTWM0SE1zZ21seFhXQXMxeS9mTGJTaG5ZWjE3bWxicmlYdzBrbjFBYy9RVGd3WUxkS3hydHNGNUpZOHdjWm43dVdwdWl6QUhwb3p2ZEVhSW1KbTdlNEc4dmsrQ2NGdnZ2MG12Kys5dEpZUHB0M3o1ODgwOWcveUhkK2ZjV1ZOUExGK3RoUWdXaDZhUjZ2S3lXd1daVDRhejFvMnQzTXNsd29mWUFLV2sxeFBBUmYzaE5MajBsSEdVdW41YUdFLyt2REQ0WlB2NDA5RkNrNEhjT2pST0YrOWVua3hMMmNNVTJZQ0xlRDNxS1ZnaDFNSW5nU3djdS9VZitzaGs2VnB6djF1bDNubTZkRkQrYkNhdjRPTkcrV29yUWlYTWhhRzVYUzd6UUFtS2poVldqa0tLUW8wQi9ZbUJtWnIraXhLdHppb1VYM1NQRDVHREVyTFFHd1p6VzVvNlEydEo0T2w4NlpQZFRLSk1QT3dtQlh1ZWV0bUcwRlVEb04vREZnOFMycERYaEZEdFhvZXQyem5ZbTFUd1MwOW9OMnN0U2RFMTdNbUpXNU4vNEVoUnoxcEJUUk5EcTBGMFFGSTZ2YlRadzhyR05hNnhDVEJ3WllZNklOemdSZUdsQWRtd0UxYVd1cnZDWnhrOVZxSWRQazhJQlFUallrWGtNamlYVWM4U1ViUHdSVGpyQjZ3Ukh3a2FBRHZudnZaNXRxSTdocER2a1RCQ2JzRWxjQkpRNHJ4aDVIU1oyaElJNUZOWGhOcmZkNXNna0I3dzZ4dHBKR2NqZ0J5eWgrSnFDdVN1UE9pblgxTGs3Q3ViRmV4dEFqdGNDYll3ZnEwMi9NcnJMYTNKOCtPRDdEVWdmb2ZUK1VrcjY1WHdxZWVyL2FQMVE1d0xHUytpV2pUakw2L2VYZFNJaXpNWmpZR0x5UEUrSmNlNUxpWDkyUnVIdVQzZU41OVpQU3J1MjdIbTdvNkdnT1hBOG5kc0xsTHhMbG9FYll3YjlSbkR1VUJIa3JMc2srZWhGaExzakE3a1BLc3pFbjlYaUtBTVR5ZlkwS1YzK1pnMXdGQkVlSHNwU1QxSHpRazlNR1J2Y3psWXNxYlc4QmNWNlkvNi9rR2NPWmdBYVYxRzJ1USs0RXc2enFnTTJaZ2RNZkpySjRXd2U5NWpKTDdOVlE5OHdKNGZUbHRyOStaMGVpRXhlT2VQbXZUZGY3bTA5ekk3NE5XcENxY2lFNXM0WFdpOUJCK3JLdHRCSU1IQ1lKSFR3UkkybUhuMnBWMnB2cmQ5Qi9ncTM1QnFGdVB1eDlCS0ZmenpmWGZSWHR0OTFWYWl4U1ZMMzd6NWVxVFR6NXV6RXNxYjZTbDVIejkyNjhHQTVpZjNCQm8rbXdXeW9QNEV3MmN2M2hoNkViUnorY2krK0VBck9CaUVyM2thcUVrVUVRODAvalFBdWJ4RXpjbzNTVzYyQnVlWDBBNlYwV3VETDhqbWtQMkpCTW14NXlLMG1NZ09Vc3liVG5ESURtZ0l0SGNyUEdhMWQvV0tmRi9NZTJZYm53WURldnFmdEVHaEc0UkpDS2FoYmI1SzA1WEV0a2tRbm1sUVM2WEZ5SWNiY3N3akllWW1FZjhWOTQzeTVhMlF5MmkrenQvL2hkekhlbXd1L2V3N2VNbHF5MFRPSnBmZ0hDa2tMeXR1azN1bURUZFcrVHZ3ZjBINHorYmduclJqQjF5cU52NlYzZUt0SlhYbEtZaW1uTHo1czM2c1ZUZlpDWmFnTTBQUjFWbVpqQ2QzN2F1em9GNGxtQUFRbWNlWk5iVko3czM3NVF0L09ybHM2VE9VaE5LSlBWNFphamR6d1F4ZzhaWEVaZnlkMFNHYlJSQllnNDVyKzVYaFhRbkxVWHV5YUVjOFlmYU1jUU95NnNTS0E4bG1ROVgvUkh0UzBjNDBxVEhFMldzUDFsOVZ6bmpTZFNMNEZVa1VBbTJodzJVK0JIYUhEWHQ4MjNMY0NSajhRbThBVUJKVHRuM3h4cy9nVWJFeFd6YWp0aU9sdEI3T2thWXRWK041YXNBNk5pSmloVkdsTFV5ekFPc0RoV3RaSDQ5Yno2ZmQ5NmpjcTJlSk9oMk9IczdjenVCSlN4dWpnOTJmbGNPNkc4bWZPVHJrYWkwYzQwYTEva3ZBaWNBOExhb25SanNzY3hCTmZBVjYydWxkMjNvaFlCUlZTUHErNHZHdHFudEd3Q1JTVkUyM3RCSjEydW5GZ3R1cEYyNlQ0U3MxSTEzam4yMDZScUhWZ0dEQTJDaHFUVmc0UStnNVc4K1ZCVW50RTM0MEFvQk5FWkVSNENTdG1UNWxSY0l0dnhrS2xrUVdtN1hsM045ZjZPeFVRNzZXa1F1YkZ0KzZ4eC84d05iQXlnSHN2SVN0Y1A5MHZxL2ZGSHE3WjhOZE42L2VpMmV1aGNQUDB3NFcreGNEYm5BaCtsNExoK3Vrakw2ZU92WFgvWmNxY0U5eDRWTDUxWlhMcDZ2UHZ6MVJzNXl1WXI0VVNvaUZFcWVITXQ3T2NuNXp6NzRvRlNJTktpR0pWb3BCNnh4SXpCdjNyZytnR1Z0S2g4anBZRFN3RFZrZWM5UGYvS1RVUlp1dHdYWmRyUzRHMDJvMVFVUHpzUnJBbVdqaERRWFZtKzhkK1h5S0NzMFVhNmtNYXNKcmp0Mzc1WUYrLzVJdTUxUzdiZTJMa1NvUy9rWFRqSFN4dDlNUUh1WGlmNUozVGR4UXA1N21TdWliYmFERW1FU3Z1VEVvMEthSU1tWkVzODJqNzNJdHI0OUFDR1QzSTlxVVZrMmNqNXpUUmIxc1p5emlCY0lLYWtNN1hjQVlTYmg5UnMzeGxTemdTay96WnFJdkJ0Zzl1L1IxUGhCOEpoVXBFdXBDbG44OG5zVTZ6dCtmRmxVeXVSYmExSkV1eDJETVpUU0s4Q1hOT2E3UW15V0lWa0swYndPb2NrZkdRbUpTTk1NSmlPNHNkaHJJWGk5N2w0eFJkZlRGQktRalNzaURGaktrUUYrTHhYYml4a1FvSTBpRVIxVmw1bndJbTdqMzdsVmlaZmJEMTVWTTFzeVp1a1pQZVB1bmpCeFViZ21PM0hWbUZoTEdTajF1aGloYWxzTi9OczNyOC9PMWJGVnpCUUw5V3hxcTlPd1hnVWtORHRnZGJTU0xTSjMxcGpaVk9UWXdaWW54YU5xdDNQbU1xdTJUdStOQUhxVTd3a3ZkOXJxeE11Y3phMGZreUI0SVlGaWc0dG5wU2c4S3d2L1NYTjR0eElqdHl0VDhyVG4yYzVsWUwvQUhtazBqYzJ5ckRmVDZJSDcwY2IxZUU1ZXlhcnJoRlgwSXFJVWxZL0dCY09naHpFUUJUeDMva3BqRi8yOTZ0a3krd2tIT1ZZN2FYMzU4VWQ3VTRyR1pweXZZK2o5L2NDeDVwaVdYQWtBVUU2YXBHWFBLRjFGSlJDZ05FZHZ3SWhreHlEcjc0SFhXcnRaYXp3RFpBSE1xK1p2U25oM2Z3SjYvSjdtbHpEcWZqTDNKV0VTYXE1WkEvSnlINlprTncyeHhocUlSdnlPL3Uza2pjZnFTYzhWUURWT20xazlmRG1UUzVocFpjOU1PVmw0NG5oSnZJL3VQVm85a2lLVHFmM1J4KzkxZjJ4bTMwZ0YrQjVQZ0lxZ1pnSis4T0Y3elRlK1BqemEwZVA3QjFZZmY1QkxKSDZYLzZmRzBPV3JaeFBTNVUrbEJiKy91aHIvdGVxaFBuTE00eUZtdXY3N25qWjk3ZjFyMGROdXhRcCtOTVA1T0RyZ1Q3dDY2V3JGQkI2M0RkbXQwcFRPeFdmeGIwQ2w2c01zNHU1NVZXL2hOL1A4NzEyNE1QejMzYmMzVmg5ZS9uWjQrazBDdUdFc2NmVGtrYy9kbENNTndpMFRzei9aenBnWHhaQVljamRJWDJycW1DOFJIck9KNHhGaXk2TVNrdGJHdVhNWHhybHVjRXdjSjY5UU1rY2dZRFBndERqK0xlaXY2TjV1VEtVb1BTMEtVU0FZWmlHelQwWXNNMmphRHJVL3pHYW1WbXFEOWtjRHNCU0luMlhhenZ4alJpQVMwaElnOExPb0phUU5oR1VxK1hRV2xSMHdaY1kxaUphU3VQKzZ6aGJpSFdGWC80RVFuNE93dTFLMXRKMXUxS1JCTHhLVE9hMHlaSXRCR3lmUFBFelN6N1FFRXBtRzFRWHp2ZC9XWmdHbTBzYWtPa1NrcDlySyswSkptUWVLOUJXQVRaT2lDUVRNTVRsaVA1S1Rsb1J5UGNsTWJRWThnZ1dTUEYvMi91RGU3YW5LOFBTQkd1dEZkZlBGblU5anNzeUNPSHdjRUhHSTg1TnhZbk9JNy9CYk5Hb1kyL3BPNVV6NC8zNys4MDl6bExZWW5Sb1kwOWlzZ1QvcVlVRHlPQUYydDFTRjd5dVplN3NJNFoyV1lqM0tkQk5FZUpGR1k4TlhBQzF2eUZ3UU1IeWNXeUhYOFJpUDZjSXhMTDNEV0RJSlp1TU9abFQzZWhYNHlieFg0OTdPUXF6ZjEzMEhITVkvbEV2aVNVdSttcW5vTjFEbjZDOEt1bmE0MDN4SWJScHlvOWZUTGY5eGZmQUZxallDSk1hTTgxdE1JOTFrZmVBUEdwWEQyRHQ4QnhIUWZoL21iM1REN3pWanRENm45bXB3ZU1nMTJuYk05VDk0MSs2NjdTNFkydlUzaFdGb01LRzFKTlZxVGgvbFJyV3RWdk9QeWkyUjRzK3JWd01FcDgrY3FMRGlkelBlSE43NERHOHNPMEZ0ajh2aVVkRzZSL0dFRFNNa1pVclVwa1c1ancwcEJHdG9QanZOSmVUM2ZOcWlGUmtQWTZaTU56ZlJVcVcwNEUrLzh5M3lnN0tVMWhhYnRJbjFPSEtSVEJaQ2RQRW9VMUlCUUluYmZOVUFkalRJbm9sYjVmenBuOVJHMVhmVHFuY3EweDNBTGxFT3dPS0JkRVRKVlJFSlF6SEVVd2NnS0hUZHpQbnJHa1hxYjl5NFBnUEFWd1hJSkFFQ0swQnk3ZHI3WXk3YWV1ckk0U1I4NExSMXNqeXRHTmFFamtOdGMxRzNvZXhtTzU4WUVBbHNvZ2hHWGdMajhSeUVVaEt1NWhEbkFQL3F5eThIckFBUDlabFA2dDY5eW1Ga2dwbm8zNGVEeHhsc1Y5enVsZTJzL0FYUUF3aExocTRBQVkweXN5dGk0S3ZqYXdNQVZwUjdYbmIyZ0VFanNaaVpmQXNMOFdvWDhDR291YVp4azJJd0JObHZpSzNINlRvTUZ0UDJra00yL0E3dytoRWhBaTNFUUxWV3N4ckJjY0xmclpqZU44ZHZyRDYrbWxxZk5uT0E2ZFc0STZiWXQrZE00Nkl1MTRaN1NoRTQyMlliZ1BiUjJVZXJtOTk4TzhtZituSHh5dm5KWUxmdTY3MUwxNHF5Qmp3QnlmZHRFYVgwanR3bUJBMzRxZk9JaVVaaWppK2xSVjFMUUhDdzM2dHN5RmUvL2FKeGVyMjZFN0YvbDVQMVhtYnovYWNsRUw2bzFITDRrdEsyNG1FNjNBWW1XMmRFS1dQdytpbGZyNDdYYmxLOVBvVlBnUTBvTVFhMEdpRFNTUFR1ZzAxUmpRbDRBQ2pqcjNrVE9BYVErMFVFRDJRU0NrcVF5cW9OMElhQmtheC9hL0lPenA2RmdDN3djbzdHRzF5SnBGT0dwN1pmWlIwMGdqT1AvVG9IK3RjRjg3TUl0Z1VnMElpeGRHQlVMN1gwOVJzdHVvNXdsUXJrMmpVZ3VTazZYVUNzNTIxc3ZWeTMzR3NCU0JvZkU3MmZPcjhoNnovMDZEejM5VDFhNHFZQkJCdHRYK2QrQUFob1hEeGNqbHdtNEdTbzd6NWJmZlgxYjhjZjdGNHNsWW1nQSthQWpxQlRRa2JlMVluYXRDem03cjA3bVk5bnNqU1c5WUluU21EMldlQnFwL0VFS1BnZW5YamVXUkpWSHdTcEtBKytsM0lpRUlkdkNRZStiUUEyRnR3QWV5NllzQUtHME1vQTdIdFgzeS8xb3YxSUU4aVc5SmpIL1lKQ2VJSVc5NnMvcVZ5MExlc2EraUFTN1dRWE5obTBFZElQTWZwT2FORytaL3d2Qm0yU0FXZmdxSUF5MTZ1bGt5bUltTlJqTW9FZTVGbGJsai9PYVc3TjJPTjNHdER4Q3RVRE01MVJwa1p0cHdHNFREYnBFdkZ5R2xLWnJFMHVBaGV0cytVVmxaUHo4Rm5adGJRVE5qcEVCancwSzVxZWM1aVJKbThJdS9NR3FadDB6TzNCdDdmVHhOSUlnYzdUTXJJQk05OFZmOEE0bWdNV1VUUXIyMldQVzlBdC9BcWdBWnlrenFVdEJJZVloZW5UQWlKTTQwUGpvbmtkaW9ud2hWUURwcTQvbU5ETVdpSDR5SGpHQUdQeGFXRFJtbXQ4KzZlRDBCaTFPRUxZejhIOHFDM0tMcDB1MnZXc2hMbk9QWEs0ZTZiMXBCalVwd1d3RDlkZm5jS1FSNCsySVVBL1dwQnIzN29mLy9pVGRpUnBjQU9USTVsUXAzS2dMOXRzSlpIVG1ILzhrMDlidUZ6QnRmRTN5cDJ6OHI2MmVzbWJta1hiOWZ0bzgyenBCTzF1TSthdzdkbjU1b0svYWp0MVp5TVQ0ZkJtYTlJeXFjK203UjFOMWQ5cWJhQkk0OE1jN3BaMXFhTTJtZkgxRDBUTDdOZFhXdFdodENxbG9aZjFpMmxqbzJYRitERS9RcVpvV2JuUHoyVzVqUXgraGVQMjNyWVBKYjltM3pVVncrbkFudGFEbnZsaGJjemIxSlR5c0FSV09tbm1qY1liMXZmNzRrYVE3MFlUUkJlMCt4Y0poRFhvQUJhZnZZOXdpMGZ3aFBsZndHbGhUTC92dElYYUFqQUw4RG5QL0hiNTc5c3oxMzkwOURzZ0Ftd09mVnBBYlFGVGdnMHhBVkQrSkJFOVVVeThvdjZYZ2dPUEFxQXpWWHQxN2ZHU2NWL3M1QVNQUnEzNjJFa2hZRjNnVWU0VVVUNldqUEc4bTB0b3I2QVB2eTVlUk05SDBvUnBzUmFSWHlvSXR0c3VTWGlIOVlIZmpDMmw0bFRwS0pRVFlNVWFVeHlRYWN2ZEFpTzRSbWhlK1BScHUxRGpXYytGZjJVandCdjBEb0F0eGR2ZXZsL2syMUtqSXZNSkhyN3dqUlNaTi9IQ2dYaENubVBMN3BDUHpwSGVSUUY3SUIzWXk2R09hVEU4TStPRER6N3MremR0TnZDNzhWK1lGR3Y3VElaRnlWNGV4T3YwbWZQTGUrV0twNE1LcmRWUnprMTdwM21nTjIvYXJLQ1FwOE5BWW82bWFUUTdhd01SRHVMdzRKeU5OS2VDZitNc3B5cUtIcXEvNDNmdGVYaEVPR1pxa3NBU0U5SVZvUUJTSm9nNjlkWXQ4YnJ1dHIwVklySDFsUEN1c1BLektsU1lHR3NWZ2JiQjVCd1VSc2JFekJUYWxITlF1M3NPalEzeCtxM25ienlXQThoYmpKdG00ZWhFRFBTMnNSaXAyYk10SWZtRndTeWloVjdlY3owRjBtOVc5dzYwZlhqUzZHeWxQSTRYUW54VzNYU21XSS9YK01wb3p5enRtZXRTQUdjcmVhdmpsYVdSV3BINUhXaWVhTUpmdHcyVHJaUDR0QVJKN0J2M1lzYWs5Sk91MjgzL2xueXY4a1RBR01FcDZoWTZWWVcwTlY4Ump2Vm5DUHhGQkx1M1UvbWJya1dNaHdNRGp0M2pFZXBCRXJocytMZk4xYU9FeHNNQTduSDllYlc3bUJiV3VjMm10cGtaaHhvTGpOR3B2WXpIT2tremJiSHZ3cDlBZzVhVlZocURQclBaUWRkWTE3WlVhY2c5MEhyVmd5VzdxdFk2Z1pFQm9zYWhxYUhsVU9HSUEvTmphUkpITndZMWo5STlCRXpRQy9vZnJhNHBBbFNqTmZkOWR4dWFSZWY0d2p3dXpBWThqUDhDSnNEUk9WNExPTlh4RGtBMkV6cC9MYWFrMzdYdjJ2WDVDK0F0SUZxSGgrNmNoMjRkd01vNVVsclE1TnZtai9BK1BIN1NGSXZ5b29EUVJHU2paZjZsM1RSUjRNRnMvUGFicjBhckFVSUF6TkkzL013aHp0eTdsSFBiempxT2h3K3J0WjVUWGhtYWpmWUdmTm9tSkpiaUhEbDBjcTdCZDRyMHJVRm5NZDF5WDVTNzVUZjl4T095Qi9DclNEVkE4enhjUWR3dStxVGlDMTR3QnZLL2poVTRZT0VZbTh2MTU1RkYwTkV1eFdYcmJFbXY2S0U1VWQxNDQ5eUZFNS96VVRDWm9DZVFzR2lXcWFSRDhwaW9lZU13VHFLYUJCMmlPY2l2OFRjMTI4MXBDUHdLcWdMUWN0aXRFN1dLd1hVYXVEeE1ROUlXd0JHaEJEclNFQUNkaGI3QXkvSU9iYnFHaVdLWG5uRm1odFFJYnNuR1hTVG1ndHBMbmhDSHJmNTcwU0JvaFZSUXp5YlpFbEFwWmRMUEhVdlVrOHFySmhPUUhtSU91RG5mMVNFaUdaZ3ZkdTJ3b0RyeUdhSkJUR3V3QXVMOFQxUmdXaDZRTXlZQUVEandZekdKM3BINVRLTGZlNkFZSm1Mc0dUMG5ZdTNEdklEZW1FMzl6UVE5VVlSUnBJVG1NU3NHM0tGK3hWNURKT3B4RFpCR0REUTNac0hrajhYc3BKVHhvTlhxTjhrRmhLbjBJN2tiZDFITFZ3a29Fb05BbndBQVFBQkpSRUZVUGhFWjBlNnoxeHpjVDNESWJoZjZSN2h5dFBiYlpQYmV2VnVCU0dXMXRVbklGYlhkaW1qdHRMeGQ0T2I3eklzSGFjeDhubTl5R0FOVXdBU2dLTDNIQXQvTkFFeWwwbVJHZmZjOHZaWmhDVXg2amhDTGlXQm5uQnB1TGdPUnRDQlEwc3pGbEp6c1F2Ymxod1ZrejdKRkpZWjJhZGNHVkFFdnc2cldaMmpOQTNDQkkyalRRYXVZbTNaalkyUWVtRzdqY0lkMEhXdVFZZzVoSWdjKzhmMVVoYTBqR0hYOVdvQU9nNWxLazFvYjlXQnBtK2EzS0FqTzk1MTI4QTd0Q2cvb2gzRndMT2M2cDNHS3ZpWm5xMnZRNmxhYWlCYy83R2ovMFlmeE5mZXFHdXcxN2tCYUVxZlZJQVBTWGNjMVk4VUlDNEhacjA0VkhrTVhseTlmYnV6MlZqZHVmamNhTE9FUFdPclZXRTFNMVRFRnV4SHdkQTN3dzBONEhYOGJKeHZhQUo4bHJXaFo2K3E1eGlYak9RWXJGbXR1UFNmcnNhS3BVVEFXZ0V2Yk92bTM4cXVtVE1TUHltVnZuRG0zOWJrSjhBQk9CQmdHa2RxSjRXbFJaMFBqV1J5Y25yaE10czR5aVpJWURheUZrY3c5ZGk1d3N3eEN1SjRKTkpLcGM0U1BQWXdjbzRXeFZUMHN1cEYwNENmaThMWk51WHRiQUFteFBiQ0lvbElaSHN4Z1RVbmZtRWt1bDdDcXlZUG1IdGk5VlNSOVZIUkNCQ0t5R1daVHQwazVHVXh2aWNlcEhKS2NpNkluQmhFem9oRkFKU0xpZU5nNk84NUd1U2EyM0hKK042bC9DNDNUc0x5QUhNMXFKQXZIcDJmdlArTTR5YXkxUDFqVXY1Z284dXdUaVIvQnpwMzg0eHVFWFZ1Ly82NVBmWWxJbGRvNW1NYUFTQUJ3MWxITXlSOFRJQ1JjbUx1aXMwY0Q2ZGh0emtORUdFVVcrdmltMHBMV2k2R0JrRGxmcEIyTkkyYU5VR2Z6MWViY0pxdlBNdVZlRysvT2ZWYUV5ZnF5RjQwVENYMi9zVHlVdER0ejVkcnFjWFB4TUdCNjBubjNTbEM4OStET1ZJZmxkelEyeGtocG1pa2V4KzlTZ3V5eG5PeldTWjVzdWRIQVQ1LzVhMFJnWGNJMGt5dzZZZlBBNmtYT2Uvc0pMSnFYQUU1MDE3aHN5MldJb1Y2a2NYQkJBQ3NWSVpUNWpweUgvdVJvR2VkSkxZZ0dhVjhjNmdDRFFFSTM2SXl3RlJrMTV1YkQvR0V5b1BGRGtGbGZzMHpUSDB4RlRPajhkdzNVRjZCTFRCRXlTeHRycGtUalh1dGo2UU90YS9GTCtYNDU5d2NhWCtSQWlORzBqcGpyK0hNcjdSdE5INjlpQ28zeVRhWWhaL3RzSlI5Z1RlcEcvUkNRb1JUZzhVOS8vT253TTBGdmFkTnZ2dmh5Z0ppQ2dvNVpOdXVLQ3RkdmZKc21kcUVLdDZwamRQL0dqUkI2Y1A5ZVFLV2tNbDZ4ZDJKK3JvQVFUV2xueVlPVWM2V2Fpd1R1MGk3aSs2bWRGbDIrTUpjQlBiQ2pMQzNIb3ZrU29yTWZZdjJXOG5UNXZiL1hjK0NYc0NUZjFrYWJCbndPWER3TUU4bmtJSFlPUHNtV1ZEb2hkNEFFb0ZSYzJMVjJNRUlpQ1lYbzEyamEzUCtlQ0R3STFWVWI4bitzMGRzcUxRTHdrR3g4UmV0eUlNNFRPVko4L3RLbGkxT2Jpc1NocXRLc3JHVnlEKzB6aFN4WXBvWWFEQVRrTjVvYW9nR29CbDRhQnVjZXJlRm9xRDdTSnFlL1JjRytKOVdaWkNvaEdDVFBKejFqcWs0MG1FdENhV01CVUtNdDVpRFRpS1RDNEpZbzhSZGdSc0tZQkI5dHFqNHFCRGZWSi9xTThIcXI0eVJwREpvMllHeVlkbWcyMlR4L1l5c2tETFNDdHRFd0pPVmg2QzJWRVhvR2F2MFExanVDUDF3dC9sVTVXZ0JzZkkvMWh4YWd5b0ZVak1XM2w5YmE4ejErOGlBUXZqZlAwWVAwZTM2MTBiWTR3OU1TWWxEbTMxNmd6K3lRaWlJRG5vWW13L3hsaENvNHNoM1JIRHBlL2FTemwwcGRlTHY2bTYrK1duMTlpMGIxcE1CSDJsaU13d2ZCK2QvTm1xOHFrcVloMHFwb0FNZnlpeHl2QUowNldFY0x3WHRHR3AySWxKY2NNSXh1dFlKVUV5V2paZS9UWmhDdHJiNG0rdGZwU2tuYmV4QmdIYkNvdVVmaE53c2lhaXVRYUx4cGFreFlBbUp4NkRlaTBRdmhQSUdPeHBKMk9wcHlWdzU0dk5NZ2dOZ2EyTHl2QmJvNWNFekV0N2tDUGpQUENMVC9uWXRYZlBhUCtWbEFNU0hlYi8vZlk4NXRETkFob1U2SWp2YmJpVFFlZE1KVUY0WHZJZVplODExamVTYUFXdWlQTlZUYVFiUjVyUEZsSXRKV0tBUFc3OW1QVSs2azlYcGYvT2FMMm1DR2xxWXlXZWw0UUZIRzQrTU93UE5BVmtBTG45dWt4dkthTmZpd0tQek5Qd1c0N3QyN201THdPRFBVYXBLbFpMbDhTanl2RFpnQ3pDZ1dhTWxhUjlxZFBsaXhBcmdJWmd1MTBTenI1N1BQUGl0cDlaTisvL01BT3EweDBCS0kyTmc2Y2VoenRiQzhKRkRLWFpwTTg5Yjh5YU5ZYXJSYjRsS1o0ZFF5RHluTUNGRkhuZXRCcldGVHJZRkRkOEx6VGFMTVZNaE9JK0JNTjhBNk5wS3JUbkg4eVlJSERPTmNhOVRWS3ZlUUh0RGczeS9wVS9uYkliNitHL012QmdjR1MvMHVRTVBFa0w5MVpJcVUwUXA5ZnBPL2FnR3pjcU1pQWx0L1dUSmdNUEFIbGRPQlFBQVZEVW5sMUtWU2FoSThaa1NJbk81MG9uZlVOMzFiRS9JaUJmdWxueWY1dGJPQXBiLzFFYURGWi9XL1RzWkFKRTRmWnFMNFVGQmE1RGR0QXlyL09kaitVMkdod2FZeDdPWEluWFZXTVJad01lNkk4R1RiYXMyaVcwd1oyQ2pydlBnR0F0VCtjMXZNMGdRRUlqVG1naUlqaE5JZUk3VEhMWXkxSW9GRG5XWW9MWVBHYWw4Ni9pckxQQVE4bUIzeWlXVFY3NVFFL0NvdytUNEMvZUw2OWRYZDZHU1BCdEU4eTVmanJLZnRxVVpwOGFxQUJDWmFjdVV5V1dJeWM5R3dONjRCVTg4dmlDSGx3VWdBRmI2L1pHVFBtWk9kSnQ5RGNCSEkyNXNhVjVrbzhuYlNKU2RIYXpMaE14M2wvS25tZWFpNUhMeklJUVlNZ0NCUW1zK1prUUlnektDeEFwcWZ0US9MZkk4NTJuMElUUE9MRmhmTnlUUXVZT2R2dEtVZDlBT00xb0FGREJFQUdwRGlnQjc2WXRwWjAwdGYxQmVFQWNpaXJvQ0tkdVdlTEJ2bmE5TkI4NTIyKzZ4Y2tnZXpsRVV4UmVNbW9rM0xWdE9kUUQxVk1HSXJBV0dQUU5ZQ013OW8zUzJqSGQzZXZuTjd3SjlnVXlSU0FFVXBvYk1wQVJaSmYvdnQ3MnJuemVwaSt4MTZkajVSSmJGWlFsNGlpZFlPTzFnb2RsYVN2bVNaR0tHZ0hjQzZMWWpXL1ppSlgvNzJ5OEVVNXFuc0E1YUx5UDc1cW9CSUFmcG4vK3lmVC9FKzBVdzF1OHpObmZZeWZGakd3SWMvK2c4bndaZndRNmNiVlhyOFhMVk4wb2J0YVZLZmxGTmptY1BCeXN2YTEwMTQwbmJVdEJEUlBtdVJvQ250ZzlxdlFpWFVSSEhEY2dFWXRaTGZod3ByODBXRGJwQjZwaWE3ZnlKQ0VVQ2hmR0NIY1JiYnZEU0RIbFRpNTVpQVRRN1ZVNjZJWlFoYk9RVHRjU2VIcXhHWnZxaFdJSi9HRW9LMVNYWXlEY3dHb2FlN2xoWWtFblc2ODNLYlJPNHhRNUtaby85d1JISTBJRGtTNFFCV2tTdkE4Ymp5cnJTdjB6M3Jmc3dpdDhtU0JrUTRBOTh6MExhR2VOUEl1bjNQeUhISTFNZ1IzTXM2T1A0VlMwcG14WGtnbnRyU01DMEVEVWdYeUFKZW1ZZzlqMzMyT0ltQkRIUFkyWEtqcEhzcU1UemJYZ1g0aXRRQkkzbEh5aDl2bDZncmFIR1U1R29PYVdrSDJrSytmTTRTVXF0ZW1oOVBSUEZ3Yy9DTUk3dkV4TzNBL1dGUjNRZEZUcCswSTgvOVB0K3ZSTzJkSi9kV3QzdmR0UTd0VlVUNXNwcmJKV2MrNHI5S1k3MWYvYXQ3VE0xTWtJM2FFMFZFQitOM3F3KzJTN01sazRLTy9Dc0ZGOU1RMDFaTFFLWmhiY2dwQytTQVZ1eG5OQVlvOUhrV1M2ZFY3UWMydENxazB2Qkg2SC9RcnNCY1F4S0ROQUROMTZ6amJHd2xOS05SQXhOOVQxdkI5b3lyaGVMR0Z4Z1NsQnp1aEl6OE1Ha09BRmsvT24wWUQ3MENGVXdMVkJ3THVDeU9jOEJFZ3pQL3BzdjVmRkJkUForbllrYlBQV2FjZWZZVDRxOU55NE9ZOThEYzEvNTIzWUp0dEt1RVVreTdtdy9aVDdRUHN1cHc3MGQ3VGpsMitPQm9vQ1M2YXB1MVUyazhXNEgrK2Zqa3dzVXpwWHFrc2VSV1VXeGdPeUYxS2VBQzVQamtVaHNKYy9NY2ptN1E4K1Y4eEt5Ykw3LzRUZk1rTUhaeFhDK3ZBeWE4OCtqaG5ZcjBsWXJ3OGttQmxFZHAyZFhFQ2hRRlN6Nzg2TVBwcTFwdW4zNzRRVHpkbXNNc3RITkZrUzlkckFSTnZsR1J6Sk85Tmx2Y3Jyek1vN0x3QWZMM3JVeGhBZWtyMFB2MHA1K082VTRac2pTUTlmYTMvK3dmTmk3UlU4blg2ZFNyalhhKytCeVJPR21wWTVXVE5nQ3hsOW41OHhlNkNVM0VBQzhyMDZtQmExOFVNNFRHWlBKb1QzWmlCa3FMYmFwbWU2djRZeUJxSG1sR2kvRnVFcXdacE0yWlVKUE5pYzNNb3lrSXdicldkelFtSnNKSVJGTEl4RGJvVkZuQW9OS2lPdWRqRWpXaDFQOGpEWUJFeEwwaVZJcmpLWWkzMm10Ym9iU3JWeThDeHBoMU4vTmxOeVo5VXkzNzBvbzVQOEtTcnUzVXQ1bExMOW9uY0tzZFlTUnN6cTdGRVpGMlNid2F5NzlUMkZ0Zm9tVWJpdGJBZkMrQ0dFejFpb0M3bGg5aDFQcUk5VmlOQS9KSXNMWXlpU08rSGgySk44Uk14RzdlcTcrR3VOZUFaTURDb0JrSG9XenBBWXR2TUJQQ2VQYmJmdmQ5SFpBQUMyMHFHOEpaaldFQnZ6NHNabmpqWFh0K1AwNDFKN1hqQmpYWG4wZUkyd0hUZHBWQ1gxWXU1V1Yra0pkcGR6dVYrVWxmeW0vVWZRcVp2NDFKUStCWlpxTmVFaTEwSE1ibXArY1U2WlFFelB5V0dIcXlaVmJIeTNKbkJockRXWkdQTzJPMkpWckhyUUF1dUJuU2NocGlPVmJMbG5OOGx5WGRwbWt4d1FnQVd0WlVzWXdPWmx4R1NOZ2tKSk0yNGNGNDhQMzRyd0l3ZGJLc2ZYd1ZXRmxuQ0t5R0NIc2V1VzF6MUoxbFI1N0ZGd1dvSEFBSmZZL20xTjlvbGFhMXZKcXIvdlliTGNrMVFNNW5ORDVMY1BwYlo5WWExVnhYTy8zOCsyTStONGx1Q2ZqOWpXN010VGFaelRYYXVDV2c4N09Pa0JzNlJKT2RuYUMwWmxRQ0xvRjQ4a3lLUkhScDJkWGROS29KbWpVdVZqVndTOVRVYkNWLy8rNkRTU2ZTVjRVUXphRktMTElEVlA2OG1Idm1hVnJQa1ZZbHlQSGJJZVNxQUtHZnRQQUw1WEZKVG43YUFtWnVpMWUxWWFNVStZMzNDcndBWjF2WXM0YWtDUEYvQWltYUZ5WGxjbXNlamQ5b2dRazJ1N28valBjLytPQ0QwZEpZWjcvNDlLK0hYbUxLZURXcnhjTmdmT1lDRzlmZmhveFpCWmlvdmc2Uk93ekZFZVl3U1FNU2NTd3c4L2Q2Y29HVzMxd3ZYOHM2UWhObFFMeE1LQ2JTSVNuMzgzMERhVm5BdEJOUXNaZUJsTlhkcWpOZ1hsdUFQZXIrVk5helBiQjNxdU1zczZsUHNuNXRVSEFxYWJCMXNzemRmcWV5ZmxEaTVNa3JaMGJiMm42R1FGTzVHelRSc3FoaFRKaTRjTXdQQzNSYkpyMDZlRkUwRWZGbjhsUTg3UERXMGsrRjU0NGRmWk5Vc3o5akpuSmdSNHMvZGJaTStXeHdheElSQmJQWk1vV0daY2IzL2ozcXJ2QnhqQjdUN1NmUjkvTE5IRzQ1a3R5aHQ0QnFwTWdDZHYzUjgzWFBlb0RtVmV0ODNpTFZKNjB0ZkhhMmtyUkpxMmhtdFJjeDdkUW5PVlo3cjlvQU50V0RQMHBaNWJjQVdEcEJZNjcwTVVwOTI1akt0OWs0a1BST1lLaDl0WjFFTkIrTGp3ZHppWHlKUmkzK2srRytydlVzYnc1MmJpUnhOTkJRQlNGOERCQVFzT2ZzdXB6QUd3azdma05hSzZhVDJMakJYeFdRbS91dTZOMHIvYkg3OEpmU0xQZHBwYlducXV4aWNqRzc2azhtNlBnK3V4R0FHejlXREhpc2hlQlRMZ2J0ZGIySU5MTVFXQm01TWNmcXQrVGMvZEhhcEZRMHp3M29BRUcvclFGb3JVWDVIcDNUeFB6bXBTOExFTlh3dXdNOUV5Nk85YlhPWFovbm1uWGJ5NXJIZHhmMk50Zis0Yy9HWlEyQ3kyL2E4L0w5QUNIMXFnT29vM1hYdTg5ay93Zk8zQU1LM05GY0wxMjJLTG1uVC91M2M5U0pUTFhuQlNUdXRsdjZrV2pBSGcxUGFGMVpNRklZNUV3S21oMU9HdldrUlpNWGw0OTlEbSsxT2NuaXV6cFZJdXJYcTQ4Ky9taHF5dEVPK1l4UFpvRzhpbGN2dlgrMXFPOVMzTzlpNnhJVk1uandBREN0V2lIeHAvSDFtOG85L1hZd2hMc0RiZDl2OVlYS0pKNUpUaGJjVVpMN3VMU2MvcE9IeWVmMXVqUWF6d3BBdVk4T1lZcWdjQmhzeWF0S1FoUjBrQnR4T3pSMDh1SUlXeEpHcjEyN05rQzAxRCtYdGU3M0Jkd0FnUW5uYU9PSVUvaWVwaVJ5WitBNUsrM2dZZEREc2E1Rm1FSzA1UXBsNWxIdHB6QitVbzFwQnJDWW1tSGFxSXE2S3RMQVR3UFlsTEt3dTYzeXdSUE9qUUdPdDQ1bFp6dWJ2SHBTLy9nLy8rdStQMXhCdkF1QjV2RzJ4RzZSZDRQUWVFd1NHbldhb0JlRnRFSWVRNUxxTzYzM001Q0lsdE94R01Ob0txUWZqWThhUFZwZm40ZXhlajl6bmlxKzFPbkM3TTVSK1pIZmlwYjU5VmUvYXkzVjQ5VnZmbjAzbS81V0RuQ2JvaFpWclhHbGlSSC9NSENFNStoYk54M3RSNGRwQnhhU3Z0a1RpR2dEeWhPTndlbDhjMDF5MnZpc056eDA4RVJFWUU3S2ordlNzMm5JcDQrMzRXMXR2MjNNT2NJUEpDU00vLzVtODl6QWlxRGFoSUttdlBoNW1MSUVXSXpmdXdPRGNLNWE3N212YWtMYXprWkxKZlppakxYcG0wNVRDYXlZdmQrcDhMVE9wYW9BTFNZR1NvT2cyVXdrc040WkkyTm9NYkR5eFhVUlFRVE1Gc3hMV2VuZWZUbnBDTlc4MGhOellXUUF5aUljYVROcDdya3J1QVFGanRDZnVSdUdieERNVnlnMWYyOTBUOC8wUTdCQ1I3N3o4bmtCSDFvZW5xRGhMeGJFOG4yMzcxaVB5MFFWKzN2ZG51dUIxTktIQkUvamhnN1cxN3JPNzE1L2ZDejA0dG5XL1hIT2VubVE1OFUvL0d1MFJ2N1Z5ZUZyVkFqWWpZUkkzMHkwZStmVjhkWEpWZ0pZMkgzcjlxMHFlOTVMMEN0U0tTZXE5YjJaZ1FBRWNJa0tuMjF4dERTaG5XaGlLNS9vbThvQm5kdXFtbkJ6S0RtVThuSDk1bzE4V3BkYTJ5cGllTGNvZTlkR016dHRaSEUrdmpxVDZjbEhxcmlubXZLdjB0SWxMbjlZQmoxVDhIZS8remF3ZVo2WmVMYjVKTUJFc0o4TjM0MWc2Uy9CQUprQ2ZOaS8rL3FiTU9UTURKRUlQbjdsUjVXVHB6WmRUTDBzdDNuejV0azR3akFxK3hkZ1lVaWZuV01DYUZnQXlpVFFrQkFPZ1BLN2lLQkI1MmhqL29tcWVHQ2cwWmpQSXVmNzkrL0ZWSmxjSWVnNjZzSW5ac1gyOFI2T3MxcDZneWlYM0JNUzlWbk1zcE0yZENwTnpVRkRlQkJDUzUrd0VhdUV1R2FvUWN2OGVaRVRjT3Z0NmgvL1ozKzEray8vMFQvb1dUc25xOGRTRmo2bVF5M1o4TXp1d1JkR0E0SDR6T0xaZm9rMFQ2b0xObURzalo0akVwOW45L3hMdWRlRnVBRkh5c3N3MVdzWnpyU0p3Nm5PYWFPa3c4WkdwWGppdENPMTlaTlA4L2x0Vmlqd3dWNU94bis3K3UvL3UvOWg5ZXRmVjI0MnplNUF0WUFPOUQ2TmRZSCsrV2VBRDNERjFKRmxla21KZkZXTHVQdXdwTXcyY05qcGNtV3BUMXRzV00yclU4Y1ByaTVkT0I4QlorSVhJRGw1dk1DSWZqUUs4cUJvVjV5c2ZIRG1CV05QNlk3bTBCMFF4aHFvTUJmelhFUVhzRmlKSUpyN3FIV0NHMTNYb0hkNjRERGdsTDlxVWhRczFxVmhOYzVKKzlHbSsyWkYrZ2NhOGRRQ3VyVm5Ydm5qUkFCM0F4Sjk3TS9tMU5oaTBJUlFQamc1UlUvYmFvd2drVFRxbkkyMFV0dk8yZHlWc0RuYlhubldTVDdQbkVtMUNFVExNZUlBaUxrNXhrbDZ6N3FBVXMvYzg1b2Y4d2tnQU13YVpQNEFKZ3Z3ckxVcnY3dmV0YTd6WW5mOThIZm51QjV2ck45cEMzTnVVK3AzaDkrMDlZZGo2WWZ2akpucmwvNHNGb2Z2S0ExQlgvY0RxdmhKN3AvcUoybThLUUZIMjh6MlZPQ2hTc1BCeGt5cWl5R1hWSHIxMm9kVnM5Z1BPRzVrdnVkNnFZd1VVM2lud0FvLzdiUG4wVS9uMHN6T2xBaXNJS0FJNCtWTXdtWW9hK0w0NnBNUDI3KzB2RHdtLzI5Ly9UZXJqMXV1OVRaZXNqMWJtU3JSUjN4WFlVMUM5OHo0cjY2bWxDaDRjTFA1T2QxNFgweFFmNVAyZTJ6MTQ4OStHdS92amx2b043LzVZc1pRd0VFbEZjOU5TWkVKQUZPMm96L2ZQVXRZU2wzWmFDK3p6NEdMZEFEQVR6VVRtVEdSYSswSEFJMEU3a0loVCthZVJzeVp5UUE4Y2k5b1VxNW5DdnJlWk1yYnNLU0RDYURPcytnZkZYbVcvRVRjQ0lCZmlEbjROQlNta1UwUit2cXlrMCtHazA3U3A4eHR4Y0M2YlcwdFVrc2ZtWUV2Tys5RnkyOE9WL3NaVi94WC8rVS9XUDJqLytUUFUxTmp3N0orOS9MTkhHbFRoK0JzcEQ4UWs5ZjB0dlBmeGt6UDhtdFo4VThsUHRJU2srUldlckhJRlZPc1hLZTNSVVVDcEwzV2FCMk1HZC9VNXB0eW9GNkdHTjczM3pDWDA3YmU4Tm1SZ2hHUWdLQTZWekVSMng1eWllSnNISG5kOXZLblZyLzR4VWNSeW9NMHhOSkdxaXh3b01ublJEWjJNeEhVeVpHc0M1QXMyczhpd1Yra2hYalZrUkVHR3prbytXYmtyOUVDSGNhRjcwTjdFZ0JGUUJFcklqRG1nSFpaRitxN1JhQUFGZmxSY3RVQUhNWWhaZjB0NFZaMWlub3pVdTczeTVIY0wwWmp0VmhtNHozZTZwN2RJd3hXaldJaWJzRXQ0QU13Nkl4RFhSQWhERUlGamJuSW53UmxPRkFVT3J2ekpaTzY1cTBQVkVxWjFzV3hUb0F3bzJsQm9FNEJTYnM4bzFHY2R5VFRjQ01Md2RJaHNLRDA5TXNFSGdFallnWVkxcUN4ZmtldlBxTnJ6ODE1ei9SWmY3Y0dIWDg3NXIzNVFZTU90Tzc0dy9YTCtEbHY4cUc2cDJNTlp2TkgvMmgzcm1uYzBZZjVNV2RMSHdtdkJmQ2tIQW42SEdoQWFINEU3ZXNXS0IvTCtmNjZvSXJhN2t4cjMxMnEyb0ZsZFVzUzk3RzArUW9LUkZ2WDN2OVIzNW5ySlFOOU8xNStXTFNPOW55bXlwL2NRczhES3hGSXdTcG12VEc5a2hPZXNGUEZnWFAvQXUxSFpMSzVQcFYvNnRIRGUxWEtMWU8rZXl0enM2UUUyZGV6V21jOU5pRi90L3RjdXZSZXoxYzJRc0lTSU42L2wzVVViUXFvcVRaaGowbFcyT242Z3F6Z3lwSERIMDR0dFNjcFE4OFR3aHNCd2VlMEhTRjRjMkdBSlc2UkROQWNjV3NjU1BFcitYczk0UWlBRTk2a0dXZ2RXUmpFYmpYS3d3UVVhV051UG11Y1FudmZRVjV0YVJPNU12MVUyZHhza0tpRmxnd3NPU1EyRWJBWG9QQnRSTm9nTFlDWFZsaWZKdmt6a0FRT2pXTk0rSHIxNlNmWFZ2L3RmL05mckM2Yzd2eWlXcnNCeXRFcUh5alNaMXR0K1ZPY2loSUpxZEVxWndKbWZoYm1FU0tsRFFvWEw1cE50ZFVqRmdESGtTKzlvSkZwSW1oa29oZUlQeUFxSitwb3RobGZEU2U5UkVqK3JNM1U4YzFqYlo5MXJFMVNSMnV6OWRuTzZxT1BycXgrK2N1ZkpQVytXMzMzN2NQYTdpRmlFc3dkTlhRUGs3RUFoQUZVOVJQSnp6dWU2VHdhR0MzeldmNEl4UlBIQVI0eE02c1JOVVlReVpRZEQvUXhLMy9PUk1qNmJwNDE0Y0UwOTZ6bXliTVRDdncvcnROT0pOY2NXeEtTODcwNUV5anh2ZWlXZUFOL1hMMnBQZk9jTnRBNEtIRWloTTJaNzdrSUdiek5hUjVaVGZSdko2QitsVGFWVXRYZlZjOElkT3cxZUt5MXAvS3BualYrNDllc1h6WVNKUXhmQmxvaTEyaFBPZ01mVndiaVBDZkxnSDlLVzlZT3ZoeU5MTUF3WHIxbVNWVTlIZFAwSGREMHl4OGRDekF0SUxFR0tTZjg4UFA2Z2tacytNWGYrTVo0bzMrZ2hFZjRCSm5DekVMWHI4RnFEWEwrOWpMbjVzRDQwNlljdmg4TnRUYVlnNTRCSUoxcE4rZGxoWWhJVzI2YWhQV1pOc1M5bER2QzJsMnVuRXY1Yk8rMEN3M2F1SExsdlh5clovTVRaVzdsejZWWm5XNlZTWmNXYTNwZG5mMEhxODgrL1hFdUUwR3NaU2NzZ0lYMjhNbGUvTEZmQU9iMnpXOHJUNVFGUlNnMHArYWNjQlBOdlBmd2J2TmE0Q3hoWkl5dGREbFRaZGhuOGJHbGFJK0t1T09Geno3NzJXakprb3F0ZlZTYnl4S2lKeVVtQXljV0cydE52dC9rU0FLdnJZKzdWN3hLcyt5L3pHUmxZcUkwT21GTXZDU295YnZnYjhKNHJ5ZTFIN0ViUklOTm1zako4TGVFTUlOdG9neXFneGJtYjk3L0M1a29OMjU4Tzk5anNQZmV1emJuYzZLeXpVMks3MS9FNUtvbWt1eXo2TFlKbHc3Qi8ySGpnSEhTbC9BNSs5Njk4MkZOQWFlQVNQODUyNCsyZDltLy8xZC8yZ3J3YlBEWEpVa0dLZ2NDRk10T0RrYkVhbGYxN3poM0QwYjBlNjBuREh1U0ZLa0VEU3h3M1k4QkVJaThud3lwR0FIaDhHY3QvanBNTWI2RUdGUnlLbzNHeEUvSjN0b0FDTVAvM1dkelFLclY1aHRuaXFZb2taT0VTbTArc0ZFVXBuVjJIM3h3T1dLNXN2b24vOGQzVGZTUzVVOFR4VjNSK2J6WGlmSHo4RjFnL0RFVFkxWkIrRmNCNXAzbnJ6T1pZbVRFMWdwN1d0UHhrMmxEU2F1ZGRqNldvSHBCcERSaHdKZW1iYjU5QWdTRFlTeGJjbzFxRkFuTThlN2U2MngxSUdTdVNYbWJZVWgralY1YmtwaWdhdXcyNnZOTHdxZTVEUDVxS2tqdk8yRi9hUTIwb1hHcUp3eVlhSUlOTnFsNEhkQy9NdFlCbFNnbVA1M2NvS2xwaFVIckRFME1NekRmbVk1b3h2aHZkTDF5MXdRUFRVSWVFTFB2VFJvWW9IcVJWZ1ljK1daSWVJQXk4OVo4cmJVaElPSjd4eHB3dkh2NXpkaXNnV3A5M3B6ODdwOU9HWm9aY09yY05XQjVkdy9nVHF1ZHlGOG40NGsxV0szYlgvakFmQkNXZkxPMEpORzhkd0dMcnFFVitmNUF2MHVzbGlwMC8vNmRjWkZzYjdmVUxRM3pWZmtySjArYzZ4N0FzYldTUFJhZkhmOHdNNWtRRUFoQ1J3cG5pdUErN2Zkckxkc1IxZDJMMTkvMHNrajlaY0docytWYkhjN3FlcFU1dnRuOGJ3Vk8xcWFlaVk2NGFqeVhxS3F5VFRCa2trSHpwNG84SHE4cWlIdnR2aTRLbndVallmeEZwWXQrL1p2Zk5QKzBiM2x5OHYwS1FoVklPaGg5V21kSSt5WWNIZnpaRkNtZ0xGQkNPSElmSERLd2NpQjQvZG4xaTBZVUtoWTlFSTZVZDNVdjFXMEJKR3E0TlVpTDA5c2tydFB4RjIxSmhLZndjUS91UERma2ZEOVpocmw3K0o0NXVNNktaUll5UmYxMnB3V1BIS3lJMjFiV0VKNUdjeVlISCtlakxaMU9KMG1lNXVnVG5nVVFvZ3NIMzdib01oT05XbnpxektFMmh6eWIrbmxyOWZiRjNSa1VvRUxiRWRhbUdTRHVXVHpLN0VqOUJXb2tBcUtXSktjUElvZ1loVy9Mc2dQYUF2TVVjVmtmaUVDMXRVaFF4Sm1HMGJOTXNjR0FuUS9zYmFXS1YvdUZjemRlclg3OWIvN3A2bi85WC81RjE2MVdmLzduSDYzKytqLzQwOVhiZGdIYXYvVzQ1N2ZTdnpEenN4akxYS1d5V0J6Y3c4Zjgvc05zL1oxQWtaZGx6QnVaNlZzd0UzUEdHTDN2UDZuRXlYY1ZTRXk3ZVJNUW45c3ErRkhnUVQ2VGpRa1UrOStNa2VUMGJLWU5lMDdQSUJmSi9kNTBYL3NKWWhUSnY5TVhrRUZENkZHT1pISUFuOWV2RndJYWk3WG5QQ2hWb3piczBCTkdCenBNNXRyQ1lCR3l2dk1wSFl3UmFGbHFWZEdlYU85UlE1cFEvbzhZVHJrYlEzNUNObmIzdHhPUFB0a1FWWFNZeEFYV2h6Ti9ENDIySlhJWHNQU1pxY2tVNFZTMlMvRGJIUDlNSVAzd0cyYWYzTFRPZjVzQUF4cWVjNTUxZnFmZExGcVY4ZlZhQk9rQ1FnM3ZmT2Y5aHdmd1pGbWdCeFlGbWtmL2VBVm80Uk8vN3laUW5PTjdCNDFycHZEMzl3cWNtWHQ5djl4N0xUbVcrL3B0K0N1R3ZWV0pIMmFZOWxraU5PNXQ5Zklyb25qaVpHNkZwS1ZsVFZ1Vk56Y2UzNWN3dWhXZkdIZW1LVit0YXFJS1d2N1pMMytaNXJLMyt2cnJTdEdjTDBEMjZGNVJ1ZmdzWC9GdVdLRFk0dkcwTVZIeEEzMTNMazF0ZUVqbkF4SVZYc0U5R3NKVCs1bnhxZ1F6MnkxbWZ1L3F0YkxxdjhxVVE2azlkd0pNZ09WWlBQelpUejRyV2ZSK21KQy90M1NVVVh5aUJXYmpsUlpBRTFBU3luRUJnS1FaNHZsRFMyb0JXUmF4Wkk0dDltVlpzR2xKczh3bFl1YkRzbGlaVTkyQU1pVjhSeU5TcDZvdlowQnBaMERxRk1EcFVKaFAreDk5bkIwYU9Fakx0L2VnTFg1OFp1NHByWHpwOG9YT3liN09MTE5temZJUUc0anVoc0N5VzNkMmxraWxDTjlNZnVDemgraWxEaFE1Mk1wZmNyUVE5L3ZYTHN6blZ5VTZLbCt5em5rYWgyMU04U1lrcDBWNjhMY2I1WFdJdHRST2JEdlBKVHVYdERpVUJEaWNaa2Via3JFdHVVMUJNZ1JPNVVWODNoVWlBeXdXSHlkejhsWEZ0RVhQTEY5NlVuRzhxMWQrVW4ydis2di82WC84MzFkLzg2OVNwN3Y5ZDcrTDRFcC8rTXMwd1ZkTnlvVno1NU9Zclp1TGtaaXJnUG90MDlCclJuSDVkMkFxaGw4STNROUFJVENMeVErbTJUMTdzYis2bnFaMDdFaEVsMGwvN1dKcnVBcG1iT2E4Zm1tc2Mwb2Z5YittQmxYLzFINUUyRDFwUlhhcU1IZTAwUEUzeFFRWWNORUdJcG5HaWYvRVBKT3NBQU1JYlRkL2FzUW5HcWtJWFJ0aUJRWUhPSVVCTHRBd1ZrV29hSjE3NktSMkpqbTIrNnFvUWRFZmphdXUwSDZaaEVMWWdnRkhLdEc4MmtnWTFDeHdtb1haM1lPWit6cU5vaDRGdGpGczg1Qk9NdWFpUEs0RG1lY2s5RzczSDFBeXBzMDdrRldYM0lHR01UMTZYaC82REtnQTNmTDlBbDQrbTNPL3J3K2lSQzJ5Uld0S2FIUS81emtEVVBYSExJbWFjZWhjdnhGMkZzVTdqUFA4MXdVRTM0SGFiekxtL3N4ZFl3L0F4bHlmODVlbE9VQkh5Ri9SdTZrNEVqTy9EaXdPUnYvMzdyYVpSRDVIQ3ZPclVnYlFveFNEOTkrM0tVamcwcU5LcldHNkhjaTBSbUcvL2UxWFV5SEJNaXpsZkxZQ0tRbXFuT0pSeENUNFdyL0xqTGFTQXNBUi9xOWZxTkliU05XMzdVcHp2MnJNam05VnlTRVNwVjNwKy8xU0tRaVlqZWFxeCttaEE5SVVnUE5iRWtvemJ3TkFRTXovZUxyUFZ0TThMSDlMdHIzeDFjNnZmcUZ5eWpMbmxKblo1b3NKWjZBLytlU1RnQ1RVYmxBNHYwd1NyVWlVa0FrSXROeEFGSXdtdHBuWktJUDY0YjNVd05RRVpvekVOa3pFVVdxSmhveDRXMVBiT0ZIN2R3dXp5bEpYZ2VISGdkMkRCMjJRMElQLzdWLzhkUFg5M2U5VzN6KzlIeENrZmV4V2F5dWdjQitTL1hqQXh5eFZHWXJXcGVwRGREeTI4azdKYXZzOTFHWlMzUHEwdzVrcTFoNWhFTnFZUVdYMmJlWkRBcEQ3bVhqSGt0cTJvcUkrcjVmVk9CRUJ2cDBvVjc4MVNmSjhFTWNzMVdtVVJFVVFFd0tkSlRRUnNSd2c1WWVQaUd6RnpFY3dmOHl5MjcxekFWU3pxYldTaFZLT0I0VDhUVStlR3VPa1JoUDR3YlVQQStkVTVzWmd0d2hna0RKS3NReHNIeEN5dVRFWGJ5T1VoY253d3dJaVZHVzdpdXdtOFY2V0l2SDkvWnpTSkhLRVpWOUJodTJaY3JSZTdGaDFrTERaeWtlWjhHQkd2K3daUkNkcEk4Y2lVZ1M4TUFxR2EveUFlWXh0ajBtYlArU1NndmVaV1FGVmpxZlhtWEg3elUyUTNiVk10ZnJSR0I0S1dBRUVBSnRySWd6MElIL3JSZmVjM1lBaTJPZTF5MHgvWGY5bHN2ZVFjNi85NWtXcWdnMDFUclNnL25tK1NINUIreHZHMGpPM1J3STBrRVdqZXg0OUZ0ZHRyaElhbm9sUUlsZ2FHMXJwNndSQmp6TmFNRTBPUmdNbTJuNlBQZThMUUFFTjFOTFk5bXdPNE9XWThZK2VYRHZBVmR1ekRyTHJDVUJnZXJnNTZIYkQ1R3FxaVY1elpOZmwwYlFJUFZWYzF5QTZEYzgvelV2dDZSTXRWUHRBRDFPYkQ1K1pSV2h3VlNSOHljVUN3dldyTVZTNm5EL3Z5V05wTkFGV0F2NVJMZ2hPNzNObHRHODB4NmQ3Zng3ZHRTM0FhSUx5blc1OGQzMml2KysxNVphMGdqTkY1d2pxTi9ING1jeTZvN2tOOEE4aGMvbktqMmErbFQ2WEhMcmZuRTFabURUZ2lLOFNTR2R5TzFSK09hMlBkV0s5TWMyUFAzR3ozNENQRWtXR2w5VkdvL0w1V2NtaUVzajNDcmpzeGZkV2xsZzVjNjlrOE92ZjNVZ3BZbTAxNkZIWlpueTJVU0cwejZtdEJvbk5UVU5hekx3bFkxMkpHU0ZWRTBmbGRTNm1CaDYyb2I2YnVVamJPdHFnOGpseGptRm1UbUFtcFFpRW5DMkl5eFJrZXRHNmdKcXd1TTVRYmYvdGIvNU41NURnU3N5MEFXUWQ1a054M2NrcUEvZ09JejZvaW9JSnMzUUhZaU1XK1VXQXlsNTBQLy9aeHdHRGRtTW0vMFZraUkxR05Gb0tRcXNQR0o3RDhQZHFlcFM3ZHNicVAyQzJOb3F2QjRGNWRtMGhJTy9PWVdvc2ZxSEY1aVkxTFJ4ZjFvRWx2ZE1zYkV4Nk43dit4cmN0VCtyOHE5ZTJWbi81Ny8wOE81L1pHWE8xOGVrLytULy9kUm0rZ1VCRUIrVFo4c2JYdmZSOXBIVDNkTjhmZm00QUc0T2VGUlBOZnhGajR5UmZTcVFWMkJBaXAwVWtlaFpSMnBvZnNNNXdHcTNSODgweWtMUlh2a092TWFIVGJDMEJvZUdxMGtEcjhabmJ3UHJHdWhLREtTVWtJTU5aSG5NMnhvK3JVOVhOeGlUazlKVjl2cE8wM3E1UHRLZm5FYVowaEoway9oTTE1VG5SRXliVDc1aHZMMDNZTTJIU3lXenYyU2lXNW54TnVNb2RjN2IzZjlmbnE2djlibDhFU2VTRkM2QjVpVWI1ck13NzJyVUVqQzlwQUdkQXdxbExSTkQ4K3V6bE1NNHpxUFBYOG8vdjVsdGpYVHQrUDVJQXN0YVYxbUd1bUhybUM2MDRaOXF2VFJyNFhGTUQ2L243UWRQelVWUjNIZUdkZTNVL05EamFSZGRQa0tIdkpGY3VsVDY2VC9URXIwaHJJVmhaTGxNUm9ZMUNncDNocFpNQkQ4VFVKajU3Ly8wUDRISGFrQnBYQUM0d3JJMkZ6dXBmUXpCZ09YU1FscFU3aG5OYy9Tem5MM3hRWDJuUnpULy9Hb0FpSEt5YVlLSUNYZnM3TEdXa3prYVB5eHBXN1ZKNmh2ZHFYNUVBK1pibVNqb1QxeEI4ZVpyU2RES2w1Rnc1WXIvNCtWL0ZEMXdaUzJFRHl2Ym42NEVWd1hQQmFBK2RvSE5VU0FQbnMyTTBrQ2JGQTBxY0l4V3NpV05POFJQSW56QXB0Z2xhdGdRREV6bjNycjNYOXdjSHZPUmR5ZkdSN0drM0Q1UENIRDF6NWx5b2JFbE1WUklqOEpNaHM0ZGx3ejh0TzlkQW5PeGFrbVg4VU1QVUFYd1AremFwZnlLL3pWLyt4WjgxcVVoTGVaZkZyekNNT3dPcDN3dm9HQVFWR0V5a1ovRmM2K2YwOS9xN1laeVlYMXZPMVcvUDUzZU15WCtGbUdvK0Vra2EwamhtZ0dPNjJqemRNOUFJejUwOWxuMS9jdlZYZi8zejFjZWZYbzR5NUF5cGJQcG05WC85MzcvSmRJeDR5anV5QzQxalRhQStyMEZ5elZUdXYzN05qUUYvSGZBZElnQk9mY3gwV0paYlhjNkJhcWxNVDU2cEpYTEk1R3U1VGlEUTJRTk1vZlV3czBvUDBqQlVjaGp3eXV3RGZsTjZKcVlnSkppckRVVU1vaFo4ZGRFQ0lLa0YwZ3hveitwa29SWWxvWGNDTXhxVVBRazVobjNldFVGRUd0SFJ6U1I2QmVob0RqdHBxT09vYlg3c29zMGR3YVEzem1hVHowdmxCWm44VE1pcDdSNEFxdmMrSlpDWklUMmJyY2lZV0docTVoR1FkRDBOaGhib04zUHFkNGM1WFIvT1g4WjZBWnYxR0h1ZjgvNXc2bHhDV0kxVFBWQ2FiUDNhY3E1RCszT1Avalp2QzczTVQzLzBlZmtta0tqdjZHbE5qMmpXc1ZZbVFxQzVCMjNYTGZBTzVQR1o4M3NDWHoyWGFKK2xXd3BXMm5WZFFtZFRHOWh3WHhRa2kxZUFpY2k4UkV5YnZWQU03QkZnN3dTK3JvM0cwbHh1cFNnb2JzbktjdjJKd085RVd0VGtMSFl2Z0dWNTEyWVJTT1ozZXdZMkYvbXhXcXZvbkdjRlVGZ250bVU3RlJnaEdrSmRHbzNuNGl2RlY1TmdMc0taSXVPbFN1MUdmQ1RmOGs5KytoODFkd0YyUUgwb1hDalRmV0ZXL2hpTk1NRU1zTVBGQmtJNGVUM29URWFNVFdwcDlGQTNGOXJXenFXS2dSMk9lWVVsUGVTWW1nM29aZ3NsYVdIT3NUYVJ4c2FzbEx0RmN6TEowaU4rL2YvOFpoN3Mwbyt1VkhQbmNkZFg4SzhFMGM4Ky9UVFQwbmYzQzljK2FGcWJxTzVEeWdxWkhrNk5PSGNpdEU0ZFpqYnM3NmNKZEgrbXBMYmQxd1N0SlNETjZHQ01RMXVnWVRoSUQ3VHJPZGZFN05vRnZOZVNjd0ZCek9UNTE4UTFtdEE0cmRNc0paQzJORVVpYVJRV0VIMFhZSjFZL2YyLzN4S0ZsSVFFVWdRUzhXekl5cWI2VjJ5dnhNOWhxb2lnVGpkMkttRXNtcHg3ckpsQVA0ZHgxdTlkMzY5b2VUU0l2ZnI3c21lMW5nNHp2WDdNc2I2MytzM1h0NU5TM1Nkd2xLZHo4TUNaVlBpa2NPZStUTXNoOFpxNHhzRFNvY1lyQVVIYk5oNThHVUFaZUlnNE52SVJKMzhTclpJL0pXMHU0SHRiZVJlTFZmbXZyUFVMazFxZ0xmZXVheEkwZSswZXhHUjluZG00Z0ZaemtsQ1NjaUs3ZmIvclg4dHZpUENaeC9iTkU1bVZBN1lacUcwa2hEaHlEMlhXdjRocG4xVnFPOG1RVUVCUGFZa3hPRzNMaTRZN1dvNng2Um40WXFEZUNOakd5QndiUjY4MVhhL0gyTHQ1TVE0L1BJd3pIY3RQcm5IZVlvNkxjZ0h4UllnQXNDUHhqYUFHMTRwRFg5WjA1Ry8wdUw2ZnY3VTlRczhkOUpNNUhialFudlJqbmR0SW8yVWR6TDI3NXl0YnR2V0FGSVhkTVdGVkNIM1JObXc1MlJNNG00M0QxdkVDYW9HQkpGMTVlczhUL1BaSllQM1l4SmF5Y2FJMXZQaGZ5b2lBMTh0c2QxYlJxZFB0RWZxdzJuUFBLcjljd0NzeEVOK2xQTWlIU2loWmViRFIzSEpQSGVJU0FtTDhZL0hteVZPVytZVXQwWjJDZ1h5U2p4TTYwbUVXZjVYVkdNdEdFNnBGd0l0bEpVeXVnNUs4MzVUOGVqelFOUmRTYkdqVGN1azJ6cDAvOHprZmxYQzhpMGdmRTJsUW5XenkvYjBHTWdCR3UybCtXckV0RTVuSjFsYmp2Vk8vdDNPY0NadjZmcDM2SVBOVjBma0xVL3RkeEFRanZDckY0WDN6RmFPVUI5WjlSTmVZZU45WFgwazJQSmxJeTVKaThIMWJXRjNzK3VmS29RU2d6STlJcC9TQWFybzNLS3BYbnR6YVdQMzhUejV1a09TSUxJQXl6TmE1bmtGNWppSGtPdTk5QVlsRkVnT0lJWjAwRkdQZ1dHdGNDSVFHdGhDVHNXbjBHbXhsUFh3SDRIWXR6c3dNNWZ2QTNDU0pNaHZPNVk3YUw4WGdkUXV0RDFxZldPUXdKV0pDOHJMYy8vVy8rcllzMzB3cEVhK0lkUUN3TVZxRGx2YlhjL0pEUXZmOCs5MEh3UStEMVJlcU9qWlpTakdIamoyUFBRMXBicU82OTV5SUZIZ2JRMG5DQ0EvWUxQa3Z6UUdOSjFCNGtkWkRHbk9PejVoSDBHOXk3cjdNMTlZMDFkZUFnZzlNR0gwYy95VWVGaUY2RkEwODY5cEhqeXBKRk5FK3I3VHowKzNhS01MWTFEVW0wVlIrTHdERm5IeWVKRGJ2czR5cGdRRzRBSlp1cGJaVytCZXg1dVFQNE55VDFtWlRDbWtMSW1JRWw3U09XZVlUZUhMMFkreUo1UFp1bmdIWGpGMlQ0ZDE0cm9FSHJTK3ZUdXFlNW5UR3MzOXBaTDRZYzIzNVllYlVSK1dVQ0QrYXducGVWSUtkOGpxMVNVZ2FmNyt0NzZGbDkvNmpvNyt0MktCVkxiUzFnQ1dhUTR1RU9ockFJNHIzYVV0UUFTOUt1WkV2TjdSYVg5U1hFaEcrOU43bEdjUGJaYWVMRnFxc2Npckg5Z05LUXYyMUwrYXp6SHk4ei8xQU03MlhrNXgvYVRQZkY3L1lMRXZyR2M2V3ZHMEozNE44MFNyTE12M1VzbE54K0ZFQXFGNGRMY3VMaVRqejFLUmRPSGN4cGFkeVZTa1ZUSDdQeHdxUlRHN3NsMm9saTkvVUJzeXNNOC9FNS9pa1JkZk8rOHUvKy9lYVQzeVRoQ3hGNHBBSHBkWmJDc09HMUJBZkZ1M0tJRWxwTU9DKzkxM2pOSVBvYjFMNGVackp4cmsrZDAxem5UMVBZMXY4Vzg3SGREUXRSY0JPbnRUdThVbDFrSGZoM3RvNUZScFRRWmYxWXhRVHFuLytqanB0d3ZnaW9LeHNXVXdHUkJFekg4ZnB6TWlqL2ZabWQ4bkE5NXQwQ1lYdDlKc1phc1BYb1pHVzZDQXdmYUpkS1lPaDAvb0FYSUdvM3h4cm9uSi92eU1TMTNpWEtJcVlGdkNqK2dkd1RaRDhJNUtVdzNWcXEzZi9qVFNjdytXSEhRNUlEcWROdkpRVE5nQkdTOFhvYlVTYmhqWDVaNTJQMmR5REdleFlFN3YrK1B4SGpNWXZFenJaa21zdzFQa3g2QWFpYVd3YXd0VnV5M2hzb1hiMG0ycUwvZlJIUlE0M1Y3Y2U3SlNaWENYWlUrWGJsWUI3SXMzVUJoU3ZYL2VzQVk4a3Y1bmYxS1JucmV0YmxpeFZjcnEyajdTMFF0NFdVTE0xbU8yMjNnUll0Z2g3V0hDQlQwcUYwSmNKQkhXUGxKOEdiaThDT2VheVhKcHhzRGN2SlBrd1l2Zm5qemxaVWlUTldQVFNlak1hRkpXVXczNDNCL3lySXJDeXFWMHZrdG9sTVVjT2VhQ1VzL2hvVlNGSWJZNTVKaGJkazNrSlVNd04vOHBlVFJyWk5VMGJUM1JxYmh2SitSNGRIbUEyK0thVHdRY3p4cGg0L1lGR2dHR2cyVnpOczlVV3h2Y01WREh6S0xFWWNEclc5TDZleC9ueTNUOW9lVEVMbVV4U1FORGdJdGpSMmRCRWRMWTFwajFRWGNvMXpkS3lRTUQxcXBBQ0hHQ08zK3hBTldXZjBsYk15ZTNXM1c0MEh2eHUxaEpLNmozQ2w1WG1jakRUYlQ4TnJ0NG1aTjd0aEpOQWVGRkZrNTBBUks3VVp1ZmF1ZnRoZGZMYzl5ME5pM2JiaW80N1dVU0FTaUNLb3o0N1pYeXBaMCtWRTFsZktRNThaVERHZWtQalNDT1R1aUF6QVZpWkF6NXE0NnRPRmt2c3hlNDNqU0VOUGQ3Q1kyVjRmKzdoSmFNWktJem93THdHeW0rWTBNdG5oM01NdW0yeGZjUHZRYUs1TVUzTE9pYTJNL09SWDB6cENtMnh1MmxxRXNkY0R6eWN3MHc4ZC9iQ09OcXRMdGMrMEdRL0F4em1EUWN1MVZhVWpnMEtTTlR4RW1GNFdLUnhQeURZT3JhLytvdS95S0ZkWllYZGx1UFFFSmYrQnc0UkQxSWR3T21UNjhjVTZqdWZIUWJNd0RMM1BEKy8yaDgwUzBERjUyVHpDczhQeEdnRnk3bzBtZUNTVEFIVGdVekMzWmhSWVVFSFA4SGtFcFV4N0o0V0JyOXNLWkJ0NS9mZkhsOTk4ZXM3cmJNcWJ3enhCejRtakw5bVBkN2UxNSsxWit5V0l4QnJBakJtMkRXdjVSbmZBVmg5ZEs1QWgveWtBZGJ1TWZYeUk4d1VsUUNuYy9pUit2MVoydEhPUzM0aEVjZnlvd0lyNzIrcmkvWTZ3QWgvK3E0WGJTbk9welZ0ZDc3dkg1Y0g5TGdrMWpkRjZ2YUtsdEtzWm9mbW5qRzg3SjQ2em84V2tTWjBiRjFQNmk2bGFXaHFBWFg5VkFlcHQ4YTVHM2Z1ZG4yeXYySGswM1hNVE01NzRpck51R2NmN2JMM3lHN2FzOWJ0ZE90U09YT1pxbElnbUdhY3RreVYvWVNic1RUR2F5QXdsdjVlMHpVYXFlSE9UeUEwZnNady9YSXVCdVRmS3pOa3huN21vM05OQnJvUStkUUdwN3cybGlEUEgrWnd6cThkL2ZCNURZUWdsbmFtRFMyakxhdENsbm1yRHoya05Cc0MyWjRGMnAwa3pDaUhWU1A0WkJ3LysrbG5YWDVnOWQzMUd5VnZYdzM4andVU2Q5cmd1Q1U3alEzdERIZ2ZUS00vWDdSZVNYSCtReHZqR3NndnZ2enRLQWI4eUJZOXY4NXkyT0VXcWo4NzhjV2pvbjNQNHR1TGJaQXE1NG9aeWkrdHoxSlpXR0J5SlBtdmFPbWVoKy8zVktCMG9wUWVtaE1Ya0dSZnkzTmd5NVZLelZCc2J0NjhPY29EWlFKdC8relBmdHg0UjFmaTNWbFJwUnd0MHMzZ2pXazI2dVhhVjhQNXRtekFDQUVOSUVibWhOM3VkZUIxYW1yZlVXZFIyVGpVa2xZZWpNcnBnS2hzVDR4djBlYjM3ZjU4L3Z5RmVTQWRQVnFZOWxLZFZaNENrU0hhc1k4YnVKRXFUUUFiKzNUMjkyek5GUkNwbHNtcEx5bFZ4S3FMeHRjeDVsL2dtWXhhQUJiVjlRS0kycHBOSWJybkVHWVMySDlBMCtIMzVyaitKR2thQzMxRHhJNEJrRDU3QmhQamV1Qm1JdnlHNEk0Y3ltRWVJZEVVc1pPOThuYWFURVJtVWZUTGdnSjhVOGMzei9acm1rV2grOG41U3J0UUZxWGI5eGdKaVBvRUNETTQ1dDcrV1RPTGZ2M3d5QnJvQ0p4YzFlY3dwOC96MVZ5ak1OMWVKdFNMdmZ4VnovWlcvL0tMNzlyWDcvVHFKeDlkenVIZDBxaE10U2VoemN2V1B0SUM1ZTN3RXkxTjFHWVM5T2l4Y21hYUV3N1pWVUFFT0xiYk5reTYvS01uYWVlZEQraDJpNGhhV2lNckhkUHNSaHRBWmVkVnJvYk1PVVVNYVo2MEo4L0lSN1BPb08rUG9ZMkovT1VmUWZRMEt2NHdHa3V6R3dNVi9RemducGYvNHhrbDNDNGdWTk05UFBEait3R0E2RWo2d05aSTZXV0ZCcnFhTkljSkIrRExoYjZNS2MySHB1Y0Z4RERlQW9uTlF0ODVCNTJiQi9QdE95YVJ2TFZKQXFYaE4yY2pORHBYdW9NeE9OaTUvRXNtVnh2cmU2NEJhdzFXYysvNk0wVFEzZGVLZ25sQWx4U0pCVndYQWRtRDl3Q0JRL2ZkYTQ2WjYxUG5xM3NRQnQ5OGQ2TjBvOE96TE9kRUFJVm5QLzdrczNodTJka2NqUVB6TzFrc3I3LytibnpKeGsrMDBXYXFMS1J6Rnk2TzFuTWk4L0xyNzc0WmplZjIvZlpnU0l2bHZPL0pBN29uNHhPemVvVlEvdjE2VmRwYWZia1ZyNnQ3cFNDbmVUelZlTmhmUUdyUjlldlhKK1VDVDlHQUJkK3NJNFlYcHlhdzFuTkZWMXVibFdudXZ6ZnhXc2hRS2xBUGZpTGlaZDRaUUdpKzM4ci9xWm5VWjNsVUJrdGpCbTVXOFBkd3p2Vzl1dHY3RVliQkZvbEtZQmNaS3dxWVQyRVdyZFp4b0tDTWlvbkI1QVp3U1hYbzNta3hOMi9jS1BwM2FpWUhFSncvMmFhUUlUQXR5MzE4UitWVnJlSDFkaEdFQ0ZUNGxtOUZuelpTVDgrZGpBbmVsdE9WNzZzcG5uYmxBa215ay8ydHIwdlNJNzhEazZzMWdrVlIrTmIwaDFrd1pXNENLbEJ4dEdjZ21SRTV4akFCK3NKME5BWkF4VFg4UHB5RmNuQTR0RlVST0hXaU1ySkpGbG9oemRVNnZzZFY3M1N0M0tiUnhvelZNRWZ0QktnMW5ZbURzZld2ZElhbzMvM1doL3YvNGZCOS9lbFZ4M3J2RFEzM2pzRG42LzZ5YVNZbW9kVTg0L2VoNXJ4OU1GcnZ3OGNYSXBpVzYvU3d0KzgvTC85Ri9Tb1ovVXg3REpyUEx1WStVdTZXaWcwMjVaaSsxY1ZucWlRRUp2ZVR6T1RGbXh6bVIxb1NsSG9RMGVZWDZ6a1dMWTZtdmdEUXNSeW9zM0ZKOElNR2FCSVNMNEVxQk1Ja25rRHlJRTNUWno2UHZRanFWZTFaUmNCZng2RXRySzh0a2VBSmpUYy81bFlsQ21ObS9QaEhEcldNQ0RQTHMxUDZtbGJ4dG1kMHJBSEkrWmdYYmZJZkdTODBSVXZ3M1dob2pjUmFNTG1XaVdLTVRjL3lBckFFYldZakRlNWQrN0w5YVdqOGd3NzNNbzllN3VPRjM4YkozM2Q4UzJodlBkZDlOYlNIVGx5clAyaHVTbDAzVHJRcmdoVzRtaSttSGxwRjg1LzhKRXNqZ0pJMzljMjMzODJDNGkrLyttM0MrOWhzRjIvOEJFVGUxTTVzbmRhOTd0eTlQKzBjai9acFVudjV1NzY3L1gyRHBSVDE5aFRXZTl5S0ZNdW9iRXh5Nys2RDFaLzg3SmVUMzdXVG81dy9UQnFMUHRDc2xGYVczM1dnMVJDSDYvZk42bXNkeUxSRXIvcHVUMFJyQjhmbjIvTjV4b2M1KzcrL2RXdjQ5MFZhM0tFRDEyWThnUmIvWUtzeW1ISWNuWllVSlBWTmRBK1BpbWdNbk1ocUxUdWUxa25oWmFZZGJZWVNKWDNmVWdIYTJYYUpuclFHRHdvNGFFUkt0SjZNTVlDRXd2UWM1OHdxSlZwSnhDZVY1MzJ6ZDNUMThQN2QwVjZXY0Q0Yk5sOEpWQzYwS2JwaE1lZTFFdHplN0o2Y2xINExNMDluTW5JYUg0LzVOL01QUFl1bkRyWXM0MUF2eGZORzkyaldSU2dkOHFLR0VXa3cyY05XbFZNNzFSeG5TcWd6VDdyVHlHZ2F4NUlVd3ZVNytheFVpN0FvMUJJZCtWUTBFc0IxZk1xcUNMVXpqVEpMcy9PUGxKUzVVK1RMSnA0V1F6OUwxU1ZwUkRFNUZIMUdUSzlmdHUvaTA3S1VTZjI2Wk1LVVZwbnlLcmg0R0xmdnAvZkxoT3FmWFVSOGl6RThBTW51T1hBUnJSRkpBQVZuaVl4aGJVUjVJTW42S0YvUy9TYzc3ZGI4ZlVtckZ4dmZLcCsrYlQ1T0hsNmRiQXhIMjRqNWdhOXhZNWJ6Uzl5dmZ0ZVlZRG5NT2NqVEF6TE5rck1CRitmc280ZHBZTFNvWWNTWXY4OTYyTWlNMW9YcE1KZk9XZ3BsNGF5OExQV1hKc2V1b0FSVGVqYU5pTFl3T3ZOUG1rU2treFJtNXRZYUgya0FKR0Y1bG03MC9XWkNnV0NRRHdVb1o5RjU3Z20wMklUVzF3UlF2MXRnVDZBQTFKcnZONmtuQkRTdGFUR25SUHoyQXFzVGFmd0RxbzNqVkl6dFdXaHZMalJQY3VqNFJxMnJySlc1ajFTUU1RRTEzWE42WnBWUWZPN0NBU2E1aHJya3UzVjZpSG1tQWM2bWpMVkg2QUFuNDA0d3pDUG9jTDlaYXJYUmZveTdqWXVnaGFDRGFOeFdQRWlyVndiYWhyclhyOS9KVDFXZDlXajFYS3NwVkJMVkpoNFhHVGUzZHNlK2MvdHVBSFloR3Mwc3pGODRBaWNwWk8ycFZJYXo1OCtsMmJieGFueDY2K2F0Nk1GeXZWT2pNVEUxVHhVOXZQN3Q0OVh0ZHRZNWVlWnlmbUg3UGVUbWFYNzQ4bTU4OCszcWIvM1p2eFB5dmxoZHYvSDk2cjBxUHpELzhPL0JhR212U0tkSE54YjhiOXZkazF2bFdFVUQ3dDUrMEJpY3g5VDl6eThaLzlxSnhjUnpLZzR6UnhRV0hBS1lxY0VUV2pxWmxrTVNLS3hGS25ER2UzQnJqbXlTdGRpd3pJV2xNaW1WbU1wSWd4STlST3p2WDN0L0pMZ2tzYXRYci9SOXBtWHJpbFJBMk04MC9QQ2o5d2ZVbm9mNm5NN3ViMkNYVFF1YXFNQVZxd2lSS3JGOE9mdjZZZjA0VnpKYW5xU3F1U3htSjV0YUpWQVQ1R1hHUGNPVTMyZ1FTY3NGdUlUOTVlUndCaStoZXhLczI3UW1jN2svNXYvMnhyZXAxNWRXUjAvVlJ0ZnJyOG9JQ3RRQkJOS0swMWplbFNvU1Q5cWhCbE1BWHl2Z1NjUno1OTZMbUJjdzRjQjBUYTAwN2dtSm5DSDkxUE0xN3NsWWpJN1YrMmNPYndBSTBmdHlJWFlpeFhlb3Y3ZDN4N0NHZnpvd2xwKzA3Ujg3NlBKN01KY2ViY2NZMzFlK05yT09ZL2orZ3piRURIeU5FeCtINThHOEQ0c3cwamFZcy9Ma1hxY3BpL0laUTlxUEpUN0FZRC8vMUxJb3VlZG9IUHBqNXB4V1prQ05CYnFpL3ZQanJaZmxNQnZ4czdBOFpwYlNnR0hsWnEzcGhzYlJhUFE5Vk8rOXRvc05NQSttelg0WWs1QjVaajVmV0ovV2YwSENnRWFYUmt2NVR4UEt6RTVKcEJQaHF4OEdDRERNeDc0ZldWYjc1cGoycHIrRXVYRWhGQ1RaY2hiVDZPTCswZUQwazRsb0NaT0hRZXNUN1Z1L0V5S0RPak1SdXRNQm1KWm5RdXVMZU5IZnBVKzB3Z1hvbG5GYlg2L0txR09pZUEydHNrTUtCRXhVTjVPZXhuTGg0dFg0TUhOTm1lL28wWkk2RzVuWWc5QjJkNEJmK2VNYjM5N05uUk85cGlrVDFzYkNScWJmM3JpZXI2bThxOHd6ZVZYbTdXd2xZSUNpNTZmSmNXT296YzZSL3RHUFAwNkRrditsbXFtRTd6VE9jT0dMTDc1c1hBT2srbnNqMzlTSkl2N1BIeGNFT3JXLyt1ckxid2NEdnZqeXEzeU9KMUpZSHFVVVdFUWRRSlkvdUZWd1RvV084bFVtcTk1ODgrOXVuRGx6L0hQRXRQaVlGa0kwT2I0YnRURjFtV1RFK0RRUFdwSWtUbXF6d2VFVUZJNkcwdFR2bzV4M2FWSE9wNEdNSXo3TlpHcGNSVUFJQTlWdFowb3h5eTVXRm9Qd2tHVDZQRk1EeW1JUUdiSHVkZmZ1blFFdVJQNy9rblpmVFhxbjZYM2ZuNDdvQktEUjNjakFETEJoZHJsTGlrRU1OaVVXS1ZvcVUxUXFxMlQ3ekdkK0gvTkNmT0FxdndhVkRpeVhqMXhTbFdTTEVybExjcms3Q1pqQklPZk93ZC9QL1o4V2wzUlpKWmVmbVVZLy9ZVC8vdzdYOWJ2eWRYUGc2NHJxdEE3RTdSNWZmL1ZvOXFadzYySFJqTTNOQzdQZi91MWZpNEV5VCt1RlJacTRsOThZekE5MTFXOW1vQVVnRWRWR3hjbURxWm0xQ0hXMGFnV2FnZU4rNDNyejlQbHNLYUs3a24yOWlDamJTRTVPcGdhVFlxVWFMb21MNTdsZVdnOUxlbFZtdEZhNEYxR3JuUVJhVFhkc3lsbU12MVpIMEU4L2VUcjc0eDgveUlTTG9FazVsTnlITUJ6UU9mOFpMMXErOGZwNDh2LzR4OTZkUDN6UGc1bEJZM0hBQUlZR0NCaFJxY2o3eGllWjBFR2tIS2o3TWZTekYwNFBqZ2xTelo2OTdKekgxMG56bG1jNUlwS3BQcnFNWXNJWS9hU29IMTlUTER0QVNLUm9xakZySEszakFJZytOMUluWWtiTUxQcEh1OTBMdEdtd2NyMW9iYTVyblREdEZDV2Q1bzVaN1JOdGFEU21DeXpHZk5MdTdjRjBYRmw3a0FtQ0xuM2UrOTEwckIzekQ2M1k5MFlRRFV3RjRGYUhLZXFqVSs0VHowd2FDakJxalNRWDJ3ZnI1YnBNTDJzMXdEdzZRc3lFdU91WTFnQ3QvZ0pXQTJER0dPekhYODVqQXA1ZSt1YmhiejhBMEppTjhmemg5Y21mYVh3VFVKMXJYMTYzdjdSTldyR3VDUjk4OE1Fb2YzdGNIM2VwRHRaU1VBc3ZYYnQyclNMblQydFovSU0rZDNmMmRXbENTbm11WDc4MUdtdU9OSW5vbldCVTczdnI5dDNaVHQvUittVS8zaEx0VlRSdHp0YVBsYlZkVDNkMWh2aFU1WW1VQzFVUjY3bHJmdnduZjl5YXp3L0Z3am1HNkJJdkhVZEk5c1A0QlZhNEc1emxZQVUxYk9UTG9tMnVWWkpseXQvKzd1OTAzOUlubmxmY0hpMHViTzljK2RnQ2pjMXNZNERPa0hCOXlXdm5DMmdUL05qZzgyaUtUUnpNU2l0cG9ycFNVdTJva25LUWJFQlhTV0xMNzJKbXBvRUZjUGJSQUJYN09pU1UyUWt3OWV6aGpOdE9oWlh4anNnc3pOMFBibWRxNmVwd2FTd01VY2N2SkZJRGdPWWIxMEp0S3E3dFhFejkvUDRFVnZJMjNLTlpJd1p6b2lWYWpHR2E5QzZBa1pYdTVHUFp3dVpHdjVsenZYbXdubFVBQUVBQVNVUkJWQmp4YVlXakw3OStPcnRRVzlkTEdvKzE0RWRwZndkdGtOTnBnRHEvaVA1VHNvcDFsT0M4WkVaTlhTSFRBUHJNaGRhSGVVQUw5WnNFNG05WlNyVmZYcnhjdit2SHN6LyswUmNqQ2paMUgwQ2NpR2NpOUFsNHhxTDF1b2ZYcDJkLy9kOXprRHIvTG9icWR0L2djZnZSL0tjY25oaUZadEcxSkJVV0thbDVZYTEwWngxUm4vTmNidFYrSmtkWTB0cEl2OUR5V1JRd0RheWx6VEJyYlRNUCs2cW8zYXNLWUVVYWRma2NIUllDRXFZZmgvM1VlTSs1ZVVXTFl3cWZFWHBuRWtvK1pRWUN0d1l6VEhIZmIrVmFwd2xrcEJqUUpNd1pyZGhMZXpxc2dqNHp6b3dNNUFhWUJjaERHMnJlckFRME9FWGVrdm94OWdDQWFHTHFORHNGV21oUWtIUjh6OHk2RndFNWNyQytXV0NDeHQ1T1kyWGUwYjRtSzhUWTNXdjR4ZEFFVHVzaDBYTk03WnQ5Tkc0UHYzM0dEeG9mZS9YTmR6eDNuZk9IKy9pTXh6bndBaWpmQmVLamUwaGpCZWFzR1pHMkJ3KytHRUFHK01kbDR4ZGxjOS82MXYyQVlMVk90My9lR0RwRnFyS3haMmsyM0RkOHE2d0xuek9mbDExSGVkMTI1VEd2NjZxZ1dZSEpzS3BvV1hwcXFmVUZZbHd6cjdPbUhxVkZ2YXpHbDZtOGtVa0lBMFlFdjBGczFjNThPWjY1VXJmVG4vN0ZUMGQydXpGUWduNzJzMCtHMmFoMzErUHl4amFySmFTYzhLZmV2UFVySXhoRXdJNmVXTnM3bXg5YkVEVndGa0VwamtVQ1NsN0hZRFlEY05GS2dKVDNSaFo3eE81b3JhSDI5Ym54K1RhMW1RVU9Vdm5YeTM3ZlNTcXJSZVBmc2hFVHNZa2NhTzJxREdSbnA1TjRBaXlTNE5Gb2ZGK25ockZZVytNM2xmUnR6bkViSWwvTTRnRTdnUUQrQ3hQUkVmVGkrdUpJSEwxMHNVVXQyV3hVeDdlNHc1a2ROd0FzZkc0dWcxaGFmQ3J0WHZlS2ZBWllyUVJhbzNDNXdzMUhuMzgrZS9iZ3k5bitzMUlrOHYzc3R6bHZjejd2RjZVa0dmaXNGSUFEdm5jMUI1VEtJWEdQNXNpbng5UVFrVkgwT2NDdERSb2g4UWhJTWF0QzFaT2orcjEvOG1UMjcvOGt3T0lUR2oyZUpvSUdUSC81K0t2UE1lOS82bkVPWEFQUUkyaGpvai9nR1hWbnRKejVOR005bG1TaTh6L05sWUt3eTZkVVdvTWZ4OFEzelVBSkVMV21BQ29tQUZCQlFmNFN6dGplVHl0ekxZbWNmZ3VYMHhMbjBoWTVZVVVKMXpNSCtLZ2NmRHJNd1liUXBjYjFnRUQvQjJZUlphOVB4Nk1ESEs5M25ZbGZ4MnFnbStGb2o1YjROT3dsRU9JcndpQkFiK1E5OVJ1OW9VbWFCczdsZDVWREp6TWV2WThPRHIzSGNOWmRVNDhvMmpnQVJETUFBUzlNOTJqT0RaTG1ESTY4NWo1QVRHNmdsQW5DMm5jQUVwOGJqV3ZrRUhZTisrSDE4MzJ4ZDU2N3ZnZXR4ZCt1aTcrOGZnNW81NS94T3Y3ekdUdzN0TTdtQ0RnRm9WeGZNR3V5aEtZdXdSOThlSGRjNjZ1dkh2YTkwMkdhQVIzQytWSCtLeUIxcXlZRVgzenh4ZXhYZnZtWFc2UHAvcGQwQVMxSXhNVFR6VmVwRDVQUzhYbU81R010U0UvWTdITTI1bGs1WHF3by9kS1kwMXRibDhmcDRVY0ZYZTdmdno5NDRKTEFXdlFDUkkyUkFIZjI0TTJidC9KVGI4MSs5S01maHhmWHEyaDVNWm9rQU9nYk4zN1llamVtZUd3a3lhYjJma3dqTWxtcUhWTUxjL25oUDZMNVdDU0w1Z0kwS3Y2TVBoalRJZlJKRTJCZWNGNVBGKzNpZ2N5b0Uyd0ROYVVmZ0RnSWd5TVVNYWY1NU11NWZmdjY4QTlSdnovNTVKTnhELzR4QmJoTVA2QkdYZWNIOFIyTEloaEF1dXBsdGRMNGREL1VUdWEwQXhwKzhJTjdzOXUzdHJxRkNPUGt1ekIyWUR2OGNFa1BHMDlLMFQ0aTk0bnd1d2NDcDdZZUZlRllpdmxXQTVTOXptZzhlWm41a3NUUkhHNHBoejZuK1l1WFQ4cjZyVU5xMFV4SFF5L21peHBSbW9oME5Cdk14a2V3Z0pxUHpPWWdEdEorTjhlOWF5ems5MWxhdk5oNWNJOW1mL1RIRHlyclFibk5Dd3UxcmpnRDBmcjVxdzlvNWZWSllwKy9kODRNZnA4L0gydlgzdEp3aDhZQ0dRSXJaaHdmeVRsWWlISXh5WUNSTmg2VHR1VCtqYVVmRE5rL2ZTYUtReDlkenpWb2txNEhsT1RxU0NTbGpmRGhhV2tMb0Z3N0hodWExVGlLcTJFTHc0L21lbzBIa3pUaDl0T3NlcS8vQnIwRkNEUnB0QUZzekVuS0FBSEdGQVEwbk1sQXdkbVNldFVUZE5ONk5RYzM3VE9UbzV0MklQMEVPSlJER04zMEsxcmc2bUFoUkN2UkJkb3dFRXZPckRJT3ZFRFFlSTdwamRGNkxqVSsxN2VHa3gvMFhCUDBlcHBkL09EM09mRDgvRjZhaSt2OXg3MXl2M0d2aWMrOERtejk5dkJabG9FNURTV2lkY0NYVXlCQ09vdzlKZ1FEc01ZdllzY01KRGgxNmVVczM5blpIdXZENUFOc0FrdFNFZ2hmR2cwWERoT1NBRmI3OThubm53MHQ2bjYrWmZjR3pzOExqbzAxYnM0aWZkWlFhUTB0MVZGZi9GRkthZzdqVytZaVg3WHVEalN5dzRTWFZCOThJQ1ZKUy9WcFBxZjkvV3dramFJRnVaV3NyZTN0amdLOGNMMk9Id21RcnErTHhOQTlNYTh2V2h0YUVWQVN4VkpmTjVpNjk0Q1V4ZUJFbnBDK2l2a211TktHVTllbDVQc3N1MVR5bitqZVZ1ZWpjVVNmMXBIQXNnKytDMWlPY29nN1Q4ODVaQ3RGcG9ETFRrbWdpN1ZnZWNkUlgrUUtBUmc4cysrNGhFdkhxTy9YL2ZBNFRhZXZOb1o4TExTWU5tN2VCdFdMZlRmL3lyc2t3dXpzWnAvdE96blNFUUVLUXl3Mm1OUFpoZ0ppaDEzYXBFVk1nVGo2N0FDeXhpcWNYV3BWOTgyTWJLSHpTMGZJRVd4OXRQSzRWNFNacE0zcHpDZVU5ZFNqTllwSmdUOWlIZ0lnODlFOGxuSnNJamlwSHBKZnFjc2poYUtrUzNrcEdNN2FpNXhwaVRQTUZndjJ6ZU9jYU0vL1B2ODl2WTU5WW90dkNOdnpuMmNNR2kxaWpoM0dtS1k4cVQ3ZjE0YkprOU1jcUEzL0NVSFNkY0tEaUpiWlZ1QWlUVW9rdVNFT0doa2FUN3ZKZGJCVUUwSm1EOXFaSW4xQW9iL1R4SUFLUmg0OXNJQlpMV0pFMmZqQzNLdkJEQTNOZUkzak5OcHBCN0QzK0pkUW93Vm93S2cra0M5MDJwdnVrU2FqR0h1ZVk3eDlRNDl6alVHNmlFYUNjcUtzdnpGdTUyZVZFb01HcE9yczdUcFRRTlN3TVhiUHFYd21NRXJyb25sTkxoRW55SlJYRitCd1lUQk4ra1J6WlhHMFZ3TkltR3FUOXNWdmlYYk1hUUplYTBwb2NKaDdtZFV4N1FzNk9ILzg5ZWYrdHBibjlJbEdDVm9QcjQxNU5uaWZNUi9BSmNjUm1DeVhzRHRvR3IrMWRnSTlYM2Rxam5yYUgvendGM0piTE9ZRS8vSGc3MmY1bEdpU211MXBOUVNrbkRjb1VzK3hUcnY2NU5OWHN3L3YzNTk5OU5HM1pvOGZmWjZaOXNHd1dKNDlPODIvZFdOb1dlaG1zVFc3djNNdnE0TVF6bzFRZWdObFk2djhMYWRVQmN1VjZIUXVRNjJiLyt6UGZ0cGVUSFhEdExQSllxUFZYaGgrTE44akVLUlM4ZjFLYlZxT1VKZWErMXh6Rk9EcTFKeEo0N0FvazZxWUJoQVFDRTIyVEMxS0M5WUhMYnkrNThlWkN2eEptSCsvcG5Gcm9Td0NBWFJXOGMwYllNRFVtcm80QUNYaGZVd2tFUkd4MkdBZERLNWUxWDhuVnVyYVYzZHExTFg4clZURTEwTWw3S2FoL001QVlodStVc0xhalZvdUw2ZmhTRHg3M3luRmpta0hYR3VwNlJ0RkdaZnpXMGtvRkgzczY5RjhHOWZtdW5mL2RKL0paMk91R0RNeTY2ZjdOeDdtd1FpVHQrZ3JEWXJ5d294U0l1UTVzSm83UzdzS2ZHZE1KbWtDbVVsTXZ0Tk9MRGtxTWRSOWdBOTFkeUwwQ2xHM0JTRFN1bUllaE9VOVdoWlZlSFg1eXVnK01YcHROVjdqWTE3Wk5Nem9ZWnhqL0NiMG4vRTRCNjdwTzNhay8vQlN2NEZCS3hGejBaaGl3Q1ptYWRDQWcwRE1GNWdnWm1EdVNLWGVhYytuTkFPSFVFeW1Ic21QWVRpNGZNZSt1dkprZWlxNW1VK1FFUlowSE1tTlEyc3lCVXdla0xtT2RYRWRnRXJZdVRjemkrWWlvM3V1YS9PWjZTVFEyMFBLanJyUnRHdUMwOWhOYUh5LzlSSVpibW5idnlrbFJvbVNMR210c0ljN0licHd5b3o5WmtLcTJ3eVBodmxIRzZKUjdaZVlpbkYwTEJpblR3Y0tZeithQzlCd1Q2WitFeCttSU5EdzNEd0FHbzJUS1l1WmFTUzBGU0ErOW5FYTdIaCt2ay9BWnhLV0UvajZyTWY1N3dGTy9lMDN6Y1QzQUpmOXhYZEF6bWY5ZmE2QnNXNnM1K2dXVXU3aUZ3OCs2d3BUMWNxZ2hNYTJVbk5FUWtYQk8zL2VkNzU5ZndBWG4vRnFyaGVORFRielh6Mzg4c0hzd3p1M0J4Q2RsSHdzdWtnN2M4K3hwaWtGd3d4dWZNOWYxZkcyRktrUDd0eHNTZXJjVWpyU2c4OGZEbXZpNlpOSG5jS3prNm1YcFZLZUp5elJ0bG1lRmdGdVhqQ0ZzTmY0RDZrNGlmNkhQL2hnV0FZRXFFanlhSkhzNXVNTDJmRVczYUQxWEY2cnl3TENHaElrU2RmYXRLbjVnam9aMlB1Y2JnNWo4UDJEQXh1SXlOSmdJbEFkTjZtbHh4SFI1WXFmTVRCelVYNVZuQnJqOGhsVXZyUDdzc1hJQkF0d05yY2tucjJiZmZzNzl5YnpNSk5ScXNPVmNqMGtJTkk4VmpMVExsYjV2MUUvcWEzdFN5VTg1dGZxK3hjNjJvcVp0UnhnTVVGWG1zTnh4SUtnZkcvNHNWcFVaaEVISGlKcGNLUGFuQU85aVk0dUJONWZ5UmwrVm9mT3g1MXFhenhMQVJUcGppQWNOM2Job0laakt5UTZLUjZUWkZKWWJOcUdQa09JNjV5d0VCVXRqTnFOSVVoN2dLNHN3ZkgxUTJPSnVQclllTzV2UkRpWmU3YXR2Vzh6QjNPT3YvN3lIMHlDV2NhLzB4OWpYb2gzWWk0Y0hVUDNIdUFZZ0FXaEF3eW5CVStnaGdrRGxGUkk4Q0pWdzltT0JKRU9Dbk85dDVmbUNyWDFYajlMQ3h5YVFiZmxPK0hYUVp6dUJ6cUdSdDd2VVp6dU5vMGxaV09zZXhPWmlMdHJtUTk2Y0MwVi83NUh3UGdidyttUlJZQmFiN2xWRmtqYWgwTkt1QjdlbFcyUFVVTFZjWDJudWdnbVlHYnRuT0VJdnc2emd5bTRYWXNkQWtrM1ZnbW9hQmxETzQwNmRJNFVNTFFJV05wWGY3dmV1L2JXbmx2L2NhOVdhQUFCVTdocjZINEw3TkUvelpYWkRQVE5lYXlSTmUrN25vL2ZCT01BUFovdGRlTEErdlNESHIxMy9sdDlMd2U1K2tDMFF3czFGdGY2K2V2VFBQM3Q0TlB4bXpZWkR5NlZMTDBmejFBV0hQLzE2dFhiekxOcitZSmY1b2E1T2JRbDVqUnJSaW1UZGQzTkJhUjdxMU55bnRmaXhkclJSUC90di9rMzQ1cXlBaFQ4NDZlOTdxTlNBZUJwNzVUS083djM0WjFBdXFUd05MVWJtWUpQT3lad1ZLVzBqcHBQUHUzMEhrMFdYNzZvTmZMNGZqV3ZJek5nT1JkTGtmNGl4dlp2S1Ivb2xjNCs2S1lqQUtaNGYyNC9JZGs2TCtxZmpNRTQyeldkRnpHRGN0dFhONGR0cWw3S0pnRVZHek1BSnpwUlZMbld4RGkvUjNaMGkzU3hVQ1RVOWptbUZodTZQUnJPYVJMWUlJREttM0pCeGxscStVZ2RQZ3FNUHZuMFo1bFVFV0ZmNER2anV6anErTzFuWCtyY29BbFpvZVZVNUtQNlNBMWl5Y2wrUk5PS09lWkMzclhhcFF5bWl0Qm9NTEhaWkRKRUZITWlVMmt1L0JVVWdUY0I3VVkyTW1sK2tJbkp5WG9jVVdDUWxjYkhpYi9iWnIxNE1hbklSMnJrMHFqMG1aNXJVZDkxT2s4ME1ydWZBM0lseCtSeEYzV3RDMW8xQjF6UG5wVUMwVmczTHNVTWNhdkMyQXVCTkFCM3hxTE0zaEYyYnUxQUNaTzZMUmphSUg4UVUyTktiaVRKengvZGNEeGFmSko2L0V5di9QeS81d1R0dGNFY09jd25VQWxFKzQ1eFJ3WWpzREN1RVpOYU4rdmJ5NjAvYzRubW5DU1BEblJKUFQzUlJUWnRKT0xhQmQ3dDB6RFhTOFNsK2pCOTNNT1BlY3ZzMXQ2RWF3RUFvd2ZyZzBscE4yNWtuT1Axd09Gc0hNSFc5OXM3dVRoU1JtaHpvMFFyRFJlSXprc3F6ZWN5QVNORnJXdDFYUm9NWnNWSUJNRlNiZ1ZKcittRnBjcGNHcTlaeTVNRTYrWHEyUFpqTXBvZmZkTTQwRDRmMlVGaCtmTVRzN1cwVWJ3dE9WVGtzYUUzajFhdkh6cjZPQmkyYXh3ZDhZa0Z1SzBULzUyMTg3QysvcWRadG15ZVJ2Y0FtSU04azYvWGZZWVBXRVNhUUtOZGFnRisybWN3cmIvUmlTTGdzNFNKY2lNOHlOVkJxQUpBTkFUZ0NHUEJGY0NNLzFhelJtN2Z1ZFhjc2t3b0J0SGVXcit2Sk9BUGp6cllPQ2M2RjgrM3YvT2R2aXU5b0xTZHpoUUFrTzFXYVMyUEdSU0RUNlVmWFlyR2xkYm9sTEtlaHFyekF6OVdtekY0eFJqVnpqNHVLMTZTcmIzdzIvWHd0alFvQjRhTTdySWx1V3BoMDVuVVkrMXA4eTllUFU4QnVWUnUwL3lvSlZRcDhuVzk2RC80OElPRVo1VTJDU3dKMTRmZFk5RjVYeFlTNDhtbGV0bUJCZTl6MG1uSVoxdEZ2cGd4cjgrbVNCZUg4bkRFSTh3V3lva2JvZ2tBeUFOQmtRU092V2NiZTM3cjl1MmMyVEZ3V2dVVDgwb1JoSU9TUExYcGxSSWdRMzZ0NW1ETHJkSjZTQzg5UXFpVTlqSkZGb1UvcDR4M0p4aVBvNU1XK05qS3ZlbytCMUlnUnBrR2FSVGhHem4xc1EwOXlHeWtDZEFnRUliSFJxZkxPQzl3TVhCUzdrT2FiWlMyb0xML0xHQTZ6ZkdzRWYvRlZGbytLNUhFcDA4ZmpVNExrZFRzZWNSOVpXdDlkdVdEbTdQVmFpemZ0eW43YVpLck1RUm5Jb2YwcGEzeXlib3VndUxmV1VsYjNjMXNsQms4VGlscEh1L2ZaTUttdVdyOUV2K04xMGw1R2hHQ0hTRFN2NGd6cUJsZzgvTkFOVXlUOFRtem1oNkF3T05jYXZzU0UyeHdUYzlkMVRYY1kzcTRjWURUSDh6aWhUZ3MzU0hBV3A1ZHppKzRrdVpLNHAwR1ZHL0tHM3ZPbjVjZmNqRkdqdFhHV3JlOGdkU1V2Q2pXeWh6Q3lCZlNWTzBoMDR3Z21qU0t5UVFqT1VhaWJSbm1pbG9sN29aaWc5Q1BqcXR0YkYxSVZMNlhoWWg5ckVHbWk4ZGlkS00xOElYQUIwZ05EVGxmcU9SR2tXSG5FV3dtVExTNEZ2bGJqTGRXUkFGajNJMllHZGlTNkJZRldORVdsQzJoVlpvaE9MSGV6UEtoV2JWKzAybEt2ZFp5blFXc1FlcndaVWtKY2FyTWNzQUpCTVphcDJtamdTQXF6YXZGb1RtWmY2K0oxZUlSZ0tXVmRxVFdndGlmaEZmckZzcU52ZUsvazRheG0vOFA0RklVN0N6emJZQnMzNVVSZnRMN2ZMVWMzWDVQamZ1NmM5YkoxWjNhdFhUTmd5eWltemZ6Qy9WN3NRb05aM1ZldjdhVjM2amdVVlVwMTY1ZkdubFpSNTIvU2RFZ1ZEbmRGeXBqdW5aOXEyTG5lck1uak5jdjE5bzRjSHZieWVxYnZTLy9Va1NRajVPR3luL29mbmZ2M2tuNVdSbzVsTzlhazlQR3VscEhGanpNOGdLa2I4TWQ0QTJvV0hTQWMyZm5hdG4wVG82bS9YZGc2MDlMZjdqekI4T1hxcU9FTXdRVzFjSDVlVjk2Z1lHeTdidktPSXRQM3ROWDFmV0lIdDYrZlhlWWRhMTF6RnlCWW1ya204Q05ENGVEZnUxb2JkeVlOcVpWcTlBbklHUmlNaW5kUTVLbGlJd1RlbWc3K2Q5U0EyV3lWN3RVUmI3a1JjbHNkKzdjbmdnMFcxY2JES1lqZ2cyREl2NG1WNmtBWm02cDJueDlybUw0Q09odGlXV2tCVjRjVWFWTWpzbmMrVWJsanJpbXJPWEcxRGlIdEd0VGpKTzA5aDFaK0J1MU5sbUl3SzhGdEU5UHZzeE5VNFA5YTFjNmRhYUl5UDZyMmEyWTZmdS84aXV6emV0cGh3MHFYbzBZYTF5WUkzRUZLTGNobU1McnREZTJOd0N5aVV4THA5UWdXdXZtSkdxUHlCUUxUUCtaUUdzR2RNWjcvVDUvUGw3NFQvd3ptTUZhWVlwK3U0S3JqaWQvNVh1OTluTVAvaVJyQ1d5RzZaVTVkWDByT2RqYUh5TzZnSHlwOVR5dGtkNzgreW43bVFsMG5EbTNsOVo1bWlia01JM2g0QTZNbEd5NXI3bU8vbFlCOS9BcHhaUFMxTHZUMkpzUllPaTVXa3o5MVNiQko5cVY5aE1Eam5xOHdHQWtIQ2FON1p0dXFSY3krMDdUd0EvelVUR0x1bGpYRitsMXd2aWxJY1VKVkFBZVpvN1h6MktvdHptRjBiTUlGQ3lCRDhzSGFWSGpjNU5HcUMrNTk1UjlLZkllS3dodytneFFzeGRhK2x6cTdEMkFQRG41dVFHYVIzUTBkTm5XMzIrQVIrc2NZTmgzN1FsdGMyaWFQUWZpYUhsb1NIM08rdldWUVp2U05FWXY5QUNZcjRmUERaQ1pGNmEzeCtoS2NiMXJIaVk0cmV4S0d1SnU1WFJuQ1ZFblZuMjdRMkMwaWZuMDRlZXo3MzMvdS9tZ25tYXVPUXdsVUdwZXcxM1IvbE5FQkJ1a3ZlaEdxenlIQUZCeHNwMEQvUG56SjhPVmNTbEJybVUyN1lzZjY3QkFHOUNsYVZzNE5ZU3Z3NGFuVHlmTmFYMTlNNkJONllrL3BZOGNWbzRENEZkVGRKU01YV2tjcXl2NXM0cklBRHZXbmhwZFpYQ2ZQRTlUNy9ydm84SFJNNDEyNUtiNldyM1BGR09uWG16UTd4UTNka01MaHNtVTJXQnN2WjBSdHRDM1VnMlJMVm9YSW1qOWhwUUJSbGMyeTcvcXB2SlJQdjMwcy9GZGFNNWtvbXJyVGlwRllXZ0U1VHc1TWtpRVFsY0lSMVlqSVBXRFBrTnlVczFKbFBVbTduaXVyWjFPVkVsRi83cUs4TE8wdG8zVkNEd054cUdyblBRRGhOcEVENzNJYmZRQWpkUnRUdnZCUkkyVGp3NUJ0ZE9WZE9nUDVGaXZTaTU2ZlNzN1hON04wb0VPaXJVc1NZbzliZE9PQTdtdFNuWG04eE9jdGFIdXh5eHczZlBlMTh6a0FiSVJOMEx3OExlRXlaNE1aaFZhajN6SDYrN3ZaMEJVdndmSTlOSi9MbEM1dm9kNytMR3VBNVFIQ0UzQU4zM2kvRjgzL012SDBFS2JNeURRa1BGcXlidDNiMitsUGN4bXp6dEFaTDlJN3VWTFJkSnFBbmRwWDg1UDZ4MVlhVFhEdnlMTlpLbHVyNElHaDRFMUFXSnREeU5NWjVsTEdMWG12ZFFqTGJJbnN0OEJVM3dlWXdPR2FDck5hRzhmSXdkQXZaZDhHelFER0hRRjBUZE1ST3JDV2xJN1dxQ3hZOHgxTlpIMWZkb3FyQTRrUklQNXlGeC9PS3ZIQWgvWC9iSThPZEhQTkc0YTNINlIzTEh3YkxjQXdlRWxvM1hNWUw2MHVUNHp6dXJMSEJsRFR4RnM5TTFETFNtL1ptallYSml0d1dKQU1qNDE5cGQ1UHdSMmUwR2pwVzFQK3pQNXRPd3RLMENLUjdkcFRQTGNKcER0WWdPWXByMFU2S3BmVy9lN1VNQnJ1RHphVitQR0ovekVQdWRhSGlKc3ROVFRqcG5MMEV4cmlRZnk2M0p1MC9yUmhZamVYb204QkpYMk1VTzZ4azg2YWh4WEI2c2U5bTFWSmR3Wlcxa3hYQ1RETFJKNDZGUzd2YlV6NXNocTJrL1ptZFhielg0dExtM01YdFliUytiOVNtMkxsc3JsMHh0T0JjdVQvWkt3bStpbDhHV2hlN3IzYXZ5MVdnREFvU2FQSGo3b3RRa2ZmdkNENzQrNWZMR2ZPMkpXRThlMC9JV0Nhb3VqYURuVHpjSmUyOTV1N2N2SGFoTVZqbDVKZ2tqejUweStYQ011RVQ4UlFtVVY3MnVNRkI5SHBQeEEyYmVaWmJMVHBVSklBSDN4NHRYUUlFUVVsTjNvWXFqWm5vZHMxbGRMY3J3bWM1TnRqbHkxaW5udzRHRnRLYjZhL2Vhdi8wYjNyWm05bGhOeW1Db04wQXFIVHcyWUp2cmFwTW1KaWRsRy9XRVNqSVFXUVhMU014cEZKTG9oR0NOYmYwMStWTVRJUEJCeFFteGE0UXpWblJtRElGcUxWaWx0WW1HMmZiZWt0aVFFZGY5dGpMSnovOWFJZ0RFMTMwY1VKekhGbGF0YmdYT21jbEZFV2hwQ0JGSitTRlpFaFhrOUg4NzVPSFMwa2pVSElid0JVRmFtcHhFZVRldjg0ZS96eDM4T2VQbjhYLzRBclppTHllSHhsNWVhL3ZqbVpXOEZMNzNkblJ1UFJuSVhXNGYxMXJ5ajdtTERTeDJReVZzWTlyUTAvSEhqS1BrMEVQNCt2YjduRjRCVlROYTlYa2Jvb3FXMDI2TTBHaWJuWW9Ub3RLSnhHRVFhcXMrdEJ2aUFnMVJtU2pEeGw1WWNpRHBwT3N3cmZrdU84YVhNUnJvSS9GdTlramFQN3BMQW1zYzU5WmovVURORWtXSXRVdENnZ0F3d25kSU9wblVaWmtoQmhmYzVuMlAzUUJSb1pGVUVRS0ttY3NaRzE1SHVwWDg4YmRQQzBXRHN5M0hYSDkwWFdnd2dhdVdzMS9BbHBmVU1rOTVLRmtIV21ZQzJ4Q2Nwd09JaE1BVk1SV2xwU2cydmU3dVg1NU5tN25PK002b2wvTkZqRWo1VERwYS8zWS9pb09aUUF3cC9XL1BKbnh4OU4wZVJlOEVHQVRJbFBHZmQ0OEdETDlKczlIeGZ5MGVWUlZJcGxid3M2UkdtcWlvRG5lcWFnTmR2Ui84UFB2dlowTFEyUzRvZUdyTkFTTURIci9scHZMcFhRQTNQOE1XdUJZck1TbU9uK2U0NU9lZndtUmxVUjlnaE5RbTJoZGI1Ulhza2IrNWEvZDhmZHcxTkFUWDM1TFpaRHVpLy9QS0xmaDdPZnZENy8yM3piUHdCVmpyTDFIRjA1Sm0wc2xSYjRISFVSclRXUFNENzFQcEVBU1dOaHVOVmZnVEpJMzFBRkFId1hLa28yZ2JRdENTSkdqUmJleWRONm5rdEtSWjMrYXhXV3NDZDBEZjBqNGhsV2N1Y2R1aWo5c0l2WGo1TkV0UmVKdlNXUENyWkRJSnorQUVWaEhjcDgxRldMRUtpQ1hGa3IxMjRrbmIxcHA5blNRNk9Wd21OU2ZmR0FJQlJoY3hnOXdlQ25KcGpka2xyZVVJMFBoSlRLY2xSei9XcDl4bjMxYUd4UFAyY0lFa2ZuckpNb29YYUwwK24xS1pOMEM3endZM1dGMzFIOFRmaXNtNmNvNWFSTnVGNmlIUnFHeE1qeGlUSDlZeWF6MitIYUZ2YVFUQXRlWDgzNXZITk1jd0JRSjc5ZGNEeTk4OERtczlZYzYrWnQvZlBQNFBacGtzYTBYU3p3WXV1MncvdzVnRG02T1cvZko5YWZuWkNpODFEVUFYQjJ5VStwcjRYWVBFNW5lUURETWxtUzVmU1hLTUZ3UEFtMEthZExIZVdvQTRlcHJFY1NJMys3QUhiR0gvWEc0RGEyaThITW03Z2RkVUYwaU00anBtSHZkUTFSV0xMbEUvam1nSXRmRWVFRHQvSlNvS2lZbHBkYVF1Q0tNMWFXN2R2SVZwQkF0SGlLNXNWL2hidFF0TjhwZEpIRHRLVVZ0SWlwNVNIU3E1Q1pPMmNGd2lSN01tNTZORDRqdnNjemE5QnREZTBLWnA3NDR3cGFYcW5CUnc0a1lQQldIRUNObzdtc2VkOUQ3MzUvRkhNUm9oSlNPWmduaDdUL25pT2o4Yld0RjhubWNvRTJ1UkFGN0Z2TGVMUzVkYlVPdkczMFpENC9yeG5yNW1LN1ZxME8ybHZoS1F6Qkt3Rjg5N2FUaGJSVWFlUFA1L2R1Myt2NjZRMFZFdTRXdGNGM1ZLMWw3SnZvb3FyN2VkSzJqV3owamgybzRQTnRGYWxOU3d3d2tPSER1NEJGc1YrU2FFc0YwRTQyTERYVVdJWG9uMlRvbEdyVEhpVGRXWU11cHdrdXZyN3lleDloZE9yN1FOclNXcU14Z2FqRVVEM25ab0VQcTJXOGNxc2JLYzZDZ3RFVGNKeThUeWJmZlJuNzhZV1RPVTJLV05CYUJhY1lsQ1hxczNlbGFJdzhyTVFWSnRoZ3gwaEQ3QkVHUHR6Z0JhcElURlNPd21aOEs3Qjl1YTdHVjBKazREc2ROOFJIU0l0MTladUR1WjJYaGxndkp5Sk1DS1liVGIwRmVhZG43c2N5S2hMUzJNQk1xbmxCd0VGeG9Mc3d3UkxxbmlRUENJcmZvLzdCRUFJMkVheXp5MDZJQk54YVVrSGNBemdUakpjQ0hnWGFwZmhPUFdoU3ZlWlloVXh5RlNaejI5RjJrcWdYUTlJdFljV3RVTG43d015UklWUmZOZjgvVTAxcHJvSFZURVdVcDgrN3pzQWdWOEl3QTB0cnl1ZEE0KzNyZlBQUHlZQStLdWdaUTk4enM4QTY3NkF5YzZCWVh3SGgzaDg4emtFTjRFa0JzSUl6TFhBcURVN0xPRnpkZmtrd2FDTXA5ZVU4RWhleWdSZldjdE1ycFhKNHlkRmZWdkxTNldhN05lelhwRzErY3JsV1M0NDhTNUFHSDZ1R0JKNElkN3VsQjhrWDJiQ2hmYlMwaVRNY2plMHA4ZVprR2Q5TnUvUElGUVZEV1B2QTBqejBoOS9OOFpZUEttalpReXpkRG1OYTdFajFCM3MwWXF1ZDNwU2ZvSk1rNGRqellFU2MwaHZjMmwwc3JxWjRzdjVEdzhxcVlvRkEreGtVaEpleTViWFEyT1lRS2lGYVZ1bWlLYkNaL3N5K2F4YW80U2NjZkZiemZjNXN5SXdoN25RK2cwL1ppOENPSHMvN2RjMzJoQis4bC96Y2IweDJ6NEh3T3diZXJVbjQxRForT1A4TmI0ZlVUcDFndE1lVC9tRGdnOWJFaTNUV3ZHVU5pOWRkS3l0OUtObno1NE5EVXlYQlJINDVWdTEyM216Tjd0YWl5RzAvN1o3TXRmZUJ2QWpSNi9aY09SenFxczEzSzJyQ3MzM01MOHlXanJ1TzdCaHBUeklVWURkUGNnelZzOUNaalYvTGlITjNmUitSQmVMMEthTWJON1M3S0NjelFCcW5EQ2RIM0t0UU1qY2ZNME82aTVCOE1HSWU5LzZJTDQrbk4yNVVkdm5lQjkzeW5hUFZrU3h5aEIvbXNQZFJMdUIxOWlqSDMzdmU4UHB6Z1JzbjRaUEN1aG9TZU03YjRmVFhkSHkya2dtbzhZQ1BBRGlPZDhPZFZQYzVTQnR6RUxxdkhtSkJLZ0hsa01TZ2FKczJ4VHgyZjM3OXdLYk5Kc1kvSGIrSTBlc1EzVTVJcGpjY2VUcm1ZVXZYbVFMRnhWNjhPV25FVnFTcFExZjZVekM0NjdOb1crOEZ5NWtaclFKaUlTdGJIRTdHejJOU0xoZHdxbUlUWnVlUktaVllXbWZHN0FWb1pCbXJmMllpdzJjaXhCSjFFRjBnL2hpbkw1RksvUHdPZ0pDbU83ck4vQkE0SXFoclJ0aTlKMjRNY2tUOTFYS01Ec0pnTk1vK3ZqUU1vYXZveitFcDEzVHRmNy9QdVRHZFNtai9Ma2ZmMGRoZzJtWWpvRkdmd29TNk9BQWlKa0hjNEVEQ2JnZXcvTVBOdlRaVVd0VE1udnZsWE5USDZUWXVWN2pNVnZyYzFBK0hYUHg0RmxtWWRxaitzSGpRRS8zQy9XS1MzVWdaYnJ3Z2VxT09UcUV0Z2RvWlMrVEVMRmlmb21DSHNNUEZlMXhtQzhrT0ZmVGZ1ZlNXaFpKNWJUb0s1ZFhpbmh0NTBEbXdKMkt6d0Vtd2ZhcVF0eEwrVjlZQURRdEVsMmk4Y0ZlOTA2YlNNSTA5dWkzM2t0OFYveEVienR4cVZHUEhDdm1JeUp3bitIY0hqVE5nOVYrOVJ5d3c2ZkJRMTJQYVRpYzM4MUIwVGNnNGs0QkNMVHVDWVFBWU1Ja1lZVSthRlVUWUUydUJKK2JCSGkwMXBpNFJOQU92b3BhUnc0WlU1UUQycnlHY0k3RDBCdjN6cTRlL1BONE9DR1RzRzhGQStqQVBRMTZuSzJRdHNOYzFsYm0zWnNucldlbkVDVlE3UDJiZU8xeUNkM2JaYWpiRHkyZXVWYVdGNk9CZUdLNWJncUVMN1AyVG9kY05JMDBKQm5yVW8ybUh2d1A4ejl6dmR3b2kxNXI5QmVsK0F6QWp2UzRjbzZQcjg1KzRSZStYNHBGUGR6N0hqZlMyNnd5V3ZxZEQyNG0zS3BSckFKRXplZWxsS0NnWlR5WG1yVFlQaXdDREZHLzFtYlluQllWa3VuRXllbE5yZFMvU2ZTTlk1Vi9xSjBlU1hrSCtTZTBrbGl2dGVwZVJPQzdvMTF0YXJ5VWdYdmxVV0NSRjZsL1Ywb2V4VFdQS2hmNDRPN2R3cXhYaDFZRytPcUNGSUV0VnRkMG93blVEYUdKSEpSTEl4OW0rTXp5VlNocjBXL280Y1BQdTA1YVh1SDE2K1Y1OFUwZGNNTG1nRjJKOE5GWXV6b0FpUVpsZnNibDNrQjArSzNNSUdMU0Z3cmdNSVdvOE5SL0E1WjJNT1ppOEQwZi9vc1l1Q1VLckdQaWRoZGpjYXJ5elFDcW9WM0dET1FzWnl6SHFFUkdtNFlSaG1PLzkrQVA0aUtWNWhRVE4xNVN4Y1dISWRpMStMejRCcysxcGY4dm9HVXNIZ05ZeHpOVE9nZTlNYUh4S3NZd0Q3OHhVSFRkcDJMRkNFRkR1TmNSRVg5TzFsK0JBaWZ5VG9jQ3ZFenRsNDkwc1R5MkVIeXNsOE1MTkREa3FEMHRNWkNXY3R6K1lTcUVlRmc0bUZOOWhLdmR3MlF6czlZM2FtU1lNTEpxYlZVUGRXVFZjclorR0pId0V0Q0ozNGVaeUd5VDBoSzdENm5MTkZ4TnN5QmtnTmh5UXBhcllDcGVUa05JeTVEWXpQK3hHbjNSRkpwbUVjUjhPTkh0aFJ6RSs4cWozcVdOQStOb25UdEVRZi80WFBzR2RQbmJwS1o0REUzY1BSb3JEUWlOY1l2UUdpVURlOHdMT3JTdXpCK3VneUc4clNXQjFWN2JoZlBIMkNjMHhvSklDUGg3bU1YZkNFZjc2VFcvQVdnc01LN24zbjYwNWhtQWx6Q1FvalNmVDNDckJHeW0zcnVPeWR2bGZtbDZFcHBYYnRCSTVWUGx0bWdMYnQrOG50TFJPUWxGTnVSTWJ2dGU2M3RZK29PMUlFQXVKaERXU205eG1ER2ZreHd5TllUWFNrSEFReEpEK2FsVnBXZzh5WFIvVStyQzNkdWQ2cDd5b0J3S01JbWczcm56cTVtcmVNRTVwR3V6NjJHQVU1bCsrc25uK2VKV1oxdFhDK2djNStDUHAyVVpTSDk2Vzg2WU5TWkVXcUhTR2xJdkllOWFoQVBKSWJvYXZmVWNic0tZTnNwQ2l5YXFTem8rbm16anhZaEF4aXk3ZERjd1UycGowYUczd2JpT0xGZzJ1UHdLRXdVK2QzTGl2WHoxckdTeDdOZzZiZ0t5emUweWNTc3kvdEdQL3JqRlo4dnFHaW9jWGNQN3NtS1ZTa1R4U1lNV0t2c2FVQ0lRZFdZRmtxUHpUTG9rOGtuSGFEMTkvS3JGQmloTWo0bFJMU3dBbXN6VmlRQVFETUt4R0JjanRQazJXQUh0WUhjRTBwdnNlbk1uM2Jwby8zT2VUdjZheUtiUEpva2p6bWdwUXBuS2RKaWJBQXVSOFdNQkt0Znd3SVRhMFhCV0RwOVJqdG1qbU5tNmQ1bld0dkV1SmJVYmg3RjZBSzFCMUQwL0I2UHh4di9MUCtjRWZrN2t4amEwbGRaL0FHUHI1ak9ZeUc5YUpCQTQ2MjgrQjlyelFnTEJLZDFQSThTcmwybWRhUWlCMDhnR2IwMGwzU3BPbFJWOVhMNGFzR0lTRWpwTVdrZVViMThwM04zNmFSVzlrajhKSFpRNjNwNjVWa0FDRW1JeU5ZUU8yblQ0cDh6MEMybHZCQlovRDJDZlVoZ3lMUktLL0NwekFkQnhWUldYTy9HSC8rUzQvWEFBeVhMck5wOXZrWld3ektHY1JxWDRsb1kxL0ZNeG9HYURRMXQzaEZuSndGMitmVTFvZGMrajVzK2M5Rnd4dmJYUjIwMWUzamdjdGpVUU1SOEJHclRGYm1ndG1FQlNkVVRLK0lCbzZTTmpQM3JrdjZISmkvNk5VcUptN1R1Q0NVTjdpMGJNRWZDTWZlb2ZndkF2OTF1MlB0b3p6bWt0VHJ0bUN6Zm9INTM1d1FmNFZNb09oZUZkd0hWcC9XcmZtU3ROcVBQL21qcy9tckcwUkpuZTJwNlhNcEpmN2taTk1FR29wTS9kekxybEJBYVF1VlpTT00xL3d5blNaMVBsaUtDWFZsSDI0V0IvS2x6Ry81ZlRoSWc3Nzk4SnFKNHRTM2RhbXQzLzhNT1J3MFZnMG15WG9pMWd4WElhZE5EZVcwbkhrcjNLeEpkYXBSWVozOENRcjc3cVFJb3IrYmhTbUVTazFhaUdNVUxTTXRnalRCcENMMTYrVkVwQ0xWRnZiRitmcEcvRFFheFFGVU5LR3VOZmVwNXBock5QVGk0TjFBVWlWTzI5UFFXT2w4Y0M4RCtOQXMxTXdvUDlrTHg2d0tPa0x4L0g0YUVvNEtzazFISkpacVU4Y0tpM21JaitRZmxmR0h3cE5WU0VrZFluZy9uSmk5SVlFaGszZCtybDgvV1hZOE9GdWpGaktWcVpLb0ZBbTNJYzA5SFFFTjZwSW1WRVNYTUxHYzc5U1poRUdMa0pESW4wdGswWUJ4Y0VNSmozUXVQUWEydjRFV3gyMXlaQmFHQ0lCaEJwTlROQU5rM3R4T2Y3VDYrckViMUo0dnZvdVk4SVNCZ2tsVHFMYU9SNkxjYk1oOW54NGVYUVpFa2lvQWxyL1hpdWh6MnFIZjlHaEpnOXZlajhsVEZIQkQrMHhKNU0zK2NIYVU4QlUxSzNLV1pHQlZScExiNkowUWFqdUdwZndLeGVYd21ZMWxzM1BheGU1VlBZS3Axakxla01QeDNmZEhHQWNBSWlRRGxMbTFwYXlQZVFWcnphZHlBQXdYVGFmdXdHQkRwVkVBVHJBN0FDOU9XRVluL3I4akJTR2pKTFpNMC9POHFQMUxycUtZKzVidHpZamk3eW1VUXphNTAxS1FueWJQNmJob3Q5NWxKUzJ0NGRGNnFmY3JXT1psYzdMRU1vSDFnb2pHYWViYVkxQUlDWHo2T1pObUt6dWJqM1l0ZThFSWc0TFVZWjF1V2lYdysrZk5hYzA4WmlLQ3Q4c2NqeW1oYkR6S211dFZCQi8ybHJkaHpZZFpOaDVreGxNd1dYRWppK3kyZXJsaFZRc1FhQUgwQVNTUlhKbGhZZ1FYSm8vWDFtU3FjWkZEUG1JUW1VZGtuNDBpNk5XZVFUVUVZS0JZUDZIVDJpYVdEaXpBVEN5SEZkem5UVGRNQjNuajJ0cVVEZzhXRVdqbk1CRDNLVkFHZitRWjBiMUdqZXZ0V0pVL203bEo0OWUvNTRXRGNmWEt5N1F6eHdNMHZIT2xBVUR2WmV0dFpVdjQ0T0t5akdYN2RaQ2dtL0x5QnlPSWtLbDZQYUpEMTc5cnJhdzBkaFNRR25zT1JabjFmdElDREh6TlI5SllrVGZ6cUg5RUxuVjJiKzFiMWhNNGUrVmt2OGdiSE1vSUd4OTBXakR6STU1Wm1KMkdvaXNIaFFHZ0QxZURsSHA4RytDK1UyTjIvTjl0NWwwenV4T2JUbWgwSE13c2hIRWUzTE51ZGEzUVlSK1U4LytWbWZ6d2wrck9DM1pMSVlHRUsvZkVWQzBpcXFTK3M2dzJjUm1IM3grYy9HSm1yc2RlUEdqZTVkY21MYTNkVTZINzVJaGRXQjB1R1pOMjdkYmVPWXAwZXpSdzhlTko3WHM3dDN5aXhQNHA4RlhITmQ2MHJ2YitVSGUvcjZjUkkxT3pwaGRQVnFGZm05Tjc4b2dUUkN4K1VSY1UvSGVGYVlObW1KN0d5YXprbmE0VjdtSmlrSTNSSFIwdERRY2w2MzZScWJIYmJCODBreHFMTGJaNGRtRlpIUUpvRUpBZ082bzRkNG5IMGdHN3cxay9BNmhYZ3pSUU0wUHJEUnlhQzFkTzgrRXNGaDRDQ29qUklOQVdoNlQrMlhTSnNvc0h0akhvUGdJbFpLbUNuMVlqOUFES3A1anMwbVh3dUNqcWNHdzB6YUhRZHl3QmZnU3VqRVBNT2tRUHd1QllTaFkwUTZIMkV1eDhSdGJtT3Z4Q1ovRkNBcHhERkFTWXJLdUdiTUsvdWQ2WGNwcDZraTg5RjFFcU4xczR2OTNrbmF2a3ZBalRZeXFmTzBnOTJZdXR2MzAveHpLcTVYZGJDY3d4VVlZaVN6V3lqcjIzdkwrU2xYOC9VZEZZeFJWbk1XTGVpenY5a2V2aTM3ZXJPY3F0MFk4TGh4WGk1L2IyOHZoM05ycm5CZjhUYi9GMnRCUXF2U0dKbllnT1ZDNW9kcytmMUtrRmdTeHU3Z1hRbVR6UGlMbDlabTI1ZXZOK09FWEhReWw4WjdrSVRoMitzaXd4eDFYZ0gvNlg1K0gwM3ZhTjVveE5GV0xBUHRtNEdldGp2dm1wdUZwbFZ4TDR5Y3QvWUlUZENRQ0R6MWo2TS9QQzBrdXBpM0ZnSGxVYUR0OTNFMFNSdDF4aVF6ZXdSOFJEempGWkZkelJqeHl3REhOdjlsU1pvWE4xSUd1cDZnRXo2Wk90K1dCSDV6cCtzekpVOER0VHV6KzkrNU82S3RiOSs5R0d2Ky9QbUQ5cGh6dndoRldxbklKKzBSamN2UEE2cG43UzlUTW5zNjdhaHVvRzhEcjB4QlIvL2QvZkJlZnViU21kSzh6dkpKN1hiLzl3SFo0N29IWDB4emNncldmRGxhcTYzZjgxSXI1cG9USGozT1FtSlpBV0NhOWtsVkszeG1IVEU2aFBkU1d2VEMydnJpeDlNbTc4YnNuVmJUeHZOZkFTT0xhK0NxcmpFVVZaMEVRMVRNd01jbEZEcnVlaXZ3RXJGelRCREpOM3BmdFdqVVJ4RTBYUWlGK3krVk9ZK1oyUHFEcVdKR1dvRUlSbHd6TkNzSnBmeEVwSkNqNlVscEJiZ3ZNMDlJck9XSWJqVU5aYk9KcmFWRnplZG92YnE5TWZ2ZVI1bW5TZGpqZkI3Zi8raE9XcG5OVHN2cWZ2RmVpOTUzaXhBYVB5azBzcU43ZmFCNkM4ZU1wTWFTRG42YkkyWkd4S3RsQzZNNHBwdHhEOExvRlNvMlpuZjZ6a2hYR0tEb2JoRjE2MER6YTZuN0FaeHBjVjFMSFZwc1BvQk9mZHp4MGZMc1gvOGZQNTc5Nkk4Zk5jL0dsM25MWjlKeTlLM0dDbWw3NWdVbTZRRGdybUFjN2oyME5wL29EZExjNi8wNy91TUVKekJXQnNObTJ2WTNFS1dlT3h5RHoyZUpJM3BTamdaQldwL3grZDY3dUY0Q2NPVVk2Z3FYaS83ZExGbVdMOG9lajNxN2lOaGFTQ1VBZ0lJdE1wbUJnb2lTd0kya1JoS1N4S1lkV0kzaE8ydHBBQjhnNFFjZHZyVG1zeG1OTU5Nd0dvT0J1UVBIVjd1dWRWVVdjNVNQUmJSTTZvUURZSmQ4cit4Mm1kNzhmN1RnNXk4ZUIyUU9NYW5FcWgrbFFoYVBDOFQ3MGxFa0loTXlBRUNOcTN3OUhUaUJ6MGlZRGx4N000Mmd2S0VpakpQNTM5cDFMZXVNY1lFVHMzM1U0WFY5anZpaEdUVk9OR3kvME5Cd1QvU0g3eld4c1cvb2g3dEMrb1kxakF6SDJ1STVBby9HeG15VHZqUHRQeURqLzV3NmxyQjZQRkNaZXc0WEJ0QnEvY2JyYUtGcEE5MFhkUTIxTHhwTzNreFI0T1lnZkM0VXhlWUhPMjRNK0pVSXRMZDNhcVBzeWdKT3QyN2VHaGJJOWFMOVcxdjhUalhlYkZ4ZlBQZ3FEUzNUdW5XVTVtSE1UcFptbHVNVi9sc0pwSkt1N2ZXMXExZnpYZCtNSmpxRjZ4MUExYTFoYWlQenFzYVkvR0czYjk0MjFURUdMYW9lUDUyRS9ra2FsdldJRkZSY2x3WGJwZ3I3bXVBSzUzcVRWbm5ObmtTSVZPdHZmK3RiczA4Lys3UnZURm9GMjlNeDlNQktUUkJwOGJidzU5eTg4ODl5ZEphOEp0TDBOaFMyWVFhdHBhb2ZDME1hWFAzdzZ1aDQ2SXkwOWZKQkxCQnp6TWJxWmZRZi90Mi96M3ZRc2RjN094SG94bXl6WStnL0xNcDRLMkRkVEZXZHE5YnRXdGRZM1ZxWi9mU0xqUkE3RkU4dFJ5bHF0YzVWY2dtTGlHZlkvSTNEZUJEYkFKOElpNDloK0NpYXkzR0w3LzdlczVGOExPYzVWY01uMGZmM202dEZSeWpDOTNKdzVKU0JDaWFnR2tIbXNmdGpJdHFleUlzbWc0cDhoNitqTWMzVlpGK0pTZmtTYVZhTm9kckZxVmU2VVBkZzcvN2x0MmhLTkNvQTFqMUYvcGgxeG1rdWlOYjZlazRJbklNWDdaaUdJU25SV0Mra1NidjNhSUV5SWxRMG5waWlhNDFNNlg0VFFtZGxqZlBYOENmU3ZqdUVNazBrN1NRelFpSHh1SDdBdTd1bnYxZUY4UGsrRmtzdE1EWlY5MGZMVFNqcHZMbFp4d1NGeGRZa1dsakxNYXRsVExwajJsdlhUTU52eUkwZnczVW9aNkYyK1ZscVFkVjdmbmozdzlhKzQ1OFNYaHVTZlZ0TG9MV2RXMEsrMW56MDEyNFBvY2IzNUZoMFpvdHVFK3NCa0FSVHRZOEV5Q2poYWozZWxMdTFIUER1cHIxZ3RsWnJuQW13ZnlJUTB0eHdUQ01FSk9OTXhoekE5a0xhQUdEVzgyd3ZRV285aDJuVTd5YmU1Nk9GdERwZ01LSjZUV3hxUTBURG4vWm9BbFQ3eGhTY3pIRGdHNFpHeS8zVHBUUitOT2VJcjczeVdzd2E2S2d1Mk5tK051N3pNaCtkVFIvbVpYVEtZbEJDZHBZMlBHaWc3N3g4WGFWSjlMS1dOcW5zUmNUMjRzYVZ3T3R0VHZidFVWR2lqejkvMGZNU3ZablhWNi9sOHdzVmpuTFg3TlpxQjhoSlMzbWRhYnhmdDQ3ZEd2MS8vdURMaGltQ3FUdHhib2Zsd04rY3VVWGlKWm4yWEVkS2U3NTE5ZjdzVVluaTkrN2RIM1cyZW5HZHA3eDg5dm1uWTI3V2xoRGNHc0tLMlZ6amhPczd3MzMwNXovcFVJdVFYTFJ5UG5wYXVINWo4Mk5PT0diWjBLYjZrcU9mbkMzSXRQdVBDNSttQkJsdDRtWWJaN0U0YUJWVTBxSWN4VVdiY0J3V2pZdmRxbG1kVUNzTmhBUWI3VCtTRnV6cXFXRi9DeE82NjB5cTdFQ0YvcU5LYlo0OGVkcmxJK0UyUUtmRVc2VTRLQXg5bjcvckYrOWNuWDAzU2IrWjlMNmRzLzU2UDZ1clVYdytqcXZYTDJjNmFQN1g1SnJrWU9ZV0VJQlkrTkVsb2MwRlJCWVVDSXR3eGdQamdlSDc2Q0JZMzhXc3pETDBPTDAzZ1lNUEkxRXF0ZnNvRGg5TzFDRkpkWUpzeHlNWTZ1eWd0OGJPN3hZeU5ZYWlaOVZQS2hnMXY3TUE2NnNIdGJFSi9FVGl6azc0OTV3YUZBRzJuc012WmJFamIxcGdsKzBCckxwRkE4UHNnMEI3ZFRqMSt6MEJWaXNZVTlBc0ZtT2l3UkFSTHlhblhZa21UVVRRdUpxano5clVscVlMRkMzTDFGc3ZSZUhHamMySXZJTTFNeW0wblFGWXd6SGZ2T1hwR0tQMXc1Q1lsWjlFT2NoU0I0SElDWkpidFZ2VFBFS1A1bTBtNDM0TkhKRFNvaVFQYm94cnlXak9OQTRnUmF4V1cwZkhxUzNuWjcyWStURmZHa1ZmNmV0cDdtbFdnRituanZpOXRWWTd4LytUNWgyd2lkd1JtZ0JJVXFMbnN0djNkbDgydDFvZkpkMFZGTlB3bUdicVhORTZVSG9kbzRzQWIyYitTTUZ3eER2dFlmaEVXOGpSU1NTYUYyUkNwOVlOb3dJTkFwRkRtellwb0hQdUx4MVIyVDVxZk1PdjJITjdTTU1hL2NjU0VyVFRTVWtvOHY1Ti9wNDBGMUhPR0tiUEIxajVrVVdnRlc4UFAySTA0TjRUL1FYNjNSY2RtTXNZUzFvSjNrUy9pRmFKbThOUjlOS25vTkNXbkZ1SXJqUXZWTnYzVmVhYkkrTUZUd1RQUlBrQWxnREt4a1VWTC9rS1N3ZFp6aWVwUTYzK1o4WkdjRWxKTWg3OGdjZXRFWkFXeFBINnFPSHNYZXYvUExQUjJCd2lZNzdxRlpYemNlSnJQMFVML3Z4aDROMzZEb0hhOVJidTNMMzZNYkFTUG1iU1VaL2Y1N2R5K29VY0tJRGpQU040V2NiNjdUdjZVMTNwZE5uUGV1L3R1S0hGRVdra29SRUE4NDh6YnZUSmJpQlFlRVRDV2d3UkZRbDEwaEZ1NXZqankzalZaSmlkTnAvMGwyeEpUVFhScTRIcGt5SVlUeXNSVWlkMnAwemNpeVVJYnVVM3VaaXBzcGpHdFZnTzFzSFoyNVNVd3FlOXQ5N25scnNHUmhhbWx1c0RWQzBZODFmaUlPSmFDeUNVOGpBWDhldm8vZDFFellQYVBXbElDTkx5Si9BUVlnUXlBUVVkZ1VrWkIvWGFlZ1dmUUpYWk42Sk8zVzh1NWlWRitYbVVSWXcycjQxSGJ5Q3ZlYTlCenI3NzdlL01mdXMzLzhic2IvMlh2eno3dFYvOXNBMWJMSDNqNno3SDV6RSswaHB5d2c0OUpPSkl2alhlYnR2SXB2RVlDM1BPSENsaENHajhtQTlBY2E5KytDRUFrcHlsOFZyTTdDb2tzRm1hK3hobktyMzhvNTBLb05mekpRMHdEWFFkc3J1YVVMSTJJMWVIUGVsNmdZQ002eVk2UUkyLzRVUUxvQkhCSTluVHZsb2IxOWFmRzJpTktvbk1VMDcxNVlCMEl5bTdVMzdPMU40bWh1Z2FSK1Z3blhZTm1kVnFSdGNESGgwbGdKQWt6YlB1NGFnNEdwbXdPek5jWjRaWjQzUmRXZHFqUDlhUjA2MW5BZExsb1drZDg5M21laEQ5MXM1R1B5dW43cUFMVWNHbDBtVGs1KzIzRGpTVmtaN1FCV2pibzMxS3RJQk9wVW9BbmJFWnpZcFFuc0EvSU9sMURudGdOZmtNTVhZZmFxV0M5bjRsa1BxeGw1UUYzVHVsWkZBVWFJTlNXOXJTVVg4SzVHVHF5MWtpM0RuY0FkT0lJdmNoTkduZmgrK09palQySDZzbnBIS0Y4QXU3aGpJdENiQTBQejliVzlNcDdNNERkRWl0NCtsWGM5bW9DMzFiNVlJTS8zR2tYZXV4VkVjVFRRb084MTNPVlNQNCtMSHpSM1BnMzc0MzF1M3gweWV6SjA4elBSdW5wZ2lvVGpyRTgzS3hkclozV3YrbDhpUnIwSm5aK0M1OHdVL3dnRWFNSm93UHYwdWplcCtRTS84dkgrWDNiUjFITG1RdWtZWG04ZkVFSWpTZEZ4VVRQeHJNZmJNSWk4M0F4TzliSkZvSnNJTEs4aTR3aGlqQ1RuNHZ6K1ZOTUI5SHE1YUlnSFNCOWs0TWRud1greDl4WURLUkEySDdrUlFYbzZoNVVuUU55U0VwNXlCN2xYTnlFRk1UVzA0Q2piNVhaK1Zrdlg0eXUxYWs2Rm8xWlh4Vnl3SFhNVk1xYVR4eXE1Z3hDQzdpVTdmRmpLT3huSnRNbmpPQk1jMTVST1k4Sk0yOE5iYXh1UkVDZTV6NWd6aW1iT3VpYkJHRG45QXJKa3E2RFRBS0xHT2FPSEw0VHJSdHZ0QUd6SFYvM1E0a3Q5SW5SQjNUbGZwN1ltd2dzdHdHcmRjS29zeVFOci9venAxQ3pTaytuMzd5cUUxRjNQNWpHSTliUmdkOXY1Lys3WlhwQVp3OEJ1SDIrdm5mbUFKUURBYnAvVUg0M1h1RTJkc01lOVQvamFKL3VzUmtEbUVtSlN3THMrdlZSbXlXS1g1SnNLSy9GeklWbVpmRGxPNjZSOUVBMDgwVjdLTklYTXNYbzFVaEVYQVFPcVBkZEV3MGl0MGJOeEErSEtrcENZM0M5azdtcHAzeDQ1eWtZUjRleUVSSHpQbmRBcUMxVE1RY0JlTnp6QWJsTXllWjBiUXpwdCtvOWc4OGFIRGF5ZERNK0NHTm54WjVNWXRoSStlNmpPblJGU0svM1dtQWJmOXAreHJYOFp1ZVd4Tk1uY2h5ckxlTWJXYWhVNUVJY3dEQnpFWVB0Q2krU1luVDFtNDhiRklQekVaUVdpZWdaTjFIRjljbXo2ODQxcWIzV3A2dUYyaGJXNkRWKy95TUJEOS9tTW9TL01YWE50d0lFL1dNZlJiRUlaVDk5RUx2QUgrZ3h4UzFUdzByZmtMUHJCd2dRbG1nclhNSnFQa1V4UWRTRWpZbGwzcE5NcWZhNERlbEd1eU5BRkltZWhybms2S1BYMzFkTC9obzg4blRqcFpQT3h0KzJLNzE2YWVmcElWVkxDM3kxVGd1MVU1RzFGS2ZPUmdnT1BBaWZNSGpxbXNrdFFJcWFSZ2JXU2dhSEd5MGp0c3hnWjU4ZkdzT3ZmamlVVGNyUUdBZHVXVVdVdmsvUnN3bXV0R2tPRUF0bG16eDZRVGRhYUxxNmw2bm1aZ2c0TEVBSW9MK2hwckF3UUlyaEh3RzBNYkNkSHJHbFNJU0xZVFBPSnBhV3hvVDB1Uk9mU0xwNDI5TUNEU1libkpPU0FJYnJEY1c3ZWkwMStYZGxBMlg0LzFnOXExYlYyZWJtU2g1SHdyMzVvZGpSa1VZbkpRMjR6Qm1zbU1JZ0RPV2VreHJRcFIrYzhockVFZ2JJaUdOQXlFSnkxc2NHZ1NpeEd4TVAyQW5LWEZJdE9aNmtXUTIxdWE1a1dUZWRZQmszNDNuMnFUR215WWxnZ1hBcEVmUXZvNVRsOVdValFUSUdKL3A2UDVuWGU4Z00vSGtzQnl5NDFlajNPRjc5NzhiMkhiTStLZlBpN0lGQUMwUngvNmc4SDVoZ3JGdS9ldHhybEZOdnFYcHRhRUpqdmt3SjMzb0cybmY5MGxYUytUSUxVUTlRdmJOWlRDWHYzc09XRGN2cmVSYm9HVk4zVGxQSzRrYUxZUmpRQ2NlQ2VGUCtYbjVmcm9KZ0FKZ1o1bGkxc3o1Y3V2OW9DblhIcjNNdW44M0dPdFBFTW1yNjNJRGZFN1RvdFNyS1l6ZTdMN3pYZWQxclhjdlJwZTBLdWFqZlZDY3ZmY3VQMDdyTzhDZ1BWdExVQ25ZcHEyTXlHQnVBODdCYzVBU2JIajY2UE9FUlltcGdkZmJEcng5OTdiczY1Z2JjT0Y3SlY1OGJybmh4dkx5SjQ3RE5Wb3ZHdFYwVURETmZuSitzeDRHYlhVOUxvUldjOUNQdFIvemJYMEl6SE9Uc0owYkdyMTE4djdrZEhkcWVEbHQvS2hkZDBwa2JuTUNSQnBWYURFRUNWT09wamNFVE5lZjh2ZjQyaWJSQmJBSTB2QnQ4QUJ6Rms4U1FqUkhaaS9MQlpEZ3o1Y3BIMDhMTXNnTGU1R1Z3NmNvNE9OY1NXa3RpMmxaNXNjOGZ0blpnSThEcVhlWmlVN2tmbG9hVXR3MWdWc0tpV1JQN1dWMGNIbVRSdnE2NkIrd1loWUNQZnhNMDZKWnVmZEdXcVNrVUczUHVaQjAxYUNjMEpvNTYybjhUeDUzVU1WQisxN0Fod3ZEWnhZMnQxYy9acDVCZWNRT0lIUSt2Snc5U29MSTUxQTdhTE1VSGRPd3JteGZ6UmJkR1V6Q3RsZElPcVJPbjVVeE82UjJtejhXSlZRVjl1UW5ZMHBTQkNBdHFlRjRJZURIN2tWMGwwTlozMjBnNDMzazlyTDBoMWVab3RGemhOZnAwWmxMdjNEMzJ1ekRFdDZXQWh4SmprSEVBRS9sSkJ5VGlpL25rcUtJWXhCT2dLeXhQclZ5cjhWQUhCek56QU1aOVNTVWJQUW9wSEZra2daQUFOU0QzMjcwKzI3Z2lNSFphcExsQU5WcElCalhsV3ZFVDhaQkdzRm5QZ011ekx0SW0yZ1M4cC9tQXNodU5QNGVwbE5BUy9XVlFFb3FxVkFYMGVTSE9XMThHNjNsdlh2M0dzZFJUczRYRVVSZ0VrRndYZ1BWdi83NHE0Qmw1YWFIWjdTeDRYKzB0bDFEdHdwcXU4dU15T053Nm5mdjN2Y2U0WVhBRndPSUsyV0ZYODFNeTUzZmRVaDYvaTcrcWw1cERXZ1hVN1JIUHRJVUhhUjFhR3RMT3hDcUgxalpPTGdZWGxmMW9INVA2WVU4SjNRajRWSHpSQWR6QW00Z2RsU0krL0NnTE93RWpqWThmSm44SEw3cjlKVDF6QmNDamRaRHEyTkttU3NmYTRzWS9lUlFUeE1qdVE4NnZPUWdyZTJrS1BKZURCT09OcWQ4UWRFRDdyK1lYMloxM2FsR1dyaGtkbDVLMnk4Z0lReWZ0RTF6VDRBbENBRytkczAwN1hIcVRzTEhRKzl4Mmd2QXdweG9Eb2oxcXoxdVZLM1g2RURSL25lSkhwTm1SdmdOMzJwQVpmQjhnclFyRWNlMTVzZi9neDhGZzRBZVVOZ1BTUWxRTkNsb2hJL1E3OUQ2dThpNXhxeXhnSFgzdXFvSzJoN0JCT1RRT0lFRm9QaXN0dUpOSU9aenF3a1hPWEtzSzNPbXFVbHZlWmR6ZnExT29Nc0J1K2ZHSWpqR2VrSkhCSUR2dU83Yk5ETWxjQUFLWU9vSVFXQnBySWpINVdMdTFCdGVZdm05a2t1QnRCSWZwVlF1TnBLTlMzY0NyaS9mOGlzSHlPMlYvVjI0c3JYNk1aUW5EVjNVS2dPYTk2bDdGbHdEUFdGZml3YTgyTkZLQUhSbG9CelpkTXdPM0NSODBtQWdySlQ3bHkrU2hpMFVyWXFtOHZSSmtjQUFhcTFvb0p3bktRdzBNODQreEd3RC9NM3U5dHgzcnU1a1kzZE5QbzYxUU9oM2Z2azdzeC9ldXoxYlNySzJFaU1hTndnZ1FsaUkrVW1UNWU2UnQybE1FSFB6VVRGWE1iVTBDUnNwcEF1a0VUaE5pcW9xTUlEWVNBYnpZUzRpSGdUS1lYL1M1ZzJ6cmd2d1NWbGt3Q1VheFp6aDAzTzZEM09RMW9TcG1JTE1ScWFwd3kyR3FUYnlqZmd6a3RKSk1ZbXRDcUU1NFdrdDNXeTJBQlNid1hlKzkwdUYxZWRtZi9hVEwvb2RrSS9Wc2RabTNRYVlqRTgydC8vNDgzTi9lMDhUdlBFeERPcGJmWGtjc3RsZkRhdTUrbW1kV285em41eTVncHFMOVoyNkZyQXY1Yy9pek9aNHA3V3FDN1d1d01aZWNaQlMyYlFaVnVyRmI2SWFnbllnRjhxUlVzRGNtcU9IemZwcUdTKy9tNDRjTkN3bXArVGVMaElSWTdhekhMRmJyYU5nUk4wR25wZVUySDIza3VLSW1ObkJ0T0xRRjJGVDcwaHpFL1Vhd1lXdUtaVkdPc2Z0MjNmYlA1cDZUZWVpUDZWY3c2L1oycTdIaVBML0xPclg5U0UvS3hmdTR0YjFoSFRSc3l3RGpTVzkxNVlPVFFFSTBSeFlEUjVUSkIxQVpkcm5CMjdralluSnJ6VnhGZ3R0ckRVYngrQzFaZnhUanJJYVNvTDk2QnNxQVVUVnBDYm9SeWU5d3h3Rm1MU1dBQUJBQUVsRVFWVDVtMndlSUFBUU5PRUJXSTJCKzJYUVUrOFROS01wWU04NTVaWEcrZUlRcFAxdFBKejc5cGxHeFdYanV3QlAwQUd2Yy9qNzIzVmhBak9abVJoNVpGRnBhWndWaEw0RGFsaEFtMlNKZFpseFhmNHVxUjQrdDFHeXNXc1NaZ0J5TWt1ckNPQXpicSsrOXd2ZkM1ekxxY3NFbFBrdTZ2bzBINWlUcGwrV2o3bTIxbUdxWGJzMjhJMHJualQvK0dqaHV4L2QrcGd0U1d2UWVVSExZS3FxVkFRbnY3NW9VNmh2QU1wR0lNUzlvZ1g2U28zRjZsV2xHczJ2YTBTQU1kNWYvUGxuU2VjYzhTOGkwSEtMM3FkaHZYaitPbVlYYXE3dGNMMndkenRGK00ycnN1QkRaZjJVYmw2L0V6RGxsN3Jla1VEUjNYSkh6YThGSkhNeHprbGg2SGYxZVA3RmU1dXp2L3ZySDZYR3ZHNENXcGtBamZLMGFBdmQvMEliZlpUcWVCcmhyeUhVaUptS3lVY25ONFhtUkdJQUpodXFWa3FpbWsxa1pnd1RzTVgxbk1SZlMrb3NSdERPS1R4TFJUMk5tVTVvbzIyRStrVktIR2N5ZjR5L3B5UEhrcDZod09qWFBUNVhxVTVFcDBXMEhhVFIyV2licmtSbGhJQ0x0QjdrWEc2NjNSZWRsYVNaYVRPYnk0UnNIZTdVZDU4LzY5R2pCSUJFUWNDVGZ3ZUQ1SWJzT3JUY3JwcUdCd0M2L0NBeTc2ZG1STFpBT3pCcUxkUmtjbUlPTGExNUlreW13ekFCK3p6TlNlQ0FUMm0xR2pJaDhlczdxZXpka3I5cHJZNE1yaitPdzRwZU1KODFzQ2JBem5yVG12U0RPbzBlVmlQY0FmaXRuOTdmVjY0a3phTzNrV0lRQ0lvb21qZG5PbDhlRS9Da05kb08wRnd6b2l6YnVRVEk5Z040amZiU2FkYjJWaDdXT0dBekRXYTdYTHkxZ2dQOFliUVpVY3VOWVlxMmp6R0dpQ0pMWWlQNkU5NS9XUmIyMEhDNnZvanhvT25WQ3ZXamVmM284NkNtV2ZEaFpvYm1XRlp4MFF3RGpEU2JtRjh5SkljNjNobHBRS0dadGJma0JLNG5CQzdtQkViTU5nbWN1TnRuS0FIOFJyUWMwNlRSbTV0a1Z6NDRrVjNkTWk0Vk5HQ2lNVnNGQnZZQ2ZiNDdJQWVrdEc0bWdHaXlJb1ZoVVFtczFrQlVuQllmZUpwN1FJSk9XQ0Y4Y3JRWHlib0VNMldCQnI0ZllCMzJQY3FMRmt1dmM4SFFPTkVMdm5FTmdBWm96QVZkc2J3QUpFMEtYU00vR2VsY1NEUkV1VjBDTWljc29UWlVUN1NWTkVrNWVoS1phWUxLQWgvRzN6Lzk1TlBaeXlLUWN3c2I1WGc5bWYzUnYvdlI3TXJPamRhcmRZMU81QUF1YkY1Wit0Z0FTUzdxS2JVTk9Pa2QvVFoxRHpPMytpMkdEVHpLOS9SaVRNZ202MFZrb2lNYzJ1UXRBc0ozYkxWUXJBTWRoSW1IdHZWOHl0bTRzcldkM3l1SFhsb1l5WXlZRlR4alBOSEkxMitmTmJtWXZQZE9rM3J2dTlhYmlyQnZaQXIrNGUvL3h1eDZkTFAzK3RuUWRHUStINFhDZ0dWa21kTnlDbjB2eE95ck5LZzJDeE54d0k3RXpWQ05aSlNLWUlFZE40VDNCMHRIRENTVTNDMmEwMG4zNXAvaFVKOXJUdnVaRWdCUzh6R2FoMUlTaExrWFVKSHdYdXZyZzBDbkVIL0VqRGhwakYwYnczWFR4akhsUE1rTG84bGlvaWc5amMzYWRhQkgxNVBOalVBUW5mRUQ5UDNheXY3NHo3N0lwbTgvWXRiVFhsZU80YnNlQ0xnaERJYVkvaHBzMHh4dDltUkNrTERBYVh5MHNTRytBWHBkUy9JbEJzR0VsMGEwT0hESldiMVpTc05HVHUvMXdzeHlyUkxHZzVGSk84QWdNcWNRMmprQUdJUjJzRkZrYUlxbVRxYWorNTFyOGRhYitjWlVTZmx1endQcTlvTXBITXNOUHlydFNIUUowUFIwWkQwYjExYmRibCs5ZkRLYzVITDA1T3VjQU9CK2xKWmRyS0lDRU5LY3JLOTZSOW90ellZdzlqcVRTYzJjc2VvK0FPVXZaQXF1MVNxSDhGQWt2SmFadVpKbThMSm8xa0tIVHM3M2Mxby8rOWVaT25iZkd0cWY0Unh2TDVoLytHRWpzOUorQ2VIVGFPd05NNHZXdFVIcjcvN2Uxenl2NVE0dzdUbm5PSzNIV3ZIYnBvSDIvbGFhQjNPYnhZQy9wa3FBMWltbUpWZ1ZrZ01zUU1WYzVDT3kvZWU5c2x4NzJ0dEpzTEZjK0dacFRIUTZ2SXhtUmtlT25nQWxmSUZHMEF2K053ZUF3OUtZcmlmNk56V3BESnBHdnA0VDJZSFd0U3loL1U1WDRtZWJ3RzA2dEdZdlllN2dpcHU1Y0FRV0JMVk0za2s5aTlINWkvaGJ4OVduNGNxck1PRmlUVU9YbGk3V3ovM0I3SXVIcjJaMzcyOUh3N2x3d29RekI5QjhlTzlLZ0pWak1RYzYvMDQ4T2haME1odW1GZzhTd3JwTEpzK1Uzc0FwSnRrVXNJMDBmYWdlSWZvTVFpUzVBQjI3V2IzVmNMUzF5UU9WbVFoRklDd2crMXpFN3V2SHovcGNIVTZyenBacU1OZDRqZ09NNDJ6bDlhVEYxWTM1MmQvNnpSL012dk5oZ3crc0R0UFl0SnVZU3dXZFQxVmM0VU5yTXc0ekI1N24vRjVyc3gwZ01STHhrbHdqNFJKUjlMTWE4WWdrT2pqeU5KOU04aWJDc3RrUzdEalNKWXJ1RGkxZ3FZWGNiWXo4TVh0dERDMkc3d0p3QVNWaGZlRjBqUVpIaENzcDR2VjJmd0FmWDVhU0Y2L3haUUd2K2Q3ekhZekVGOE0wazgyVFRHdE9iUG05ekxCOE1vV09TVGNDUVNMcjVwV09FLy9xNmZCbnFXczdDYXlBWk5zMTFweTJlNjd4ZmdOZk5tUXdnL2tEMHdHeE1Td21vQVdON3A5OXo0a3NVWHhsNUkzYmVxdjlxbDNMYXZsUWx6TUJGMG9hVmJFLzMyOGd3MjgwTkRsNDJYeG9rMU9PVzlkcGYvV3U3MWVneGQvVjN3QzI2OVBxTUpIZ2h1amk2NXplVEtZUkxXcXNHNWtkMGk2QXlXNE9kZmVoUlFHci9jckNSc2VRaEtzZWFiUTZaaGJUbE1tWEN0eDFKWXhLRmswNE5CZGxYZnZ0ODFvYU51SEZiT1ZyR2lBWERkQjJ0S3krVUprSXZ3MUhMOS9kY0xKSFh5OXlTRzl1WG9zaEx5VmdkOU00RkRnWFJlNzZ4TUhWYW0zTmo1Wml3dVpHZ3daZ3pOSkJIOTFuMEl0N2RYOUNnbHRrK00rWUJkWWtHZ0drVEc2YWxjam5uZHMzQjI5SkY5b3R2V0FJOVdqOHFIVmtLZkF2Y1hMN29lSFlYVnEwNXdDbm9mUmUrOXgzem1tRDZTb0IyOTgwSUVCSkE2UjUwY0lVbjhzeFEzY0F5L1dVTS9GZGJtOXY5ZDI2bDBhN3lxa3VSaDk2NFBFdFhpOHZFcSs4S3E4SzczdjRycm54NlZFbUpLcktzZ2ZXd1BMNTg1ZXp6ejc3b3VqaTUzMXVLcGpYWE5HWkRjKzBXQzZCMkZGbFYrOGsvUGhPbzVrR2drdkszRTNpaUlxeEova1hPTm5sQVZIcE9NU2grYzVXQ05va2QxdDBacUVNWHphOHBNbnR0Q2ErSVJNbDRhRDhibUFtMmhHL2p3MjFXRys3THRBRGdCejhRdlp2MzFnNHBSUnZabGVyY1NxQTAzMXFLUkxmWDg2MzhmYng1N01mZkhSNzlndmZ1aFk0bFcrVCtjUXB6ZnhjMU13K3hwNlhLTW9VREFSZVZDNTBqU012QWpUUkJGQS9nVVlieVhTVDM2RzJiVEY3VGhTRWxLYXBISkVNODlJUEFxVk1OU0NpZHpqTmlzTjhKWUsvRUFFc1FlYW9RYm9DQnVUM3E4Rk1ZQm5qUmlUT3F1TmtyMjlQV2xwTWhCaTYzM0hYNTdBWHN0VlZ0WThPeGY2MGpXNDNJclRwcDZCOG9DbU5vdHJEN0RCcStuRVNSdm5SNy8zdDc4Mys5Q2NQWjAvZWRLMGt2aXo4Q1l3YlV0ZERwSjRORXlGNlFaak5ja2hsenZYUjlLM1BETTJxOFJsbkZEMkEyUE9WaU94Ni9xcWRVa1l1MWd6UlhGZHpzcC9rc003T2JxOUZjeVJhQnZveEpha3VtcVNHRUZIS2dkSTZsL2xDNWFjaE1XRm9ra3h5aVpla0wvQ1kvSU5hbDBnbXpYU3Mrd0luN05lUEg1YW1VR1E1aGpsdXIxOVYzeWJSOVhycE14NnNBTUNBc1JXWWUzN2NQdk9WU3M1VnFqUDVjL0xGQkZiTVcweTNIcEM5RDkzVkFKN05jc1RUeWdLaS9ZUG5BMGhHNy9mR0ozSzl1bEwxUnNDMEFBUmJvdmZka3daNnRiVjVWS1FNTHpycENCaThiUzh3RW5PWEVBZk1XNTJNcFBUclZkbm9DcDRCNWFSVlRuNVJlWGptekRTZUw5cEpXNmVSS2lBWGpCQlJuanBNVEFJdndoNUNqNVk0YWNYZHYrOGVsSG5PUHlUd05jaXltVm1Qb2QyTjFVSVQwMnUwTVBSdzdzdWxVQXd6T1Y1YUJhNVJJNTcwY0czV0JzM25MSUZ3dWZLc1c3ZVZ6T1c4ZnhWdDh6VUNwbWhwcWFxUytVejcxKytpa1I1OURVNUZBMm15bVpwS3NseFBGTmErdjNyYkNUengzYXNYVHhLK0Q1cFBJRHVYbjYvMW02dTdJb1BqeGZNRVEzV0U4L09kYXJWeHA4OGttc1AyOGRuTFY4NCsxZ1ZCM1E1VTE4NUNuaFVpM05rcFdwS2FES0FnTTQyb2VaYjlmTE5CVUgwN1RpbXYvNzBQNzJYQ3BkSTNZWkZBMmFxME5kcUJod1oycEJEMUV0Q1J2TkFkWUZsY0N3N01Ta3JJTkMxQ2toUmM2ak9uRldQZjJseWEvZjV2LytMczZzVW0wSmxxOHpIK2NWcklRc3dpM2o5WDlmeHEvckw1R05LUlM1OCtmREw3NEtQN1Zlclh2YkpyYUwwc0FiQ3JEYVpwNTRlS3phbXNUZkdGRm1VaERlWTRQOFg4RVgvVlpJbzZIUEk0czFRWHh0V1lZWlZVYlpOb2RtMzliQzF6ZHpucHRxeVRIUjlheEFTZzUyaDgrVWk2NlRqaVBuSU1nVlA5Ry9kcXIrdVZkSndHQjhDWXZHVTM5SDJNTGlPNzBIaUZ4Nk5QVnRLZTFpYnZxUThNeHJ0MjdkYnNrMCsvbkgzZU1lSzBKR1l1eHl5R21VQXFoK3o0MDkvbm10Y0VYSWlHSm9TQk9YYUhKdGhtNWk2SktGYnFXcENEdlh5Mk96YzcvaW13V3Fzd2VLc3VvOXVWMWx5czNlN1dsU1JwSi9lK0tzcUgyQjAvVGl0d1RSb05yYWdCamYwajZIUUk0RHVrdVJKQUJDS1RhV2pmMFlYa1JNSXRHaDRVcnU2UDFzR0ZnRHBwVkh5SjBtejR6cnhQTTZNUmNKNFBoM2EwWlA2K04zcGZ0ZGUwTVBFa2pFbERZNjZLUWptdjhGMitzSXVkVGFDMlVkZUNuZndqSE1YTVcvNjlhOWR2QjFoQzkyOEdQYi9ObjNMbFNtMVdvaS9sS2ZzMHNPaS9hUTR0U1NEQldRTHE0V2hQMXR5aENyUSttc2d3cjBlK2taeXNCRU1BWjAzNldEL1JVZmRrZ3VFYmJndStxWkF0d0c3Y0FaNjlXc3pYeWVkRU9JaFF2cy8xNGhHbE5ZNEVTa0FnZ2tZb2ptejNMczY4dEU3dTU5cCtBQmNYak5ja2czUHhNQUVGbTY1a2FvOTE3WDU0aG51STJRbGtWYTc4OEJjL0duUDd1bDUyUU12RHVBbFV2ZG1adVZ1Yk8wVnJOd2ROc0xRQU41RjhOWnE1ZisrREVrZDEwMmhOb2tPbzVneUVyeDlYeGhmTkI1SHRBNURPZWtuYllxSS83b1RveDErL21mM2UzL212dzRQdDdxR2piTnEyVTJvVVJrcTZveFpHR1VudGpxUys2aHl4SEtwVnJtOXVkamhGRTZGQlRRbGhIYmJZUUVrKzRQYnd5NGRGdDZZK1VHeHlwVFVtUWIybS90SkVIR0c5dTA4Nko3a2pQSkZHMWZsUUgvcVRlQSsvcUkxclRMd1NZbCs2Y0RLN2ZuRnU5cXUvOUlNMHJaaHNQN0NxRGsvSnlPZ29rREdrSFhKVy9leEM1UzF6Z2M3TFI4OW1lMFVWY3Q4MmNYNkIvRURqUDJhWmpZdXhXc2lqQUtSdmQreDE0NGtZMzZZcExuYlUwMzRnL2J3anRTV3diUVhXcEtqMnZQUE5nKytKNlVIenEyTnduK2ZURTQ0Mmp2U3hKUDc3bUl4UFRqYTRQa29MRWNYdWZqNC9KaGZ6cjdZN0VHb3h5ZWpvb3BVaVZXaVVVeDRCTG5Pa3B4WWZseSswbWdBQlZKT3ZMRUk2NlFDTTl1cWYvTUZ2elA3c1IvOTg5dmg1NDBwNjdaSWdQYWoxSjJtSEE3aEk3RUNwbHdZWVlMQVJyZXhQTFV4V2s0cnh5akFwQmJWVzY4NjYwUXVsWEtVUlJzQkozTldjL2NGT2E1VnZKck5RdlNNUUllRVZ3VXYrQXlqKzFwR0NEeTU0SFMxMEQyS3N1ZllRald6a0MwSURRek1Da0tKTExRT3pob1JYVVFHemx2cGJYL2RYSGFxSjJBVnkwQVd3a2ZBNUdnYjJPVkw2REUxMUxVS1djTnhIcysydk0vTTByanZKUlNBcGVVUU9zd0NNajFtMzNsaGFpRW1iaUZtZlBQMjZ2d1ZiYVB5dFpkcWNKRk1nK3lwYTJtd2RybFZhdEJmdGhaS05OMjJxRFdQK0hoOHYyOUxCNlBaUkRoV2YwekRkdWo4ZzRlNEFWTHF4NGdWSFYxa2pjOEIzdEU5QWMwQnphczhFRXJUWVRnNk1OQjJnb3U1U2xOVWVqcUJRYTJ2TnUvRUFQd0NFNTJpK3ZqZk9tK3g2Z0E1UURmOVdhMFg3UTZjdnF4bjBNSVpPSlE2b0M0b042MGdlV0pwN2xnZTNqajNXZlpUdnlIZG9udHFhNjBZeGpoWHJmaU5Eb0lncmM5aDlISFRLdjhmZlplN1RzVjhzcHNQWm4vM3BUMlpibVlVNy9Yenh4Y1BHay84eExjejZPRkY4akNlS2s3L0ZvcFBpSWRmdDBzV2RzZDdySGJKS1FDemN2TFgrTWJQdlp2VjZObG5aaXRJQVFNSVA0Ri9QTlFKalVuend3WWNONW5RY0VqRnBTVFl3eVJaZ2VTaHNObGdaeDJ4ejJjL1FtRGxBaWpucEdXakpYVEhKNGJ6dGN4Ylg2Y3o5TXp0TWd6cE40L2lkMy94Zzl1dS9lSHUyTmw5U2FFaDBHdk1zOUpuRG5PS25nY3VGK2pHdG5rVnNLU0VjZnA5KytYVDJldmRzOXYxZi8rNXNlYnNnUXVwMWF6bmFHMFAxNGVST3N6bEwzYnk0MnBsc2U0SG9zL3dEanpORmN2STkrSXZQWnBjekI2NXYzNnhsaXZhc1JVQkFDWk9HQkd2QmNpSTBoc1liWUowbGRXbDRUTk81TnV1c01TdzRTYnJtY0VzUjgzRjIrR0dSMElNMjRlUnRueTJmUlFyMVlWSjVyakhRckM1VTRuQWFpRkNOUkMvanA1Nm1OU1NKK015R3lkbzhXcXFJZXo5QmNpdS8ydDdzMDU4K2JuNnhWb3lHc0tPaWlCdXJBYTErZXE4bEhiOXRKZk11aGEyZk5NQU8waENFdkpSdjhOcFdKdjJWbGRtM1B0Z3FFYmRFM3pwTWZuQ25JdC9qelAxS25xcUFHdldaMm4xMHNVeHJrcDEvc2ozdEoyZ00wQ2F6aHRhQVhvYXpPRWFTMjROSkJGZ3drNU9YbUk1NjMzdWRKa0RUMnJsNkkxcHBmaEU2b0xweVpXY3dCUVlsa1NYNllsTE9YVzRKNitOQitPaVJQODdCSzFqREVpQmM1d0tNQ3dFR0lXcHRuTC9IUjhvY3ZMS3pIZERrSFA3R2tjMVV1VnplbGU4U2hvQjVMVTFRcSszMTliUzlOUEJQUDN2WXVYZ0ZsNml2Z0tBeGNYdTBJTzNQNU13ZjZTOHgzL0FEUjJ2Y0hoaWExazBqVkM0MFdLcUpFb2cwWEc0VS9PRzN2bEEwSHBFelBqcjlvdzZpTFVlbVRYM3cwOEtiaXhZenJKWFIwV05vSjlJYytDV1pYcmtTYUhkOURnM2dLUTlyQitBSHVQWGJtbnJPQXNLYmZGZWpmVXdhTHd0SmhOcGU2dHdpellTYlF4TDVtSDVBUmJzbkdPMnJ4SEgzRjAxOWxxSkNZSGpRNkJ5bVRITjdGNjdnZFpyMzR6N3oxWmRmajZnc2dTSUlKaFdLK0hSTlFBbUhEbG96ZFBaMy9xdC8zRHBLdVhJV1FuUTIycjdrdHdJMFZFVzFkdkl2RGcrckpXeVFGb0thYmRJV2hML3JNR1lkSVdFTTJJTlRQYm9kaTg4WmVMbFFMR0lHWXFNeVBqVlN2NkxMZFZtSSs5dWNDazBMbHdNb3VUZXlyZC9WalRJbEpWT3d2d09Hdi9FcjEyZS8vcXZmanFsQzM4ekxCR2lUeTluSWp4VlJ1VjhLYndSUmlEWm42T3ZHL2phdFl6M1RaUzJKNXp5MXN5ck9tYUZVNmtsTlR0TTVhdkw4VzZVN25iNnFoVTNtMWNOUFA1czkvN3FDNnhib3cweWd6YVh5ZTFxOE9Dak5vQ0hUYmh1clJGSCtwMjdaZVBKekpmMDhkK1FYUnVVSHNnRTBPSDZ6ZzZSUyt6N01TS2J1aGNNTHBYaEltZzJBWW1aQU5RZHQrN3RwRDFOeHJyWFNEK3U0TmpQbDVlZEhpWWpiTUNIZHF0eGk3SmV6Zi9xUGZudjI5Y09YczMveHJ4N2lwNGh2TW9ldENHQW1LRWpKUWFUOUJycE0xdE1XK0dLbFRPc2RJT0VjeDYxS203YnlWMjJtUlFPbnZFRDVhZEtxMTQvcmhGRzByTWdiSmhiMnBpa3h2NVlpYmhxajZLRDhJcjIvM2xSVXZCYkRleTMyR1F4eGdqWWFoL1hSQUZDTm5iNVZEZ09semVoSjVUMWhiVkZrOUxlVjJTQXdZWDJZRHc1RTRGeS9lUG5Ha0xKTDBlVlp0SURBUmJVNGpnR1RuS0w0ZXZSZlVnTjRYSGtQQWovcHRQSng3bDFKME1mSGUwV2luc3lldmFuV3JYVlg0NGh4OWM3aTUrT3pZY0lkdDRUclJSdTVRTVNZM3F1c0NPeXVacWFjdk15VWowNEJoOFozd3ZlT245TmF4VzlBeUtjSktBQUNVRDZOL29Dc0hMd1ZQQkVmYlFTOEk4K3d6MndWc0JIazJTTUVXMFBhaTc1YlQ0cWFBUUZhaGZZeXRPa1R3alk2Yy8zSXEzV2krY2NEcmFmN29YRVArMDZwQU1MVDN3REVNMVlHSUd0Y3JaOEg4QWNtVEdnNVc5S1pWQlN3S0I1OTlTZzhXSnhkTDlGek5TRFJxV1d2ZEtRYjFRQnpCN3hQTU8vWDBZR3Y5N3gzRlEwU2JpalNwajB4ZFNYcnV2K2pyNzRlKzYzWG04WUl5bk5HT2tRME9pTHQwYWNqdlhRbU5rN3VJcWJnaFV4N1d0aHFGUzM1U1pkQzFicDNsdFZyMHBKQUxmRGJVaFlnSjBKZHlxK3lzZEV4NVhVVTFLU1A4d3RnalFTeEpBUXBTOUtZOUhudG5rVmpvemVXSWQyY2pPRVVtdGNSNGZNWHo0WUpBMGlTRFUybVJXUmF0WUN2WHV6UHZuUHYwdXdQL3U3Zm10MzdvTHlxMXo4TlNBQUNPMzNTNWdaQk5DRytvLzNBNmpESDU0dlhtUzlwN01MdzdPRlRmcE9JOUxBRkdKbkthVWJ5cGc1Mjh6V2xDaXR3ZmZCSFg4NmUvZXhwblVzRGxqU2lBaDZ6RncrZXp0NjEySXZsVHh3dUpIRkRLMGRlbmJSaDg0Rlg5YmpOc2ZrRHFVeXdreFp5TGlKVVU4VkptV3JZT0taMGpmazBLS2NQdmMzUm1FdW4wdXlFd1A2enN1NDdSaW5Hb3Y1UGpCM3h0S0Y4WnJTcTB3aEc3c3JRYXJvSE5CUmxYQTdjOWl2ZHViNTFZL2FQL3ZDM1ozLzI2SCtkL2Vqemx3RlJFK3Q5cHZaaGFuWmtPS1JWdXo4Mlh0cUE2Q2NsNlVybExodXJTYi9TUks3dEFCZ3BBRytHQS9qR1RtZjVwWXA3YjZQSUdXM2pLS2FiTzYxSXVMMVRZdFhzTXEwYWUzY1JFWXRrWXNhY3BqR050ak1qUXRVNlNjVWdMVWR4Y0ZJWG5URi9SR28xUGx3cXNIRmEzdFFVT2N3bjF2bDArcVE1VFJ5eFhnNlVBQnQvRUpvRWVMUk9KZ3pHWkY1aG1vMFlEL0JzUnNQOGxkbzJENjByZ2JDZTczUU1OREJhRG5DdTVnT1VEc2ZrMkFpVTMrU2pPa2l6b2ZXOXFTSGcxbGJWR1Bsa0tmbzM2bmYrSC83azB4cGFGclc5ZERYeVNBam4zendNNk5nZGN5M202RXpSdFNjNnA4RUVlbzJGUC9kdFd2U1ZFbHdkZnpWZmdUWWVNUmFhaTZnbEh4eG1sdXJBS2M4UEZVRU1ocFozNVhNQ1ZEVEJsYXlCczBCUmhQSjBKS2NCSFJmRE1aRmM5TWVVc0VhRUtoQndKK3ZuQjFod24rRFpFU1h0ODB3MzNWSFV0dktOMGU2WmhFT3pUR25acUFlY2RCREM4cE5QdmhnQWQ1UWx3VFcwbHlXaFZ0U2h1VkhkME9pMEZBS2dCTkxyeW5ndTU4OXk0NDJZNnZSWUlUUy9sUTZ4S1NkWlI4WnJYREJqQ056d2crQVpmdWZNYS9saS9PakhXU0FFeEg3WGZsTW0vQ0sxVCs2UmNMSWJrajRXSE5Peml6bUFvVHk3blEzTEtRYnRyTkdGQ25ZMXFkOVBvNkRlUlpacForcVAwc1FpcVBZdTlWS05ZcjZJMWxaaW9JcDhURWtkbFJOaUlHQkxuZGRwbXR1Tm5RdXpmL2FQZjN2MjBYZXV0WkdmTjU0a1dZdksxeVBOWWFGSWdzNk94d0hWU1NlRUhFWkVGdjhROFc1VlBIeXZRelc3Wit2VG5wSHdnV25YWnc2SzVLMHYxNld5Ny96a2ovOWk5dXFuYjJjcmgwWEYwZ0NPOHQwY3Bwci8rSTlxKzN6eWs5bjNmdW5Ea0wxTlgwano2L3pBM0dkcENDSkhYVHNOamMvc3FFMUs1WXRaODRVMUY0UkNjaUtnUTVHckNJcFA3dDFURVJSQTMyYzNTTm82Q0hURUZQTnFqN2JZQmdIZmt3aGU5R3dRb3E2b1F3dUk0TkJqNWkraElLbnc1WXRQWnovOGhUdXpmL0lQZm1QMjhILyszNmJjcklDQVQyQ2gvY0xRQzB0OUtYQ1IyNk0yYjlGZXRRODdtL21EY3AxZDI4NC9zOU5lcFNXdUpMa3U1VmkvMkdkV0Z1dnUyWHEwdU4xVUlDREhhYVU1UjVtd3BPNXFtckYyTHduam9TVXlkZlp5STFEZlJicnNQZi9KYm1ZOTdVV0d0c1JqcHllUFRnYnRQUTNKT2pGeG1ZRkFTZHZ0SjNYazRDZmRETkRRb2dOT0pTdlN5REcwUkU1TTd5UW1YU3Rkdzk5TVEyYWNBbnNNUUJnOFo1NDBIbVlsSmpTR1FiTUI1MTVKeDY4THdlc05oVXhFY24veXA0OGFPN1AxWXM1MVpsUFhEMGdXMCtvM0t2NSsrcXIxQ0hqbUU0Q1lUWkp6VXg1YVFEY2E5S1VhaEJBL0NMaEZ5RllDMTVWeWlvN2FRSm9qalhTMXdNWlM1ellLNWpoYzlYbXAzRXc4Z01aSHVCUjlLMDNDek1OMEN4Um9RTHY1Z1E2N0JpMGFUZE1vbVhPc0h2bVBmVHdoRlFEMVJSSGF5VVFFQ2duVE9FRFBMZlcxOWtta2R2QnJuNTFTUXZwT0RFcGpsTjgyVHNWdVhWbFcvUnJhOFB2MjhrSW1tVG1mZEhBSFFSUlVkbDg4Rmc5M2ZTVTR3Rmlodkt4NUtUS3ZSeGxlb0J1ZENEaU1FNWtTZEp2MTBsT2F0bEVsQmUzcTdDUmFhYTRpNlJlTFNzS2UvWU9WV2xkL09TeTFRUStzaGR1M0xueHNvOTRWTlpHY3RoOG9PRFo2ZGEzU2dGVGxscmNGbVV3ak5yWGFJWklUWXlYRXlsck5kbTVqYnQrKzEvaGpyaGh2czU1VVRNclJrWUNwVWJxQXRyZXE3QkVPTFd5eXdWdjhsbk5zZE15NW5qZjd2L2tIdno3N2U3L3pVVUR3VmFiZWx4M00yQ0dzbXR6bG16cDVHd1AxZkxrandtcmFrTDQrUmZVY2R2Q3F5YTdkWEpqZC9PNjEyZXJWQnBZL1pxK3d1SnFyU2RLa2ZSUUp2TFN5TS92OEo0OW1QL3VUejJiZnVmYXJzNnZyOTRZRzhlWmxCWjJQSFNCNk12dnlpd28zaTFCZXkxUmVpRkdYTXlQbk9oVm84U0FDcVhmMTBtRitsYlNPMC9kdEdHSFJvUWhISGRsK2tNUSs2aDVTTS9hU01rWFRoNnE4Vk5oMnFSTmFSay9xd0ZScldXbytEV3M2eDVBcUhHRzFwbzZvMG9POStFQkVoM0hTNHFJU29kM1QvSFVqYnl2TVhLaXR6czI3dHpKekh0ZGg0L1drc1I2MUx1M0JhTmRTWThPbE5MTGNKWms0WjVWQlhaamR2RmE2d3VySjdPNk5HaUR1bEVzVHFGM0pOTHg5OVhMclVFWjQ2U0ViTWN1bG9uTHBTK1hPWEIxQXpHZHg3cE5KWFdqQ01aK3hKb21sYnNncDQ2KzR1bFhxQ1MyaEh3THdTcG9rQWliczNpZkF1QnVZWFV5OWtadlVQV2dwMGc4NDkxdUU4Zmx4L0xrVWdlaEV2eVRhYkRjZHZoWnBJVXhUUUNRM0NOT0lRTkxDcEVOSUw1QlQrT3pwNHpTNXpnaElJQXRxbUlORTRBdUI2V25DMkRoMzBxaDAwcURWM2J0M2YzYS9INmJtU1NranAyZHBKRWw4ZmlpSnhFRENqelkva3FJMzg4ZmhGeHJJS0tZUG1PVWNBVkh1a0hhMk9jazNQTWhkd1RVdytRNjFrMTV0VDVVYU5mUkFvVTRuU245Ni8xS25DSzBWbFJNbHhMam9GbGhkS0hDZ0U4SXVMVC9OZERRZERPUUFCVTJMWnNTVW91MENMU2lqZDc5SXZpVGN0Y3h2UUFYY2dEdVVCbEQ0RU1EWksxcDRGTlkxSnNIRUZGeEtPRkU4MW4wL3ZsNXF6VVRqblUzWklrV3J0Y0RwL2d0ZFkvQjB3b2Z5YzdrcUV6N3N0Y0RvNWNzbnpVRzJ2Yk1nT3JnMUlUZ1hGbWdCdlZGdi9mVUNUZVo5bzZnK0RmL2UzZXRGYXpmVDBKWDA1Y05jL1c3M1RLUHRQeUJXdXRBVTFpVjkxc3N1ZmxVM1FoT1RKZnc4T3hveFdiaUZObWxzR09LTkNFYzBxbU83SVQ2ZkNYT3IvcEdoc096emZGVDlkWEZ6Zm5idmZvN1dtcmtKSHovODhuSEtSQ2Q2WkY1ZzV0MlFPdTRjR3QxeUcvYjNmdmNYWjMvLzkzK3o3NWJkL3JMT2hPK2ZCd2FweGFSeUR2S0ZvOWhvTjRXODc2NTI5dHBCQmJMT2R6c054QzZzbkhac1VBelR3b3RTSEhSMGs2amRla21RcEFsMVdMS2tPcWt2djNvNCsrcFJtdG5UUDUrZFZnN0dvYmhYN1NSbmNGT1A0THAraExMYW5MVTMyZjJtb244K2RYYUFYeHFXbHExOGRCSkt4NkVIYmVUaVlOYVlhU1Z3U2dKVHY4OHpqeEgyY1p0MXVKZ0RQdElBV013QktqNVRrbUFndVRGcGVOQmNPVTdUY25PUU8yaGdkR3BBcERTeElaRWwxWjdPL3J0LytudjVnUDdGN0YvL1g1M1Z5SHdqVFYwcUFpN3FIekhNRlZEWm5OMHF2S3pNNW1UL2RUbEpqbTBxQjZydkgrNlZLNVRtc2xRWnl5aWJhbU4yYW1XTDhZREM4VXBhVXhyVldqNHRlVVU2TVZ6YnZqWWlWOGZ0VFFOTEt0ZjlOWEQvOHN1SHpXbHluT3NqUmRLanBjdEpVMUZpaituZzNnZzFWNFBqd3k2bGdkQ0U3QmxYQkVERHlkT1plc2hEL1pxMW1Qd3YwbUthM2REQWZFZTAwZmNsdjBySWxRaktseWJ0NHF2MitSMXdqRDVYVjY0TmY1Z2tZQkV6Q2MvUEFudnVFRFE4bXR5MTUxMHEybCtkUGF1cG9vNFJhR2FQNWhNdG5PVmlBS3dYbGk2My83a2Mwa0JTOXdPZ0tTZHJCR1JDRFZVYW96UUxjQVJleTJjSk4rWjFQTEEzMTVrSkl4a1dtQ3kxZHBtam1YNTdXUzA3QlFRR0FFY1hBSThnYjdjSDM5SENhUEFpK0xSTmE0dG5wL3kyZU5EQTZUdTl5TVZDcVhBb2lpcVFsUVNRaWdwN3FuaGVxUkQvbXJNRStJa0lsS1h5NExyd2lHanVKcHdCb2MrTnNyWm9hU090Q1E4RERZWGxBTktZamxxVExqbjJTWG9Na09SbWdJc254NHVsTXdTK2dSZUI5OEdIZCtQSnFjK2VOWjQwd2U0VGpWd3JHQWZvcWU2SEFiRDZWNUhsTnE1ckVkcTl4ZWsrQ0NjcHVSQnlIK2ZiOGVaU0gzcFJKcXJFMElId3d3bXZ4aWh6SnNMRFZGUi95TTlNVVB2MTluVytuNzRqTmVBWHYzOXA5aXUvKzJ0SnJPM1pCL2V1ZHZNM21UR3ZaLy8yLy94eGF2K2Jtdktmeko1bGxpMklrdVhsVlA3eU4zL3A1dXkvLzRlL05idTdsUnI1cU5xeEJydVlHZVJFMkxsQWF2YStSZHhQZWtjanJVZXFlYXJrYnZrNnRMNit2M3B0SlQ5SUViVDhYVFpXOU9ja1lrY3dKRDZVdCtBazJkMFBiOHgrK3VPdloxOTg5cVJJMytRZnNsYjVkd2VZZnZTZHJka1B2Mzh2YWRFcHdYV0s0R1BBSEtlQkNDa0RGZzRqZWdjUW5NU2diUDNUVkNLbEJ0WklFcHhkWEVucVN6ZndFTFZ4VWt2L0R5Smo2c2l6SWJGSnJkSDZGekVGMS93Sy9HeEE1elNoQUhDWmp5U040bUorZ0hTOUFQOVIvcXlkWVVJL2Vmb3Zaei83SXJXOXNUaFU0ZExGcGRsM1NyWmRYbkpDU3IyRzJyY3JaU2Z2djRzZzlsNEVza25XVEw4TGl6bmVxekNnVVNYMkFxYWF4NVZ4UG5KNzBwd0VZRlpHbHJ0a3dUckxabzRCeHQwRWdEd2RHZzFUNWllUHZvem95dnpPb1N6djdTRHRscFNtL1RJVkJ3UDFIYzUwWlJrU2ZmVjd2OUM0T0t2NXd6aXVKNTlHenVuV25JRGtYMUpNalhoVlR0RGtQS1lna0dpWFpNL1hhVUVLNGFjRElFVHM1SnJkdm5XNzhhWHR4NmdBNnNFWG4rVkF2bFpGUmJtQ2FTd1BIbncydmkrcUtibzNOYXZzQlBFNlZGeHVyWFJLZFRyeHRlcGMvK1RQUCt2Nlo3UGJuZWp6T2xwOGxaQmJhN3kwby9mdGw0M0Z1QVFhVUpYV0UrOUdLZTBWRjBKV2lFRFRTdmxnTEpydHNzWVhLdzM2dWtUVXhVeEU5TURrQlJDckNUd09kOTA4SWFqMW15THRhZERSbjhlazdRVnIzWlR2R1dCTm9CWGROQTdDVkErclF3cEJRa2dDc2ozbENCODVXNldkaktUbTFtbXM5ZkZHR3F5bWxYVnJDUTlHZWtmN3Iva0EvcVNSdG1PWmNsTktDUzBXV0tvMzVvOERZTG5rOGlWV25qVHVVZDVjODlXWndiclFodTMxUW9mRDBFNEJsajEzS0lwOE9kVUhEcUVRelEwR3V6Yi9NZDZLUDdyd2ZGcGVFWi9ab3MxOG5WWWxSNGxEWEtzWW9LV0IxOFdPUDdJWTJqMk0yajdhWmd3NjVmZ0VBa2xnbW9hczc0TjNtVzVwRUwvN1czZG0vL0FQZjJ2MncrL2RTYXAwb3ZOWmtjYWNzdGMyTTllMmZqMkgrMjZFOG5MMnB4dGZWZUQ0c3ZTSTQ5bjkrNWRuLyt3UGYyUDJyV3NCMHQ3ajJkcHA3VWRhaUpNMHArUEE2dUJGTm01bkdLNmRWWGJSU2NsU0RCU3I2djc0UGhOc1AxUldJaURrNjhTTkJaRk8yc0h3WWVYajZELzhhR0gzQ3NWdTFaVHVELzdoMzV5OStLSjJ1WmwxeXlXc01lRllPN2UzZFllUTAxTWpzNGhhbHZRQXJNYkR0R2cxVTRITGd1KytycG55RTVYMmNoNzVoYnFkdG5SdExCT0VhWlRxRzBBYUM3MkJjM0VRVmtTeWx3TnlGSDlHRkFRRTFacVZNRmRheEp4a3I3N0ErWjRPWEt1Y0FOR2I3WVhyUkIxRDA1bm5PMmo5djNkL1ovWS8vZysvTy91Zi9wZC9PZnY2bVlNRzVrZHI0eC8rNE1QOGJJRi9mcmlUZzJlei9lYXpHbkRydGIrWXVlaklkOXBZaXowa3IyalRTb0QxUEpBMnpxRzlOT0hKZDNJY2srMlV6UGZwRUZEQUFBaklZUnZGejMxdUhDamEzUFM2QjFZbm1YS09naHM1VjQyWnhua2FqYnpmTGZHVlJoUXo4Wk40TVBPQTBtSCt3dVdTVmkwMFF2ZkRKM2N4MEpLQXJLSWZLTWp0ZXA1L2hPYU1xT1haWFpKbjFjK3o1K1VJQmhRYzhZcmpNZHlsSW9VRHpMc0hnRG82cW4zUC9ZOGFjOXArWS83aWk1LzFlc0NlMU5yZHpjUXVSSEp5ekpTTE52WUtiT1JqdVh3cG9VNWJhdU9WbDF6Wkx2SDA4NjlHbjdpRi9HMWRwaTFLcTZBcG1XLzc5dVRac3dSMDRKWmlLSWZwV3FhUE14dWxEbnhWVlliU200Nk42WHNBaXJhU3NGM09kSXBXUkwrbE5DZ1k3bks5TjRIVHFDUXBzbmllcm1EOThLa0hZQk5CVEtIS3pFc3JiZjJHNWhxSWpLaGxuL0U5UmQ2TmNORGdjTzczQlNjVDdlNUZmMzFHTnhNK3FKMjBaMExTTmFad2VUVGRlQmJiSTFVdWl2UHQzV2kzay9aM0szT09yL2JKMDRJWW0xZXJVQkQ0c0JZK0o4THVsUGVXdGM5b1g2MldkTFdjUzFGYmU2bG1VeEFEbHFDVjdhb0xGdlAzRmkrYzdYRjNHQWhISVFjZnplbmFUczd1Vk5MTDlRaXllUlpVbmhVMUUrT1pMQkZCaWlDQzB6NWJEa0M1UmM5bXYvKzdIODMrMGQvL3JkbnRhNm1QdXcvNlRqVjVNUWduSFlQZ1Z1MTJsWDU4Kzg2TjJhLys4TU9BNjFFVDA4UDV5dXlYUG9yWWRyK2M3ZGFkY0M5dGJMY0ppd0RPT2hqZ05JbTJtdk9UcEJKVzNzMEJxb3VoVmhmdmNqU2Y5ZFdWam53NlRNV2RqeERtNDBKMWkxVEx1Y1lzK2pDT29FcWJRQkFYa2lRTGN5MTJhQk92anJ5c3ZUZEprSno0KytVZmFlbzJGL0VjdFppdFhadXVUQWRETmRVWVhDb0c1a1lNbUtWZDcwUHVuVU1YQXdaNGlPTTRlNVBHZFJ6UjAwanB0VnI5VXZVUGsrak1jWWM0WE42ODNyRlRmYjVObFAxZjV1d2dVcUhCMDh5aHZqaUZ0VnQ3dmdKQkM2ZkpLQnNDa290SnBkLzh0UStMdnZ6VzdKLy9pMzgxdTVKUHluZldsNU5hYmZwaWFta3p5NkhlZ0pPRWw0cnlDWVNvWGVORWRoNWxOeHhnejJUd245N2ZjcnhJL01FZytYRUExTjA3SHpUMjkxTlFKU1loS2ZtVjVOaFE1OS9sUW1BQzdxYjZBeWlKeDg5S0oxalBLYjZhV2FrRGFKc3cxbWMvc0pWd2ljQ1pabWdMRTlCMG1KTFdVQzJxUkdDZ3BRYzRJV2t0K1pwb25uS3NhR0J6cmR0QldnOXRqUU4vYXJWU0xWdWFnSzRjR09MbXpWc3BRaVdubHEyUHdabVoyb0xMKzdsMSs0UFdBTU12SjZ4ZmRiSk1lOUpubnVRVVA4eWZ1VlgwOE8xdS9yZG8rZWExV3Q3a1BqbGViSjBUOUkrZjFMT3RGQmIrUmI0MHZqcm1EUjhXR3NFL2g5R2R0QUdkSFdqNzBpd2N1cUdzekw0VFp2eDlGSU1wYlVPVVRLZmV3Q29FSWtDRzZaWkM0VEU1M0RXYUJIYkFhQktHbnU5VnBHMysxZ25JT1R4RVFxbXNkbTFoK0FoSE1pMG5kSk9tM1ZpbjQ2Tks4d0o4aDhoY2lHNUZNVjhMV0dSaXk1M2szM3EvRzNpMzl0WnRzeFNpN1oyWXI3RmRqYmVkRXduTTNsWUN0eFVvcTVCNFUvTkZLZ01oY2ZmRE84MVhqV1YwbkRCeklLdUVkZThQWDFqWFZQTGxQcXRweTJmeDhrSDcvalp0OFcxQXVwdlZVZXJRaE13RGRXTUdrVURIYmlGaUdhclV4Y1l6Smc3Y0xCeTFIY0M5Qzh4T0NyOWZYanVlL2VENzEyYi8rQi84N1U0S2JuRVBrcXFMd3VVaFoyb3VCK1p5RXFnL3hnS3BXVnZaTHF5K2ZYY1FJaUpiVzRvdzNqeWV2WDN4ZUxZWGlBR2wwNlN0UEo4RVVBdld3aC9tTDNwVkRzZHplU3FaUnZISUxLZnk5czJLbmF0MW1xK01Kd3VnQkwrUXBibDA0d0VNVWhpWVNhUXBzK01zUnVFRW51L3dpb1djZmc3QzJNalp1WlQwUE42UG1IYnJkSG1heE96K09oaWNsTlZjMFZpbE5kV1RWZkNxR1NFblpmUVhnUFZldi9sR2dNbCt6Q3c2aVBBd29yeXo1TmtBcnFVQTREaXQ4Smd2TGgrZmNwUDNiZTV5NXROYVR2bDJjV3krUGNrVkV5Rkh6SE1SZ2ZxWmVtWTU1ZVdrOTVZU0ZqWnlNZC9TVUoyUE10Mkx6djdPZi9GUkRROC9uVDJ1ZU5TcHlnZHZ2b29KQXNJNm1SNjFCaGN1aWt5MVpyUE10ZFVTTFBPUjdRZk1hNmVyK2EwNndpc2kzK1BQQ2xBMzAyWXd3eTUvQ25XOXVUVDhJUkhqalpqOFJkckM5ZWFvNVVuZlNVaXN5azV1ckJlVHprK2ZwN24yMmtvaGJabzZqWWlrVGJ3TXM4UUJ1dXVGdnZXaWtqZ3B1RERxMDFvWklYWCtFWVFuYXJnVUFQQkxPZFFEVUZFQm1QbzBONERtTSt0cDhjWWdBVklKa0pPZmFjNGF4am5aNlZ6THNCZDZaTTB6MDlwUG10TFVMdG9XS3pYYlRJam0zc2pNRlgzclF6RnV0VytCZ0FMb3Q3a2xUZ3RvdkgzZjJpV1F6eEtrZUlMMmJjaWM5SUJtSjdPVFRTanF1QmNqdzNPcFBYeVNUcGJpSTFwSndGMkkzc1loSWQrQVN6dWFzSkNwTC9MS1pSQ3RkRjBQOStHUFkxNGJ1d2VBNGxBbmtDa1JRSXFyWVZSbHRFWmNFb1VMaGdZdEJXYzQzOTByVTF1TzJraEhhaDNWL2pwZjhlcTF5ME5Jdlh2L3V2dTRhY0dDMXZYT25WczEzTHpXSEROZmFZTHQ0NTI3ZDhiZTRkK3R6R2lkTk9BSXgvcWxUR3I3NkV4Uy9pKzBvMnZEbGZMOFJJK0hleW0vbG9jb29WSTR4NEZ4dmFqRzROOHp4Ly85czY5U1RITGFGL0E2emwrOUtMTHhmL04wWjgxMUpWbWFuZy9tR1NSSWdIUE1tVmxaMlZsVlhkVlNXWnQwMFMyWjZiSXY5SS95aDBsWHVwTnA2SmFxczNLSU9jamdDSkNZWjBEdjR5Y29oREVBSEp5enQyLzM1V3Q5NjF1RFQ5dThCdEVHUkplTVY2K29GSlVjRU1ocStnOHNKWVN4L3duZmFQRFdoa0VDdGtTVC8vN2YvM05rWXUrNTNFMURzK2EvcE54M1RkbnMvRitsTW82cmRwelFsR0NMbnduc0xaVE1PQ3VNWHRoWWlZY3VCaGR4VTFmakdQZHloaEpBVm9CL0xTZXNrcUxKblZETzJzT3R5Y2JqTEd3OTBPOS85WGh5V2toK3BzakRSWUkwdWlSMGIrNWMwREVGZ3lpSHVuSlJlNmFsM0NZbERlVlM5RXdJODZCbzFtc1pDcnNXeGovSnJkZ2V6MzZlbTdaMklVTy9xdk0ydHZiSVNsMG9zNUgxMjZUZnZiN1hiWEkrVThveXJFOHB4Q1pjU1FiRk00cGZKWUVXVmIwb0Vuc1RJWGtnb05BbW5zOEZkZzhCQXlIb1lGNWtmTStaQllybTY1b01SYzhTWjNDVEs0ZS9VelZBTVZJQU44M2IxV1ViTk5qOSs5OTFDTzcvK2JKWFUzWUo5dVZwejFtV2JFdGFqdHZiTXVYTHEwdFFCMThVMFg0ZGQwSDJKZjl1Yno4Y1FzTmdmZi9qRHlHVnJXRmxoNUp2Y3huYjN0RTd1NlJjc3MxQm9GSVFteHVxK050SXh0RWM3R1ZzcENwSVk4QU5RV25UbXRGcE1JY2l2SDkvSjZxZ2EyYVI3MVlzYkpOVGFCY2hqL1VsRWRVMmdOTlU0amRtKzNsMGZXM09aa3JER0p2U0U3WlJLYmszUlFRZjNOMHVwd295eTNXZ2ROdGtlS0VtTGdVYWFtak0rbHpwb3JDNysyYnkvZmRmajhnMjVPY3oybWhUVmpZZlk3M1ZYSnkyVG9kRnBqOThLTW9OY1lUK2xQM3NwNnprY24yb293UkVycnNEZDFia1c4dWx1OVhtV1cvVUNVcUJDODZ0RXZYbDJpOGxienIyN25YeXRJMnZoMWVTbURJSXVjUy9yZVEvS3BjWnhlSVpxc1ZRM0VVS0Nmb3pWcmxPMEtkNW5KTGlTVUhQT1ZYQWxXeWw0TWcvSkU0QjRuUXBFc2pHT2tpcElMc1NndEVTRUtIZ0dqUjFXbEJHWndYYzlHVUlVQUc3UUlrV042dEZra2NtZ1RXTnlOOE5PY3V0Z3RiZXZNZ0lKcS9XY0hzbnZxcDlEa251N3I3TGpiK1luaWFkc3I0SWRFaXdobzUxSk1HcEtSUy9TU1ladUtzR0w1bDRKRDQzN3YwUGVvWmwzcHZ6bTlCbUhGWURpV1NsOFRjMjJnU3BRdkNlNElHeVErUDFzSVJrdUlHUnJvUlRCdmw1YUtFZkpyLzc4djdrSC8vdHI5cklLUmxGdktaZndtTWIxQ1RPeWJnczVSQWtoaUlhWTFiRk5WS0kzV2NobDJZdTg2UTF5Q1QzYUxIY0tHa0ZZWkdzZGlIa2hQYnk4RlU1TFQzVVJYbGpkeExDRU5mR293alV6NTVNVmg1RjR0NlJYNVAvbmNLYUNjR28rK29SRXdpVEVweHRNcENYWUxFRlhjdmQ3UzI5TC9RVFpHajltc1EyZVg4VXZidUs5MW5KMHJFRVJ4Vmlya1kySXFPdlE3REgrZUtyamZreWhNSTk0aFpxQ2FLMlRpQmhOa1c3Y0E2ZGRjODJGS3M3K3J4SGNNMldrbkdjcFI0RnlGc2h2dHplaGxVK1ZuUFdZcDlmNUlJWGlGaVlxVWczQ0J5VWFySlNaZ21BWkVVSTQrWXNhQ3lrclZsZEl0bms5Wm1wMVh2eXFJREgzLzk2OHBjLy8yV3l2cldUUUhWc2VhalNaaVM0OSs2bEtCcVBDQjNMcS8vVGVnaEllVTJ6RVhKOTB5YXREZmJkbmVZanQ3TU5USERYc3BZUTQwWWtOTjdPeHJrTk9hdmNYdzQ1cU9rN0xKQ2lZWno1eldsSnlEVm41QWEySG95R2xJM21hS0I1bXlkTE9odFArYkExdDNFV01pNytUdGxBUFFJOGpNUjU4bmVWMEg1MGZ3ajRYcjJxb1AvTnpTY3B6QkJVQks3angyenFMdEdUTklKUXN4SWxBN0xPMXZYd2NIZHM4dC8rOXZlanU2Z0VhV2ptMGFPbmd3SkJOZHk1MDdGM0cvZEtUbjJkVXFrWStyQjlVT0lvMUhvcXI2N0MzWXVTS0hVdHpZNDBUa2UzaHdCN0htUFQ0STdDR1NVcHJkRndBWk52aHZGdTFSNzd1NityZUVpeDVzTHVoK3FjLzNkV2g0NmxqT1J5ejZLWTJsaVZ3MTJHS3U1MDVpWUZKU1dJRXBZRURIMUJKbHhuZ2JGN2NVMlVGdVhpK2MxajMxSnVLZmJteno5cjVuVks2NEk3bWlLRVhKZWJwL1BrbUpJRkZKVFliTVpuQVJaN0dZRlhLZlA5VWo4NEUxeDkrMWRyR1RkNFVGa1ZRdjN1NXVOeGdNVFBMMzhhUkx4YTB0T0RpeEY5ZFMwVUJncEVFd0hCRTdyRmNYYXJCVkhPUTg2b2dMUG16RjZ4NzNCY2tvcVBIUUJiZ0VpT3BqS25sRjNvb2d2MHZxeGhMa0JXUlRTTnpCSHN0bGcvVGJPVEtTb0pZNHBPQnp4dmt5WEhrMS8vK2xrM2NiQml4YTdsWFRrQWdNUm9tYUlPU1FNdUhVSm5DdzJmNVlzYW5GeVlrVlBVZTJhS0JpcjhuSS92bUV0UVoxdVUwMk9OMFVKVUNheURQZWRUTURObFJxdi9BMjBER1pNNCtPRUd6dDJOYnlucGNhWjhxZE1XUWhxQWhFaFdBV1R1WFdQQlBOTkl6R3pqanFMbUVLS053cjJnTmVUN09FNzliTGFFUWNXV0tiQlpNTHQ4a051ZTZUSnk4S1MvaVpLeG1vU0FKZWhtazhNQ0RDeFZNMXBYMERaS0NZS0R0TzVlTEpyRVZRR04wd3FnYjNyT2JqM1pmTEtkd210dW1nc3VwTTJKbHp0dC9uRWpRdnFKWmRmcjE2NnJ2dW82cGJiUkl1dkpmcDRWbEF6cmRCZ25TbCtWWmIvWTl3ZnhlYnR0aktONHhRZmMxM1FSWWJXeGJHb3VwOUIrUTB2aFpEUkt6YkFCamtOWmpiNmt6SzFjdW5lMURGbWMvT3BYWHlVTEdSeHVZQzdEZXNhTUVuQUlDVmZ3WFZVTGo1ZXE5MHd4TmVDQkVyU1Baa1UzUzlLbEpLR1BQakxteTRhQlFFYXliMnR0clNCd1ZwcThUUXVSVS9CZFE2c2pKZ2VPbk1vcE43QW9Xa3BoSUlWZkVsRFZ0NzUvVnhwTUNzeUo1TTRlc0ZuSktIZlRwaVc3V3ZIdTc3MFo2STZiUjRsU1dPUVJ6V0ZUeW0xUzRFOGg2azdnd05LckNIb1J6YXVTZVVkL3FnSTFjUW5OUVQzZ3kyaDM3V25HUGdPdmZVN1JlRzVrYzdpUWtuWTgrMVg3d2g0VEdaTnVzOVVtSjl0T21WNnErSnlMajd0U1JVQXBRWTljcUxOeS9NakZRZHd0OTF1aTdVY0ZaRTRwS2Z3Vk1mUTc1UVV2cU1JWVNxc1gvUTBTQTBZRWFjWjVtRzErYysvem84OWRiMUk1WUtHbjNKbUM4V2lTNUFhZ2tTbXY5UTFlY3J2R0NCUWxSSFMvQUlPSTVuSHpzSnhzZUsvVHhFY1NhL3pjL2UydERFQVZGZDFydTJqMGgzY1ZQc2VINHVDMmNzMTFaUjFWR09tR0VxS0dNbHN2UGNMK0pRKzNSNjlHa0dzdS9vZEhNYis2SEZ4dTk1OW02Uys1SWh4bTZ4R2FtVzFRQmluTTNqcU9pNE9OZDRQUnkzRlNIY000MFYzbDAyZjN5b3VLL0pPWEZXdzVUMGhuKy94Rms2dFpYaloxQ0FjK1o1Q2hVRUtMWjBCZzgxV0NmdFE5YnlQUUlad1BuVEg0N3F6RTBYSlg3bXgrR2krMkhTd09va2VPSHFXVmJ5dUdYbW5UUXowTEtaYnIwQkM0ZjlhOUw5TE00NmhzQTV2TnJXb0JFWWdpb054U0RjSnVTdVNDRmdnV1JKRCtTVWdhZnd2UWt3NVhUQTRLQ2FDNlp5UFJIU0YySFZLVXRZdzR2KzVacEIyc2x6WU9lRHNxNmJJczBzV2UyMlpjS3FKa3Mra1hkWlVidDFBU25SdldWbW95RnlKSklrTVhMUUtVMStaY2lrY0M5V1hRTHpjNWF3VTBDRDhyWjB3c09ZOGY1eVZVZmRMY2NLbVc1SXBGMk11cE9ZMFhXaXBVdmxYUzNkM2M3UFc1amNtZGlsa1ArZ3hrZXhhVTUvNDdxSEsyMTZGbmRXMkVjdFN6RlhuZEtlaGk0N3pmVldwVm5WdlcxVWFUOW5Mdlh1aTNuN25XdC8yK1g4blJWUnZqTkt0OFV6b0pudWp4b3lkRFdOL3Z2Z3FsVGR1VzJOQTJFcVZFSVhFVGJVcWxXanBlRHRSZzg1R0JIbFNxeDBoY0ZoMUtrU3MycGlBcElQZFFyRzh6R3FmTnhlMFFHTGpxdXRzUEh3OGo0cldIdVhXU0xDbXRFWUhxTTEvKyttL0tOMHVaNUc0KysrU1RsUEJtbTIrdU5pa3ZHbC91VzBqcHpadlhqVzBuVkpmc1hzZ2hxblBKK3M1a1B3VDA4dDNQalMrWE9zV2ZEU21uTFhUWlpqMFZuR3JkRnpkQ3FUOFhaVXc1Sk55dFo4YTJEYjJTYkQxSWtlcDV0VjQwVWlHdlZJRHIxaHVDWVBoNElKUzdQbGZac05CY1hrZ0lhNm45cEZRbEZaT3NKcjl3dFgyWkVuQ0l4QkpEM244b2wyQjQ5MllrTXBCZFErQkFCUUJrYmkvT2h4SUJsUE5jVmV2Q3hTTmpnWjkrejVoR2w1aC95ZVBUMUl6SzZVTFBONzAybHdFZnA0Q1hvVSsxM2ZSc2YvM21tMlRuZkxJZGlxTGtlVjZRb0FqZlV2enBYdk55OS83bTVNdXZQcC9zVmVKMkVycWI2ZjYrdXYwd1BOQ1gzQzF0cmtmV2ZNRGhMQ1EzRUZrVklzTmtWUUhRUnB6TTdXeXQvZ0ZoaDJ3UHZEYllGRUNqYVErbEtYdFRteFlwclR2bFJRanNLdXZQejliTk1jT1VVTTVOL3NkLy85dkpnN0twWnd1aDMzWmdwWVdIYmtZbWJvdnFlMlJYUXQrbTdRdHhDQlpDTjl6Q2FXS245aXp0M2phalNOdEJuVVVkWTM3YnZjSEIyOXlrdkppRXlDSTIwUzNiT1FWWXo2YlpsSUVKeEROSTBQVEZhdmVFRFQvQmFSUDBHQWxMTlZ4Wkt6c0Q5MFRMSXlFSkYvZG50R2hKNkFZZk1EN2IySnVNZ1VBcHQzSEYvdGRudUxJNEF0YmV4Rkp0K2dOUmdQcW02NnN0UjBXVFBjMERlK0RzUjZMV1JYU1J1Q2dkL2pKQlVaQ01DYjhLUWtOMGN4SFhzeFJhbXVHaXRBaThGZGZ6TkdVOGs5Q2ZOQW5hcWZnM2ltS0h3ZzJsaEdDRnFuRjFDTmVMTnZKS1JMUm5PUXp1MzYvM0V5U2haeEYzSDZKUXV5ZUhqUHNoQzE4ZWxTLzFvckxFZDhwMC8vT2YvMnZyNThqNW1qUjJ6YUgwV3NmVFpFWkVUTTRRSGdpeHJyRWZSQzR6M09acjZjZG5LWmVwT3pMbGJrWlJidU5LSk1iYVQvUGtVc2U5UUdHWjd5YWx6L2F0ZFJGaUh3Z213MG54dVJaWnNuYm1uenM2Tm1GeTUzazNRNkM3SVM3QkZvZjBJdkJWWTFodlNZcGNycVBHU082T29VdEdzemtSOVZiL2Q1THhlVmRMbFIrck0xVXFzM24zV1Fob2FmTFhra2wvZnRNQkNVVTdWNHNTanFMLzFuZWdWZHlRNjdlZVdnSk5lMG9sVjJTL3RkbTVwK1V6VDZLeE40WVJLVVpYcHF6MDJZSjh0MG9iRVgxTWlCclBUQ2ZHbE9EYUhLakxsUEFNVlZNb2lzOGRianBjcStRY2tpZkRVS2U1NXJuWXMrYkNuRUpBeGlPdFl0UnhOcjhVbURuMC90N1U3M2JRK0hIb0FHVlJnbFRyb1Z3ZGdDRmx5YnpXVE04d2tWVXJiTDFGTDdudzZqaWRtbTBmalZTWTV1R3FOZnIraDI4SFlseXZLY0lQUDM3VDRhZ3Z1cmZlWjUzZjBKeFI0bHZ4bUtMV2tsSUJnYlpienpjLytaYy9kbktTamRlekRBWHF4aVp2Yk5KTWhud1d5QU4zUWUvWjloU1Fadi9IdFVpWnRvMFJRWXlmaU9TOW44SllieUl1czJKQzVFcyszTU1mNVhJc3g0OGtYK1B6WVBuSFVLdXBzYmxXbGpZbU45N1FDd1BXTnZqV3Y0bnFjTXl0aDVPanEvZTFaam1idkhqMTArVDFUYmsxS1ovRjBoRXUyOFMwZVR6ejVMUXhQTTBGczhHUjFFTHNDbFRuK0Z4akRWSldMYWJlVkdvQk5TVFRxTStma055VWo1SWlSTHoxWlZYeGVSWUdSSWJFbHZFN3ZjREh4eGtOSHFueDMzUmZ5dHVpVTc3ZHByLzI5OGJIMHFUQ1F6NmhTSHdkbjN3SVJZc3ZkYUY1dGdsN1V3cWo1TmZjQk1LNGtpV1RoMksrSkcxU2RtcS9ST3RteHYwWjBRUzJlOTYybWE5Nkh3VStoQkpmMUNVcDQ0Y2xPNzU3dmR0RXh6T1VVTXR5SDdVNXViLytQdHpaeGpicURoTmd4NHlyQWNTQk9NQ1M2eVdTOTV0Zi9YYndWbS9mS0xHb3UwQXdYbUJCaXNGb1Fad2JaZzZjUnljQmtCS0FtaFlyV3AwbWkwSnFVMkxmbkVOSEFqb2VmTGxxQ201dUM5Qjdwa2RaS2YveVJTbWhIN1RWcGFUMlJUNzdvblRKcS93dEczVEtxMDd6QlZkRFJlb0czZGM5Y1hFN2RTcGxJTW4zWXBGWUoyNURLL0xrcnRJR1R2YlJub2F4Y3dMTTBkSEw1cVpXMjY5ZkovTUt4QitGWmpOSEtZYWpra1JSQ3JLd2RUbDUzOTRacllSNzV2dlZXMW9EWlVJVWlEd3JlMFRLeGYyN2o3cGZLSHNvcWlpSGpQNGhranN1N0NUVVJwNXZRemRISGVEcUh1UHczRkFjRjA0OXFmVzNCeWt4WUdJby81NEh1UEJGL3NiZlErVGNSNjZhanJ1OVpjeWRDQzJGUTU2aHllTlFLejZRa3Zlc2pLdzFjQjMzSXFiUTEzU05wcldaV0lvQkNKSlpSbFFQL2RGVU1LQ0RRbG9MalYrRjJyWTc1bys3Ky9yTno1UGxTc2tZaWpaYUNiTHYrdHM5M3VyZzdkUlovdnFMcnpLZzhWdmQvbTZvMzl3ZDdHdHBWQlZHUm9laHZMNStrMHpsQ25ZTmNqdlAwdktOYmFhaE5Pak1CRVNXYkZ1MFJRaEdwb1JzeU1WVUhkOTFwUC8zZmtlSFAwcExycWNvd3E4aktURUtKWlNWeFNpaU14Y3ljcFcxS3Y5UEU1UldwckZuSlhPM0pBNDZnVVo1aDJ4bS9JL01YbVV5SWl2R3RWeHg3bVcrLzM0bnpyNS9GZUlxV1hPbTlpb3ozZVFremNhOU9hMSs3M3hmbHR3d1RFTkJHQU80YnRJSjlXV0x4WnJnVmVhQ3VyTVJwZ1I0bXBnWlE5THoyOEROU0FtcVdiR2U5N1pGR0Q1MG43MHAxd2tRYXNXSGt1c3lUV0JScDRUMnczeG4wcVZvV2M0Ui9ZaGphbDZIMGt2aWhsS1IrWTB6Z3lSYWc1UkV3MDA1aUNxbDA2WUNtNkxTUDJvZU1kMWNxL21TV0ttbys5eUhtaU0vTjVMcHVGSjRzMWxOUkQ5U2ZLdzZCWlFBV3JlN3VYeVh6Zit4bzhVVHpKVktZTzdlMng1dUZPR0dDbVRpMi9EbXlMUGJpQkN2RFU5SlNMVFZaZ1dYdE5GNzl5cVhZaWhFdWh3bUFwM0o2K0Z5c1lZMkFOZUxoYjNxZWJsNjNMK0dQVFlTZ2FjczhEbzIxWFVvekJ6anAwUVVwNG9GR29PKzR5NVQ1S2FkdTA0ZWJGUWJpalgzT1dNa3Q5Yk85VHlMMWlRaVhqaWJzMXhoM0p4K1Q4cDA4Q1ZicFdzNFRRZDZFSENTOGE3a1NFMGREazlIaHlWUjJCVFRiMy8xUllwcG9kWkR1NU8zQlZHY2ZPeklOY25IYytXMnpTWm9WeUdvdFpTanFOdEpDYkdlZzJLYWo0NTR1SDF2MUFYT1JoVkFnUnRyTllYTXFJMjh0VGI4ZWZ2bktyUzlIRmMxSDhLVnFhLy9GYlJIaGVqckpSQTBhaFRsNC9YTW50ZDZrVzNQYXg0OFAwTmc3aWtkSldMYUsxRW81Snl4a3I1QmdTMmVkMEJMQnNaY2k3QU93MFVHMjdNVWxMWHczZlVodGFIa21yZTJ6M0I5NVkwZDFlZHRMdmR0dXh3c2U0QnhHQVB1TXljWm5NUG4zT3ZLckFJSHgrVXlydVlpYXAzekxyVEw5YjNzR1VSdEtVckljVFVPOXF4b05yU3lLU09nNStObTQrdHV1L0ZGY3c1RU5PbTUxdzFhMmdLU3pFWTBHUkNDeFNWc1hBREpiZ29kVnhKUWhKa1NEZUhPcFJLa250YVJrU053SFFkMlZjY0RYSXFJakhiQXQ1WE95SUtmbEEwYlE5dzA0SUdDb3ZtKzZjTXgyV3RaRXBaTW5kNll0QVJTZlI4K3JRQUFRQUJKUkVGVXhIQ3UrMThYQ2J4ZGxGSDhvUHNWUGNuNjZGbmxrQU51MCtxOUlseEJiVHlWdXFRelBtT0w1R2NSdGlITWJWcVJPcTFQRW9IaG1rbWJtSzVMQWhjazZkV2gwQWpTTEU2aGllTE9xYWZrS3MwRzJ6M3pxRUJ2OGtlcjRSWnp3TStVckwvSk9wOEpnUmlMSkRqejUxQU1VbUplUGJ2N0o4cmoraXJuTDdxR1Z5Q2tWclJ4NDNsU3NHMGtodzNnbUNUQVFrV0NCeUpQdmh5TEJNMDVnZGRHQmN3ZEJYNFdyK1hnMFJHaDdYMDI5R2d3MkxwUkZEaU9NWmJHUkdnSkFZdE1CcXoxbmRJWUhqOTlNazdvaG1vZmJPOE1FcGkxNVA2Snl0MnJSaytQcy9GRVhkT3Eyaml2WG5WbVlNakM5ZTVVZGFESW1CSmpCQm1ucVFLY1JzOCticlFQdVJhTEtaTTd1Wk5kcW45SThKb2I5am1FOE9BVVcyL0Jpc1hjQmVQMEhuT0J3akEvTmhZa0E5RWd6YUViU01uemNHMTM3bStQZVRPSFE2YVQwNk5ybFIxVGhZZW5nMERmbDkxL1VOZUp1MFVJYmRUTjFsNFVjejBsOC9qeCt1VEZuMy9xODlWZ0ZzUVFtQm9CbERZajNxcnBid3d5OXAyaldPdWMxbUFwWHVaTy9HWXFwakZsV09ZMmgxSlpidUc0cHRDOTFCUlVCSVI2WGtJcWhFM2U5Snc3enVWbWtCM3lla0h4ZEJPRStVZWluS0poZU56Y2ZQclpYUGduTFFDU21pdENDYm5aMHhRWmxEaDE5NmZId1UrQlNudDBvREdtWVNvWGN1N3dqVmZKa3dObnNDcGszUE9MdE5NWG9xUzc3dzRhZTF3dEpSNTlZNzMyUy9yV3BITTFlZHdQZ2VLTGI5dVBCeWVkcFNDcnZacGZMWkNraFRBK3VyVElpWlBISmxKNU4yVDFwMisvbWZ6dzNYZlQ0TXhOdGNDdHQ3bmhrY3l0TEY3L1ljRENKb2V3OFhGdERORGV4TXR3RmVYd0hwd0Izb1o3cUQzRWN1SDlmL3lieDVOZjF3ZDhya0xsbVZJUnpoSWE1UGxGY0hjdUZEQk90OGtqSFdjSEZoSmVpdlNPaGFnZ05BM2JRbWpZZHhQeGQ5Vy8wNFRWWndadWpPeEI1czFHbm10Tnd2cHM1c3QvMmlHcTY4SEgreVlsWWVmSFV3b2oxRXY1ZG8rRnJuRVpzc0I5dWE3WHJ2cjlNaUdZYVd6WFNHS0tMS3RpZ2E4TG1XZnFHbmRSMElxZ3AzOFA0ZlE3VkhoSkdCUGlaYVFmYlcvY1dURnUyUkpGMDJSQ204SFJrY3ZGdmVST0UwYi9Cb0xwdmNMSXdCRGtNeFJSd3Z1eFcrUEloV3NCblhuSGxieHRQUVpma2VLYmExM09XbUJGMG1jcDBvRlVFajZ1Ymk4T0pBUU5FV3Z1ZEZ0OUNKWEtoZlBHRFlZZlExUmNUQ2h2Q0xaRFA1MFdnd0p3S3MrOUVUM1RjZll3UmFKdnY5d2tDWmdiV1QwQ3IvV0llNUNEVmFVYmpZdHlZTVUvLy9UemVKMmlTU2tHYnJUanlteUJhVGxPbGpkaDdDTERYWlJmeEJYbExrTk5vbVd1RHdWeitXeEN3dXlMVzhlNElOaHRTdGVEd05RUFFsM0c3WDZVRnpURmpjMnFkUjM5NUcrcWlIalRjK3R3MEwxNnpzTmMyZlh1d1RpOXJ4MHpoUSt4MmFDSS9aTlEyYzh2ZnhvbjVxQkEwb1hsbFpVb0dzTDVrUHg4Q0YxUU5xTGFjaEh2Wk1Ed1EzQ0pKT0pwaHdzcEhWTWVWenFMOUlhM0phUHVQQ2hWcGMxN21DTFY5ZVN3ZElaWGJ6clZKMk9nMTV4SUhLUjFHaTF4MEY2NFNQNHl2ejJQb3YwRUoxbGlaTXlWT1RjbjFvN3g4Y1VvZVAyOHpYODNJK0NMWW1QUVJwNWJ2MCtWdm4yTURpaUExSmdwYjByZlhQajhRRm10c2VBVjVEM09LMHorR0NRdThlQ3dreit5aHJ2VWVaUytVQXJsTTRmbFppSHpIWkRTcmNmNmNmMnQ5VWp6NlhVSHdtelhpV010dVdYZ3o1TlBTQjAzS2tWRXU2QkhqNTlPL285L21lWWdlZ1lYbXllMEJzbkhGVW1UMi9Ib1lTZmt0UG1WWXJRSCt6c3lzMzg5SUtzZ3czcWo2dTYxTXNQdmhIVG1lbDJYME52UWdEYkExMDJZTFBuYnRLbW8wRzJ0VjdnYWZOeloycHZNRmxuQi80anNjRjl1RXhnUWRpa2xSVnVmcDcxRmh6enZjRUZUT0VoRUxwUWtQdEF3ZTh1cEhwczZOVFVzbmV1YnVNeDc1dHB5OWRYRWV1bTZDQmp5dnhqVGVONXhrR3F1cEU2T1VKSEtkbENjWXA1T2JKczlvYXBLb1h5ZUZyUnM5SXZjZ0k4S2ZESHVib1J1ZTc4U0JzckZvYThzaHRRRHBTQmNObTZuRml6YUdmZVhCaEljYitoU0dacTIzaDlTYlQ0SWpKTkdSZ2ZKRnRhbWRGaG5jdE8xbkNMU2ZMUnpnYkhyRkRMZVJjU1NOUnc4VnhlampQeXNHWnNzN3g1OWNsekhqY091Yzc4TWZRcE1RSU9pNFphTDRncWZEL0syNit5TkRUdy8rZnpMTDBjL0oyNGxlRDVhQW5WOWlvN1NzN25KQmpRekt2cDdUVW1QeldEVHlGcWl2NDNYZWd5cjM4K1VqYzNHSUlwZTZnZ3JDb2tBeDBzTlE5bld0NUUwaElOd2JXWWJpaXM2NVdJZ2l4Qk9HNVhjeWs2SHBMVTB3WUZBVmx4YWl2YVRUejlySTJ4T3Z2djI2ekxlYTlkcnJudHVMalIzbHNMejN2MUtkVnhyTTRRcFB3Lzk4U0tDWGFMb284ZlBKaGN2NnJnYXhmRmdPMjcyNGsyb3JZVGwrTm45K1pSZnZDSFVzZDhhQzdCQUxURkYyYmZhaW5kSXkvMFNiRGRDSWRjSDdZRmtXSVJNb3UxK3Rib3J6WmRrUzBFdlBCRHVTclNaQ3ppVGNjUFoyS1RRSkM3SXBzWFBramZLeWpyaW9pZ2pjMnp1ZmVHSEhNQjZrTElmVFFwN2orYVhTdTA4SitWT3Zwclc1a0MwY3VwU3U0WTVnY1RzZFZRTncwdUdOUm5RQjAvZG9QWkYwN01MSXRkVHJ2cGdYZGZVei96YVB5b0VITkdsOCsrSm10ejJIakxqZkNuUWNGTmI2TklsQkViSUEzZjFLdjRaZ3FPWVAwYU1Iei83ZFBMREQ5KzNwMUpTRUttbmJ4K1gzcVN4MlJRcTh2VUpnbHlRNHhJSWJkSWwvRktMUE5OTmhMN3ZWM0xnbU8zUlNhREpXNHpjbVd1aFJuMWJpMlJEOVd0NVJrMUlTWlNpYVZkSFFma3NQV1NtWTRGRHRHNUNOWG1OdmIvSmErYm1LYXZDL0pjdHVPUkxLQ3pDcW9IMm5qYlRoWFNHRnBYRk0zSnRhVFhvdis0K0VJbnVrZ3AzYjJuckZKN29nL2ErNTkzbnVneHNDVzhzdXdtM2FYUVFUUlYwVFJ4Vm03RUpZZlg3bGtVSlVYVmppT2E0TW9xMTBDVElPbm9ZNVplZjVlck9IVW9zN1RrYTR3MkxLMXUvWExTcjJqOE1CZ0o4enBWc0dRWTNkUFBMZmZXTzRpbXl6bHdQNUZzcUxRWEc2a0dUd2VQZWN4aDhiaXBTT2phb1NKQkVQU2hObEF1Q3lSSmxiQ0F6YzM3YTg4bStsemwrMjNqbU1oUU9sRjNxUFUxSGdrRklzOGF0TWVOa0RtdzBHZEhwMnZpcE5tMFA3OGcyU0ViUjh0TlNGRmhFM0E0dUUzcWl4QVFES0FaeUF4MnBVME9rd3dQR253eU9MMk1kRTlyL0tSNGJnVUhzZHVQK3JER2tTVm5qUVd6QWxmZ2xpazV1RUc0SWVyQkpqZDFtZTk4NHlhak42ZjAyM20xelR2RjR4cUdNKzV2c2RzOXBRei9PVXZ2QzJ6aWM5cmdNZGJ3Y2QrMjBXazVaMjFvdEc1aVR6eUdObGJwZG5MZlI4SFpudVdzSWNPaENQZVpNOUlKMk1ZMG96NkdnQWxTWS9PM0YwV2dPdVJJNjBDNW1OaDdyT2c5QjlIdXB5T0tkclRvZmxQNGhkMDFSODNtYkhJclg2OHBwMUtPRFoyS3ZDYWFDWnhuZWpMSzIzTmFZWWpHbDA3bVlCck1vR2NwcjFQeTJSdFRsWWpMQmxXTkFLQ2ZyeVFpYkcydGlucWJSY1c2eHpoaFRRK1AxZ2Nnc1VKTXgxcXM5TkJmZkpvOVE2Mk51OVUzem9MSEFkZFVwVmxpSGozMVovODNYYUgzVVhKM2ptNnVBd1l0dTFuWjhCa1ZnVjQrYTROQllmZlFCRW9ibzljOUhJNWhEQm5SNGZkOTVEMi82SjFMdGJNelJIU2JkSVZBM1NIZUVIU1Frb3VFaFJiaE8yakJnQ2lRMVBXV1hocTNtckdpUWJPampMTnVUVlp1Z2pkcmdRVXlDQk1wZmhxN2toNXhWL0N1SGEzVnBaN2hTOGkxbVNyRzNTVlNTYXdtcytSaWU0NVppU2NPbTJ2cDd5Q05Cdklxc0hJZU9wdFJ1Y1ZDaEFRM3FtbGVpMHFTME9QbnZiMTd2SlJSdHVPNlBMOGlobU5TMHNJbE1PWWFPTGk0OUM1ZDJ1a0EycStlMGlOUE5HOElFZThiR0Zna0tNZlhMNWJWanM4c1IyOVcxSVN0bnNSTWVKUnRwMzVSNHFyY1ZzM2l6ZHhQYTJqT2Z0RkNpZHd0WktxVUVBOFYwalpzMm9mUGJSbDk0U0tvNW1IYVRLQmpSMy8xblV3eXIyc2FrUmJSWHR1Q3NtUU1VUmw1YjR4WlZoRTRwVVZuc0JJdGdDNWRUZ1dlTjBVc0FuU3FDbGNhQnVGNHVLb3M3NlBHejhrVUZYYVBYMjBVSmJ0R2w1cEx5b3FDYXJHYWdXZTUzaXNMWTFKNzVuYktZbVVrQkpVQVU1aUJIMjFIVzN4Z2hGRW1xTnBpdjlhS0hrSm1zYnVpSklocEZ2a1VBR1V5UmF0SEp3NzVEaVRpWkVTSHJtc2hxQWdGdFVUN1dic290TGtTa0kzZHpmMEpQbWt6YWZBTmhkMCtLN01jZnYwc1d6eVpmZmZtYk5tVnBBU2sxSlY0aTNaQnlnakxadXExMURhU2FqRUVFV3FiczdiK1pySmZzZU5QenZkMTcxU1phelUwOHFCODhwRHB0YisyNkdsUWU3cWQwekhQeko4cjZ2Z05ITGtJRnA3WGlGalM1ckZWdEtVb2piSzhEQ3JUTTJGd1c4VHZzZ0pLMTBrSkc2VlhBZ0FHeEFCQ2pVNlZhNmxBTFJJUW56Y0cxdzVQRDZidzIrTDdNT2FVMWpmcUZ6SnNENndWMStXNjlodUhvWjY2dmEvdWRhd2xOS1hLbjBMelhQeWtLMDlPZzRUbW9KZ0Z2VFBZS3ViK3NlOGkwRVYrUmE4L1QvS3NWbENMRFJYUmZFZGp6T0MzY2xIMGw4NERHaGNRZWxEczVVeUw1UWRIY0QrL2pQbC84TmNVUHpYMmU3TFpYazUvMWtWaGM5K0dubjdidnZobkFZU3lXNTMyNHZmSUgvcmJ5QVp3VlpRWFd5WUhTLy90K3JWZzJTMmVYVjJNN0hNWlJUYzhpcTY5VUo5UDh1OTk5UHJsWFZYYmh1akdaQlBHRSt6U3VReENDN2ZtNFIvRUJGMFhncEJaSWpyeEJpdmR2SmxRbFExMi82TWFhZ09XV3RUaXpjVnZYV1NFRnhhS1NJQ05oZFFER2NjMzVUdXZnOE9PUHV3bkFVdG5ZL3pENXkxK2VULzcwMTdwdi9yemJBUTJkYWZhaWtwVElmcjJQVW9kdC92aWpRVHIzMjVDTDBGL1hHenhSMFRtUXltTEtzR1psb0ozNWtpTWhJUjhZaDF0YXdQNDIzKytqYVZ2dlgwanc4SENpZFVPaEpyd1VGWXRwZ1pDbmVzQTdjOUF6NmVHbC9JRWdYS1hVQ2NsNnhLK3Z3Uk5tY2VWWExRWFZLUXpYOU4rd2xzYVZnRkpxVHBBUkRSdjlnNUpzYnE5Tjd0bUU2K1dmSmNjSm94QThsK05pdUFqN2trdFRDSTZXNnEzL1B6SlNIMHFRUFlhRXo1SG1rRHlJZmhGR0cwRmZkNXVLSlNic0xnRFdEejdFdktSNGZRMnlQWVNBNEZVS0JVbFJJSlFWMThidnJ2T2hzVWdQY0QxNVJOeXgwNVR3VU56OVRxRzY3MURDeWRXNFRxK1pBeHRJdmRzMFJ5dGoxMmJrR2FBZUtCMWRUZkZZK2pFNVNndy9wZWo0TWpuZDFJcW85ekFhL25NQ3RjMHNtMTJrejF5UFEyTTdBRUdyNUwzcTJkNWt0T0lPaW93OXFIUEQzZUV0eUJHOFNoRnE0Y3lJakxsdkhoTFpESDM1YnNtTE1TUktHVEp1Yi9PWm9oUmhGUUY4dDJ2OTFvdFM1c3EyVGs3MGRyaXY5ZElYM2M4YVZITEZBQUhycnEyd2NmdWFLaDV5RzVIZCtrSmE1aDVYMS9RUGRFNlJlZC9ndTFwUDYwdXhraTBsVlZ4alAxK2tnS2VLTUhldk5ScW9MR1ZtcmtHaEpIcnNRd1plTFMyMGpVTGgwbG5MclVxRHVOdWlmaENxcEZpRS9OUjk3N1BOcWM0dFN5S3JvVGJkaDE4OC8zRjRRbi83dTcvTFpkOGFVZXU3R1FUdSsySUc3N3NmdnB0OCs0MW5uU3BPeG1pZVlscHJVbG1uaTdTL0FscFJ2clU0aGE4K2V4YkJEYllqQ0l2QVJINkxSQzJXeVBnd0NITnZyWHErOXZwRjBIQW1uMVUyOUZtS0I4ZXkwbzJqQmNlRXo4Wmh2WDd4WWZMR3VZTjVZcXZ6KzUwV3NqVFp1VnZPUnI3c1dvT1RGakFUQjNGVlhvb2pxV1M4TCtUSEg1ZDBsNmZaWms3Qk5IWklKZDB5ZVp0cjhNMFBOVjM3eTllZGhsekdkWnYvL3AyZGhPQk40Nmhtcmk2YkQ1OThOVkNEbmtZTFN3ai84bEVhKzN5YmJDUjJKcVNVdjgxRUtWNUgvTW51eDgxbzlXcWlGaHFUbGloVDM3MDM1NTdlY2xIS00wcDJRb2FoblJib1VtcEYzUjNBNTZzV1dKbklWYytCR0hjRTJWclY3Rm8yWDRhdVpCTFAxellIVDZPTTU2S1NtcE9lY3lPK0E1ZW40ZHA1UVF2UkVWeUNmMUlGakFjUGgwZThhQVBvdFVYY2JIckcxMUh2RXZVb3pJWHFEd2tMQWZQYWZNSU12YTR1eDZuazFyR0VKeUd4Z1NRVHVvWG1BbWZCR3I3UHVqTVVsQ0Frek8yWmJkNnVVOEtVTGFsbm1NeVoreEo2Rk1SQzdoTDA1UVJuTk1MZFNQcVRjb3NFSmRTQk9jNWNZYkllWnJLdkdiT1ZrQlBselJyYkhMZHhieG9nVXVUUTVjcGEzRlB2NHhZdDVyYnB1cEdqa3pFb2lGQW5BSzdnUm1oSWw4ekRrem9NdEhFcE1aMGpLTUdUODZQSnl6Yy9UWFp1SHRFMy9ZMGlkQUJGcE8vMjAzR1NqcHBQdVdmbktheWp6aWE4VTJUd29qTTB6K2FVOVZSUVhZTTlKMEV6WGpkMTVjQjM0b2tpWTBZbjE4UGtScVBDa3dJNzE3amVadlU4VW5rMVRnZnF2WXFTZ0pJUGNxbm1sNm9lQ0lXOUxNOXJLU1dxVnp0NU9Vc3U1bk1mcDRta1BJQUNFS0hZTWNkZE80S2x1UTVwb1V5R0FwcnlSZVpNQU9DeWVkZEJSTktxOXNycUdhRlc4OGdWL0Vpb1ErcHFSeUhPMGFTdmRVYlZXRHRHMWZVdTgyWVdvNEEwallTaXRuN3Bkc0VRdXM2SDJpOXhTNkcwdVpvUlNHaDlVNTdjM1ZyTXpMZnU5aFNrTGtsN3JoWThxZ0x3YnJPbEJ4MUZYZWd2LzZIOWNyZUF4UmVCRFh2aTYrK2VUejcvNnZNMmVBR2EzTXQzNytvakZycSt2UzBmeThadlRwdll5ZHkvKy90Zi9XRzRCVDJZU0pMU0JCYk9CeFZVcWdzU3NoMkVhQ09odWE4cnRIMzg4TTdraTBkcms3Lzk2bWtDMTBLbXRLVGpiL1p3VzRYRDd6MTZOcmxUWWVSRzFtUzdNdzhmUG5zd3VWdmVoaktTdytxaTNnZUhYNzUrVjlicjYrQnZ4endWV1RqTy8yLzZ1alUzYnBvQnJCRDRNazZMMHBrcEVXMHhIemp0bUJWcmtWSlN5WFFiUkNLaWpWMmRZNGRpZkZhWDAzL3pENytlM0g5d055R05LSzVEd2tLMWh2TzVpUE10eEh5TDFxcm1EK3VkaFlmS2d2UlA0dW1pQkVadXBjWHdIaVVZS1lpUkdKcnc0VEVVL0lvSXBVS0hBaEdkWXJGSFZEQTRiSG92VXl5NlhSeUhnbGc1OVZ0S1M4NURrS0kvWEdaa0sxVDNNYW1XMVdJc2hnWHRrZFhzc1hxcStMdFpBZ0xLdzR1aHpOQ0wwNVc1alNJc3cvcW1FTGpURWhpdDhSUWROcFlVampGUXhKU3pqVXlRQncvVXM3bzJkRTBpM0pzMWh6SW9yT252YWFQV1hSY1ByWUpaVW9KTjBZZ0dzdHBraGl1SE0vSDdOQ20yRC9WOGlzTkh3bWk4aXM4ZytnazBLK296cS9GV1NIZlBpcHJBVzMxMDErVUtkWWt4VDR5cTkzQkZHUkNiUjZqOG8zc3pQSVArcHRHZkpPVWZmdmgyWkZNL2V2Z294RkkzQyt0WG1SVFVob1RldkZPS0JzU1pBVE12Tmk2T1ptOVhBOERjOGRibzdkc2FVNVp3U3ZFN3RVYmhNNlFubXU2QUJkMGZWbk50UGJSa1d0bjFVSzJjdDg4Kysyd0VGS1NGa0p2SG5jU2pFd01VZ3BkY2kzeDNIdUZ1NUx6MnYrdWhNdVQydTNjaHdUak5KREE1c1JZWmh1WjN2cjJZOWg3UEt3RGh1YldIc1ZhRHkycWVQUWYrRHVyQk9mbUNocTIxSERIdjVUMGtSajFUYmNRTGdFQlhHaDFhVXpLbys0VDNqOFRxNXBueTQzWDRMTzdMdlh4WnkvRytQbWNkZGg2SzNLL202aWt3TDRldkJGS3lhcTM2NEhpUDdyVmNjK3NqeDgrZTRDMW8rV01QaXBLL2VQR2k1NG96eTZpK2Yxc0tUM3VxWGRjZG13T2J5aVJaa0wzZG9HMnlLWHYzUWZrckV2emVGWTU5LytGdFFwSlYxRXk5d1dxSG9aVEFVVWhidFhvOWVQOHk0dGxCQkpVMnBEVUhvWnZpcVpZa0JhY1RaTkdZTlBWeUN1dUwzLzE2Y3ZLK2xzcnZEbXRKOFdieS9QczZqM1ltNE9rUHRTdE8rZWovTEVWL1BhSjdyVHdXeFBKaTlZNDRFTUJVUHRWU1N1aGhtY1ZiRzUrbUFFSVFUYVlDNmV4YWxqV0ZWNzhpUGJLV1UxSTN1VVlTWHVXdlJLUmwxWnQ0Q2lhTE45T2lqQ083Z3R5SWM1dFJ6cERjTVZFd0hVeWI1NmJKaFBmb2FVZENKT2xUbnBpanhPU2RRVEMydTc3M2xNUEltMG5acWRlU1hUNmZFYmhKd1lnZ1haU1VlSk9Ddis0a1p4dHh0ZmxaVGNqbVc4RGoybzJ3bnVvT0tWamp6TWlOelRBMmVSK2dTRWZkV1U4cmRvS0lWRTRpc2pSQ3hsMUxzaDlCZ1pMNndCZzducEF5c0RhK2JINUtDK0h0TlVwWXZ5NXdkaWplZ1lyNnVDdWxBSnVjSVRTNEdxN040RWk2ajBDRnVjSTV1alNGUlhuaDBYcklnYXdrcVpLZkhuZDYvMzRZeXEzdnJrUEJnczBNcHc0STNKR2hNRzNTN2dlTmVXYkt5cWJ5TXlYRGdwLzR2ZiswZFprU3pYaWwvVEVIWEZsUnhKbTRXWE4wMjNwYzFqa1VEZERJSmk5ZlBUY1ZRMGs5LytucmNVMFJWZ1pnTllMOHVwYTlrS3JDN21jWnlPQnpxTDVqNFhiZjVmSnREdTdNQnRkRm96MlY3TWg0dnhlaVUwUjlPWG4rOC9PcU5INk9jSS9qVVVuUWVCa0xpbit1L1NBNmJYMWtjVHVxVGMya0JHUEt3WkZxd3pobGdkU1ltc3ZiV3MzTXR6ZEZwNjBkNVdTZXVHVlExQ0NuUmR5U1UrczZVSG55MHJ0YkI3TFFNcWJrRjRjM0ZKb0xwVm92aHMxZWQ3MHhOOTNMR2l6M08rOUhOd1hHVTB0bEJlL1dyaWRPSk1wTHcxMzErMCt2SEMzL3FyMkxxbUNZcG1rb3JnLzRrS08xUEthdGU3M2VmV1h3NzFkYjZHQ1ZqZE55L0FJbG01M1RRUEc5cWhQci9Yczd3N0NOSUVCM0d4a0tqV2Z1eWM3Nkh4cGZRZzJHVHQyVmtVV1V0Z1BqZG91U0hBV0Q1M05qTnFwemNqQWtsK3VUT2czODNXK2Vsa3NodXRFQzE5Wmx0YlBPOHdxbmFRVk56RnlXWjY2dUJrZlhIWFZkMjVUclBxY2x5a2FONlRmcVNQanN5MDhuWC96MjA4bWp6N1ltTzdsd2xOTmhFUG5OM3RIazUwNWpmdkdxYU1GYjdoNXV5ZVpzUHlscTdpRm5TNm5ZWE8zd2crRHRUa0l5RjJ4dit6WHhvWmVpUmtzMUNwdlBaVjNNQlpncHZlSzZFMkl1ZzZRM2JiYkxZT0oxbGlvS2JiaHQ0ZldRMWhSNVNlalVrbGpkWHBMYy9rMVFVakFVL0czS3lSRmppT3lsL0hOQ0NpV0l4TTNtTGk5bVhScm01Q0MvOTdwcm5DUjg3NDlyTzkwbWRDakRhU2huY1hWNjdwMGtSVzZzbzg3MEkyZFI5SzhTNFVtWDlDd0VLYlRTV0FrdWhVdjNVSm9VQm9IVkVVQTJzeVRHb3haL3VDd3BFWW1ubEpibWgycTZCaW5maDZkSWdsSk9FUXhoNzU0dFBxNUljakMzL0tQMUpBL3FSeW1vZmhvdXpRaU9ORDgyQTRGV3R3aVIyQkxHUDc2Nkw2VUs3WUQwWEd0SnJWdzNDbXN0ZzJhVEd3TWpDUW40M2Ywb0l5aVF3UHRacVkveDJlVFU3SENQdW9wckQ0VFFacERZVE5GeGNaRDUwQnEwcVcyekExeFZUcGdMQmc5UHRmdnVWUjBZUWtJaFE2MTFSUGcwYzl5cEJFZjdvdEh4c3Z1SlFMUHc4L1ZIbXczOWNQZEVwcFh5N0pZYzZYMXFEN1dUTnI4VU5OZG9zUTE3Rk9LWGd1UGNUYytCSjB0YmhpS2dvblJQYytpOGhLdU1sZXRldE84U3JCSFpQY2piQUNBa2MwS2RDUGRwU3RBVTNUaExrR0ppWkpxNkRMWWdVZlBUNzlaOVVEdU5EWEp5WCtzSnJacG44MGZabUV0UlgraVpvZVRlajY2dERRN2FaNFNzRldSc3JqOUcxdDNETmZCa3Jzc0l1VGI1ZFBhbXhuNk1sWFV6T0VhRXdrSVBjRVZkUi9BS1o0bVU5eDRvK1NDalRoNThmLzdpeDlHQUVZRXZBdjNtZVM1bXNqRTJvUGtIWVVkNHZUbVZ1SWZ3RnZrREg0OWFiQTlnOG5SeGRKRzlOOVVMM1dIYkV6UUdPZGRIZlI1WDcrU3lhRnFiUHd3eUp2QW1SVGJjblZxdDZHS1FsbWdUQ1gwbTNGbUNXV2tSS1phSEc0OG5Eei83ZFBMcnY4dlBqNkFIaVY5MjdQeUxIOTlNM3J3Nm5uejk0MCtUeXovL2xJWEtOMDhvRnhNZ2ladXJMV2pyMzhPRytsS1lpNXQxS0toUnZZNmMxMW5HMjBLaU02RVZhUXNFOEtvSGwvYWdPcDVMTnJpZEZJMEZOK25YaEtEUk96REE0aWowVmc0RG5QSHhiK3ZkUkdzTVpEWVFDbXRWeVVpTDlLSHc3RkZFamh5ekdVcXB0eTR2bEVVZGw3ZDlYeEttREhiUUhUcXA2MEFDTGFqQVBZU1l6ME92Yy8xd1dwNktIa2hMbTlPSTZXSmxUWVNDTHc2T0R3WFRtb2lVWlpaenllS2lFazdqMVRKbHVJWTlnKytYRlUvN0drcW5NZmJ4b1NSQWVadXN5NlFzY29WYVZ3cXdMVFkydjU3K1M5M1hScWVzSURQbFI5RGxhRWc0K0s3NGpxNkphS2ZnbmNNM0VHampJSkF1anVnZENNbnZ2VzRERUhob0VaSVVQU1Q0RkJLUjhKeGtrRnZCc25KalIvRzVqVE1RV3V2YzJuYkxYdTl2ZllqQ3RDbHU4RysvL0RkcTNKcHZxRU5pNDNvR1JWNFdpUEg0OFdkeGFKM2NVa1NTTEV4UlQ3U0hOSUErSTVuNG9ENVVzM1Vla2JPMnRMaWQ2L0lvZzdNWCtmNDJPWStiQy8zclZhVitFbWUyRWdKYmJWT09QQ1RTMzN0T003eDRMaTdUM3B0M2s1djZ1a25LbmFrVzFvSkQrdWV0RzdlVEFrcXpOL2NobzY0SDVUTmtyaTN0QThJaW4xeFpuMFZCZUJack5xSis3UVh6S3VJcThaYjdiVjZWSG5GQmtmRDRyN251b1kvYk9IcXQ5WGRBTUZtQVZDRXY2RWwvckJhdmF6YzN6UTgrVTVDQ1BtQ1VvRnRCT25KSVBoYm1LYW5wZUIxUFI4a3lVRkl5WmtvNTJzaEFLWWdlYm1pQVlaMzduRnpNOWwxL3NPWGFnYTlGL2kvSE9lNDN2K3ZyMjVQUHYvZ3lSY3hZTU13QnBQUVI0WlVwTVArK0UyL2RoTUJUVU9yWmxvTnVheHAwdFVsc1pqZWp0TjZyZkcrdXVBekQwcmVUUlJlRnRtZHl3NVlpUVpPOU5ubHVRUVN0Ykcwd1pENVUxZndGdGVOUjRwaGttVHNwK0x4anI2KzY3M1dMcG1acXBvM2h4SktGM05HTmgydVRMenRFWWU5dFpQM0x5aWIyVGdzdDc0Mk00Tk15c1h2N1JHeXZ1VTFvNjBCNnY1TjluKzJFcmtJa2Q4ckVYMzBZc2lvSVVLMFdUYTAwUmJuTEdFZUxmdE1tQTd1UjBSOHR2WEhQTm9uVC90dHR2QlRkYmNpRGRXU3RSbzFYenlQWEJITFJwZlNvcU5hVkJXd1h6YlV4MXV2L3MxMDdqV09XcFB0eEQ3VVFXUzFJTVJSR3o3N1V4dGpjZnBMeUxvTzZPWFVRNldtdk9WSnNxMU5IVnB1am1SSnN4MGtudVovSTZVWXkwSnpXdGxTTFNNOTVpaU1KR3NUMWN1OFowNUZMeHgwaCtFTEVUbG1oQ0d3Y1dlT0VmQ2RPeCsrUThsRGFyUk5MTjNVZWNGNGxOSlpUSnFXRGdFSldVOWNqbDd2M1FTWGRkaWd2WEJDNFRnRU40VzlUNGZzOE02V2pWczhheVpLbXdOS3h3NVhGQTBtam9KUWdUVEpJY1VGdnhqamtMdGtqdE5QZVZUWmc2OU4vbm0yL0pGZThvVlkzbnMvcFQ5WUhhckFCSVVDYlZxOXliczNnWnB2ZjI3aldMajhDT3U5MzMweWVQWHlhYkUyYkFTN1hta2ZIaVR0dHRCY3ZmdzRoMWt1ODUzOS9OQnZpandET0VEdXhTQUxoVWRIZWw5VzNTaXM1TE1HWTBwZm9lOUo5S2QwSDhUbjRXY0Vpcmg5R1NsNGZaZlMrSERjS1FaY0xmYzR1b2dkdVJRVGJkMm9jUmREa0xWbm5URmhqc28rZ0RJZ2sxMitnWnVoRy9TUzVFa1VNS2NzZGF3elE1dGpqeVhsZ1BNT29wckpPb0FWQnR2SnNHQjNwTmZJSUQxSmFVb0hrS2Rydmd5UExxMWdPcWJxblUyMXcyTlpCenFGUldPc2VxSVVzcVRVQUFzam9ZSEdhQzMzU25tNG5ESjFnckU1bmt1S3g5SEJsWlBvdkxzYzVkUjBsWG5MU0R1VnZaWXdPM3VyT0lrMW5lZkpmL3AvL010eDZ5dmoyOXQ4T0JJNldHRHp6dyszVlB5QTVJYVdqRXIvV1VqcHo1WDVJdGx5djU5Um9oOUZFRTZyZGlqOUhoOUJjcE5YT3EvdW4zMzgxS1UycnIwS1dhVXBja2RRQmlZVVUxVXJKamlZVW1jK0ttR0NKZ3pmMXUvSEVwMFZ3UkNSdTJ6aHpmVjYvcWJNUXhua3RmUlVjWDRVUUZ0TytEK29sL2VpVFR1QjRjbSt5WGNtSUZxNzN5bnRhYVJKblJPMTZzRm5XSjhHOUlBaGxJdDk3K25Ba1VKN2szeVBZYjVwY0NFcER2cVFrM2lHTDJHSU0xNi9YRlJ6M1VSUk9ZdUdKS0FscXFtdXphaTFERDVVaFRNbUI2ejBmQkNibjdHN2s3ZjJuenlZUHZ2eGlzcEExT2t4Wm5YRi9zMjRmNHE3Kyt2MjMxVU9tUVB2c1lXNWFvQ29sNUo1dC9wQ1NuazFIdVNnU0NCMFZOaHRhTGNZdzNOZmJua2t4dHBOMUtaOXhoRmdDYzk0aTAxRUVuL1VsWEF5TForQ08yTEM0SDRab29jMUFHZGlvdURkSm5OYkY4N1NMcHQ5N1lvS3NESXBTUjd3N3pYcVUvTFFoa091S2lSR3cza0NCSVV5MWFxRXdtcUlzKzFFYkNsckxPS1JNV1gxcm82VU5aV1Zla2ZHVWxaL1ZUVkpxK0MrYmwwSzEyYUVvNzRmVW9JVGhHdm01dFdRb1J6cERGcHByUXZFNitvdHN5Yk56dnhaNFBCTkRpTndsdXhDblFNbDVRUkNrdWswL1RlSU5wWFV2UVl6ZEVqb1Z6cDNFYWU0V3lUdHZzNjF1UGdwWnhlRkV2QzhzM1NtcWVOUy8ra1AxdnVNSWVGOWM3WmV2WGsvUjBaaS9VRWp6dDd0M0VDS2pCTG5jSFRiY3VabmMrUkhBYXEzVzFBbEdkMEJqb29RaWdMaklZeFJCandFRk14N0c1em5OdVNVenJ4WWFLa0s4VDcrbWFOaDhxWG5WMFZlanpiVVVxbUNERklPRkZvbFIwc05ySzVTb3lvRExwelpYdFlGajVYR3VVbEVnczR2Y05ubVFjdFNnWStPUnRVNldFT1hXaW9KVWM0bkg0OXBEVTlQVW9LR2llNTVvbXRiR21rS3NFblhKK3RmZmZqMzU2Zm56b3FRbkFaR2YyeHNCaEs2dnlhS0dDTmZSS2lPb2NQNWtHRUN5YXcvT2YvTHBzN1JjaVh2bG4yeDJpTU9kcmRWZ25GWVBSMEhRSnFPRmtSMTlYRjVJenphVU1FNXBiVVYvbjdSN0ZvdlB4SmtpWUxhNDJRYmhtKzRVU3BhM1BDdnVCdlNTUm1zZ0VjRDZYRWZNVDZNaFBWeGRHV1QzbWlBS1RmS2xpdTh1azc1T3NMTVVrL1UwYzV0dm8zYkl0NGRsUUQrNE16bmVhOUVUTUwyMmoxTmUzYVZGUmRCUHMvYTdZS0YwU2FlTk1NVWd4QzQ4enhVWWJUKzdwN0lTU0dJcURRVCtsNi94V3Npd2lJMHVvK3NkanJxU3Nwb2paSEVRSHlJSHQwdWxtSWtNUFNqcWVkenpuUlNwckpDbS8rSUZjZ2RYSTN6dmJpZndLWjI5ZWl3Slk4dnZPaTRxcXR4SUwvTGwzclBPemVJS0pZVHZjL1B1bG5FdGdpbGN6Z2lNdktwY3pnWDhSWE5qOFRSa0c4bWlEWm1RTFF3Q2tUNkdhclBFSHFPVnByUUlPNkdYUVByeTVZdmh6dUF0dkNaNWNEVWxLWmVKMjRmUElvU1V6bUVaL2FPTXBSTk5ybnRPaWpCSkhjS0pkeUJVWERJSWcrSHorLzYrMXI0bDd4YXRtNGtLb1B3R3gyVnpXWjYrY1NtNlNNc3pSamsrUi9FWko4czhkZE83ZnVzT01kaFlSTURHa2RoYmJzbVFPYnBhMFRNWFNnMGFPZVRtNG1Zb1lPNFFMbTJnclJTc1krbTBMM0Y5YnRMYjNSZXR2UWFCSFV4Ulp2cHNzckZYNUhBdGhENDZFeFRSVm84SkRjN09GRkNhcjlUa3JMclpjS0lXenZmdWJiZlJTMnFOU29Ha0hJb3FzbmNad3RSaFYwQkJXK1ROVWk4T1c5ZUZsS0JlVmllbEVBMTAyUmoxUmIrSzBHK3d3MkJDMHlOQ1RCUlRNZ0k1RklKMWhUN3ROczh6U1BhZW56SzJqdFlhaHlVZGFDYjBzaERudXBTQ2RKQXFJUExpK1U4OSsyd25mMytha25qWlNlY3YyKzkxa0dqdEZ6b01RN0w0VWxIMDVSU2E0K1pyVURHNVRuR0pHdUsxZ2pJcG82a2JpdWkzbUF5Y1lhSVJ0QUk2NlR5SEhxbXhURjFpQ3R0N24vOVkzLzFhbVMrRTlrYnFSK05lSzNDeFVhN25RY3B5WVJIL3VEVDU1cThkcUJJZnZaaXNyQlhkbHlzcGNpaWhtQ0djKytyTCszK2dhWjFrb1U4ekxjdWxhTTFiVkJQQng0eTlUN01leTZrSkdZZ1MvdTYzbjAvKzhXOC9MU2RMYUQ1QnozMjZpSFRUV2tPZFhCcG5SSmR1VTFpTEtSbGgvUnVDM2FRckg0RmF4c0VDSVorQlluSXRuY1htQ0cwOW5naTB0akRJVEowVEVMbGRza1ZqdFF2amE4dlJ2Wnpvc1JINTZjRWNibm1kSUI1bXVmZEtGcVRqa2VrekxaTDZQampaeHJycFFpTzZrNktOTGg1V254TFZzOHFrTkxnaEJFTW9XaWdiM3U0ZlJjNHByNE1DQWUrZS81aStxNTF3RWN5ejdyc1h1cmdrSUxWM1hZbGNIZDFEMjRETGNWeDMxc3Q3U3VFM3JTbWxRdmk1S0pEUVlZWFdXbTFZOEUybnV4Uk5XY210UEFHdFU5cnpjUUhXbnF1c293UEJ3U1Z3a1pSREpEcGpUZ1p5Ylg2Rnkxay9Hc0VpKzJvcW15Kzg1SlFmR2lIOU5oVDNEUkhOU3VLNFBEOUVvbWgxb0pVK2d5T3lYbHBlUTlvRGFUYU9iakRjQW9MSVBjQjdNRllVcTgzREpkVEVjQ2lmQkdtNitUSmlYWStsOWV4STRGRVBtVXlBL29jaVJzMzEySGkvYkVpS2JpalVsSjduMHRabWJOaGtCNHFnSE1rb3hER2VKNFZKUVltTzR2YUdhOW40ak0wenFWVGdhT2tPc2wrRFNNc3FCV0tsdVVUUXoyazVrMEo3OVZwa1BPV1dVcnJNaDVWNjl1cE5tZTd2YXl4WmUrUzl2ZVB4ZDhuSU8vVi9VdXlyQ05zRmQzUHhIZklCUVV0ZDhLeFBuajBlM1U2MDNGRVZNazFKaUJMSnNCOVVUQTJKTWFZNFZybDU0N1NlbE1GUVRWMXpQSE95YjcwOWh6a2U2TFdWOEIxSzlTVWx4anB6NXhla2J6US9XNVczYkpkcXBESmxOVVAwdERyaFpxam9hY2QzOWV6cjVmNHB5TVlQS3hEdjBzMUhPWVB4YXdBREErY29OV3RFVWJvM21aTHJ4UTIxTDBhNlNYL3ozUGhjSENKbHpMallUeU55T0dSVHZXYXluTnlRZXRGVEhYUUZvTzZwTGUzQ2V1cmZ2N2RhM2FZdUdnOXJNeDFYMjdqR3dGcS9USnd6N3pzTVlmbitzSkJTR3ZaMk8wZ3o0VnE4VTFuSEt1VnlWdk90emJwWUpsUzVkMXYxVVArcS9DdHU3a0pDcEx2QlpjbVJCSTR2dzdKUlNsSWZsTjRFZnJxK2tPaFUyRmtlb1ZEV0ZnSHRVRWFMbmMwYlFyMlF4amNaMTAzNnJVWjhMWG9VK1NEVEhhS2FBekp5cXE0NkhPQTZiWHhkYUc0dXEvWDhtOWQxaEpTWEVlek9EOStvRE9EcHAvY212L3UzWDA0ZWYxWlZmd1RoSkI5NkxqSmVTVUdHTll0bUlYeDVUcTZhTVU3bmg4OHN3VlNMRHRHWms1N3hjSzgrNXQvOU5GbkxFbS9lVDBpck0vTjU3V1gwLzlwZTdYaW5ubnNwTkxaZjl3cDVQT3FtWkhtczVTTFAxM0VDRDhJTnZBd1pYalYzenUwN1Q0azVsVGhQWWJnS0w0cG16Y3hYcGhEU1VxZUhYeFA2VnR5c05yQ3BLeDB0cml2a2NSeXNQbzlueXc2MkdST3JOcXk4SHhOSGNBUlJDSmc1bHRPMlhsQUF3cEJYdEpLQWFiZHpXZTltdVcyRFRPMzFORXJ6VWVKZ2hpeG5LcVhUV0ZNdXpvdXo4UWZVYm40SU9vR0NXQWQzMVhzSXRMb3dxS3FyMURDdTVPU1VHa1hTWlllUXN4OFVHUVdEajFzYW9mYUV2ZGR0d0dHZytyU2ZyeXF0UXU3cnp1SHNRZDBJYkY3R1ZQRTNZb3lsUDZrM21vMHcwRk1UcVdpWW9ZWFlMbG83WVhpSFhveDFUTzdNOWQyVjdYSFAzYmV2Q3B4VWIxcWVuOE1oRnBhMk01aDR6bEpyMnNBM014L3lRbTViejNwaVpZUXB1SVZPOTVFQkQ0bmVmZkM0WSsrcTZIQVFSK2owUThaSTkxQ0c0RU1HYnJhZ3lrWlJkSDJMenpOc0ZNRkNicVpVQ0FUOGZITWo3YUpKeXppMDBaTVJRRUovdERHaEdXaEJqa0c0dHk0b2tCRXNhdzVIYTZpRVZ6NWtGeHhHWnFIT0lsc0JrRHNyOWZndnNKVjJUQTYzK2x0MFF2bDd2Ly90MzFRVVh4NVdhei80M2U3TGFGZzd4dUZ5RGFydlkyU2t0ZHhLRHFGdXVZTnYzdXkxbi9OZ1VsNkh1YThDU1RxUUhLbXZEWjJOY2JTNWNOdUhTb3phczV1TlJjcUhvOXVmUFBsODh2U3pUNUt0azhtZi92UXY2WS9aeVovKzVmczZoSFNZUlJudngwVWNQeXQzODVPbm4wMys4bDhMNUJtVDYzVy9rSFJ3TjhKenM0aUhZMytFZ1Z2WGNpVk95ckdvd2Z4TTZLdEJiNlRRTk96YXJWQnh2Z2djcFRVYi9MdDFXa3Z3RS9Fc3duTFJpVEhRenFVejI3SlcwZ0lXU3o4WU1EMEJnVlprL1lxWU5ZS2dleFk0N291eUkrQnEzUXhPc3FhanJYdHBiT3pSSVhLNFFDMU1pR21jYnJPU2VQYjV5WGtSanZjaHBRUnphUzBpTVhML0ltRjdsMUR1bGVVTUFmM3p6ZDlObm54NUw4N3BvQjNUZStQTGhKMGIwRkE0dExzeEVQZ0I1Yk1NL09wcHprNGJLeFRpWitVZFp3bWxhdjNMVHFXZVRhbW9YcGRYY3JMYlNkWS94Qm1VdHJIZGd1Q2MzdThuQk9rT1RkcVViOHkxVS9GT05yK0l5Y0o2cm1iS1JKK3h2ZDEzUXhHdEt2cGNjcHJJVFZZd0lVM0pnUC9hSitPZ1JDNUI1aVVSbVlWcStsSWNGNDFYdXhzR1IrY010a2pPbXJZMzBoWms1NGN0V2g4dWVVSTFIS3llUDJzTXBta0xMSktLYnpBSFBBeVo5R2ZDN2s1MGFSTVp3MUh6TnlKMUNRbkVSSEdZUXlkdWF3ZU01NkFzUmRPY1JxTjU0RUE2amRzaEgxRFRlcndkWG1aRXlycW1lak51aUVBR0lmLzQ5UkVWVXIxcHJ1SG1VZGFRSUdXVmNJN25sSDdqMElXUkJkLzdGdk1TNU1jeERKSXRWNXFuZzA1dmhzSjBBNG5SeWdBL0haVEFoODVYQktxdlVtUjNObXR3V0pSNTcxMVVSRXI2T0xUNUpyN3JRd2VvdnQxclR1dHBkWlRpR3pXcE9OQ1VwRk4wdWxuM1VzTUpPVUE4VUVlQmxoUWR4T0hBWG1TNkEwSW9GNTBVanVKMnVIb1V2bVBPVGp0c1lxUXpkQVVHQVFkR1kwQzEweVJjY3ZwUjBZVVdtMWQ1ZmNOVDZSNjhucFhJYzlIc1dNK3hkcHQxRkZrc3E5OUJ1dXVyWlNtZTFHcm5Ua2ZpMWRibFEzd2RyaGZsb0kwUVJibVFVb1RWdWtUZ0FCV2tqMzRHb2YwNHNnVm9zRWp4a1ZFZmlrWWxMRFpPTDN0bXBXaVoxSDczbkxpNlVrMHl4RzMzOFI2cnRmM2dVYzk3TjVjejVaV2kyOXJZcWZVVGpyVEliTUVPUE9QMXlWN0s5WDdqZk5Dek1FSkpxekhrUmN6OTlqZjMvL0QwNmJNRVpiYklpL1l5TkRsTjVxREV4OE9DNFNLUXkyc3BoTkppczFKWEhkcjV1L2liaEtRajZxK3o0czErNzhuRjZXZEphczREdkUwQVI1Vis4TjN2bUg0TDZLRVVXZm9PVlUwampqUnpnQzh1b0gzUSs5dEF6UlYvbkgvc2I4cEd1SlVqeXBHQWVGOFFyR3RWTHZDaG82Z0tpZjcrOS84VUltbGgrK3lEQjl1VHYvbWJMOHFrRjVMZW0zenhxNmVEek5jRkVXSkROSTZDNHJGcG1velFpOGtoMkIvYnVlQnM4Q3g2ZkowZEJ0OS9mcFd5Nk9TUXJTS1NRVnRCQXkyUU5SdDA4clRETVBBM05qV1hDb3FRd05obHMxYjZMa0dFbDdtSU5aRnIvUE80RGhxdGpZNE1oanowMHQvTTBzakNKcXhPVCthdWlzWkFNMkEyQzZjdWJiVGY2WGRLd1JvT0dKNzBzSDdtVisxajI3bmZ1ZUxUZjU3Uk9DQVBRdWU1b2Eza2JxQ1RUSDJiWjdxV3VuQzRGcVhBeFNNYlhFbktoTHRtSEZNWHA3djF2bzh0VENCMHA4L29BMzRVNUtmdzAydmpHcUsyZUJ4Y0hLUkI0RzFBNkk1N09oQlJjenZjMU5iRy9ITjlXR3B2bHMvajNuaVYxTU13TkF3YXBHYStKR0Q2SW1PU01wSEFBZ1RkYnNoT3crdzl6VS9QcGhMQlo2V1lVUEluSVRKcE5ldWJEOXRjUlhJendEKzllTlc4V01NVVJUd2h5b01yVFFBRnF5aWh3NlA5Z2libEdyWTNCRWJ1RitudUxzMHBsMGdYaXBSYjNvays4QTdmZUZ0VXpPRWRvNXREMzBXQ2tlN21vU2VJVDRJaUlmSFVUOC9wZmpneXZDRTMyRHg4YkF6Z1dLeTdvVGR0bXRianF1N0hsK2t0ZnlmMzY2VE5mM1JRQks3NVpDUzBkZEd2M2ZVbEp1dE9nV0IzRDgrZ3ZiRlRtcDN1STFpZ25UTlFvQjhYaGN4b24zRUZtek41bXlMc1lkcmVZMUpUVnIrczFlaXdVc1JYQ29Xb0xXVmpydCsrZlRsNS90T0x5WGZmL0RCNStmUEwwSlFpYjlIQjVBbGxrN1pjTDlDR1E1T1EvT3FISEtaY05LVmQ2blZ4azROMGZ4a0poOXk4WDFuTkJXRU5ZWWxtcUtwZWVaQTFhWU9mUmM3blNFeisrZC85YXZLb0RQZmIwK3IydXBBRVE1R3BBbU10WnBaakNDRUdLV1RoYjIwVTFvU3YyeTRmL01JNE5xajNIM1VmRzhYSnhSTHBrUHlqNVVsWm5iZitOU216UWZEQkIzU3ZBVmQ2UHcwQUVtdkxNcC8xUXBBU2d1T09CNXNMRGk5bktjOEtzZW92ZEhUVTMwcUEvZXMzMzA0ZWZCb1JuTjZsL0JaejIzUUpKYmpUUzZhd0VuaUxKRm9EU1lxS3l2aGwxUWNSbmZLOGsxdTNHbWV4djFzTG5wNkxhTmxrWEZGdTBWbnV3UGQvL05mSjVzNTI3K3VnenA2ejZVbEFvK01MbGErVzQ1UUVUUmNyZGJKU09QMzltN2VsT0ZSaitmbmQvcDdBOVV5aVdBZTl0aGdLeWtpM0JxS1V0U3ZKSXJLS014Nmt6MU1laEhFbUpLRU9jM1I1YmJ3NEU0cU1LOFNkc0dNcFJHNEZudEJqUTNvNFFxN01JRkFUT0JFbWdtaGVwTG5NOWZ2STIrbzU4V2NRTW5UbG1ibGZ3OGoxM2IxOFRibWxObEJ6Q2JYTGhhTEE1VHJaR0Vwcm1vclF0elcwK1JQSXhrYVJEZTZqNzc5Y2FsekRKazcxdHBFemlxM25NQVNOaFJJYzdVNzYrVVBvbHZzaEF4M2FNeWZ0cmd4STdsM2poZm9wMUZHVW4zdDkwRVkrNnhnNW5CNitVZkx0VWx3cksrbjZiOSsrbnF5R2NQY3F0eG04WWQ0Y0kzclp2SzlXWHVKYURJQTIwKzNkTnVPMGZwSlhjTjdjUTVublBSdVg5Zmk0Y1lkU05VYVV4akNLKzZORm9PT1pGT0dMVjN1cFhaeFdDcmI5UW5GTnUzUk1reWJ0TFlXcjNTYjVtaHFzTEhmUDFScDJ2ZVVxUDY0TGtrbnhRTTFjNTZxaWNyaWd0MVZXeUJFRE9qYUxTcTdtN1NodHU5L3BRbTlDV2NiOS9NWFB6VzZ1ZS90ZDRpdmxLSmwwQkV0R2ZXUDdBYkpzRGdWM0dDNHJMYmh3YlgvM25JWUlQREFzbzBWMENGUTUwWEdmazBpTHg5ckk0RExnOUVYRDd4bHhtaW56dXB6TXQzOFBTK2pWMU9EWFh6enVXYXRlYUQyZDNzVm8wZ21qQ2FPYW4vY2RWb2lnNituR1AxWlVQdE8wZDFFWGIyQVg1V21jbHZIK1AvMkhmNXI4eDMvL0Q1V1J2TzZTbldqUjR1c1RSY0U1ZlNURjNsZEpiUGlhQmloN3U3dkdMOVJXdDFzb1l0WFZrUnZLWXJDQ2EwNEZDYjFjcGNtVnQ4QmRvMU5EcmhEdUFVZHhYcmNIdzVQQmpLd2NqY04wZGlnQ2VkdzF2LzcyaDhsZi92UzZNVHhQbzlmZTFtZHFEN083LzZycjNrd2VmTUk2UVJTRm1ZZXhEQVVXeVNnbTJYaWhnd1FsUWNPWlFIQWdMUTVrSE1HVjFicEppV1hBY25VNms3SDN2VWlnUjh1YmRPeGNENzNTdUxTa3pmaVhFRnRVbysrbmNSZXl3VzA0UEI3RWVaVXJRTW0wZEtPWCtIV1JxZVVFQzgveG9jM3hjT3ZoNUdZRHp5SHJYYkh4YVlkSnZPbjRxdnUvQkRXejZsbXU2OWJvckhsM1ZoN0ZRWWx3UXlpNWdiVGkwVzRoa2pZMVY1RUdtT2x2bm1zYTNVdS85bjV1T0E2TU83am9tcTFYZTZKMXhCbW1FSk1ML05SVVFVMFAzTENPNWtpY2FLU3J0STRRanprY0xyK2YyN0FJWk1JdDdRRENnYUJjQzlrK09LcUVjSkR3elJXbEIxRlFlaElmdTFCR3JuWG92NUdQMDkrbE1TRHo1WFRKV3IvT01FcjJsRGJEa0MyRkRFUkhYUXY2MWFhWjVlY1NueFRaVzF2ZHJsUHRnM0w1T21CaXBHemNDNWxYRXRabklhUFZsZmpIWUM5bG9RRDlyQTJOZzd5Sy81bnRQTXJiK05ubDJoVXRKd043dS9zWmVnZUFQc2g5Nzc3eFVYTGEzcGVhSVVwcUcyZ0F5RTFqN0xYc2dkcWZ4WFhkMjlyT1VDZDVHWnlibEFma1BTdWExdk9hQlI2Rk9iWnNBME8yRmpOZTYvcnlvU2g0NS9aQlZNQ0JycVozYzdNM0sxZWoxZ05NclVjcEdSczZiUFRNblFlNEZZOTYxQjd6eFVpOVNjSHJzZjdkRHo4bGgyWDY3OGpSMm01dTRxOHo1aFQvUWFrZGQrNVZGRjR3RFpaZ1RQQi9jc1JpalpPampHSHpPMmlUbmlIVk5hNWRVbG1EaHdvQmpoUmJlK2M2T29EaXY0MHFjazZoMUNTZUZiZjJzaVJUdmVUUUVUSUU0QklORktib256RnBqeGw0bTRwVXQrbmpyWHJ6UnFIcm15WUJRVDZmMjBOWXR1L1hUejNrOExhSCtnLy8zVDlNL3VmLzlEOU1qdDYrYUhMcmQ5Tm5iVUxkTlhWOW9JeHU4b1Bselp4ZlZwYVIwaXFnTjVJdmo2dWsxNnhQOGh6TEN6S3V6Rll2V01LZlh1SVNMUGV6OHVyT0hEYWg5S1o2bXNsVjF1a2lTemVUajgrUGRjSkk4eDM1YWhIYlVDbXNINy81Y2ZMRDE2OUhGSTV3bkhUYzlreGg0dmJqUUg0N2oxWW12L3Y5RjZQVnlPaXdHQytuWDdXRERzYTVmN1I5RngwbENXMmlFY0pOMmVvc2dCdkJXUjIzZUxuVExWcldwazN5dm5QdG5qNTlsT3VRWW02K1pOVzcxa25DZXA1eTNpbzNhNllET04vLy9IcXlsU0tZRGVMT3R3aWJJWTNoc0xRcUQzTXJaMHFKUHp0b0xKSGVxeDA4K3E3azJJVVExbTJaKytyZ2NERE9IcHl1WW9vc2hMYlpuRkdDK3ozbndtTFo0aXhjeWtDa05wVWZiQjRQUGx5NTVSQlNqZnZIei9naHd1N3dWVzJldGNoUm51UjNKeElCOXlPSHB0ZTJja1BiRzcyZjAwNG9jd1Bzd25ZUmtsYkM3Y2oxNnI0TC9hMDlQNVNtREhMS3lISHYzdS8xMGVhNDc1VFp5T2NKd1RqNEE2THlCcmxEdytyMmZxaGxaSy8zSHBuZVpKQXlISDIybWtmZEhVYk5ZekxFVGFiY2JQUTdjYkJjUXZMVHJlb3QzancyUjhPTmJqeXk2cm5yUjZGZmdRUm9VbUcvRGI4VUltbnZwRlR3dDUyU3ZWV3g5T0YxbS9ubnJ1ZmN2OXlhQWtGUDYrNXdIcmw4V0tlSG85Yjd1TjV1Z055ZDJpL04xWVZoR29tZVBuTXptdnczdnhrOTdxQ2pzUWFTYnc0Y0lkWmk5WHZjYTdLa2puUFVpalpoWEdsN3BFM1NlM0FlYUNPdXQwTld0UVFYOVd6ejU3S2xzVk1ZQlhxMjFpS283eGZybVZJbTkzWjBxNWd2VVRSRFVXSW1GL0pkeWFwYTFmend3NHRrcFd1a0FLOEVXdkpnbmp4NjBweEUyWXhnd3AyQ0dxSHVsTWhWZ0VHM0JqV0hUWGVqUzM2VGQ5MVFjVnZUYmhEVGRSM0txVGZoT3ExenprK0tkSXJDUmVVbEVtdjlMTUFqdGNReDlYZktCVk10b0tUdU9rV3hYQ2NSblZIZXZLbFhWZ29WU2w2ZSswM3JhcTdhMlF5ZWRpN2FQNHlhSk5veTRSZDJsNndKQnZxZGIvNW9aMlB5My83VGIwSThGVUtmRmZVb2NuUFdob2xLVFVPL0xzTzNQa05wNDd0M0g3VkFLU29nTjRrbmFFdHRzTzNKSjBNUmVCaWNpUUg0TG5GU0h5UTVLck9sVFZ4RVpPOWQ3bzZUY2k2RGg3ZTErYmhOV1ZXN2tvYXVUQUdYUWdWZkV2WXNleGJxazBlZlRVNi9xaTNLdTVCQ1hKT2swTk1rOEcyTHRIbDNmdks3MzMwMStmekxUOXBFeUV5RWZMa2cyVElKYzBOSk5kSGdMMFU2aVBlRVJiaFZieTdScVE4VjArS3ZsbTd5OWR0Z2ZQclZDcnJYczBqYlJUWnVpMlllVkZhQTIrUHVTQ09RWUtvUi8zRUNlNUtBeWxhcGpMdElaYy9VWXJYTVk0TWZ2RCtlZlAvMVR3bkxaUExGcDM4NytDNWxSWnJJWGVmK2NCYzNtay9wSkU0amNvQm1LajlGR3Y5UTlNWmNRMG50LzZHb3puTEIyc0hkS1JlclRTSHhWSHNXaUEvNm10YitUUkdsQm5VRUM1ZW1uT204alovWmJGeTVNMW5GNDJUanFvM2lTQ2VKajNpbkJDTFExZHFGNk5hRDhoKzVNNy83bWJJQzNmRld3ODNyL29obHZCZVVoYngxdWhCRkFpMzVHZ2kwKzNJUmNHQmtnNXNxNnhuM1FYSHBrVVJSdlE4Qm5QVStTb0FPM1NuMHphM2hya2lUd1JuaHBOUVVRb0VqaHlzRnl5QkphcDI2bnlrVHlqSVoyTGtmVDVYU2dONVFDVTN4VUlBZmNzWE42eWNsTEw4L0RLMlYraUNmNnZuelY3Mi9zcHo0b2ZPOEN0RlRKU2xJNytQa1pUc2llODlSWTQxWmI2ZnI3clBRMzkzdm9DZ2FSYVU5TjljdFlXdmZoWko2Um1kVjRuZUhiRGRIb3V5NHVvMUtla1ovK294aCtISVlyc3gyK1gyNWVVVWhWMUoyVDBwVjJHcHNzMTBQSVo1SnphQTRUdXQ5bmsxakNVRkxjaDA1ajdtUXVzVnlGWkhwOTdjN0N4SEgyaGZYaXdHWjdvTm1NaG5EbzZxcFpCQkZ0bHV0eGlhZmI1cE16RFdPUGVpeG9ObiszUE9OalA3a0czb2FWU1FwYi8yL0dKVDU3cy9kZlBueVErTlQxZENSZEk5d25TbkNubThwSXhKOTMzc0tBRGFIV0tTa3RkZjY2cjBaY0QySGFsS21jREdoQTcvUGl3UjkyTzhnenF3R2wweEU2bmUvN1F5eElscm5SMi9MdlVLZ2wrelZkVnhLdzduMXRZZVRwMS8rSmt1VEVzbXlxRnZpVHJEQ29pbmVxRWkxWmNpeVRTTkhsTU9CWm44dGpvaVJTQnFFeElxZWY4QjExSTZsUmI3WVR5aktZbHVNbDVySkJVclZwZ3hLc216Q1djZU5vTlRHNzJ1WVZsSWUrQTZXLy9IN3Z5VFlrOG16cng1Tm5uM1dPWHVSZWdMLzUvblRWeVYzemtTNFdSaGZIOTFBM3dtMkRTbnoyWmgxUWIwc0hXTXUrRzV5S1JhYmNmbitUdGVyYktNRTB1Vk9Xa2FjcjFUak9OK3B2cWRaTDY2UG84d2x6YkppTitBNFY0c3lDRkhjUk9hZTFyanRUUTBIZjM3eEl0ZFBaZnhPY0Q3b1hpS2tWQWI4UitMUi9EZVhiY1RVVHd2UFhTNTAzbHJOTmEvWGNXM21jZVE2R1ZIU2c2QWtlelljSlllL0dzUitjNHVrOXhwQk8rdnYzaXVqSFdwaVFFYi9wcENsZkRXYmNGQUZLUU1JQUhHN2xnS3o1cFFFOUtNY1J2ZFMzOG1PVkFpNVRRSUNMRENsSmVlS082RXVUb0h1aUM2YSs5N3JpNEx5bnFtQ2tlRU1BU0Q0UTMwVWNUS2xoYlBvcDl3bmZKM3hVQW8zaHhCeEFaUmM3Y1dGTm1YM29CeDFJUjBjU0drSnJrMitScnVVZFBKQW1ZM2p1SUFSUHM5cDRMMWx0RVBXTWZTNFVoS0dZTFhEZ1pVaE9TeUNnanlzRHhRZUNnV2lrKzJEblk1U1MxNGNkSEYxVTY1VHJucmFhS0FmWndoYWI1d1dHbjFEV2dBUEkzbnExOXovRkdKL1FXK0lycWxmWlV6a2FkbmtEbDJWMktxczVqUnFReEwzdlU3MGtlWC92dVlBZDFOV2YvOXZmajNJNlZabnlNYjdjcGhPamdTQ01yWjVQMGZKcHBZNW0rTjA4Z2ljRHJhUUwyYU5CVmt1enZjekVMbCs3V2trZTZHV2NzSkNmOG15L2F1a2h2SVIyVjdNYUkwR2ZVQk00NXBQbWE3bkJWQkV3STZ6Q24yT3U4bGJZOWludFk5V21KeFlwNmFuNnluNUdrRzBqUHFyME5UcmQyOG5uMy8rT0g1dGRwU21JWmtEd28yeGVTZ05DMDBCWVpLTCtjMGlGbXU1Z3ExRmdzYWl0WEp0NWp2Vnd4M1VCb1k3b0RVdS9YTjA4SFp5ZHpIdEhicTY3bUZsQUkrb1NDRitOWFFMV1VjbEpXY05YcDhlYXlPUFNhZEJDT1lrd1lLd2JEM1dzUDFTL1JGQjd5RTlSSCsva0REWnhnRVY1NXVJTjNFSWg2LzNKdnQxYjNET3UzN1gxMjIycFpUQlFrSzFzaW82MktrdWplVkdXVU5FblVqRTVkV0hqcXk2TTNuNnlmMEVOVUl2a3RXTXpTNG1KazIrdEFtV0J3ZGp3N01teUVNV21jSkNzdnRTcnljcWlGc1RLU1RjeVBlOStJM0wwam5XYWtTNFVlT3laUnVpUlNUUTF5bmFpM3FHVTRDRU1EMVgvV1RLRUNuYW5PamFjRnVEdHNzejJieWJIVmI2OTVQLzlYLzV2eHYzZjU3OHgvK1l0WnVidHVaZEx3RjFPdmNwUFdWSzBFcGpHeUh2MXNXNWpxZmRZNXI0bWRqR1dYSGdLS0hzSko3V2IyT3pRaWVqSG94Q3BpdUMyUXpPRFdYV0dDOGpOdzlUaEpDWUU0S2hKRGxNZldzTU9LcWVvN1dqZEFhcFRybDFqZEc3djUraHErdWlQUkFsaGFUT3ozeHk1NlpvSnJlczkxMHZsWmphYXlKNW9rRG1TSlk2QlVwaGVyOTZRb1c0cXY0aEh3SitGV2w3MmhyalBYdWtNYTlyalVkYUFsUzJsZ0pYQmpLZXVOZFZXclNEQnFyYVl3QVNla25JZDlvQjR6NVorNnRTY2s2UFV4eVVWbU1RbmQxNXVEbTV0MTFPMy9QeXJncTNiNmI0VGpLRTZBN0pwbTYvRllWQnFUaGgrOVdyMm9WSFlZemt5eERoeTkzWFk5TnlnNlNxQ0RRZHBYUkVPUFdwZ2lhNVZwVHVpUnlObm51NHhwQkpQOXN6eTExWDFZRWlZbU9FTWxaRFdvK3I3RkFhZGZGd0szcmozdVRoenQza3JlQkJ4b054ZXZYeVZiOTNOSHhIM3psU1hnUjN2VEdKK2treE1lOXFCNk8vMnBoT2FDb2cwdnplbHZZd004ZWdMa3crL1dKN3VIOWp6cnZtT0JRbUY5SFlidkZtS1d1SzV6YUZzS0xKWDFUQ1htUGtsa05lbE5ub3l0Q2U2dW42VEJMWVovdkl1QzRlYTFRaHRMMU9jbmtGZENTYzMweGVobHFkRlFEbEYvam9Qa01aZHBIelpPUTZLbWFwdVp2ZktETmJZLzdiRm5ncHdWREJmbEVkb2J3aVNrY1JNNndWemg0QUFFQUFTVVJCVkxkUUIwM1dpL3NqbER2WHphNUxWSE15ekdiUWQ2VnMycG1zUW1KYXZWenY3WWFyS1VLVjhqUTFoVFZLWUxyK0tOcnQ3NndUZDJHVWtmUTdJbFdDcHQ3dnQrMG1TbXZsMCtEaXpNUEp2NzcvMCtTdi8vcTJCWWQ4dWthYmt2RGFjSWhiWkNpaFVJdzlVM2VJejc1NGtzdVdUNXdDUFU5Z21EWC9JYURsNkp5WDJxQkhGMTVzdUlHOWc0OThuVlkzMWN0RjZRUUVIUHZsbWViU3hEcENiaFZwOGRxSG9vNWMyWXNtK0xTQUFEaTlmMW8zeXBEQnpzNnpGR25FZjFlUzVIcVJJblV0aXVhMDUzSW9BZjV0N3FvVGd1dXp2aEhoK3MvL2pmbklhdVY2ZlB2akgzdlB3ZVRac3ljSjZMUnJ3ampTbmtCM0h5MStSc2xUWTc4bzU4eTVqeUpoQ0dnY0VOZlBmOU91b1Qxdm41SHJoTVMzMFNBcUJkekdoR3lmeTBVaElHT0RtOU4rTmllZUwyTThSVm45RlRKVWpUQ1VZWUt1T3NLMWJVSzFaVklZS0p1bWVDQVcvQkJVdHRlQkFwUWNXUmpHQWRUditoUVB4UWh4KzFWSUhHRStGRkJkUS92UU9KREErMng4WEZJL0Rya1pCckhCVVlaT0dlZXVtSHVicFYyVFMxMjZUYzlxMDFENmtKLzc2TzNrcEJySThWM0p1WTc4TXY3RFNIRzF0RmR4TFllaHRsZXYzcWNNYzFseUU1SHlGTUh1Ymtid2NWMTRLOFdSNW5QYzRTcGFTOThOUlIxeVN5RlFDY096SWFKTWg0bUE3TlRJR1FpanJIM01WWnNjaDlaa2pXYzJGamw3aWN0NFB2Vi9wL0dtTjNITG16VUQrT1RwZzU2OVU3ZUxPRytVRy9XaUZ1QkhCUXZlNXVtODMzMFgvMVNFTW1YTFIzWklTSGZ0ODhoajBWTkpuaUhveHNBZE93NHQzbjkwdnlUbHgwV3AzNmVnZDVvWDFSOFVqU2kzdXNJNHZxN25kUW1oRmJXMjlpR3k5cGZXMzlJWjFFREs2ZE13SVFzNXVWYTZ4MXoyR05DL09sdlV5RURkUGQ4b1RHOE9LQytIckZCY3JPRTR0RG12YVcrdktvS1U2ZDRIRlRkVkVKU0ZzSkhSOTM3Y0srckcvZWZ2VmIxOVVITGpKMDhiZUpPb2xPUjFwUHFIMTRVNmNVUkYzTTRxUGRoOUZRTDU2ck9SeHJYcUF2TkJ6NW1LWVVNQjg3V2J1UXdWWE5kT3hrbXRGbmlsaGVPR25GVGlnTnR2M1hwNFdidzJDekl1eXh0cXdmbklucGNFS1hseHBkY3EyR3ZEOWtESjdOSjg2Uk1kRlBESlJXMHBWdDVOZnZqcnl5S0tiWVEwT3RRQ1Fad2Q2TTJVc05ZeDR1SER1NU9kSjQ4bXA0VjFLVlRSdmVJOXVXYk5qN2F6Q08wczUwaVhhSzV4TWphSlVEUjNpMi92d01yRWhUOVlZbHh1YUJOdDBrWjR2TTgrdXZkNGNoR3ZzZi82WkRRbk93c3ByUmI1Y0liaXZmdDNlcllRWmM4S1MxTE9VS3ZUVkdZUy90T0U2UFFFcjBTeDlKeFpKL1ZkR3gwVWkxRDk2ZXMvUlJpL25IenlaZEdrT2xJbVJpSFd4dFo4aWZHb1A3UXVrSTIwalNXbmtFVGMzOGFmcUhIRWZkaXdPQ0JJMFlrd1hHRzgxT2lzMmpwd0h5RWJVUm9LNENhRlBqdFQ1SzdmbFFwbExoS2szRnRLWUFoV0tDeEI1bHIxUTkvYmhOWXlaUXFxTXpvNkZiQ0VZRHRyYnd3ZmlrSkpCRlNVN2VCZFBlMGhxSkdFU2lENjI3UjlTdk1jaW1zbnRLbDAyZFJTQkFMbENvZ2NoNGE3dmpaR1hBNW8yRmlrT0F4RkJuVzNYQXM5Zys2WnZiMUFUcjJxY2pVKzdMN05kWHN3MGhORUNFVzJXdjFjc3FpTnhyUVFDbW5ZZmVYSzVzN2Z4b251RjFtK1RXQldjL1VQNm1kMm50eXNsbE8yWG1yQ2ZQSWp1amNYcHplYllaOU5LZU9DcnM2bnlMZEhUSEdGUERQa3hrbk95NXdlNDllV1dkbEs4ZGRrSVpYV1JzNHZDMUVsTDZnVEEyL0ZiMnZUOUdpSE1VTnlyMHcrZTFhcjZSVGk1ZUdyeHBNeTJxL2haY3J3enNyalVQVmhQRldkSkpaUEczZkJoNUpTZDdaYXk5Wm0ycWl2dWJzNHl0UDRaQ2dOU2dscVZNNjJzdlNiakpVektiZEdBVExrRDlYc3hhRUdabE1XNmRUUXoyWDNXTTRBSDFTVDZlRFpsbmFzczdWNjh1QloxUnVWaXFYZ1Q1S0o2eWJBUHQ2ckdTWHZ6SVdTbmhTbFFNY1VsZDhHZGhMTi9oU2FDbVhLQzdzdTBadGlmLzMyUEc0ckdxaHBQVDFyckUvakx0TU5ERCtyTmo5dHRqVXplVnRPbFFTdTZ6WU5YM1VwTGtXdkxGRkRtd0NSK0RyNGU3Y1NGODN5cnVOcitQV0wvZlBRaXBXMVBnVXJyeElheWFSSVJNb0w5Mk9FU01yWnppYmo4aEZxMW5rdXdSTnV2Mm1FUzIxZzF1RTZDTzZnQjFwWUtjNWMrVEgzQ3dkZm5hK1ZkQmE4YnZFSWc0aUtUYWtVWURabFJSalZING9FM2JRWnBnUm1RcFlTMUl0OG1sc0dBU0JCdGJtSkFBLzFRRDYwUGw5SjVuMFNQZVdDVWpRNmtrckI0TW9XUkluM2FRSDZ2blgzUWVrR3J5WS9mdnR5SUF2aHR2dTVoc2NGQ3Q2MVNlVHEyR3hjS1pIRm94UWNLM1BjczBVNXQ0Z0paOExyYU83YitLem4zNzBZNFhZVjh2ZDJPdSt4c0RLQkdZMzdVdkxPVC9RUnJ0MUY1UkVYS1hUWDV0SnlOVzEyLzBaeWFCOWtMUHA0Z2dEWkpuMXRCb2FDKzRVckdzR0RCQStISXdIUlErTlBvQnpCRWlnS053R1pqSnltWG5FU3pteTdHLy9RRWs0M28zdGxwTWJyeVlCQjIzaEMwanU5THNLalYxYVQyL0NNcGZsTXhnWkI3Lzc5eGJ6SXRZTytjSjdtZWlDdmxCdkY1WnBlYTNESlJKRzhnWkI2dmMzOXZsUVFTTnc4SU5zcFE2UXVWOXh6M04rNkg1S29hd0xDUFZraFV5ZTVpSHJpMzgyQ2MzSE9tazlqazlhaU1vT0NWTlQ4WXdtakVpeVBUaUZVNDFxYy9QRFRUejE3TkFENm93VlJlNmpob0ZTWCtmYkUrNktrK0tHMTZBb2JyY0huc1VpK25PNFIxbTh4dWVnSmUxOGdvUFdlYlkrdHhoZEtFTlpGWWJYRXlYdU8ydW1lWjBYWFR3NWVEOFFrVjBtMzJ2ajF3YTN0djN2Wm5ycWNQTzdZZUVtNjUvY3VKcDkvL2tYN1VPdHNCNXZXUDE1YXpPNnJ5YWNCa21sandOSXlHcHVxaTdNUW9ybW4rSC80OXJ1UjFRODVxYWxjcWtiV2M0YXZrMTBGM1ozZUhMQnBhZ2VZV01nVGNGREdaQ1pPai9acDdjMmgra0FubXVNWEpkQXlVQ0xDRHJQRnllcmtvcFRucHBKQVg0TmY3Ty9tbmt3QU45b0l2WDJ6SHhvOW1YeFdMekt3TFFrZUZNZjhtN2Z2UmkyYlBKNTdXU1VFMTZ4TXg4Wnd6Wi9zQzJGNEVxei82emZmVEg3MXliMlI1SGs5bjd2UTNwWnJjNVRsR0kzeDhDTzlhT0NzcWpiRU5nZHJ3b0xJVWhlK1JuaXJCMU1iNTc0ZTJBSXU5ejRiNWdJYXVXaVRSbllmMVFYaDZ6OStYeFgzYm4yeE9ncnFLS3VjSXZHZ09UT2h0UDRGZFZPaElTRHBGTUh1aU1mNUd2ZGRReHNoS3diME5JV2sxY3h3RERNUlR0UXhOcTFIS0NzTGgrUjBJTUhnZUhwMEtSdmNZY3JCZnJFZkYxTWNGSmJTRS83MlVRZHNuSFRFMk5zM0RqWG9HTFNLTmpNYklTM24xRlg5bm1KVS9MMHcxeHhHZXE0c1ZxRmV2ZUZabngwNVhia2gvL292LzdXczM0alBsT3FqaDIzMG5aMlFhOGlwWnlEY2wwVVdLZmVtcm5tYUdnRURHaDB4ZXFaUmt0UEdaaHkwVGNFL3NIN2pDM3lRMFp1U2FjcDZoZ3dIcFpEaVkvM2JaZ05WeWNMT1V2VnNGSWNaODlVY3R6N1dreEs0eWZYQnI3aUdUVTBZdVFQVEhsWkZ5dUpMS0ZIUlFEbDVYSFdOODJ6b3hXUnJjRjU5MXIzbDV6bFMzV3YrK1hJZjF4NUMzbUNoUUs5UmF0T3M3cFJTbjNWZC9KQ2d5VWJYTlVjNURtTVRRcDhpVzVBNzE5SXpubWRRTnpiaU1ydlAvYVhTZFBJaUxndnNLTlA2L3Z2dlI1ckk4bklkYjN1K25PdGtLR1BaZmFHUStWRE9VdVR5K3c3d2hTaWxCQnlVdWtKT29Ba25OQ1BOUlk0aC9pa25hRjRyYkM0NDh6SHltc2owdkwwbjVRUkJqc1Vvc1hlK0VPMXlyWm9lVkt1TFMxNnZpOGxzU3VuNlhQMGhOejdFMkhQTzFVVVhKN21lVEVpUmNYN2svTnlqc1pFcDZ1M3RoME01N1hTT2dxanVXdGY1VU0rd2srb2ZGeGNyZjBtSlVSd0t2UUdIbDFWc3pKWDZzMTRPcE5LeXBpdnRRYWJyT3ZMdWVQSXNLb2FMOTFNS2VqYlA0UGkwcE03YzRLZWZoUHJiUC9zVmd1dGk4aTdPVHI0bE9jR1RMZmJhV1JGRWE4aWRrek5uenk4c2xHc1owUEJsWFQ5K0RhVGZubWVzcGtZcEdVMSs3Y3RwNi9iZTJlVDVHNjlxL2xWaDRpZFBueFdaS2hHdVVPSnhKS1FERE44VytlZ3pMVzZLS1lzbXBQMGgvL3REZzFvVlZjbXZaYkhWYXptbFpSUmxkdFBaWHF1VlZSdkxKa2toSkpnMjdFd1hhOStOQlR2UEd2Snh3VlAxYml3NFFVelg5M09vNGFqQjk1QnpWeDBJOEdwMzhwLy9yLyszVlA1cDlmZnhUWnM5MUFNRHNMRlFWRHFsalZRVHNhcktOOWZqSE9Ld1pITGJkemJwUlRrMUZ6SjJ6MU9pZmNhREh6ZTIwNnlNRGdqamhCc2NXeGNheDlCRE1uM09ObElPMEk5REtRNWxGVHJRRVhPMVpGSWxEY2hQbHQ0aGtwVHltMDVEb1l4MVRNMWJ5aFdhbHE2czE0N0hjV2NPNjNoN3RWY24xYjNHTVpuc3ZwR2huR0RtQ1g5ZXEyaWxSSGVmbEV5NmxVS0lhRlg4TFNLMjBJWVFjWE55eVNDcFU4UzM1WktKSUVvVHVBazU0RlhVb2ZYclFGaURlbS93MHdMakZOWXZ6eTRDTjl2RXNLRFNJeWh1Q0JrUEFwVk15MDI2Q00zY2wvV1I5aURSRktwdDZvY2JUWW5hNUZOU3ZTejRCTGMvTllibXVia2NtZE5lcTFVMUpJekg0cXBLSjVFOG1nUWtuRk1FUjJBL0trSUtqS0thS3F3cElqZkhIM3R2Y1F0Rm5BVWhjSDdqdmQzUHljOUtrT1I2Y1djZDBLR0hGOUpaZnBuSTYzenY1OTZMVmpvSHNkc1BKVTNaN3ZjN3Q0MHJvaVlXeDNvUy8zcFloNGJaanZ3YWJZUXB0SkNuWGJTMlhxSm1tMzU1dFkyVWpQOWNndS9yRWtvWFVoYmswMEtNemR3ODQzK3ZpMDRQQk55MGZnZ0FYT2JCS0tuNTlOUFBocUhUMHNtKzRZWUwzTnlwZVA4MFpINlQ1N1A5dEtQYkh6MHFsV0hhR1FQdkppRlhaUDlEM2c4amVYcmhaS3M2Z3hRYysvQTJualdGcFNXMTRJcDFGalU4Q0pGdWJFVFlsODV3RXIzQm9ETFcrRDRlRVZ5dU1nSHZlQml5d25VZVZiSWpGZU1rdnZTUGYvekwyUE1PMERqcWQra3ZCelV3OUhlSzdFTUdDa3JqQ1BaQzR5SVJVM0JBaVZsaktGcS9NMTljZlY5ZXArQW9KdGVaN3JyMnQwMFNnZ0I2MERqSlZyMnZDSDhMN015MW1YZFp1T0Q4YW92QkZkcFFwSmpHWEFxdDNPUS9PK1hqdkkyME5NY3YzeC9XWXJGRkd6VitYWno3Nk1LaUJ6VDRiSXQvd2dkT1FLVUdKS1c1WVQyRWUvTDkwOGpRbWNRenBMdmVXN2ZuYVd5OXRCT1M5ZElSdnZycTkvMjk4UC9yZytCODFpOVZOY2pzcG1VK2Q0WnlXbkRhamVyNGxPdEpYTnJlMndqd0h0dG1wNWh1RW03ZFFYRkMrQ3BrNkZGQ3J0c2hoUUdNNVEyVW9lOGZ0N2pjbzZ6enlEK3FRRng3bGRXS2o5Y0xFYTkzcjdtc0VrNUYvTU80MXhmcjR0bW91QmdYcFdvZ0xnbWR5S0ZPRGxjWmdzWGNyNU1tMjdtS3FlcXNlSWRsM08rNlBmTnlsdk96ejU5MXNFZWNYWlh5SlgzVkl3bXl5enExdU5DVGhMdHUxOWhLOEJYMFNObkxUdStINGVKeGgwUmdtczcrRWYzdTNkOHBBNkYvSEtWbys1SVRpWVB0VUFBeWs2RGlpODV2NHB6U3NxdFo4QkgxU1dHTlpOK3V0ZGcvQkRxbFF5NHdNYnBaUU1RWjdqYjkxRzJqTU9WK2FVNDRrOHROK1NpQVZVbzBMR3ZYR2VSNmM1RjJIRWJsbzhVMVZueWlMKzRCUlRnYUNMYUdua0VyYU8vaDVrSlAxa1pPa2Rka3B2dk02SEFReXFOcWpaY2J1MTVFK2QzYk43MVBNdTVCR3pTT0pPVjE3MjVaNEJYaU9uMFluNmQ5TjZWNG5JSTZPdFIrT242cHJIYWRhZmRUSEtnTnZhdDBKWlh1OENHU1dNb081YXN0MEZxdTVaM1dhUzBleWJtU1p2aXljVHZxalR0NVdpQmxxOEpzS09tOFRpTmZScWFydGJzdEwvQTBmdWlnUUFGZ2ZLZWNwSjJkOVZCWFovWE5iMmN3MmgrdDI4YzYwZm5raFNMZ0t2cCttMktGY3E4cThGNlovNlNqOFdvbFE0WkRiY2gwdFh2N3c1MUR5aitJQzU3V2QrNld1clM0WE8rdnhydldublpjMm1uQnRoY3YzK2NoNkp6UXZCVm8wSXRlU29SSTZPRDlrajl1MzNKUndvWDJ5VW5lQlZtRFFQV25iL2xUK3NHUDNnT0pZaVFZR1gyNUFCRmY2azhaUW0yaktUQXlJR0JDa1YxbExLQTZYb0pjUVRyckpscUgxNVlCMkJwdXplNjd5a2l5UHFkNG5UNjRsaFptemMvN045ZEMrUzdMMnBGY2w2WDYyK1Nid1VsdFM3aHd0d21hY1ByZTNwc2taYjVreDlwMnRGQU9QcjB1WS8wd2diSVlLeUUydVZKOGI5WGFsTmhKR3ZteVA2cnZPOGw5bVcxQ1ppTXFaeUx1TjJxUTkzZi8rRVZIaHIyZnZQL2YvdmNJeDZJL1EwMGs3eGFyaHljWU15bWpxOWR2bXlDNnNQQjZSRHRYRTM5RWNjbm1Qazd4aW9qTkoyQW5DZWE3SWlaTkZWdlFKbmJHWXE1RHgycHZ4aUdzcDR4VTI2OW1MV2RtaTRhbElOVDA0ZURtRWpqVkFBdWxTNXdWYlJRNVhjaDFtRzlUTG1pQTFpQWUxQUoyN01ibVpDa0NXK0YzUCthbWd0Y3AvaERaS0RodWpoWkRLYkt1TjBwR3ZGMHBCK3BlUEZPZEtDNXpGNXdIMkdTM1dGQnRsNFNHV2x6MWdUWnNxejJRdzBCTUNjTnM1cFNTR0ljVnBLUWdqYUc4b05vc2xlUk0zVEJTNGMxOTJ6cjVHVnhpUC91ZE1xRWNGdHRJbEljeFEwRmVnOVNjVlVjNG9XdkpyS0svRUdlTFBGSktDQ0UrQ2JxQlRwMU9mVnV0V3pmcFd2RnVLU0d0b3lrWEtJRUxPcmlMOGZ2VVJSd0t0dXV4dnBRUnJwVEE2OVhXbThkWWpIdVU4RFFXTFlRdkw3aTY1d1V3MnN6ZGR6eGJnemNYcm1lRFFOTnpQZE5aU0ZUZ1FDZk52WGN2aWw3ZUg0Y0RYOGVoUG4zeXE4bkJYNzRkbS9QeGswK2J4K1ZxL1hhN1RuTGd1bDJQeDRDTFdZNk01MUtMbE8zM1R3OHk5WU1MdVh5MzdhTlJWTnhlZXB1eWRQYm52TFVzYmVmWjQwOHl0Qm5VeVBXalNvYVV4ZHlrS0picS9QSHBwNTlNUG9zZ2w4cXdoY2ZzRGhlaFJFR0MwNUtxSVJrWis5QWtwR2p1K1NiWGwzV2pTT3Jmdi9zaFh1OWQyZUx2YzhQWWhJQ0E2ZSsvaHlXWU1uWm5LVTdSOGNJNWc2ZWVXMHlaOUR3STludjNVcGJlcDg5Yjg3VmN4dno5N2NlVGw2RkhmQllrZVZWaytRelE2Qm84TEUzNGp0cExqcUd2UFVuS1RUU0xHeWo2Mi9zYXdPZ3pqeTl0L1h5TjlVQWQ5UHZITmZKZWN6eGtwZXVLUWtyY3BtUHdwZ3NDUWZzSEpXZWwrU2FWeVh4NEh3THBSSnFMb2s0T3p6UVlDWlM5dlV6dm83UjNXZDlwMnRNVXpueWExSWtmYTIzK1JEeXRtSHVWVzdsWXFINm03Z2xhUmR6VXN1T21oTS9UM2llVi96YWlyVXVNTklkMzVWZUp5SG5mUjFKT09nTmYrRGFZZWxzUzRNeFMzRmhjMmRzNk1mejEyNDRESzhrc2xtd29LYXJLdzRHUkp1ZmN4RkJJYVI4cEFMRmdMVFYza1h2WWZtcXlSODFUU3RMRVg0UUFyMXR3a0JmWkREbmRqZlFFMFZmaXR3SXJCWGNTempWOGtQYzFtWkdleStXcUxkZnlCWEhQeDFWZHpqbkZOeEFjNzJrYmg0QnkxWnBzQ1pTTCtaY1dUYkdvQTJjMVdKdE5LYTZVT1ova3BFVDdmTzlaNERyVkcrd3FBWXFLRzhoVFJBOTM0UzVjdFJGc2FMNjFhVmFlY1pOUVVUSmpMbm8waUpLTE40anpsT0ZRTE0wckMrYjBIMjQ0STZlSGt5NldRczlrU05IcVpRSzBWcW1QTDNsUXBwWXc0WE5ZMHQ3Wm9McUh1ZTQ5VUppVFo5emI3d1RPeFl5SG16YnluZnJEZUwxM1dDdVo3dEltcGttaC9jeDhqcjlObGFMN0VXS1cxajg4RlpUbm54UVBKRExrSk5wTTZReDBoVjlyYnB4WXpSV1ZJL2RnNStGUW1zTDdIK0pCRWV3cU5xUzRRQ3dMNWRaZFJlQ1BQTGtnNGxiSVk3ZCtXTHNkYXlmU3VMUHpSUThQUmVYK1pVamRVLy95a1FLUjBYWllpa05lSVZVSzZUUmxwWmFSMUUyRENKVWtsUmdNZmMvazBsM0dUejRvS0xOZFZQN2lyQzRjNVVBdFo2UTJhL1c5MDNrRWQ2c2hYUXZCUDlqdTVPUHl6MTc4K0YxRU82VVdjaW9IN0ZUamdXUkZRdXhsUE9wbFRSNlhNcEpuWmQwZjl6N0lWek9BTjBYNElkT2R1TlROQ0h4cnk4VlRUbk5Sd0NjemtRSFFrRzkyOGlRNWtGYWdLSDgxeENvVjUyMnVvQTRTYndJdzBsVHV4NDF0aGtSM09rRjdOM2QzY0hYSjBIazZRRm1SRGhiYXhleVdsc0RGeEMvUEZYeWcxQ0J2ZEZHTzNwQWxjMGhXeUFaZWswd09oVVptRFBRWEdlSVMvdkpyenlLUEw1MlN2RnVIK1crL2V4UDBSRGh1SkJUZ2JadXpjQzIrUlI2RzZKcmtzM0hXWGcvOCtrMFp4MTk5bGFLS3ZMdUkzQXhoWEpqTUVOaENwTjFWVnVDczZNRjVEMzNlb0FJeUtkMnpoTWk1Y2JsR1diR0xySS9jckp0YTdwbzREMGJ3b0FKSm9RNTB1RXlaWERZWnB3M3lRL0R5T0VHY24wMGdDanRQWWFYM0RwVTBsT0JNaXpnaWFRbU1uQ01LYXVUaHRKQWlmV25DNEdRRWR0Y1AwSTJFeThzRTN0WVQ1WFJxeDJxbEpoVFV6RnpxTGgwK2wzV1pyWTlRMjZxWmJ4S3g4Zml4TkFqRk9Cc0trL3ZrdWpwenpxZm9SdFN5dkpLcGd1bGp2ZSs4YUEva0krSjNOYzluejFxa3lLQUxtZlNpajlYU1ZBYlRQWElGYjFOZU41QlJ5bHVDcHhDNUJiUjV1YUUyaFkrZ295bUgwU3FsM3oveUl4U0pFREVSdUFwTnJPUWV1SGR2N0RFOFRWZm9XZ1NuUlUrQmRKMytuYmM1UkgxMXNEaHRrOGt3WHkraUZFaVlYcXRyZWo2WDZoSnRnR2tIVkdzMzVjbGFnLzdlSXczWGxQTDRhRFVIV2d0WjRZcGthMU9rUzMzT2xUMlg5M2tQRjQ5UytDakE0d1NuRU1XSVJIdGY0NVgwT3c2dTlVaGR3MmNob0dINDR0cEUrS0F6WFVmbFdkMjJnWEVyM0xpRFhQT1Y1aE9hM3oxNk45Q1NlWU91N3VSVlVGcTNHZEd1UEZvS3YraTh2Y1BxQ1JuMmhZVmFzVFFmMmZMUmlnbnh6Nmpya2tEeHkzZEtuSlBSS1Rla0sreFJpY1FQYzYzdUZMaGl5QUxUUmI0UE9pYnYzdVEzdi82aUtIRVJ1V1NCNjhab0hPV3lIbGVuK3VMNUQwT21Sb2ZTME0rZE9DT2JkNkgxY1RqSjh3NW00VXQ0N252M096aWoydFh0aDA1OGpsN0lpN0gybE5odUVXc1ovcFNEZ25BbE5aNEIyYjdmZm53UWVrSnl5OExYcGNSeGZwU01QRVE1VjA1MC92T2Z2eDhlQ3U1THJ1QkorNUZMS0toRWxuUlNPYW1sRTdyb2ZYdGZ0MVdLVEFDT1M2amk0L2FtOXNsanJhMzNGR3dBQW42MlZoU1pkU1JUNkE5eTVFdHdpNGZnV1NpeStlZlAzemI1dFNpdDZSd052MTRoSjM5MnBlTzZiY0lNMTRDUnkxbUFzNzFPYVU3NWdOYXF0Ry83ZmhPUHBSNGRXVDJUNnpmWEExMm5qS1FtN05Xcy95UUMvVVArK3BzM0ZWR212UHB6QTJqVHpWWXNHZ0pyNnplc0NQRUVNV2FoclFnZEtZZE04YlVsMFp2WGFZOHJmZHB6SHhkU2hEN1JNelJWWGF6dmVzRTc5TlMvcWJYdkhSNDR3YUhjdk5jRHl3T3hrT2ROMG5XNzBPYjEzOWdzYmRDMFNzcG5VUG1KUWdJZlNYcGRmbzF1bVk1SkgxeENiaGloeEkzWVJFblo0R3Q2OURZcUZOUGtsbVNLNzlEVUVGbllEVnE0bEUvM0JORUpXYStrT0NtT05ydGtWNExjNTN1NVorMmExbXNzVWhzMFBla1ovRy8wditxZUk2azNaU1kveTRpMXdmRjM2UVNpaEtPZlYvY1NoY1VGbkxQeVRveHBQTExNZS9SUUlISGptcVZBM1NURm9JSGpZbklBempkcHJSZkZFcHBMMktlTjIvcDgxMWNvdTE1eTV6UWFOSjEzRzQ0aUdqd1dRY3dkdEI2TGVNbWVHQ2MwRkd6WEphVG0zcHhBWGdRWE42WGV6elg5ZmFDMHRLT0VVWDNsUlI5WmFVZlI0NnA2K3JGMjF0WjlsSmZNbDR1RjYvbFFJdWk0ZjBJdWNaVHhrb3gzSXl1N2VaYVZmOVg3SGNrKytKOEw3bFdoL0NKR1VsQ096bkt0a25WUlFYS3p1dHE5ZWo3ekp1R1d6RUMzVUVhM3o2MHNFSk9jckZSaktpdGU1NDNGQi9kQ3gwV0RXKytscUE1SHBkMHArcnQxUi8wZVYvMnFDUDJMNWw4T3FRZzYxMVlyY29UMzhlU0x6em85dmV4NDR6eUoyUDVyQjEzY3JhYlh5ZW5hdW56K3hTY3QwVFI1RmhyZHF1eUdJZndRNzZUVGd0ZEdSRGdab0RRb3BMVmN5cUU4RzlQOVVwY2M1NllZWE1lRzFWelF2ZDBTYU9QaVBQZEpVZFQzSlhMZWxDTWxEZWtneE1oYjBrMlYzR3BlZU54NzBVVDJzZDl4V0xxaTRKVmJ3TGpqZ0VVbzJ0cVJhZXRzWGMyZk5hT01wZ3FNK1A2eWYxc3pjdVJydE4zbUNRdzBuU3pmdHNEN0pWNGVuNGFXUkoxQ0tzNWQrOXUvZlpyZ3h2ZDBqdHJwQVl2ZXhlYnpYN2toclJEWXUxNTQySWE5YXREbmhmZkI0L21yVUZBNytsTEJjb2pOWWk1bWNuVjJTUDFsbmR2TUlhV2J1akZReEJjOWVCZ2hCUkZuaytyalVLSEdKU0Q0THBJRXhuYjNoajlWT0FUZGRibGNyTEhTbTNSTlNDWHlmR2l6SHI1M200QU1WMStoRnJPVllrUGMvWCsxM2RtT1psZVcyUGN2NXNqSWVTYUxRMVYxcVNWWUhtUkFnQzhFM3hxd0RmaktMNlJuTWd3WXZqRDhBSWJVRFVIZDd1b2F5U0taWk00WlkyWmtSS1QvdjNYeVkxSHRidmpLSnhuOHBqUHN2ZmFhcDcwVjh1N2xTSjNNZG5CQmFKbTB1Q2ttc3huU01sMUZjZXgrc1ZQd1lJQWFnOUFSOVNwdGFUdkNVYW9RKzhHUGtqeGQzL001cEpVb2pEK0k2VUdhOXpzcFRyT3dLUUFuN0RDckFEQTc4bmJlQjR5czMxVHV0OElSYmErTm9iVWJRbHRtRk5QcCtRcHU0M0ZwUVBtNnJFeEl3THh6anUvY2F5T0pPZWFtQ0JVRzJDdDQ2TFUwSFJuTTJkeTdWdlJQeUYvUGVyc2VuNzlOSWdaYit6OUtWTVZ6T2ViTms3YWwxUWtOUlRPN1FOdHE5R1hQeDNoSVJKRTY4TitpNVgzVWltYXhyV1BDeW5VZlVqMzUxMGJqNjhZWXNmR0xoSHExdng2dHd3S0c4aUZ1K0dFQWpXUHEwaHI3UkR1YjA1Z05NYVZweE5lNjBDYTBhS2FOL1ZBQzlHZWZmdDc5Ylk3eGNzWWx0OGttdFBmdlBteDhPYStMZ2lGY1BiQzA4YjVUOU8xTmxvSTBnMnRsbWgvcC9Kb2syUXdQUkdpdGsvMzJCaDR4Vk4wNjlxdWZmQmZNN1FnRE4yVzlIeFNzdVgyblRyMVZnUkFvMnJ3OHpKcDUzdGIxNzlOSXJ1VUxKYnhPYzdqYkhrdlU5bmI1Vk5leVh1N2VTM3hIajk4Ly83NTVTSWorTkdaVkVtVTdnai9LTGFFZytrYUJzY2xuYkZGMFBLRlp2cTdtMGk0KzE2N2xZKzVlZSs4dzBQZTFKZjVsL2pGbU1NR1F1Wm9QOVdWTzk2Y3YzcForY1pncFdCckZkdnVBeHV5bUcwTTFnOXJuSE1WSWQ0cHdiMGI3MzVXSFNhTTh5bWN0ZDFIZTJhbXVEcTBsMFVmN1V1SVVza1ZMVVhWcjVjQTAwZHFTUkN3WVI4VENiVmYxajhEcU16d2FkUGY1STdJUlZBUXVWOFpFeURVVzI4cFc1MkI3bjRsMlVickNTWlhVbk1sMzRzby95eGR3TStBY1RtZkdtdGxaOGhaTSs1Q05BTEVYd3p1S2MxL1dQZUhkVWVaUkE2dnlwR2hNMFp1MEluNkdreVk0bnYrdTN0bSttWG9aeCthN0doWVc4elBaL2pDcFdFNEUxbXVMb01aclFkcUlZd2lUUnNLTEJhVWppQmpRZmdTdU5yRG04djBtUE8rNjd0WkpuWTBlRnpEa3M5SkRTOEUwZ081NmJSRmszVzdHYUE1Q0Z2NjBkNm5KSWpmN0lSTFRlQzhuT1poMHk1QzZzV0VZQVpPWjEyVEc5S0g2U29ZVUtWTmZoc1dpYkR1UUtBWlhGb0hoY1pKRzV6MFRFZmE1aGRpaUxXVmlqcThwZ3ZDcUw3c05OaVlLMTN3Mk50Skd1cjRoNWZzSXVFVTU1YkJaN3BGUWxpUm5LRmdkbDI4emRZTE5vUXRESU9jdDVoYkpCaVdZZzVzeFZpVVdieE5BdWt6a0RDaml1QWlFelJqU3FQTXhGNW42SDdxSGVrTytyR3N4Y0VMQ245WTdHTWwyL3ExQktIc3hCcytKMm9hNEhMUU5ZYVNwdWQvSk9RdUpqV09LV1dtSWpRM2xNNDh0R3Vlc1FBY2ZsMmd6dkp4QytzYk1ZYnlSZWN0SHA0NXQycHQwQnhVRVdzMU1vbkdFeEllamtlR1VReFgxcEhsSks3akk1RVVnSlA2MWlGNGZLWmdsZWRldU4yOEs2THlSMXZCT2JXM3VqemFiT01pVTI3dGVuL0hLdUhhTFdOK3VOT3N3QnZma20rZXp4ai8vK1pjRmNHS1NqZjE2T01YeEhYZGFQYWdSNHljUDIxbXFkYmlmVDhyTzEwKysvU3JONTJuTTZUQWYwNE1ZVnkyTHdsRXRvekZibGs1WTNYdkpxRy9TSkJNSU1WcWFqeTRmcTlvZDM0NzVFZFJRYkxPYXUzdDExUlhBdVpuSlNLdFhFSCt6N1BqMHdrNmhZUitzbnJ5TVFWNThIWjFmbTlTa3N4UU1KbHg3d1JZaHZKL0plMXJEQU4wUkVteVNySVBYazVKbUtSNm5yZS9yWEQ5S3I1VG5jRFhJdmZSNlVWRTJoayt5eHArQ2dhaXVIYmZTQU1NcHVWUVhyUU9HQkJHV3BwaVlWV3ZRNzQ2aFQrVFNQLytmK2NmbkJsZDd0bFNuOFFuQ20yZ2oxd1B6Z0tqdGtnQ09NQlJtdmk0SDQrUk5wbCtJdkZFVVkyd1c5Z3BuTlZNdTRud2Z0MDdlQklpMGxmdzdlbmIzWXcrakwvazlsYkV3c0Zva29XVVpycTFBVHNnNE1xSVpEV1VaYW5kczJ2U1ZUbThDWHBOcE13WDNRcGltRXlYMUxRYkFCT3B1bVVRWTFWeHZUTVBrWE9Ib1JqT1NyZzl3aXJEUGlqeHc0R3EyaHRnUUNic2RvendKd09OUGFuejJPTnBNRTlnc0NMRkRFL0pWREE4ZllJNWNsWkNua0RsYUxscGF0NEs0eVllaWVycDJrUGdJbXFTL2pKbVA0enlBSThLK21aRVp6N1M2alRueGY5QXNhREVrcHRxeWlRYkc5T0NEQlI5enBQdE5ZYk9GN0FjT2FveUZTVWVib3NucEdMa3NjQ2diOHdTQjk1ay9uamZtV3d3ZUExMzZTTVUyZ3dPa1k3Sk5jbW9hbU16MC9iYTBXak5WT09HYWE1bHIrNWs5NXJPa0h6VG1BREFGeVoyOXprcGZNdVVoNm1KdWN0Sy9ydVpONGU2TlRCejNHKzBLQWliOE1CajM4MmN1VEU1T1daL2Z4b0QzMHNZeFhreVBjOTI4bWJwMnYxNU1ZeWFEdi9DeE1TS0c0M3hXelBCSFZVaElxWkJhb1JJRGM3VUxrUFU1eXdkRjI3cDU4M0U5ekhSeHJXNFU3aEttamZsbXdTZ2JzTzZYb21EZW5uRlVBZlQzMzFXMkZseC9PU2JaYW5XL2RKcXRtT21Vcmx6UEp4Uk8zTWFjUWJVMVV6R0NNV093VEp5N2Q2djNRM2ZSMi9nRUV3WWZjc1EvejlGOVdIM2YvUktRYitTcjRwcWhPVVcrdytEdjNTNHBOSzBNNDM2WU0veCtXZUFVZTVRamV2ajk5KzMya3cvcDFhdnVVVGVSNHpTa0YwWHQzcFZHdEJzTmZ2dk5rK1pvVjZBZllvYTF2cmxLZWFnTTVsbTc5dnorNjIvclpHdVhISUdyaFJMNU5xa0h4K0d3cnFlMFMweEhGMS9FeC95RDA0U3puZFR0cVdudHR6TWhGNzlVZUJzY0Z6b01QNk5oYTBTSWVlL3dFb2ptZTUvaEkyTHorNXdmTUFsWmlzOWw5RlVGVEIvN2c4d0c2b0VBSkd6YWg4b1RWS2p2clI1WEthN3RpZDFOcnZpcVNOVTBFd2w4dEsrclZFZFJPQlh4Sm9jSVRFTHI0M3NWK0o1bU11cXZSYTFqRG14aVdGRllDa1FnOFMrQW1FRC9FRTlENnJzbTA0QzVIM3pCUDhTUE1nREtSd1lRVENIT1hVUUUwVGRqTHBNQUZ3R3I0Wk85amdoNjB2eFRISTAvYjRqZWdGYkFhZVJwSnMwNVpOcE41ZDdQYWI1ZkZNU3VQemRqRHZ0N0lReE5iakpmeWE1TTVSQW51WkxaV0hUa1EvNlVCcXQySzB0Z3htWEpSVzNNWnB5bExlekEybmc3QXdNMld4RkFPOWRnRHBnUmJ2MGhwcXE5TWN4bnFtbUR1eG14VEdvRXM3dDFFZXFkUHVuTnpkb2gwZy9kRE53d2lJbmtMVGd4R2hXbTU1RWNsdzdYNkpJQjJkMDNsQXhXTGlnZzBwelV5bWxOTXBwUTE0NFBNTVpDaS9IZWhBa3RVcy9ZcHk2eDhTcWVOYTlCdGg3Rm40YXBZQ1JhN3JnZVVqTG5NRFQ0MlpKTnFvT2RZRERXZ1VYemxncVFlemdZR0ZldzdINlNOaEdCdkN1VDlSNWpNeWE0Ty9EcS9XYk16TTB4SG9tVm1LVzZ3RWUxUWRLVTdzMnJHaXVtWFJqbnN5SnJvbHkwSUpvaUh4bWYzVUV3VjFhanRPZGFRa2xRNGs5Zi9XR2lldzhlbGptZlQrd28vNDJ5TWQxbnJjSGpUejlOUTh1c2xtNFMweFhOM0ExWDdLakRQSlRycEt6SFppYmNDUFpSK0RZR2VQOWV1ekMxTCtpdG90UWkxVUZraE9Qald0Z3dDYWNiUlBPeVk3TFVFUGg4a2kvcGJYUndXTHJSczJGMitaYkMrYWN2YW52YzdqNkprTVlsU24xOTlmUk52cWRLak43bXFubjl0dDJuODF1OWpKbGhPai9rV0ZjbWRLT1VIam80UVcxalc4WHpvV0xXUnRwNGM3dWUyWHU5ZXNzcFpZdUowYmo0LytDemlnRFMxYndWeVhzL0FuQndxaE02ck8zNldQT2RvY0gxbDczNnZ2Ly8rRTNLTkhUNmVHVFJyQmNiSW10bGVyc0lnaVozTzBVTjB3bnk2YndMQUxXbUVNa29vZXVzRklQZi91YTcxYzRYait0RjFDNnR0VzA1VFpydHg4RzNNaTlQYWtoM1VYSHZ3VTdielJjV0ZRblVIWFNiMHpHVFNqUUpvbTBFSUVTTlNmVnBKazFMV3Q1NTdmdVFpWE14ZmFyZklTY05ESE5saXJWb2JUK21jK240ZldndVhUUjJzWXRua2dpNEJXaWh4L0hYTTkrVHhMUzBFQk9EWnI2OERTcFRYcEk1ODZIRVZFd05kWGpPVFRsWnBTSGNLcVAwZHExa3JsZWpkYVBpN0g0dFYwc0NYYWhWVFpiMkw5ZDhINUhzeGtDSGdJY0JoV3pCZnl0bU4vbE9hUlJSUmMrbm5TeUY0RXBWRUo0dHp6QW10WUg2RFcwd0IxMDg2Uk5KNFRSYnpIc1ljbEd0S1QxcTNvdVoxZnliNTNUY3BHMzFucGFHaVJNcTdqL0lFVHd4Q1FmR3Q1V0paZTJWbFRCSDU1d0VqbXpyWmZQUVpiMnMxZndHNTRMdHBDeTBsanA5dEpEZG8vVktWTkoranBQQ1dxT0F3U1M5ZHI0MUZPM2t3SWI4cWd2bS9QQ0RRS0dOZXBVZFQvdFRmak50am1PY2V1b0Q1YUtWcHBrMFRpYUQ5Wk9RYkc0MHI3MFlIRi9rNjZKc2FqSDFuQ0t3RG1KQW1QR3JWMVZ2bEU3d2l5OS90WHFibjRmbVpZMi8vYlppLzllWmNTVk9meWlwOXM2ZHp5Y0s5eXBtY3Z5c3pPMDBCZ1h0WVBLbzRuYmRTNWZPcGlXSnBvWHQ1NUo0V2JtT3NjZ3VseEI4a2wvcS9vTjdRSlBtVkg3Z1IyYjZmZHZYLy9IdFY4MlIxaVdIYlhQU0F1NCtrS2NsVXordHBVWUM5M0tnZjlLZWg1OSsrbmhvRU5PbXRVaiszUzBmNlcvLzc3OFA3NHNHTnQ2djA1eFlEaDl5Mm92ZS9mNVA1V0FWanJ4Vi95elIrSk4yVzliNzZxaVN0ZTkvZUQ2TWJEdjN3N095NGUvY2ZaRHhWQ1FaYlJZWjNDNEtyanp2cUFBSkpzOG51dG4zTmdIZS9haHBFZktUUklxQ0NTUkltYlpJYTIyWnc4OFNjRnNIL0dTSzhSZGlIUHl4aGd0VGdvR2RqaGRFRDlad2ZTeXBOZ3Z0VW5RSU5nZE5mTnVOT1JkMUI2UVZUWjVPYkFSU0lTajVTUzlmUDI5aU9RenZQVm85cTgzRzE5KytYSDEyOTlGSXYydWFlRjJXTUZiNC9IMlNaVGRucDBiNjEyTjRHem5kTDB0aGVKZk5yT0daQ05aRkNYN1U0dExNeHprYk9UVEhqd3dwVVA3SWE3Q283ak85Y3pDdWorZEU2ajh5dnZjeE1GR2phN1MrSnFWK0RJSk9yNlhSTTRlV0JzRzdYZmVtOVJTaDhDRkFKNnE2VGtTdC9KRUFoem02VDZwVzczdE45WDFleEFqU2JXK1VkeFBqdXA0a3VaMlA1Yk5IQjZ0YitUU3VWK1NzWUpXUEN3TTVLN2RuMGtBU2toOTZmejFrNXAzYkRUSDFJN0t0a3FKUXBqaW5zR1o2eWtlWWd0T0RxOGRpaDRwSWRZM1lvQ1Uydm90NllkTlM2SWx5M21LOU1abm1sNU9iZjJaS1hsclF1VHA0OFRmeEM5RmtsMmhvNHdrcEZJTFAvT01BRUFDanNET3lma09pVkhQdkdJS0VUMllMYVU1WWtaeDhibWNZUUg2aGFhVWlXN2s1S1kvU1RxaGhoL2o2cWk2cnlLRTg2OVo0YnJaUmJEOVBoRlUvTWQvZjZucDRaazBnc2o5TXk0SHgwUUxIWk8yemMremF3Z1R4MjFWek5yL3BLTm9jbUF4U0pwalduTTZFSGIrTERISkNFZ1A1aTEvOTUxMGJubmhtNDlVcFYxcUtWSUNqN1pJZFd6L3BBZTlsd3BldmRUUGNiOUxCd083RStyZVhSNVZtUlRzOFNJQk51NXEwQ1gzSWFkZmY1ZUJQb2tZcmFWL2Q2Nmk4cjZtOW5HZm0zTTVVZTlXK2xxWjQ5ODVDYS9kcm82SytVSEx4NC96RlNtVWVaczZCQTZiN3MwOCtMVlA5YTJyelJCNy9jSmpqTy9MNSt0dHYwb2dldHphM1Z0L1dLMDZYQ1JyUTg3U21xNTJjOFRHMjM5WFQ2eVJuL25mZjFiSTcybFgzZUh3U1hESnpIOXh0dTYzNnVXa3RmWlZ2aTNhS2FUeC8vbnpvNXl5aGVYaDZHSTVJS0gwVC9Db3BxMjB4Q3drZXdDbHVncUVxQW9reTBYcXpIQWhBVEl3Z1hRdVpSYWlnYVZoQXdCRXk2WUN0elpwcHpRLzlieTA0L1NhSGp0TWRQQzR5YlhrR3Vpa2tTYnIyUG53YzdoaWQ1Smc4aU9DcXNVcHFHT3p1YmszNmloZzhmWkdUcnJ5VXJleHMyNFJMY1RqUDhiY1ZVaDIwdUZGOUJCOERZeWFtbFltZTdSVngzRW9hSEJlUnZCQmVMNlRMS1R2N3hDVVZHQUpyNXNVVjIwZ2FrU05BWUVaOW5paFJ6STRXd2hFcmVpZnhBUU5VMDhZRWhkZ29oMFlRSkFZWWkxM2NOMmtkc3E5SjYwNFp4SHZYNTNNU3UxZXRjUllmV0lEMTVCZ1lxRmdjZ0RrK3l6RmJWT1NGWFhqcWxWVGNvWUx4R05pdDQxck9WT0YvcStoUnpKOFRWbExnUm4zdlA1UW9hRjEzT3RuVzh2dVZYWXpEUHdEcmFMSFpqL3VpcW8wN0hYVVlBNGxEYzVudW5HR25zZkNGQ085REFQNDNhUlViTWNzQTNSaDdnSlA2M3VKZllYQVI1RWJNcHFWSkNQRmZMWXdBcnliQkpnQUFFUDFKUTVnZHFMdG1XanlERVRnR0YvQ0NPQmc0L3c2TlRRUnhwR0R6VjJNNDUzb0czMTFDQ1JON200VEc3QWI1MGc3VXRQSGhURUpxOXhRWTBPWFVlbUVncHFCRHBXdjRVREVmR291Q1dlY01JNHNJSk00Mm9qN0hLSVBKRkZaM0RlYW1OenlUa1JtTEVWdDN4ZEduNVRhZHBVM2RmL0I1QlBsZHpQaG9ITzMzSWxyUnp1Ky8vejRtbHlWUUF1WFpidlcwK1NxVkorbkVjTnltbmpzbDhvcHUwdWk0U3JhN1AxTlA3U0d6L0UwSjB4OFNCUGN5Mzc3KytxdlZMMzc1aTVnZ0ovcXJtZlAxRkE4YmhONjVYY3VnZS9tVWFpMStxMFRXNi9uRy91SXZmaFVqM0kyQjdKZnVFSzZFd3lvUitPZCtLTHY4L04wUHdiZUM3alM0Ynl2K2wxSkF1My8vUWFkUU1LeWJ4RWxybTNJaE5lanYvL0M4UFJoanZoRzVsQU9kVG9SVTN1YVgzV3F2eTlJTVc0c1NSelB6M2xUb2ZGbmp2dVJBVlN5eTB5a09OS1UwNGVaN2ZGb1NhZC93M1VuZW5LaHNLU0VFM2V6cG1aQ0FqMHI1QXNCb2dOWnFmTGZoWlQrMUxqVDhKWExMcXZnUUxsaEwxemtQMHhyTnZhZXZEd3d2MUpydmowdmM1VkpSV1RMKzNZUHlSMlQ3dWxoL2FiVEpXYzRmOHZScGVWY3d2aThCaW9ueWFkbTZwKzJnODdkLy8vWHFYM3gyTjVzeXhwYVpJNlNwS05yRHo3UG5YMVpVdlozamRxL002ZDAwa3VtVW1QMzhMbVoxL0s1KzN3RmxPL05LNHVpN3ppZjlaK0E5QzVmR2NMU2U0VjBoNVRBcEViM3pITWhYY1ZyM3UycFI0THJFU2VGMFV1NnRWaUJtU3pzckVBQkEwZy9TbllmUWNYM05DN1E1NmFzV0lTS05JYnJtc25NdmUyUFJhSDBETkt3MFJLWDFBSVZOTVBZekV6OTRWcVVNaDVscHo3OHYyVERtZVpMbThHbklkcFM1YzYxeWxJUCt0bXMzYzVCbUp1SHpXdkNaSm9neGxLYlNBL3RmZjVkS1JkS2FFQThQRUNaK01vMy9XNHlJVGxRTUlXZERwYUVZV2QrM1Bsc3Rva2dhUWhwVHU3SDJ0ckZnVU4zSisvNU5yR1B1SzhMRGpkcDhZaGlUNjlSejNXNlFzSEZKK3dBQi9vdkxqd3dBNW0wVzdVU2M2NHozclpCSUJERzIwdk1TSHMwTm84Rjg1aDdXcHJIVGRySEtrMkRTWGNmbnBUKzc3aEI4T0xUdTNiUURwcUE1OG9zQ2ZFTWEwMHJCc3JTTFcya2JHS3YyMUh4c25PSHlqSmpQTXRBUDBoSVFqdGJOWjJuSUdLM2pNS2JpL1kySTlGVjdVN3J6NEdqOTZsODgrMU9hamV6NTFzK3FwK1VjeHFBMnFxN1FxK2xKakV4VHY4ZDFlcmhLK3p6Tmd0alhOVFFHd3hTeVM1TG1nUnRwb05JUmlGeWxhUzlmL0RERjdWZHBhdmZ6UzJHZzE5T3dFZDdORWpZdkwvY3k5WDZXcjZxMk1ESFVtNW1zSHpyM2FhVmxYQlhQbjZjbEZmMGg2QmFUS0FiVjJyeElPM3VUMXE5RTZUQ2h5VUcvSFgwWjcrOS84LzNxWlJIT0pwZlFLQldwdFRzNzAvUXc1bFBrYnFOb0ljQnFiSGlVNEZXMFRCMDhpVTQxRHJBZm83cE5tM0J3NDJ6MHVuOXdKM0FGbVhBaFdiN1FZY1JEYUV3ckhyVGFtaEFlTFhVNGw3Q0tjWUl2UnNUc0hRSGErN1cySmNDM1psS3UvY2VPV2JvUXdIa0UrYVM2Sk53SndncjltVlVoYlVoTVZSU0JPTGlXRnRRL2RXZE1MbW8wYzBUZjZkem9tVDc3cTcvK216SngrKzIvYW5QUzdiU2x6ZjF1WEZLZXpSZ2xrZEtBMUhYTlpIcDRERGl6SmFiWHhLK251WjNHV0ZxYnNCS1hYakIwZWc0Tk9jbFBJZlZOTHVhSitTUjl0UTY1RktJTzJmWmFVTStRZEtsRDZ1dVEwVFUwQnBKYjJIK3RmcEx5dVBiNk0yb0FZTlE5dVZnNS8rMTRvdDVRanRSUVM4Z3lLTTlFYlA3elhiRFMxMGdPMVVtRXJuNVB0dmFIeHJDUkNYeHkrV2IxS3VtOFh4NFhrK2RhMnRiYjd0a1NGakt1Y0xjTTl2ZHZoTktMakFVSTBjZk50TXN5TW9vUzBUeEZZa29YNkJuYkFReUJOdWpHRlR6SDE1TlU2bncrUnQwdU5ndCtYQlE1NFd1eUtRYXpkQ000MFpJNG53VWtObUljQkEzbitHaWFNS1NKMFJySExJMnBjeGFQYWg3RDNzOFA1MTgzR05VL0ZXa1lKcUtrb1dKZWttNHhjRDRxVG5RSmt6UzJ1Vi8zNWFmYVRGT0FjR29lNS9BK0V3MENPc2E4TEVxbnNlRGlLRzh0UHY3bU9uK2l5SmhTRUo3ZlpydTVwTFh4RGFGRVJSby8wdmJjMXk0MW4yWkNhUnlvYmJBc2ZXa21FbjhWUFgvenB6K1VlMVgwTSszM2JZRWkyOHZwcVB2Z1FlY2RXSVJ5RXBQb1pSN0ZOTXBMQ2orWWZuQlBmM0dFbzBUbDE3Ly96ZXJKMDdMa1kxd1l4RUgzVVJYdzFWZGZOOUxjQXRIQXYvakx6eHQzbW1HK1RRR3J1NVd2bU10KzU5bGxTbDJmYmhOdkRsOGt4TktCRW5pbk9jOGxWY3VvUHlZc012blAyc2I5TUxmRXM1NDM1bDVqdW5HNlZ3bE9MWTMwaGIrcTQyait4OE4yOE1Ia2J0Y0Q2M3AxdURzMUR6aXY4K2xwL21ORit6L1VZQS91NnFSQTRHcmx0Qk5qK3k2SFAvalJ4cVE3Z09kWitET0NiaUdBZnY4Si9RenVZQ1JwVGEzUldxTWlaQ2tKQkNYaEJ4ZTRtL3hPZ01tdUY2ME9uWDZrdzhHNThNVmFqN0lTWG5pZE5JaStSNisyR0ZPL2VoNmozcXBHZVhHNmQzTlMxVU5JT2lyY1hwRU5pS21mVDlmTjRhSGFTcndvWDBRZDN0ZVZCOVNVc1YxcjZyOGVzT3lESjNGU0h0SE5HRi94bHU0VjhTWXFUdExLK0cvMkpPT2xnakpySUlHR2Uvb0U0VFdLVnpuVk9YUXRKcldIaW93ckkyTG5BTWpiR045WlBoWkpaVkYrU0U5OXpWR2JwSmJsTEh3TmdXMHpSQU5MUHg3RTRwREgvREFUMHA0aGVoNUR4S3pBdTRmMEI2SmVQMDRhQUQ4eXpVYmFzMExER0lZVUJtYnN0T2hnVGpTM2F6SG9MZUh6SEx2blJlQmtXK3VMZnVmT1p3MmhPVVd3YWpEZkpnbTF0ZDBPVVRaRG9Oa2dva1dUWnZGaGc3RGd2OGxjYmc2WW9zUmJ3OU1rRCtPeGVlMzBkNCs1dmUzOVhta1oxL1Y0NnBuTVc5Y05jOEVRdTY5NVJ3bkJqOWF6TUl6SjVZa0pXZHpOL0l3azYwYS9mU0JabXZwYzAwUGh4TFNONlJYeWNlYlM1aGFKMmZvTUk0VGVhWjhoTVlacnB5VG1nMmdiNWtMcjJrblNjNlRMTGVNbmREMjhXbW9MZzExTWhjWkYwOGZBU0ZQSTYvbG5NUmRQa0hpb1dSL0dPKzFhT3BmdkRpUFJMLzFkYVFtMHg5bWRwOS9HTkltaDZuYnBlUS9iSnYyeTdlZkdkeGhPd2F0VEd0ejI3VmxUVVYwQmluWVNtV3N3aXNjUFB4M3pqQXREc1RsR1QydDUvTFBIelRPQlRvREVYUDcrTjMrWGorbGt6THJyMGM1dW1vaFVIbldrQkxyZGpGV1MrRHM2dE12Uzg4ekZDb1hiYlltZjZEenJZMWZQTkhXMzVTdnY3TFI5Zloxc2owcGcvZU5YVCt1VDlzWHE2Ky9UQ3J2bWZuVDFLZzNycEdpZmpxbWkyUm13dzdDdXFySjQ5VG9OdE9vQzNWTE82ZzJXRTNRWTRmZ2tXL0xqSXB1djhrVS95R2QyRnQxTWw0cVkxZlQ0aXQ2NEJ3aHlVZUFSZkswdG9ZWW1sdFFWYmlUcll4Mmo1V2hZT1ErNndXVGd5ZUxIb296d2pXRkszYTlYZUd5OXJPMnNUOC81aDhlaXdDeS9XMytSVHd5UnFieDE4K0RhdjlWT0Z0SHptWENra2RBa2t5Z0tVMjE2WUNlcGxUZ2dCSWxtekNjcCtDZE4rRjU1SmJkalJMdVpWOWVUNnBJaGNVbTdpQnpuVU43UEpId2JnZTYyZ096anc2NC9DekIyRE9rbElLUzVOUk90V0Foa3JZSnZsTmpIakpJenBjcGY0U2RKcDVmV1dYOXYrKzZpNkZtS3h6QUxWZkpYRVp2aVRPVXdHekVJNVE3OEVIM0lobys1Qkp6VGtQMlNPUlBqZWQ3OGppRjJnTWFNbUdUcTBSQlp0eDNnRC9VaStQNUVhcGlkL0VGYStpSWlTSERMcGdUQjdGWVJJd21rbTJrdDkrb0NlZjFHWFJzK3VUc040QTVTNHpsekZWamYwMnNlc1pUVFl5T0pMWXc1TStkRC9yRzlUS3NXb2UvemxmVE1BK3EyZ3QzT3QrL2M3RmFTSm5Fam9vRXMxL3BkdDFadE9NTFk0QnNTVDVRemVQWTdEWFduTmR2dmU1bnNuUEJUT3RPNTcvZ3d1czQ1dERDUnNHbGYyeHFNZVJBTzJtbGErNXN0RG44TUxvMUJIdE1TRVN6a25kWXdCY1FoNmdRRmdqMmZoMkowYTBCSVRUZmFtQkgvMVZGYUZUTjgxUHRndUpPdkNqTmpQdXBDd0t4Z2pqSDlsektweHBEd20wMTVRM2haMjZLcVRFM01UbzdVelRMVHVRUlVLUkI2a1VQL2RPVnNlN1RXV1FFME0vTDU5OThPWE9sODRFOFRra2VtZjljZVlkTmNqeklKZHdzYzNLaXdtYW4yNk9IUCtueVFPZll5Zkg2WEJhSG9PRXVrODM5SXczbFR1c0tyOHBoYWdIYXlTVnNyYmVGUnRZUFhLa25SL1dNLzdmeHV0SEVyMTR2V1EvWkwvT3FQdnc5WENZRHRkbzJ4SFZxN1UxMWRXLzN4eWZNU2tzdm5xaVhUOGZsT0RPcG85VGQvLzgzcXhlR0hOdTQ5V1gzM0xITTNjL0tzYUh3dXdvUSt1Tlh0SkNhbklZRTh5bWx4SFkycFNyR0hvaTRyYjhveDB4RlZBcmNlVmtmNXF6QmFHd1ZUSmdKak5KalNZTDNDQzhEamVzQ2NNYUI1alFRYWFQK0ZWT0dSZjVpUTl5b2IvTlp0d3JtRjBZd2ZxdnVBLzZMWkwwd0xQWG5lK25CL2Z3NU1qT2I4MCs4ZTNtdTNvY2FPSXNmcExzWGZGdUl5VjVtR3BBOE5TKzZIZnVEVWNOR1d1MFY1RkkzcVgzUFUrVU1jTWJYTEp2M05zMWVyTCs1LzJXWXZaZVptc24xbzhUQSt5Q00zYTZQeUhsRWlXYmRIMVJXbVFDVEZ6SVp0blBuUTU2cHJadEpkMEtBQkxjSUlDVytWTFY5dm1wSFlVOWFCZ0VQbXljQXVjMU94dHNKc1BySHUwZ0taZlBlTmFLZS9mRXpRemp6KzN2ZWdDNGplbzg5aUNxZU5rYk85aitBNC8rdDB5c2d3WExWMkM5SDdyVk5DY2o2M29HU1lBdzhhMlVtTVVjSGZxeVJYTk5QdUppVTBkc09UcWdVZVBLZzBJbzFzYzljVzlMWFFiV3VwZ3dwT1Avdmx6MGNyZXZQZDgrQ1dtWlVaSW9mTWx1bWtsVkh0SnhBT0l1QzlmSUUweSttdUVDS3BzR2V1YkNEOG1LOXNmSzl4dFBFSFJvWDVnOUpTMGdnd1Zjd1dNVkxCNHo2RGFLTkZKNFFnM2VKQTVTZVRZVWFMQ0QwYWl3Z2w4MjVhR25lL1hiNldDcWJHeDlqNmpTTThXSGlkZXc4ays3NXpONEt2SUFoazNldTV0QzY1WXdxUW1laktXK0JJaitxM0dIU01qZGFkd2p4RUFkRkpkN0NqMFJHQW9xdm50Y0ttMWNGRlBpOUYwRGE4cFVtQ3lSWC9WZVBSb2ZRd3B6Y3RIQk8wcm5ZMm5yNXVtUmw2aS9FbkVjZ0JOUFV3eHBZdjZ6aXo3R0ZkTStTQTNjcDNKYjlKMzZoSG4zNFo0NjNmZWZqLzlFVjdjeEowL2YzOEY3OHNZLzM3YVhGc1E5UFkwUFM4Mmd2LzlGTzdGYndQR3FmTlFnNHpVMFU2TDlxQWhBOHFLSVM3ZDFhLy9VT01NMkYrOGFIOUUwNDNWbi80NDVOTVV6bGU4aHdKMDZLWWZHdkRxS1VPTGJsb1RESzc0OGlsd29CVW4weW56a3A2cmtwbmtCNWluSlBVR1V5YTZNQ1d0c0t2eXk5R0kxN1dMaTNLZWxqRGFHTGF6NHkxZ1RUUThNSm9STExobEdzd0VYZ3FJc2luMTJVL01wczE4MEUzb3pGMWpUc3RrVVhmL3Zsdzd2ckFyS3lWdy9kNjJ1dDB5cGZIaHpSdWtyRWhtenlWbDNxci85QzcybGZJNjhDMHFQYkN4aGlRM1hFbEFuTEtZZ0Q4T2VxUHJyYitvdHJESkZvSUJRaXRSbEl3NXBMV0kvRlVTd3ZkR3M1aWFNMnhBK2ZPTURQWVBORFIwemlRSWJBY0QwUVdOU1hKYUROcEhTSFlaa2d3VzA3bEt6dko3bjliM2RkR0RtM21uZnNBcEFSUzZxc01jOVJ3RldBUndsV1NGSFBpcDhLOG1IRGdNa014bkkvSG1yc1A0RHIvei9iMXh3WHJPZ3ZPWEQ0ZzFZTURKcjU3cCszbUswbzlTWVcvMlhaRm16bElIOTJsQmRGVUt5QU5vZmFLbEYyLzhVV0xWaGZIWU9uem5ZYzFPRXhDSitmVGdPUzZ1YiswaFRUWkpDSENzdVVUTTBSV2VNcEF2SkhHSjdvWGpDTjJHdWt1QXUvMzJNb3dyczJZVjFqWGZmSXpoR1J5dC9TWWgxVWtiL3AvQkU3cWRXMzM0dk5ZTmlLTmVRWVlma2lwRG5OZFpUQ3BESzF2T1RreFVZSnR6YVNvK1NPZGV6NlRDb09DN05jU2Nrd0RMZ0huQzNuYllhWWhEeUVoSmt3Skl4SVJ4VkRYbXBvT29WSVRyQ016Y2t5QzRJNVJJNVJ4NWlNWUdsZkNRbXFEWEswSk5IUi9VbHFFTWM0NXp2M1o3S0dGRmxtOVNxc0d4SU8yYnQ4NEliVnRGUHc2RGFwdUR0Yy9XejM4UkFMbmc0Unl1eitsbVozR0RLMjF5T0QzeitvelZldWFiOHNvaDZkN2FaN1RXeW9CYTFlZGU3ZnFBbHBpcDN4RHVNSDNZeDJmVjBDTXllcHljRkxRNDNVTkFkNGNQV2xsZEsyOW4yQzlYd1N3ZHNZNXJXd3UralN0QzZPYVRoQUZkU0NwOXlvZ2xxUmdwaGFtM0RyT2I4eFNsZ2l6M0hONlR4dHFyY2ZYRjdQeTZ2UVJFcTEzQ05TbGk3WkVRUHEzVUFQbTlQSGF6cGp2TzU5bWhTYUdPWFZmeDFvYmdvdnI5MnU2V1ROQjU2MFprdGYxZTkvLzlIQ2RZLzA2dytuejNWcnZiRmV4UkJocHBMRE4zelAraUxncEp2UWg1UEdqaG5LU012VVJ1dDdDNkRFMHlaQ05kZkozSW5vMlBEUGxXWTdLNzVObS8veFJ5YVpwUmhxWTdVVWdlem5pSWR0SmRVc1cvakJtaDJGZGhkRGpBNHBnMVA1aFdPTlRvWG1GQ1RLc0Z6WkxhcVJoUkdoYkhOWWhqbDVLMjdTTVpzUi84ZUdVODUwWnN2N050U1c0Tmo0d1lFTFN3RFloZmd1bWNSOUh1TnF2WVpacnlJQldCOEE3Um9KMG4vRjU5VXozK3JoT1EyZ0JLaVFwVjhtYVI2U2tXSk1ZN1VOZitjdWV0OWNPSXhkcGdWdlZXMm9reUVTbDN0NHBpL2hHQkxOZDh1ZTdIS1BaMTJrT09Uenp3VjJWQUxoZDh6UlJudU15clBra3BoOSs2eUlmaFJUZEVhZ28yVzl5c0pLbW9wMlhTZTN0aTY2M2JyVE1FRjdRQWs3U09KcDY1VU14NE1hcUhwS1BpWGFGK00wVkRtQWNtRDlKWnJJMDNXRkFhY0l5bVQ5SVZXbk1uZEVmNGlGcEZ4Tk9RN2Mxekd5bFJlSmlaZ2hyaVhEMjNQQ0Y5c3RYQlJiYXNZaElBeUw0anFCcmJWd2poVUxhZ0xJbkp2aVBzRzk5dG9QdE9PVzd4ak9uYzBieldBc1htZy8zQVFGSHVtTmtrV0FhMStzYTNIMmY1cFRKWndPS3ZqMHAxZUwxNGRjSm1wempiZFJ3c1hGYzRmUFJPTjVmYVVWVFJQTWtnZklxOC9GWkp2eEpxUTgzYVZKcFRaaWltc0RYTDhQajRDK2hGUHo4TWMxc1UyK2VSNVcvUkFiempPZnRKdk9xejlkdTFySGg5cVBvNXUzcW0rOSsrTmdncnhFRml5M0NvN0ZkSkZpNFZYYkNmZDFDTVA3ckNRTHVFVkZlWnBka1kyNFpBWnZabXpOQWdoVThObTh3WVRvdjc4T0I3cmMrd000ZmVEbThkLzc2d0Z6OHRvYXJ6KzdyUFBTMi92UDltdEU0MXprL3ZjLzY4MC9QKytrenZQZmIrblUwck9WamF4cytsNVMray9EWnpZcVphTGlPalZjdExxbG4yMjJNeXU3TjJsREkveUhCUEZUUkl5UVhub1ZnSW1weXNkUnQvZTdicCszZTBZNGZJVERmeUVYTit1eENqQ08vcjAvV2VaR1JjUmp6VzdRWTJ5SGE3WTJpQUFBN1kwbEVRVlQ0N2lBcVpvUFdHMWdPcVVrNGE4RVZIaWVnWTRqOEMvblBrcUNuTGRpYmZBZ05aUmFOTS9lOHhUcklXV25DdEIzYmNXTzRrZlF3MUhlTjkwUG00bGJJOWJaenA3Vk12NmNNaEZqLytQRVBGOEw0SEdCcXNRQXRYQm1weHRjMk5XWWw2Q21yNEdONlViYS96U2JlVkE2eEV5Rjk4b0JEZUpHd3RLOFBhUStuTFN3emVDc045aUsvMk5tYk5LRTBLL3NONmllVU1HNE8rUlVWSjliZFlpSXlJWDk2MXF6RlJya0tranhGYy9tV2xtVFM1b3BaeHREMUptTUZLSGZCWHVLYzdaS1N2ZG9raGlrRkt3d1FJUy9mWlpJRnF6RTdtQUpOVVA3YjdOYWNIM0tudWRFc2cyN0lMODhwV01kc0RuSXdMNW9WRnRadnRPckdCRDZiK1JqWGlDdUhqRmFHUWVqTUtmdGN1Z0ZjazZLaVVIbXE4cnRPcWdJNDg0M3dYZEdrWEQrdWk4N0RoRGpIWjJQTk5FVnJqOUIxMTRDbm90dm01SHUrTWd3U0hwdjM3Wkl5NzVVVDlhcXVCbVRsQzl0UmJkMWFmZEUrbHZ2NXJYYnlEYjA3ZVZua3QzdkdsRTRieXc4SjYvTzBLd1hTSXVXWThVR005SDdKMUhiZmtiWnc3KzdqSE90dDB0b3pqWitmOTdoRVRVM3pqalAvbmordnoxVVd3VlVhOTliZS9kVmgyOWI5elY5L1hUZUcydUJrSnVydWNiTklMM1A4WkxLN3c3SFdXdityNlVMUjl3SlVKOUhvTEdlNFQ3TlZaaVM2ejZjSFpvT25mVDlkRS9vZ1QwMzJ1Mk9ZTnpNNldDeU9jVGl3MXI0V2hvOUJnZUZ5cjhYc3Q0YnJkZlNiQTQyc24rY2EvbCtmZmU4YzUvK1VqdGIzOWQxUEQ1K3Rrei9IOGhvemhFQWR0L1A1S21SL0szZ1JiNnBhSXZZUllpTEN5NURkVHEwSDFRdnhsMWpvOC94VnIxOGwzZVBxRUpNejFpUUo0VVlVQXdnUVpiRy9TUEw4VUtUaEwrN1ZFYkZvelljYTZpZnZoOUN1UnJMSGxQSUw3UGJROS9LdUN2M3Z4TndNVEo3UjdGZ1NzY3EyWmo0eDl6aXZQK1JjYi9nOUxKOU8yb1B0MDQvbEVqWEIvZHBibkxSd2lqRVZwODR1TlBrS1RpWW8wTE83Sm5MT3BOenZtbmVyMTNKLytnN1JoU0hkTTVNeVJGZ0RyUzhpb0s3cTN1dEY0cmV5ME9ZOFdsOXo5aHM0eEZNbWd1U3pTSlRNZTJsRUo3VWplZkpEeGJlcmRpN09iM2UzaE5KclZkNi95MWUxbDRuOHBzamgwWldpM2lyODh6OEpCTFF4V1gzZjY1dWR0dlVoeG0zTGRKckticzBFT2I2WlBNeXNOMVg2YjhYOHBFenMxS05KRHRsZU1LT2xiWFZ2aUtPMWpBenV5SDNHTE5wRERiUEdVajVvVFRTcVhvYlFtUURxTVptRVM0Sm9wbUJ6NmRZeG9PNGJ1UFo2UFFrZlpGUzNUQU1EL3FoSmR3bGU4cUtXQk1IV05hSW16UGlad0ZQZ2hNYkRQOG9zTkEvbkt2dXl0T0NuVEdoUisyVlhNNVVJQXBvTFRUWnRzam40ekFFOFl3MkpFWWI2djJHYzRkYWJOTkp1RnBKWDcwYjRHbGZQT2pvTUZxMmZOWHliSkhoV3h2a1p4ek56TmVuOThOTi8zdHozSzhkNUdxT0pJZVJReDVoZW5YdzNEbXViOXI3UDhia2RIdkVYdWUvTjZoQzVVTFlqQk9POVgydVhONW1GaFA3cjdpK2tEMnRmVjllM3YzOTNkYjNXTWtmVjk3MHNnbmZVRmxZWDFaKytibi9OODU0dmIwcjNpVk8rNUxSbi9kQ1prMlBDdGthNmxuSlJudWJMdVprem5hYUZFVDFzbjhXNzkrdlQ1c2R3ZXRxNGNCRTA5bVU3TFl3bUdBWm5BZ1lOZ1ljbzZzSjRNSXJ3SmZRZ0xKamYxNjRwRVFzYmd5T1RmWDBNN1B2TzNFZGpEZmErQTlPMW1Zb0pycy96NnZEcXozVS9mZlhibW9rWnl6SWUzenFjUzlsSnlDVFFsRDdKeFdPOU5kY1M0aUkyYXZkMkRDRysyV0JscVhQV0JmUXVXaEE4d09aYjBocVlacVBsN3pTTGE5RTJTdHA3SHRQNDY5OVdHUG92LzFuVjY3ZlRFR1JxWjlLRWJNbTlKSGVMblZUVWwwcFM2bDRSbGVtbkpMS1hIMlhxNHlJU1dweW9FbTFyeWY4Z1VmdWRvaERCYWRnWjdlWjM0Y3VJUVVDbS9Eelpmck9ub2dwNGtVak9XQ2J1Um5OaUVzcWJZaW5sdXBzRFBKdE43eTNrQWxoQVhmL05sLzNQZ2lLV2haRzFRTUhKdkE4aUtHV2ZOaVhRdStxZ3pHUnRUQmhWQnlFd3pVUUU2SDZieUwwTU1XV2UvK0xubnpXdTRKbVVuWWI4TVluakNzSzNNMUV1QzZFL0wxZm1QQzFvbzlxMWs1eS90S2FkbVBadWtVTmJOOTNFY0Q2RW9DSFNWUVJVdTZVWi9idVl1M0lvN1dHZ21PNEpFbTFObHBDaFpZVnIvZERuM2pBRG05U1l4RXU5WXZmQm5lYS81UlZzclBGbEd1dmJ4bmd6UnF4SDFVWHBEMXNScm1ncUNKNkcvRkpoZEdFUVRWVDZJMHFMK2JVQzRVWmFYTStiT3NuR2pZblJnUGhTd05MNUMxUExKeGdjREVPNGY3UUIya3lmeHdVQmVSdTdJQUF0ZjhuUFE1RFdTT3NTTzd5MDN2MUQwSDA1REVENUQvL2YyNGhRb0VZbHc3RTJMc0ZuaXZCalRxK0Q5ZnVxRW14MDhLNldLVDg4K3k3UWJhMisrZlpGWTRraTBtRHZWTnB5VUdzWlhXQWx3VEwxM3RTQlFua1FEZnMzdi9sVFNhYXl4dCt2SGxRTWZaUldKVW4zb3AyZmRNeUZEeitrVGIxdVkrRjNDWmNwZDZKTk56OXVBdWtWWjdsTW1NUG1qTUZLWXVZNzBqb25xaXR2U3VzWXV5RzNGczNuMDg4K0ErR1o1K3ZNNTJHU0lmYjdtTzdyTXVQQmE0NllLa1kvRHUvUk5QN01TTllNQlkyQjI0L1hkT0g2dHpXakFXZUhjM3kzZnUvemZBZUJQaDdPWGQvTDY1cXUxdmY4NlhuZXIrOW5IUE9VWGgxbjBkZEJBWWxyZkxMaFhCcFdKcGsrVlptRUpOVlZmZ3FNWlRaLzdBSU4vYWkxMGUzNGx0eHdmRjRSNlg3TzBlbjNsQzd4UFBYM0tLTGIyZmpkNmwvOXNtWmoyZUVYaWlBejdkQU9oWXoveXVKS1lMdlpUaHgyMWdrUEIyazFpdnVReE50TEZTZlNjNmYwWE5JWkYrZThUdFdNMFdGY0ltQzdNUkgrRkltWHMrVjYvZ0tkSkVrODRWMzVTd1BvaUIzRG1wMXpBb1VGQnRkQTN2TUJjZ0VXZ003NXZhNkJDMkNZOVhwQkpLa3lNYWkrYTZKUXhMdGJOd3BwRGpvc1VHWU9hODF6UHhQcVhSckp0MDlxS1gxVlg2UXZIK2U3T0Z2dHBWbmNTOXB1aGh5MlhrSjR0bEk3S0xId1dtVkxaKytTL3ZrWnRJK3hwYm1XUE8rYTU4dHl1bmJ6Rlc0VkZkSWxNN3hlYlJhbTNpcnJWRExpdGN2V01PemZ6em5PeCtGN1hSN01wZTJKK3h3TjU1T1NVaERMSEJnVERDSngwV0JtYzVvdXZ4OTRoR0NhbitZeUNFYkJ2SFZRUTZiclFQeHJObkxGR0RBd2YzeFBtSXFtZWZDWWJ4Q09JRklhdkZiYmg3WFJYdStzQkthdHpwempXb1EybTU5MmJzczk2NkFZWFc0VkRWd1FnbFBlT3RBVXJCT3RScUV6K0kwdzZYNjMydWFOYVhnWmpKMURpREJ6Q1Y1K3RGdWxQL3hRcmR4Ry9oQk44bzZML29IenRZTk11MnJsbUZGWDdXWXVYaVB4bUpieXFNNEtkKzU5RWl3enk0T0pYWlAzWTQ2YTNrbktmRlZxZzIzZEJWZFc3ZkowTXpQeFRVbWNUNTlqVmxmTk8rWldTMlNLUU1OS0k4NEYwSnhPKzM1eUVLTU5PSWxKMFl4b1ZSaUx1YllpZmttWTEvdTlPc0ZIOWI2eTF1anAzWGRQSnNWaU5zQ1F6WitHeEp3L3FxK1ZSY0RVSFlQWDBjUm9Rc0dPRDNNdGdEMkhRRjZmNXpNdDZjK0hlMWluQlkvUXZuSEIvVFc5ekRndE9qenozMGY2Y1krMWlmaFR1bksrdzNmdXQzN3ZzL05kdndpa2hjbXBSYjdNR2xNSVB4dXRjRzZPa2RSaytSTVEzT3hZck0xdlVCU0svcERmZ1Jvb0M5Yk5NQkdBbEJOelhOUWxPZEc1bklXcjFXKytlNVZQNmNQcVgzNythU0g1bkpQNlI4WHd0SDdsWUtjMTJJNHFhaDJ1RDhoeWZ6cWpBVWNjYk95UzZFaFNCZGtUd2VpWkY0SUJMYUJuaVBvQUlvSVVmZHBPUTZQeEFyZzc4U01Fd2c0K0dwcFkzdytSQUR5R0NVdFE0NXcwLzFzRDFRZEErL1ByUW55QUsyY0hjZWhKUHhzWnhGaW5UNVB6SVVtTHpUK0FtWjdVc1dEdlp1SHJmRnRiN1dBaVRBNHJQM21VWDRRRVROS1NHblp5UHRTR3RoS2VxMkM5bVdrbGFoakZ0RWdoVk9QVU1CQU1SUVRyMlJiL3lZVE94RHhJOHNlZVJsTzQ4bnUrRTlFaGJYczBOOFRZSVlGYVMxa2ZrbS9QZzRXYXh0RjBteE5OYUJ0bmF2T0xkTkErQjdQT2k2cGkvZ3RDQ1JnY2xldzZOYU54eXJjaExBYkY2WXdRRmlIR3RBQ2ZHRWppNExob0YxUC9mZG5KL0ROMlpibjhlTzRrQVFlN2Qya1UweGJJT0JybmNjUkdzSEd3SG1YNk1oT3R4S0xkOGx0RjhSMVcxM3I1ZzVkTUdYbFdUTXJCMSs3M0ZtSDJYUDR4anVxVElya3ZYcFJWSGk3ZGZmQXdtTlpob2Y3dDJzUGNLRENpOUV3eXNsd3JqSWxneFlUVTBNayt0MW5xYkhHWEpxOGNCKzUvbnpEU2grckdYZzMyTXNzSm1KZWxJang5YXROUkdlWkZ4anRQbVFzcjRHM3Y1UXFhMUVXUmJuMzJLUXJET0JvejdWYzJPRWEzR3d6VUt6NSs5TE9Lc08zZ25GK3NPUWgraVU0ZU51N2p6TnBKU1FuL2xNUk1aVW8wZ0Q2c0QrYmdUeHFKM25XRXlPQnA5QXQyWWRKQWM4MWt4bnpzYXduR2t6Z00yQjloelFYamluOUlKMnRhV2VodEx2aFAvdWQzK0xGK1pYb1NPdXMxOVdxTTZ6R3NYOWQ0ZFphbXFrUlBCVVpJVzJDSk16eEd4ZHNqUW5ndFovczErOUkxd2RsNE1pUVF0VnNpYyt6eUhoYkNOdWR1UUtXdEhXMUZ1TnJFSGlUOUR5THFOeTNNODlUakIvR2wvWHdEa0pCelBCSVlqVXVhRmJNUzRqYVhGakpUc1VrYzFES0dSQ1ZkVGNyZytUOTZlbzdhV0JIZzkxd3RtbDNJLzBSMTNnK3hKaGVsY1pIZTBoam9VTXdSNTJIRXZobWc5cnh1aTNmTXNVWjh6M0xHbjErcCtqNGpHSDZCSld3dXBZTlp0NW5teHNiM3ZmRktkcVFGdUdCOWpaMkM3bHh2cTZiTysrcFB6eHByNWxUUzR1NUZEdWpHbHF1cmJxMmxMclRieUhsbTQ0Mkt5NjgvZkppRWZyZDYvdDNUa0RlaUM4SDV3RVdCWUxxU0hBeW5sbkhsa1FXYmJWcXA4cFA4Z3oyK1VGRnJsWGFVS1NuVDMzeUcrTXFhQml0Q1EycUhEVHcyOHdlNnJZaFdUK203b01ZUFI1ajBRL0owR0FxZjRsWU15S2FsTzIzVVFVUGdFRDlOWFlmM1VoQW16NnRuUXo1MWhqUmlKVU5HUFF3emVHRzgvR25HUVhDTmhoZGhIVFIrekVqNWpHeDV2akZKbnlPMFduZU4rQkNUbllWdEQwWGdxWHZ0eS83VGxocWpTZ3Z2YWVQQzZIc0xmbG9lM1BzYU1TcE8xamxCYmR0aGY2b1RiR3YzdHRlODZ4VzFGd0hNQ2MrSFpCdTQwOWFUWDhnZUFuaWtWSU1kdXo3M3JEOSszV2FwN1pLRGlSUTZXUDJ6di93djg2TmRyUDdEZi96Ym9vMDVQMkpPVWo5RWl0WFVIdGZvY1RzNHYrMmNZeHF4MzhOSlZvWXVFYlRoOTJYZk0yR2FEUXhjM1E4SHZ2anNpMGtoNGlMNXZ1Zng0OUdlbUk1NjZaODBEMUZYSmlvY1BLb1JJZTFvOFFVdXZrb3BHOVpqVmpLY0lXUVhMR3BSZWc3RVduQjh3WFZNQ3U0MmxPRG56STVlaGtiNmZpNzJNc3h1K2JoK1A1VVZ6dTlZZi9kVFJtVE84NXZuZmp6Y1puMHVQRjJmUXhueW1RQjhHNUdrdW94Mnp2V3k5ZG1qN1gvN3hSZWZCSkFrZnJhKy9qeVR2dEJKbUpsdHJMMXFyVkxBb3U0Tm1XT0Z1VFd6dTVVSC83TlBIcFRaMjg0ZkVjNk5rUGw2M1Foc1BHbERTa1JFY2txcDE5U2V3ek0wYmlCbHpMZW9WT0xUblBYK1VNNjF1am4wMkhKbmxrUldtdHhaQktxYjQyUzNSMHpITGNyYnpyV05VT3ZSb2tsdklOTVI1ckljZ0hjWndUYlFJbkoyM1NreTFZSk40WENjQ3RPMWRQZ2VzR055Rm9yV3RnYmdvalpqUXJTVU5UQ2hrK3RwZXI1RHJCSldZN2JaMllBOGZvak9WNVp4cHd6NHd6YXd0S1c1VW92NGFaL3JINTRKdUxlVCtWUXQ0R2JkTkcxNXJ5LzJhWXpCN2tDMExKSE5ucDR2VU80T3N5SnpNU0ovRjFlNUVKaW9kUThZSkJJaTRLSzVYWCtWNlNpbEFmUG5kRmNZL1Q1dDhGU3hLK0xzZk5vQ1hNUTRaS0xMTVhyTGJJL2NwL0MxKzZ0dGEyVDVCeGVoZ0VIUi9xNFZ0a2NnQ0dWMm9rNWc3YVZDMjM0cktMbWkvOVBZNmh3UXpqaU9NcDFBN0ZqZFlPYU1CTktqTkhZTWdlUVhyR0RPRUZRMGlpWXlFbjYvOTNaZDZxVG1OVi9YNk83YjBTalVMbHBwcFNSdmROUXNpSEVRYzd3S1JqVFcyZnlqNVQvTUNZNzYzbVpPOEYvdVZ3QjlrWC93eFl2YStaUWx2dEgyNmVkRlU1L20weEtOdmZzZ2JhWW1lMXBuKzN3ZXptNjJUdWY1VTArcWZYMVJIZWo3MXV6QjQ4OVhOMHBKZUZwSDNyLzczYmVyWC8vaFQ2WExpT3lHUkRHNWk4Ni95RTgxa2VIZy9xYU5jdzhUU0J6N0d1QnRObTUvM1h3WW1kMmxSZkpzeG5xUWdKTzVEK2JQWHBTMFdpckdrNHFpZFNwcEJjUDFhQWErSkt5blYxeGZFbWJXZEpoZXJ6NkhObjBYZnZDSkJSUEtBVzNNZVJnQm54WTZRUXNqdlJzNk92RGV2NFVCT2RsOVA5SUZJcG5QcU1iNUg4L3IrMFV3OXZrZnZPKzBIdzgrUnJpempNTWRscU9yd3h6L1Q1ZzFWdmNkUnR2cnYvb3ZmdFpFdWlaOHRySE45cGRmZmg2eDVYaHNsdzk1TjBMSTd5TVFsZm0zMHJRUTYxNS80ZFF3TW0xU3JvZWd5bFN1M2JnN2t1WWlHMzJ2emdTeWtqV3UvN1NJeVdWTVNINmlVaDNOK2MvNXhvcjQ5ZXh3TUdDM2RaTEpqYXJaZVh3TUlsUWdPdlZMcVlwVVpjaXNHSE4wd09CdmJ6OTFnb280bThOTTNtV2tIeW5zV0RmOHdwR1lnbE5hc01EbTQvL1h3QUo5NXkrdkgzLzg4V1d0bHY3NFJjdkU3SEEyZ0VvQTlabGtPS3JmRXVmcDVNbkVMRjFybkhiTVZYdTRSTGIwN3Y2dyt2WGYveUdOb00wRTd0OWYzWWtKMkVwTjVFYjdXcldhVExHckdJT1VqREhoUXFwaHNUMVlwTTArZGFSbkFjVFZ6cGwwbENyNDAzSVBjc3pQVHRwRmJXVmF0L3lEQkh5VHcxaEQ0SlBNaUt2V2ViTmdoQzNROVpPLzZtK1lUWUlGekRDODgvNGdOcGFvL2ZWT24ybTlyeXU2bFJFZlVwUTUzdTdMTVZkTjVaZ3I4RWVoNjQyQ0V2YXJuUHlwMXNVNjNya1g4NjZ1elQxb1NSTkJESGFuY0NOR2N6Ti8wMmwrT2xxQ1JGamhlb0pyTjhMZVNZT1QxdkQ1WjErRUQveUk0VVNtdGdpdTFzZjhsclFWR3p2UUJ0K1Vxc0J2cFNPQm5WLzRFakhLbHpYUGUyWERsVW52aUxGa1Vmd1FNOUNDNWNHRFQwaXN5bUJheHh4MVp3V2RtSFVuVlNhY1p6SytTbnM2YUJkMEd5L1lhZXA1dnF2WFJjVXhFUm5pOWdVb21yVGdXbk1lZHdaY2o3R3NpZlJHREFzdVdnL3psTWZIVEx1ZXIyNC9iY0QrZnI2bkNYN3p6WlBPNHdmckp1R253QWFtd3dTMXJvdDV2TkRLTUpvL0krbkNTQWFuMTNpOU1KUmhUK0Z0UXhxY1J5ZHJCck8rL0oraWhiVWc5enZjZHhEbWErYmk4L3FjOWZ2MXZYNTg3UWZ6Ly9Ib1hvdEMwejNEQy9kZE15cm51STVyOEhyZEpqWnBySUpMVEJOUm5KK2xLWWtBTXAvdVozQWNGVG5aVGVPU1dHcnZOR1lSL3d4Vlg2NE5QMGU0UFpvVWt5Z1JtVzlHTFdMY1BjbDBuRS9nWnRoK3MwYjhleEhUVHNTd3k4NlBLRGVTQUZSNjlZc0tOT1A5SVhjMmQ4aG1JY1pVQ0RFLzlGNGJHRFZtRnozdnNzVVZ1cVdaa1RUaFl3Q0lNUHVOSDY1QnpDUk5sdU1YNFNONmtyd1QvbC9IR3NCcmdLNC96L1VCRmpBZGdPZ2NmL3g2dEs4SitUWm54ZGJzY3M1ZDJjYlR1U0E0Nm5LaGhlM2RuTEIzVXVIUHl0ZDVVUmNCaEhCUVYwZFIwY1BESjNHRGJ5TFc2K01Qa25YK0pnSlRabkt0bFhwdkRtbHFHTUZGZnFaejhEVi9wbDdtOTJWU2ZYaDBnaUJzR2RqZHFEalpQb3p2KzMwbnovbGF6ZWI4Ym1sYm03VFJUTGNQYVFNN09kRkJMa3BkblRWV1RGQnRIZ0lJeEJTeTVoYkRpSGtHaEJCR3J5bHRYTGdNdWtld1p3cEtEK0F2MGdtVDBMQmh3MEg1Wm1PaXhMamRnd2IxUXEveE9taytmUFJ3OWF6V0xXcFc1VENCTC9lRHVkMk1nY3ZvYnFDcnk1MThhc0dKMmZlT3VlYjc1am1zT09haWJNeHp6ZWs0Um5NY1F6UWV0WUJucDY5cmNaUkRQUC9WUnM4L2p1RC84UFdmSW9DN2FTaVZ5YlNWMW1lZi8rWHE4MS9lQzlmVDhvUHA0ZkhTdjJvN0I3c2VWUGZ2ZlJiamZKWloxODdPSlhzZTFWMlhFLzJrZFFqVGtoYTBwSFRMN3MrVWhoOW5DUjk5enpFYXZqZ1JVMHg2NldpUmhaQjJ1ZmJmd0MzS3d1M0sxcGhqWVBDcWpVekJBeTZaNjVLY0c5M0V5S3dsbkdRcU0rZk84NmZSOW4vMGI3amhIREdGeHVMOHdkbnUzYTNHcDhrdjUvNmVCOStkNDlXZmMvK3B3Mi9ydi9VMTYzbXN2LytIRE15OTF2ZjBPcXpxNDdNTUNJMktzazVFTkI1Z2ptdGFjeS9YS0hqL0VDd0pLY0p3ZStuRmsyTzQ2RktZUHR4OUw2UjBrQXdRNVhyY2Yzb3k1YUExcGZFSmhmUnVLRmVMNDVSU0YzcVBkdlFxNUQ5NldSNVdSSHkzWWxBdFdDOXFuSFVWQW9wRVRWZlFDSW9aTWJWQlNlaFd0aUVuVVlaNThSY2dMSGlMQVdhMkpJa3ZNMFVqMWN6SnhocHg4YjFOUm5IQXo5dno0d0pOOTRYQW94Y1dYOHhvYnYvMFdwanFqOGNhd0JZRDBKWkZJWHdiYmZjTHZuQTBYRlVzdnBnOWdXR2laVnZOVVo4bm1kVE1vbmNsWE9vUnhZZjFTYjIrRWVUYld0Vyt5dG5jREdKa0pScjIyNVBueDhGU3d6dWJIZHlvS1dCWjJQbVk5aklwQlJRTzIzSFhEc0JaZmVJSW1WUDV6dnJEeE1IY3hnRVRNSkdKbnRwOEhKeVVOQ2w2eHFnT1d0dTNNVW85ajY1VmlDNVVQbTFkWWxxVFpvRUp4M1FaZGVjSkVrem5XdlBqL0xXdjNpU00wZ0x6d1J5a1hkTWt6TjBHSTRnUzg2SlJTaWlGek1mVjVFbVZNU1lJU1NPak5YeGF0d1JsTjgvYlgyK0NFMzFQMitJVFBVL0RuTFNKZkZneTNGVlh3UEQzQ1N0WitSenJOTzlaaDNDRlAxUGh0V3h5UW81ZlRwRXlQOWk3R01iNC84cUJPK01ES2JqeHpUY3Y2cnI1cTJCZitVdnczMnQ3K2hPTVAxZzllZjVxbU5ndzgzRDVmdnNUSG9iRFo4SDhlWkZFMjdDZkJkZXpBZytLd0cvZXJmMUxUbSttK1kxTVBNeFlmL1JobmlOME1meG9Jdmd6VmJmaFlQaU1hYTRKRXROUjhtWmVoUEJaL2M4OGYvTGt1bmJwQUpxY1NBdms3ME1mMWszNnhydnVpOEdNSUE0RHdQd2ZPOWJmTDh3bzFHbU40ZmY0cXFLamJqSFh3bkdIMzV6NzAyUDlHUzI0bi9IL1k0ZHI1OTRmZjE4LzI3bStYeC9yOTU0Q0J5UnlDeWFGZ25NZXVocUcybjNjdzNac3NubmxrclZZcSsyekhIbnZwbWwrR3lrV0x1ZS9VcnJTVkFKVURzcWtwVnl0MFh5NitSQnFTT1c0ckFjMU0wZ25BS1pkb2l4SmxSbFVjdHlIVERaTzVROE40TmFqMnN5RXdOaU5LT083d3ZPNEszVlpzN1hMRUFkZ1NOYU56bS9rbVNTWmZZMGpIU0hHeFRrczBnZllYUWZZODd4VTBoNDdNRzdHbzI2MjJOamVWbk9aSm5XWnBvRER2RUVCQTdBQmp1djg0cmRsb1h6MkIxQytXd051VVozVHN1THd2cE0wNnRJYk1SelJHQzJtM1FseHFScmdPN2xibFlBa1NXTjZWblJLemxGUFdYMzI1YThpaGpkbG5iZDVaU2JGYVloUDlhZHA3SWJZenlzSGVaTVUzNnA5N2MwY3o3Y3I3OW5McDFIRllvU3JLRGNUQ0x0REpCSFFwSU8wOEV6TnpaaUwzSjJ0aEFsSFBKUHNHbHdQZm5MclpvZmlCcHIrRnlNTmRqR3hxOHc5a2NLdHRENmJ4OHFTbDhlbE9WMnJPa1JuM0Z3RmRzMng3WG1ZUDNDU2c4YmhqbEZKVGNqTlBVeEhLWkdOVzhHYktSb2sweUlQeGw4bHFWTENKUVpKazdNbkgyRE9waWNJTnB5YmRqQ3RxNFJKZXlqcWN3VkdXcVdZaTN2dXRCWWlzZXROS2JUb1lYYnJYSkFNVGNCV2kxa0I4ZHUrNDFUL09qUHUzV1hPYTdzZ3hkaDJxeDY0V2JxQ0JOMm5tWGRhSEVtZmFiRFRDZUdiSjY5YXgrL0c3V0M3T3JsVGFsRVY0VjVtVXRyV1hkdWQyZW00WjV4blJzNjI5TUVNVTZQZHk4UGlld3lyWnZ5SUhoNWdVb3ZHdFNSbjA2cW1OVTl3WDVpMnJkelJYZmRKZTFPUFNTQ3NYUlFFeEUrMW13QTk2NEVrMWpnTVR1RC9JNE1JMWc3V3dVOFArTHpHLy9XcjM5ZTA0YjN2L2EyWkVGNncvczZyZS95VWJ0YS9yY2ZpSG5NWVlJZmY1OVg3L3ZDTzlUVytYMTluanJQWGFmN2luWHpSZU5IVzUzZTMvcTNkY0hCeXhhZkltdjF2SWZteG1IcDhNVXZYaGFSd1FMVVBtbDAyYk9nd2JZc0R6UFNFeitGNGtqOWwxT0cwa1R0dDJ2Q1h2L3E4RmgxcFdmeGozZHdDME5iMERKY2tSMTJleUFidW4rcUNFUWpudjAzU00va2FLZmJUaFYyWE5wTGUwL2Y5M3FJcFlPYWNqRlQ3Vy80QmdIZjc1WGxGdTZzWE1ZZlVtSGhwUk52M2kxOW1BVkNuL2lmSEdwQVdCbkl0Z010L2c2Qjd0Z1JFekV2aXBsZUVnK2hrVyt0bXdUUjhHNFAweXVlZ2hFbnJIWWhtYXljbU52TkNxSnpQUk1PMW81eXhyNVBpSW9PSFplbS9TYklmcDlWNmZWSHJFcTE0cnVYam1BaGo0OGppanNsck1WMm1meldKbUlWeGpTWVgvR2lUdEF2YWtkMTVoZDhuZ3pxWWpSQUNzOVlYNFdDeXRBTnBCK1lUeCtzNXpiWHhCK2hNd2N5OGo4eEo4dUlONGZWK3NGY2dnb080ekNHYWpzOXZaaU9HeGlKUExnVEQ2R2hDazJQVjgyWUg3VjRuUjZqbmNqT2M1SXlIc0RTeGk1Z2NJcjBXUTZPTnRrcU4vYmdVaHpjSlUvNVVXbURPNzJmUFJpSWJ1K013b2Z2Njladk1yY3kxOEcvWkRXWlZrNzFYcTkvOThVK1RVVzczOE8xYUJELzg5RmZoUWk2T3RFU0JINXN5dkNvd29yWlRTWlJXTE4vRnJQYjI4eVV5RFV2dk9jbHhyZ3VJY3B6dEpMN3piRWo3c3V1WWsveXFvLzBGSzVxVnZETTVYU3lVZ2VVUTZJZlpsSVdRYzJEQUtqS2tGU0ZNTXhrTks5cUFkK2pDL0FQZm40L3V3d1V4cVVWZEE5UDl3VTk0dU1aZkRBUmpJa3poOHBxNTZjeUNXVHAzcUdTZTgyZTNnUWQ1OWs4UDk0Uy92dmQrZmIrZm5yZiszdXVhZWYxVDkxcjdzRnp2WHY2NjhlQ2g3OWIzZFM5Ly85ay9leHgxRjB4SkU4WnJ0M25mT1gwM1JQMXVWN2ZYcE41VE85TzY3UFFpZWtVYThtL2cvcGZkSkg0L3hQOHVOYmtuZHNPQTArS2YxcTJBbzFKZnBXblJHdkIxRURpT2lQV0NVdlAyb1NURy9iTGNNOEhUSXNwK2J5QjVIUm9NRTBaME1lMHRaTmhLcXU3MHJQZWVud01aNHFlY0pibGpsaEVoSklFY21OWDZ3S3djekFhNHpQY0ZHQnpqQ0h3UUhHSDJuNWNCU2xCWUE4cnJXdlYxSDU4eE9PZEJJSXZSVlVPb24zejZjQUlWOTNPY3kxdjc3ZS8rc1ByNXp6OXZQN2o3aGN3MVhIc2NZMzRmOGorcDZkek5JaiszcHJzanpXTS96ZWt3N2VRd1RYTXZaL012N3ovTUVmL2JpTGU1bTA2RUtlZnR0UEVmbjJkNnJHcGZFcUxlcEZrMGxvMWUxVlZ1Qnd1YUQyTG1XNUxOTFVxWmUyOENIZTlqK255T1VqNUVvYTduMytMalNzeTBydnhWbFpZVVJNRlk3ZWl0RENvMUpWOWo1bGRyajJYUXNoYmtMbzhvallhei9lYmQvRUxCYmRrQnVRaGhPQ0JIRFJ4ZXZYb1JnYi91K292Vko1OThNdkNrdGFzaHBJRktTa1lBVTQvYVhEQW41cXVuY0FFNDk2cTU5Vk4vQ1I2K3R4clFRUmdKcFB5blArdSswaGhvZFc5aVZvUmxEOHc4azY5VUZESXQ2S3FTcDVTdHVuVGFETFZhdThwZnRrc1cvZlZ2LzFRRys1T0VSN2d1aFVjMDk5N2pKWGVLRDdKN1NEamRqMkVkSHRVZlBTRWk0Sk1kdnVCOXVIUitWWkowNnllM0N0elQ3VWZZb2c5Q21ObDJWcm9LdkNQMFZWMm9qdEFhR2s0ZEhUOGZob1dSd0xlWmJQQ2NmVUY3RmtzQ3Z0clJpWkFOQytjZnZPWG5nWXNJSFVQQytCeHpuMTdYaE82Vk5lUjVhNGExL20yTjU2N3puY1A5Zk8vK0R1OGRmdmQrL2JxK2R2MzduUFR4UE85L1pFSzlIMGI4ay9zc1QzTFduKy9iamVmKzZIdjluUFU0bmJkWlpZZXFsM1QyNEpFdjYwRmgzTGN0a0QzWHJncjVUZ3VZd3FiYkpYMUtock16OEc2TFQyVSt5dG5JQkNTc01maFRIQ1JBdjR0ank3L3lrWC9KVkRuZkhTbDFYU005SU1sZEFlTkYwdGZtcEdvV3Qzdk5vNVpaczBUKzJIZVlqVFJyQ1pETVBZbCt0TGkzM1k5V05WblJEUURCV2NnR01NK2JoODI3dnNXd1FuYVJJYWM0dHpXZTk4dDUvL2ovQWNyQ2UxMllFNDB3WW1xT0Nsb1I3cHFoMFNhc0JTQXpqZFE2OFFkT2UyTFBiOHpqdDBpMTUrZmIzdjVqaUp4MmhlRHI1ZjNrVDIzTkZIUCtwSmErZHZ3bG9XOVh4bU1yTEVoSWVxOXgrVEJ0OWpETjRidDNMOHZWcWlsZ3ZpM2F5bjdqdlBoSUhCY2ZIZTk3RlZOalFwYzVqVTJZbzFvUzZWc0VsT21kOE04L0ZmeURpMDRVVE1xenpjcGE2bEpRbTQwMG1NeWxwTEI1RGhMRkVLVndhSHNqcS85MmRYSDM3a3ZYT014ZjlMcFd2NC9xaVBtSDhPR2kycmFrWVlpUFdldHl1ZC9EWmp1c25zT3RJSCtLajArZ3A2R25vVVpRclo4SUVSelJoTkI3MjdvditobkZPcndaNTEyQkNCbmwzQU9ONWNYeldoUm5qbnF1RFNzdXJ0NnVmcWhVUmtza2Zjbis3dS8rcWdnaDRZcnhoNk1Kell0WGxVc3g5VXJhdlZPaC9xMjJvV3QyOVc1L1ZrTG1tOVdYWC95cTFJSmJiVXJ4dkZTQ3AybEFPc3VHajQxZjJvcGF2cGZsYTJGV0prQnJKNURodXQ1ald6RVFHcVBBek9TOGhSOHFDMXFDV2RPblQ1OE9FVStYRDlmM1o2MHhpV25SRTY1NTczdHJBN2RHR2ZxSXJ1UHphYjUrSHh3TlZsNnQxZnJQL1h5SFdheWY0M0wzaFpQV3gzdjM5bjd1MC9kZWYzcXNQM3Rkbit2VlBUeHIvZjJhVGx6cnZlL1gxL3J1cCs5OVhoK2V6WC90MVNFSjNQMS95dVRtaDNJV1A4UjdrcmZEUzBvc1Q1UEpwRmkxL2M5WmpxM0xtSldRZGl2Unc3S2JkL1JmRjBLVzJZNWhOZG1ZeVd4dW1WWVZheGx0eVU0amUwazlQZzM5bjdBcmZiVk1RcHNVdStncWRyWFBIbzFKZ3ozUndzMklTNzdRZHRxVktDSEhwWHlOQ2Q4M2pta1pHM09UbjNUTTNHd2Nma2VNR05hYWFabk9jblF2VENiSnhsbHJIRFFyN0czOFhyNlpMNzBzN3dGMXZYanI5d3Z3bDhSUTRYT0xKSFIrbm8vRi9TL1RsQkEwY3hDalVrZjRNdTNpVlIwbEpUMjZEN1B3VnN6cFR1YWl4RDhTNzFaNWFycGZjQ3lMMk9nLy9yUiszUnlxMXhJY3RyRm4xdTBsclRtcnBUczh6enhVbHRDRWdxZHcrdytsRHV5c2ZuNy9YbVU5SE9wRnNFNDBxMHZsN3k4UWhRRE0yT0RRdURjbGlTYnRsV0ZKMkQzUmtpYVRLR1VsWmlvN3Z1eTRJb1pNMlVIMG9vRTJ4VGhvTFRVZEpGeVlhTzlpdnFGbHBsOCt1WkRvenAxYnJaUElxQ0publVuYlRDSVRpWkpzMTJMbURsUFJZZmNiZVg2Y3piWnZaeXFkMU1hRnFzdFBGVThkMDFSS2czVnFzNEdaT3hoTGJ6alBhWCtqRklxakdQbGVKcDIrYk9mbkwwSmtWa0FsTVBrRGovSnhNTE4vL2R2ZjVvZDZueWI0c3hKQ0ZSL1hSSkdmTlBsMS9jYWQwY0wyd3V1ekdKS2s1WnRwUHIvNDViOEltM1pqdnJXYXllWEJKNlhqZ2lnMjgvRW9wL3JoUi9PdnhScnRVbVFiTjZKdGd1OVpRUmFIOTFSR21oRGZLNmJEZkhZZ1Ntdk5MSWRUNEQxTUpzM01uREVsdjF2dTVWZ1l5Y0lZc1BldTkveWVJYWloSEdtYUJ5UmtDUHRuSlprNi9BNXZGd3VCb0tWeExXdE1BUHNlSFhrK0JnYi9qVzNHMXpqVzlPQmVhMGJrMVI4ODl2c3lwbVZPcmx1Zjk5UGZYTzlBRDJoMklUN2ZMTzk4RHc1TW9yR0FldnRUcG5XUlpiYlJQR3pvb2U1MW00T1lCckpUVklZbVk1Rm9TWmlUUkUrY2JmeE9BVis3WWRHdlZxVC9wQ29VcFd2Qk9jYVlaOEx0bXh5NUllcFdUczgzcjlwdDUvblY2a0YxZFc4bHU0VjBzdWtWMVc2bHRjMDJWcElURVZiSWdnMmRsV3R4bnUvbGJWVDNwdWNmaGpocCtkTzdYQ0xmTUt5a0lrYkY5OUZqZndUREtOQVJwMDFibFR3c2FpYkFER3ZxN290RVdVQUgrQXR5cllGcElaZkZzNkNMbXMzZWgwUXc2Rlg1UGJzeFdCME1tS1FpYlppTVdzWHc3MlBFck4yR2psOUdHQkY2TUh2MHlhTWhQRGxCZHlLTTc3NTcwZTRvTlh1ck43bDk3cjZ2RjVKMkt4Z1UrR2tOUEFYZ1E4Q1lwTVJNeUpncGtWYlRReXYzYWRPTnROMjNwMDlYdi9yMHdlUTBYWXZ3M3lYZGoyTUNLZ0JTRGJKaUZxZXQzYnB0a3lUVFdVdGsva1Q1WFNmNXlPdzd5UWYyUHJoSk9wV011VkhlMFdiTVVrUlg1YjRhU3ZzUVhxWWhIdVkvZXY3MGN2WEZGeitQbWUydVhqejVybm0wY1VtYWlmcklHNWwzZDRxU3ZtdG5KUDY4OWNFLzgyWSt4MkJDeWpZK0NrbVhYS1RrZFF5ZzlJZzRuYndyV2hQdHdNcHhFVHo5NXZ0U0RFcUgrTmt2MCtTckFWUzNXc0JodjQwL21JamZmUDFWRFBkbXpIaDdOS09YTVpZYmJUKy9tUWxZSkNQdDZiaWswNmVkbnk4MUlmd3FEWXNXZWE4VUNuc0kvdXlMTDlycDVtajFKUE5kdW9laS9QTTBhaDF5TDhOUGUrUHBSUG91dkwyVGFXOHVoRFlCVGVPM1l3NUJlMUluMDdkcGtJalhnWUI5SDhDYlNiZ1dzNFpIQ0ZRelFzaUxFRlVOd0ZBSnJwQVp3YzltRmQwYjhZcmF3dVhsV25ndG43RkU3ZUI4c3hLdGwrMWEvZUQrejlJTTIyY3hvVFpOQ2FBQUhJcTJIRktQakpYSlN1a1lxUmFPN0JXQXNHTlBvbm40UUdpRXNob1RnWWVwUmJjU2kzdSsrL2xkM2xrVTMvRDdNRWZqOC83SGo2aHpzVklXQnRoSkVSUW15YVhoOEg5VkNlWTJGUkFEQzVaUXo1bFQwR3FhWWJ0czRTZFR3WkUydTgwaHl4RjhJOG11MVN5SHIwejFpNUJYcmxOVG5sSUFwdUM3bU1kR2puV1BHeUpPVy9Jd0k1VUlDUTZJaEVTeWsvREZ1eHl3VzludEFmZ3dEZUQ5V2VIcXBMeDRtWWlWZGphWGRuNlJGSmJVajI5R0lGMFh3V2pSY2hpUngrZVdWc1pKZVU3a1dGMS93T0Zma3hyZGlYWVYwSUxtUXF1ZElkTzk3eGJ3UUpnRmlNYStmTGNBYmZuLzhnM0dCZTZRWkpGR1hkY1hOQ3FIMFB6dXg3MFVsV1BjZW5pM2IyMTFuc2FUbG5XVUprVGJlZkRnZm9BdTJscTltRDNnbmhZMlB5NHA4bmJFY2VQNjNXay9jbFNvOXJKc2FwcmZTVEEvZ05nZDRJd0ltVTNUT3lxQ3ZmNnB2Q0FNdHZrSC84c1l6dnZXNjNYZFRZOEppYzdGUEs0eWdURHEwQzJDNy9zZzlTR1RPejdjTUxzKzRGQzkrU2t4SVpIS2dsOTFqdTAzSm56LzNjcTBvVkhaVFFZaVQ0ZU52cGY4dXRrT0xpZmxPKzBWOFRzcTJnYzJDRUxybTVyWWhodUxpYk5YK2RGV1JZOFZSd3h4ZzZkYVNnaXVhRmwvSTB3YXppQ2tzOTVmWlFyVFNNNHZsK3I4MDdSVEdzemRZUGJaNlpjeHJqVFlORkhPZFF6OTJiT2E2WjArS1dCUnVVNnRqRGZLWC92TlY3K3RmVXNPOU5zUFkxVDdCVndPNjVpUm1WZ0xsLzArWStLNkd1aDg4ZURoZzB6YmU1T2E4ZFh2djE3OXFVUk5wVlFhRXA1VUdYQmVEU1FoZTV6bTlpNGhyRmk2THdKaitOT2Y5amQyaW41U01tcDI1d1JDbGsxREZod2FJZmdSUHZadURDQldZNWpZa2xiUWVpY01GeGRJeXhNY3RRcWlITWg3NHh4SFl3VG0vQTMrZXU4ZTBVaXd1bFovOTdCMTBtZ1UxTnZIa01VMDJOeGFqTFhTZVJqZzFOeTZkekRkU1VQRlRIWDgyQ2tSMXE1UEFtNVhNYVlHTXV2STlCNzY2bm53eDNQZGI3US8xL2JaZDR1d2g3a29vYVB2cEJJNUtCVGVPY2VmNjJtUjgxdGpjajNjaUJCK3ZMYUJSY09kRTc1aWNPY1haUmVrU1RwaFRHLzd2Um5FWkxZblZTRWpZRHg3S2drdmJBNzUxdzVud0RSNUtyajhIUnJHRkNKM3Mwa2tiVkg4ZmtvN3EyaHhMU1c5U2dBa0JXOWtOb1Q5K1dUS1BhcmxqUE1kMUdLSUtGL280bHkwcllGSG9CWjBXcUFndGs1dGFQKy9IcVFLNkJqWG9rNzNNY0Q2VEsyMjBKaVJjWEd5MGtDWWU1aVVyYVVBMWFhWnNxaWZQQ2wxb2RJS1pxVG9Ebi9PamFKTW5OUjhRTFFIODRhY0RxcjJBalB6WEpEWmM1MGpHWE90dWpQZHF0MUpKdXBDR3Z1SERHRVZ5WG9yYlFmWDNxaFRCZ1pub2YxbURzNWp5cm1HdHNWaExKZU51YmFkZVlyeERTSkhrSWhsY3JXNkZpOGR3dXBtcDJseGV6V2FVMGhzN2h6cjUrZExrcWp4bWVOMlBzamJhZFZyUkhVdmM0Qzh6dkc5ZWozN1c5NU5PM24wNlBIQTZjbVRiNGRZRVpYZVVrd0VOWHMwbzhNaTJYeGxSekVvVVdndGllOC8vSEsyNDJLV2YvUFY3L0dqR0Z3dGl0UDI5cTdkV1IwL2VaWVFZWlpuT29kNzJyODhMbWxWeDRXSGorN251M3JTMWw5UGhuR3RIZGtpdnpiT2VGM0hqVmV2YWxYY2VqTHhwNEZnWXpaK2RIRTdVNHo3UTRLdzU0T2I5VnNpeHd1czRZa0ZtRFVOcndqVEJiNDBMNHdQY2FkbGhOVFgrT3FDOWVTdHhiQXducmY1RnEwL3dnWThtclBnQmh5YmZ6RXo1OTB1cU1Ea0JHT2Z2VDlvYmRHckFBQjRxMUJaMXQzYUwxSEZKakwzWHFkYXNLcldoMGN1WTEyMG9CbkFyT0Q2alAvdlY5Zi9KMGZ6Tno5NHNKNFhodVhQWjM4TzgzV080elFseDdNYmZVSTBHUHpQLytiTFdBL0V4bkZ6ZW1ib2l3NHkyYll2MHlBQ0NoTmkra3QxRjVySDIvcTlZeUlHRkN6bThGQUE5UStCZUhiL253ZDNONlFWSWtkb3pjRzNqRURYcFB4ajZqMHZZakdTYmpnRE4vYk9YUnJTTFZxRGhuOFRSV3BNcUVpZTFmaXBra3g4TVZzbFgxTG4xZFV0M0w4eFpSNGlYSWlsaTZrQ3l1bS94VGRScnlMdjZibE1MZzV6MnptcGw1TmhyNVV3ZjRTNUlCSmg5dytiamJmNWJOZmxkTHMrWUl2VUFRSVNhQm43cU16RDBKdGxDYkxwaWN2OWc2OFV0aTFiZzMvMC84a1cxOG5TbG1jL0ZJYTNDNHMrK284LytUeXpvQzNIZytsT2xRSzM3cEdLKzZ1Lyt1c25oZUZqYUpramZCaHlOMFJZUC8zeTF1cS8vVGRmcm03dDUyUExOUHJ3bmxtMnZmcTdyNzVmL2J1L3lnRWRJNWxlK1dsVDFId214OE9IdGJUUnFxWnh2NmxqeEl0TXA0eUVOR01wTG1CU1NVMk9hYzM1Ym1YNjdxUlJENi9Nb2I1VEtkWmx1V0pVZFhsTkYybks3M1AwSDUxY0ZUQ0lVYWZkeUIvYVRDanBVRERSNXRJNUl0VTBOL2dWN0lFK1hQdnk4MGVyLytsLy9HOVdqKyszbmwxLzBXOTVaMWIvNi8vMkgxZS8rVjJhZWYrK2ZQeHU5ZC8vZDMrNXVuVy9kdE5uTjFmLysvL3k3OU9PRGxmLzNmL3dYNisrL1BtRDFmLzVmL3p0NnYvNmR5OXpHZXl2L3ZXL3ZyZjY0bDcreEwvLzk1TThDNGNGTzZ4eFM5czYwMlJLUFdoaDE4U0JRSmRqZWNNRWdvZHdkanFZUnZBVGpSeW1rUkJQeTVIN3RwTW02Ujd5dnJJdndrOU1SeVEydjJmbE9yTDBhZnRvaUUvSk9XQzFaTWRqYkNvRitKb2FVMEtHNW5rQkoxZ2IvWThaSjJIM3FJaHl5bnZNdFBFSEQ0RXBpb1A3Mlp4bDB3N1BQVHNGUFFiZkxqMlp1d0lGYU94Rk5ZbndkMFlZUTZQbDRwNkUwRjZhSjVOME45aG9qbm45ZG5XN1dRWS9QSDg1UHVPVnJpMVpBaGVkdTlsbU1nOXpaZno4Y1RzLzNVeWdkYTEyU3hRY093a2RsRE40bzQwOTlxK244WmRmdkxWZDJnc1hqVUJPZmV2MzIrSXNEMnE0dnp5cjJTeS9oeGM3MXg2M1JuQzJMaGgvK3RQcTEvL2hyMWEvLy9YZlZNTDMvY2MrWWVGT2RGSmFBNzVRbnliK2poRFBCS21nMm04czNDVUdWdXVSZnVnL0VaSHMwQ3JjZlNZQncvVTRVRGZxVGNzWEhBSkV2WCtaSXN0Q3R1aGhlWG1KSWVySDZFU2cwelZnQ0tqRlk5Z3QvQW1Ta0FTeHZlNWoxNW9aVDR0cGFld1F2UmtETWk1QTVLamZhcXdJSjdrVGdwQXFaWmlQLzZQbnRmQlpvNm04WFI5VHhHQWdJSUpSamtSeitOQTlNT01tTk14SnFRK1Q2a05tNlI3R0ZXSnFKRGgrRnY2VkZnN0xYYlFjYWpHSDlOUlpkMjRNdjdtTUpPdGFvSmtRL1V5dU9WWm9HMDZFN0pBY0lpOVp2VUYra092Z2s5M1Z5NURnWlMxNlg3OStXbTVYc0VsbFA0d0JIRlhUdHJGelo0SFpoOHd2U043VGxObGNOZjhQT2FQUG5yY1YrVDM5bElvVVhhbUo2OEV4TlcyWGQ3YUtZSkw0QkZNRXhHL3BFRXQwemk0a3FnWVJnVFRoR0h3RUdxamY1NWZaakNqMzk0dHc3a2lUU0RNcmMzN3BjOFUzVm5Kc1JFblE2VzV3STJmNy9tNkJobndycjE2VWRaNERVZ0l3czNQS1ZJTGZaWXhBRkxqSzlPQ2F1YVhOY3NBNlBZL1EzMWU3dDFWK1UxcmVjUWhxUGZZcW12ejhpN1NjMitGUEF1T0g3OHVHZi9OMjllVXZINmVoNVI5OVh2VHYyemFHQ0M2M2J1UXJ6RVI4L3Z6MXRPQzJPY2N3aCtETkZ6SU44dmp5K0Y4ajhNaHF2Z3N3ZzUvMlpuVEFQMXJ1d0tPeHozb0hMVjFNUmxBSEwya2dFbFkxSWV3bCtNSXgrTFF3bFdZZGJtYml4NVEwQytUSEpQeTBqakVPZUR5YVZrZ0J3NW41VTZBZlVhWVhyRzVuVTU5bWttNEZWM3NiS0FteW5aZm9KOFkwK3kvQU9EUmh6Y05MdVhOcVNxWFNhS3BvVHdYV2ozcFQwZXp6QUUxRHRIN0RjUGw3VTEwTzhxZktENVFEK2JMS2luZG4wWG9XWXRRMURGRjNDVTAzMVk5S0JVRUdWeWt1SVdqUExiRTh1RnhMeVVGUHMwOURlTExSWitZM1grajdpNWZ4Z052aEpGTmY4WG8wRE9iOTZVRHkzcVkzR1FjVUFFRVpoZXBYQ2NyTkhKNmJwNDJsKzJOd01jaFFObUJqRENRS1RVZCtDV20wczdNUXd4VHZ0Z29qT1RwM0dKcHJ1b2VGSGNiVndwc0ZBdWRJbzRrMThnYlFnRHVSS3V2K1N3UUVvK3NHSFY3R0pnL2dPeTNjdXZ4bHNvWWJQQ21JUlRXejVUempuRXZ6c2FYQ2FvWGlYaVFVNlptdTFTdGs2Z0xYOUUrN0Q0d0ZKbWthMk1qbnVleDZFVGtBbmRLV2ZzTFFaQ2hiZkhZOXpjd1lKUUhLSGhhS2ZZOUpSczFUTEk3d2VzYVlyZDEzVG00c0h4L2ZJeTFNZngvbjYvY3h0NEs3N3dkK01kdFYycUZXc0orMGorSEIyLzJLYXc4TDNmK1FhVk56d0tLdFBUcW5kTDZ1OHFnZTNNOFUwUkVnWWpnTEJxSnM1MjB1TzZIK2ZJWTlvTlZneWtkMGRkTFU3MG96UGRHc2tmamRpNmFxWjd2cUFnUnRicHVsT3h4V004ZDUzSUNROHN5RDJYaVkwem5NNkR5bVQrcDVzSlpBSzVmcHp0MmtxNWJOM1dmeFUvbitXdG50bVRVeHJKTjhRVzlEdktzeXhwK1ZGelVpSjBhN0grS1N0amZ5QjkzcytoRlVhVEo2dFgvL0lnZDI1U3E3YVhJM0Q5b0U5Y0hkcWlYQ3JaRDdqL21jOXZZK3JINys1YWZEZEg3M3UyL0dwNVhTc2ZyOC9wM1Z4dW56MVVYYlloMjBWaHprczBTdFllZ1FNMi9lalIvdTROODBMZHVNV1JlK3RTRFdXVDR1RjhBak9BakdmRE83T2pta0JXa1FzRFhwTnpSQ2VNdnZHQnhIYXdobnUyNjBtaDQrQ2FUaEZXR0tIa1JJRjhXZ0VjR243dWU3elJqVFRrSnNxem1qUThFSGV5MTBaWENRNTVicGx6dzVLdC9SRGp4TWFsci9VaDdYbUx0MmNDcWNZNXFLME5MZ2Rvb2M4NjlDb3RlWnlCTERDWjZiYVR6WHlwM0RKTkQwU2E0QlVWT2ROY0FFN2s0NlVyQ1F0dkg0MFlOTWZXMS9NT21lRlA0Y0grYzZTc2plS05WbXR4YTRlOWZRZXJCRFFlRFpIL2paa2R3OG0vQzhva2MwUTJsUitjQWNuazFPd2xtbXJIYm5lKzJMY0pSZzNzK2NQNjlOMEFUOXBoZFdhcHNGV3R2QU5BUklTU01TTFRDWm50bUtoL0JKbFkzT0g2QVBKd241azRhdXdXMlgrcVlXb3Z0WmJINFYxZS9XZnh4MUgzMEF3MUM2NVdnM21NN2NQMGFRVklOa2pUOWdZWjRRYUdGMlMwZUdIdHBpQWdtMVhmdGFVbXl4M1hXNFhKb01PbUhNdWNaR1pTVkpsYzE4Q1BGSVFZK2JuV013MVI0bWR3dVRScEIyNmJsSzg0TlUwSHh0aTV0TCtsYklxOXpDbk53WHNpTUtJL0tySzVhNXo1eDl4aXlEaFRPbWZYSHpvZ1ZKdlZnT0pyY2xqbkVHYTdzNmYxSiswK3MwcTJjMWJOczhXU3I2TjByR2xLSXc5WmtSaDVBKzUvRGxaY3dDd3VYWS8rTWY2ejZKRVFWUThMYnh3WFo5cGZkMjNUc05pb25TMktVUE5MRmcwZHpCcjg4ZldqK1M3RGh0elp4cEZRaUg0TEVPV2pmREJlWVAyTCs3NHBUUDRLMDl5cDA3U2RnRHpJeHZMOWczWisyR2JyWTErUDBZMWZiK3ZSellCU2llLzgwUXZoMDRycExHa1A5bUcza3dOMmNNeHRINnZFc2p3S0IzTysvelQ5cmxKc1o0VVRlR0owK2ZsYkQ3ck1MbHo4cEYyOHJSL0hyMXQ3LzVmUXpvWlBVdzgvVnVKdkg3MTBuem5QZkRuQU82UUFnZkR2ekJCSGFZWksyQk5adkMyZ2g5anVaRTQ3RlFoRERmRXR3SUxZYlIwVlFDWW5UUnV2ZEhDSTlRRHg5MDZ0VStCc3FNdzdwektiRUVjTXN3VEJvZWFGZTlNTEpGMDFrckNwNFhtNTlueDVzYU82SFh1c1BudnFCRVRNRi84TnJKN1ZHMlRCSDF1bVJVQlREcEZzTmd6TUp6SzdMS3I0WW1hY0RTWGFZUllWSkdLeWJwTm1mQllucmN0ZllZQ3VZaWVvaGh2WmVUR1JZSG92N0M4MmorUmpXb3Qxc25UU2YzWXRUdnkrdDduMFA4UFBOQ2wrQ05Fc0kzdGxMSjBxcG9WbHdlOW1Rd2VYTmtkb0tuaWd6d0pmQUpDSnZZanZCUFlHT1FyRGd3dkgvM2NiN05lb0k5Kzd0eFYyeHQ2aDRiNjE1eU5aYjF3clRtNWdpcWlla2xUa1BlYUlHSEVpTUVTWWhidTJXZENvVU9rU1B1bnBBVHVORXVES04zOXRJRFBJc3pJK3dHbUJSQ2dDemUrOE1JbVNyd3BHOUc0aVA2VWJzeHN2NHdSLzRrWThWOWgzRjJuMW1jRnRhVlM1NFRUWXFVRE5JZFpCTXBJT3JsbXRqcUxBU05ieEwxU0luR2Jnd0xVMG9mYThLTllybSsrUzErQnlZZy8wUUE3VmYvMFN5TVdUNFdiYU9STGt3b1JqSEUwSThRd2ZWVDBOcGNIZjRQenVhaFo5SnNoK1djNERXTXMvSHVaZ1pxd1hQclpndWZHZmptc0dMeW5QZlVjcnNnWDJXZTJmTlJUeVhteG41K0tBaGgxeDNyWnVlZTlJY1pHeCtZYXBCcHZ4S2pPYytjdnd3QklldEZTSDNheHJhSzBkZlIzZWtNMjNoRUI2VUpFRnl6RVVYYTFMcExBS0tYaDBmSTBGamUxWFBydktMdTNiMGlkcG1DZGhLUzliNlhwcnNmVTk1cGZOZHYzMGd6eUpjeUdlREJzbkZOT0QyaVBNajB1VXhEUEcvTzF6djNxaTJ6em92SW5aZlg5T2pPd2VyVGg5MmorYngrZHI3NituZlBTaURkWEgzMjJiVUtrSit1ZnYvN0h3b1FQVzFYcFFJZk5aN2ZPWDlXRjR1WHdhTncvRUFjMGRFc0YvaURQZVpneFVLT21FdkUydHA1aGV5TC8yN1JGRkZPZE4zdmlMZDd0UDd3UTdtU0tDci9ESE1hdkdrUzNCTFFjclR0Y0lkbUV3SzBoa3RnQkcxaFdtREdzb0gveG9OWkRDMkVyNWlHNE1kb0pkMFI0eUJiTUhaaWVuYVI2cjBFNzYxTUoxbytxMERLeGZFa0tTdDdxeDRUVXlxcXJhTUQ3WGszTGVoNnBwelVHamxzY3RzSXFzdno5Z29vd20wTUxKMnA2V3crM29OSnBKZmJwZUJIMnZLMXlxMEsvN2NTQ2R2bVNtT2NCTzd1TXhZWlhqU01aNW12dVlHTElNcDVHdUdOZ2lmb1pQeURlRXk4d1hVME1vcU93QStCaU5iVTRYNWF3NERURjUrdi9uRDB4d1J6ZmQzUzFrc2MvZlBORVMyZ0xzUzVPUHgyeW5qWEdNNi9yVXlMelJBQmtLS0dicjVnaElYcHNnWVNZTXZFSnBIVnNpSEt4cndzSmkwbTVnTXc2d1VhbGJQQllqMUQyQzIrZks3cFJkN3pMdk1Ka1lMdVJUL3hudWszR3N0Y0kvOHBRbzh3T1A4NENCUGJSdG96Y1BRQUVtRG1wd1lMYVVtLzNzMVlGNVhYSFBvK2hCeG5lK2RZNUpHMC9lSStrS21iTHVkMWI4aXVRU0ZHNVQyMUZsUGY4UHhPNUhqRmZKcnRmTjVrT29Uc3dMVVFUSENPV0pJeHkzaWFKd1JOdDF6T0N3R015UVlVZHhCL1VrblR1VmM1eFk5cWdiSmhmN0FXZFR0SDYzWU41cWE3UnRxWG9BUUdwanJBaHJheDhSNllWQ01CYzdhK3p5emJaaVkya0NHRjFsQlpGa2ZmMitaekh1ejA1R3JLTXlkK05zVFZmek45dFl2R3NyVDViZDdOOFV6WmxaMnJtOTlKdFh5NkRweWVabzVrYm14aERPM0N3dHg5djM5Uy90VFRDS0JJVzJPVWtDbGZqdlAvUmpsclRJeEp4dTAzdmk3M3dyd2U1V1MvZTdPNnZhZmZGeVdNVWJjTDhxZWYzMnBPWjZ2ZnhLeWVmRlBVTXB4OFVGblpqYzBpejlJdllzampwb2pKTGt3Qk1VWXFMUWZjWm5KSzNBUUkrTHFZOTJrdWZVOVRoYlE2WFZoZzlHQXRsRXFkTjUvQmNacFZ4Q3FibnhCczZWcEhVaXVCblJBQkxiV0hBamVFMTBEYnRZU21lMFBJZjNENEhtWnFtK3pSUzBBRlVmWGQvUFhNN2h1NWQvdG9LRzIvcFlvWnBsakVFQ1hLZXBZNno3TmdvRHZwRHo5ODN4cjFyTVpHeThLNFJMN1ZNeDRXQUpKd3VwbTdBWXd3NHRsRXBRVG9qWGdDSm9rbTRBQTZPa2pEUXZ1d0ZxTkd5d0pGeW1ac3FNRjBCT04zUmNTdmIwdU9yak5JREtwVjdkbG9JMlljSFV2ZkFCKzVtME1qaUQ4WThyRk9ubGhqeFN3M2V0YnRBZ0JmL1B3WENldEszTDVyNjdYTyszOEFmSHBDOEVMMFg4OEFBQUFBU1VWT1JLNUNZSUk9XCIiLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCAqIGFzIFJlYWN0RE9NIGZyb20gXCJyZWFjdC1kb21cIjtcbmltcG9ydCBQdXp6bGUgZnJvbSBcIi4vcHV6emVsL1B1enpsZVwiO1xuaW1wb3J0IHsgc3R5bGUsIGNzc1JhdyB9IGZyb20gXCJ0eXBlc3R5bGVcIjtcblxuY29uc3Qgd3JhcHBlclN0eWxlID0gc3R5bGUoe1xuICBkaXNwbGF5OiBcImZsZXhcIixcbiAganVzdGlmeUNvbnRlbnQ6IFwiY2VudGVyXCIsXG4gIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsXG4gIGhlaWdodDogXCIxMDAlXCJcbn0pO1xuXG5jc3NSYXcoYFxuICBodG1sLCBib2R5LCAjbWFpbiB7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIHVzZXItc2VsZWN0OiBub25lO1xuICB9XG5gKTtcblxuUmVhY3RET00ucmVuZGVyKFxuICA8ZGl2IGNsYXNzTmFtZT17d3JhcHBlclN0eWxlfT5cbiAgICA8UHV6emxlIC8+XG4gIDwvZGl2PixcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtYWluXCIpXG4pO1xuIiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBzdHlsZSB9IGZyb20gXCJ0eXBlc3R5bGVcIjtcbmltcG9ydCBQdXp6ZWxNb2RlbCBmcm9tIFwiLi9QdXp6ZWxNb2RlbFwiO1xuaW1wb3J0IHsgb2JzZXJ2ZXIgfSBmcm9tIFwibW9ieC1yZWFjdFwiO1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuICBpbmRleDogbnVtYmVyO1xuICBudW1iZXI6IG51bWJlcjtcbiAgcHV6emVsTW9kZWw6IFB1enplbE1vZGVsO1xufVxuXG5Ab2JzZXJ2ZXJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBpZWNlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzLCB7fT4ge1xuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3NOYW1lPXtbXG4gICAgICAgICAgcGllY2VTdHlsZSh0aGlzLnByb3BzLm51bWJlciksXG4gICAgICAgICAgdGhpcy5wcm9wcy5wdXp6ZWxNb2RlbC5pc1RvdWNoaW5nKHRoaXMucHJvcHMuaW5kZXgpICYmIFwidG91Y2hpbmdcIlxuICAgICAgICBdLmpvaW4oXCIgXCIpfVxuICAgICAgICBvbkNsaWNrPXsoKSA9PiB0aGlzLnByb3BzLnB1enplbE1vZGVsLnNlbGVjdCh0aGlzLnByb3BzLmluZGV4KX1cbiAgICAgID5cbiAgICAgICAge3RoaXMucHJvcHMubnVtYmVyICE9IG51bGwgPyAoXG4gICAgICAgICAgPGltZyBzcmM9e3RoaXMucHJvcHMucHV6emVsTW9kZWwuaW1hZ2V9IC8+XG4gICAgICAgICkgOiAoXG4gICAgICAgICAgPHNwYW4gLz5cbiAgICAgICAgKX1cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cblxuY29uc3QgcGllY2VTdHlsZSA9IGluZGV4ID0+IHtcbiAgcmV0dXJuIHN0eWxlKHtcbiAgICBoZWlnaHQ6IDk2LFxuICAgIHdpZHRoOiA5NixcbiAgICBtYXJnaW46IDIsXG4gICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIixcbiAgICBiYWNrZ3JvdW5kOiBcImdyZXlcIixcbiAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUzZCgwLCAwLCAwKVwiLFxuICAgICRuZXN0OiB7XG4gICAgICBcIiYudG91Y2hpbmc6aG92ZXJcIjoge1xuICAgICAgICBvcGFjaXR5OiAwLjVcbiAgICAgIH0sXG4gICAgICBpbWc6IHtcbiAgICAgICAgbWFyZ2luVG9wOiAtTWF0aC5mbG9vcigoaW5kZXggLSAxKSAvIDMpICogMTAwLFxuICAgICAgICBtYXJnaW5MZWZ0OiAtTWF0aC5hYnMoKGluZGV4IC0gMSkgJSAzKSAqIDEwMFxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuIiwiaW1wb3J0IHsgb2JzZXJ2YWJsZSwgYWN0aW9uIH0gZnJvbSBcIm1vYnhcIjtcbmltcG9ydCB7IHNodWZmbGUgfSBmcm9tIFwiLi4vY29yZS91dGlsc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQdXp6bGVNb2RlbCB7XG4gIEBvYnNlcnZhYmxlIHBpZWNlczogbnVtYmVyW10gPSBbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgbnVsbF07XG4gIEBvYnNlcnZhYmxlIG9yaWdpbmFsOiBudW1iZXJbXSA9IHRoaXMucGllY2VzLmNvbmNhdChbXSk7XG4gIEBvYnNlcnZhYmxlIHNvbHZlZDogc3RyaW5nID0gdGhpcy5nZXRIYXNoKCk7XG4gIEBvYnNlcnZhYmxlIGN1cnJlbnQ6IG51bWJlciA9IHRoaXMucGllY2VzLmluZGV4T2YobnVsbCk7XG4gIEBvYnNlcnZhYmxlXG4gIGltYWdlczogc3RyaW5nW10gPSBbXG4gICAgcmVxdWlyZShcIi4uL2ltYWdlcy8xLnBuZ1wiKSxcbiAgICByZXF1aXJlKFwiLi4vaW1hZ2VzLzIucG5nXCIpLFxuICAgIHJlcXVpcmUoXCIuLi9pbWFnZXMvMy5wbmdcIilcbiAgXTtcbiAgQG9ic2VydmFibGUgaW1hZ2U6IHN0cmluZyA9IHRoaXMuaW1hZ2VzWzBdO1xuICBAb2JzZXJ2YWJsZSBwcmV2aWV3OiBib29sZWFuID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5yYW5kb21pemUoKTtcbiAgfVxuXG4gIEBhY3Rpb25cbiAgcmFuZG9taXplKCkge1xuICAgIHRoaXMucGllY2VzID0gc2h1ZmZsZSh0aGlzLnBpZWNlcyk7XG4gICAgdGhpcy5jdXJyZW50ID0gdGhpcy5waWVjZXMuaW5kZXhPZihudWxsKTtcbiAgfVxuXG4gIEBhY3Rpb25cbiAgc2VsZWN0KGluZGV4OiBudW1iZXIpIHtcbiAgICBpZiAoIXRoaXMuaXNUb3VjaGluZyhpbmRleCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5waWVjZXNbdGhpcy5jdXJyZW50XSA9IHRoaXMucGllY2VzW2luZGV4XTtcbiAgICB0aGlzLnBpZWNlc1tpbmRleF0gPSBudWxsO1xuICAgIHRoaXMuY3VycmVudCA9IGluZGV4O1xuXG4gICAgaWYgKHRoaXMuZ2V0SGFzaCgpID09IHRoaXMuc29sdmVkKSB7XG4gICAgICB3aW5kb3cuYWxlcnQoXCJDT05HUkFUVUxBVElPTlMhIVwiKTtcbiAgICB9XG4gIH1cblxuICBAYWN0aW9uXG4gIGNoYW5nZUltYWdlKGltYWdlKSB7XG4gICAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICAgIHRoaXMucmFuZG9taXplKCk7XG4gIH1cblxuICBAYWN0aW9uXG4gIHN0YXJ0UHJldmlldygpIHtcbiAgICB0aGlzLnByZXZpZXcgPSB0cnVlO1xuICB9XG5cbiAgQGFjdGlvblxuICBlbmRQcmV2aWV3KCkge1xuICAgIHRoaXMucHJldmlldyA9IGZhbHNlO1xuICB9XG5cbiAgZ2V0SGFzaCgpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5waWVjZXMpO1xuICB9XG5cbiAgaXNBY3RpdmUoaW5kZXg6IG51bWJlcikge1xuICAgIHJldHVybiBpbmRleCA9PSB0aGlzLmN1cnJlbnQ7XG4gIH1cblxuICAvLyBmaW5kIGlmIHRoZSBzcXVhcmUgaXMgYSBkaXN0YW5jZSBvZiAxIGZyb20gdGhlIGN1cnJlbnRseSBhY3RpdmUgaW5kZXhcbiAgaXNUb3VjaGluZyhpbmRleDogbnVtYmVyKSB7XG4gICAgY29uc3QgZHggPSBNYXRoLmFicyhNYXRoLmFicyh0aGlzLmN1cnJlbnQgJSAzKSAtIE1hdGguYWJzKGluZGV4ICUgMykpO1xuICAgIGNvbnN0IGR5ID0gTWF0aC5hYnMoTWF0aC5mbG9vcih0aGlzLmN1cnJlbnQgLyAzKSAtIE1hdGguZmxvb3IoaW5kZXggLyAzKSk7XG4gICAgcmV0dXJuIGR4ICsgZHkgPT0gMTtcbiAgfVxufVxuIiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBvYnNlcnZhYmxlLCBhY3Rpb24gfSBmcm9tIFwibW9ieFwiO1xuaW1wb3J0IHsgc2h1ZmZsZSB9IGZyb20gXCIuLi9jb3JlL3V0aWxzXCI7XG5pbXBvcnQgeyBvYnNlcnZlciB9IGZyb20gXCJtb2J4LXJlYWN0XCI7XG5pbXBvcnQgUGllY2UgZnJvbSBcIi4vUGllY2VcIjtcbmltcG9ydCB7IHN0eWxlIH0gZnJvbSBcInR5cGVzdHlsZVwiO1xuaW1wb3J0IFB1enpsZU1vZGVsIGZyb20gXCIuL1B1enplbE1vZGVsXCI7XG5pbXBvcnQgRmxpcE1vdmUgZnJvbSBcInJlYWN0LWZsaXAtbW92ZVwiO1xuXG5Ab2JzZXJ2ZXJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFB1enpsZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDx7fSwge30+IHtcbiAgbW9kZWw6IFB1enpsZU1vZGVsID0gbmV3IFB1enpsZU1vZGVsKCk7XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBwaWVjZXMgPSB0aGlzLm1vZGVsLnByZXZpZXcgPyB0aGlzLm1vZGVsLm9yaWdpbmFsIDogdGhpcy5tb2RlbC5waWVjZXM7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtwdXp6bGVTdHlsZX0+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicGllY2VzXCI+XG4gICAgICAgICAgPEZsaXBNb3ZlIGR1cmF0aW9uPXsyMDB9IGVhc2luZz1cImVhc2Utb3V0XCI+XG4gICAgICAgICAgICB7cGllY2VzLm1hcCgobnVtYmVyLCBpeCkgPT4gKFxuICAgICAgICAgICAgICA8UGllY2VcbiAgICAgICAgICAgICAgICBrZXk9e251bWJlcn1cbiAgICAgICAgICAgICAgICBpbmRleD17aXh9XG4gICAgICAgICAgICAgICAgbnVtYmVyPXtudW1iZXJ9XG4gICAgICAgICAgICAgICAgcHV6emVsTW9kZWw9e3RoaXMubW9kZWx9XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICApKX1cbiAgICAgICAgICA8L0ZsaXBNb3ZlPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiB0aGlzLm1vZGVsLnJhbmRvbWl6ZSgpfT5SYW5kb21pemUhPC9idXR0b24+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICBvbk1vdXNlRG93bj17KCkgPT4gdGhpcy5tb2RlbC5zdGFydFByZXZpZXcoKX1cbiAgICAgICAgICBvbk1vdXNlVXA9eygpID0+IHRoaXMubW9kZWwuZW5kUHJldmlldygpfVxuICAgICAgICA+XG4gICAgICAgICAgUHJldmlld1xuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPGRpdj5cbiAgICAgICAgICB7dGhpcy5tb2RlbC5pbWFnZXMubWFwKGltYWdlID0+IChcbiAgICAgICAgICAgIDxpbWdcbiAgICAgICAgICAgICAgc3JjPXtpbWFnZX1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidGh1bWJcIlxuICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiB0aGlzLm1vZGVsLmNoYW5nZUltYWdlKGltYWdlKX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKSl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuXG5jb25zdCBwdXp6bGVTdHlsZSA9IHN0eWxlKHtcbiAgYmFja2dyb3VuZDogXCJ3aGl0ZVwiLFxuICBwYWRkaW5nOiAxMCxcbiAgd2lkdGg6IDMwMCxcbiAgbGluZUhlaWdodDogMCxcbiAgJG5lc3Q6IHtcbiAgICBcIi50aHVtYlwiOiB7XG4gICAgICB3aWR0aDogNTAsXG4gICAgICBoZWlnaHQ6IDUwLFxuICAgICAgbWFyZ2luOiBcIjEwcHggMTBweCAwIDBcIlxuICAgIH0sXG4gICAgYnV0dG9uOiB7XG4gICAgICBtYXJnaW46IFwiMTBweCA1cHggMCAwXCJcbiAgICB9XG4gIH1cbn0pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==